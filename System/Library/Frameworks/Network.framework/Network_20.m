uint64_t nw_http2_get_stream_from_protocol(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  int v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  const char *v10;
  int v11;
  int v12;
  char *v13;
  _BOOL4 v14;
  int v15;
  char *v16;
  _BOOL4 v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  const char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *backtrace_string;
  _BOOL4 v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_http2_get_stream_from_protocol";
    v24 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v24, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_http2_get_stream_from_protocol";
          v27 = "%{public}s called with null http2";
LABEL_68:
          _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
        }
      }
      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "nw_http2_get_stream_from_protocol";
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_69;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_http2_get_stream_from_protocol";
          v27 = "%{public}s called with null http2, no backtrace";
          goto LABEL_68;
        }
      }
      else
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_http2_get_stream_from_protocol";
          v27 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_68;
        }
      }
    }
LABEL_69:
    if (!v24)
      return 0;
    v23 = (char *)v24;
    goto LABEL_52;
  }
  v3 = *(_QWORD *)(a2 + 56);
  if (v3)
  {
    result = *(_QWORD *)(v3 + 32);
    if (result)
      return result;
    if (*(__int16 *)(a1 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v5 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    v33 = "nw_http2_get_stream_from_protocol";
    v34 = 2082;
    v35 = (char *)(a1 + 378);
    v36 = 2080;
    v37 = " ";
    v38 = 1024;
    v39 = v5;
    v6 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v6, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v7 = gconnectionLogObj;
        v8 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v9 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          v33 = "nw_http2_get_stream_from_protocol";
          v34 = 2082;
          v35 = (char *)(a1 + 378);
          v36 = 2080;
          v37 = " ";
          v38 = 1024;
          v39 = v9;
          v10 = "%{public}s %{public}s%s<i%u> stream not found";
LABEL_49:
          _os_log_impl(&dword_182FBE000, v7, v8, v10, buf, 0x26u);
        }
      }
      else if (v30)
      {
        v16 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v7 = gconnectionLogObj;
        v8 = type;
        v17 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (!v16)
        {
          if (!v17)
            goto LABEL_50;
          v22 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          v33 = "nw_http2_get_stream_from_protocol";
          v34 = 2082;
          v35 = (char *)(a1 + 378);
          v36 = 2080;
          v37 = " ";
          v38 = 1024;
          v39 = v22;
          v10 = "%{public}s %{public}s%s<i%u> stream not found, no backtrace";
          goto LABEL_49;
        }
        if (v17)
        {
          v18 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          v33 = "nw_http2_get_stream_from_protocol";
          v34 = 2082;
          v35 = (char *)(a1 + 378);
          v36 = 2080;
          v37 = " ";
          v38 = 1024;
          v39 = v18;
          v40 = 2082;
          v41 = v16;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s %{public}s%s<i%u> stream not found, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v16);
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v7 = gconnectionLogObj;
        v8 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v21 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          v33 = "nw_http2_get_stream_from_protocol";
          v34 = 2082;
          v35 = (char *)(a1 + 378);
          v36 = 2080;
          v37 = " ";
          v38 = 1024;
          v39 = v21;
          v10 = "%{public}s %{public}s%s<i%u> stream not found, backtrace limit exceeded";
          goto LABEL_49;
        }
      }
    }
  }
  else
  {
    if (*(__int16 *)(a1 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v11 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    v33 = "nw_http2_get_stream_from_protocol";
    v34 = 2082;
    v35 = (char *)(a1 + 378);
    v36 = 2080;
    v37 = " ";
    v38 = 1024;
    v39 = v11;
    v6 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v6, &type, &v30))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v7 = gconnectionLogObj;
      v8 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v12 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        v33 = "nw_http2_get_stream_from_protocol";
        v34 = 2082;
        v35 = (char *)(a1 + 378);
        v36 = 2080;
        v37 = " ";
        v38 = 1024;
        v39 = v12;
        v10 = "%{public}s %{public}s%s<i%u> node not found";
        goto LABEL_49;
      }
    }
    else
    {
      if (v30)
      {
        v13 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v7 = gconnectionLogObj;
        v8 = type;
        v14 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v13)
        {
          if (v14)
          {
            v15 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136447234;
            v33 = "nw_http2_get_stream_from_protocol";
            v34 = 2082;
            v35 = (char *)(a1 + 378);
            v36 = 2080;
            v37 = " ";
            v38 = 1024;
            v39 = v15;
            v40 = 2082;
            v41 = v13;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s %{public}s%s<i%u> node not found, dumping backtrace:%{public}s", buf, 0x30u);
          }
          free(v13);
          if (!v6)
            return 0;
          goto LABEL_51;
        }
        if (!v14)
          goto LABEL_50;
        v20 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        v33 = "nw_http2_get_stream_from_protocol";
        v34 = 2082;
        v35 = (char *)(a1 + 378);
        v36 = 2080;
        v37 = " ";
        v38 = 1024;
        v39 = v20;
        v10 = "%{public}s %{public}s%s<i%u> node not found, no backtrace";
        goto LABEL_49;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v7 = gconnectionLogObj;
      v8 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v19 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        v33 = "nw_http2_get_stream_from_protocol";
        v34 = 2082;
        v35 = (char *)(a1 + 378);
        v36 = 2080;
        v37 = " ";
        v38 = 1024;
        v39 = v19;
        v10 = "%{public}s %{public}s%s<i%u> node not found, backtrace limit exceeded";
        goto LABEL_49;
      }
    }
  }
LABEL_50:
  if (v6)
  {
LABEL_51:
    v23 = (char *)v6;
LABEL_52:
    free(v23);
  }
  return 0;
}

void nw_http2_protocol_close(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  unsigned int v13;
  uint64_t v14;
  void (*v15)(uint64_t, uint64_t);
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  const char *v25;
  NSObject *v26;
  const char *v27;
  int v28;
  const char *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  NSObject *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  void (*v40)(uint64_t, uint64_t);
  char *v41;
  _BOOL4 v42;
  const char *v43;
  NSObject *v44;
  int v45;
  int v46;
  char *backtrace_string;
  _BOOL4 v48;
  char *v49;
  _BOOL4 v50;
  const char *v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  const char *v56;
  const char *v57;
  uint64_t v58;
  int v59;
  int v60;
  char *v61;
  _BOOL4 v62;
  const char *v63;
  const char *v64;
  const char *v65;
  const char *v66;
  NSObject *v67;
  int v68;
  char v69;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  void *v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  int v78;
  __int16 v79;
  _QWORD v80[5];

  v80[4] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v34 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v36 = *(_DWORD *)(a2 + 176);
        v35 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447234;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)(a2 + 191);
        v75 = 2080;
        v76 = " ";
        v77 = 1024;
        v78 = v35;
        v79 = 1024;
        LODWORD(v80[0]) = v36;
        _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", buf, 0x2Cu);
      }
    }
    goto LABEL_4;
  }
  if (a1 && *(__int16 *)(a1 + 376) < 0)
  {
LABEL_47:
    if (a3)
      goto LABEL_15;
    goto LABEL_48;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v26 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v27 = " ";
      v28 = *(_DWORD *)(a1 + 368);
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v29 = (const char *)(a1 + 378);
      *(_DWORD *)buf = 136446978;
      if (!a1)
        v29 = "";
      v74 = (void *)v29;
      if (!a1)
        v27 = "";
      v75 = 2080;
      v76 = v27;
      v77 = 1024;
      v78 = v28;
      _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      goto LABEL_47;
    }
  }
LABEL_4:
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_http2_protocol_close";
    v30 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (!__nwlog_fault(v30, &type, &v69))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null http2";
      goto LABEL_130;
    }
    if (!v69)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_130;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v31 = __nwlog_obj();
    v32 = type;
    v48 = os_log_type_enabled(v31, type);
    if (!backtrace_string)
    {
      if (!v48)
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null http2, no backtrace";
      goto LABEL_130;
    }
    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
    goto LABEL_131;
  }
  if (!a3)
  {
LABEL_48:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_http2_protocol_close";
    v30 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (!__nwlog_fault(v30, &type, &v69))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null input_protocol";
      goto LABEL_130;
    }
    if (!v69)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_130;
    }
    v49 = (char *)__nw_create_backtrace_string();
    v31 = __nwlog_obj();
    v32 = type;
    v50 = os_log_type_enabled(v31, type);
    if (v49)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = v49;
        _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v49);
      if (!v30)
        return;
LABEL_132:
      free(v30);
      return;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446210;
      v72 = "nw_http2_protocol_close";
      v33 = "%{public}s called with null input_protocol, no backtrace";
LABEL_130:
      _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0xCu);
    }
LABEL_131:
    if (!v30)
      return;
    goto LABEL_132;
  }
  if (a2)
  {
    v6 = *(unsigned __int16 *)(a2 + 188);
    if ((v6 & 4) == 0)
    {
      if (((v6 | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v7 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v9 = *(_DWORD *)(a2 + 176);
          v8 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447234;
          v72 = "nw_http2_protocol_close";
          v73 = 2082;
          v74 = (void *)(a2 + 191);
          v75 = 2080;
          v76 = " ";
          v77 = 1024;
          v78 = v8;
          v79 = 1024;
          LODWORD(v80[0]) = v9;
          v10 = "%{public}s %{public}s%s<i%u:s%d> protocol already closed, skipping callbacks";
          v11 = v7;
          v12 = 44;
LABEL_111:
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, v10, buf, v12);
          return;
        }
      }
      return;
    }
    v13 = v6 & 0xFFFFFFFB | (*(unsigned __int8 *)(a2 + 190) << 16);
    *(_WORD *)(a2 + 188) = v6 & 0xFFFB;
    *(_BYTE *)(a2 + 190) = BYTE2(v13);
  }
LABEL_15:
  v14 = *(_QWORD *)(a3 + 24);
  if (v14)
  {
    v15 = *(void (**)(uint64_t, uint64_t))(v14 + 184);
    if (v15)
    {
      v15(a3, a1);
      goto LABEL_18;
    }
  }
  __nwlog_obj();
  v20 = *(const char **)(a3 + 16);
  if (!v20)
    v20 = "invalid";
  *(_DWORD *)buf = 136446466;
  v72 = "nw_http2_protocol_close";
  v73 = 2082;
  v74 = (void *)v20;
  v21 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v69 = 0;
  if (__nwlog_fault(v21, &type, &v69))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_124;
      v24 = *(const char **)(a3 + 16);
      if (!v24)
        v24 = "invalid";
      *(_DWORD *)buf = 136446466;
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)v24;
      v25 = "%{public}s protocol %{public}s has invalid input_finished callback";
      goto LABEL_123;
    }
    if (!v69)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_124;
      v57 = *(const char **)(a3 + 16);
      if (!v57)
        v57 = "invalid";
      *(_DWORD *)buf = 136446466;
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)v57;
      v25 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      goto LABEL_123;
    }
    v41 = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v42 = os_log_type_enabled(v22, type);
    if (v41)
    {
      if (v42)
      {
        v43 = *(const char **)(a3 + 16);
        if (!v43)
          v43 = "invalid";
        *(_DWORD *)buf = 136446722;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)v43;
        v75 = 2082;
        v76 = v41;
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v41);
      goto LABEL_124;
    }
    if (v42)
    {
      v64 = *(const char **)(a3 + 16);
      if (!v64)
        v64 = "invalid";
      *(_DWORD *)buf = 136446466;
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)v64;
      v25 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
LABEL_123:
      _os_log_impl(&dword_182FBE000, v22, v23, v25, buf, 0x16u);
    }
  }
LABEL_124:
  if (v21)
    free(v21);
LABEL_18:
  if (!a2)
  {
    if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v67 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v68 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)(a1 + 378);
        v75 = 2080;
        v76 = " ";
        v77 = 1024;
        v78 = v68;
        v79 = 2048;
        v80[0] = a3;
        _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> sent input_finished to protocol %p", buf, 0x30u);
      }
    }
LABEL_62:
    v37 = *(unsigned __int16 *)(a2 + 188);
    v38 = v37 | (*(unsigned __int8 *)(a2 + 190) << 16);
    if ((v37 & 0x40) != 0)
      return;
    *(_BYTE *)(a2 + 190) = BYTE2(v38);
    *(_WORD *)(a2 + 188) = v38 | 0x40;
    v39 = *(_QWORD *)(a3 + 24);
    if (v39)
    {
      v40 = *(void (**)(uint64_t, uint64_t))(v39 + 48);
      if (v40)
      {
        v40(a3, a1);
        goto LABEL_66;
      }
    }
    __nwlog_obj();
    v51 = *(const char **)(a3 + 16);
    if (!v51)
      v51 = "invalid";
    *(_DWORD *)buf = 136446466;
    v72 = "nw_http2_protocol_close";
    v73 = 2082;
    v74 = (void *)v51;
    v52 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v52, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v53 = __nwlog_obj();
        v54 = type;
        if (!os_log_type_enabled(v53, type))
          goto LABEL_142;
        v55 = *(const char **)(a3 + 16);
        if (!v55)
          v55 = "invalid";
        *(_DWORD *)buf = 136446466;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)v55;
        v56 = "%{public}s protocol %{public}s has invalid disconnected callback";
        goto LABEL_141;
      }
      if (!v69)
      {
        v53 = __nwlog_obj();
        v54 = type;
        if (!os_log_type_enabled(v53, type))
          goto LABEL_142;
        v65 = *(const char **)(a3 + 16);
        if (!v65)
          v65 = "invalid";
        *(_DWORD *)buf = 136446466;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)v65;
        v56 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_141;
      }
      v61 = (char *)__nw_create_backtrace_string();
      v53 = __nwlog_obj();
      v54 = type;
      v62 = os_log_type_enabled(v53, type);
      if (v61)
      {
        if (v62)
        {
          v63 = *(const char **)(a3 + 16);
          if (!v63)
            v63 = "invalid";
          *(_DWORD *)buf = 136446722;
          v72 = "nw_http2_protocol_close";
          v73 = 2082;
          v74 = (void *)v63;
          v75 = 2082;
          v76 = v61;
          _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v61);
        goto LABEL_142;
      }
      if (v62)
      {
        v66 = *(const char **)(a3 + 16);
        if (!v66)
          v66 = "invalid";
        *(_DWORD *)buf = 136446466;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)v66;
        v56 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
LABEL_141:
        _os_log_impl(&dword_182FBE000, v53, v54, v56, buf, 0x16u);
      }
    }
LABEL_142:
    if (v52)
      free(v52);
LABEL_66:
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v58 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v60 = *(_DWORD *)(a2 + 176);
        v59 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)(a2 + 191);
        v75 = 2080;
        v76 = " ";
        v77 = 1024;
        v78 = v59;
        v79 = 1024;
        LODWORD(v80[0]) = v60;
        WORD2(v80[0]) = 2048;
        *(_QWORD *)((char *)v80 + 6) = a3;
        v10 = "%{public}s %{public}s%s<i%u:s%d> sent disconnected to protocol %p";
        v11 = v58;
        v12 = 54;
        goto LABEL_111;
      }
    }
    return;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v44 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v46 = *(_DWORD *)(a2 + 176);
      v45 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)(a2 + 191);
      v75 = 2080;
      v76 = " ";
      v77 = 1024;
      v78 = v45;
      v79 = 1024;
      LODWORD(v80[0]) = v46;
      WORD2(v80[0]) = 2048;
      *(_QWORD *)((char *)v80 + 6) = a3;
      _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> sent input_finished to protocol %p", buf, 0x36u);
    }
  }
  v16 = *(unsigned __int16 *)(a2 + 188);
  if ((~v16 & 0x5000) != 0)
    goto LABEL_62;
  if (((v16 | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v17 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v19 = *(_DWORD *)(a2 + 176);
      v18 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447746;
      v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)(a2 + 191);
      v75 = 2080;
      v76 = " ";
      v77 = 1024;
      v78 = v18;
      v79 = 1024;
      LODWORD(v80[0]) = v19;
      WORD2(v80[0]) = 1024;
      *(_DWORD *)((char *)v80 + 6) = v19;
      WORD1(v80[1]) = 2048;
      *(_QWORD *)((char *)&v80[1] + 4) = a3;
      v10 = "%{public}s %{public}s%s<i%u:s%d> skipping disconnected for stream %d, protocol %p because stream is already "
            "gracefully closed";
      v11 = v17;
      v12 = 60;
      goto LABEL_111;
    }
  }
}

void nw_http2_stream_destroy(void **a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  char v5;
  _QWORD *v6;
  _QWORD *v7;
  char v8;
  void *v9;
  void *v10;
  void *v11;
  __int16 v12;
  void *v13;
  void *v14;
  void *v15;
  NSObject *v16;
  NSObject *v17;
  __int128 v18;
  uint64_t (*v19)(__int128 *);
  void *v20;
  void **v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (((*((unsigned __int16 *)a1 + 94) | (*((unsigned __int8 *)a1 + 190) << 16)) & 0x100000) != 0)
    nw_http_transaction_metadata_set_event_handler(a1[12], 0);
  if (gLogDatapath)
  {
    v16 = __nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v18) = 136446210;
      *(_QWORD *)((char *)&v18 + 4) = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v18, 0xCu);
    }
  }
  v2 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v18 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v18 + 1) = 0x40000000;
  v19 = (uint64_t (*)(__int128 *))___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_81659;
  v20 = &__block_descriptor_tmp_30_81660;
  v21 = a1;
  v22 = 0;
  v3 = *a1;
  do
  {
    if (!v3)
      break;
    v4 = (_QWORD *)v3[4];
    v5 = v19(&v18);
    v3 = v4;
  }
  while ((v5 & 1) != 0);
  if (gLogDatapath)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v18) = 136446210;
      *(_QWORD *)((char *)&v18 + 4) = "nw_protocol_release_master_frame_array";
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v18, 0xCu);
    }
  }
  *(_QWORD *)&v18 = v2;
  *((_QWORD *)&v18 + 1) = 0x40000000;
  v19 = (uint64_t (*)(__int128 *))___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke;
  v20 = &__block_descriptor_tmp_31_81662;
  v21 = a1 + 2;
  v6 = a1[2];
  do
  {
    if (!v6)
      break;
    v7 = (_QWORD *)v6[2];
    v8 = v19(&v18);
    v6 = v7;
  }
  while ((v8 & 1) != 0);
  v9 = a1[12];
  if (v9)
  {
    os_release(v9);
    a1[12] = 0;
  }
  v10 = a1[13];
  if (v10)
  {
    os_release(v10);
    a1[13] = 0;
  }
  v11 = a1[14];
  if (v11)
  {
    os_release(v11);
    a1[14] = 0;
  }
  v12 = *((_WORD *)a1 + 94);
  *((_DWORD *)a1 + 44) = -1;
  *((_WORD *)a1 + 94) = v12 & 0xEF66;
  if (((_BYTE)a1[21] & 1) != 0)
  {
    v13 = a1[20];
    if (v13)
      os_release(v13);
  }
  a1[20] = 0;
  if (((_BYTE)a1[19] & 1) != 0)
  {
    v14 = a1[18];
    if (v14)
      os_release(v14);
  }
  a1[18] = 0;
  v15 = a1[15];
  if (v15)
  {
    a1[16] = v15;
    operator delete(v15);
  }
  free(a1);
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_81659(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke(uint64_t a1, _QWORD *object)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = object[2];
  v3 = (_QWORD *)object[3];
  if (v2)
  {
    *(_QWORD *)(v2 + 24) = v3;
    v3 = (_QWORD *)object[3];
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  object[2] = 0;
  object[3] = 0;
  os_release(object);
  return 1;
}

uint64_t nw_http2_get_stream_node_from_id(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v4;
  int v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  uint64_t v10;
  int v11;
  int v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v12 = a2;
  if (a2 <= 0)
  {
    if (*(__int16 *)(a1 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v10 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      return 0;
    v11 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447234;
    v14 = "nw_http2_get_stream_node_from_id";
    v15 = 2082;
    v16 = a1 + 378;
    v17 = 2080;
    v18 = " ";
    v19 = 1024;
    v20 = v11;
    v21 = 1024;
    v22 = a2;
    v6 = "%{public}s %{public}s%s<i%u> requested stream id (%d) is not valid, returning NULL hash node";
    v7 = v10;
    v8 = OS_LOG_TYPE_ERROR;
    goto LABEL_14;
  }
  result = *(_QWORD *)(a1 + 160);
  if (result)
  {
    result = nw_hash_table_get_node(result, (uint64_t)&v12, 4);
    if (!result)
    {
      if (*(__int16 *)(a1 + 376) < 0)
        return 0;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        return 0;
      v5 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      v14 = "nw_http2_get_stream_node_from_id";
      v15 = 2082;
      v16 = a1 + 378;
      v17 = 2080;
      v18 = " ";
      v19 = 1024;
      v20 = v5;
      v21 = 1024;
      v22 = v12;
      v6 = "%{public}s %{public}s%s<i%u> requested stream id (%d) not found, returning NULL";
      v7 = v4;
      v8 = OS_LOG_TYPE_DEBUG;
LABEL_14:
      _os_log_impl(&dword_182FBE000, v7, v8, v6, buf, 0x2Cu);
      return 0;
    }
  }
  return result;
}

uint64_t ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke_81728(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  size_t v15;
  BOOL v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  size_t v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *v29;
  _BOOL4 v30;
  char *v31;
  _BOOL4 v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  size_t v36;
  uint64_t v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  size_t v47;
  uint64_t v48;
  char *v49;
  NSObject *v50;
  os_log_type_t v51;
  const char *v52;
  char *v53;
  _BOOL4 v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  size_t v58;
  uint64_t v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  char *v64;
  _BOOL4 v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  size_t v69;
  uint64_t v70;
  char *v71;
  NSObject *v72;
  os_log_type_t v73;
  const char *v74;
  char *v75;
  _BOOL4 v76;
  uint64_t v77;
  NSObject *v78;
  const void *v79;
  size_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  unsigned int v84;
  size_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  const char *v90;
  BOOL v91;
  int v92;
  const char *v93;
  char *v94;
  NSObject *v95;
  os_log_type_t v96;
  uint64_t v97;
  const char *v98;
  BOOL v99;
  int v100;
  const char *v101;
  const char *v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  NSObject *v108;
  os_log_type_t v109;
  const char *v110;
  char *v111;
  _BOOL4 v112;
  uint64_t v113;
  const char *v114;
  const char *v115;
  uint64_t v116;
  const char *v117;
  BOOL v118;
  int v119;
  const char *v120;
  uint64_t v121;
  const char *v122;
  BOOL v123;
  int v124;
  const char *v125;
  char *v126;
  _BOOL4 v127;
  uint64_t v128;
  NSObject *v129;
  const void *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  _QWORD *v134;
  uint64_t v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t *v138;
  uint64_t v139;
  uint64_t result;
  uint64_t v141;
  uint64_t v142;
  const char *v143;
  BOOL v144;
  int v145;
  const char *v146;
  uint64_t v147;
  BOOL v148;
  uint64_t v149;
  unsigned int v150;
  uint64_t v151;
  uint64_t v152;
  char *v153;
  NSObject *v154;
  os_log_type_t v155;
  const char *v156;
  _BOOL4 v157;
  int v158;
  uint64_t v159;
  BOOL v160;
  uint64_t v161;
  BOOL v162;
  char *backtrace_string;
  _BOOL4 v164;
  NSObject *v165;
  uint64_t v166;
  const char *v167;
  BOOL v168;
  int v169;
  const char *v170;
  uint64_t v171;
  NSObject *v172;
  uint64_t v173;
  const char *v174;
  BOOL v175;
  int v176;
  const char *v177;
  uint64_t v178;
  NSObject *v179;
  uint64_t v180;
  const char *v181;
  const char *v182;
  BOOL v183;
  int v184;
  NSObject *v185;
  uint64_t v186;
  const char *v187;
  BOOL v188;
  int v189;
  const char *v190;
  NSObject *v191;
  uint64_t v192;
  const char *v193;
  BOOL v194;
  int v195;
  const char *v196;
  NSObject *v197;
  uint64_t v198;
  const char *v199;
  BOOL v200;
  int v201;
  const char *v202;
  NSObject *v203;
  uint64_t v204;
  const char *v205;
  BOOL v206;
  int v207;
  const char *v208;
  NSObject *v209;
  uint64_t v210;
  const char *v211;
  BOOL v212;
  int v213;
  const char *v214;
  NSObject *v215;
  uint64_t v216;
  const char *v217;
  BOOL v218;
  int v219;
  const char *v220;
  NSObject *v221;
  uint64_t v222;
  const char *v223;
  BOOL v224;
  int v225;
  const char *v226;
  NSObject *v227;
  uint64_t v228;
  const char *v229;
  BOOL v230;
  int v231;
  const char *v232;
  NSObject *v233;
  uint64_t v234;
  const char *v235;
  BOOL v236;
  int v237;
  const char *v238;
  NSObject *v239;
  uint64_t v240;
  const char *v241;
  BOOL v242;
  int v243;
  const char *v244;
  NSObject *v245;
  uint64_t v246;
  const char *v247;
  BOOL v248;
  int v249;
  const char *v250;
  char v251;
  os_log_type_t type[4];
  os_log_type_t v253;
  unsigned int v254;
  uint8_t buf[4];
  const char *v256;
  __int16 v257;
  const char *v258;
  __int16 v259;
  size_t v260;
  __int16 v261;
  _BYTE v262[18];
  uint64_t v263;

  v263 = *MEMORY[0x1E0C80C00];
  v254 = 0;
  v4 = (_BYTE *)nw_frame_unclaimed_bytes(a2, &v254);
  v6 = v4;
  v7 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v7 > 8)
  {
    LODWORD(v8) = 0;
  }
  else
  {
    if (!v254)
    {
      LODWORD(v8) = 0;
      goto LABEL_278;
    }
    if (9 - (int)v7 >= v254)
      v8 = v254;
    else
      v8 = (9 - v7);
    memcpy(v4, (const void *)(*(_QWORD *)(a1 + 96) + v7), v8);
    v9 = *(_QWORD *)(a1 + 104);
    if ((!v9 || (*(__int16 *)(v9 + 376) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v172 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v173 = *(_QWORD *)(a1 + 104);
        v174 = "";
        v175 = v173 == 0;
        v176 = *(_DWORD *)(v173 + 368);
        v177 = (const char *)(v173 + 378);
        v256 = "send_data_callback_block_invoke";
        v257 = 2082;
        if (v175)
          v177 = "";
        *(_DWORD *)buf = 136447234;
        if (!v175)
          v174 = " ";
        v258 = v177;
        v259 = 2080;
        v260 = (size_t)v174;
        v261 = 1024;
        *(_DWORD *)v262 = v176;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = v8;
        _os_log_impl(&dword_182FBE000, v172, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of frame header", buf, 0x2Cu);
      }
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v8;
    LODWORD(v7) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 112) + 16);
  if (!v10)
  {
    if (v7 >= *(_DWORD *)(a1 + 200) || v254 <= v8)
      goto LABEL_278;
    if (*(_DWORD *)(a1 + 120) - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) >= v254 - v8)
      LODWORD(v21) = v254 - v8;
    else
      LODWORD(v21) = *(_DWORD *)(a1 + 120) - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    if (!*(_QWORD *)(a1 + 128))
      goto LABEL_269;
    v22 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v23 = *(unsigned __int8 *)(a1 + 204) - (_DWORD)v22;
    if (v23 >= v21)
      v24 = v21;
    else
      v24 = v23;
    if (!(_DWORD)v24)
    {
LABEL_99:
      v45 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
      v46 = *(unsigned __int8 *)(a1 + 205) - (_DWORD)v45;
      if (v46 >= v21)
        v47 = v21;
      else
        v47 = v46;
      if (!(_DWORD)v47)
        goto LABEL_150;
      memcpy(&v6[v8], (const void *)(a1 + v45 + 144), v47);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v47;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v47;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) += v47;
      v16 = v21 >= v47;
      v48 = (v21 - v47);
      LODWORD(v21) = v21 - v47;
      if (v16)
      {
LABEL_146:
        LODWORD(v8) = v47 + v8;
        v66 = *(_QWORD *)(a1 + 104);
        if ((!v66 || (*(__int16 *)(v66 + 376) & 0x80000000) == 0) && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v221 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v222 = *(_QWORD *)(a1 + 104);
            v223 = "";
            v224 = v222 == 0;
            v225 = *(_DWORD *)(v222 + 368);
            v226 = (const char *)(v222 + 378);
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            if (v224)
              v226 = "";
            *(_DWORD *)buf = 136447234;
            if (!v224)
              v223 = " ";
            v258 = v226;
            v259 = 2080;
            v260 = (size_t)v223;
            v261 = 1024;
            *(_DWORD *)v262 = v225;
            *(_WORD *)&v262[4] = 1024;
            *(_DWORD *)&v262[6] = v47;
            _os_log_impl(&dword_182FBE000, v221, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule length", buf, 0x2Cu);
          }
        }
        if (v254 <= v8)
          goto LABEL_278;
LABEL_150:
        if (!*(_BYTE *)(a1 + 206))
          goto LABEL_267;
        v67 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
        v68 = *(unsigned __int8 *)(a1 + 207) - (_DWORD)v67;
        v69 = v68 >= v21 ? v21 : v68;
        if (!(_DWORD)v69)
          goto LABEL_267;
        memcpy(&v6[v8], (const void *)(a1 + v67 + 152), v69);
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v69;
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v69;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) += v69;
        v16 = v21 >= v69;
        v70 = (v21 - v69);
        LODWORD(v21) = v21 - v69;
        if (v16)
        {
LABEL_263:
          LODWORD(v8) = v69 + v8;
          v128 = *(_QWORD *)(a1 + 104);
          if ((!v128 || (*(__int16 *)(v128 + 376) & 0x80000000) == 0) && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v233 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v234 = *(_QWORD *)(a1 + 104);
              v235 = "";
              v236 = v234 == 0;
              v237 = *(_DWORD *)(v234 + 368);
              v238 = (const char *)(v234 + 378);
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              if (v236)
                v238 = "";
              *(_DWORD *)buf = 136447234;
              if (!v236)
                v235 = " ";
              v258 = v238;
              v259 = 2080;
              v260 = (size_t)v235;
              v261 = 1024;
              *(_DWORD *)v262 = v237;
              *(_WORD *)&v262[4] = 1024;
              *(_DWORD *)&v262[6] = v69;
              _os_log_impl(&dword_182FBE000, v233, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of datagram context", buf, 0x2Cu);
            }
          }
          if (v254 <= v8)
            goto LABEL_278;
LABEL_267:
          v129 = *(NSObject **)(a1 + 160);
          if (!v129 || *(_BYTE *)(a1 + 208))
            goto LABEL_269;
          v149 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24);
          v150 = *(_DWORD *)(a1 + 168) - v149;
          v151 = v150 >= v21 ? v21 : v150;
          if (!(_DWORD)v151)
            goto LABEL_269;
          nw_dispatch_data_copyout_from_offset(v129, (uint64_t)&v6[v8], v151, v149);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v151;
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v151;
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) += v151;
          v16 = v21 >= v151;
          v152 = (v21 - v151);
          LODWORD(v21) = v21 - v151;
          if (v16)
            goto LABEL_388;
          __nwlog_obj();
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v151;
          v261 = 2048;
          *(_QWORD *)v262 = v152;
          v153 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v253 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v153, type, &v253))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v154 = __nwlog_obj();
              v155 = type[0];
              if (os_log_type_enabled(v154, type[0]))
              {
                *(_DWORD *)buf = 136446978;
                v256 = "send_data_callback_block_invoke";
                v257 = 2082;
                v258 = "bodyCopySize";
                v259 = 2048;
                v260 = v151;
                v261 = 2048;
                *(_QWORD *)v262 = v152;
                v156 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_384:
                _os_log_impl(&dword_182FBE000, v154, v155, v156, buf, 0x2Au);
              }
            }
            else if (v253)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              v154 = __nwlog_obj();
              v155 = type[0];
              v164 = os_log_type_enabled(v154, type[0]);
              if (backtrace_string)
              {
                if (v164)
                {
                  *(_DWORD *)buf = 136447234;
                  v256 = "send_data_callback_block_invoke";
                  v257 = 2082;
                  v258 = "bodyCopySize";
                  v259 = 2048;
                  v260 = v151;
                  v261 = 2048;
                  *(_QWORD *)v262 = v152;
                  *(_WORD *)&v262[8] = 2082;
                  *(_QWORD *)&v262[10] = backtrace_string;
                  _os_log_impl(&dword_182FBE000, v154, v155, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(backtrace_string);
                goto LABEL_385;
              }
              if (v164)
              {
                *(_DWORD *)buf = 136446978;
                v256 = "send_data_callback_block_invoke";
                v257 = 2082;
                v258 = "bodyCopySize";
                v259 = 2048;
                v260 = v151;
                v261 = 2048;
                *(_QWORD *)v262 = v152;
                v156 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                goto LABEL_384;
              }
            }
            else
            {
              v154 = __nwlog_obj();
              v155 = type[0];
              if (os_log_type_enabled(v154, type[0]))
              {
                *(_DWORD *)buf = 136446978;
                v256 = "send_data_callback_block_invoke";
                v257 = 2082;
                v258 = "bodyCopySize";
                v259 = 2048;
                v260 = v151;
                v261 = 2048;
                *(_QWORD *)v262 = v152;
                v156 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_384;
              }
            }
          }
LABEL_385:
          if (v153)
            free(v153);
          LODWORD(v21) = 0;
LABEL_388:
          LODWORD(v8) = v151 + v8;
          v178 = *(_QWORD *)(a1 + 104);
          if ((!v178 || (*(__int16 *)(v178 + 376) & 0x80000000) == 0) && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v245 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v246 = *(_QWORD *)(a1 + 104);
              v247 = "";
              v248 = v246 == 0;
              v249 = *(_DWORD *)(v246 + 368);
              v250 = (const char *)(v246 + 378);
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              if (v248)
                v250 = "";
              *(_DWORD *)buf = 136447234;
              if (!v248)
                v247 = " ";
              v258 = v250;
              v259 = 2080;
              v260 = (size_t)v247;
              v261 = 1024;
              *(_DWORD *)v262 = v249;
              *(_WORD *)&v262[4] = 1024;
              *(_DWORD *)&v262[6] = v151;
              _os_log_impl(&dword_182FBE000, v245, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule body", buf, 0x2Cu);
            }
          }
          if (v254 <= v8)
            goto LABEL_278;
LABEL_269:
          *(_DWORD *)type = 0;
          v130 = (const void *)nw_frame_unclaimed_bytes(*(_QWORD *)(a1 + 176), type);
          if (v130)
          {
            if (v21 >= *(_DWORD *)type)
              v85 = *(unsigned int *)type;
            else
              v85 = v21;
            memcpy(&v6[v8], v130, v85);
            v132 = *(_QWORD *)(a1 + 104);
            if ((!v132 || (*(__int16 *)(v132 + 376) & 0x80000000) == 0) && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v209 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v210 = *(_QWORD *)(a1 + 104);
                v211 = "";
                v212 = v210 == 0;
                v213 = *(_DWORD *)(v210 + 368);
                v214 = (const char *)(v210 + 378);
                v256 = "send_data_callback_block_invoke";
                v257 = 2082;
                if (v212)
                  v214 = "";
                *(_DWORD *)buf = 136447234;
                if (!v212)
                  v211 = " ";
                v258 = v214;
                v259 = 2080;
                v260 = (size_t)v211;
                v261 = 1024;
                *(_DWORD *)v262 = v213;
                *(_WORD *)&v262[4] = 1024;
                *(_DWORD *)&v262[6] = v85;
                _os_log_impl(&dword_182FBE000, v209, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of body data (no padding)", buf, 0x2Cu);
              }
            }
            nw_frame_claim(*(_QWORD *)(a1 + 176), v131, v85, 0);
            LODWORD(v8) = v85 + v8;
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v85;
            v87 = *(_QWORD *)(a1 + 40);
LABEL_277:
            *(_DWORD *)(*(_QWORD *)(v87 + 8) + 24) += v85;
            goto LABEL_278;
          }
          if (*(_QWORD *)(a1 + 128))
            goto LABEL_278;
          v141 = *(_QWORD *)(a1 + 104);
          if (!v141 || (*(__int16 *)(v141 + 376) & 0x80000000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v142 = *(_QWORD *)(a1 + 104);
            v143 = (const char *)(v142 + 378);
            v144 = v142 == 0;
            v145 = *(_DWORD *)(v142 + 368);
            *(_DWORD *)buf = 136446978;
            if (v144)
              v143 = "";
            v256 = "send_data_callback_block_invoke";
            if (v144)
              v146 = "";
            else
              v146 = " ";
            v257 = 2082;
            v258 = v143;
            v259 = 2080;
            v260 = (size_t)v146;
            v261 = 1024;
            *(_DWORD *)v262 = v145;
            v94 = (char *)_os_log_send_and_compose_impl();
            v253 = OS_LOG_TYPE_ERROR;
            v251 = 0;
            if (!__nwlog_fault(v94, &v253, &v251))
              goto LABEL_343;
            if (v253 == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v95 = gconnectionLogObj;
              v96 = v253;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253))
                goto LABEL_343;
              v147 = *(_QWORD *)(a1 + 104);
              v98 = (const char *)(v147 + 378);
              v148 = v147 == 0;
              if (!v147)
                v98 = "";
              v100 = *(_DWORD *)(v147 + 368);
              if (v148)
                v101 = "";
              else
                v101 = " ";
LABEL_219:
              *(_DWORD *)buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              v258 = v98;
              v259 = 2080;
              v260 = (size_t)v101;
              v261 = 1024;
              *(_DWORD *)v262 = v100;
              v102 = "%{public}s %{public}s%s<i%u> unexpected NULL in source frame";
LABEL_342:
              _os_log_impl(&dword_182FBE000, v95, v96, v102, buf, 0x26u);
LABEL_343:
              if (v94)
                free(v94);
              return 0;
            }
            if (v251)
            {
              v111 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v95 = gconnectionLogObj;
              v96 = v253;
              v157 = os_log_type_enabled((os_log_t)gconnectionLogObj, v253);
              if (v111)
              {
                if (v157)
                {
                  v113 = *(_QWORD *)(a1 + 104);
                  v114 = (const char *)(v113 + 378);
                  if (v113)
                  {
                    v115 = " ";
                  }
                  else
                  {
                    v114 = "";
                    v115 = "";
                  }
                  goto LABEL_325;
                }
LABEL_326:
                free(v111);
                goto LABEL_343;
              }
              if (!v157)
                goto LABEL_343;
              v161 = *(_QWORD *)(a1 + 104);
              v122 = (const char *)(v161 + 378);
              v162 = v161 == 0;
              if (!v161)
                v122 = "";
              v124 = *(_DWORD *)(v161 + 368);
              if (v162)
                v125 = "";
              else
                v125 = " ";
LABEL_341:
              *(_DWORD *)buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              v258 = v122;
              v259 = 2080;
              v260 = (size_t)v125;
              v261 = 1024;
              *(_DWORD *)v262 = v124;
              v102 = "%{public}s %{public}s%s<i%u> unexpected NULL in source frame, no backtrace";
              goto LABEL_342;
            }
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v95 = gconnectionLogObj;
            v96 = v253;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253))
              goto LABEL_343;
            v159 = *(_QWORD *)(a1 + 104);
            v117 = (const char *)(v159 + 378);
            v160 = v159 == 0;
            if (!v159)
              v117 = "";
            v119 = *(_DWORD *)(v159 + 368);
            if (v160)
              v120 = "";
            else
              v120 = " ";
LABEL_245:
            *(_DWORD *)buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = v117;
            v259 = 2080;
            v260 = (size_t)v120;
            v261 = 1024;
            *(_DWORD *)v262 = v119;
            v102 = "%{public}s %{public}s%s<i%u> unexpected NULL in source frame, backtrace limit exceeded";
            goto LABEL_342;
          }
          return 0;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        v257 = 2082;
        v258 = "bodyCopySize";
        v259 = 2048;
        v260 = v69;
        v261 = 2048;
        *(_QWORD *)v262 = v70;
        v71 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v253 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v71, type, &v253))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v72 = __nwlog_obj();
            v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              *(_DWORD *)buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              v258 = "bodyCopySize";
              v259 = 2048;
              v260 = v69;
              v261 = 2048;
              *(_QWORD *)v262 = v70;
              v74 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_259:
              _os_log_impl(&dword_182FBE000, v72, v73, v74, buf, 0x2Au);
            }
          }
          else if (v253)
          {
            v75 = (char *)__nw_create_backtrace_string();
            v72 = __nwlog_obj();
            v73 = type[0];
            v76 = os_log_type_enabled(v72, type[0]);
            if (v75)
            {
              if (v76)
              {
                *(_DWORD *)buf = 136447234;
                v256 = "send_data_callback_block_invoke";
                v257 = 2082;
                v258 = "bodyCopySize";
                v259 = 2048;
                v260 = v69;
                v261 = 2048;
                *(_QWORD *)v262 = v70;
                *(_WORD *)&v262[8] = 2082;
                *(_QWORD *)&v262[10] = v75;
                _os_log_impl(&dword_182FBE000, v72, v73, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v75);
              goto LABEL_260;
            }
            if (v76)
            {
              *(_DWORD *)buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              v258 = "bodyCopySize";
              v259 = 2048;
              v260 = v69;
              v261 = 2048;
              *(_QWORD *)v262 = v70;
              v74 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_259;
            }
          }
          else
          {
            v72 = __nwlog_obj();
            v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              *(_DWORD *)buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              v258 = "bodyCopySize";
              v259 = 2048;
              v260 = v69;
              v261 = 2048;
              *(_QWORD *)v262 = v70;
              v74 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_259;
            }
          }
        }
LABEL_260:
        if (v71)
          free(v71);
        LODWORD(v21) = 0;
        goto LABEL_263;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446978;
      v256 = "send_data_callback_block_invoke";
      v257 = 2082;
      v258 = "bodyCopySize";
      v259 = 2048;
      v260 = v47;
      v261 = 2048;
      *(_QWORD *)v262 = v48;
      v49 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v253 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v49, type, &v253))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v50 = __nwlog_obj();
          v51 = type[0];
          if (os_log_type_enabled(v50, type[0]))
          {
            *(_DWORD *)buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v47;
            v261 = 2048;
            *(_QWORD *)v262 = v48;
            v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_142:
            _os_log_impl(&dword_182FBE000, v50, v51, v52, buf, 0x2Au);
          }
        }
        else if (v253)
        {
          v53 = (char *)__nw_create_backtrace_string();
          v50 = __nwlog_obj();
          v51 = type[0];
          v54 = os_log_type_enabled(v50, type[0]);
          if (v53)
          {
            if (v54)
            {
              *(_DWORD *)buf = 136447234;
              v256 = "send_data_callback_block_invoke";
              v257 = 2082;
              v258 = "bodyCopySize";
              v259 = 2048;
              v260 = v47;
              v261 = 2048;
              *(_QWORD *)v262 = v48;
              *(_WORD *)&v262[8] = 2082;
              *(_QWORD *)&v262[10] = v53;
              _os_log_impl(&dword_182FBE000, v50, v51, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v53);
            goto LABEL_143;
          }
          if (v54)
          {
            *(_DWORD *)buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v47;
            v261 = 2048;
            *(_QWORD *)v262 = v48;
            v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_142;
          }
        }
        else
        {
          v50 = __nwlog_obj();
          v51 = type[0];
          if (os_log_type_enabled(v50, type[0]))
          {
            *(_DWORD *)buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v47;
            v261 = 2048;
            *(_QWORD *)v262 = v48;
            v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_142;
          }
        }
      }
LABEL_143:
      if (v49)
        free(v49);
      LODWORD(v21) = 0;
      goto LABEL_146;
    }
    memcpy(&v6[v8], (const void *)(a1 + v22 + 136), v24);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v24;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v24;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) += v24;
    v16 = v21 >= v24;
    v21 = (v21 - v24);
    if (v16)
    {
LABEL_95:
      LODWORD(v8) = v24 + v8;
      v44 = *(_QWORD *)(a1 + 104);
      if ((!v44 || (*(__int16 *)(v44 + 376) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v203 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v204 = *(_QWORD *)(a1 + 104);
          v205 = "";
          v206 = v204 == 0;
          v207 = *(_DWORD *)(v204 + 368);
          v208 = (const char *)(v204 + 378);
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          if (v206)
            v208 = "";
          *(_DWORD *)buf = 136447234;
          if (!v206)
            v205 = " ";
          v258 = v208;
          v259 = 2080;
          v260 = (size_t)v205;
          v261 = 1024;
          *(_DWORD *)v262 = v207;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v24;
          _os_log_impl(&dword_182FBE000, v203, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule type", buf, 0x2Cu);
        }
      }
      if (v254 <= v8)
        goto LABEL_278;
      goto LABEL_99;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    v257 = 2082;
    v258 = "bodyCopySize";
    v259 = 2048;
    v260 = v24;
    v261 = 2048;
    *(_QWORD *)v262 = v21;
    v25 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v25, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v26 = __nwlog_obj();
        v27 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v24;
          v261 = 2048;
          *(_QWORD *)v262 = v21;
          v28 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_91:
          _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        v31 = (char *)__nw_create_backtrace_string();
        v26 = __nwlog_obj();
        v27 = type[0];
        v32 = os_log_type_enabled(v26, type[0]);
        if (v31)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v24;
            v261 = 2048;
            *(_QWORD *)v262 = v21;
            *(_WORD *)&v262[8] = 2082;
            *(_QWORD *)&v262[10] = v31;
            _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v31);
          goto LABEL_92;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v24;
          v261 = 2048;
          *(_QWORD *)v262 = v21;
          v28 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_91;
        }
      }
      else
      {
        v26 = __nwlog_obj();
        v27 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v24;
          v261 = 2048;
          *(_QWORD *)v262 = v21;
          v28 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_91;
        }
      }
    }
LABEL_92:
    if (v25)
      free(v25);
    LODWORD(v21) = 0;
    goto LABEL_95;
  }
  if (v7 <= 9)
  {
    if (v254 <= v8)
      goto LABEL_278;
    v6[v8] = v10 - 1;
    v11 = *(_QWORD *)(a1 + 104);
    if ((!v11 || (*(__int16 *)(v11 + 376) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v179 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v180 = *(_QWORD *)(a1 + 104);
        v181 = (const char *)(v180 + 378);
        v182 = "";
        v183 = v180 == 0;
        v184 = *(_DWORD *)(v180 + 368);
        v256 = "send_data_callback_block_invoke";
        if (v183)
          v181 = "";
        v257 = 2082;
        *(_DWORD *)buf = 136447234;
        if (!v183)
          v182 = " ";
        v258 = v181;
        v259 = 2080;
        v260 = (size_t)v182;
        v261 = 1024;
        *(_DWORD *)v262 = v184;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = 1;
        _os_log_impl(&dword_182FBE000, v179, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u byte of padding length", buf, 0x2Cu);
      }
    }
    LODWORD(v8) = v8 + 1;
    LODWORD(v7) = ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 112) + 16);
  }
  if (v7 >= *(_DWORD *)(a1 + 200) + ~(_DWORD)v10)
    goto LABEL_191;
  if (v254 <= v8)
    goto LABEL_278;
  if (*(_DWORD *)(a1 + 120) - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) >= v254 - v8)
    LODWORD(v12) = v254 - v8;
  else
    LODWORD(v12) = *(_DWORD *)(a1 + 120) - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (!*(_QWORD *)(a1 + 128))
  {
LABEL_181:
    *(_DWORD *)type = 0;
    v79 = (const void *)nw_frame_unclaimed_bytes(*(_QWORD *)(a1 + 176), type);
    if (v79)
    {
      if (v12 >= *(_DWORD *)type)
        v80 = *(unsigned int *)type;
      else
        v80 = v12;
      memcpy(&v6[v8], v79, v80);
      v82 = *(_QWORD *)(a1 + 104);
      if ((!v82 || (*(__int16 *)(v82 + 376) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v197 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v198 = *(_QWORD *)(a1 + 104);
          v199 = "";
          v200 = v198 == 0;
          v201 = *(_DWORD *)(v198 + 368);
          v202 = (const char *)(v198 + 378);
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          if (v200)
            v202 = "";
          *(_DWORD *)buf = 136447234;
          if (!v200)
            v199 = " ";
          v258 = v202;
          v259 = 2080;
          v260 = (size_t)v199;
          v261 = 1024;
          *(_DWORD *)v262 = v201;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v80;
          _os_log_impl(&dword_182FBE000, v197, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of body data (padding)", buf, 0x2Cu);
        }
      }
      nw_frame_claim(*(_QWORD *)(a1 + 176), v81, v80, 0);
      LODWORD(v8) = v80 + v8;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v80;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v80;
      goto LABEL_190;
    }
    if (*(_QWORD *)(a1 + 128))
    {
LABEL_190:
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 112) + 16);
LABEL_191:
      if (v10 < 2)
        goto LABEL_278;
      v83 = v254 - v8;
      if (v254 <= v8)
        goto LABEL_278;
      v84 = ~*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) + v10;
      if (v84 >= v83)
        v85 = v83;
      else
        v85 = v84;
      bzero(&v6[v8], v85);
      v86 = *(_QWORD *)(a1 + 104);
      if ((!v86 || (*(__int16 *)(v86 + 376) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v185 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v186 = *(_QWORD *)(a1 + 104);
          v187 = "";
          v188 = v186 == 0;
          v189 = *(_DWORD *)(v186 + 368);
          v190 = (const char *)(v186 + 378);
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          if (v188)
            v190 = "";
          *(_DWORD *)buf = 136447234;
          if (!v188)
            v187 = " ";
          v258 = v190;
          v259 = 2080;
          v260 = (size_t)v187;
          v261 = 1024;
          *(_DWORD *)v262 = v189;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v85;
          _os_log_impl(&dword_182FBE000, v185, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of padding", buf, 0x2Cu);
        }
      }
      LODWORD(v8) = v85 + v8;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v85;
      v87 = *(_QWORD *)(a1 + 80);
      goto LABEL_277;
    }
    v88 = *(_QWORD *)(a1 + 104);
    if (!v88 || (*(__int16 *)(v88 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v89 = *(_QWORD *)(a1 + 104);
      v90 = (const char *)(v89 + 378);
      v91 = v89 == 0;
      v92 = *(_DWORD *)(v89 + 368);
      *(_DWORD *)buf = 136446978;
      if (v91)
        v90 = "";
      v256 = "send_data_callback_block_invoke";
      if (v91)
        v93 = "";
      else
        v93 = " ";
      v257 = 2082;
      v258 = v90;
      v259 = 2080;
      v260 = (size_t)v93;
      v261 = 1024;
      *(_DWORD *)v262 = v92;
      v94 = (char *)_os_log_send_and_compose_impl();
      v253 = OS_LOG_TYPE_ERROR;
      v251 = 0;
      if (!__nwlog_fault(v94, &v253, &v251))
        goto LABEL_343;
      if (v253 == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v95 = gconnectionLogObj;
        v96 = v253;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253))
          goto LABEL_343;
        v97 = *(_QWORD *)(a1 + 104);
        v98 = (const char *)(v97 + 378);
        v99 = v97 == 0;
        if (!v97)
          v98 = "";
        v100 = *(_DWORD *)(v97 + 368);
        if (v99)
          v101 = "";
        else
          v101 = " ";
        goto LABEL_219;
      }
      if (v251)
      {
        v111 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v95 = gconnectionLogObj;
        v96 = v253;
        v112 = os_log_type_enabled((os_log_t)gconnectionLogObj, v253);
        if (v111)
        {
          if (v112)
          {
            v113 = *(_QWORD *)(a1 + 104);
            v114 = (const char *)(v113 + 378);
            if (v113)
            {
              v115 = " ";
            }
            else
            {
              v114 = "";
              v115 = "";
            }
LABEL_325:
            v158 = *(_DWORD *)(v113 + 368);
            *(_DWORD *)buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = v114;
            v259 = 2080;
            v260 = (size_t)v115;
            v261 = 1024;
            *(_DWORD *)v262 = v158;
            *(_WORD *)&v262[4] = 2082;
            *(_QWORD *)&v262[6] = v111;
            _os_log_impl(&dword_182FBE000, v95, v96, "%{public}s %{public}s%s<i%u> unexpected NULL in source frame, dumping backtrace:%{public}s", buf, 0x30u);
            goto LABEL_326;
          }
          goto LABEL_326;
        }
        if (!v112)
          goto LABEL_343;
        v121 = *(_QWORD *)(a1 + 104);
        v122 = (const char *)(v121 + 378);
        v123 = v121 == 0;
        if (!v121)
          v122 = "";
        v124 = *(_DWORD *)(v121 + 368);
        if (v123)
          v125 = "";
        else
          v125 = " ";
        goto LABEL_341;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v95 = gconnectionLogObj;
      v96 = v253;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253))
        goto LABEL_343;
      v116 = *(_QWORD *)(a1 + 104);
      v117 = (const char *)(v116 + 378);
      v118 = v116 == 0;
      if (!v116)
        v117 = "";
      v119 = *(_DWORD *)(v116 + 368);
      if (v118)
        v120 = "";
      else
        v120 = " ";
      goto LABEL_245;
    }
    return 0;
  }
  v13 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  v14 = *(unsigned __int8 *)(a1 + 204) - (_DWORD)v13;
  if (v14 >= v12)
    v15 = v12;
  else
    v15 = v14;
  if (!(_DWORD)v15)
    goto LABEL_73;
  memcpy(&v6[v8], (const void *)(a1 + v13 + 136), v15);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v15;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v15;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) += v15;
  v16 = v12 >= v15;
  v12 = (v12 - v15);
  if (!v16)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    v257 = 2082;
    v258 = "bodyCopySize";
    v259 = 2048;
    v260 = v15;
    v261 = 2048;
    *(_QWORD *)v262 = v12;
    v17 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v17, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v15;
          v261 = 2048;
          *(_QWORD *)v262 = v12;
          v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_65:
          _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        v29 = (char *)__nw_create_backtrace_string();
        v18 = __nwlog_obj();
        v19 = type[0];
        v30 = os_log_type_enabled(v18, type[0]);
        if (v29)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v15;
            v261 = 2048;
            *(_QWORD *)v262 = v12;
            *(_WORD *)&v262[8] = 2082;
            *(_QWORD *)&v262[10] = v29;
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v29);
          goto LABEL_66;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v15;
          v261 = 2048;
          *(_QWORD *)v262 = v12;
          v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_65;
        }
      }
      else
      {
        v18 = __nwlog_obj();
        v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v15;
          v261 = 2048;
          *(_QWORD *)v262 = v12;
          v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_65;
        }
      }
    }
LABEL_66:
    if (v17)
      free(v17);
    LODWORD(v12) = 0;
  }
  LODWORD(v8) = v15 + v8;
  v33 = *(_QWORD *)(a1 + 104);
  if ((!v33 || (*(__int16 *)(v33 + 376) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v191 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v192 = *(_QWORD *)(a1 + 104);
      v193 = "";
      v194 = v192 == 0;
      v195 = *(_DWORD *)(v192 + 368);
      v196 = (const char *)(v192 + 378);
      v256 = "send_data_callback_block_invoke";
      v257 = 2082;
      if (v194)
        v196 = "";
      *(_DWORD *)buf = 136447234;
      if (!v194)
        v193 = " ";
      v258 = v196;
      v259 = 2080;
      v260 = (size_t)v193;
      v261 = 1024;
      *(_DWORD *)v262 = v195;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v15;
      _os_log_impl(&dword_182FBE000, v191, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule type", buf, 0x2Cu);
    }
  }
  if (v254 <= v8)
    goto LABEL_278;
LABEL_73:
  v34 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
  v35 = *(unsigned __int8 *)(a1 + 205) - (_DWORD)v34;
  if (v35 >= v12)
    v36 = v12;
  else
    v36 = v35;
  if (!(_DWORD)v36)
    goto LABEL_125;
  memcpy(&v6[v8], (const void *)(a1 + v34 + 144), v36);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v36;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v36;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) += v36;
  v16 = v12 >= v36;
  v37 = (v12 - v36);
  LODWORD(v12) = v12 - v36;
  if (!v16)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    v257 = 2082;
    v258 = "bodyCopySize";
    v259 = 2048;
    v260 = v36;
    v261 = 2048;
    *(_QWORD *)v262 = v37;
    v38 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v38, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v39 = __nwlog_obj();
        v40 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v36;
          v261 = 2048;
          *(_QWORD *)v262 = v37;
          v41 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_117:
          _os_log_impl(&dword_182FBE000, v39, v40, v41, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        v42 = (char *)__nw_create_backtrace_string();
        v39 = __nwlog_obj();
        v40 = type[0];
        v43 = os_log_type_enabled(v39, type[0]);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v36;
            v261 = 2048;
            *(_QWORD *)v262 = v37;
            *(_WORD *)&v262[8] = 2082;
            *(_QWORD *)&v262[10] = v42;
            _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v42);
          goto LABEL_118;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v36;
          v261 = 2048;
          *(_QWORD *)v262 = v37;
          v41 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_117;
        }
      }
      else
      {
        v39 = __nwlog_obj();
        v40 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v36;
          v261 = 2048;
          *(_QWORD *)v262 = v37;
          v41 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_117;
        }
      }
    }
LABEL_118:
    if (v38)
      free(v38);
    LODWORD(v12) = 0;
  }
  LODWORD(v8) = v36 + v8;
  v55 = *(_QWORD *)(a1 + 104);
  if ((!v55 || (*(__int16 *)(v55 + 376) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v215 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v216 = *(_QWORD *)(a1 + 104);
      v217 = "";
      v218 = v216 == 0;
      v219 = *(_DWORD *)(v216 + 368);
      v220 = (const char *)(v216 + 378);
      v256 = "send_data_callback_block_invoke";
      v257 = 2082;
      if (v218)
        v220 = "";
      *(_DWORD *)buf = 136447234;
      if (!v218)
        v217 = " ";
      v258 = v220;
      v259 = 2080;
      v260 = (size_t)v217;
      v261 = 1024;
      *(_DWORD *)v262 = v219;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v36;
      _os_log_impl(&dword_182FBE000, v215, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule length", buf, 0x2Cu);
    }
  }
  if (v254 <= v8)
    goto LABEL_278;
LABEL_125:
  if (!*(_BYTE *)(a1 + 206))
    goto LABEL_179;
  v56 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
  v57 = *(unsigned __int8 *)(a1 + 207) - (_DWORD)v56;
  v58 = v57 >= v12 ? v12 : v57;
  if (!(_DWORD)v58)
    goto LABEL_179;
  memcpy(&v6[v8], (const void *)(a1 + v56 + 152), v58);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v58;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v58;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) += v58;
  v16 = v12 >= v58;
  v59 = (v12 - v58);
  LODWORD(v12) = v12 - v58;
  if (v16)
    goto LABEL_175;
  __nwlog_obj();
  *(_DWORD *)buf = 136446978;
  v256 = "send_data_callback_block_invoke";
  v257 = 2082;
  v258 = "bodyCopySize";
  v259 = 2048;
  v260 = v58;
  v261 = 2048;
  *(_QWORD *)v262 = v59;
  v60 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v253 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v60, type, &v253))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v61 = __nwlog_obj();
      v62 = type[0];
      if (os_log_type_enabled(v61, type[0]))
      {
        *(_DWORD *)buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        v257 = 2082;
        v258 = "bodyCopySize";
        v259 = 2048;
        v260 = v58;
        v261 = 2048;
        *(_QWORD *)v262 = v59;
        v63 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_171:
        _os_log_impl(&dword_182FBE000, v61, v62, v63, buf, 0x2Au);
      }
    }
    else if (v253)
    {
      v64 = (char *)__nw_create_backtrace_string();
      v61 = __nwlog_obj();
      v62 = type[0];
      v65 = os_log_type_enabled(v61, type[0]);
      if (v64)
      {
        if (v65)
        {
          *(_DWORD *)buf = 136447234;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v58;
          v261 = 2048;
          *(_QWORD *)v262 = v59;
          *(_WORD *)&v262[8] = 2082;
          *(_QWORD *)&v262[10] = v64;
          _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v64);
        goto LABEL_172;
      }
      if (v65)
      {
        *(_DWORD *)buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        v257 = 2082;
        v258 = "bodyCopySize";
        v259 = 2048;
        v260 = v58;
        v261 = 2048;
        *(_QWORD *)v262 = v59;
        v63 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
        goto LABEL_171;
      }
    }
    else
    {
      v61 = __nwlog_obj();
      v62 = type[0];
      if (os_log_type_enabled(v61, type[0]))
      {
        *(_DWORD *)buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        v257 = 2082;
        v258 = "bodyCopySize";
        v259 = 2048;
        v260 = v58;
        v261 = 2048;
        *(_QWORD *)v262 = v59;
        v63 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
        goto LABEL_171;
      }
    }
  }
LABEL_172:
  if (v60)
    free(v60);
  LODWORD(v12) = 0;
LABEL_175:
  LODWORD(v8) = v58 + v8;
  v77 = *(_QWORD *)(a1 + 104);
  if ((!v77 || (*(__int16 *)(v77 + 376) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v227 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v228 = *(_QWORD *)(a1 + 104);
      v229 = "";
      v230 = v228 == 0;
      v231 = *(_DWORD *)(v228 + 368);
      v232 = (const char *)(v228 + 378);
      v256 = "send_data_callback_block_invoke";
      v257 = 2082;
      if (v230)
        v232 = "";
      *(_DWORD *)buf = 136447234;
      if (!v230)
        v229 = " ";
      v258 = v232;
      v259 = 2080;
      v260 = (size_t)v229;
      v261 = 1024;
      *(_DWORD *)v262 = v231;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v58;
      _os_log_impl(&dword_182FBE000, v227, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of datagram context", buf, 0x2Cu);
    }
  }
  if (v254 > v8)
  {
LABEL_179:
    v78 = *(NSObject **)(a1 + 160);
    if (!v78 || *(_BYTE *)(a1 + 208))
      goto LABEL_181;
    v103 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24);
    v104 = *(_DWORD *)(a1 + 168) - v103;
    v105 = v104 >= v12 ? v12 : v104;
    if (!(_DWORD)v105)
      goto LABEL_181;
    nw_dispatch_data_copyout_from_offset(v78, (uint64_t)&v6[v8], v105, v103);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v105;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v105;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) += v105;
    v16 = v12 >= v105;
    v106 = (v12 - v105);
    LODWORD(v12) = v12 - v105;
    if (v16)
      goto LABEL_369;
    __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    v257 = 2082;
    v258 = "bodyCopySize";
    v259 = 2048;
    v260 = v105;
    v261 = 2048;
    *(_QWORD *)v262 = v106;
    v107 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v107, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v108 = __nwlog_obj();
        v109 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v105;
          v261 = 2048;
          *(_QWORD *)v262 = v106;
          v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_365:
          _os_log_impl(&dword_182FBE000, v108, v109, v110, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        v126 = (char *)__nw_create_backtrace_string();
        v108 = __nwlog_obj();
        v109 = type[0];
        v127 = os_log_type_enabled(v108, type[0]);
        if (v126)
        {
          if (v127)
          {
            *(_DWORD *)buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            v257 = 2082;
            v258 = "bodyCopySize";
            v259 = 2048;
            v260 = v105;
            v261 = 2048;
            *(_QWORD *)v262 = v106;
            *(_WORD *)&v262[8] = 2082;
            *(_QWORD *)&v262[10] = v126;
            _os_log_impl(&dword_182FBE000, v108, v109, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v126);
          goto LABEL_366;
        }
        if (v127)
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v105;
          v261 = 2048;
          *(_QWORD *)v262 = v106;
          v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_365;
        }
      }
      else
      {
        v108 = __nwlog_obj();
        v109 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          v257 = 2082;
          v258 = "bodyCopySize";
          v259 = 2048;
          v260 = v105;
          v261 = 2048;
          *(_QWORD *)v262 = v106;
          v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_365;
        }
      }
    }
LABEL_366:
    if (v107)
      free(v107);
    LODWORD(v12) = 0;
LABEL_369:
    LODWORD(v8) = v105 + v8;
    v171 = *(_QWORD *)(a1 + 104);
    if ((!v171 || (*(__int16 *)(v171 + 376) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v239 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v240 = *(_QWORD *)(a1 + 104);
        v241 = "";
        v242 = v240 == 0;
        v243 = *(_DWORD *)(v240 + 368);
        v244 = (const char *)(v240 + 378);
        v256 = "send_data_callback_block_invoke";
        v257 = 2082;
        if (v242)
          v244 = "";
        *(_DWORD *)buf = 136447234;
        if (!v242)
          v241 = " ";
        v258 = v244;
        v259 = 2080;
        v260 = (size_t)v241;
        v261 = 1024;
        *(_DWORD *)v262 = v243;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = v105;
        _os_log_impl(&dword_182FBE000, v239, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule body", buf, 0x2Cu);
      }
    }
    if (v254 <= v8)
      goto LABEL_278;
    goto LABEL_181;
  }
LABEL_278:
  nw_frame_claim(a2, v5, v8, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v133, v8, 0);
  v135 = *(_QWORD *)(a2 + 32);
  v136 = *(_QWORD **)(a2 + 40);
  v134 = (_QWORD *)(a2 + 32);
  if (v135)
  {
    *(_QWORD *)(v135 + 40) = v136;
    v136 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 184) + 8) = v136;
  }
  *v136 = v135;
  *v134 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v137 = *(_QWORD *)(a1 + 192);
  v138 = *(uint64_t **)(v137 + 8);
  *(_QWORD *)(a2 + 40) = v138;
  *v138 = a2;
  *(_QWORD *)(v137 + 8) = v134;
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24);
  v139 = *(_QWORD *)(a1 + 104);
  if (!v139)
  {
    if (!gLogDatapath)
      return 1;
LABEL_351:
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v165 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v166 = *(_QWORD *)(a1 + 104);
      v167 = "";
      v168 = v166 == 0;
      v169 = *(_DWORD *)(v166 + 368);
      v170 = (const char *)(v166 + 378);
      v256 = "send_data_callback_block_invoke";
      v257 = 2082;
      if (v168)
        v170 = "";
      *(_DWORD *)buf = 136447234;
      if (!v168)
        v167 = " ";
      v258 = v170;
      v259 = 2080;
      v260 = (size_t)v167;
      v261 = 1024;
      *(_DWORD *)v262 = v169;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v8;
      _os_log_impl(&dword_182FBE000, v165, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> copied %u bytes into output frame", buf, 0x2Cu);
    }
    return 1;
  }
  result = 1;
  if ((*(__int16 *)(v139 + 376) & 0x80000000) == 0 && gLogDatapath)
    goto LABEL_351;
  return result;
}

void http2_output_frame_metadata_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const char *v4;
  const char *v5;
  int v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  int v10;
  const char *v11;
  char *v12;
  _BOOL4 v13;
  int v14;
  int v15;
  int v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *backtrace_string;
  _BOOL4 v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  void *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "__nw_frame_get_metadata";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v17, &type, &v23))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v26 = "__nw_frame_get_metadata";
      v20 = "%{public}s called with null frame";
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v22 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "__nw_frame_get_metadata";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_50;
      }
      if (!v22)
      {
LABEL_50:
        if (v17)
          free(v17);
        goto LABEL_3;
      }
      *(_DWORD *)buf = 136446210;
      v26 = "__nw_frame_get_metadata";
      v20 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v26 = "__nw_frame_get_metadata";
      v20 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
    goto LABEL_50;
  }
  if ((*(_WORD *)(a1 + 204) & 4) != 0)
  {
    *(_QWORD *)(a1 + 208) = a2;
    *(_QWORD *)(a1 + 216) = a3;
    return;
  }
LABEL_3:
  if (a2)
  {
    if (*(__int16 *)(a2 + 376) < 0)
      return;
    v4 = " ";
  }
  else
  {
    v4 = "";
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  if (a2)
    v5 = (const char *)(a2 + 378);
  else
    v5 = "";
  v6 = *(_DWORD *)(a2 + 368);
  *(_DWORD *)buf = 136446978;
  v26 = "http2_output_frame_metadata_reset";
  v27 = 2082;
  v28 = (void *)v5;
  v29 = 2080;
  v30 = v4;
  v31 = 1024;
  v32 = v6;
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v7, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v8 = gconnectionLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_33;
      v10 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      v26 = "http2_output_frame_metadata_reset";
      v27 = 2082;
      v28 = (void *)v5;
      v29 = 2080;
      v30 = v4;
      v31 = 1024;
      v32 = v10;
      v11 = "%{public}s %{public}s%s<i%u> frame has no metadata";
      goto LABEL_32;
    }
    if (!v23)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v8 = gconnectionLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_33;
      v15 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      v26 = "http2_output_frame_metadata_reset";
      v27 = 2082;
      v28 = (void *)v5;
      v29 = 2080;
      v30 = v4;
      v31 = 1024;
      v32 = v15;
      v11 = "%{public}s %{public}s%s<i%u> frame has no metadata, backtrace limit exceeded";
      goto LABEL_32;
    }
    v12 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v8 = gconnectionLogObj;
    v9 = type;
    v13 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (v12)
    {
      if (v13)
      {
        v14 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)buf = 136447234;
        v26 = "http2_output_frame_metadata_reset";
        v27 = 2082;
        v28 = (void *)v5;
        v29 = 2080;
        v30 = v4;
        v31 = 1024;
        v32 = v14;
        v33 = 2082;
        v34 = v12;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s %{public}s%s<i%u> frame has no metadata, dumping backtrace:%{public}s", buf, 0x30u);
      }
      free(v12);
      goto LABEL_33;
    }
    if (v13)
    {
      v16 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      v26 = "http2_output_frame_metadata_reset";
      v27 = 2082;
      v28 = (void *)v5;
      v29 = 2080;
      v30 = v4;
      v31 = 1024;
      v32 = v16;
      v11 = "%{public}s %{public}s%s<i%u> frame has no metadata, no backtrace";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v8, v9, v11, buf, 0x26u);
    }
  }
LABEL_33:
  if (v7)
    free(v7);
}

uint64_t ___ZL13send_callbackP15nghttp2_sessionPKhmiPv_block_invoke_81833(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  unsigned int v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  NSObject *v17;
  uint64_t v18;
  const char *v19;
  BOOL v20;
  int v21;
  const char *v22;
  unsigned int v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  v4 = (void *)nw_frame_unclaimed_bytes(a2, &v23);
  v5 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v6 = *(_DWORD *)(a1 + 48) - v5;
  if (v6 >= v23)
    v7 = v23;
  else
    v7 = v6;
  memcpy(v4, (const void *)(*(_QWORD *)(a1 + 56) + v5), v7);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v7;
  nw_frame_claim(a2, v8, v7, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v9, v7, 0);
  v11 = *(_QWORD *)(a2 + 32);
  v12 = *(_QWORD **)(a2 + 40);
  v10 = (_QWORD *)(a2 + 32);
  if (v11)
  {
    *(_QWORD *)(v11 + 40) = v12;
    v12 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) = v12;
  }
  *v12 = v11;
  *v10 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v13 = *(_QWORD *)(a1 + 80);
  v14 = *(uint64_t **)(v13 + 8);
  *(_QWORD *)(a2 + 40) = v14;
  *v14 = a2;
  *(_QWORD *)(v13 + 8) = v10;
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v15 = *(_QWORD *)(a1 + 64);
  if ((!v15 || (*(__int16 *)(v15 + 376) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v17 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v18 = *(_QWORD *)(a1 + 64);
      v19 = "";
      v20 = v18 == 0;
      v21 = *(_DWORD *)(v18 + 368);
      v22 = (const char *)(v18 + 378);
      v25 = "send_callback_block_invoke";
      v26 = 2082;
      if (v20)
        v22 = "";
      *(_DWORD *)buf = 136447234;
      if (!v20)
        v19 = " ";
      v27 = v22;
      v28 = 2080;
      v29 = v19;
      v30 = 1024;
      v31 = v21;
      v32 = 1024;
      v33 = v7;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> copied %u bytes into output frame", buf, 0x2Cu);
    }
  }
  return 1;
}

uint64_t http2_create_input_frame(uint64_t a1, uint64_t a2, size_t size)
{
  uint64_t frame;
  uint64_t v7;
  uint64_t *v8;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  NSObject *v14;
  int v15;
  int v16;
  NSObject *v17;
  int v18;
  int v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  _BOOL4 v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "http2_create_input_frame";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25))
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v28 = "http2_create_input_frame";
      v13 = "%{public}s called with null http2";
LABEL_55:
      _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
      goto LABEL_56;
    }
    if (!v25)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "http2_create_input_frame";
        v13 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "http2_create_input_frame";
        v13 = "%{public}s called with null http2, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (!v21)
      goto LABEL_42;
    *(_DWORD *)buf = 136446466;
    v28 = "http2_create_input_frame";
    v29 = 2082;
    v30 = backtrace_string;
    v22 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_41:
    _os_log_impl(&dword_182FBE000, v11, v12, v22, buf, 0x16u);
    goto LABEL_42;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "http2_create_input_frame";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25))
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v28 = "http2_create_input_frame";
      v13 = "%{public}s called with null stream";
      goto LABEL_55;
    }
    if (!v25)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "http2_create_input_frame";
        v13 = "%{public}s called with null stream, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "http2_create_input_frame";
        v13 = "%{public}s called with null stream, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (!v23)
      goto LABEL_42;
    *(_DWORD *)buf = 136446466;
    v28 = "http2_create_input_frame";
    v29 = 2082;
    v30 = backtrace_string;
    v22 = "%{public}s called with null stream, dumping backtrace:%{public}s";
    goto LABEL_41;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v14 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v16 = *(_DWORD *)(a2 + 176);
      v15 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v28 = "http2_create_input_frame";
      v29 = 2082;
      v30 = (char *)(a2 + 191);
      v31 = 2080;
      v32 = " ";
      v33 = 1024;
      v34 = v15;
      v35 = 1024;
      v36 = v16;
      v37 = 1024;
      LODWORD(v38) = size;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> requested input frame of length %u", buf, 0x32u);
    }
  }
  frame = nw_frame_cache_create_frame((uint64_t *)(a1 + 200), size);
  if (frame)
  {
    v7 = frame;
    *(_QWORD *)(frame + 16) = 0;
    v8 = *(uint64_t **)(a1 + 176);
    *(_QWORD *)(frame + 24) = v8;
    *v8 = frame;
    *(_QWORD *)(a1 + 176) = frame + 16;
    *(_QWORD *)(frame + 80) = nw_protocol_http2_frame_input_finalizer;
    *(_QWORD *)(frame + 88) = 0;
    http2_input_frame_metadata_reset(frame, a1, a2, size);
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v19 = *(_DWORD *)(a2 + 176);
        v18 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447746;
        v28 = "http2_create_input_frame";
        v29 = 2082;
        v30 = (char *)(a2 + 191);
        v31 = 2080;
        v32 = " ";
        v33 = 1024;
        v34 = v18;
        v35 = 1024;
        v36 = v19;
        v37 = 2048;
        v38 = v7;
        v39 = 1024;
        v40 = size;
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> input_frame_create returning frame %p for requested length %u", buf, 0x3Cu);
      }
    }
    return v7;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v28 = "http2_create_input_frame";
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v10, &type, &v25))
    goto LABEL_56;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v25)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "http2_create_input_frame";
        v13 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "http2_create_input_frame";
        v13 = "%{public}s called with null frame, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v28 = "http2_create_input_frame";
      v29 = 2082;
      v30 = backtrace_string;
      v22 = "%{public}s called with null frame, dumping backtrace:%{public}s";
      goto LABEL_41;
    }
LABEL_42:
    free(backtrace_string);
    goto LABEL_56;
  }
  v11 = __nwlog_obj();
  v12 = type;
  if (os_log_type_enabled(v11, type))
  {
    *(_DWORD *)buf = 136446210;
    v28 = "http2_create_input_frame";
    v13 = "%{public}s called with null frame";
    goto LABEL_55;
  }
LABEL_56:
  if (v10)
    free(v10);
  return 0;
}

void nw_protocol_http2_frame_input_finalizer(nw_frame *a1, int a2, void *a3)
{
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  __int16 v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  char *v15;
  _BOOL4 v16;
  const char *v17;
  uint64_t v18;
  int v19;
  int v20;
  char *v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  NSObject *v30;
  int v31;
  int v32;
  unint64_t v33;
  uint64_t v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint64_t v39;
  const char *v40;
  unsigned int v41;
  const char *v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  uint64_t v51;
  const char *v52;
  char *v53;
  NSObject *v54;
  _BOOL4 v55;
  uint64_t v56;
  uint64_t v57;
  NSObject *v58;
  int v59;
  char *v60;
  uint64_t v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  uint64_t v65;
  const char *v66;
  _BOOL4 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  NSObject *v73;
  char *backtrace_string;
  _BOOL4 v75;
  NSObject *v76;
  int v77;
  _BOOL4 v78;
  _BOOL4 v79;
  _BOOL4 v80;
  NSObject *v81;
  int v82;
  int v83;
  uint64_t v84;
  int v85;
  int v86;
  NSObject *log;
  int v88;
  int v89;
  char v90;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v93;
  __int16 v94;
  const char *v95;
  __int16 v96;
  char *v97;
  __int16 v98;
  _BYTE v99[22];
  int v100;
  __int16 v101;
  int v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v73 = __nwlog_obj();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      _os_log_impl(&dword_182FBE000, v73, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v6, &type, &v90))
      goto LABEL_42;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v90)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v75 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v75)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v94 = 2082;
            v95 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v75)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v9 = "%{public}s called with null frame, no backtrace";
          goto LABEL_41;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v9 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
      goto LABEL_42;
    }
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v9 = "%{public}s called with null frame";
LABEL_41:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_42;
  }
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v6, &type, &v90))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      v9 = "%{public}s http2 input frame has nonnull context";
      goto LABEL_41;
    }
    if (!v90)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      v9 = "%{public}s http2 input frame has nonnull context, backtrace limit exceeded";
      goto LABEL_41;
    }
    v15 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v15)
    {
      if (!v16)
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      v9 = "%{public}s http2 input frame has nonnull context, no backtrace";
      goto LABEL_41;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      v94 = 2082;
      v95 = v15;
      v17 = "%{public}s http2 input frame has nonnull context, dumping backtrace:%{public}s";
LABEL_19:
      _os_log_impl(&dword_182FBE000, v7, v8, v17, buf, 0x16u);
      goto LABEL_20;
    }
    goto LABEL_20;
  }
  v10 = *((_WORD *)a1 + 102);
  if ((v10 & 4) != 0)
    v11 = (char *)a1 + 208;
  else
    v11 = 0;
  if ((v10 & 4) != 0)
  {
    v12 = *(_QWORD *)v11;
    if (*(_QWORD *)v11)
    {
      v13 = *((_QWORD *)a1 + 2);
      v14 = (_QWORD *)*((_QWORD *)a1 + 3);
      if (v13)
      {
        *(_QWORD *)(v13 + 24) = v14;
        v14 = (_QWORD *)*((_QWORD *)a1 + 3);
      }
      else
      {
        *(_QWORD *)(v12 + 176) = v14;
      }
      *v14 = v13;
      *((_QWORD *)a1 + 2) = 0;
      *((_QWORD *)a1 + 3) = 0;
      if ((*(__int16 *)(v12 + 376) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v76 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v77 = *(_DWORD *)(v12 + 368);
          *(_DWORD *)buf = 136447234;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v94 = 2082;
          v95 = (const char *)(v12 + 378);
          v96 = 2080;
          v97 = " ";
          v98 = 1024;
          *(_DWORD *)v99 = v77;
          *(_WORD *)&v99[4] = 2048;
          *(_QWORD *)&v99[6] = a1;
          _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> finalizing input frame %p", buf, 0x30u);
        }
      }
      v18 = *((_QWORD *)v11 + 1);
      if (v18)
      {
        v19 = *(unsigned __int16 *)(v18 + 188);
        v20 = v19 | (*(unsigned __int8 *)(v18 + 190) << 16);
        if ((v19 & 1) == 0 || *(_DWORD *)(v18 + 176) == -1)
        {
          if ((v20 & 0x80000) != 0 || !gLogDatapath)
            goto LABEL_113;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v24 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            goto LABEL_113;
          v26 = *(_DWORD *)(v18 + 176);
          v25 = *(_DWORD *)(v18 + 180);
          *(_DWORD *)buf = 136447490;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v94 = 2082;
          v95 = (const char *)(v18 + 191);
          v96 = 2080;
          v97 = " ";
          v98 = 1024;
          *(_DWORD *)v99 = v25;
          *(_WORD *)&v99[4] = 1024;
          *(_DWORD *)&v99[6] = v26;
          *(_WORD *)&v99[10] = 1024;
          *(_DWORD *)&v99[12] = v26;
          v27 = "%{public}s %{public}s%s<i%u:s%d> skipping stream flow control update on closed stream %d";
          v28 = v24;
          v29 = 50;
          goto LABEL_176;
        }
        v21 = (char *)*((unsigned int *)v11 + 4);
        v22 = *((_DWORD *)a1 + 13);
        if (v22)
        {
          v23 = v22 - (*((_DWORD *)a1 + 14) + *((_DWORD *)a1 + 15));
          if ((_DWORD)v21 == v23)
            goto LABEL_50;
        }
        else
        {
          v23 = 0;
          if (!(_DWORD)v21)
            goto LABEL_50;
        }
        if ((v20 & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v30 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            v32 = *(_DWORD *)(v18 + 176);
            v31 = *(_DWORD *)(v18 + 180);
            *(_DWORD *)buf = 136448002;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v94 = 2082;
            v95 = (const char *)(v18 + 191);
            v96 = 2080;
            v97 = " ";
            v98 = 1024;
            *(_DWORD *)v99 = v31;
            *(_WORD *)&v99[4] = 1024;
            *(_DWORD *)&v99[6] = v32;
            *(_WORD *)&v99[10] = 2048;
            *(_QWORD *)&v99[12] = a1;
            *(_WORD *)&v99[20] = 1024;
            v100 = (int)v21;
            v101 = 1024;
            v102 = v23;
            _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> http2 input frame %p original length (%u) does not match unclaimed length (%u) when finalized", buf, 0x42u);
          }
        }
LABEL_50:
        v33 = *(int *)(v18 + 184) - (unint64_t)v21;
        *(_DWORD *)(v18 + 184) = v33;
        if (v33 == (uint64_t)(v33 << 31) >> 31 && (v33 & 0x1FFFFFFFFLL) == ((int)v33 & 0x1FFFFFFFFLL))
        {
          if ((int)v33 > 1597151)
          {
LABEL_111:
            if (((*(unsigned __int16 *)(v18 + 188) | (*(unsigned __int8 *)(v18 + 190) << 16)) & 0x80000) != 0
              || !gLogDatapath)
            {
              goto LABEL_113;
            }
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v84 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              goto LABEL_113;
            v86 = *(_DWORD *)(v18 + 176);
            v85 = *(_DWORD *)(v18 + 180);
            *(_DWORD *)buf = 136447746;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v94 = 2082;
            v95 = (const char *)(v18 + 191);
            v96 = 2080;
            v97 = " ";
            v98 = 1024;
            *(_DWORD *)v99 = v85;
            *(_WORD *)&v99[4] = 1024;
            *(_DWORD *)&v99[6] = v86;
            *(_WORD *)&v99[10] = 1024;
            *(_DWORD *)&v99[12] = (_DWORD)v21;
            *(_WORD *)&v99[16] = 1024;
            *(_DWORD *)&v99[18] = v86;
            v27 = "%{public}s %{public}s%s<i%u:s%d> consumed %u bytes on stream %d";
            v28 = v84;
            v29 = 56;
LABEL_176:
            _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, v27, buf, v29);
LABEL_113:
            if (a2)
            {
              http2_input_frame_metadata_reset((uint64_t)a1, 0, 0, 0);
              nw_frame_cache_return_frame(v12 + 200, (uint64_t)a1);
            }
            else
            {
              if (((*(unsigned __int16 *)(v18 + 188) | (*(unsigned __int8 *)(v18 + 190) << 16)) & 0x80000) == 0
                && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v81 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v83 = *(_DWORD *)(v18 + 176);
                  v82 = *(_DWORD *)(v18 + 180);
                  *(_DWORD *)buf = 136447234;
                  v93 = "nw_protocol_http2_frame_input_finalizer";
                  v94 = 2082;
                  v95 = (const char *)(v18 + 191);
                  v96 = 2080;
                  v97 = " ";
                  v98 = 1024;
                  *(_DWORD *)v99 = v82;
                  *(_WORD *)&v99[4] = 1024;
                  *(_DWORD *)&v99[6] = v83;
                  _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> disposing of input frame, finalizer called with success == false", buf, 0x2Cu);
                }
              }
              if ((*((_WORD *)a1 + 102) & 0x100) == 0
                || !g_channel_check_validity
                || g_channel_check_validity(a1, *((_QWORD *)a1 + 11)))
              {
                v72 = (void *)*((_QWORD *)a1 + 14);
                if (v72)
                  free(v72);
              }
              nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
              os_release(a1);
            }
            nw_http2_session_send(v12);
            return;
          }
          v41 = 0x200000 - v33;
LABEL_73:
          if (!nghttp2_submit_window_update())
            goto LABEL_90;
          v88 = (int)v21;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v47 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v94 = 2082;
          v95 = (const char *)v47;
          v48 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v90 = 0;
          if (__nwlog_fault(v48, &type, &v90))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v49 = gLogObj;
              v50 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                v51 = nghttp2_strerror();
                *(_DWORD *)buf = 136446466;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = (const char *)v51;
                v52 = "%{public}s nghttp2_submit_window_update: %{public}s failed";
LABEL_85:
                v58 = v49;
LABEL_86:
                _os_log_impl(&dword_182FBE000, v58, v50, v52, buf, 0x16u);
              }
            }
            else if (v90)
            {
              v53 = (char *)__nw_create_backtrace_string();
              v54 = __nwlog_obj();
              v50 = type;
              log = v54;
              v55 = os_log_type_enabled(v54, type);
              if (v53)
              {
                if (v55)
                {
                  v56 = nghttp2_strerror();
                  *(_DWORD *)buf = 136446722;
                  v93 = "nw_protocol_http2_frame_input_finalizer";
                  v94 = 2082;
                  v95 = (const char *)v56;
                  v96 = 2082;
                  v97 = v53;
                  _os_log_impl(&dword_182FBE000, log, v50, "%{public}s nghttp2_submit_window_update: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
                }
                free(v53);
                goto LABEL_87;
              }
              if (v55)
              {
                v70 = nghttp2_strerror();
                *(_DWORD *)buf = 136446466;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = (const char *)v70;
                v52 = "%{public}s nghttp2_submit_window_update: %{public}s failed, no backtrace";
                v58 = log;
                goto LABEL_86;
              }
            }
            else
            {
              v49 = __nwlog_obj();
              v50 = type;
              if (os_log_type_enabled(v49, type))
              {
                v57 = nghttp2_strerror();
                *(_DWORD *)buf = 136446466;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = (const char *)v57;
                v52 = "%{public}s nghttp2_submit_window_update: %{public}s failed, backtrace limit exceeded";
                goto LABEL_85;
              }
            }
          }
LABEL_87:
          if (v48)
            free(v48);
          LODWORD(v21) = v88;
LABEL_90:
          v59 = *(_DWORD *)(v18 + 184);
          *(_DWORD *)(v18 + 184) = v59 + v41;
          if (!__OFADD__(v59, v41))
            goto LABEL_111;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v60 = (char *)v41;
          v61 = *(int *)(v18 + 184);
          *(_DWORD *)buf = 136446978;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v94 = 2082;
          v95 = "stream->window_remaining";
          v96 = 2048;
          v97 = (char *)v41;
          v98 = 2048;
          *(_QWORD *)v99 = v61;
          v62 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v90 = 0;
          if (__nwlog_fault(v62, &type, &v90))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v63 = gLogObj;
              v64 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                v65 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136446978;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = "stream->window_remaining";
                v96 = 2048;
                v97 = v60;
                v98 = 2048;
                *(_QWORD *)v99 = v65;
                v66 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_107:
                _os_log_impl(&dword_182FBE000, v63, v64, v66, buf, 0x2Au);
              }
            }
            else if (v90)
            {
              v89 = (int)v21;
              v21 = (char *)__nw_create_backtrace_string();
              v63 = __nwlog_obj();
              v64 = type;
              v67 = os_log_type_enabled(v63, type);
              if (v21)
              {
                if (v67)
                {
                  v68 = *(int *)(v18 + 184);
                  *(_DWORD *)buf = 136447234;
                  v93 = "nw_protocol_http2_frame_input_finalizer";
                  v94 = 2082;
                  v95 = "stream->window_remaining";
                  v96 = 2048;
                  v97 = v60;
                  v98 = 2048;
                  *(_QWORD *)v99 = v68;
                  *(_WORD *)&v99[8] = 2082;
                  *(_QWORD *)&v99[10] = v21;
                  _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v21);
                LODWORD(v21) = v89;
                goto LABEL_108;
              }
              LODWORD(v21) = v89;
              if (v67)
              {
                v71 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136446978;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = "stream->window_remaining";
                v96 = 2048;
                v97 = v60;
                v98 = 2048;
                *(_QWORD *)v99 = v71;
                v66 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_107;
              }
            }
            else
            {
              v63 = __nwlog_obj();
              v64 = type;
              if (os_log_type_enabled(v63, type))
              {
                v69 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136446978;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = "stream->window_remaining";
                v96 = 2048;
                v97 = v60;
                v98 = 2048;
                *(_QWORD *)v99 = v69;
                v66 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_107;
              }
            }
          }
LABEL_108:
          if (v62)
            free(v62);
          *(_DWORD *)(v18 + 184) = 0x200000;
          goto LABEL_111;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = *(int *)(v18 + 184);
        *(_DWORD *)buf = 136446978;
        v93 = "nw_protocol_http2_frame_input_finalizer";
        v94 = 2082;
        v95 = "stream->window_remaining";
        v96 = 2048;
        v97 = v21;
        v98 = 2048;
        *(_QWORD *)v99 = v35;
        v36 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v90 = 0;
        if (__nwlog_fault(v36, &type, &v90))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v37 = gLogObj;
            v38 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v39 = *(int *)(v18 + 184);
              *(_DWORD *)buf = 136446978;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              v94 = 2082;
              v95 = "stream->window_remaining";
              v96 = 2048;
              v97 = v21;
              v98 = 2048;
              *(_QWORD *)v99 = v39;
              v40 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_69:
              _os_log_impl(&dword_182FBE000, v37, v38, v40, buf, 0x2Au);
            }
          }
          else if (v90)
          {
            v42 = v21;
            v21 = (char *)__nw_create_backtrace_string();
            v37 = __nwlog_obj();
            v38 = type;
            v43 = os_log_type_enabled(v37, type);
            if (v21)
            {
              if (v43)
              {
                v44 = *(int *)(v18 + 184);
                *(_DWORD *)buf = 136447234;
                v93 = "nw_protocol_http2_frame_input_finalizer";
                v94 = 2082;
                v95 = "stream->window_remaining";
                v96 = 2048;
                v97 = (char *)v42;
                v98 = 2048;
                *(_QWORD *)v99 = v44;
                *(_WORD *)&v99[8] = 2082;
                *(_QWORD *)&v99[10] = v21;
                _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v21);
              LODWORD(v21) = (_DWORD)v42;
              goto LABEL_70;
            }
            LODWORD(v21) = (_DWORD)v42;
            if (v43)
            {
              v46 = *(int *)(v18 + 184);
              *(_DWORD *)buf = 136446978;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              v94 = 2082;
              v95 = "stream->window_remaining";
              v96 = 2048;
              v97 = (char *)v42;
              v98 = 2048;
              *(_QWORD *)v99 = v46;
              v40 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_69;
            }
          }
          else
          {
            v37 = __nwlog_obj();
            v38 = type;
            if (os_log_type_enabled(v37, type))
            {
              v45 = *(int *)(v18 + 184);
              *(_DWORD *)buf = 136446978;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              v94 = 2082;
              v95 = "stream->window_remaining";
              v96 = 2048;
              v97 = v21;
              v98 = 2048;
              *(_QWORD *)v99 = v45;
              v40 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_69;
            }
          }
        }
LABEL_70:
        if (v36)
          free(v36);
        *(_DWORD *)(v18 + 184) = 0;
        v41 = 0x200000;
        goto LABEL_73;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      v6 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v90 = 0;
      if (__nwlog_fault(v6, &type, &v90))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v9 = "%{public}s called with null stream";
            goto LABEL_41;
          }
        }
        else if (v90)
        {
          v15 = (char *)__nw_create_backtrace_string();
          v7 = __nwlog_obj();
          v8 = type;
          v80 = os_log_type_enabled(v7, type);
          if (v15)
          {
            if (v80)
            {
              *(_DWORD *)buf = 136446466;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              v94 = 2082;
              v95 = v15;
              v17 = "%{public}s called with null stream, dumping backtrace:%{public}s";
              goto LABEL_19;
            }
            goto LABEL_20;
          }
          if (v80)
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v9 = "%{public}s called with null stream, no backtrace";
            goto LABEL_41;
          }
        }
        else
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v9 = "%{public}s called with null stream, backtrace limit exceeded";
            goto LABEL_41;
          }
        }
      }
LABEL_42:
      if (v6)
        goto LABEL_43;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v6, &type, &v90))
      goto LABEL_42;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v90)
      {
        v15 = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v79 = os_log_type_enabled(v7, type);
        if (v15)
        {
          if (v79)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            v94 = 2082;
            v95 = v15;
            v17 = "%{public}s called with null http2, dumping backtrace:%{public}s";
            goto LABEL_19;
          }
          goto LABEL_20;
        }
        if (v79)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v9 = "%{public}s called with null http2, no backtrace";
          goto LABEL_41;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_http2_frame_input_finalizer";
          v9 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
      goto LABEL_42;
    }
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v9 = "%{public}s called with null http2";
    goto LABEL_41;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v93 = "nw_protocol_http2_frame_input_finalizer";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v90 = 0;
  if (!__nwlog_fault(v6, &type, &v90))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v9 = "%{public}s called with null input_frame_context";
    goto LABEL_41;
  }
  if (!v90)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      v9 = "%{public}s called with null input_frame_context, backtrace limit exceeded";
      goto LABEL_41;
    }
    goto LABEL_42;
  }
  v15 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v78 = os_log_type_enabled(v7, type);
  if (!v15)
  {
    if (v78)
    {
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      v9 = "%{public}s called with null input_frame_context, no backtrace";
      goto LABEL_41;
    }
    goto LABEL_42;
  }
  if (v78)
  {
    *(_DWORD *)buf = 136446466;
    v93 = "nw_protocol_http2_frame_input_finalizer";
    v94 = 2082;
    v95 = v15;
    v17 = "%{public}s called with null input_frame_context, dumping backtrace:%{public}s";
    goto LABEL_19;
  }
LABEL_20:
  free(v15);
  if (v6)
LABEL_43:
    free(v6);
}

void http2_input_frame_metadata_reset(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v6;
  int v7;
  char *v8;
  uint64_t v9;
  os_log_type_t v10;
  int v11;
  int v12;
  const char *v13;
  char *v14;
  _BOOL4 v15;
  int v16;
  int v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  uint32_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  NSObject *v26;
  os_log_type_t v27;
  uint32_t v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  char *backtrace_string;
  _BOOL4 v33;
  const char *v34;
  int v35;
  uint64_t v36;
  os_log_type_t v37;
  int v38;
  const char *v39;
  _BOOL4 v40;
  int v41;
  int v42;
  int v43;
  char v44;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  void *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  int v53;
  __int16 v54;
  _QWORD v55[3];

  v55[2] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "http2_input_frame_metadata_reset";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v8, &type, &v44))
      goto LABEL_31;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v47 = "http2_input_frame_metadata_reset";
      v13 = "%{public}s called with null frame";
    }
    else if (v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v29 = __nwlog_obj();
      v30 = type;
      v33 = os_log_type_enabled(v29, type);
      if (backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          v47 = "http2_input_frame_metadata_reset";
          v48 = 2082;
          v49 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_31;
      }
      if (!v33)
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v47 = "http2_input_frame_metadata_reset";
      v13 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v47 = "http2_input_frame_metadata_reset";
      v13 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    v26 = v29;
    v27 = v30;
    v28 = 12;
    goto LABEL_30;
  }
  if ((*(_WORD *)(a1 + 204) & 4) != 0)
  {
    *(_QWORD *)(a1 + 208) = a2;
    *(_QWORD *)(a1 + 216) = a3;
    *(_DWORD *)(a1 + 224) = a4;
    return;
  }
  if (a3)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0)
      return;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = *(_DWORD *)(a3 + 176);
    v6 = *(_DWORD *)(a3 + 180);
    *(_DWORD *)buf = 136447234;
    v47 = "http2_input_frame_metadata_reset";
    v48 = 2082;
    v49 = (void *)(a3 + 191);
    v50 = 2080;
    v51 = " ";
    v52 = 1024;
    v53 = v6;
    v54 = 1024;
    LODWORD(v55[0]) = v7;
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v8, &type, &v44))
      goto LABEL_31;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v9 = gconnectionLogObj;
      v10 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v12 = *(_DWORD *)(a3 + 176);
        v11 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447234;
        v47 = "http2_input_frame_metadata_reset";
        v48 = 2082;
        v49 = (void *)(a3 + 191);
        v50 = 2080;
        v51 = " ";
        v52 = 1024;
        v53 = v11;
        v54 = 1024;
        LODWORD(v55[0]) = v12;
        v13 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata";
LABEL_29:
        v26 = v9;
        v27 = v10;
        v28 = 44;
LABEL_30:
        _os_log_impl(&dword_182FBE000, v26, v27, v13, buf, v28);
        goto LABEL_31;
      }
      goto LABEL_31;
    }
    if (!v44)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v9 = gconnectionLogObj;
      v10 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v23 = *(_DWORD *)(a3 + 176);
        v22 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447234;
        v47 = "http2_input_frame_metadata_reset";
        v48 = 2082;
        v49 = (void *)(a3 + 191);
        v50 = 2080;
        v51 = " ";
        v52 = 1024;
        v53 = v22;
        v54 = 1024;
        LODWORD(v55[0]) = v23;
        v13 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, backtrace limit exceeded";
        goto LABEL_29;
      }
LABEL_31:
      if (!v8)
        return;
      goto LABEL_32;
    }
    v14 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = gconnectionLogObj;
    v10 = type;
    v15 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (!v14)
    {
      if (!v15)
        goto LABEL_31;
      v25 = *(_DWORD *)(a3 + 176);
      v24 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447234;
      v47 = "http2_input_frame_metadata_reset";
      v48 = 2082;
      v49 = (void *)(a3 + 191);
      v50 = 2080;
      v51 = " ";
      v52 = 1024;
      v53 = v24;
      v54 = 1024;
      LODWORD(v55[0]) = v25;
      v13 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, no backtrace";
      goto LABEL_29;
    }
    if (v15)
    {
      v17 = *(_DWORD *)(a3 + 176);
      v16 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447490;
      v47 = "http2_input_frame_metadata_reset";
      v48 = 2082;
      v49 = (void *)(a3 + 191);
      v50 = 2080;
      v51 = " ";
      v52 = 1024;
      v53 = v16;
      v54 = 1024;
      LODWORD(v55[0]) = v17;
      WORD2(v55[0]) = 2082;
      *(_QWORD *)((char *)v55 + 6) = v14;
      v18 = "%{public}s %{public}s%s<i%u:s%d> frame has no metadata, dumping backtrace:%{public}s";
      v19 = v9;
      v20 = v10;
      v21 = 54;
LABEL_20:
      _os_log_impl(&dword_182FBE000, v19, v20, v18, buf, v21);
      goto LABEL_21;
    }
    goto LABEL_21;
  }
  if (!a2)
  {
    v31 = "";
LABEL_47:
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    if (a2)
      v34 = (const char *)(a2 + 378);
    else
      v34 = "";
    v35 = *(_DWORD *)(a2 + 368);
    *(_DWORD *)buf = 136446978;
    v47 = "http2_input_frame_metadata_reset";
    v48 = 2082;
    v49 = (void *)v34;
    v50 = 2080;
    v51 = v31;
    v52 = 1024;
    v53 = v35;
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v8, &type, &v44))
      goto LABEL_31;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v36 = gconnectionLogObj;
      v37 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_31;
      v38 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)buf = 136446978;
      v47 = "http2_input_frame_metadata_reset";
      v48 = 2082;
      v49 = (void *)v34;
      v50 = 2080;
      v51 = v31;
      v52 = 1024;
      v53 = v38;
      v13 = "%{public}s %{public}s%s<i%u> frame has no metadata";
    }
    else
    {
      v39 = v31;
      if (v44)
      {
        v14 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v36 = gconnectionLogObj;
        v37 = type;
        v40 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v14)
        {
          if (v40)
          {
            v41 = *(_DWORD *)(a2 + 368);
            *(_DWORD *)buf = 136447234;
            v47 = "http2_input_frame_metadata_reset";
            v48 = 2082;
            v49 = (void *)v34;
            v50 = 2080;
            v51 = v39;
            v52 = 1024;
            v53 = v41;
            v54 = 2082;
            v55[0] = v14;
            v18 = "%{public}s %{public}s%s<i%u> frame has no metadata, dumping backtrace:%{public}s";
            v19 = v36;
            v20 = v37;
            v21 = 48;
            goto LABEL_20;
          }
LABEL_21:
          free(v14);
          if (!v8)
            return;
LABEL_32:
          free(v8);
          return;
        }
        if (!v40)
          goto LABEL_31;
        v43 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)buf = 136446978;
        v47 = "http2_input_frame_metadata_reset";
        v48 = 2082;
        v49 = (void *)v34;
        v50 = 2080;
        v51 = v39;
        v52 = 1024;
        v53 = v43;
        v13 = "%{public}s %{public}s%s<i%u> frame has no metadata, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v36 = gconnectionLogObj;
        v37 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_31;
        v42 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)buf = 136446978;
        v47 = "http2_input_frame_metadata_reset";
        v48 = 2082;
        v49 = (void *)v34;
        v50 = 2080;
        v51 = v31;
        v52 = 1024;
        v53 = v42;
        v13 = "%{public}s %{public}s%s<i%u> frame has no metadata, backtrace limit exceeded";
      }
    }
    v26 = v36;
    v27 = v37;
    v28 = 38;
    goto LABEL_30;
  }
  if ((*(__int16 *)(a2 + 376) & 0x80000000) == 0)
  {
    v31 = " ";
    goto LABEL_47;
  }
}

uint64_t ___ZL22on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke(uint64_t result, char *__s1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;

  v2 = result;
  if (__s1)
  {
    result = strcmp(__s1, "?1");
    v3 = ((_DWORD)result == 0) << 17;
  }
  else
  {
    v3 = 0;
  }
  v4 = *(_QWORD *)(v2 + 32);
  v5 = *(unsigned __int16 *)(v4 + 188);
  v4 += 188;
  v6 = (v5 | (*(unsigned __int8 *)(v4 + 2) << 16)) & 0xFFFDFFFF | v3;
  *(_WORD *)v4 = v6;
  *(_BYTE *)(v4 + 2) = BYTE2(v6);
  return result;
}

uint64_t ___ZL22on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2(uint64_t result, char *__s1)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;

  v2 = result;
  if (__s1)
  {
    result = strcmp(__s1, "connect-udp");
    if ((_DWORD)result)
    {
      result = strcmp(__s1, "connect-ip");
      v4 = ((_DWORD)result == 0) << 18;
    }
    else
    {
      v4 = 0x40000;
    }
  }
  else
  {
    v4 = 0;
  }
  v5 = *(_QWORD *)(v2 + 32);
  v6 = *(unsigned __int16 *)(v5 + 188);
  v5 += 188;
  v7 = (v6 | (*(unsigned __int8 *)(v5 + 2) << 16)) & 0xFFFBFFFF | v4;
  *(_WORD *)v5 = v7;
  *(_BYTE *)(v5 + 2) = BYTE2(v7);
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>>>::remove(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)a2[1];
  v4 = a3[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*a2 + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a3);
  if (v7 == a2 + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a3)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a3 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*a2 + 8 * v4) = 0;
  }
  v10 = *a3;
  if (*a3)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*a2 + 8 * v11) = v7;
      v10 = *a3;
    }
  }
  *v7 = v10;
  *a3 = 0;
  --a2[3];
  *(_QWORD *)result = a3;
  *(_QWORD *)(result + 8) = a2 + 2;
  *(_BYTE *)(result + 16) = 1;
  return result;
}

void nw_http2_connection_receive_goaway(uint64_t a1, uint64_t a2)
{
  int v2;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  _QWORD v8[5];
  int v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v2 = a2;
  v20 = *MEMORY[0x1E0C80C00];
  if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v7 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      v11 = "nw_http2_connection_receive_goaway";
      v12 = 2082;
      v13 = a1 + 378;
      v14 = 2080;
      v15 = " ";
      v16 = 1024;
      v17 = v7;
      v18 = 1024;
      v19 = v2;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received complete GOAWAY frame, last_stream_id %d", buf, 0x2Cu);
    }
  }
  *(_WORD *)(a1 + 376) |= 2u;
  v4 = *(char **)(a1 + 160);
  if (v4)
  {
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = ___ZL34nw_http2_connection_receive_goawayP17nw_protocol_http2i_block_invoke;
    v8[3] = &__block_descriptor_tmp_54_82068;
    v8[4] = a1;
    v9 = v2;
    nw_hash_table_apply(v4, (uint64_t)v8);
  }
  v5 = *(_QWORD *)(a1 + 88);
  if (v5)
  {
    if (*(_QWORD *)v5)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v5, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    }
    else
    {
      *(_OWORD *)(v5 + 32) = xmmword_183C6F190;
      if (*(_BYTE *)(v5 + 48))
      {
        if (*(_BYTE *)(v5 + 49))
          nw_queue_source_run_timer(v5, a2);
      }
    }
  }
}

uint64_t ___ZL34nw_http2_connection_receive_goawayP17nw_protocol_http2i_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t object;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  const char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint32_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  BOOL v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  NSObject *v28;
  int v29;
  int v30;
  NSObject *v31;
  int v32;
  int v33;
  int v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  _BYTE v43[20];
  __int16 v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  object = nw_hash_node_get_object(a2);
  if (object)
  {
    v5 = object;
    if (*(_DWORD *)(object + 176) <= *(_DWORD *)(a1 + 40))
    {
      if (((*(unsigned __int16 *)(object + 188) | (*(unsigned __int8 *)(object + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v23 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v25 = *(_DWORD *)(v5 + 176);
          v24 = *(_DWORD *)(v5 + 180);
          v26 = *(_DWORD *)(a1 + 40);
          v34 = 136448002;
          v35 = "nw_http2_connection_receive_goaway_block_invoke";
          v36 = 2082;
          v37 = (const char *)(v5 + 191);
          v38 = 2080;
          v39 = " ";
          v40 = 1024;
          v41 = v24;
          v42 = 1024;
          *(_DWORD *)v43 = v25;
          *(_WORD *)&v43[4] = 2048;
          *(_QWORD *)&v43[6] = a2;
          *(_WORD *)&v43[14] = 1024;
          *(_DWORD *)&v43[16] = v25;
          v44 = 1024;
          v45 = v26;
          v12 = "%{public}s %{public}s%s<i%u:s%d> stream in node %p in id table will remain active because its stream id "
                "(%d) is less than %d, skipping";
          v13 = v23;
          v14 = OS_LOG_TYPE_ERROR;
          v15 = 66;
          goto LABEL_28;
        }
      }
    }
    else
    {
      v6 = *(_QWORD *)nw_hash_node_get_extra(a2);
      v7 = *(_DWORD *)(v5 + 176);
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v28 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v30 = *(_DWORD *)(v5 + 176);
          v29 = *(_DWORD *)(v5 + 180);
          v34 = 136447490;
          v35 = "nw_http2_connection_receive_goaway_block_invoke";
          v36 = 2082;
          v37 = (const char *)(v5 + 191);
          v38 = 2080;
          v39 = " ";
          v40 = 1024;
          v41 = v29;
          v42 = 1024;
          *(_DWORD *)v43 = v30;
          *(_WORD *)&v43[4] = 1024;
          *(_DWORD *)&v43[6] = v30;
          _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> closing stream %d", (uint8_t *)&v34, 0x32u);
        }
      }
      nw_http2_stream_close(*(_QWORD *)(a1 + 32), v5);
      v8 = (*(unsigned __int8 *)(v5 + 190) >> 3) & 1;
      if (!gLogDatapath)
        LOBYTE(v8) = 1;
      if (v6)
      {
        if ((v8 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v9 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v11 = *(_DWORD *)(v5 + 176);
            v10 = *(_DWORD *)(v5 + 180);
            v34 = 136447746;
            v35 = "nw_http2_connection_receive_goaway_block_invoke";
            v36 = 2082;
            v37 = (const char *)(v5 + 191);
            v38 = 2080;
            v39 = " ";
            v40 = 1024;
            v41 = v10;
            v42 = 1024;
            *(_DWORD *)v43 = v11;
            *(_WORD *)&v43[4] = 1024;
            *(_DWORD *)&v43[6] = v7;
            *(_WORD *)&v43[10] = 2048;
            *(_QWORD *)&v43[12] = v5;
            v12 = "%{public}s %{public}s%s<i%u:s%d> deferring release of stream %d (%p), has associated input handler";
            v13 = v9;
            v14 = OS_LOG_TYPE_DEBUG;
            v15 = 60;
LABEL_28:
            _os_log_impl(&dword_182FBE000, v13, v14, v12, (uint8_t *)&v34, v15);
          }
        }
      }
      else
      {
        if ((v8 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v31 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v33 = *(_DWORD *)(v5 + 176);
            v32 = *(_DWORD *)(v5 + 180);
            v34 = 136447746;
            v35 = "nw_http2_connection_receive_goaway_block_invoke";
            v36 = 2082;
            v37 = (const char *)(v5 + 191);
            v38 = 2080;
            v39 = " ";
            v40 = 1024;
            v41 = v32;
            v42 = 1024;
            *(_DWORD *)v43 = v33;
            *(_WORD *)&v43[4] = 1024;
            *(_DWORD *)&v43[6] = v7;
            *(_WORD *)&v43[10] = 2048;
            *(_QWORD *)&v43[12] = v5;
            _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> destroying stream %d (%p) immediately, no associated input handler", (uint8_t *)&v34, 0x3Cu);
          }
        }
        nw_http2_stream_destroy((void **)v5);
      }
    }
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 32);
    if (!v16 || (*(__int16 *)(v16 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v18 = *(_QWORD *)(a1 + 32);
        v19 = (const char *)(v18 + 378);
        v20 = "";
        v21 = v18 == 0;
        v22 = *(_DWORD *)(v18 + 368);
        v35 = "nw_http2_connection_receive_goaway_block_invoke";
        if (v21)
          v19 = "";
        v36 = 2082;
        v34 = 136447234;
        if (!v21)
          v20 = " ";
        v37 = v19;
        v38 = 2080;
        v39 = v20;
        v40 = 1024;
        v41 = v22;
        v42 = 2048;
        *(_QWORD *)v43 = a2;
        v12 = "%{public}s %{public}s%s<i%u> stream in node %p in id table is NULL, skipping";
        v13 = v17;
        v14 = OS_LOG_TYPE_ERROR;
        v15 = 48;
        goto LABEL_28;
      }
    }
  }
  return 1;
}

void std::destroy_at[abi:nn180100]<http2_stream,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  if ((*(_BYTE *)(a1 + 168) & 1) != 0)
  {
    v2 = *(void **)(a1 + 160);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 160) = 0;
  if ((*(_BYTE *)(a1 + 152) & 1) != 0)
  {
    v3 = *(void **)(a1 + 144);
    if (v3)
      os_release(v3);
  }
  *(_QWORD *)(a1 + 144) = 0;
  v4 = *(void **)(a1 + 120);
  if (v4)
  {
    *(_QWORD *)(a1 + 128) = v4;
    operator delete(v4);
  }
}

void nw_http2_stream_init(uint64_t a1)
{
  int v2;
  uint64_t v3;
  char v4;
  void *v5;
  _BOOL8 v6;
  char v7;
  void *v8;
  _WORD *v9;
  __int16 v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = a1;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = a1 + 16;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    v2 = *(_WORD *)(a1 + 188) & 0xEFFF | (*(unsigned __int8 *)(a1 + 190) << 16);
    *(_WORD *)(a1 + 188) &= ~0x1000u;
    *(_BYTE *)(a1 + 190) = BYTE2(v2);
    v3 = _nw_http_parsed_fields_create();
    v4 = *(_BYTE *)(a1 + 152);
    if ((v4 & 1) != 0)
    {
      v5 = *(void **)(a1 + 144);
      if (v5)
      {
        os_release(v5);
        v4 = *(_BYTE *)(a1 + 152);
      }
    }
    *(_QWORD *)(a1 + 144) = v3;
    *(_BYTE *)(a1 + 152) = v4 | 1;
    v6 = nw_array_create();
    v7 = *(_BYTE *)(a1 + 168);
    if ((v7 & 1) != 0)
    {
      v8 = *(void **)(a1 + 160);
      if (v8)
      {
        os_release(v8);
        v7 = *(_BYTE *)(a1 + 168);
      }
    }
    v10 = *(_WORD *)(a1 + 188);
    v9 = (_WORD *)(a1 + 188);
    *(_QWORD *)(v9 - 14) = v6;
    *((_BYTE *)v9 - 20) = v7 | 1;
    *((_DWORD *)v9 - 3) = -1;
    *((_DWORD *)v9 - 1) = 0x200000;
    *v9 = v10 & 0xFE62 | 4;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_http2_stream_init";
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_http2_stream_init";
      v14 = "%{public}s called with null stream";
      goto LABEL_23;
    }
    if (!v17)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_http2_stream_init";
      v14 = "%{public}s called with null stream, backtrace limit exceeded";
      goto LABEL_23;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v16 = os_log_type_enabled(v12, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_http2_stream_init";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_24;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v20 = "nw_http2_stream_init";
      v14 = "%{public}s called with null stream, no backtrace";
LABEL_23:
      _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
    }
  }
LABEL_24:
  if (v11)
    free(v11);
}

uint64_t nw_http2_add_to_id_table(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t internal;
  _BOOL8 v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  const char *v12;
  NSObject *v13;
  os_log_type_t v14;
  int v15;
  int v16;
  const char *v17;
  char *v18;
  _BOOL4 v19;
  int v20;
  int v21;
  const char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  char *backtrace_string;
  _BOOL4 v27;
  const char *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  char *v33;
  NSObject *v35;
  int v36;
  int v37;
  NSObject *v38;
  int v39;
  int v40;
  _BOOL4 v41;
  NSObject *v42;
  int v43;
  int v44;
  char v45;
  os_log_type_t type;
  os_log_type_t v47;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  _BYTE v59[18];
  __int16 v60;
  uint64_t v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_http2_add_to_id_table";
    v22 = (const char *)_os_log_send_and_compose_impl();
    v47 = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, &v47, &type))
      goto LABEL_54;
    if (v47 == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = v47;
      if (!os_log_type_enabled(v23, v47))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_http2_add_to_id_table";
      v25 = "%{public}s called with null stream";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = v47;
      v41 = os_log_type_enabled(v23, v47);
      if (backtrace_string)
      {
        if (!v41)
          goto LABEL_39;
        *(_DWORD *)buf = 136446466;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = backtrace_string;
        v28 = "%{public}s called with null stream, dumping backtrace:%{public}s";
        goto LABEL_38;
      }
      if (!v41)
      {
LABEL_54:
        if (v22)
        {
          v33 = (char *)v22;
          goto LABEL_56;
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v49 = "nw_http2_add_to_id_table";
      v25 = "%{public}s called with null stream, no backtrace";
    }
    else
    {
      v23 = __nwlog_obj();
      v24 = v47;
      if (!os_log_type_enabled(v23, v47))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_http2_add_to_id_table";
      v25 = "%{public}s called with null stream, backtrace limit exceeded";
    }
LABEL_53:
    _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0xCu);
    goto LABEL_54;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v35 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v37 = *(_DWORD *)(a2 + 176);
      v36 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447746;
      v49 = "nw_http2_add_to_id_table";
      v50 = 2082;
      v51 = (char *)(a2 + 191);
      v52 = 2080;
      v53 = " ";
      v54 = 1024;
      v55 = v36;
      v56 = 1024;
      v57 = v37;
      v58 = 1024;
      *(_DWORD *)v59 = v37;
      *(_WORD *)&v59[4] = 2048;
      *(_QWORD *)&v59[6] = a2;
      _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d (%p)", buf, 0x3Cu);
    }
  }
  v47 = OS_LOG_TYPE_DEFAULT;
  internal = *(_QWORD *)(a1 + 160);
  if (!internal)
  {
    internal = nw_hash_table_create_internal(0x11u, 8, (const void *(*)(const void *, unsigned int *))stream_get_key, (unsigned int (*)(const void *, unsigned int))stream_key_hash, (BOOL (*)(const void *, const void *, unsigned int))stream_matches_key, 0);
    if (internal)
    {
      *(_DWORD *)(internal + 48) &= ~2u;
      *(_QWORD *)(a1 + 160) = internal;
      goto LABEL_7;
    }
    *(_QWORD *)(a1 + 160) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_http2_add_to_id_table";
    v22 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v22, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_http2_add_to_id_table";
        v25 = "%{public}s nw_hash_table_create_no_lock failed";
        goto LABEL_53;
      }
      if (!v45)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_http2_add_to_id_table";
        v25 = "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded";
        goto LABEL_53;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = gLogObj;
      v24 = type;
      v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!backtrace_string)
      {
        if (!v27)
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_http2_add_to_id_table";
        v25 = "%{public}s nw_hash_table_create_no_lock failed, no backtrace";
        goto LABEL_53;
      }
      if (!v27)
      {
LABEL_39:
        free(backtrace_string);
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446466;
      v49 = "nw_http2_add_to_id_table";
      v50 = 2082;
      v51 = backtrace_string;
      v28 = "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s";
LABEL_38:
      _os_log_impl(&dword_182FBE000, v23, v24, v28, buf, 0x16u);
      goto LABEL_39;
    }
    goto LABEL_54;
  }
LABEL_7:
  v7 = nw_hash_table_add_object(internal, a2, (char *)&v47);
  v8 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
  if (v47 == OS_LOG_TYPE_DEFAULT)
  {
    if ((v8 & 0x80000) != 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v11 = *(_DWORD *)(a2 + 176);
    v10 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)buf = 136447490;
    v49 = "nw_http2_add_to_id_table";
    v50 = 2082;
    v51 = (char *)(a2 + 191);
    v52 = 2080;
    v53 = " ";
    v54 = 1024;
    v55 = v10;
    v56 = 1024;
    v57 = v11;
    v58 = 1024;
    *(_DWORD *)v59 = v11;
    v12 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v12, &type, &v45))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = gconnectionLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v16 = *(_DWORD *)(a2 + 176);
        v15 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v15;
        v56 = 1024;
        v57 = v16;
        v58 = 1024;
        *(_DWORD *)v59 = v16;
        v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d";
LABEL_46:
        _os_log_impl(&dword_182FBE000, v13, v14, v17, buf, 0x32u);
      }
    }
    else if (v45)
    {
      v18 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = gconnectionLogObj;
      v14 = type;
      v19 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (!v18)
      {
        if (!v19)
          goto LABEL_47;
        v32 = *(_DWORD *)(a2 + 176);
        v31 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v31;
        v56 = 1024;
        v57 = v32;
        v58 = 1024;
        *(_DWORD *)v59 = v32;
        v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, no backtrace";
        goto LABEL_46;
      }
      if (v19)
      {
        v21 = *(_DWORD *)(a2 + 176);
        v20 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447746;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v20;
        v56 = 1024;
        v57 = v21;
        v58 = 1024;
        *(_DWORD *)v59 = v21;
        *(_WORD *)&v59[4] = 2082;
        *(_QWORD *)&v59[6] = v18;
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, dumping backtrace:%{public}s", buf, 0x3Cu);
      }
      free(v18);
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = gconnectionLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v30 = *(_DWORD *)(a2 + 176);
        v29 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v29;
        v56 = 1024;
        v57 = v30;
        v58 = 1024;
        *(_DWORD *)v59 = v30;
        v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, backtrace limit exceeded";
        goto LABEL_46;
      }
    }
LABEL_47:
    if (v12)
    {
      v33 = (char *)v12;
LABEL_56:
      free(v33);
      return 0;
    }
    return 0;
  }
  v9 = v7;
  if ((v8 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v38 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v40 = *(_DWORD *)(a2 + 176);
      v39 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v49 = "nw_http2_add_to_id_table";
      v50 = 2082;
      v51 = (char *)(a2 + 191);
      v52 = 2080;
      v53 = " ";
      v54 = 1024;
      v55 = v39;
      v56 = 1024;
      v57 = v40;
      v58 = 1024;
      *(_DWORD *)v59 = v40;
      _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> added stream %d to stream id hash table", buf, 0x32u);
    }
  }
  if (a3)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v44 = *(_DWORD *)(a2 + 176);
        v43 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136448002;
        v49 = "nw_http2_add_to_id_table";
        v50 = 2082;
        v51 = (char *)(a2 + 191);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v43;
        v56 = 1024;
        v57 = v44;
        v58 = 2048;
        *(_QWORD *)v59 = a2;
        *(_WORD *)&v59[8] = 2048;
        *(_QWORD *)&v59[10] = v9;
        v60 = 2048;
        v61 = a3;
        _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> connecting stream %p node %p with protocol %p", buf, 0x4Au);
      }
    }
    *(_QWORD *)nw_hash_node_get_extra(v9) = a3;
  }
  return v9;
}

uint64_t stream_get_key(uint64_t a1, _DWORD *a2)
{
  *a2 = 4;
  return a1 + 176;
}

BOOL stream_matches_key(uint64_t a1, _DWORD *a2)
{
  return *(_DWORD *)(a1 + 176) == *a2;
}

void nw_protocol_http2_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  char *handle;
  char *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint32_t v11;
  uint64_t v12;
  int v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  char *backtrace_string;
  _BOOL4 v19;
  char *v20;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  _QWORD v24[6];
  int v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_http2_error";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_error";
      v17 = "%{public}s called with null protocol";
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_http2_error";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_61:
        if (!v14)
          return;
        goto LABEL_62;
      }
      if (!v19)
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_error";
      v17 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_error";
      v17 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_60;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_http2_error";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26))
      goto LABEL_61;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (!os_log_type_enabled(v15, type))
          goto LABEL_61;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_http2_error";
        v17 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_60;
      }
      v20 = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v21 = os_log_type_enabled(v15, type);
      if (!v20)
      {
        if (!v21)
          goto LABEL_61;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_http2_error";
        v17 = "%{public}s called with null http2, no backtrace";
        goto LABEL_60;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_protocol_http2_error";
        v30 = 2082;
        v31 = v20;
        v22 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_45:
        _os_log_impl(&dword_182FBE000, v15, v16, v22, buf, 0x16u);
      }
LABEL_46:
      free(v20);
      if (!v14)
        return;
LABEL_62:
      free(v14);
      return;
    }
    v15 = __nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type))
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_http2_error";
    v17 = "%{public}s called with null http2";
LABEL_60:
    _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
    goto LABEL_61;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_http2_error";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_error";
      v17 = "%{public}s called with null other_protocol";
      goto LABEL_60;
    }
    if (!v26)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_error";
      v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_60;
    }
    v20 = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = type;
    v23 = os_log_type_enabled(v15, type);
    if (!v20)
    {
      if (!v23)
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_error";
      v17 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_60;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_http2_error";
      v30 = 2082;
      v31 = v20;
      v22 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_45;
    }
    goto LABEL_46;
  }
  if (a3)
  {
    v5 = (char *)*((_QWORD *)handle + 19);
    if (v5)
    {
      v24[0] = MEMORY[0x1E0C809B0];
      v24[1] = 0x40000000;
      v24[2] = ___ZL23nw_protocol_http2_errorP11nw_protocolS0_i_block_invoke;
      v24[3] = &__block_descriptor_tmp_18_82223;
      v25 = a3;
      v24[4] = handle;
      v24[5] = a2;
      nw_hash_table_apply(v5, (uint64_t)v24);
      return;
    }
    if ((*((__int16 *)handle + 188) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v12 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v13 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v29 = "nw_protocol_http2_error";
        v30 = 2082;
        v31 = handle + 378;
        v32 = 2080;
        v33 = " ";
        v34 = 1024;
        v35 = v13;
        v36 = 1024;
        v37 = a3;
        v8 = "%{public}s %{public}s%s<i%u> cannot pass error %d up the stack, protocol table is NULL";
        v9 = v12;
        v10 = OS_LOG_TYPE_ERROR;
        v11 = 44;
        goto LABEL_18;
      }
    }
  }
  else if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v7 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v29 = "nw_protocol_http2_error";
      v30 = 2082;
      v31 = handle + 378;
      v32 = 2080;
      v33 = " ";
      v34 = 1024;
      v35 = v7;
      v8 = "%{public}s %{public}s%s<i%u> suppressing error 0";
      v9 = v6;
      v10 = OS_LOG_TYPE_DEBUG;
      v11 = 38;
LABEL_18:
      _os_log_impl(&dword_182FBE000, v9, v10, v8, buf, v11);
    }
  }
}

uint64_t ___ZL23nw_protocol_http2_errorP11nw_protocolS0_i_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t object;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  const char *v9;
  NSObject *v10;
  os_log_type_t v11;
  int v12;
  int v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  int v36;
  BOOL v37;
  const char *v38;
  int v39;
  const char *v40;
  NSObject *v41;
  uint32_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  BOOL v50;
  int v51;
  const char *v52;
  const char *v53;
  NSObject *v54;
  os_log_type_t v55;
  uint64_t v56;
  const char *v57;
  BOOL v58;
  int v59;
  const char *v60;
  const char *v61;
  char *v62;
  _BOOL4 v63;
  uint64_t v64;
  const char *v65;
  BOOL v66;
  int v67;
  const char *v68;
  uint64_t v69;
  const char *v70;
  BOOL v71;
  int v72;
  const char *v73;
  uint64_t v74;
  const char *v75;
  BOOL v76;
  int v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  const char *v82;
  int v83;
  BOOL v84;
  const char *v85;
  int v86;
  char v87;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v90;
  __int16 v91;
  const char *v92;
  __int16 v93;
  const char *v94;
  __int16 v95;
  int v96;
  __int16 v97;
  _BYTE v98[24];
  uint64_t v99;

  v99 = *MEMORY[0x1E0C80C00];
  object = nw_hash_node_get_object(a2);
  v5 = *(_QWORD *)nw_hash_node_get_extra(a2);
  if (!object)
  {
    if (v5)
    {
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) != 0)
        return 1;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v8 = *(_DWORD *)(v5 + 176);
      v7 = *(_DWORD *)(v5 + 180);
      *(_DWORD *)buf = 136447490;
      v90 = "nw_protocol_http2_error_block_invoke";
      v91 = 2082;
      v92 = (const char *)(v5 + 191);
      v93 = 2080;
      v94 = " ";
      v95 = 1024;
      v96 = v7;
      v97 = 1024;
      *(_DWORD *)v98 = v8;
      *(_WORD *)&v98[4] = 2048;
      *(_QWORD *)&v98[6] = a2;
      v9 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v87 = 0;
      if (!__nwlog_fault(v9, &type, &v87))
        goto LABEL_32;
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v10 = gconnectionLogObj;
        v11 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_32;
        v13 = *(_DWORD *)(v5 + 176);
        v12 = *(_DWORD *)(v5 + 180);
        *(_DWORD *)buf = 136447490;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = (const char *)(v5 + 191);
        v93 = 2080;
        v94 = " ";
        v95 = 1024;
        v96 = v12;
        v97 = 1024;
        *(_DWORD *)v98 = v13;
        *(_WORD *)&v98[4] = 2048;
        *(_QWORD *)&v98[6] = a2;
        v14 = "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol";
      }
      else if (v87)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v10 = gconnectionLogObj;
        v11 = type;
        v16 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (backtrace_string)
        {
          if (v16)
          {
            v18 = *(_DWORD *)(v5 + 176);
            v17 = *(_DWORD *)(v5 + 180);
            *(_DWORD *)buf = 136447746;
            v90 = "nw_protocol_http2_error_block_invoke";
            v91 = 2082;
            v92 = (const char *)(v5 + 191);
            v93 = 2080;
            v94 = " ";
            v95 = 1024;
            v96 = v17;
            v97 = 1024;
            *(_DWORD *)v98 = v18;
            *(_WORD *)&v98[4] = 2048;
            *(_QWORD *)&v98[6] = a2;
            *(_WORD *)&v98[14] = 2082;
            *(_QWORD *)&v98[16] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol, dumping backtrace:%{public}s", buf, 0x40u);
          }
          free(backtrace_string);
          goto LABEL_32;
        }
        if (!v16)
        {
LABEL_32:
          if (!v9)
            return 1;
          v23 = (char *)v9;
LABEL_34:
          free(v23);
          return 1;
        }
        v22 = *(_DWORD *)(v5 + 176);
        v21 = *(_DWORD *)(v5 + 180);
        *(_DWORD *)buf = 136447490;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = (const char *)(v5 + 191);
        v93 = 2080;
        v94 = " ";
        v95 = 1024;
        v96 = v21;
        v97 = 1024;
        *(_DWORD *)v98 = v22;
        *(_WORD *)&v98[4] = 2048;
        *(_QWORD *)&v98[6] = a2;
        v14 = "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v10 = gconnectionLogObj;
        v11 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_32;
        v20 = *(_DWORD *)(v5 + 176);
        v19 = *(_DWORD *)(v5 + 180);
        *(_DWORD *)buf = 136447490;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = (const char *)(v5 + 191);
        v93 = 2080;
        v94 = " ";
        v95 = 1024;
        v96 = v19;
        v97 = 1024;
        *(_DWORD *)v98 = v20;
        *(_WORD *)&v98[4] = 2048;
        *(_QWORD *)&v98[6] = a2;
        v14 = "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v10, v11, v14, buf, 0x36u);
      goto LABEL_32;
    }
    v47 = *(_QWORD *)(a1 + 32);
    if (v47 && *(__int16 *)(v47 + 376) < 0)
      return 1;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v48 = *(_QWORD *)(a1 + 32);
    v49 = (const char *)(v48 + 378);
    v50 = v48 == 0;
    v51 = *(_DWORD *)(v48 + 368);
    if (v50)
      v49 = "";
    *(_DWORD *)buf = 136447234;
    v90 = "nw_protocol_http2_error_block_invoke";
    if (v50)
      v52 = "";
    else
      v52 = " ";
    v91 = 2082;
    v92 = v49;
    v93 = 2080;
    v94 = v52;
    v95 = 1024;
    v96 = v51;
    v97 = 2048;
    *(_QWORD *)v98 = a2;
    v53 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v87 = 0;
    if (__nwlog_fault(v53, &type, &v87))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v54 = gconnectionLogObj;
        v55 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_109;
        v56 = *(_QWORD *)(a1 + 32);
        v57 = (const char *)(v56 + 378);
        v58 = v56 == 0;
        if (!v56)
          v57 = "";
        v59 = *(_DWORD *)(v56 + 368);
        if (v58)
          v60 = "";
        else
          v60 = " ";
        *(_DWORD *)buf = 136447234;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = v57;
        v93 = 2080;
        v94 = v60;
        v95 = 1024;
        v96 = v59;
        v97 = 2048;
        *(_QWORD *)v98 = a2;
        v61 = "%{public}s %{public}s%s<i%u> node %p did not contain protocol";
        goto LABEL_108;
      }
      if (!v87)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v54 = gconnectionLogObj;
        v55 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_109;
        v69 = *(_QWORD *)(a1 + 32);
        v70 = (const char *)(v69 + 378);
        v71 = v69 == 0;
        if (!v69)
          v70 = "";
        v72 = *(_DWORD *)(v69 + 368);
        if (v71)
          v73 = "";
        else
          v73 = " ";
        *(_DWORD *)buf = 136447234;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = v70;
        v93 = 2080;
        v94 = v73;
        v95 = 1024;
        v96 = v72;
        v97 = 2048;
        *(_QWORD *)v98 = a2;
        v61 = "%{public}s %{public}s%s<i%u> node %p did not contain protocol, backtrace limit exceeded";
        goto LABEL_108;
      }
      v62 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v54 = gconnectionLogObj;
      v55 = type;
      v63 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v62)
      {
        if (v63)
        {
          v64 = *(_QWORD *)(a1 + 32);
          v65 = (const char *)(v64 + 378);
          v66 = v64 == 0;
          if (!v64)
            v65 = "";
          v67 = *(_DWORD *)(v64 + 368);
          if (v66)
            v68 = "";
          else
            v68 = " ";
          *(_DWORD *)buf = 136447490;
          v90 = "nw_protocol_http2_error_block_invoke";
          v91 = 2082;
          v92 = v65;
          v93 = 2080;
          v94 = v68;
          v95 = 1024;
          v96 = v67;
          v97 = 2048;
          *(_QWORD *)v98 = a2;
          *(_WORD *)&v98[8] = 2082;
          *(_QWORD *)&v98[10] = v62;
          _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s %{public}s%s<i%u> node %p did not contain protocol, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(v62);
        goto LABEL_109;
      }
      if (v63)
      {
        v74 = *(_QWORD *)(a1 + 32);
        v75 = (const char *)(v74 + 378);
        v76 = v74 == 0;
        if (!v74)
          v75 = "";
        v77 = *(_DWORD *)(v74 + 368);
        if (v76)
          v78 = "";
        else
          v78 = " ";
        *(_DWORD *)buf = 136447234;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = v75;
        v93 = 2080;
        v94 = v78;
        v95 = 1024;
        v96 = v77;
        v97 = 2048;
        *(_QWORD *)v98 = a2;
        v61 = "%{public}s %{public}s%s<i%u> node %p did not contain protocol, no backtrace";
LABEL_108:
        _os_log_impl(&dword_182FBE000, v54, v55, v61, buf, 0x30u);
      }
    }
LABEL_109:
    if (!v53)
      return 1;
    v23 = (char *)v53;
    goto LABEL_34;
  }
  v6 = *(_QWORD *)(object + 24);
  if (v6 && *(_QWORD *)(v6 + 56))
  {
    if (v5)
    {
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) != 0 || !gLogDatapath)
        goto LABEL_7;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v43 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        goto LABEL_7;
      v45 = *(_DWORD *)(v5 + 176);
      v44 = *(_DWORD *)(v5 + 180);
      v46 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)buf = 136447746;
      v90 = "nw_protocol_http2_error_block_invoke";
      v91 = 2082;
      v92 = (const char *)(v5 + 191);
      v93 = 2080;
      v94 = " ";
      v95 = 1024;
      v96 = v44;
      v97 = 1024;
      *(_DWORD *)v98 = v45;
      *(_WORD *)&v98[4] = 1024;
      *(_DWORD *)&v98[6] = v46;
      *(_WORD *)&v98[10] = 2048;
      *(_QWORD *)&v98[12] = object;
      v40 = "%{public}s %{public}s%s<i%u:s%d> passing error %d to input protocol %p";
      v41 = v43;
      v42 = 60;
    }
    else
    {
      v32 = *(_QWORD *)(a1 + 32);
      if (v32 && *(__int16 *)(v32 + 376) < 0 || !gLogDatapath)
        goto LABEL_7;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v33 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        goto LABEL_7;
      v34 = *(_QWORD *)(a1 + 32);
      v35 = "";
      v36 = *(_DWORD *)(v34 + 368);
      v37 = v34 == 0;
      if (v34)
        v38 = (const char *)(v34 + 378);
      else
        v38 = "";
      v39 = *(_DWORD *)(a1 + 48);
      if (!v37)
        v35 = " ";
      *(_DWORD *)buf = 136447490;
      v90 = "nw_protocol_http2_error_block_invoke";
      v91 = 2082;
      v92 = v38;
      v93 = 2080;
      v94 = v35;
      v95 = 1024;
      v96 = v36;
      v97 = 1024;
      *(_DWORD *)v98 = v39;
      *(_WORD *)&v98[4] = 2048;
      *(_QWORD *)&v98[6] = object;
      v40 = "%{public}s %{public}s%s<i%u> passing error %d to input protocol %p";
      v41 = v33;
      v42 = 54;
    }
    _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, v40, buf, v42);
LABEL_7:
    (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(object + 24) + 56))(object, *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48));
    return 1;
  }
  if (v5)
  {
    if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v25 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v27 = *(_DWORD *)(v5 + 176);
        v26 = *(_DWORD *)(v5 + 180);
        v28 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)buf = 136447746;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = (const char *)(v5 + 191);
        v93 = 2080;
        v94 = " ";
        v95 = 1024;
        v96 = v26;
        v97 = 1024;
        *(_DWORD *)v98 = v27;
        *(_WORD *)&v98[4] = 2048;
        *(_QWORD *)&v98[6] = object;
        *(_WORD *)&v98[14] = 1024;
        *(_DWORD *)&v98[16] = v28;
        v29 = "%{public}s %{public}s%s<i%u:s%d> callbacks on protocol %p not set, cannot pass error %d";
        v30 = v25;
        v31 = 60;
LABEL_42:
        _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      }
    }
  }
  else
  {
    v79 = *(_QWORD *)(a1 + 32);
    if (!v79 || (*(__int16 *)(v79 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v80 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v81 = *(_QWORD *)(a1 + 32);
        v82 = "";
        v83 = *(_DWORD *)(v81 + 368);
        v84 = v81 == 0;
        if (v81)
          v85 = (const char *)(v81 + 378);
        else
          v85 = "";
        v86 = *(_DWORD *)(a1 + 48);
        if (!v84)
          v82 = " ";
        *(_DWORD *)buf = 136447490;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = v85;
        v93 = 2080;
        v94 = v82;
        v95 = 1024;
        v96 = v83;
        v97 = 2048;
        *(_QWORD *)v98 = object;
        *(_WORD *)&v98[8] = 1024;
        *(_DWORD *)&v98[10] = v86;
        v29 = "%{public}s %{public}s%s<i%u> callbacks on protocol %p not set, cannot pass error %d";
        v30 = v80;
        v31 = 54;
        goto LABEL_42;
      }
    }
  }
  return 1;
}

void ___ZL31nw_protocol_http2_get_callbacksv_block_invoke()
{
  qword_1EDCE47C0 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCE47C8 = nw_protocol_default_input_flush;
  qword_1EDCE4790 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCE4798 = nw_protocol_default_waiting_for_output;
  qword_1EDCE4750 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCE4758 = nw_protocol_default_unregister_notification;
  qword_1EDCE46E0 = (uint64_t)nw_protocol_http2_disconnect;
  unk_1EDCE46E8 = nw_protocol_http2_connected;
  qword_1EDCE4780 = (uint64_t)nw_protocol_http2_output_finished;
  unk_1EDCE4788 = nw_protocol_default_get_output_local;
  qword_1EDCE4770 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1EDCE4778 = nw_protocol_http2_input_finished;
  nw_protocol_http2_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_http2_add_input_handler;
  *(_QWORD *)algn_1EDCE46C8 = nw_protocol_http2_remove_input_handler;
  qword_1EDCE46D0 = (uint64_t)nw_protocol_http2_replace_input_handler;
  unk_1EDCE46D8 = nw_protocol_http2_connect;
  qword_1EDCE4700 = (uint64_t)nw_protocol_http2_input_available;
  unk_1EDCE4708 = nw_protocol_http2_output_available;
  qword_1EDCE4710 = (uint64_t)nw_protocol_http2_get_input_frames;
  unk_1EDCE4718 = nw_protocol_http2_get_output_frames;
  qword_1EDCE4730 = (uint64_t)nw_protocol_http2_get_parameters;
  unk_1EDCE4738 = nw_protocol_default_get_path;
  qword_1EDCE4720 = (uint64_t)nw_protocol_http2_finalize_output_frames;
  unk_1EDCE4728 = nw_protocol_default_link_state;
  qword_1EDCE47B0 = (uint64_t)nw_protocol_http2_remove_listen_handler;
  unk_1EDCE47B8 = nw_protocol_http2_stream_get_message_properties;
  qword_1EDCE4740 = (uint64_t)nw_protocol_default_get_local;
  unk_1EDCE4748 = nw_protocol_http2_get_remote_endpoint;
  qword_1EDCE46F0 = (uint64_t)nw_protocol_http2_disconnected;
  unk_1EDCE46F8 = nw_protocol_http2_error;
  qword_1EDCE4760 = (uint64_t)nw_protocol_http2_notify;
  unk_1EDCE4768 = nw_protocol_default_updated_path;
  qword_1EDCE47A0 = (uint64_t)nw_protocol_http2_copy_info;
  unk_1EDCE47A8 = nw_protocol_http2_add_listen_handler;
}

BOOL nw_protocol_http2_connect(nw_protocol *a1, nw_protocol *a2)
{
  __int16 *handle;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  _QWORD *output_handler_context;
  uint64_t v16;
  int v17;
  int v18;
  void *v19;
  _BYTE *v20;
  _BOOL4 v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _BOOL8 result;
  int v27;
  int v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  uint64_t v32;
  int v33;
  int v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  int v38;
  const char *v39;
  int v40;
  const char *v41;
  NSObject *v42;
  os_log_type_t v43;
  int v44;
  const char *v45;
  int v46;
  char *v47;
  _BOOL4 v48;
  int v49;
  char *v50;
  _BOOL4 v51;
  _BOOL4 v52;
  int v53;
  int v54;
  int v55;
  int v56;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  void (*connect)(nw_protocol *, nw_protocol *);
  int v60;
  char *v61;
  const char *v62;
  NSObject *v63;
  os_log_type_t v64;
  const char *v65;
  NSObject *v66;
  int v67;
  nw_protocol *v68;
  const char *v69;
  nw_protocol_identifier *identifier;
  char *v71;
  NSObject *v72;
  os_log_type_t v73;
  nw_protocol *v74;
  const char *v75;
  nw_protocol_identifier *v76;
  const char *v77;
  char *backtrace_string;
  _BOOL4 v79;
  const char *v80;
  _BOOL4 v81;
  _BOOL4 v82;
  NSObject *v83;
  int v84;
  char *v85;
  _BOOL4 v86;
  nw_protocol *v87;
  const char *v88;
  nw_protocol_identifier *v89;
  nw_protocol *v90;
  const char *v91;
  nw_protocol_identifier *v92;
  NSObject *v93;
  int v94;
  int v95;
  nw_protocol *v96;
  const char *v97;
  nw_protocol_identifier *v98;
  char v99;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v102;
  __int16 v103;
  char *v104;
  __int16 v105;
  const char *v106;
  __int16 v107;
  int v108;
  __int16 v109;
  _BYTE v110[10];
  _WORD v111[15];

  *(_QWORD *)&v111[11] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v102 = "nw_protocol_http2_connect";
    v62 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (!__nwlog_fault(v62, &type, &v99))
      goto LABEL_193;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v63 = __nwlog_obj();
      v64 = type;
      if (!os_log_type_enabled(v63, type))
        goto LABEL_193;
      *(_DWORD *)buf = 136446210;
      v102 = "nw_protocol_http2_connect";
      v65 = "%{public}s called with null protocol";
LABEL_192:
      _os_log_impl(&dword_182FBE000, v63, v64, v65, buf, 0xCu);
      goto LABEL_193;
    }
    if (!v99)
    {
      v63 = __nwlog_obj();
      v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v63 = __nwlog_obj();
    v64 = type;
    v79 = os_log_type_enabled(v63, type);
    if (!backtrace_string)
    {
      if (v79)
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    if (!v79)
      goto LABEL_167;
    *(_DWORD *)buf = 136446466;
    v102 = "nw_protocol_http2_connect";
    v103 = 2082;
    v104 = backtrace_string;
    v80 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_166:
    _os_log_impl(&dword_182FBE000, v63, v64, v80, buf, 0x16u);
    goto LABEL_167;
  }
  handle = (__int16 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v102 = "nw_protocol_http2_connect";
    v62 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (!__nwlog_fault(v62, &type, &v99))
      goto LABEL_193;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v63 = __nwlog_obj();
      v64 = type;
      if (!os_log_type_enabled(v63, type))
        goto LABEL_193;
      *(_DWORD *)buf = 136446210;
      v102 = "nw_protocol_http2_connect";
      v65 = "%{public}s called with null http2";
      goto LABEL_192;
    }
    if (!v99)
    {
      v63 = __nwlog_obj();
      v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v63 = __nwlog_obj();
    v64 = type;
    v81 = os_log_type_enabled(v63, type);
    if (!backtrace_string)
    {
      if (v81)
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null http2, no backtrace";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    if (!v81)
      goto LABEL_167;
    *(_DWORD *)buf = 136446466;
    v102 = "nw_protocol_http2_connect";
    v103 = 2082;
    v104 = backtrace_string;
    v80 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_166;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v102 = "nw_protocol_http2_connect";
    v62 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (!__nwlog_fault(v62, &type, &v99))
      goto LABEL_193;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v63 = __nwlog_obj();
      v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null other_protocol";
        goto LABEL_192;
      }
LABEL_193:
      if (!v62)
        return 0;
      v61 = (char *)v62;
      goto LABEL_122;
    }
    if (!v99)
    {
      v63 = __nwlog_obj();
      v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v63 = __nwlog_obj();
    v64 = type;
    v82 = os_log_type_enabled(v63, type);
    if (!backtrace_string)
    {
      if (v82)
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_protocol_http2_connect";
        v65 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = backtrace_string;
      v80 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_166;
    }
LABEL_167:
    free(backtrace_string);
    goto LABEL_193;
  }
  v5 = handle[188];
  if (v5 < 0)
  {
    if ((v5 & 8) == 0)
      goto LABEL_7;
LABEL_137:
    result = 1;
    if ((v5 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v83 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v84 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        v102 = "nw_protocol_http2_connect";
        v103 = 2082;
        v104 = (char *)(handle + 189);
        v105 = 2080;
        v106 = " ";
        v107 = 1024;
        v108 = v84;
        _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> tunnel already closed, ignoring connect with success", buf, 0x26u);
      }
      return 1;
    }
    return result;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v66 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v67 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)(handle + 189);
      v105 = 2080;
      v106 = " ";
      v107 = 1024;
      v108 = v67;
      _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  LOWORD(v5) = handle[188];
  if ((v5 & 8) != 0)
    goto LABEL_137;
LABEL_7:
  if (!*((_QWORD *)handle + 8))
  {
    v6 = mach_continuous_time();
    v7 = v6 <= 1 ? 1 : v6;
    *((_QWORD *)handle + 8) = v7;
    v8 = nw_protocol_copy_info(*((_QWORD *)handle + 4), 255);
    if (v8)
    {
      v9 = (void *)v8;
      v10 = *(_QWORD *)(v8 + 24);
      if (*(_QWORD *)(v8 + 16) != v10)
      {
        v11 = *(void **)(v10 - 8);
        if (v11)
        {
          v12 = os_retain(v11);
          if (v12)
          {
            v13 = v12;
            if (nw_protocol_metadata_is_tls(v12))
            {
              v14 = v13;
              nw_http_connection_metadata_set_sec_metadata(*((void **)handle + 32), v14);
              os_release(v14);
            }
            os_release(v13);
          }
        }
      }
      os_release(v9);
    }
  }
  output_handler_context = a2->output_handler_context;
  if ((handle[188] & 4) == 0)
  {
    if (!output_handler_context)
      goto LABEL_24;
    v16 = output_handler_context[4];
    if (v16)
    {
      v17 = *(unsigned __int16 *)(v16 + 188);
      v18 = v17 | (*(unsigned __int8 *)(v16 + 190) << 16);
      *(_WORD *)(v16 + 188) = v17 | 8;
      if ((v18 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v93 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v95 = *(_DWORD *)(v16 + 176);
          v94 = *(_DWORD *)(v16 + 180);
          *(_DWORD *)buf = 136447746;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)(v16 + 191);
          v105 = 2080;
          v106 = " ";
          v107 = 1024;
          v108 = v94;
          v109 = 1024;
          *(_DWORD *)v110 = v95;
          *(_WORD *)&v110[4] = 1024;
          *(_DWORD *)&v110[6] = v95;
          v111[0] = 2048;
          *(_QWORD *)&v111[1] = v16;
          _os_log_impl(&dword_182FBE000, v93, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> marked stream id %d (%p) as waiting for connect", buf, 0x3Cu);
        }
      }
LABEL_24:
      v19 = (void *)*((_QWORD *)handle + 14);
      if (v19)
      {
        v20 = v19;
        v21 = (v20[231] & 4) == 0;

        if (v21)
        {
          if ((handle[188] & 0x80000000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v22 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v23 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446978;
              v102 = "nw_protocol_http2_connect";
              v103 = 2082;
              v104 = (char *)(handle + 189);
              v105 = 2080;
              v106 = " ";
              v107 = 1024;
              v108 = v23;
              _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered", buf, 0x26u);
            }
          }
        }
        else
        {
          nw_endpoint_add_edges_for_instance(v20, (unsigned __int8 *)handle, 0);
        }
        goto LABEL_110;
      }
      if (handle[188] < 0)
        goto LABEL_110;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v34 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)(handle + 189);
      v105 = 2080;
      v106 = " ";
      v107 = 1024;
      v108 = v34;
      v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v99 = 0;
      if (__nwlog_fault(v35, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v36 = gconnectionLogObj;
          v37 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            goto LABEL_108;
          v38 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)(handle + 189);
          v105 = 2080;
          v106 = " ";
          v107 = 1024;
          v108 = v38;
          v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
          goto LABEL_107;
        }
        if (!v99)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v36 = gconnectionLogObj;
          v37 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            goto LABEL_108;
          v54 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)(handle + 189);
          v105 = 2080;
          v106 = " ";
          v107 = 1024;
          v108 = v54;
          v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
          goto LABEL_107;
        }
        v47 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v36 = gconnectionLogObj;
        v37 = type;
        v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v47)
        {
          if (v48)
          {
            v49 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136447234;
            v102 = "nw_protocol_http2_connect";
            v103 = 2082;
            v104 = (char *)(handle + 189);
            v105 = 2080;
            v106 = " ";
            v107 = 1024;
            v108 = v49;
            v109 = 2082;
            *(_QWORD *)v110 = v47;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s", buf, 0x30u);
          }
          free(v47);
          goto LABEL_108;
        }
        if (v48)
        {
          v56 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)(handle + 189);
          v105 = 2080;
          v106 = " ";
          v107 = 1024;
          v108 = v56;
          v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_107:
          _os_log_impl(&dword_182FBE000, v36, v37, v39, buf, 0x26u);
        }
      }
LABEL_108:
      if (v35)
        free(v35);
LABEL_110:
      output_handler = a1->output_handler;
      if (output_handler)
      {
        callbacks = output_handler->callbacks;
        if (callbacks)
        {
          connect = (void (*)(nw_protocol *, nw_protocol *))callbacks->connect;
          if (connect)
          {
            connect(output_handler, a1);
            return 1;
          }
        }
      }
      __nwlog_obj();
      v68 = a1->output_handler;
      v69 = "invalid";
      if (v68)
      {
        identifier = v68->identifier;
        if (identifier)
          v69 = (const char *)identifier;
      }
      *(_DWORD *)buf = 136446466;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)v69;
      v71 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v99 = 0;
      if (__nwlog_fault(v71, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v72 = __nwlog_obj();
          v73 = type;
          if (!os_log_type_enabled(v72, type))
            goto LABEL_210;
          v74 = a1->output_handler;
          v75 = "invalid";
          if (v74)
          {
            v76 = v74->identifier;
            if (v76)
              v75 = (const char *)v76;
          }
          *(_DWORD *)buf = 136446466;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)v75;
          v77 = "%{public}s protocol %{public}s has invalid connect callback";
          goto LABEL_209;
        }
        if (!v99)
        {
          v72 = __nwlog_obj();
          v73 = type;
          if (!os_log_type_enabled(v72, type))
            goto LABEL_210;
          v90 = a1->output_handler;
          v91 = "invalid";
          if (v90)
          {
            v92 = v90->identifier;
            if (v92)
              v91 = (const char *)v92;
          }
          *(_DWORD *)buf = 136446466;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)v91;
          v77 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
          goto LABEL_209;
        }
        v85 = (char *)__nw_create_backtrace_string();
        v72 = __nwlog_obj();
        v73 = type;
        v86 = os_log_type_enabled(v72, type);
        if (v85)
        {
          if (v86)
          {
            v87 = a1->output_handler;
            v88 = "invalid";
            if (v87)
            {
              v89 = v87->identifier;
              if (v89)
                v88 = (const char *)v89;
            }
            *(_DWORD *)buf = 136446722;
            v102 = "nw_protocol_http2_connect";
            v103 = 2082;
            v104 = (char *)v88;
            v105 = 2082;
            v106 = v85;
            _os_log_impl(&dword_182FBE000, v72, v73, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v85);
          goto LABEL_210;
        }
        if (v86)
        {
          v96 = a1->output_handler;
          v97 = "invalid";
          if (v96)
          {
            v98 = v96->identifier;
            if (v98)
              v97 = (const char *)v98;
          }
          *(_DWORD *)buf = 136446466;
          v102 = "nw_protocol_http2_connect";
          v103 = 2082;
          v104 = (char *)v97;
          v77 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
LABEL_209:
          _os_log_impl(&dword_182FBE000, v72, v73, v77, buf, 0x16u);
        }
      }
LABEL_210:
      if (v71)
        free(v71);
      return 1;
    }
    if (handle[188] < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v40 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447234;
    v102 = "nw_protocol_http2_connect";
    v103 = 2082;
    v104 = (char *)(handle + 189);
    v105 = 2080;
    v106 = " ";
    v107 = 1024;
    v108 = v40;
    v109 = 2048;
    *(_QWORD *)v110 = a2;
    v41 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (!__nwlog_fault(v41, &type, &v99))
      goto LABEL_120;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = gconnectionLogObj;
      v43 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
LABEL_63:
        v44 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v102 = "nw_protocol_http2_connect";
        v103 = 2082;
        v104 = (char *)(handle + 189);
        v105 = 2080;
        v106 = " ";
        v107 = 1024;
        v108 = v44;
        v109 = 2048;
        *(_QWORD *)v110 = a2;
        v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra";
LABEL_119:
        _os_log_impl(&dword_182FBE000, v42, v43, v45, buf, 0x30u);
      }
LABEL_120:
      if (v41)
      {
        v61 = (char *)v41;
LABEL_122:
        free(v61);
      }
      return 0;
    }
    if (v99)
    {
      v50 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = gconnectionLogObj;
      v43 = type;
      v51 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v50)
      {
        if (v51)
          goto LABEL_91;
        goto LABEL_92;
      }
      if (!v51)
        goto LABEL_120;
      goto LABEL_118;
    }
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v42 = gconnectionLogObj;
    v43 = type;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      goto LABEL_120;
    goto LABEL_100;
  }
  if (output_handler_context)
  {
    v24 = output_handler_context[4];
    if (!v24)
    {
      if (handle[188] < 0)
        return 0;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v46 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)(handle + 189);
      v105 = 2080;
      v106 = " ";
      v107 = 1024;
      v108 = v46;
      v109 = 2048;
      *(_QWORD *)v110 = a2;
      v41 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v99 = 0;
      if (!__nwlog_fault(v41, &type, &v99))
        goto LABEL_120;
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v42 = gconnectionLogObj;
        v43 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_63;
        goto LABEL_120;
      }
      if (v99)
      {
        v50 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v42 = gconnectionLogObj;
        v43 = type;
        v52 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v50)
        {
          if (v52)
          {
LABEL_91:
            v53 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136447490;
            v102 = "nw_protocol_http2_connect";
            v103 = 2082;
            v104 = (char *)(handle + 189);
            v105 = 2080;
            v106 = " ";
            v107 = 1024;
            v108 = v53;
            v109 = 2048;
            *(_QWORD *)v110 = a2;
            *(_WORD *)&v110[8] = 2082;
            *(_QWORD *)v111 = v50;
            _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, dumping backtrace:%{public}s", buf, 0x3Au);
          }
LABEL_92:
          free(v50);
          goto LABEL_120;
        }
        if (!v52)
          goto LABEL_120;
LABEL_118:
        v60 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v102 = "nw_protocol_http2_connect";
        v103 = 2082;
        v104 = (char *)(handle + 189);
        v105 = 2080;
        v106 = " ";
        v107 = 1024;
        v108 = v60;
        v109 = 2048;
        *(_QWORD *)v110 = a2;
        v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, no backtrace";
        goto LABEL_119;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = gconnectionLogObj;
      v43 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_120;
LABEL_100:
      v55 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)(handle + 189);
      v105 = 2080;
      v106 = " ";
      v107 = 1024;
      v108 = v55;
      v109 = 2048;
      *(_QWORD *)v110 = a2;
      v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, backtrace limit exceeded";
      goto LABEL_119;
    }
    if (nw_http2_stream_connect((uint64_t)handle, output_handler_context[4], (uint64_t)a2))
      return 1;
    if (((*(unsigned __int16 *)(v24 + 188) | (*(unsigned __int8 *)(v24 + 190) << 16)) & 0x80000) != 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v25 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v28 = *(_DWORD *)(v24 + 176);
      v27 = *(_DWORD *)(v24 + 180);
      *(_DWORD *)buf = 136447746;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)(v24 + 191);
      v105 = 2080;
      v106 = " ";
      v107 = 1024;
      v108 = v27;
      v109 = 1024;
      *(_DWORD *)v110 = v28;
      *(_WORD *)&v110[4] = 1024;
      *(_DWORD *)&v110[6] = v28;
      v111[0] = 2048;
      *(_QWORD *)&v111[1] = v24;
      v29 = "%{public}s %{public}s%s<i%u:s%d> nw_http2_stream_connect failed for stream id %d (%p)";
      v30 = v25;
      v31 = 60;
LABEL_44:
      _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      return 0;
    }
  }
  else
  {
    if (handle[188] < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v32 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v33 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      v102 = "nw_protocol_http2_connect";
      v103 = 2082;
      v104 = (char *)(handle + 189);
      v105 = 2080;
      v106 = " ";
      v107 = 1024;
      v108 = v33;
      v109 = 2048;
      *(_QWORD *)v110 = a2;
      v29 = "%{public}s %{public}s%s<i%u> connect called on protocol %p which is not in protocol hash table";
      v30 = v32;
      v31 = 48;
      goto LABEL_44;
    }
  }
  return result;
}

void nw_protocol_http2_connected(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*connected)(void);
  NSObject *v8;
  int v9;
  const char *v10;
  int v11;
  NSObject *v12;
  int v13;
  const char *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  NSObject *v19;
  int v20;
  char *backtrace_string;
  _BOOL4 v22;
  char *v23;
  _BOOL4 v24;
  const char *v25;
  _BOOL4 v26;
  __int16 v27;
  int v28;
  int v29;
  void *v30;
  _BYTE *v31;
  _BOOL4 v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  int v36;
  int v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  int v41;
  const char *v42;
  char *v43;
  _BOOL4 v44;
  int v45;
  int v46;
  int v47;
  char *v48;
  NSObject *v49;
  int v50;
  int v51;
  NSObject *v52;
  int v53;
  char v54;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v57;
  char *v58;
  char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v15, &type, &v54))
      goto LABEL_130;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null protocol";
    }
    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v22 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_130:
        if (!v15)
          return;
LABEL_131:
        free(v15);
        return;
      }
      if (!v22)
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_129;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v15, &type, &v54))
      goto LABEL_130;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v54)
      {
        v16 = __nwlog_obj();
        v17 = type;
        if (!os_log_type_enabled(v16, type))
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
        v18 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_129;
      }
      v23 = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v24 = os_log_type_enabled(v16, type);
      if (!v23)
      {
        if (!v24)
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
        v18 = "%{public}s called with null http2, no backtrace";
        goto LABEL_129;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v23;
        v25 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_55:
        _os_log_impl(&dword_182FBE000, v16, v17, v25, buf, 0x16u);
      }
LABEL_56:
      free(v23);
      if (!v15)
        return;
      goto LABEL_131;
    }
    v16 = __nwlog_obj();
    v17 = type;
    if (!os_log_type_enabled(v16, type))
      goto LABEL_130;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
    v18 = "%{public}s called with null http2";
LABEL_129:
    _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
    goto LABEL_130;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v15, &type, &v54))
      goto LABEL_130;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null other_protocol";
      goto LABEL_129;
    }
    if (!v54)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_129;
    }
    v23 = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v26 = os_log_type_enabled(v16, type);
    if (!v23)
    {
      if (!v26)
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_129;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v23;
      v25 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_55;
    }
    goto LABEL_56;
  }
  if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v19 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v20 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 378;
      *(_WORD *)&buf[22] = 2080;
      v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v20;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      connected = (void (*)(void))callbacks->connected;
      if (connected)
        connected();
    }
  }
  if (a1->output_handler != a2)
  {
    if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v8 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v9 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 378;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v9;
        v10 = "%{public}s %{public}s%s<i%u> connected protocol is not our output_handler, ignoring";
LABEL_69:
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, v10, buf, 0x26u);
        return;
      }
    }
    return;
  }
  v11 = *((__int16 *)handle + 188);
  if (v11 < 0)
  {
    if ((v11 & 0x80) == 0)
      goto LABEL_20;
  }
  else
  {
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v49 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v50 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 378;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v50;
        _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    LOWORD(v11) = *((_WORD *)handle + 188);
    if ((v11 & 0x80) == 0)
    {
LABEL_20:
      if ((v11 & 0x8000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v13 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 378;
          *(_WORD *)&buf[22] = 2080;
          v57 = " ";
          LOWORD(v58) = 1024;
          *(_DWORD *)((char *)&v58 + 2) = v13;
          v14 = "%{public}s %{public}s%s<i%u> not server, processing input without waiting";
LABEL_136:
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, v14, buf, 0x26u);
          goto LABEL_62;
        }
      }
      goto LABEL_62;
    }
  }
  if (!*((_QWORD *)handle + 18))
  {
    if ((v11 & 0x8000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v35 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v36 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 378;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v36;
        _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> no listen handler on server, deferring processing of input and connected state until listen handler is present", buf, 0x26u);
      }
    }
    *((_WORD *)handle + 188) |= 0x1000u;
    return;
  }
  if ((v11 & 0x8000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v12 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v51 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 378;
      *(_WORD *)&buf[22] = 2080;
      v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v51;
      v14 = "%{public}s %{public}s%s<i%u> listen handler present, processing input without waiting";
      goto LABEL_136;
    }
  }
LABEL_62:
  v27 = *((_WORD *)handle + 188);
  *((_WORD *)handle + 188) = v27 & 0xEFFF;
  if ((v27 & 0xC) == 0)
  {
    nw_http2_send_settings((uint64_t)handle);
    v29 = *((__int16 *)handle + 188);
    *((_WORD *)handle + 188) |= 4u;
    if ((v29 & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v52 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v53 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 378;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v53;
        _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2 tunnel is now connected", buf, 0x26u);
      }
    }
    v30 = (void *)*((_QWORD *)handle + 14);
    if (v30)
    {
      v31 = v30;
      v32 = (v31[231] & 4) == 0;

      if (v32)
      {
        if ((*((__int16 *)handle + 188) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v33 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v34 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 378;
            *(_WORD *)&buf[22] = 2080;
            v57 = " ";
            LOWORD(v58) = 1024;
            *(_DWORD *)((char *)&v58 + 2) = v34;
            _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered", buf, 0x26u);
          }
        }
      }
      else
      {
        nw_endpoint_add_edges_for_instance(v31, (unsigned __int8 *)handle, 1);
      }
      goto LABEL_111;
    }
    if (*((__int16 *)handle + 188) < 0)
    {
LABEL_111:
      nw_protocol_http2_process_input((uint64_t)handle);
      v48 = (char *)*((_QWORD *)handle + 19);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL35nw_protocol_http2_process_connectedP17nw_protocol_http2_block_invoke;
      v57 = (const char *)&__block_descriptor_tmp_46_82346;
      v58 = handle;
      nw_hash_table_apply(v48, (uint64_t)buf);
      return;
    }
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v37 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 378;
    *(_WORD *)&buf[22] = 2080;
    v57 = " ";
    LOWORD(v58) = 1024;
    *(_DWORD *)((char *)&v58 + 2) = v37;
    v38 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v38, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v39 = gconnectionLogObj;
        v40 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_109;
        v41 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 378;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v41;
        v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
        goto LABEL_108;
      }
      if (!v54)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v39 = gconnectionLogObj;
        v40 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_109;
        v46 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 378;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v46;
        v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
        goto LABEL_108;
      }
      v43 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v39 = gconnectionLogObj;
      v40 = type;
      v44 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v43)
      {
        if (v44)
        {
          v45 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 378;
          *(_WORD *)&buf[22] = 2080;
          v57 = " ";
          LOWORD(v58) = 1024;
          *(_DWORD *)((char *)&v58 + 2) = v45;
          HIWORD(v58) = 2082;
          v59 = v43;
          _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v43);
        goto LABEL_109;
      }
      if (v44)
      {
        v47 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 378;
        *(_WORD *)&buf[22] = 2080;
        v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v47;
        v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_108:
        _os_log_impl(&dword_182FBE000, v39, v40, v42, buf, 0x26u);
      }
    }
LABEL_109:
    if (v38)
      free(v38);
    goto LABEL_111;
  }
  if ((v27 & 0x8000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v8 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v28 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_process_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 378;
      *(_WORD *)&buf[22] = 2080;
      v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v28;
      v10 = "%{public}s %{public}s%s<i%u> tunnel already connected or closed, ignoring connected event";
      goto LABEL_69;
    }
  }
}

void nw_protocol_http2_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  _QWORD *output_handler_context;
  uint64_t v5;
  int v6;
  int v7;
  nw_protocol_callbacks *callbacks;
  void (*disconnected)(nw_protocol *, _DWORD *);
  uint64_t v10;
  int v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  NSObject *v21;
  int v22;
  char *backtrace_string;
  _BOOL4 v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  nw_protocol_identifier *identifier;
  const char *v30;
  NSObject *v31;
  os_log_type_t v32;
  nw_protocol_identifier *v33;
  const char *v34;
  char *v35;
  _BOOL4 v36;
  nw_protocol_identifier *v37;
  char *v38;
  _BOOL4 v39;
  nw_protocol_identifier *v40;
  nw_protocol_identifier *v41;
  char v42;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  nw_protocol_identifier *v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  nw_protocol *v53;
  __int16 v54;
  _QWORD *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_http2_disconnect";
    v17 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v17, &type, &v42))
      goto LABEL_84;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_84;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      v20 = "%{public}s called with null protocol";
    }
    else if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v24 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_protocol_http2_disconnect";
          v46 = 2082;
          v47 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_84:
        if (!v17)
          return;
        goto LABEL_85;
      }
      if (!v24)
        goto LABEL_84;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      v20 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_84;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      v20 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_83;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_http2_disconnect";
    v17 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v17, &type, &v42))
      goto LABEL_84;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v42)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (!os_log_type_enabled(v18, type))
          goto LABEL_84;
        *(_DWORD *)buf = 136446210;
        v45 = "nw_protocol_http2_disconnect";
        v20 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_83;
      }
      v25 = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v26 = os_log_type_enabled(v18, type);
      if (!v25)
      {
        if (!v26)
          goto LABEL_84;
        *(_DWORD *)buf = 136446210;
        v45 = "nw_protocol_http2_disconnect";
        v20 = "%{public}s called with null http2, no backtrace";
        goto LABEL_83;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v45 = "nw_protocol_http2_disconnect";
        v46 = 2082;
        v47 = (nw_protocol_identifier *)v25;
        v27 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_53:
        _os_log_impl(&dword_182FBE000, v18, v19, v27, buf, 0x16u);
      }
LABEL_54:
      free(v25);
      if (!v17)
        return;
LABEL_85:
      v38 = (char *)v17;
LABEL_86:
      free(v38);
      return;
    }
    v18 = __nwlog_obj();
    v19 = type;
    if (!os_log_type_enabled(v18, type))
      goto LABEL_84;
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_http2_disconnect";
    v20 = "%{public}s called with null http2";
LABEL_83:
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
    goto LABEL_84;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_http2_disconnect";
    v17 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v17, &type, &v42))
      goto LABEL_84;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_84;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      v20 = "%{public}s called with null other_protocol";
      goto LABEL_83;
    }
    if (!v42)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_84;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_83;
    }
    v25 = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v28 = os_log_type_enabled(v18, type);
    if (!v25)
    {
      if (!v28)
        goto LABEL_84;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_http2_disconnect";
      v20 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_83;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v45 = "nw_protocol_http2_disconnect";
      v46 = 2082;
      v47 = (nw_protocol_identifier *)v25;
      v27 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  if (((__int16)handle[94] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v21 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v22 = handle[92];
      *(_DWORD *)buf = 136446978;
      v45 = "nw_protocol_http2_disconnect";
      v46 = 2082;
      v47 = (nw_protocol_identifier *)((char *)handle + 378);
      v48 = 2080;
      v49 = " ";
      v50 = 1024;
      v51 = v22;
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    if ((__int16)handle[94] < 0)
      return;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v10 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      return;
    v11 = handle[92];
    *(_DWORD *)buf = 136446978;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = (nw_protocol_identifier *)((char *)handle + 378);
    v48 = 2080;
    v49 = " ";
    v50 = 1024;
    v51 = v11;
    v12 = "%{public}s %{public}s%s<i%u> attempting to disconnect on protocol that doesn't have entry in table, ignoring";
    v13 = v10;
    v14 = 38;
LABEL_22:
    _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return;
  }
  v5 = output_handler_context[4];
  if (!v5)
  {
    if ((__int16)handle[94] < 0)
      return;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v15 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      return;
    v16 = handle[92];
    *(_DWORD *)buf = 136447490;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = (nw_protocol_identifier *)((char *)handle + 378);
    v48 = 2080;
    v49 = " ";
    v50 = 1024;
    v51 = v16;
    v52 = 2048;
    v53 = a2;
    v54 = 2048;
    v55 = output_handler_context;
    v12 = "%{public}s %{public}s%s<i%u> protocol (%p) node (%p) has no stream pointer as extra";
    v13 = v15;
    v14 = 58;
    goto LABEL_22;
  }
  nw_http2_stream_close((uint64_t)handle, output_handler_context[4]);
  v6 = *(unsigned __int16 *)(v5 + 188);
  v7 = v6 | (*(unsigned __int8 *)(v5 + 190) << 16);
  if ((v6 & 0x40) != 0)
    return;
  *(_BYTE *)(v5 + 190) = BYTE2(v7);
  *(_WORD *)(v5 + 188) = v7 | 0x40;
  callbacks = a2->callbacks;
  if (callbacks)
  {
    disconnected = (void (*)(nw_protocol *, _DWORD *))callbacks->disconnected;
    if (disconnected)
    {
      disconnected(a2, handle);
      return;
    }
  }
  __nwlog_obj();
  identifier = a2->identifier;
  if (!identifier)
    identifier = (nw_protocol_identifier *)"invalid";
  *(_DWORD *)buf = 136446466;
  v45 = "nw_protocol_http2_disconnect";
  v46 = 2082;
  v47 = identifier;
  v30 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (!__nwlog_fault(v30, &type, &v42))
    goto LABEL_96;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v31 = __nwlog_obj();
    v32 = type;
    if (!os_log_type_enabled(v31, type))
      goto LABEL_96;
    v33 = a2->identifier;
    if (!v33)
      v33 = (nw_protocol_identifier *)"invalid";
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v33;
    v34 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_95:
    _os_log_impl(&dword_182FBE000, v31, v32, v34, buf, 0x16u);
    goto LABEL_96;
  }
  if (!v42)
  {
    v31 = __nwlog_obj();
    v32 = type;
    v39 = os_log_type_enabled(v31, type);
    v40 = (nw_protocol_identifier *)"invalid";
    if (!v39)
      goto LABEL_96;
    if (a2->identifier)
      v40 = a2->identifier;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v40;
    v34 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
    goto LABEL_95;
  }
  v35 = (char *)__nw_create_backtrace_string();
  v31 = __nwlog_obj();
  v32 = type;
  v36 = os_log_type_enabled(v31, type);
  if (!v35)
  {
    v41 = (nw_protocol_identifier *)"invalid";
    if (!v36)
      goto LABEL_96;
    if (a2->identifier)
      v41 = a2->identifier;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v41;
    v34 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
    goto LABEL_95;
  }
  if (v36)
  {
    v37 = (nw_protocol_identifier *)"invalid";
    if (a2->identifier)
      v37 = a2->identifier;
    *(_DWORD *)buf = 136446722;
    v45 = "nw_protocol_http2_disconnect";
    v46 = 2082;
    v47 = v37;
    v48 = 2082;
    v49 = v35;
    _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
  }
  free(v35);
LABEL_96:
  if (v30)
  {
    v38 = (char *)v30;
    goto LABEL_86;
  }
}

void nw_protocol_http2_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  uint64_t v4;
  void (*v5)(void);
  char *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *v10;
  const char *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  NSObject *v16;
  int v17;
  char *backtrace_string;
  _BOOL4 v19;
  char *v20;
  char *v21;
  _BOOL4 v22;
  char *v23;
  _BOOL4 v24;
  char *v25;
  char *v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (((__int16)handle[94] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v16 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v17 = handle[92];
          *(_DWORD *)buf = 136446978;
          v30 = "nw_protocol_http2_disconnected";
          v31 = 2082;
          v32 = (char *)handle + 378;
          v33 = 2080;
          v34 = " ";
          v35 = 1024;
          v36 = v17;
          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
      nw_protocol_remove_instance((uint64_t)a1);
      v4 = *((_QWORD *)handle + 18);
      if (!v4)
        goto LABEL_9;
      if (*(_QWORD *)v4)
      {
        v5 = *(void (**)(void))(*(_QWORD *)v4 + 8);
        if (v5)
        {
          v5();
LABEL_9:
          nw_http2_connection_close((uint64_t)handle);
          return;
        }
      }
      __nwlog_obj();
      v6 = (char *)*((_QWORD *)handle + 18);
      *(_DWORD *)buf = 136446466;
      v30 = "nw_protocol_http2_disconnected";
      v31 = 2048;
      v32 = v6;
      v7 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v27 = 0;
      if (__nwlog_fault(v7, &type, &v27))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v8 = __nwlog_obj();
          v9 = type;
          if (!os_log_type_enabled(v8, type))
            goto LABEL_52;
          v10 = (char *)*((_QWORD *)handle + 18);
          *(_DWORD *)buf = 136446466;
          v30 = "nw_protocol_http2_disconnected";
          v31 = 2048;
          v32 = v10;
          v11 = "%{public}s listen protocol (%p) has invalid disconnected callback";
          goto LABEL_51;
        }
        if (!v27)
        {
          v8 = __nwlog_obj();
          v9 = type;
          if (!os_log_type_enabled(v8, type))
            goto LABEL_52;
          v25 = (char *)*((_QWORD *)handle + 18);
          *(_DWORD *)buf = 136446466;
          v30 = "nw_protocol_http2_disconnected";
          v31 = 2048;
          v32 = v25;
          v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, backtrace limit exceeded";
          goto LABEL_51;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v8 = __nwlog_obj();
        v9 = type;
        v19 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v19)
          {
            v20 = (char *)*((_QWORD *)handle + 18);
            *(_DWORD *)buf = 136446722;
            v30 = "nw_protocol_http2_disconnected";
            v31 = 2048;
            v32 = v20;
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s listen protocol (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_52;
        }
        if (v19)
        {
          v26 = (char *)*((_QWORD *)handle + 18);
          *(_DWORD *)buf = 136446466;
          v30 = "nw_protocol_http2_disconnected";
          v31 = 2048;
          v32 = v26;
          v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, no backtrace";
LABEL_51:
          _os_log_impl(&dword_182FBE000, v8, v9, v11, buf, 0x16u);
        }
      }
LABEL_52:
      if (v7)
        free(v7);
      goto LABEL_9;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_http2_disconnected";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_59;
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_http2_disconnected";
        v15 = "%{public}s called with null http2";
        goto LABEL_58;
      }
      if (!v27)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_59;
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_http2_disconnected";
        v15 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_58;
      }
      v23 = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v24 = os_log_type_enabled(v13, type);
      if (v23)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_protocol_http2_disconnected";
          v31 = 2082;
          v32 = v23;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v23);
        if (v12)
          goto LABEL_60;
        return;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_http2_disconnected";
        v15 = "%{public}s called with null http2, no backtrace";
LABEL_58:
        _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_http2_disconnected";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v12, &type, &v27))
      goto LABEL_59;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_59;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_http2_disconnected";
      v15 = "%{public}s called with null protocol";
      goto LABEL_58;
    }
    if (!v27)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_59;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_http2_disconnected";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_58;
    }
    v21 = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v22 = os_log_type_enabled(v13, type);
    if (!v21)
    {
      if (!v22)
        goto LABEL_59;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_http2_disconnected";
      v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_58;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "nw_protocol_http2_disconnected";
      v31 = 2082;
      v32 = v21;
      _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v21);
  }
LABEL_59:
  if (v12)
LABEL_60:
    free(v12);
}

void nw_protocol_http2_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  _QWORD *output_handler_context;
  uint64_t v5;
  NSObject *v6;
  int v7;
  const char *v8;
  int v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  NSObject *v14;
  int v15;
  char *backtrace_string;
  _BOOL4 v17;
  char *v18;
  _BOOL4 v19;
  const char *v20;
  _BOOL4 v21;
  NSObject *v22;
  int v23;
  int v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http2_output_finished";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http2_output_finished";
      v13 = "%{public}s called with null protocol";
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_protocol_http2_output_finished";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_72:
        if (!v10)
          return;
        goto LABEL_73;
      }
      if (!v17)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http2_output_finished";
      v13 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http2_output_finished";
      v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_71;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http2_output_finished";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25))
      goto LABEL_72;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http2_output_finished";
        v13 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_71;
      }
      v18 = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v19 = os_log_type_enabled(v11, type);
      if (!v18)
      {
        if (!v19)
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http2_output_finished";
        v13 = "%{public}s called with null http2, no backtrace";
        goto LABEL_71;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v28 = "nw_protocol_http2_output_finished";
        v29 = 2082;
        v30 = v18;
        v20 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_52:
        _os_log_impl(&dword_182FBE000, v11, v12, v20, buf, 0x16u);
      }
LABEL_53:
      free(v18);
      if (!v10)
        return;
LABEL_73:
      free(v10);
      return;
    }
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http2_output_finished";
    v13 = "%{public}s called with null http2";
LABEL_71:
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_72;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http2_output_finished";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http2_output_finished";
      v13 = "%{public}s called with null other_protocol";
      goto LABEL_71;
    }
    if (!v25)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http2_output_finished";
      v13 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_71;
    }
    v18 = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v21 = os_log_type_enabled(v11, type);
    if (!v18)
    {
      if (!v21)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http2_output_finished";
      v13 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_71;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v28 = "nw_protocol_http2_output_finished";
      v29 = 2082;
      v30 = v18;
      v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_52;
    }
    goto LABEL_53;
  }
  if (((__int16)handle[94] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v14 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v15 = handle[92];
      *(_DWORD *)buf = 136446978;
      v28 = "nw_protocol_http2_output_finished";
      v29 = 2082;
      v30 = (char *)handle + 378;
      v31 = 2080;
      v32 = " ";
      v33 = 1024;
      v34 = v15;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    v5 = output_handler_context[4];
    if (v5)
    {
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v22 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v24 = *(_DWORD *)(v5 + 176);
          v23 = *(_DWORD *)(v5 + 180);
          *(_DWORD *)buf = 136447234;
          v28 = "nw_protocol_http2_output_finished";
          v29 = 2082;
          v30 = (char *)(v5 + 191);
          v31 = 2080;
          v32 = " ";
          v33 = 1024;
          v34 = v23;
          v35 = 1024;
          v36 = v24;
          _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> sending non-deferred end stream", buf, 0x2Cu);
        }
      }
      nw_http2_send_end_stream((uint64_t)handle, v5);
      return;
    }
    if (((__int16)handle[94] & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v9 = handle[92];
        *(_DWORD *)buf = 136446978;
        v28 = "nw_protocol_http2_output_finished";
        v29 = 2082;
        v30 = (char *)handle + 378;
        v31 = 2080;
        v32 = " ";
        v33 = 1024;
        v34 = v9;
        v8 = "%{public}s %{public}s%s<i%u> couldn't get stream during output_finished";
        goto LABEL_21;
      }
    }
  }
  else if (((__int16)handle[94] & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      v7 = handle[92];
      *(_DWORD *)buf = 136446978;
      v28 = "nw_protocol_http2_output_finished";
      v29 = 2082;
      v30 = (char *)handle + 378;
      v31 = 2080;
      v32 = " ";
      v33 = 1024;
      v34 = v7;
      v8 = "%{public}s %{public}s%s<i%u> couldn't get output handler context during output_finished";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, v8, buf, 0x26u);
    }
  }
}

void nw_protocol_http2_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  NSObject *v3;
  int v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  int v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  const char *v18;
  _BOOL4 v19;
  _QWORD v20[5];
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_input_finished";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_63;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_input_finished";
      v11 = "%{public}s called with null protocol";
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_protocol_http2_input_finished";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_63:
        if (!v8)
          return;
        goto LABEL_64;
      }
      if (!v15)
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_input_finished";
      v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_input_finished";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_62;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_input_finished";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_63;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_63;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_http2_input_finished";
        v11 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_62;
      }
      v16 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!v16)
      {
        if (!v17)
          goto LABEL_63;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_http2_input_finished";
        v11 = "%{public}s called with null http2, no backtrace";
        goto LABEL_62;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_http2_input_finished";
        v25 = 2082;
        v26 = v16;
        v18 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_47:
        _os_log_impl(&dword_182FBE000, v9, v10, v18, buf, 0x16u);
      }
LABEL_48:
      free(v16);
      if (!v8)
        return;
LABEL_64:
      free(v8);
      return;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_63;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_input_finished";
    v11 = "%{public}s called with null http2";
LABEL_62:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_63;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_input_finished";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_63;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_input_finished";
      v11 = "%{public}s called with null other_protocol";
      goto LABEL_62;
    }
    if (!v21)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_input_finished";
      v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_62;
    }
    v16 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v19 = os_log_type_enabled(v9, type);
    if (!v16)
    {
      if (!v19)
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_input_finished";
      v11 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_62;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_http2_input_finished";
      v25 = 2082;
      v26 = v16;
      v18 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_47;
    }
    goto LABEL_48;
  }
  if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v12 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v13 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v24 = "nw_protocol_http2_input_finished";
      v25 = 2082;
      v26 = handle + 378;
      v27 = 2080;
      v28 = " ";
      v29 = 1024;
      v30 = v13;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if ((*((_WORD *)handle + 188) & 0x9000) == 0x1000)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v3 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      v4 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v24 = "nw_protocol_http2_input_finished";
      v25 = 2082;
      v26 = handle + 378;
      v27 = 2080;
      v28 = " ";
      v29 = 1024;
      v30 = v4;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> still waiting for listen handler, but input finished. Processing input anyway.", buf, 0x26u);
    }
  }
  nw_protocol_http2_process_input((uint64_t)handle);
  *((_WORD *)handle + 188) |= 2u;
  v5 = (char *)*((_QWORD *)handle + 19);
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 0x40000000;
  v20[2] = ___ZL32nw_protocol_http2_input_finishedP11nw_protocolS0__block_invoke;
  v20[3] = &__block_descriptor_tmp_50_83083;
  v20[4] = handle;
  nw_hash_table_apply(v5, (uint64_t)v20);
  v7 = *((_QWORD *)handle + 11);
  if (v7)
  {
    if (*(_QWORD *)v7)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v7, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    }
    else
    {
      *(_OWORD *)(v7 + 32) = xmmword_183C6F190;
      if (*(_BYTE *)(v7 + 48))
      {
        if (*(_BYTE *)(v7 + 49))
          nw_queue_source_run_timer(v7, v6);
      }
    }
  }
}

BOOL nw_protocol_http2_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  __int16 *handle;
  int v5;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_remote_endpoint)(nw_protocol *);
  void *v8;
  nw_protocol_callbacks *v9;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v11;
  void *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  int v18;
  _BOOL4 v19;
  uint64_t v20;
  int v21;
  const char *v22;
  NSObject *v23;
  os_log_type_t v24;
  uint32_t v25;
  uint64_t v26;
  const char *v27;
  int idle_timeout;
  NSObject *v29;
  uint32_t v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t v33;
  _BYTE *v34;
  int v35;
  unsigned __int8 *v36;
  int v37;
  uint64_t v38;
  int v39;
  void *v40;
  char v41;
  const void *v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t stream_node_from_id;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  int v55;
  int v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  int v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  int v68;
  unsigned __int8 *v69;
  unsigned __int8 *v70;
  void *singleton;
  BOOL v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  NSObject *v78;
  uint32_t v79;
  NSObject *v80;
  int v81;
  int v82;
  void *v83;
  void *v84;
  void *v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  uint64_t v96;
  int v97;
  const char *v98;
  NSObject *v99;
  uint32_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105;
  uint64_t v106;
  int v107;
  int v108;
  uint64_t v109;
  int v110;
  int v111;
  const char *v112;
  NSObject *v113;
  os_log_type_t v114;
  uint32_t v115;
  char *v116;
  _BOOL4 v117;
  int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  int v124;
  int v125;
  uint64_t v126;
  _QWORD *v127;
  id v128;
  void *v129;
  id v130;
  id v131;
  id v132;
  id *v133;
  NWConcrete_nw_protocol_instance_stub *v134;
  id v135;
  void *v136;
  _BOOL8 v137;
  void *v138;
  void *v139;
  __int16 v140;
  id v141;
  void *v142;
  void *v143;
  int v144;
  int v145;
  uint64_t v146;
  NSObject *v147;
  int v148;
  int v149;
  int v150;
  int v151;
  uint64_t v152;
  _BOOL8 result;
  char *v154;
  NSObject *v155;
  os_log_type_t v156;
  const char *v157;
  NSObject *v158;
  int v159;
  int v160;
  NSObject *v161;
  int v162;
  char *backtrace_string;
  _BOOL4 v164;
  const char *v165;
  _BOOL4 v166;
  _BOOL4 v167;
  NSObject *v168;
  void *v169;
  NSObject *v170;
  int v171;
  NSObject *v172;
  int v173;
  int v174;
  nw_protocol_identifier *identifier;
  NSObject *v176;
  int v177;
  int v178;
  char v179;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v182;
  __int16 v183;
  uint64_t v184;
  __int16 v185;
  uint64_t v186;
  __int16 v187;
  int v188;
  __int16 v189;
  _BYTE v190[26];
  _BYTE v191[10];
  int v192;
  __int16 v193;
  char *v194;
  os_log_type_t v195[16];
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  int v200;
  uint64_t v201;

  v201 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v182 = "nw_protocol_http2_add_input_handler";
    v154 = (char *)_os_log_send_and_compose_impl();
    v195[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v154, v195, &type))
      goto LABEL_259;
    if (v195[0] == OS_LOG_TYPE_FAULT)
    {
      v155 = __nwlog_obj();
      v156 = v195[0];
      if (!os_log_type_enabled(v155, v195[0]))
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null protocol";
      goto LABEL_258;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v155 = __nwlog_obj();
      v156 = v195[0];
      if (!os_log_type_enabled(v155, v195[0]))
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_258;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v155 = __nwlog_obj();
    v156 = v195[0];
    v164 = os_log_type_enabled(v155, v195[0]);
    if (!backtrace_string)
    {
      if (!v164)
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_258;
    }
    if (!v164)
      goto LABEL_239;
    *(_DWORD *)buf = 136446466;
    v182 = "nw_protocol_http2_add_input_handler";
    v183 = 2082;
    v184 = (uint64_t)backtrace_string;
    v165 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_238:
    _os_log_impl(&dword_182FBE000, v155, v156, v165, buf, 0x16u);
    goto LABEL_239;
  }
  handle = (__int16 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v182 = "nw_protocol_http2_add_input_handler";
    v154 = (char *)_os_log_send_and_compose_impl();
    v195[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v154, v195, &type))
      goto LABEL_259;
    if (v195[0] == OS_LOG_TYPE_FAULT)
    {
      v155 = __nwlog_obj();
      v156 = v195[0];
      if (!os_log_type_enabled(v155, v195[0]))
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null http2";
      goto LABEL_258;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v155 = __nwlog_obj();
      v156 = v195[0];
      if (!os_log_type_enabled(v155, v195[0]))
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_258;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v155 = __nwlog_obj();
    v156 = v195[0];
    v166 = os_log_type_enabled(v155, v195[0]);
    if (!backtrace_string)
    {
      if (!v166)
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null http2, no backtrace";
      goto LABEL_258;
    }
    if (!v166)
      goto LABEL_239;
    *(_DWORD *)buf = 136446466;
    v182 = "nw_protocol_http2_add_input_handler";
    v183 = 2082;
    v184 = (uint64_t)backtrace_string;
    v165 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_238;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v182 = "nw_protocol_http2_add_input_handler";
    v154 = (char *)_os_log_send_and_compose_impl();
    v195[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v154, v195, &type))
      goto LABEL_259;
    if (v195[0] == OS_LOG_TYPE_FAULT)
    {
      v155 = __nwlog_obj();
      v156 = v195[0];
      if (!os_log_type_enabled(v155, v195[0]))
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null input_protocol";
      goto LABEL_258;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v155 = __nwlog_obj();
      v156 = v195[0];
      if (!os_log_type_enabled(v155, v195[0]))
        goto LABEL_259;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v157 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_258;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v155 = __nwlog_obj();
    v156 = v195[0];
    v167 = os_log_type_enabled(v155, v195[0]);
    if (backtrace_string)
    {
      if (v167)
      {
        *(_DWORD *)buf = 136446466;
        v182 = "nw_protocol_http2_add_input_handler";
        v183 = 2082;
        v184 = (uint64_t)backtrace_string;
        v165 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_238;
      }
LABEL_239:
      free(backtrace_string);
      goto LABEL_259;
    }
    if (!v167)
      goto LABEL_259;
    *(_DWORD *)buf = 136446210;
    v182 = "nw_protocol_http2_add_input_handler";
    v157 = "%{public}s called with null input_protocol, no backtrace";
LABEL_258:
    _os_log_impl(&dword_182FBE000, v155, v156, v157, buf, 0xCu);
LABEL_259:
    if (v154)
      free(v154);
    return 0;
  }
  if ((handle[188] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v158 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v159 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v182 = "nw_protocol_http2_add_input_handler";
      v183 = 2082;
      v184 = (uint64_t)(handle + 189);
      v185 = 2080;
      v186 = (uint64_t)" ";
      v187 = 1024;
      v188 = v159;
      _os_log_impl(&dword_182FBE000, v158, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
    v160 = handle[188];
    v5 = *((_DWORD *)handle + 90);
    *((_DWORD *)handle + 90) = -1;
    if ((v160 & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v161 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v162 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447746;
        v182 = "nw_protocol_http2_add_input_handler";
        v183 = 2082;
        v184 = (uint64_t)(handle + 189);
        v185 = 2080;
        v186 = (uint64_t)" ";
        v187 = 1024;
        v188 = v162;
        v189 = 2048;
        *(_QWORD *)v190 = a2;
        *(_WORD *)&v190[8] = 1042;
        *(_DWORD *)&v190[10] = 16;
        *(_WORD *)&v190[14] = 2098;
        *(_QWORD *)&v190[16] = a2;
        _os_log_impl(&dword_182FBE000, v161, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> incoming protocol %p has flow id %{public,uuid_t}.16P", buf, 0x40u);
      }
    }
  }
  else
  {
    v5 = *((_DWORD *)handle + 90);
    *((_DWORD *)handle + 90) = -1;
  }
  if (!*((_QWORD *)handle + 14))
  {
    callbacks = a2->callbacks;
    if (!callbacks
      || (get_remote_endpoint = (uint64_t (*)(nw_protocol *))callbacks->get_remote_endpoint) == 0
      || (v8 = (void *)get_remote_endpoint(a2)) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)buf = 136446210;
      v182 = "nw_protocol_http2_add_input_handler";
      v27 = "%{public}s failed to get remote endpoint from input_handler";
LABEL_32:
      v29 = v26;
      v30 = 12;
LABEL_66:
      _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, v27, buf, v30);
      return 0;
    }
    *((_QWORD *)handle + 14) = os_retain(v8);
  }
  v9 = a2->callbacks;
  if (!v9
    || (get_parameters = (uint64_t (*)(nw_protocol *))v9->get_parameters) == 0
    || (v11 = (void *)get_parameters(a2)) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    v182 = "nw_protocol_http2_add_input_handler";
    v27 = "%{public}s couldn't get parameters from input_protocol";
    goto LABEL_32;
  }
  v12 = v11;
  v200 = 0;
  v198 = 0u;
  v199 = 0u;
  v197 = 0u;
  *(_OWORD *)v195 = 0u;
  v196 = 0u;
  v13 = nw_parameters_copy_protocol_options_legacy(v11, a1);
  if (!v13)
  {
    v19 = 0;
    idle_timeout = 240;
    goto LABEL_47;
  }
  v14 = v13;
  v15 = v14;
  v16 = 0;
  v195[0] = OS_LOG_TYPE_DEFAULT;
  v17 = v14 + 48;
  while (1)
  {
    v18 = v14[v16 + 48];
    v195[v16] = v18;
    if (!v18)
      break;
    if (++v16 == 83)
    {
      HIBYTE(v200) = 0;
      break;
    }
  }

  v19 = *((_BYTE *)handle + 378) == 0;
  if (*((_BYTE *)handle + 378))
  {
    if (handle[188] < 0 || !gLogDatapath)
      goto LABEL_43;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v20 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      goto LABEL_43;
    v21 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447234;
    v182 = "nw_protocol_http2_add_input_handler";
    v183 = 2082;
    v184 = (uint64_t)(handle + 189);
    v185 = 2080;
    v186 = (uint64_t)" ";
    v187 = 1024;
    v188 = v21;
    v189 = 2080;
    *(_QWORD *)v190 = v195;
    v22 = "%{public}s %{public}s%s<i%u> new stream %s joined http2";
    v23 = v20;
    v24 = OS_LOG_TYPE_DEBUG;
    v25 = 48;
  }
  else
  {
    v31 = v15;
    v32 = v31;
    *((_BYTE *)handle + 378) = 0;
    v33 = 84;
    v34 = handle + 189;
    while (1)
    {
      v35 = *v17;
      *v34 = v35;
      if (!v35)
        break;
      ++v34;
      ++v17;
      if ((unint64_t)--v33 <= 1)
      {
        *v34 = 0;
        break;
      }
    }

    *((_DWORD *)handle + 92) = nw_protocol_get_next_instance_id();
    v36 = v32;
    v37 = *((_DWORD *)v36 + 33);

    if (handle[188] < 0)
      goto LABEL_43;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v38 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      goto LABEL_43;
    v39 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447490;
    v182 = "nw_protocol_http2_add_input_handler";
    v183 = 2082;
    v184 = (uint64_t)(handle + 189);
    v185 = 2080;
    v186 = (uint64_t)" ";
    v187 = 1024;
    v188 = v39;
    v189 = 1024;
    *(_DWORD *)v190 = v39;
    *(_WORD *)&v190[4] = 1024;
    *(_DWORD *)&v190[6] = v37;
    v22 = "%{public}s %{public}s%s<i%u> created HTTP/2 and assigned instance ID: %u from C%u";
    v23 = v38;
    v24 = OS_LOG_TYPE_INFO;
    v25 = 50;
  }
  _os_log_impl(&dword_182FBE000, v23, v24, v22, buf, v25);
LABEL_43:
  idle_timeout = nw_http2_get_idle_timeout(v15);
  v40 = nw_http2_copy_reset_stream_error_callback(v15);
  v41 = *((_BYTE *)handle + 272);
  if ((v41 & 1) != 0)
  {
    v42 = (const void *)*((_QWORD *)handle + 33);
    if (v42)
    {
      _Block_release(v42);
      v41 = *((_BYTE *)handle + 272);
    }
  }
  *((_QWORD *)handle + 33) = v40;
  *((_BYTE *)handle + 272) = v41 | 1;
  os_release(v15);
LABEL_47:
  *((_QWORD *)handle + 10) = (1000 * idle_timeout);
  v43 = nw_http2_add_to_protocol_table((uint64_t)handle, (uint64_t)a2, 0);
  if (!v43)
  {
    if (handle[188] < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v59 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      return 0;
    v60 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136446978;
    v182 = "nw_protocol_http2_add_input_handler";
    v183 = 2082;
    v184 = (uint64_t)(handle + 189);
    v185 = 2080;
    v186 = (uint64_t)" ";
    v187 = 1024;
    v188 = v60;
    v27 = "%{public}s %{public}s%s<i%u> could not add protocol to protocol based hash table, cannot add input handler";
    v29 = v59;
    v30 = 38;
    goto LABEL_66;
  }
  v44 = (_QWORD *)v43;
  if (v5 != -1)
  {
    stream_node_from_id = nw_http2_get_stream_node_from_id((uint64_t)handle, v5);
    if (stream_node_from_id)
    {
      v46 = stream_node_from_id;
      v47 = *(_QWORD *)(stream_node_from_id + 16);
      if (v47)
      {
        v48 = *(_QWORD *)(stream_node_from_id + 32);
        if (v48)
        {
          if (((*(unsigned __int16 *)(v47 + 188) | (*(unsigned __int8 *)(v47 + 190) << 16)) & 0x80000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v50 = *(_DWORD *)(v47 + 176);
            v49 = *(_DWORD *)(v47 + 180);
            v51 = *(_QWORD *)(v46 + 32);
            *(_DWORD *)buf = 136448258;
            v182 = "nw_protocol_http2_add_input_handler";
            v183 = 2082;
            v184 = v47 + 191;
            v185 = 2080;
            v186 = (uint64_t)" ";
            v187 = 1024;
            v188 = v49;
            v189 = 1024;
            *(_DWORD *)v190 = v50;
            *(_WORD *)&v190[4] = 2048;
            *(_QWORD *)&v190[6] = a2;
            *(_WORD *)&v190[14] = 2048;
            *(_QWORD *)&v190[16] = v51;
            *(_WORD *)&v190[24] = 2048;
            *(_QWORD *)v191 = v47;
            *(_WORD *)&v191[8] = 1024;
            v192 = v50;
            v52 = (char *)_os_log_send_and_compose_impl();
            type = OS_LOG_TYPE_ERROR;
            v179 = 0;
            if (!__nwlog_fault(v52, &type, &v179))
              goto LABEL_193;
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v53 = gconnectionLogObj;
              v54 = type;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
                goto LABEL_193;
              v56 = *(_DWORD *)(v47 + 176);
              v55 = *(_DWORD *)(v47 + 180);
              v57 = *(_QWORD *)(v46 + 32);
              *(_DWORD *)buf = 136448258;
              v182 = "nw_protocol_http2_add_input_handler";
              v183 = 2082;
              v184 = v47 + 191;
              v185 = 2080;
              v186 = (uint64_t)" ";
              v187 = 1024;
              v188 = v55;
              v189 = 1024;
              *(_DWORD *)v190 = v56;
              *(_WORD *)&v190[4] = 2048;
              *(_QWORD *)&v190[6] = a2;
              *(_WORD *)&v190[14] = 2048;
              *(_QWORD *)&v190[16] = v57;
              *(_WORD *)&v190[24] = 2048;
              *(_QWORD *)v191 = v47;
              *(_WORD *)&v191[8] = 1024;
              v192 = v56;
              v58 = "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer"
                    " %p for stream (%p, id %d)";
            }
            else if (v179)
            {
              v116 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v53 = gconnectionLogObj;
              v54 = type;
              v117 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
              if (v116)
              {
                if (v117)
                {
                  v119 = *(_DWORD *)(v47 + 176);
                  v118 = *(_DWORD *)(v47 + 180);
                  v120 = *(_QWORD *)(v46 + 32);
                  *(_DWORD *)buf = 136448514;
                  v182 = "nw_protocol_http2_add_input_handler";
                  v183 = 2082;
                  v184 = v47 + 191;
                  v185 = 2080;
                  v186 = (uint64_t)" ";
                  v187 = 1024;
                  v188 = v118;
                  v189 = 1024;
                  *(_DWORD *)v190 = v119;
                  *(_WORD *)&v190[4] = 2048;
                  *(_QWORD *)&v190[6] = a2;
                  *(_WORD *)&v190[14] = 2048;
                  *(_QWORD *)&v190[16] = v120;
                  *(_WORD *)&v190[24] = 2048;
                  *(_QWORD *)v191 = v47;
                  *(_WORD *)&v191[8] = 1024;
                  v192 = v119;
                  v193 = 2082;
                  v194 = v116;
                  _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer %p for stream (%p, id %d), dumping backtrace:%{public}s", buf, 0x5Au);
                }
                free(v116);
                goto LABEL_193;
              }
              if (!v117)
              {
LABEL_193:
                if (v52)
                  free(v52);
                goto LABEL_195;
              }
              v151 = *(_DWORD *)(v47 + 176);
              v150 = *(_DWORD *)(v47 + 180);
              v152 = *(_QWORD *)(v46 + 32);
              *(_DWORD *)buf = 136448258;
              v182 = "nw_protocol_http2_add_input_handler";
              v183 = 2082;
              v184 = v47 + 191;
              v185 = 2080;
              v186 = (uint64_t)" ";
              v187 = 1024;
              v188 = v150;
              v189 = 1024;
              *(_DWORD *)v190 = v151;
              *(_WORD *)&v190[4] = 2048;
              *(_QWORD *)&v190[6] = a2;
              *(_WORD *)&v190[14] = 2048;
              *(_QWORD *)&v190[16] = v152;
              *(_WORD *)&v190[24] = 2048;
              *(_QWORD *)v191 = v47;
              *(_WORD *)&v191[8] = 1024;
              v192 = v151;
              v58 = "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer"
                    " %p for stream (%p, id %d), no backtrace";
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v53 = gconnectionLogObj;
              v54 = type;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
                goto LABEL_193;
              v145 = *(_DWORD *)(v47 + 176);
              v144 = *(_DWORD *)(v47 + 180);
              v146 = *(_QWORD *)(v46 + 32);
              *(_DWORD *)buf = 136448258;
              v182 = "nw_protocol_http2_add_input_handler";
              v183 = 2082;
              v184 = v47 + 191;
              v185 = 2080;
              v186 = (uint64_t)" ";
              v187 = 1024;
              v188 = v144;
              v189 = 1024;
              *(_DWORD *)v190 = v145;
              *(_WORD *)&v190[4] = 2048;
              *(_QWORD *)&v190[6] = a2;
              *(_WORD *)&v190[14] = 2048;
              *(_QWORD *)&v190[16] = v146;
              *(_WORD *)&v190[24] = 2048;
              *(_QWORD *)v191 = v47;
              *(_WORD *)&v191[8] = 1024;
              v192 = v145;
              v58 = "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer"
                    " %p for stream (%p, id %d), backtrace limit exceeded";
            }
            _os_log_impl(&dword_182FBE000, v53, v54, v58, buf, 0x50u);
            goto LABEL_193;
          }
LABEL_195:
          nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
          return 0;
        }
        *(_QWORD *)(stream_node_from_id + 32) = a2;
        v44[4] = v47;
        while (1)
        {
          v108 = v195[v48];
          *(_BYTE *)(v47 + 191 + v48) = v108;
          if (!v108)
            break;
          if (++v48 == 83)
          {
            *(_BYTE *)(v47 + 274) = 0;
            break;
          }
        }
        if (((*(unsigned __int16 *)(v47 + 188) | (*(unsigned __int8 *)(v47 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v109 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v111 = *(_DWORD *)(v47 + 176);
            v110 = *(_DWORD *)(v47 + 180);
            *(_DWORD *)buf = 136448258;
            v182 = "nw_protocol_http2_add_input_handler";
            v183 = 2082;
            v184 = v47 + 191;
            v185 = 2080;
            v186 = (uint64_t)" ";
            v187 = 1024;
            v188 = v110;
            v189 = 1024;
            *(_DWORD *)v190 = v111;
            *(_WORD *)&v190[4] = 1024;
            *(_DWORD *)&v190[6] = v5;
            *(_WORD *)&v190[10] = 2080;
            *(_QWORD *)&v190[12] = v195;
            *(_WORD *)&v190[20] = 1024;
            *(_DWORD *)&v190[22] = v111;
            *(_WORD *)v191 = 2048;
            *(_QWORD *)&v191[2] = v47;
            v112 = "%{public}s %{public}s%s<i%u:s%d> connected incoming stream id %d for %s to existing stream %d (%p)";
            v113 = v109;
            v114 = OS_LOG_TYPE_INFO;
            v115 = 76;
LABEL_140:
            _os_log_impl(&dword_182FBE000, v113, v114, v112, buf, v115);
            goto LABEL_76;
          }
        }
        goto LABEL_76;
      }
      if (handle[188] < 0)
        goto LABEL_195;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v86 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_195;
      v87 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      v182 = "nw_protocol_http2_add_input_handler";
      v183 = 2082;
      v184 = (uint64_t)(handle + 189);
      v185 = 2080;
      v186 = (uint64_t)" ";
      v187 = 1024;
      v188 = v87;
      v189 = 1024;
      *(_DWORD *)v190 = v5;
      v77 = "%{public}s %{public}s%s<i%u> stream (id %d) not found in hash node";
      v78 = v86;
      v79 = 44;
    }
    else
    {
      if (handle[188] < 0)
        goto LABEL_195;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v75 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_195;
      v76 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447490;
      v182 = "nw_protocol_http2_add_input_handler";
      v183 = 2082;
      v184 = (uint64_t)(handle + 189);
      v185 = 2080;
      v186 = (uint64_t)" ";
      v187 = 1024;
      v188 = v76;
      v189 = 1024;
      *(_DWORD *)v190 = v5;
      *(_WORD *)&v190[4] = 2048;
      *(_QWORD *)&v190[6] = a2;
      v77 = "%{public}s %{public}s%s<i%u> could not find existing stream %d to connect protocol %p with";
      v78 = v75;
      v79 = 54;
    }
    _os_log_impl(&dword_182FBE000, v78, OS_LOG_TYPE_ERROR, v77, buf, v79);
    goto LABEL_195;
  }
  if ((handle[188] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v170 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v171 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v182 = "nw_protocol_http2_add_input_handler";
      v183 = 2082;
      v184 = (uint64_t)(handle + 189);
      v185 = 2080;
      v186 = (uint64_t)" ";
      v187 = 1024;
      v188 = v171;
      _os_log_impl(&dword_182FBE000, v170, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> detected new stream initiated from this side of the connection, allocating new stream", buf, 0x26u);
    }
  }
  v61 = malloc_type_calloc(1uLL, 0x118uLL, 0xEAFB8F1AuLL);
  v47 = (uint64_t)v61;
  if (v61)
  {
    v62 = (uint64_t)(v61 + 11);
    v61[34] = 0;
    *((_OWORD *)v61 + 15) = 0u;
    *((_OWORD *)v61 + 16) = 0u;
    *((_OWORD *)v61 + 13) = 0u;
    *((_OWORD *)v61 + 14) = 0u;
    *((_OWORD *)v61 + 11) = 0u;
    *((_OWORD *)v61 + 12) = 0u;
    *((_OWORD *)v61 + 9) = 0u;
    *((_OWORD *)v61 + 10) = 0u;
    *((_OWORD *)v61 + 7) = 0u;
    *((_OWORD *)v61 + 8) = 0u;
    *((_OWORD *)v61 + 5) = 0u;
    *((_OWORD *)v61 + 6) = 0u;
    *((_OWORD *)v61 + 3) = 0u;
    *((_OWORD *)v61 + 4) = 0u;
    *((_OWORD *)v61 + 1) = 0u;
    *((_OWORD *)v61 + 2) = 0u;
    *(_OWORD *)v61 = 0u;
    nw_http2_stream_init((uint64_t)v61);
    goto LABEL_71;
  }
  v168 = __nwlog_obj();
  os_log_type_enabled(v168, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v182 = "strict_calloc";
  v183 = 2048;
  v184 = 1;
  v185 = 2048;
  v186 = 280;
  v169 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v169);
  if (!result)
  {
    free(v169);
    MEMORY[0x110] = 0;
    MEMORY[0x100] = 0u;
    MEMORY[0xF0] = 0u;
    MEMORY[0xE0] = 0u;
    MEMORY[0xD0] = 0u;
    MEMORY[0xC0] = 0u;
    MEMORY[0xB0] = 0u;
    MEMORY[0xA0] = 0u;
    MEMORY[0x90] = 0u;
    MEMORY[0x80] = 0u;
    MEMORY[0x70] = 0u;
    MEMORY[0x60] = 0u;
    MEMORY[0x50] = 0u;
    MEMORY[0x40] = 0u;
    MEMORY[0x30] = 0u;
    MEMORY[0x20] = 0u;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    nw_http2_stream_init(0);
    v62 = 88;
LABEL_71:
    v63 = 0;
    *(_BYTE *)v62 = (handle[188] & 0x80) != 0;
    v64 = *(_WORD *)(v47 + 188) & 0xFF7F | (*(unsigned __int8 *)(v47 + 190) << 16);
    *(_WORD *)(v47 + 188) = *(_WORD *)(v47 + 188) & 0xFF7F | handle[188] & 0x80;
    *(_BYTE *)(v47 + 190) = BYTE2(v64);
    while (1)
    {
      v65 = v195[v63];
      *(_BYTE *)(v47 + 191 + v63) = v65;
      if (!v65)
        break;
      if (++v63 == 83)
      {
        *(_BYTE *)(v47 + 274) = 0;
        break;
      }
    }
    v66 = (16 * (unsigned __int16)handle[188]) & 0x80000 | (*(unsigned __int16 *)(v47 + 188) | (*(unsigned __int8 *)(v47 + 190) << 16)) & 0xFFF7FFFF;
    *(_WORD *)(v47 + 188) = *(_WORD *)(v47 + 188);
    *(_BYTE *)(v47 + 190) = BYTE2(v66);
    *(_DWORD *)(v47 + 180) = *((_DWORD *)handle + 92);
    v44[4] = v47;
    v67 = *(unsigned __int16 *)(v47 + 188);
    v68 = v67 | (*(unsigned __int8 *)(v47 + 190) << 16);
    if ((v67 & 0x80) == 0)
      goto LABEL_76;
    if (a1->default_input_handler)
    {
      if ((v68 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v80 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v82 = *(_DWORD *)(v47 + 176);
          v81 = *(_DWORD *)(v47 + 180);
          *(_DWORD *)buf = 136447234;
          v182 = "nw_protocol_http2_add_input_handler";
          v183 = 2082;
          v184 = v47 + 191;
          v185 = 2080;
          v186 = (uint64_t)" ";
          v187 = 1024;
          v188 = v81;
          v189 = 1024;
          *(_DWORD *)v190 = v82;
          _os_log_impl(&dword_182FBE000, v80, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> http2 has default_input_handler on the first stream in a listening connection. Is a connection trying to join while having server set on the parameters?", buf, 0x2Cu);
        }
      }
      nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      if ((*(_BYTE *)(v47 + 168) & 1) != 0)
      {
        v83 = *(void **)(v47 + 160);
        if (v83)
          os_release(v83);
      }
      *(_QWORD *)(v47 + 160) = 0;
      if ((*(_BYTE *)(v47 + 152) & 1) != 0)
      {
        v84 = *(void **)(v47 + 144);
        if (v84)
          os_release(v84);
      }
      *(_QWORD *)(v47 + 144) = 0;
      v85 = *(void **)(v47 + 120);
      if (v85)
      {
        *(_QWORD *)(v47 + 128) = v85;
        operator delete(v85);
      }
    }
    else
    {
      if ((v68 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v176 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v178 = *(_DWORD *)(v47 + 176);
          v177 = *(_DWORD *)(v47 + 180);
          *(_DWORD *)buf = 136447234;
          v182 = "nw_protocol_http2_add_input_handler";
          v183 = 2082;
          v184 = v47 + 191;
          v185 = 2080;
          v186 = (uint64_t)" ";
          v187 = 1024;
          v188 = v177;
          v189 = 1024;
          *(_DWORD *)v190 = v178;
          _os_log_impl(&dword_182FBE000, v176, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> responder's first stream detected, overriding stream id to 1", buf, 0x2Cu);
        }
      }
      *(_DWORD *)(v47 + 176) = 1;
      v121 = nw_http2_add_to_id_table((uint64_t)handle, v47, (uint64_t)a2);
      v122 = *(unsigned __int16 *)(v47 + 188) | (*(unsigned __int8 *)(v47 + 190) << 16);
      if (v121)
      {
        if ((v122 & 0x80000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v123 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v125 = *(_DWORD *)(v47 + 176);
            v124 = *(_DWORD *)(v47 + 180);
            v126 = v44[4];
            *(_DWORD *)buf = 136447746;
            v182 = "nw_protocol_http2_add_input_handler";
            v183 = 2082;
            v184 = v47 + 191;
            v185 = 2080;
            v186 = (uint64_t)" ";
            v187 = 1024;
            v188 = v124;
            v189 = 1024;
            *(_DWORD *)v190 = v125;
            *(_WORD *)&v190[4] = 2048;
            *(_QWORD *)&v190[6] = v47;
            *(_WORD *)&v190[14] = 2048;
            *(_QWORD *)&v190[16] = v126;
            v112 = "%{public}s %{public}s%s<i%u:s%d> new stream is %p, stream pointer is %p";
            v113 = v123;
            v114 = OS_LOG_TYPE_DEBUG;
            v115 = 64;
            goto LABEL_140;
          }
        }
LABEL_76:
        v69 = nw_parameters_copy_protocol_options_legacy(v12, a1);
        if (!v69
          || (v70 = v69,
              singleton = nw_http_messaging_options_copy_transaction_metadata(v69),
              v72 = nw_http2_get_capsule_handling_disabled(v70) != 0,
              v73 = (*(unsigned __int16 *)(v47 + 188) | (*(unsigned __int8 *)(v47 + 190) << 16)) & 0xFFFEFFFF,
              *(_WORD *)(v47 + 188) = *(_WORD *)(v47 + 188),
              *(_BYTE *)(v47 + 190) = BYTE2(v73) | v72,
              os_release(v70),
              !singleton))
        {
          if (nw_protocol_copy_http_transaction_definition_onceToken != -1)
            dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_59_74256);
          singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_transaction_definition_definition);
        }
        *(_QWORD *)(v47 + 96) = singleton;
        if (v19)
        {
          nw_http_transaction_metadata_set_first_on_connection(singleton);
          singleton = *(void **)(v47 + 96);
        }
        nw_http_transaction_metadata_set_connection_metadata(singleton, *((void **)handle + 32));
        if (((*(unsigned __int16 *)(v47 + 188) | (*(unsigned __int8 *)(v47 + 190) << 16)) & 0x80000) == 0
          && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v172 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v174 = *(_DWORD *)(v47 + 176);
            v173 = *(_DWORD *)(v47 + 180);
            identifier = a2->identifier;
            *(_DWORD *)buf = 136448002;
            v182 = "nw_protocol_http2_add_input_handler";
            v183 = 2082;
            v184 = v47 + 191;
            v185 = 2080;
            v186 = (uint64_t)" ";
            v187 = 1024;
            v188 = v173;
            v189 = 1024;
            *(_DWORD *)v190 = v174;
            *(_WORD *)&v190[4] = 2048;
            *(_QWORD *)&v190[6] = a2;
            *(_WORD *)&v190[14] = 2080;
            *(_QWORD *)&v190[16] = identifier;
            *(_WORD *)&v190[24] = 2048;
            *(_QWORD *)v191 = v44;
            _os_log_impl(&dword_182FBE000, v172, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting input protocol %p (%s) output_handler_context to %p", buf, 0x4Au);
          }
        }
        a2->output_handler_context = v44;
        nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
        if (a1->default_input_handler)
        {
          if (!v19)
            goto LABEL_115;
        }
        else
        {
          nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
          *(_OWORD *)handle = *(_OWORD *)a2->flow_id;
          if (!v19)
            goto LABEL_115;
        }
        if (!*((_QWORD *)handle + 36))
        {
          v127 = v12;
          v128 = *(id *)(v127[13] + 136);

          v129 = (void *)*((_QWORD *)handle + 35);
          if (v129)
          {
            os_release(v129);
            *((_QWORD *)handle + 35) = 0;
          }
          v130 = nw_path_copy_flow_registration(v128, (uint64_t)handle);
          *((_QWORD *)handle + 35) = v130;
          if (v128)
          {
            os_release(v128);
            v130 = (id)*((_QWORD *)handle + 35);
          }
          if (v130)
          {
            v131 = nw_path_flow_registration_copy_endpoint(v130);
            v132 = nw_path_flow_registration_copy_parameters(*((void **)handle + 35));
            v133 = nw_endpoint_copy_association_with_evaluator(v131, v132, 0);
            *((_QWORD *)handle + 36) = v133;
            if (v131)
            {
              os_release(v131);
              v133 = (id *)*((_QWORD *)handle + 36);
            }
            if (v133)
            {
              v134 = nw_protocol_instance_stub_create((nw_protocol *)handle);
              *((_QWORD *)handle + 37) = v134;
              nw_association_register(*((void **)handle + 36), v127, v134, 0, &__block_literal_global_53);
              v135 = nw_association_copy_current_path(*((void **)handle + 36), v132);
              if (v135)
              {
                v136 = v135;
                v137 = nw_path_copy_for_flow_registration(v135, *((void **)handle + 35));
                if (v137)
                {
                  v138 = (void *)v137;
                  v139 = (void *)*((_QWORD *)handle + 15);
                  if (v139 != v138)
                  {
                    if (v139)
                    {
                      os_release(v139);
                      *((_QWORD *)handle + 15) = 0;
                    }
                    *((_QWORD *)handle + 15) = os_retain(v138);
                  }
                  if (nw_path_has_flows(v138))
                    v140 = 32;
                  else
                    v140 = 0;
                  handle[188] = handle[188] & 0xFFDF | v140;
                  v141 = nw_parameters_copy_effective_proxy_config(v127);
                  if (v141)
                  {
                    v142 = v141;
                    if (nw_path_has_proxy_config(v136, v141))
                    {
                      v143 = (void *)*((_QWORD *)handle + 38);
                      if (v143)
                        os_release(v143);
                      *((_QWORD *)handle + 38) = v142;
                    }
                    else
                    {
                      os_release(v142);
                    }
                  }
                  os_release(v136);
                }
                else
                {
                  v138 = v136;
                }
                os_release(v138);
              }
            }
            if (v132)
              os_release(v132);
          }
        }
LABEL_115:
        v88 = *((_QWORD *)handle + 11);
        if (v88)
        {
          nw_queue_cancel_source(v88, v74);
          *((_QWORD *)handle + 11) = 0;
        }
        if (!*((_QWORD *)handle + 13))
          *((_QWORD *)handle + 13) = os_retain(v12);
        v89 = *(unsigned __int16 *)(v47 + 188) | (*(unsigned __int8 *)(v47 + 190) << 16);
        if (v195[0])
        {
          if ((v89 & 0x80000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v90 = gconnectionLogObj;
            v91 = 1;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
              return v91;
            v93 = v47 + 191;
            v96 = v47 + 176;
            v94 = *(_DWORD *)(v47 + 176);
            v95 = *(_DWORD *)(v96 + 4);
            v97 = nw_hash_table_count(*((_QWORD *)handle + 19), v92);
            *(_DWORD *)buf = 136448002;
            v182 = "nw_protocol_http2_add_input_handler";
            v183 = 2082;
            v184 = v93;
            v185 = 2080;
            v186 = (uint64_t)" ";
            v187 = 1024;
            v188 = v95;
            v189 = 1024;
            *(_DWORD *)v190 = v94;
            *(_WORD *)&v190[4] = 2048;
            *(_QWORD *)&v190[6] = a2;
            *(_WORD *)&v190[14] = 2082;
            *(_QWORD *)&v190[16] = v195;
            *(_WORD *)&v190[24] = 1024;
            *(_DWORD *)v191 = v97;
            v98 = "%{public}s %{public}s%s<i%u:s%d> added input handler %p from %{public}s, now have %u input handlers";
            v91 = 1;
            v99 = v90;
            v100 = 70;
            goto LABEL_130;
          }
        }
        else if ((v89 & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v101 = gconnectionLogObj;
          v91 = 1;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
            return v91;
          v103 = v47 + 191;
          v106 = v47 + 176;
          v104 = *(_DWORD *)(v47 + 176);
          v105 = *(_DWORD *)(v106 + 4);
          v107 = nw_hash_table_count(*((_QWORD *)handle + 19), v102);
          *(_DWORD *)buf = 136447746;
          v182 = "nw_protocol_http2_add_input_handler";
          v183 = 2082;
          v184 = v103;
          v185 = 2080;
          v186 = (uint64_t)" ";
          v187 = 1024;
          v188 = v105;
          v189 = 1024;
          *(_DWORD *)v190 = v104;
          *(_WORD *)&v190[4] = 2048;
          *(_QWORD *)&v190[6] = a2;
          *(_WORD *)&v190[14] = 1024;
          *(_DWORD *)&v190[16] = v107;
          v98 = "%{public}s %{public}s%s<i%u:s%d> added input handler %p, now have %u input handlers";
          v91 = 1;
          v99 = v101;
          v100 = 60;
LABEL_130:
          _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_INFO, v98, buf, v100);
          return v91;
        }
        return 1;
      }
      if ((v122 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v147 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v149 = *(_DWORD *)(v47 + 176);
          v148 = *(_DWORD *)(v47 + 180);
          *(_DWORD *)buf = 136447234;
          v182 = "nw_protocol_http2_add_input_handler";
          v183 = 2082;
          v184 = v47 + 191;
          v185 = 2080;
          v186 = (uint64_t)" ";
          v187 = 1024;
          v188 = v148;
          v189 = 1024;
          *(_DWORD *)v190 = v149;
          _os_log_impl(&dword_182FBE000, v147, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> Failed to add new stream to the id based hash table", buf, 0x2Cu);
        }
      }
      nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      std::destroy_at[abi:nn180100]<http2_stream,0>(v47);
    }
    free((void *)v47);
    return 0;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_http2_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  _BYTE *v5;
  char *v6;
  _QWORD *output_handler_context;
  uint64_t v8;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  _BOOL8 result;
  int v15;
  uint64_t v16;
  int v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  uint32_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  int v28;
  NSObject *v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  const char *v38;
  NSObject *v39;
  uint32_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  NSObject *v47;
  int v48;
  int v49;
  BOOL v51;
  char *v52;
  int v53;
  const char *v54;
  NSObject *v55;
  os_log_type_t v56;
  int v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  int v63;
  uint64_t v64;
  dispatch_time_t v65;
  uint64_t v66;
  char *v67;
  _BOOL4 v68;
  int v69;
  int v70;
  int v71;
  char *v72;
  const char *v73;
  NSObject *v74;
  os_log_type_t v75;
  const char *v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  const char *v80;
  NSObject *v81;
  int v82;
  NSObject *v83;
  int v84;
  char *backtrace_string;
  _BOOL4 v86;
  const char *v87;
  _BOOL4 v88;
  _BOOL4 v89;
  char *v90;
  _BOOL4 v91;
  char *v92;
  _BOOL4 v93;
  NSObject *v94;
  int v95;
  int v96;
  NSObject *v97;
  int v98;
  NSObject *v99;
  int v100;
  _QWORD v101[6];
  _QWORD v102[5];
  char v103;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v106;
  __int16 v107;
  char *v108;
  __int16 v109;
  const char *v110;
  __int16 v111;
  int v112;
  __int16 v113;
  _BYTE v114[24];
  __int16 v115;
  int v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_remove_input_handler";
    v73 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v73, &type, &v103))
      goto LABEL_207;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v74 = __nwlog_obj();
      v75 = type;
      if (!os_log_type_enabled(v74, type))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_remove_input_handler";
      v76 = "%{public}s called with null protocol";
LABEL_206:
      _os_log_impl(&dword_182FBE000, v74, v75, v76, buf, 0xCu);
      goto LABEL_207;
    }
    if (!v103)
    {
      v74 = __nwlog_obj();
      v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)buf = 136446210;
        v106 = "nw_protocol_http2_remove_input_handler";
        v76 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v74 = __nwlog_obj();
    v75 = type;
    v86 = os_log_type_enabled(v74, type);
    if (!backtrace_string)
    {
      if (v86)
      {
        *(_DWORD *)buf = 136446210;
        v106 = "nw_protocol_http2_remove_input_handler";
        v76 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    if (!v86)
      goto LABEL_163;
    *(_DWORD *)buf = 136446466;
    v106 = "nw_protocol_http2_remove_input_handler";
    v107 = 2082;
    v108 = backtrace_string;
    v87 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_162:
    _os_log_impl(&dword_182FBE000, v74, v75, v87, buf, 0x16u);
    goto LABEL_163;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_remove_input_handler";
    v73 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v73, &type, &v103))
      goto LABEL_207;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v74 = __nwlog_obj();
      v75 = type;
      if (!os_log_type_enabled(v74, type))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_remove_input_handler";
      v76 = "%{public}s called with null http2";
      goto LABEL_206;
    }
    if (!v103)
    {
      v74 = __nwlog_obj();
      v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)buf = 136446210;
        v106 = "nw_protocol_http2_remove_input_handler";
        v76 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v74 = __nwlog_obj();
    v75 = type;
    v88 = os_log_type_enabled(v74, type);
    if (!backtrace_string)
    {
      if (v88)
      {
        *(_DWORD *)buf = 136446210;
        v106 = "nw_protocol_http2_remove_input_handler";
        v76 = "%{public}s called with null http2, no backtrace";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    if (!v88)
      goto LABEL_163;
    *(_DWORD *)buf = 136446466;
    v106 = "nw_protocol_http2_remove_input_handler";
    v107 = 2082;
    v108 = backtrace_string;
    v87 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_162;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_remove_input_handler";
    v73 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v73, &type, &v103))
      goto LABEL_207;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v74 = __nwlog_obj();
      v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)buf = 136446210;
        v106 = "nw_protocol_http2_remove_input_handler";
        v76 = "%{public}s called with null input_protocol";
        goto LABEL_206;
      }
LABEL_207:
      if (!v73)
        return 0;
      v72 = (char *)v73;
      goto LABEL_119;
    }
    if (!v103)
    {
      v74 = __nwlog_obj();
      v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)buf = 136446210;
        v106 = "nw_protocol_http2_remove_input_handler";
        v76 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v74 = __nwlog_obj();
    v75 = type;
    v89 = os_log_type_enabled(v74, type);
    if (!backtrace_string)
    {
      if (v89)
      {
        *(_DWORD *)buf = 136446210;
        v106 = "nw_protocol_http2_remove_input_handler";
        v76 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      v106 = "nw_protocol_http2_remove_input_handler";
      v107 = 2082;
      v108 = backtrace_string;
      v87 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_162;
    }
LABEL_163:
    free(backtrace_string);
    goto LABEL_207;
  }
  v5 = &unk_1ECD84000;
  if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v81 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v82 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447234;
      v106 = "nw_protocol_http2_remove_input_handler";
      v107 = 2082;
      v108 = handle + 378;
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v82;
      v113 = 2048;
      *(_QWORD *)v114 = a2;
      _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with input_protocol %p", buf, 0x30u);
    }
  }
  v6 = (char *)a1->handle;
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_http2_remove_input_handler";
    v77 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v77, &type, &v103))
      goto LABEL_214;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_http2_remove_input_handler";
      v80 = "%{public}s called with null http2";
      goto LABEL_213;
    }
    if (!v103)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_http2_remove_input_handler";
      v80 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_213;
    }
    v90 = (char *)__nw_create_backtrace_string();
    v78 = __nwlog_obj();
    v79 = type;
    v91 = os_log_type_enabled(v78, type);
    if (!v90)
    {
      if (!v91)
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_http2_remove_input_handler";
      v80 = "%{public}s called with null http2, no backtrace";
      goto LABEL_213;
    }
    if (v91)
    {
      *(_DWORD *)buf = 136446466;
      v106 = "nw_http2_remove_input_handler";
      v107 = 2082;
      v108 = v90;
      _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v90);
LABEL_214:
    if (!v77)
      goto LABEL_20;
    goto LABEL_215;
  }
  if (!*((_QWORD *)handle + 19))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_http2_remove_input_handler";
    v77 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v77, &type, &v103))
      goto LABEL_214;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_http2_remove_input_handler";
      v80 = "%{public}s called with null table";
      goto LABEL_213;
    }
    if (!v103)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_http2_remove_input_handler";
      v80 = "%{public}s called with null table, backtrace limit exceeded";
      goto LABEL_213;
    }
    v92 = (char *)__nw_create_backtrace_string();
    v78 = __nwlog_obj();
    v79 = type;
    v93 = os_log_type_enabled(v78, type);
    if (v92)
    {
      if (v93)
      {
        *(_DWORD *)buf = 136446466;
        v106 = "nw_http2_remove_input_handler";
        v107 = 2082;
        v108 = v92;
        _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v92);
      if (!v77)
        goto LABEL_20;
LABEL_215:
      free(v77);
      goto LABEL_20;
    }
    if (v93)
    {
      *(_DWORD *)buf = 136446210;
      v106 = "nw_http2_remove_input_handler";
      v80 = "%{public}s called with null table, no backtrace";
LABEL_213:
      _os_log_impl(&dword_182FBE000, v78, v79, v80, buf, 0xCu);
      goto LABEL_214;
    }
    goto LABEL_214;
  }
  if ((*((__int16 *)v6 + 188) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v83 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v84 = *((_DWORD *)v6 + 92);
      *(_DWORD *)buf = 136446978;
      v106 = "nw_http2_remove_input_handler";
      v107 = 2082;
      v108 = v6 + 378;
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v84;
      _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    v8 = output_handler_context[4];
    if (v8)
    {
      nw_http_transaction_metadata_mark_end(*(void **)(v8 + 96));
      v9 = *(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16);
      v10 = *(_WORD *)(v8 + 188) & 0xFFFB | (*(unsigned __int8 *)(v8 + 190) << 16);
      *(_WORD *)(v8 + 188) &= ~4u;
      *(_BYTE *)(v8 + 190) = BYTE2(v10);
      if ((v9 & 1) != 0 || *(_DWORD *)(v8 + 176) != -1)
      {
        nw_http2_stream_close((uint64_t)v6, v8);
        goto LABEL_36;
      }
      if ((v9 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v22 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v24 = *(_DWORD *)(v8 + 176);
          v23 = *(_DWORD *)(v8 + 180);
          *(_DWORD *)buf = 136447234;
          v106 = "nw_http2_remove_input_handler";
          v107 = 2082;
          v108 = (char *)(v8 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v23;
          v113 = 1024;
          *(_DWORD *)v114 = v24;
          v18 = "%{public}s %{public}s%s<i%u:s%d> not closing already closed stream";
          v19 = v22;
          v20 = OS_LOG_TYPE_DEBUG;
          v21 = 44;
          goto LABEL_35;
        }
      }
    }
    else if ((*((__int16 *)v6 + 188) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v17 = *((_DWORD *)v6 + 92);
        *(_DWORD *)buf = 136446978;
        v106 = "nw_http2_remove_input_handler";
        v107 = 2082;
        v108 = v6 + 378;
        v109 = 2080;
        v110 = " ";
        v111 = 1024;
        v112 = v17;
        v18 = "%{public}s %{public}s%s<i%u> stream not found as extra";
        v19 = v16;
        v20 = OS_LOG_TYPE_ERROR;
        v21 = 38;
LABEL_35:
        _os_log_impl(&dword_182FBE000, v19, v20, v18, buf, v21);
      }
    }
LABEL_36:
    if (nw_http2_remove_from_protocol_table((uint64_t)v6, (uint64_t)a2))
    {
      nw_protocol_set_output_handler((uint64_t)a2, 0);
      if (!v8)
      {
        if (*((__int16 *)v6 + 188) < 0)
          goto LABEL_63;
        goto LABEL_39;
      }
    }
    else
    {
      if (!v8)
      {
        if ((*((__int16 *)v6 + 188) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v94 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            v95 = *((_DWORD *)v6 + 92);
            *(_DWORD *)buf = 136447234;
            v106 = "nw_http2_remove_input_handler";
            v107 = 2082;
            v108 = v6 + 378;
            v109 = 2080;
            v110 = " ";
            v111 = 1024;
            v112 = v95;
            v113 = 2048;
            *(_QWORD *)v114 = a2;
            _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> unable to remove protocol %p from protocol table", buf, 0x30u);
          }
        }
        nw_protocol_set_output_handler((uint64_t)a2, 0);
        if (*((__int16 *)v6 + 188) < 0)
        {
LABEL_63:
          v46 = *((_QWORD *)handle + 19);
          if (v46)
          {
            if ((*((_WORD *)handle + 188) & 0xC) == 0 && a1->default_input_handler == a2)
            {
              if ((*((_WORD *)handle + 188) & 0x8000) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v47 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  v48 = *((_DWORD *)handle + 92);
                  *(_DWORD *)buf = 136446978;
                  v106 = "nw_protocol_http2_remove_input_handler";
                  v107 = 2082;
                  v108 = handle + 378;
                  v109 = 2080;
                  v110 = " ";
                  v111 = 1024;
                  v112 = v48;
                  _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> first input handler bailed, closing", buf, 0x26u);
                }
              }
              *((_WORD *)handle + 188) |= 8u;
              nw_protocol_remove_instance((uint64_t)a1);
              nw_protocol_http2_notify((uint64_t)a1, (uint64_t)a1, 0x16u, 0, 0);
              v46 = *((_QWORD *)handle + 19);
            }
            v49 = nw_hash_table_count(v46, v25);
            v51 = *((__int16 *)handle + 188) < 0 || v5[1345] == 0;
            if (v49)
            {
              if (!v51)
              {
                v96 = v49;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v97 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v98 = *((_DWORD *)handle + 92);
                  *(_DWORD *)buf = 136447234;
                  v106 = "nw_protocol_http2_remove_input_handler";
                  v107 = 2082;
                  v108 = handle + 378;
                  v109 = 2080;
                  v110 = " ";
                  v111 = 1024;
                  v112 = v98;
                  v113 = 1024;
                  *(_DWORD *)v114 = v96;
                  _os_log_impl(&dword_182FBE000, v97, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> not destroying, still have %u input handlers", buf, 0x2Cu);
                }
              }
              if (a1->default_input_handler == a2)
              {
                nw_protocol_set_input_handler((uint64_t)a1, 0);
                v52 = (char *)*((_QWORD *)handle + 19);
                v101[0] = MEMORY[0x1E0C809B0];
                v101[1] = 0x40000000;
                v101[2] = ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke_56;
                v101[3] = &__block_descriptor_tmp_57_82964;
                v101[4] = a1;
                v101[5] = handle;
                nw_hash_table_apply(v52, (uint64_t)v101);
              }
            }
            else
            {
              if (!v51)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v99 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v100 = *((_DWORD *)handle + 92);
                  *(_DWORD *)buf = 136446978;
                  v106 = "nw_protocol_http2_remove_input_handler";
                  v107 = 2082;
                  v108 = handle + 378;
                  v109 = 2080;
                  v110 = " ";
                  v111 = 1024;
                  v112 = v100;
                  _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> no more input handlers, scheduling destroy", buf, 0x26u);
                }
              }
              nw_protocol_set_input_handler((uint64_t)a1, 0);
              nw_frame_cache_remove_all((uint64_t *)handle + 25);
              v60 = *((_QWORD *)handle + 11);
              if (v60)
                nw_queue_cancel_source(v60, v59);
              v102[0] = MEMORY[0x1E0C809B0];
              v102[1] = 0x40000000;
              v102[2] = ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke;
              v102[3] = &__block_descriptor_tmp_55_82961;
              v102[4] = a1;
              *((_QWORD *)handle + 11) = nw_queue_context_create_source(0, 2, 3, 0, v102, 0);
              v61 = *((_QWORD *)handle + 10);
              if (!nw_protocol_http2_accept((uint64_t)a1))
              {
                if ((*((__int16 *)handle + 188) & 0x80000000) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v62 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
                  {
                    v63 = *((_DWORD *)handle + 92);
                    *(_DWORD *)buf = 136446978;
                    v106 = "nw_protocol_http2_remove_input_handler";
                    v107 = 2082;
                    v108 = handle + 378;
                    v109 = 2080;
                    v110 = " ";
                    v111 = 1024;
                    v112 = v63;
                    _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> cannot accept input handlers, destroying immediately", buf, 0x26u);
                  }
                }
                v61 = 0;
              }
              v64 = *((_QWORD *)handle + 11);
              v65 = dispatch_time(0x8000000000000000, 1000000 * v61);
              nw_queue_set_timer_values(v64, v65, 0xFFFFFFFFFFFFFFFFLL, 1000 * v61);
              nw_queue_activate_source(*((_QWORD *)handle + 11), v66);
            }
            return 1;
          }
          if ((*((_WORD *)handle + 188) & 0x8000) != 0)
            return 0;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v53 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136447234;
          v106 = "nw_protocol_http2_remove_input_handler";
          v107 = 2082;
          v108 = handle + 378;
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v53;
          v113 = 2048;
          *(_QWORD *)v114 = a2;
          v54 = (const char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v103 = 0;
          if (__nwlog_fault(v54, &type, &v103))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v55 = gconnectionLogObj;
              v56 = type;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
              {
                v57 = *((_DWORD *)handle + 92);
                *(_DWORD *)buf = 136447234;
                v106 = "nw_protocol_http2_remove_input_handler";
                v107 = 2082;
                v108 = handle + 378;
                v109 = 2080;
                v110 = " ";
                v111 = 1024;
                v112 = v57;
                v113 = 2048;
                *(_QWORD *)v114 = a2;
                v58 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p";
LABEL_116:
                _os_log_impl(&dword_182FBE000, v55, v56, v58, buf, 0x30u);
              }
            }
            else if (v103)
            {
              v67 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v55 = gconnectionLogObj;
              v56 = type;
              v68 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
              if (!v67)
              {
                if (!v68)
                  goto LABEL_117;
                v71 = *((_DWORD *)handle + 92);
                *(_DWORD *)buf = 136447234;
                v106 = "nw_protocol_http2_remove_input_handler";
                v107 = 2082;
                v108 = handle + 378;
                v109 = 2080;
                v110 = " ";
                v111 = 1024;
                v112 = v71;
                v113 = 2048;
                *(_QWORD *)v114 = a2;
                v58 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p, no backtrace";
                goto LABEL_116;
              }
              if (v68)
              {
                v69 = *((_DWORD *)handle + 92);
                *(_DWORD *)buf = 136447490;
                v106 = "nw_protocol_http2_remove_input_handler";
                v107 = 2082;
                v108 = handle + 378;
                v109 = 2080;
                v110 = " ";
                v111 = 1024;
                v112 = v69;
                v113 = 2048;
                *(_QWORD *)v114 = a2;
                *(_WORD *)&v114[8] = 2082;
                *(_QWORD *)&v114[10] = v67;
                _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p, dumping backtrace:%{public}s", buf, 0x3Au);
              }
              free(v67);
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v55 = gconnectionLogObj;
              v56 = type;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
              {
                v70 = *((_DWORD *)handle + 92);
                *(_DWORD *)buf = 136447234;
                v106 = "nw_protocol_http2_remove_input_handler";
                v107 = 2082;
                v108 = handle + 378;
                v109 = 2080;
                v110 = " ";
                v111 = 1024;
                v112 = v70;
                v113 = 2048;
                *(_QWORD *)v114 = a2;
                v58 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p, backtrace limit exceeded";
                goto LABEL_116;
              }
            }
          }
LABEL_117:
          if (v54)
          {
            v72 = (char *)v54;
LABEL_119:
            free(v72);
          }
          return 0;
        }
LABEL_39:
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v26 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v27 = *((_DWORD *)v6 + 92);
          v28 = nw_hash_table_count(*((_QWORD *)v6 + 19), v25);
          *(_DWORD *)buf = 136447490;
          v106 = "nw_http2_remove_input_handler";
          v107 = 2082;
          v108 = v6 + 378;
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v27;
          v113 = 2048;
          *(_QWORD *)v114 = a2;
          *(_WORD *)&v114[8] = 1024;
          *(_DWORD *)&v114[10] = v28;
          _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removed input handler %p, now have %u input handlers", buf, 0x36u);
        }
        goto LABEL_63;
      }
      if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v29 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v31 = *(_DWORD *)(v8 + 176);
          v30 = *(_DWORD *)(v8 + 180);
          *(_DWORD *)buf = 136447490;
          v106 = "nw_http2_remove_input_handler";
          v107 = 2082;
          v108 = (char *)(v8 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v30;
          v113 = 1024;
          *(_DWORD *)v114 = v31;
          *(_WORD *)&v114[4] = 2048;
          *(_QWORD *)&v114[6] = a2;
          _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> unable to remove protocol %p from protocol table", buf, 0x36u);
        }
      }
      nw_protocol_set_output_handler((uint64_t)a2, 0);
    }
    v32 = *(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16);
    if (*(_BYTE *)(v8 + 191))
    {
      if ((v32 & 0x80000) != 0)
        goto LABEL_62;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v33 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        goto LABEL_62;
      v35 = *(_DWORD *)(v8 + 176);
      v36 = *(_DWORD *)(v8 + 180);
      v37 = nw_hash_table_count(*((_QWORD *)v6 + 19), v34);
      *(_DWORD *)buf = 136448002;
      v106 = "nw_http2_remove_input_handler";
      v107 = 2082;
      v108 = (char *)(v8 + 191);
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v36;
      v5 = (_BYTE *)&unk_1ECD84000;
      v113 = 1024;
      *(_DWORD *)v114 = v35;
      *(_WORD *)&v114[4] = 2048;
      *(_QWORD *)&v114[6] = a2;
      *(_WORD *)&v114[14] = 2080;
      *(_QWORD *)&v114[16] = v8 + 191;
      v115 = 1024;
      v116 = v37;
      v38 = "%{public}s %{public}s%s<i%u:s%d> removed input handler %p, originally from %s, now have %u input handlers";
      v39 = v33;
      v40 = 70;
    }
    else
    {
      if ((v32 & 0x80000) != 0)
        goto LABEL_62;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v41 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        goto LABEL_62;
      v44 = *(_DWORD *)(v8 + 176);
      v43 = *(_DWORD *)(v8 + 180);
      v45 = nw_hash_table_count(*((_QWORD *)v6 + 19), v42);
      *(_DWORD *)buf = 136447746;
      v106 = "nw_http2_remove_input_handler";
      v107 = 2082;
      v108 = (char *)(v8 + 191);
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v43;
      v113 = 1024;
      *(_DWORD *)v114 = v44;
      v5 = &unk_1ECD84000;
      *(_WORD *)&v114[4] = 2048;
      *(_QWORD *)&v114[6] = a2;
      *(_WORD *)&v114[14] = 1024;
      *(_DWORD *)&v114[16] = v45;
      v38 = "%{public}s %{public}s%s<i%u:s%d> removed input handler %p, now have %u input handlers";
      v39 = v41;
      v40 = 60;
    }
    _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, v38, buf, v40);
LABEL_62:
    nw_http2_stream_destroy((void **)v8);
    goto LABEL_63;
  }
  if ((*((__int16 *)v6 + 188) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v11 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      v12 = *((_DWORD *)v6 + 92);
      *(_DWORD *)buf = 136447234;
      v106 = "nw_http2_remove_input_handler";
      v107 = 2082;
      v108 = v6 + 378;
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v12;
      v113 = 2048;
      *(_QWORD *)v114 = a2;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> output handler context doesn't exist on protocol %p", buf, 0x30u);
    }
  }
LABEL_20:
  if (*((__int16 *)handle + 188) < 0)
    return 0;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v13 = gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v15 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447490;
    v106 = "nw_protocol_http2_remove_input_handler";
    v107 = 2082;
    v108 = handle + 378;
    v109 = 2080;
    v110 = " ";
    v111 = 1024;
    v112 = v15;
    v113 = 1042;
    *(_DWORD *)v114 = 16;
    *(_WORD *)&v114[4] = 2098;
    *(_QWORD *)&v114[6] = a2;
    _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> http2 does not have input handler registered for %{public,uuid_t}.16P", buf, 0x36u);
    return 0;
  }
  return result;
}

BOOL nw_protocol_http2_replace_input_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  int v13;
  uint64_t stream_node_from_id;
  _BOOL8 result;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  const char *v25;
  NSObject *v26;
  uint32_t v27;
  uint64_t v28;
  int v29;
  int v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  NSObject *v35;
  int v36;
  char *backtrace_string;
  _BOOL4 v38;
  const char *v39;
  _BOOL4 v40;
  _BOOL4 v41;
  _BOOL4 v42;
  int v43;
  _QWORD v44[2];
  uint64_t (*v45)(uint64_t, uint64_t);
  void *v46;
  uint64_t v47;
  char v48;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http2_replace_input_handler";
    v31 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v31, &type, &v48))
      goto LABEL_99;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null protocol";
      goto LABEL_98;
    }
    if (!v48)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v33 = type;
    v38 = os_log_type_enabled(v32, type);
    if (!backtrace_string)
    {
      if (!v38)
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_98;
    }
    if (!v38)
      goto LABEL_76;
    *(_DWORD *)buf = 136446466;
    v51 = "nw_protocol_http2_replace_input_handler";
    v52 = 2082;
    v53 = backtrace_string;
    v39 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_75:
    _os_log_impl(&dword_182FBE000, v32, v33, v39, buf, 0x16u);
    goto LABEL_76;
  }
  v4 = *(_QWORD *)(a1 + 40);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http2_replace_input_handler";
    v31 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v31, &type, &v48))
      goto LABEL_99;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null http2";
      goto LABEL_98;
    }
    if (!v48)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v33 = type;
    v40 = os_log_type_enabled(v32, type);
    if (!backtrace_string)
    {
      if (!v40)
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null http2, no backtrace";
      goto LABEL_98;
    }
    if (!v40)
      goto LABEL_76;
    *(_DWORD *)buf = 136446466;
    v51 = "nw_protocol_http2_replace_input_handler";
    v52 = 2082;
    v53 = backtrace_string;
    v39 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_75;
  }
  if ((*(__int16 *)(v4 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v35 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v36 = *(_DWORD *)(v4 + 368);
      *(_DWORD *)buf = 136446978;
      v51 = "nw_protocol_http2_replace_input_handler";
      v52 = 2082;
      v53 = (char *)(v4 + 378);
      v54 = 2080;
      v55 = " ";
      v56 = 1024;
      v57 = v36;
      _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http2_replace_input_handler";
    v31 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v31, &type, &v48))
      goto LABEL_99;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null old_input_protocol";
      goto LABEL_98;
    }
    if (!v48)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null old_input_protocol, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v33 = type;
    v41 = os_log_type_enabled(v32, type);
    if (!backtrace_string)
    {
      if (!v41)
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null old_input_protocol, no backtrace";
      goto LABEL_98;
    }
    if (!v41)
      goto LABEL_76;
    *(_DWORD *)buf = 136446466;
    v51 = "nw_protocol_http2_replace_input_handler";
    v52 = 2082;
    v53 = backtrace_string;
    v39 = "%{public}s called with null old_input_protocol, dumping backtrace:%{public}s";
    goto LABEL_75;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http2_replace_input_handler";
    v31 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v31, &type, &v48))
      goto LABEL_99;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null new_input_protocol";
      goto LABEL_98;
    }
    if (!v48)
    {
      v32 = __nwlog_obj();
      v33 = type;
      if (!os_log_type_enabled(v32, type))
        goto LABEL_99;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http2_replace_input_handler";
      v34 = "%{public}s called with null new_input_protocol, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v32 = __nwlog_obj();
    v33 = type;
    v42 = os_log_type_enabled(v32, type);
    if (backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "nw_protocol_http2_replace_input_handler";
        v52 = 2082;
        v53 = backtrace_string;
        v39 = "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s";
        goto LABEL_75;
      }
LABEL_76:
      free(backtrace_string);
      goto LABEL_99;
    }
    if (!v42)
      goto LABEL_99;
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http2_replace_input_handler";
    v34 = "%{public}s called with null new_input_protocol, no backtrace";
LABEL_98:
    _os_log_impl(&dword_182FBE000, v32, v33, v34, buf, 0xCu);
LABEL_99:
    if (v31)
      free(v31);
    return 0;
  }
  v7 = *(_QWORD *)(a2 + 56);
  if (!v7)
  {
    if (*(__int16 *)(v4 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v23 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v24 = *(_DWORD *)(v4 + 368);
    *(_DWORD *)buf = 136446978;
    v51 = "nw_protocol_http2_replace_input_handler";
    v52 = 2082;
    v53 = (char *)(v4 + 378);
    v54 = 2080;
    v55 = " ";
    v56 = 1024;
    v57 = v24;
    v25 = "%{public}s %{public}s%s<i%u> Failed to find old node";
LABEL_29:
    v26 = v23;
    v27 = 38;
LABEL_36:
    _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_ERROR, v25, buf, v27);
    return 0;
  }
  v8 = *(_QWORD *)(v7 + 32);
  v44[0] = MEMORY[0x1E0C809B0];
  v44[1] = 0x40000000;
  v45 = ___ZL39nw_protocol_http2_replace_input_handlerP11nw_protocolS0_S0__block_invoke;
  v46 = &__block_descriptor_tmp_59_82865;
  v47 = a3;
  v9 = *(_QWORD *)(v8 + 16);
  do
  {
    if (!v9)
      break;
    v10 = *(_QWORD *)(v9 + 16);
    v11 = ((uint64_t (*)(_QWORD *))v45)(v44);
    v9 = v10;
  }
  while ((v11 & 1) != 0);
  nw_http2_remove_from_protocol_table(v4, a2);
  v12 = nw_http2_add_to_protocol_table(v4, a3, v8);
  if (v12)
  {
    *(_QWORD *)(a3 + 56) = v12;
    nw_protocol_set_output_handler(a3, a1);
    if (*(_QWORD *)(a1 + 48) == a2)
    {
      nw_protocol_set_input_handler(a1, a3);
      *(_OWORD *)v4 = *(_OWORD *)a3;
    }
    v13 = *(_DWORD *)(v8 + 176);
    if (v13 != -1)
    {
      stream_node_from_id = nw_http2_get_stream_node_from_id(v4, v13);
      if (stream_node_from_id)
        *(_QWORD *)(stream_node_from_id + 32) = a3;
    }
    result = 1;
    if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v18 = v8 + 191;
        v21 = v8 + 176;
        v19 = *(_DWORD *)(v8 + 176);
        v20 = *(_DWORD *)(v21 + 4);
        v22 = nw_hash_table_count(*(_QWORD *)(v4 + 152), v17);
        *(_DWORD *)buf = 136447490;
        v51 = "nw_protocol_http2_replace_input_handler";
        v52 = 2082;
        v53 = (char *)v18;
        v54 = 2080;
        v55 = " ";
        v56 = 1024;
        v57 = v20;
        v58 = 1024;
        v59 = v19;
        v60 = 1024;
        v61 = v22;
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> replaced input handler, have %u input handlers", buf, 0x32u);
      }
      return 1;
    }
    return result;
  }
  if (!v8)
  {
    if (*(__int16 *)(v4 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v23 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v43 = *(_DWORD *)(v4 + 368);
    *(_DWORD *)buf = 136446978;
    v51 = "nw_protocol_http2_replace_input_handler";
    v52 = 2082;
    v53 = (char *)(v4 + 378);
    v54 = 2080;
    v55 = " ";
    v56 = 1024;
    v57 = v43;
    v25 = "%{public}s %{public}s%s<i%u> could not add protocol to protocol based hash table, cannot replace input handler";
    goto LABEL_29;
  }
  if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) != 0)
    return 0;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v28 = gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v30 = *(_DWORD *)(v8 + 176);
    v29 = *(_DWORD *)(v8 + 180);
    *(_DWORD *)buf = 136447234;
    v51 = "nw_protocol_http2_replace_input_handler";
    v52 = 2082;
    v53 = (char *)(v8 + 191);
    v54 = 2080;
    v55 = " ";
    v56 = 1024;
    v57 = v29;
    v58 = 1024;
    v59 = v30;
    v25 = "%{public}s %{public}s%s<i%u:s%d> could not add protocol to protocol based hash table, cannot replace input handler";
    v26 = v28;
    v27 = 44;
    goto LABEL_36;
  }
  return result;
}

void nw_protocol_http2_input_available(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  NSObject *v7;
  int v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http2_input_available";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v3, &type, &v13))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_http2_input_available";
      v6 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_http2_input_available";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_40:
        if (!v3)
          return;
LABEL_41:
        free(v3);
        return;
      }
      if (!v10)
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_http2_input_available";
      v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_http2_input_available";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_39:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_40;
  }
  handle = a1->handle;
  if (handle)
  {
    if (((__int16)handle[94] & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v7 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v8 = handle[92];
        *(_DWORD *)buf = 136446978;
        v16 = "nw_protocol_http2_input_available";
        v17 = 2082;
        v18 = (char *)handle + 378;
        v19 = 2080;
        v20 = " ";
        v21 = 1024;
        v22 = v8;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    if ((handle[94] & 0x1000) == 0)
      nw_protocol_http2_process_input((uint64_t)handle);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_http2_input_available";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v3, &type, &v13))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http2_input_available";
    v6 = "%{public}s called with null http2";
    goto LABEL_39;
  }
  if (!v13)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http2_input_available";
    v6 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_39;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v12 = os_log_type_enabled(v4, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http2_input_available";
    v6 = "%{public}s called with null http2, no backtrace";
    goto LABEL_39;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_protocol_http2_input_available";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v3)
    goto LABEL_41;
}

void nw_protocol_http2_output_available(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  NSObject *v3;
  int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  int v12;
  char *backtrace_string;
  _BOOL4 v14;
  char *v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_output_available";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_51;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_output_available";
      v8 = "%{public}s called with null protocol";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_protocol_http2_output_available";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_51:
        if (!v5)
          return;
LABEL_52:
        free(v5);
        return;
      }
      if (!v14)
        goto LABEL_51;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_output_available";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_51;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_output_available";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_50:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_51;
  }
  handle = a1->handle;
  if (handle)
  {
    if (((__int16)handle[94] & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v9 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v10 = handle[92];
        *(_DWORD *)buf = 136446978;
        v20 = "nw_protocol_http2_output_available";
        v21 = 2082;
        v22 = (char *)handle + 378;
        v23 = 2080;
        v24 = " ";
        v25 = 1024;
        v26 = v10;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    if (nghttp2_session_want_write())
    {
      if (((__int16)handle[94] & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v3 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          v4 = handle[92];
          *(_DWORD *)buf = 136446978;
          v20 = "nw_protocol_http2_output_available";
          v21 = 2082;
          v22 = (char *)handle + 378;
          v23 = 2080;
          v24 = " ";
          v25 = 1024;
          v26 = v4;
          _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> session send wanted by nghttp2 library", buf, 0x26u);
        }
      }
      nw_http2_session_send((uint64_t)handle);
      if (((__int16)handle[94] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v11 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v12 = handle[92];
          *(_DWORD *)buf = 136446978;
          v20 = "nw_protocol_http2_output_available";
          v21 = 2082;
          v22 = (char *)handle + 378;
          v23 = 2080;
          v24 = " ";
          v25 = 1024;
          v26 = v12;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called session send for nghttp2 session", buf, 0x26u);
        }
      }
    }
    nw_http2_drain_output_frames((uint64_t)handle);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_http2_output_available";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v5, &type, &v17))
    goto LABEL_51;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_51;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_output_available";
    v8 = "%{public}s called with null http2";
    goto LABEL_50;
  }
  if (!v17)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_51;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_output_available";
    v8 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_50;
  }
  v15 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v16 = os_log_type_enabled(v6, type);
  if (!v15)
  {
    if (!v16)
      goto LABEL_51;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_output_available";
    v8 = "%{public}s called with null http2, no backtrace";
    goto LABEL_50;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v20 = "nw_protocol_http2_output_available";
    v21 = 2082;
    v22 = v15;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v15);
  if (v5)
    goto LABEL_52;
}

uint64_t nw_protocol_http2_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, unsigned int a5, nw_frame_array_s *a6)
{
  char *handle;
  _QWORD *output_handler_context;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  int v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  NSObject *v25;
  int v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  const char *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  nw_frame **v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  BOOL v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  NSObject *v61;
  int v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  os_log_type_t v66;
  int v67;
  uint64_t v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  _BOOL4 v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  os_log_type_t v79;
  int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  nw_frame **v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  os_log_type_t v90;
  uint64_t v91;
  NSObject *v92;
  os_log_type_t v93;
  const char *v94;
  uint64_t v95;
  NSObject *metadata_for_capsule;
  nw_frame **v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  os_log_type_t v103;
  uint64_t v104;
  NSObject *v105;
  os_log_type_t v106;
  const char *v107;
  char *v108;
  NSObject *v109;
  os_log_type_t v110;
  _BOOL4 v111;
  uint64_t v112;
  char *v113;
  NSObject *v114;
  os_log_type_t v115;
  _BOOL4 v116;
  uint64_t v117;
  uint64_t v118;
  os_log_type_t v119;
  uint64_t v120;
  NSObject *v121;
  os_log_type_t v122;
  uint64_t v123;
  uint64_t v124;
  char v125;
  NSObject *v126;
  int v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  char *v136;
  uint64_t v137;
  os_log_type_t v138;
  uint64_t v139;
  uint64_t v140;
  NSObject *v141;
  os_log_type_t v142;
  const char *v143;
  char *v144;
  NSObject *v145;
  os_log_type_t v146;
  _BOOL4 v147;
  uint64_t v148;
  uint64_t v149;
  NSObject *v150;
  os_log_type_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  NSObject *v156;
  NSObject *v157;
  int v158;
  int v159;
  uint64_t v160;
  uint64_t v161;
  NSObject *v162;
  int v163;
  int v164;
  NSObject *v165;
  int v166;
  int v167;
  uint64_t v168;
  NSObject *v169;
  _BOOL4 v170;
  int v171;
  int v172;
  BOOL v173;
  BOOL v174;
  uint64_t input_frame;
  uint64_t v176;
  NSObject *v177;
  int v178;
  int v179;
  char *v180;
  _BOOL4 v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  NSObject *v185;
  int v186;
  int v187;
  char v188;
  nw_frame **tqh_last;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  char *v193;
  NSObject *v194;
  os_log_type_t v195;
  uint64_t v196;
  const char *v197;
  char *v198;
  _BOOL4 v199;
  uint64_t v200;
  uint64_t v201;
  NSObject *v202;
  int v203;
  uint64_t v204;
  _BOOL4 v206;
  _BOOL4 v207;
  char *v208;
  NSObject *v209;
  os_log_type_t v210;
  const char *v211;
  NSObject *v212;
  int v213;
  NSObject *v214;
  int v215;
  NSObject *v216;
  int v217;
  int v218;
  int v219;
  int v220;
  char *v221;
  _BOOL4 v222;
  NSObject *v223;
  int v224;
  int v225;
  NSObject *v226;
  int v227;
  int v228;
  NSObject *v229;
  _BOOL4 v230;
  int v231;
  int v232;
  int v233;
  _QWORD v234[2];
  uint64_t (*v235)(uint64_t, uint64_t);
  void *v236;
  uint64_t *v237;
  uint64_t *v238;
  uint64_t v239;
  char *v240;
  nw_frame_array_s *v241;
  unsigned int v242;
  int v243;
  char v244;
  os_log_type_t v245;
  _QWORD v246[2];
  uint64_t (*v247)(_QWORD *);
  void *v248;
  os_log_type_t *v249;
  uint64_t *v250;
  _QWORD *v251;
  os_log_type_t *v252;
  uint64_t v253;
  nw_protocol *v254;
  uint64_t v255;
  char *v256;
  _QWORD v257[3];
  int v258;
  uint64_t v259;
  uint64_t *v260;
  uint64_t v261;
  uint64_t v262;
  os_log_type_t v263[8];
  os_log_type_t *v264;
  uint64_t v265;
  __int16 v266;
  _QWORD v267[2];
  BOOL (*v268)(_QWORD *, uint64_t);
  void *v269;
  uint64_t *v270;
  _QWORD *v271;
  _QWORD *v272;
  uint64_t *v273;
  uint64_t *v274;
  uint64_t *v275;
  uint64_t *v276;
  char *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t *v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t *v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t *v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t *v292;
  uint64_t v293;
  __int16 v294;
  _QWORD v295[3];
  __int16 v296;
  _QWORD v297[4];
  uint64_t v298;
  uint64_t *v299;
  uint64_t v300;
  char v301;
  os_log_type_t type[8];
  os_log_type_t *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t *v307;
  uint64_t v308;
  int v309;
  uint64_t v310;
  uint64_t *v311;
  uint64_t v312;
  int v313;
  uint8_t buf[4];
  const char *v315;
  __int16 v316;
  const char *v317;
  __int16 v318;
  uint64_t v319;
  __int16 v320;
  _BYTE v321[36];
  __int16 v322;
  int v323;
  _QWORD v324[5];

  v324[2] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v315 = "nw_protocol_http2_get_input_frames";
    v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v310) = 16;
    LOBYTE(v306) = 0;
    if (__nwlog_fault(v27, &v310, &v306))
    {
      if (v310 == 17)
      {
        v28 = __nwlog_obj();
        v29 = v310;
        if (os_log_type_enabled(v28, (os_log_type_t)v310))
        {
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v30 = "%{public}s called with null protocol";
LABEL_217:
          _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0xCu);
        }
      }
      else if ((_BYTE)v306)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v28 = __nwlog_obj();
        v29 = v310;
        v206 = os_log_type_enabled(v28, (os_log_type_t)v310);
        if (backtrace_string)
        {
          if (!v206)
            goto LABEL_38;
          *(_DWORD *)buf = 136446466;
          v315 = "nw_protocol_http2_get_input_frames";
          v316 = 2082;
          v317 = backtrace_string;
          v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
          goto LABEL_37;
        }
        if (v206)
        {
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v30 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_217;
        }
      }
      else
      {
        v28 = __nwlog_obj();
        v29 = v310;
        if (os_log_type_enabled(v28, (os_log_type_t)v310))
        {
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v30 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_217;
        }
      }
    }
LABEL_218:
    if (v27)
      free(v27);
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v315 = "nw_protocol_http2_get_input_frames";
    v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v310) = 16;
    LOBYTE(v306) = 0;
    if (__nwlog_fault(v27, &v310, &v306))
    {
      if (v310 == 17)
      {
        v28 = __nwlog_obj();
        v29 = v310;
        if (os_log_type_enabled(v28, (os_log_type_t)v310))
        {
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v30 = "%{public}s called with null http2";
          goto LABEL_217;
        }
      }
      else if ((_BYTE)v306)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v28 = __nwlog_obj();
        v29 = v310;
        v207 = os_log_type_enabled(v28, (os_log_type_t)v310);
        if (backtrace_string)
        {
          if (!v207)
            goto LABEL_38;
          *(_DWORD *)buf = 136446466;
          v315 = "nw_protocol_http2_get_input_frames";
          v316 = 2082;
          v317 = backtrace_string;
          v33 = "%{public}s called with null http2, dumping backtrace:%{public}s";
          goto LABEL_37;
        }
        if (v207)
        {
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v30 = "%{public}s called with null http2, no backtrace";
          goto LABEL_217;
        }
      }
      else
      {
        v28 = __nwlog_obj();
        v29 = v310;
        if (os_log_type_enabled(v28, (os_log_type_t)v310))
        {
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v30 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_217;
        }
      }
    }
    goto LABEL_218;
  }
  if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v202 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v203 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136447746;
      v315 = "nw_protocol_http2_get_input_frames";
      v316 = 2082;
      v317 = handle + 378;
      v318 = 2080;
      v319 = (uint64_t)" ";
      v320 = 1024;
      *(_DWORD *)v321 = v203;
      *(_WORD *)&v321[4] = 1024;
      *(_DWORD *)&v321[6] = a3;
      *(_WORD *)&v321[10] = 1024;
      *(_DWORD *)&v321[12] = a4;
      *(_WORD *)&v321[16] = 1024;
      *(_DWORD *)&v321[18] = a5;
      _os_log_impl(&dword_182FBE000, v202, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called min_bytes: %u, max_bytes: %u, max_frame_count: %u", buf, 0x38u);
    }
  }
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v315 = "nw_protocol_http2_get_input_frames";
    v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v310) = 16;
    LOBYTE(v306) = 0;
    if (!__nwlog_fault(v27, &v310, &v306))
      goto LABEL_218;
    if (v310 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = gLogObj;
      v29 = v310;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v310))
        goto LABEL_218;
      *(_DWORD *)buf = 136446210;
      v315 = "nw_protocol_http2_get_input_frames";
      v30 = "%{public}s called with null input_protocol";
      goto LABEL_217;
    }
    if (!(_BYTE)v306)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = gLogObj;
      v29 = v310;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v310))
        goto LABEL_218;
      *(_DWORD *)buf = 136446210;
      v315 = "nw_protocol_http2_get_input_frames";
      v30 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_217;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = gLogObj;
    v29 = v310;
    v32 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v310);
    if (!backtrace_string)
    {
      if (!v32)
        goto LABEL_218;
      *(_DWORD *)buf = 136446210;
      v315 = "nw_protocol_http2_get_input_frames";
      v30 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_217;
    }
    if (!v32)
    {
LABEL_38:
      free(backtrace_string);
      goto LABEL_218;
    }
    *(_DWORD *)buf = 136446466;
    v315 = "nw_protocol_http2_get_input_frames";
    v316 = 2082;
    v317 = backtrace_string;
    v33 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_37:
    _os_log_impl(&dword_182FBE000, v28, v29, v33, buf, 0x16u);
    goto LABEL_38;
  }
  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    v14 = output_handler_context[4];
    if (v14)
    {
      v310 = 0;
      v311 = &v310;
      v313 = 0;
      v312 = 0x2000000000;
      v306 = 0;
      v307 = &v306;
      v309 = 0;
      v308 = 0x2000000000;
      if (nw_array_is_empty(*(_QWORD *)(v14 + 160)))
      {
        v15 = MEMORY[0x1E0C809B0];
        v233 = a4;
        if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x20000) == 0)
        {
          v234[0] = MEMORY[0x1E0C809B0];
          v234[1] = 0x40000000;
          v235 = ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_66;
          v236 = &unk_1E14ABB70;
          v237 = &v310;
          v238 = &v306;
          v242 = a5;
          v243 = a4;
          v239 = v14;
          v240 = handle;
          v241 = a6;
          v16 = *(_QWORD *)v14;
          do
          {
            if (!v16)
              break;
            v17 = *(_QWORD *)(v16 + 32);
            v18 = ((uint64_t (*)(_QWORD *))v235)(v234);
            v16 = v17;
          }
          while ((v18 & 1) != 0);
          if (*((_DWORD *)v307 + 6) < a3)
          {
            v19 = *(unsigned __int16 *)(v14 + 188);
            v20 = v19 | (*(unsigned __int8 *)(v14 + 190) << 16);
            if ((v19 & 0x1000) == 0)
            {
              if (*((_DWORD *)v311 + 6))
              {
                nw_frame_array_prepend_array((_QWORD *)v14, a6, 1);
                a6->tqh_first = 0;
                a6->tqh_last = &a6->tqh_first;
                v20 = *(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16);
              }
              v21 = 0;
              if ((v20 & 0x80000) == 0 && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v22 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v24 = *(_DWORD *)(v14 + 176);
                  v23 = *(_DWORD *)(v14 + 180);
                  *(_DWORD *)buf = 136447490;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = (const char *)(v14 + 191);
                  v318 = 2080;
                  v319 = (uint64_t)" ";
                  v320 = 1024;
                  *(_DWORD *)v321 = v23;
                  *(_WORD *)&v321[4] = 1024;
                  *(_DWORD *)&v321[6] = v24;
                  *(_WORD *)&v321[10] = 1024;
                  *(_DWORD *)&v321[12] = a3;
                  _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> failed to find enough (%u) bytes to return, returning 0 frames", buf, 0x32u);
                }
                v21 = 0;
              }
              goto LABEL_287;
            }
          }
LABEL_199:
          if (*((_DWORD *)v311 + 6))
            goto LABEL_284;
          v173 = (*(_WORD *)(v14 + 188) & 0x800) != 0 && v233 == 0;
          v174 = !v173 && (*(_WORD *)(v14 + 188) & 0x1000) == 0;
          if (v174 || !*(_QWORD *)(v14 + 112) || (*(_WORD *)(v14 + 188) & 0x8000) != 0)
            goto LABEL_284;
          if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v223 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v225 = *(_DWORD *)(v14 + 176);
              v224 = *(_DWORD *)(v14 + 180);
              *(_DWORD *)buf = 136447234;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = (const char *)(v14 + 191);
              v318 = 2080;
              v319 = (uint64_t)" ";
              v320 = 1024;
              *(_DWORD *)v321 = v224;
              *(_WORD *)&v321[4] = 1024;
              *(_DWORD *)&v321[6] = v225;
              _os_log_impl(&dword_182FBE000, v223, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> no frames to return, adding metadata only frame", buf, 0x2Cu);
            }
          }
          *(_WORD *)(v14 + 188) |= 0x8000u;
          input_frame = http2_create_input_frame((uint64_t)handle, v14, 0);
          if (!input_frame)
          {
LABEL_284:
            if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v216 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v218 = *(_DWORD *)(v14 + 176);
                v217 = *(_DWORD *)(v14 + 180);
                v219 = *((_DWORD *)v311 + 6);
                v220 = *((_DWORD *)v307 + 6);
                *(_DWORD *)buf = 136447746;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = (const char *)(v14 + 191);
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v217;
                *(_WORD *)&v321[4] = 1024;
                *(_DWORD *)&v321[6] = v218;
                *(_WORD *)&v321[10] = 1024;
                *(_DWORD *)&v321[12] = v219;
                *(_WORD *)&v321[16] = 1024;
                *(_DWORD *)&v321[18] = v220;
                _os_log_impl(&dword_182FBE000, v216, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> returning %u frames (%u total bytes)", buf, 0x38u);
              }
            }
            v21 = *((unsigned int *)v311 + 6);
            goto LABEL_287;
          }
          v176 = input_frame;
          v177 = *(NSObject **)(v14 + 112);
          v178 = *(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16);
          if (v177)
          {
            v179 = (*(_WORD *)(v14 + 188) & 0x1000) != 0 && *(_QWORD *)v14 == 0;
            if ((v178 & 0x80000) == 0 && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v229 = gconnectionLogObj;
              v230 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
              v177 = *(NSObject **)(v14 + 112);
              if (v230)
              {
                v232 = *(_DWORD *)(v14 + 176);
                v231 = *(_DWORD *)(v14 + 180);
                *(_DWORD *)buf = 136448258;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = (const char *)(v14 + 191);
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v231;
                *(_WORD *)&v321[4] = 1024;
                *(_DWORD *)&v321[6] = v232;
                *(_WORD *)&v321[10] = 2048;
                *(_QWORD *)&v321[12] = v177;
                *(_WORD *)&v321[20] = 1024;
                *(_DWORD *)&v321[22] = v232;
                *(_WORD *)&v321[26] = 2048;
                *(_QWORD *)&v321[28] = v176;
                v322 = 1024;
                v323 = v179;
                _os_log_impl(&dword_182FBE000, v229, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting metadata %p from stream %d on frame %p, complete %u", buf, 0x4Cu);
                v177 = *(NSObject **)(v14 + 112);
              }
            }
            nw_frame_set_metadata(v176, v177, 1, v179);
            if (v179)
              v188 = 0x80;
            else
              v188 = 0;
            *(_BYTE *)(v176 + 186) = v188 & 0x80 | *(_BYTE *)(v176 + 186) & 0x7F;
          }
          else if ((v178 & 0x80000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v185 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v187 = *(_DWORD *)(v14 + 176);
              v186 = *(_DWORD *)(v14 + 180);
              *(_DWORD *)buf = 136447746;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = (const char *)(v14 + 191);
              v318 = 2080;
              v319 = (uint64_t)" ";
              v320 = 1024;
              *(_DWORD *)v321 = v186;
              *(_WORD *)&v321[4] = 1024;
              *(_DWORD *)&v321[6] = v187;
              *(_WORD *)&v321[10] = 1024;
              *(_DWORD *)&v321[12] = v187;
              *(_WORD *)&v321[16] = 2048;
              *(_QWORD *)&v321[18] = v176;
              _os_log_impl(&dword_182FBE000, v185, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream %d has no metadata to set on frame %p", buf, 0x3Cu);
            }
          }
          *(_QWORD *)(v176 + 32) = 0;
          tqh_last = a6->tqh_last;
          *(_QWORD *)(v176 + 40) = tqh_last;
          *tqh_last = (nw_frame *)v176;
          a6->tqh_last = (nw_frame **)(v176 + 32);
          v190 = *((unsigned int *)v311 + 6) + 1;
          v191 = v190 << 31 >> 31;
          *((_DWORD *)v311 + 6) = v190;
          if (v191 == v190 && (v191 & 0x8000000000000000) == 0)
          {
LABEL_282:
            if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v226 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v228 = *(_DWORD *)(v14 + 176);
                v227 = *(_DWORD *)(v14 + 180);
                *(_DWORD *)buf = 136447234;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = (const char *)(v14 + 191);
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v227;
                *(_WORD *)&v321[4] = 1024;
                *(_DWORD *)&v321[6] = v228;
                _os_log_impl(&dword_182FBE000, v226, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> delivering empty incoming frame", buf, 0x2Cu);
              }
            }
            goto LABEL_284;
          }
          __nwlog_obj();
          v192 = *((unsigned int *)v311 + 6);
          *(_DWORD *)buf = 136446978;
          v315 = "nw_protocol_http2_get_input_frames";
          v316 = 2082;
          v317 = "return_frame_count";
          v318 = 2048;
          v319 = 1;
          v320 = 2048;
          *(_QWORD *)v321 = v192;
          v193 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v298) = 0;
          if (__nwlog_fault(v193, type, &v298))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v194 = __nwlog_obj();
              v195 = type[0];
              if (os_log_type_enabled(v194, type[0]))
              {
                v196 = *((unsigned int *)v311 + 6);
                *(_DWORD *)buf = 136446978;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = "return_frame_count";
                v318 = 2048;
                v319 = 1;
                v320 = 2048;
                *(_QWORD *)v321 = v196;
                v197 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_278:
                _os_log_impl(&dword_182FBE000, v194, v195, v197, buf, 0x2Au);
              }
            }
            else if ((_BYTE)v298)
            {
              v198 = (char *)__nw_create_backtrace_string();
              v194 = __nwlog_obj();
              v195 = type[0];
              v199 = os_log_type_enabled(v194, type[0]);
              if (v198)
              {
                if (v199)
                {
                  v200 = *((unsigned int *)v311 + 6);
                  *(_DWORD *)buf = 136447234;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = "return_frame_count";
                  v318 = 2048;
                  v319 = 1;
                  v320 = 2048;
                  *(_QWORD *)v321 = v200;
                  *(_WORD *)&v321[8] = 2082;
                  *(_QWORD *)&v321[10] = v198;
                  _os_log_impl(&dword_182FBE000, v194, v195, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v198);
                goto LABEL_279;
              }
              if (v199)
              {
                v204 = *((unsigned int *)v311 + 6);
                *(_DWORD *)buf = 136446978;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = "return_frame_count";
                v318 = 2048;
                v319 = 1;
                v320 = 2048;
                *(_QWORD *)v321 = v204;
                v197 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_278;
              }
            }
            else
            {
              v194 = __nwlog_obj();
              v195 = type[0];
              if (os_log_type_enabled(v194, type[0]))
              {
                v201 = *((unsigned int *)v311 + 6);
                *(_DWORD *)buf = 136446978;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = "return_frame_count";
                v318 = 2048;
                v319 = 1;
                v320 = 2048;
                *(_QWORD *)v321 = v201;
                v197 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_278;
              }
            }
          }
LABEL_279:
          if (v193)
            free(v193);
          *((_DWORD *)v311 + 6) = -1;
          goto LABEL_282;
        }
        while (1)
        {
          *(_QWORD *)type = 0;
          v303 = type;
          v304 = 0x2000000000;
          v305 = 0;
          v298 = 0;
          v299 = &v298;
          v300 = 0x2000000000;
          v301 = 0;
          v324[0] = 0;
          v324[1] = 0;
          v297[0] = 0;
          v297[1] = v297;
          v297[2] = 0x2000000000;
          v297[3] = v324;
          v295[0] = 0;
          v295[1] = v295;
          v295[2] = 0x2000000000;
          v296 = 0;
          v291 = 0;
          v292 = &v291;
          v293 = 0x2000000000;
          v294 = 0;
          v287 = 0;
          v288 = &v287;
          v289 = 0x2000000000;
          v290 = -1;
          v283 = 0;
          v284 = &v283;
          v285 = 0x2000000000;
          v286 = 0;
          v279 = 0;
          v280 = &v279;
          v281 = 0x2000000000;
          v282 = 0;
          v267[0] = v15;
          v267[1] = 0x40000000;
          v268 = ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
          v269 = &unk_1E14ABB20;
          v270 = &v298;
          v271 = v295;
          v272 = v297;
          v273 = &v287;
          v274 = &v291;
          v275 = &v283;
          v276 = &v279;
          v277 = handle;
          v278 = v14;
          v46 = *(_QWORD *)v14;
          do
          {
            if (!v46)
              break;
            v47 = *(_QWORD *)(v46 + 32);
            v48 = v268(v267, v46);
            v46 = v47;
          }
          while (v48);
          if (!*((_BYTE *)v299 + 24))
            goto LABEL_112;
          v49 = 0;
          v50 = *((_DWORD *)v284 + 6) + *((unsigned __int16 *)v292 + 12);
          v51 = *(_QWORD *)v14;
          while (v51)
          {
            v55 = *(_DWORD *)(v51 + 52);
            if (v55)
              v55 -= *(_DWORD *)(v51 + 56) + *(_DWORD *)(v51 + 60);
            v51 = *(_QWORD *)(v51 + 32);
            v52 = __CFADD__(v49, v55);
            v53 = v49 + v55;
            v49 += v55;
            if (v52)
              v54 = -1;
            else
              v54 = v53;
            if (v54 >= v50)
              goto LABEL_63;
          }
          if (v49 < v50)
            goto LABEL_112;
LABEL_63:
          *(_QWORD *)v263 = 0;
          v264 = v263;
          v265 = 0x2000000000;
          v266 = 0;
          v266 = *((_WORD *)v292 + 12);
          v259 = 0;
          v260 = &v259;
          v261 = 0x2000000000;
          v262 = 0;
          v262 = v284[3];
          if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v157 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v159 = *(_DWORD *)(v14 + 176);
              v158 = *(_DWORD *)(v14 + 180);
              v160 = v288[3];
              v161 = v284[3];
              *(_DWORD *)buf = 136447746;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = (const char *)(v14 + 191);
              v318 = 2080;
              v319 = (uint64_t)" ";
              v320 = 1024;
              *(_DWORD *)v321 = v158;
              *(_WORD *)&v321[4] = 1024;
              *(_DWORD *)&v321[6] = v159;
              *(_WORD *)&v321[10] = 2048;
              *(_QWORD *)&v321[12] = v160;
              *(_WORD *)&v321[20] = 2048;
              *(_QWORD *)&v321[22] = v161;
              _os_log_impl(&dword_182FBE000, v157, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule type 0x%llx length %llu", buf, 0x40u);
            }
          }
          v56 = 0;
          v257[0] = 0;
          v257[1] = v257;
          v258 = 0;
          v257[2] = 0x2000000000;
          if (!v288[3])
          {
            v57 = (*(unsigned __int8 *)(v14 + 190) >> 3) & 1;
            if (!gLogDatapath)
              LOBYTE(v57) = 1;
            if (v280[3])
            {
              if ((v57 & 1) != 0)
              {
                v56 = 0;
              }
              else
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v165 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v167 = *(_DWORD *)(v14 + 176);
                  v166 = *(_DWORD *)(v14 + 180);
                  v168 = v280[3];
                  *(_DWORD *)buf = 136447490;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = (const char *)(v14 + 191);
                  v318 = 2080;
                  v319 = (uint64_t)" ";
                  v320 = 1024;
                  *(_DWORD *)v321 = v166;
                  *(_WORD *)&v321[4] = 1024;
                  *(_DWORD *)&v321[6] = v167;
                  *(_WORD *)&v321[10] = 2048;
                  *(_QWORD *)&v321[12] = v168;
                  _os_log_impl(&dword_182FBE000, v165, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule datagram non-zero context ID %llu", buf, 0x36u);
                }
                v56 = 0;
                v15 = MEMORY[0x1E0C809B0];
              }
            }
            else
            {
              if ((v57 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v169 = gconnectionLogObj;
                v170 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
                v15 = MEMORY[0x1E0C809B0];
                if (v170)
                {
                  v172 = *(_DWORD *)(v14 + 176);
                  v171 = *(_DWORD *)(v14 + 180);
                  *(_DWORD *)buf = 136447234;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = (const char *)(v14 + 191);
                  v318 = 2080;
                  v319 = (uint64_t)" ";
                  v320 = 1024;
                  *(_DWORD *)v321 = v171;
                  *(_WORD *)&v321[4] = 1024;
                  *(_DWORD *)&v321[6] = v172;
                  _os_log_impl(&dword_182FBE000, v169, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule datagram with zero context ID", buf, 0x2Cu);
                }
              }
              v56 = http2_create_input_frame((uint64_t)handle, v14, *((unsigned int *)v284 + 6));
            }
          }
          v246[0] = v15;
          v246[1] = 0x40000000;
          v247 = (uint64_t (*)(_QWORD *))___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_63;
          v248 = &unk_1E14ABB48;
          v253 = v14;
          v254 = a1;
          v249 = v263;
          v250 = &v259;
          v251 = v257;
          v252 = type;
          v255 = v56;
          v256 = handle;
          v58 = *(_QWORD *)v14;
          do
          {
            if (!v58)
              break;
            v59 = *(_QWORD *)(v58 + 32);
            v60 = v247(v246);
            v58 = v59;
          }
          while ((v60 & 1) != 0);
          v61 = *((_QWORD *)v303 + 3);
          if (!v61 || !v260[3])
            goto LABEL_105;
          if (*((__int16 *)handle + 188) < 0)
            goto LABEL_104;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v62 = *((_DWORD *)handle + 92);
          v63 = v260[3];
          *(_DWORD *)buf = 136447234;
          v315 = "nw_protocol_http2_get_input_frames";
          v316 = 2082;
          v317 = handle + 378;
          v318 = 2080;
          v319 = (uint64_t)" ";
          v320 = 1024;
          *(_DWORD *)v321 = v62;
          *(_WORD *)&v321[4] = 2048;
          *(_QWORD *)&v321[6] = v63;
          v64 = (char *)_os_log_send_and_compose_impl();
          v245 = OS_LOG_TYPE_ERROR;
          v244 = 0;
          if (__nwlog_fault(v64, &v245, &v244))
          {
            if (v245 == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v65 = gconnectionLogObj;
              v66 = v245;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, v245))
              {
                v67 = *((_DWORD *)handle + 92);
                v68 = v260[3];
                *(_DWORD *)buf = 136447234;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = handle + 378;
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v67;
                *(_WORD *)&v321[4] = 2048;
                *(_QWORD *)&v321[6] = v68;
                v69 = v65;
                v70 = v66;
                v71 = "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu";
LABEL_100:
                _os_log_impl(&dword_182FBE000, v69, v70, v71, buf, 0x30u);
              }
            }
            else if (v244)
            {
              v72 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v73 = gconnectionLogObj;
              v74 = v245;
              v75 = os_log_type_enabled((os_log_t)gconnectionLogObj, v245);
              if (!v72)
              {
                if (!v75)
                  goto LABEL_101;
                v82 = *((_DWORD *)handle + 92);
                v83 = v260[3];
                *(_DWORD *)buf = 136447234;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = handle + 378;
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v82;
                *(_WORD *)&v321[4] = 2048;
                *(_QWORD *)&v321[6] = v83;
                v69 = v73;
                v70 = v74;
                v71 = "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu, no backtrace";
                goto LABEL_100;
              }
              if (v75)
              {
                v76 = *((_DWORD *)handle + 92);
                v77 = v260[3];
                *(_DWORD *)buf = 136447490;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = handle + 378;
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v76;
                *(_WORD *)&v321[4] = 2048;
                *(_QWORD *)&v321[6] = v77;
                *(_WORD *)&v321[14] = 2082;
                *(_QWORD *)&v321[16] = v72;
                _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu, dumping backtrace:%{public}s", buf, 0x3Au);
              }
              free(v72);
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v78 = gconnectionLogObj;
              v79 = v245;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, v245))
              {
                v80 = *((_DWORD *)handle + 92);
                v81 = v260[3];
                *(_DWORD *)buf = 136447234;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = handle + 378;
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v80;
                *(_WORD *)&v321[4] = 2048;
                *(_QWORD *)&v321[6] = v81;
                v69 = v78;
                v70 = v79;
                v71 = "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu, backtrace limit exceeded";
                goto LABEL_100;
              }
            }
          }
LABEL_101:
          if (v64)
            free(v64);
          v61 = *((_QWORD *)v303 + 3);
          v15 = MEMORY[0x1E0C809B0];
          if (v61)
          {
LABEL_104:
            dispatch_release(v61);
            *((_QWORD *)v303 + 3) = 0;
          }
LABEL_105:
          _Block_object_dispose(v257, 8);
          _Block_object_dispose(&v259, 8);
          _Block_object_dispose(v263, 8);
          if (v56)
          {
            nw_frame_set_metadata(v56, 0, 1, 1);
            *(_QWORD *)(v56 + 32) = 0;
            v84 = a6->tqh_last;
            *(_QWORD *)(v56 + 40) = v84;
            *v84 = (nw_frame *)v56;
            a6->tqh_last = (nw_frame **)(v56 + 32);
            v85 = *((unsigned int *)v311 + 6) + 1;
            v86 = v85 << 31 >> 31;
            *((_DWORD *)v311 + 6) = v85;
            if (v86 != v85 || v86 < 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v87 = *((unsigned int *)v311 + 6);
              *(_DWORD *)buf = 136446978;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = "return_frame_count";
              v318 = 2048;
              v319 = 1;
              v320 = 2048;
              *(_QWORD *)v321 = v87;
              v88 = (char *)_os_log_send_and_compose_impl();
              v263[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v259) = 0;
              if (!__nwlog_fault(v88, v263, &v259))
                goto LABEL_151;
              if (v263[0] != OS_LOG_TYPE_FAULT)
              {
                if ((_BYTE)v259)
                {
                  v113 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v114 = gLogObj;
                  v115 = v263[0];
                  v116 = os_log_type_enabled((os_log_t)gLogObj, v263[0]);
                  if (v113)
                  {
                    if (v116)
                    {
                      v117 = *((unsigned int *)v311 + 6);
                      *(_DWORD *)buf = 136447234;
                      v315 = "nw_protocol_http2_get_input_frames";
                      v316 = 2082;
                      v317 = "return_frame_count";
                      v318 = 2048;
                      v319 = 1;
                      v320 = 2048;
                      *(_QWORD *)v321 = v117;
                      *(_WORD *)&v321[8] = 2082;
                      *(_QWORD *)&v321[10] = v113;
                      _os_log_impl(&dword_182FBE000, v114, v115, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                    }
                    free(v113);
                    goto LABEL_151;
                  }
                  if (!v116)
                    goto LABEL_151;
                  v130 = *((unsigned int *)v311 + 6);
                  *(_DWORD *)buf = 136446978;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = "return_frame_count";
                  v318 = 2048;
                  v319 = 1;
                  v320 = 2048;
                  *(_QWORD *)v321 = v130;
                  v92 = v114;
                  v93 = v115;
                  v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                }
                else
                {
                  v121 = __nwlog_obj();
                  v122 = v263[0];
                  if (!os_log_type_enabled(v121, v263[0]))
                    goto LABEL_151;
                  v123 = *((unsigned int *)v311 + 6);
                  *(_DWORD *)buf = 136446978;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = "return_frame_count";
                  v318 = 2048;
                  v319 = 1;
                  v320 = 2048;
                  *(_QWORD *)v321 = v123;
                  v92 = v121;
                  v93 = v122;
                  v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                }
LABEL_150:
                _os_log_impl(&dword_182FBE000, v92, v93, v94, buf, 0x2Au);
                goto LABEL_151;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v89 = gLogObj;
              v90 = v263[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v263[0]))
              {
                v91 = *((unsigned int *)v311 + 6);
                *(_DWORD *)buf = 136446978;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = "return_frame_count";
                v318 = 2048;
                v319 = 1;
                v320 = 2048;
                *(_QWORD *)v321 = v91;
                v92 = v89;
                v93 = v90;
                v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_150;
              }
LABEL_151:
              if (v88)
                free(v88);
              *((_DWORD *)v311 + 6) = -1;
              v15 = MEMORY[0x1E0C809B0];
            }
            v131 = *((unsigned int *)v307 + 6);
            v132 = v284[3];
            v52 = __CFADD__(v131, v132);
            v133 = v131 + v132;
            *((_DWORD *)v307 + 6) = v133;
            if (v52 || HIDWORD(v133))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v134 = v284[3];
              v135 = *((unsigned int *)v307 + 6);
              *(_DWORD *)buf = 136446978;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = "total_bytes";
              v318 = 2048;
              v319 = v134;
              v320 = 2048;
              *(_QWORD *)v321 = v135;
              v136 = (char *)_os_log_send_and_compose_impl();
              v263[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v259) = 0;
              if (!__nwlog_fault(v136, v263, &v259))
                goto LABEL_170;
              if (v263[0] != OS_LOG_TYPE_FAULT)
              {
                if ((_BYTE)v259)
                {
                  v144 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v145 = gLogObj;
                  v146 = v263[0];
                  v147 = os_log_type_enabled((os_log_t)gLogObj, v263[0]);
                  if (v144)
                  {
                    if (v147)
                    {
                      v148 = v284[3];
                      v149 = *((unsigned int *)v307 + 6);
                      *(_DWORD *)buf = 136447234;
                      v315 = "nw_protocol_http2_get_input_frames";
                      v316 = 2082;
                      v317 = "total_bytes";
                      v318 = 2048;
                      v319 = v148;
                      v320 = 2048;
                      *(_QWORD *)v321 = v149;
                      *(_WORD *)&v321[8] = 2082;
                      *(_QWORD *)&v321[10] = v144;
                      _os_log_impl(&dword_182FBE000, v145, v146, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                    }
                    free(v144);
                    goto LABEL_170;
                  }
                  if (!v147)
                    goto LABEL_170;
                  v154 = v284[3];
                  v155 = *((unsigned int *)v307 + 6);
                  *(_DWORD *)buf = 136446978;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = "total_bytes";
                  v318 = 2048;
                  v319 = v154;
                  v320 = 2048;
                  *(_QWORD *)v321 = v155;
                  v141 = v145;
                  v142 = v146;
                  v143 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                }
                else
                {
                  v150 = __nwlog_obj();
                  v151 = v263[0];
                  if (!os_log_type_enabled(v150, v263[0]))
                    goto LABEL_170;
                  v152 = v284[3];
                  v153 = *((unsigned int *)v307 + 6);
                  *(_DWORD *)buf = 136446978;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = "total_bytes";
                  v318 = 2048;
                  v319 = v152;
                  v320 = 2048;
                  *(_QWORD *)v321 = v153;
                  v141 = v150;
                  v142 = v151;
                  v143 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                }
LABEL_169:
                _os_log_impl(&dword_182FBE000, v141, v142, v143, buf, 0x2Au);
                goto LABEL_170;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v137 = gLogObj;
              v138 = v263[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v263[0]))
              {
                v139 = v284[3];
                v140 = *((unsigned int *)v307 + 6);
                *(_DWORD *)buf = 136446978;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = "total_bytes";
                v318 = 2048;
                v319 = v139;
                v320 = 2048;
                *(_QWORD *)v321 = v140;
                v141 = v137;
                v142 = v138;
                v143 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_169;
              }
LABEL_170:
              if (v136)
                free(v136);
              *((_DWORD *)v307 + 6) = -1;
              v15 = MEMORY[0x1E0C809B0];
            }
            v125 = 0;
            if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v162 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v164 = *(_DWORD *)(v14 + 176);
                v163 = *(_DWORD *)(v14 + 180);
                *(_DWORD *)buf = 136447234;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = (const char *)(v14 + 191);
                v318 = 2080;
                v319 = (uint64_t)" ";
                v320 = 1024;
                *(_DWORD *)v321 = v163;
                *(_WORD *)&v321[4] = 1024;
                *(_DWORD *)&v321[6] = v164;
                _os_log_impl(&dword_182FBE000, v162, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving datagram capsule", buf, 0x2Cu);
              }
              v125 = 0;
            }
            goto LABEL_175;
          }
LABEL_112:
          if (!*((_QWORD *)v303 + 3))
            goto LABEL_147;
          v95 = http2_create_input_frame((uint64_t)handle, v14, 0);
          metadata_for_capsule = nw_http_create_metadata_for_capsule(v288[3], *((void **)v303 + 3));
          nw_frame_set_metadata(v95, metadata_for_capsule, 1, 1);
          if (metadata_for_capsule)
            os_release(metadata_for_capsule);
          *(_QWORD *)(v95 + 32) = 0;
          v97 = a6->tqh_last;
          *(_QWORD *)(v95 + 40) = v97;
          *v97 = (nw_frame *)v95;
          a6->tqh_last = (nw_frame **)(v95 + 32);
          v98 = *((unsigned int *)v311 + 6) + 1;
          v99 = v98 << 31 >> 31;
          *((_DWORD *)v311 + 6) = v98;
          if (v99 != v98 || v99 < 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v100 = *((unsigned int *)v311 + 6);
            *(_DWORD *)buf = 136446978;
            v315 = "nw_protocol_http2_get_input_frames";
            v316 = 2082;
            v317 = "return_frame_count";
            v318 = 2048;
            v319 = 1;
            v320 = 2048;
            *(_QWORD *)v321 = v100;
            v101 = (char *)_os_log_send_and_compose_impl();
            v263[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v259) = 0;
            if (!__nwlog_fault(v101, v263, &v259))
              goto LABEL_138;
            if (v263[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v102 = gLogObj;
              v103 = v263[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v263[0]))
              {
                v104 = *((unsigned int *)v311 + 6);
                *(_DWORD *)buf = 136446978;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = "return_frame_count";
                v318 = 2048;
                v319 = 1;
                v320 = 2048;
                *(_QWORD *)v321 = v104;
                v105 = v102;
                v106 = v103;
                v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_137;
              }
              goto LABEL_138;
            }
            if ((_BYTE)v259)
            {
              v108 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v109 = gLogObj;
              v110 = v263[0];
              v111 = os_log_type_enabled((os_log_t)gLogObj, v263[0]);
              if (v108)
              {
                if (v111)
                {
                  v112 = *((unsigned int *)v311 + 6);
                  *(_DWORD *)buf = 136447234;
                  v315 = "nw_protocol_http2_get_input_frames";
                  v316 = 2082;
                  v317 = "return_frame_count";
                  v318 = 2048;
                  v319 = 1;
                  v320 = 2048;
                  *(_QWORD *)v321 = v112;
                  *(_WORD *)&v321[8] = 2082;
                  *(_QWORD *)&v321[10] = v108;
                  _os_log_impl(&dword_182FBE000, v109, v110, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v108);
                goto LABEL_138;
              }
              if (!v111)
              {
LABEL_138:
                if (v101)
                  free(v101);
                *((_DWORD *)v311 + 6) = -1;
                v15 = MEMORY[0x1E0C809B0];
                goto LABEL_141;
              }
              v124 = *((unsigned int *)v311 + 6);
              *(_DWORD *)buf = 136446978;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = "return_frame_count";
              v318 = 2048;
              v319 = 1;
              v320 = 2048;
              *(_QWORD *)v321 = v124;
              v105 = v109;
              v106 = v110;
              v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v118 = gLogObj;
              v119 = v263[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, v263[0]))
                goto LABEL_138;
              v120 = *((unsigned int *)v311 + 6);
              *(_DWORD *)buf = 136446978;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = "return_frame_count";
              v318 = 2048;
              v319 = 1;
              v320 = 2048;
              *(_QWORD *)v321 = v120;
              v105 = v118;
              v106 = v119;
              v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            }
LABEL_137:
            _os_log_impl(&dword_182FBE000, v105, v106, v107, buf, 0x2Au);
            goto LABEL_138;
          }
LABEL_141:
          v125 = 1;
          if (((*(unsigned __int16 *)(v14 + 188) | (*(unsigned __int8 *)(v14 + 190) << 16)) & 0x80000) != 0
            || !gLogDatapath)
          {
            goto LABEL_175;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v126 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v128 = *(_DWORD *)(v14 + 176);
            v127 = *(_DWORD *)(v14 + 180);
            v129 = v288[3];
            *(_DWORD *)buf = 136447490;
            v315 = "nw_protocol_http2_get_input_frames";
            v316 = 2082;
            v317 = (const char *)(v14 + 191);
            v318 = 2080;
            v319 = (uint64_t)" ";
            v320 = 1024;
            *(_DWORD *)v321 = v127;
            *(_WORD *)&v321[4] = 1024;
            *(_DWORD *)&v321[6] = v128;
            *(_WORD *)&v321[10] = 2048;
            *(_QWORD *)&v321[12] = v129;
            _os_log_impl(&dword_182FBE000, v126, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule type 0x%llx", buf, 0x36u);
          }
LABEL_147:
          v125 = 1;
LABEL_175:
          v156 = *((_QWORD *)v303 + 3);
          if (v156)
          {
            dispatch_release(v156);
            *((_QWORD *)v303 + 3) = 0;
          }
          _Block_object_dispose(&v279, 8);
          _Block_object_dispose(&v283, 8);
          _Block_object_dispose(&v287, 8);
          _Block_object_dispose(&v291, 8);
          _Block_object_dispose(v295, 8);
          _Block_object_dispose(v297, 8);
          _Block_object_dispose(&v298, 8);
          _Block_object_dispose(type, 8);
          if ((v125 & 1) != 0 || *((_DWORD *)v311 + 6) >= a5)
            goto LABEL_199;
        }
      }
      if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v212 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v213 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v315 = "nw_protocol_http2_get_input_frames";
          v316 = 2082;
          v317 = handle + 378;
          v318 = 2080;
          v319 = (uint64_t)" ";
          v320 = 1024;
          *(_DWORD *)v321 = v213;
          _os_log_impl(&dword_182FBE000, v212, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> adding informational response", buf, 0x26u);
        }
      }
      v34 = nw_array_remove_object_at_index(*(_QWORD *)(v14 + 160), 0);
      v35 = http2_create_input_frame((uint64_t)handle, v14, 0);
      if (v35)
      {
        v36 = v35;
        nw_frame_set_metadata(v35, v34, 1, 1);
        *(_QWORD *)(v36 + 32) = 0;
        v37 = a6->tqh_last;
        *(_QWORD *)(v36 + 40) = v37;
        *v37 = (nw_frame *)v36;
        a6->tqh_last = (nw_frame **)(v36 + 32);
        v38 = *((unsigned int *)v311 + 6) + 1;
        v39 = v38 << 31 >> 31;
        *((_DWORD *)v311 + 6) = v38;
        if (v39 == v38 && (v39 & 0x8000000000000000) == 0)
          goto LABEL_234;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = *((unsigned int *)v311 + 6);
        *(_DWORD *)buf = 136446978;
        v315 = "nw_protocol_http2_get_input_frames";
        v316 = 2082;
        v317 = "return_frame_count";
        v318 = 2048;
        v319 = 1;
        v320 = 2048;
        *(_QWORD *)v321 = v40;
        v41 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v298) = 0;
        if (__nwlog_fault(v41, type, &v298))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v42 = gLogObj;
            v43 = type[0];
            if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
            {
              v44 = *((unsigned int *)v311 + 6);
              *(_DWORD *)buf = 136446978;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = "return_frame_count";
              v318 = 2048;
              v319 = 1;
              v320 = 2048;
              *(_QWORD *)v321 = v44;
              v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_230:
              _os_log_impl(&dword_182FBE000, v42, v43, v45, buf, 0x2Au);
            }
          }
          else if ((_BYTE)v298)
          {
            v180 = (char *)__nw_create_backtrace_string();
            v42 = __nwlog_obj();
            v43 = type[0];
            v181 = os_log_type_enabled(v42, type[0]);
            if (v180)
            {
              if (v181)
              {
                v182 = *((unsigned int *)v311 + 6);
                *(_DWORD *)buf = 136447234;
                v315 = "nw_protocol_http2_get_input_frames";
                v316 = 2082;
                v317 = "return_frame_count";
                v318 = 2048;
                v319 = 1;
                v320 = 2048;
                *(_QWORD *)v321 = v182;
                *(_WORD *)&v321[8] = 2082;
                *(_QWORD *)&v321[10] = v180;
                _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v180);
              goto LABEL_231;
            }
            if (v181)
            {
              v184 = *((unsigned int *)v311 + 6);
              *(_DWORD *)buf = 136446978;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = "return_frame_count";
              v318 = 2048;
              v319 = 1;
              v320 = 2048;
              *(_QWORD *)v321 = v184;
              v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_230;
            }
          }
          else
          {
            v42 = __nwlog_obj();
            v43 = type[0];
            if (os_log_type_enabled(v42, type[0]))
            {
              v183 = *((unsigned int *)v311 + 6);
              *(_DWORD *)buf = 136446978;
              v315 = "nw_protocol_http2_get_input_frames";
              v316 = 2082;
              v317 = "return_frame_count";
              v318 = 2048;
              v319 = 1;
              v320 = 2048;
              *(_QWORD *)v321 = v183;
              v45 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_230;
            }
          }
        }
LABEL_231:
        if (v41)
          free(v41);
        *((_DWORD *)v311 + 6) = -1;
LABEL_234:
        if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v214 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v215 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            v315 = "nw_protocol_http2_get_input_frames";
            v316 = 2082;
            v317 = handle + 378;
            v318 = 2080;
            v319 = (uint64_t)" ";
            v320 = 1024;
            *(_DWORD *)v321 = v215;
            _os_log_impl(&dword_182FBE000, v214, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> delivering empty incoming frame", buf, 0x26u);
          }
        }
        v21 = *((unsigned int *)v311 + 6);
        if (!v34)
          goto LABEL_287;
        goto LABEL_237;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v315 = "nw_protocol_http2_get_input_frames";
      v208 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v298) = 0;
      if (__nwlog_fault(v208, type, &v298))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v209 = __nwlog_obj();
          v210 = type[0];
          if (!os_log_type_enabled(v209, type[0]))
            goto LABEL_331;
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v211 = "%{public}s called with null empty_frame";
LABEL_330:
          _os_log_impl(&dword_182FBE000, v209, v210, v211, buf, 0xCu);
          goto LABEL_331;
        }
        if (!(_BYTE)v298)
        {
          v209 = __nwlog_obj();
          v210 = type[0];
          if (!os_log_type_enabled(v209, type[0]))
            goto LABEL_331;
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v211 = "%{public}s called with null empty_frame, backtrace limit exceeded";
          goto LABEL_330;
        }
        v221 = (char *)__nw_create_backtrace_string();
        v209 = __nwlog_obj();
        v210 = type[0];
        v222 = os_log_type_enabled(v209, type[0]);
        if (!v221)
        {
          if (!v222)
            goto LABEL_331;
          *(_DWORD *)buf = 136446210;
          v315 = "nw_protocol_http2_get_input_frames";
          v211 = "%{public}s called with null empty_frame, no backtrace";
          goto LABEL_330;
        }
        if (v222)
        {
          *(_DWORD *)buf = 136446466;
          v315 = "nw_protocol_http2_get_input_frames";
          v316 = 2082;
          v317 = v221;
          _os_log_impl(&dword_182FBE000, v209, v210, "%{public}s called with null empty_frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v221);
      }
LABEL_331:
      if (v208)
        free(v208);
      v21 = 0;
      if (!v34)
        goto LABEL_287;
LABEL_237:
      os_release(v34);
LABEL_287:
      _Block_object_dispose(&v306, 8);
      _Block_object_dispose(&v310, 8);
      return v21;
    }
  }
  if (*((__int16 *)handle + 188) < 0)
    return 0;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v25 = gconnectionLogObj;
  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    return 0;
  v26 = *((_DWORD *)handle + 92);
  *(_DWORD *)buf = 136447490;
  v315 = "nw_protocol_http2_get_input_frames";
  v316 = 2082;
  v317 = handle + 378;
  v318 = 2080;
  v319 = (uint64_t)" ";
  v320 = 1024;
  *(_DWORD *)v321 = v26;
  *(_WORD *)&v321[4] = 1042;
  *(_DWORD *)&v321[6] = 16;
  *(_WORD *)&v321[10] = 2098;
  *(_QWORD *)&v321[12] = a2;
  _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> can't find hash table entry for %{public,uuid_t}.16P", buf, 0x36u);
  return 0;
}

BOOL nw_protocol_http2_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  char *handle;
  _QWORD *output_handler_context;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  _BOOL8 result;
  int v16;
  int v17;
  const char *v18;
  uint64_t v19;
  int v20;
  nw_protocol_identifier *identifier;
  NSObject *v22;
  os_log_type_t v23;
  uint32_t v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  size_t v32;
  uint64_t frame;
  uint64_t v34;
  uint64_t *v35;
  int v36;
  int v37;
  int v38;
  nw_frame **tqh_last;
  int v40;
  int v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  int v45;
  int v46;
  const char *v47;
  char *v48;
  _BOOL4 v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  const char *v59;
  NSObject *v60;
  int v61;
  char *backtrace_string;
  _BOOL4 v63;
  const char *v64;
  _BOOL4 v65;
  _BOOL4 v66;
  _BOOL4 v67;
  char *v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  NSObject *v72;
  int v73;
  int v74;
  NSObject *v75;
  int v76;
  int v77;
  NSObject *v78;
  int v79;
  NSObject *v80;
  int v81;
  char *v82;
  _BOOL4 v83;
  NSObject *v84;
  int v85;
  int v86;
  int v87;
  int v88;
  char *v89;
  NSObject *v90;
  os_log_type_t v91;
  int v92;
  int v93;
  const char *v94;
  char *v95;
  _BOOL4 v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  char v103;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v106;
  __int16 v107;
  char *v108;
  __int16 v109;
  const char *v110;
  __int16 v111;
  int v112;
  __int16 v113;
  _BYTE v114[26];
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_get_output_frames";
    v56 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103))
      goto LABEL_148;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null protocol";
      goto LABEL_147;
    }
    if (!v103)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v57 = __nwlog_obj();
    v58 = type;
    v63 = os_log_type_enabled(v57, type);
    if (!backtrace_string)
    {
      if (!v63)
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_147;
    }
    if (!v63)
      goto LABEL_130;
    *(_DWORD *)buf = 136446466;
    v106 = "nw_protocol_http2_get_output_frames";
    v107 = 2082;
    v108 = backtrace_string;
    v64 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_129:
    _os_log_impl(&dword_182FBE000, v57, v58, v64, buf, 0x16u);
    goto LABEL_130;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_get_output_frames";
    v56 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103))
      goto LABEL_148;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null http2";
      goto LABEL_147;
    }
    if (!v103)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v57 = __nwlog_obj();
    v58 = type;
    v65 = os_log_type_enabled(v57, type);
    if (!backtrace_string)
    {
      if (!v65)
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null http2, no backtrace";
      goto LABEL_147;
    }
    if (!v65)
      goto LABEL_130;
    *(_DWORD *)buf = 136446466;
    v106 = "nw_protocol_http2_get_output_frames";
    v107 = 2082;
    v108 = backtrace_string;
    v64 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_129;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_get_output_frames";
    v56 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103))
      goto LABEL_148;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null input_protocol";
      goto LABEL_147;
    }
    if (!v103)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v57 = __nwlog_obj();
    v58 = type;
    v66 = os_log_type_enabled(v57, type);
    if (!backtrace_string)
    {
      if (!v66)
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_147;
    }
    if (!v66)
      goto LABEL_130;
    *(_DWORD *)buf = 136446466;
    v106 = "nw_protocol_http2_get_output_frames";
    v107 = 2082;
    v108 = backtrace_string;
    v64 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_129;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_get_output_frames";
    v56 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103))
      goto LABEL_148;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null return_array";
      goto LABEL_147;
    }
    if (!v103)
    {
      v57 = __nwlog_obj();
      v58 = type;
      if (!os_log_type_enabled(v57, type))
        goto LABEL_148;
      *(_DWORD *)buf = 136446210;
      v106 = "nw_protocol_http2_get_output_frames";
      v59 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v57 = __nwlog_obj();
    v58 = type;
    v67 = os_log_type_enabled(v57, type);
    if (backtrace_string)
    {
      if (v67)
      {
        *(_DWORD *)buf = 136446466;
        v106 = "nw_protocol_http2_get_output_frames";
        v107 = 2082;
        v108 = backtrace_string;
        v64 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_129;
      }
LABEL_130:
      free(backtrace_string);
      goto LABEL_148;
    }
    if (!v67)
      goto LABEL_148;
    *(_DWORD *)buf = 136446210;
    v106 = "nw_protocol_http2_get_output_frames";
    v59 = "%{public}s called with null return_array, no backtrace";
LABEL_147:
    _os_log_impl(&dword_182FBE000, v57, v58, v59, buf, 0xCu);
LABEL_148:
    if (v56)
      free(v56);
    return 0;
  }
  if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v60 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v61 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v106 = "nw_protocol_http2_get_output_frames";
      v107 = 2082;
      v108 = handle + 378;
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v61;
      _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_25_81469);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    if ((*((__int16 *)handle + 188) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v19 = gconnectionLogObj;
      result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        v20 = *((_DWORD *)handle + 92);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447490;
        v106 = "nw_protocol_http2_get_output_frames";
        v107 = 2082;
        v108 = handle + 378;
        v109 = 2080;
        v110 = " ";
        v111 = 1024;
        v112 = v20;
        v113 = 2048;
        *(_QWORD *)v114 = a2;
        *(_WORD *)&v114[8] = 2080;
        *(_QWORD *)&v114[10] = identifier;
        v18 = "%{public}s %{public}s%s<i%u> cannot get output frames for protocol %p (%s) without proper output handler context";
        v22 = v19;
        v23 = OS_LOG_TYPE_ERROR;
        v24 = 58;
LABEL_31:
        _os_log_impl(&dword_182FBE000, v22, v23, v18, buf, v24);
        return 0;
      }
      return result;
    }
    return 0;
  }
  v11 = output_handler_context[4];
  if (v11)
  {
    v12 = *(unsigned __int16 *)(v11 + 188);
    v13 = v12 | (*(unsigned __int8 *)(v11 + 190) << 16);
    if ((v12 & 1) == 0)
    {
      if ((v13 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v14 = gconnectionLogObj;
        result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          v17 = *(_DWORD *)(v11 + 176);
          v16 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447490;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v16;
          v113 = 1024;
          *(_DWORD *)v114 = v17;
          *(_WORD *)&v114[4] = 2048;
          *(_QWORD *)&v114[6] = a2;
          v18 = "%{public}s %{public}s%s<i%u:s%d> cannot get output frames for stream that is not yet open, protocol (%p)";
LABEL_30:
          v22 = v14;
          v23 = OS_LOG_TYPE_ERROR;
          v24 = 54;
          goto LABEL_31;
        }
        return result;
      }
      return 0;
    }
    if ((v12 & 0x2000) != 0)
    {
      result = 0;
      if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v29 = gconnectionLogObj;
        result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        if (result)
        {
          v30 = *((_DWORD *)handle + 92);
          v31 = *(_DWORD *)(v11 + 176);
          *(_DWORD *)buf = 136447234;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = handle + 378;
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v30;
          v113 = 1024;
          *(_DWORD *)v114 = v31;
          v18 = "%{public}s %{public}s%s<i%u> stream %d sending informational response, not allowing output frames";
          v22 = v29;
          v23 = OS_LOG_TYPE_DEBUG;
          v24 = 44;
          goto LABEL_31;
        }
      }
      return result;
    }
    if (*(_QWORD *)(v11 + 16))
    {
      result = 0;
      if ((v13 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v26 = gconnectionLogObj;
        result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        if (result)
        {
          v28 = *(_DWORD *)(v11 + 176);
          v27 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447490;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v27;
          v113 = 1024;
          *(_DWORD *)v114 = v28;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v28;
          v18 = "%{public}s %{public}s%s<i%u:s%d> stream %d already has waiting output frames, cannot get more";
          v22 = v26;
          v23 = OS_LOG_TYPE_DEBUG;
          v24 = 50;
          goto LABEL_31;
        }
      }
      return result;
    }
    if (a4 >= 0x1000000)
      v32 = 0x1000000;
    else
      v32 = a4;
    if ((v13 & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v72 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v74 = *(_DWORD *)(v11 + 176);
        v73 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v106 = "nw_protocol_http2_get_output_frames";
        v107 = 2082;
        v108 = (char *)(v11 + 191);
        v109 = 2080;
        v110 = " ";
        v111 = 1024;
        v112 = v73;
        v113 = 1024;
        *(_DWORD *)v114 = v74;
        *(_WORD *)&v114[4] = 1024;
        *(_DWORD *)&v114[6] = v32;
        *(_WORD *)&v114[10] = 1024;
        *(_DWORD *)&v114[12] = a4;
        _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> h2 was asked for frame of adjusted size %u (original %u)", buf, 0x38u);
      }
    }
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v75 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v77 = *(_DWORD *)(v11 + 176);
        v76 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447490;
        v106 = "nw_protocol_http2_get_output_frames";
        v107 = 2082;
        v108 = (char *)(v11 + 191);
        v109 = 2080;
        v110 = " ";
        v111 = 1024;
        v112 = v76;
        v113 = 1024;
        *(_DWORD *)v114 = v77;
        *(_WORD *)&v114[4] = 1024;
        *(_DWORD *)&v114[6] = v32;
        _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> adding frame of size %u", buf, 0x32u);
      }
    }
    if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v78 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v79 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v106 = "http2_create_output_frame";
        v107 = 2082;
        v108 = handle + 378;
        v109 = 2080;
        v110 = " ";
        v111 = 1024;
        v112 = v79;
        v113 = 1024;
        *(_DWORD *)v114 = v32;
        _os_log_impl(&dword_182FBE000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> requested output frame of length %u", buf, 0x2Cu);
      }
    }
    frame = nw_frame_cache_create_frame((uint64_t *)handle + 25, v32);
    if (frame)
    {
      v34 = frame;
      *(_QWORD *)(frame + 16) = 0;
      v35 = (uint64_t *)*((_QWORD *)handle + 24);
      *(_QWORD *)(frame + 24) = v35;
      *v35 = frame;
      *((_QWORD *)handle + 24) = frame + 16;
      *(_QWORD *)(frame + 80) = nw_protocol_http2_frame_output_finalizer;
      *(_QWORD *)(frame + 88) = 0;
      http2_output_frame_metadata_reset(frame, (uint64_t)handle, (uint64_t)a2);
      if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v80 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v81 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136447490;
          v106 = "http2_create_output_frame";
          v107 = 2082;
          v108 = handle + 378;
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v81;
          v113 = 2048;
          *(_QWORD *)v114 = v34;
          *(_WORD *)&v114[8] = 1024;
          *(_DWORD *)&v114[10] = v32;
          _os_log_impl(&dword_182FBE000, v80, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> output_frame_create returning frame %p for requested length %u", buf, 0x36u);
        }
      }
      v36 = *(_DWORD *)(v34 + 52);
      if (v36)
        v37 = v36 - (*(_DWORD *)(v34 + 56) + *(_DWORD *)(v34 + 60));
      else
        v37 = 0;
      v38 = *(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16);
      if (v37 == (_DWORD)v32)
      {
        if ((v38 & 0x80000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v84 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v86 = *(_DWORD *)(v11 + 176);
            v85 = *(_DWORD *)(v11 + 180);
            *(_DWORD *)buf = 136447490;
            v106 = "nw_protocol_http2_get_output_frames";
            v107 = 2082;
            v108 = (char *)(v11 + 191);
            v109 = 2080;
            v110 = " ";
            v111 = 1024;
            v112 = v85;
            v113 = 1024;
            *(_DWORD *)v114 = v86;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v32;
            _os_log_impl(&dword_182FBE000, v84, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> returning frame of %u bytes", buf, 0x32u);
          }
        }
        *(_QWORD *)(v34 + 32) = 0;
        tqh_last = a6->tqh_last;
        *(_QWORD *)(v34 + 40) = tqh_last;
        *tqh_last = (nw_frame *)v34;
        a6->tqh_last = (nw_frame **)(v34 + 32);
        return 1;
      }
      if ((v38 & 0x80000) != 0)
      {
LABEL_92:
        nw_frame_finalize(v34);
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v41 = *(_DWORD *)(v11 + 176);
      v40 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)buf = 136447746;
      v106 = "nw_protocol_http2_get_output_frames";
      v107 = 2082;
      v108 = (char *)(v11 + 191);
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v40;
      v113 = 1024;
      *(_DWORD *)v114 = v41;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v37;
      *(_WORD *)&v114[10] = 1024;
      *(_DWORD *)&v114[12] = v32;
      v42 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v103 = 0;
      if (__nwlog_fault(v42, &type, &v103))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v43 = gconnectionLogObj;
          v44 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            goto LABEL_90;
          v46 = *(_DWORD *)(v11 + 176);
          v45 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447746;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v45;
          v113 = 1024;
          *(_DWORD *)v114 = v46;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_create_output_frame";
          goto LABEL_89;
        }
        if (!v103)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v43 = gconnectionLogObj;
          v44 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            goto LABEL_90;
          v53 = *(_DWORD *)(v11 + 176);
          v52 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447746;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v52;
          v113 = 1024;
          *(_DWORD *)v114 = v53;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_creat"
                "e_output_frame, backtrace limit exceeded";
          goto LABEL_89;
        }
        v48 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v43 = gconnectionLogObj;
        v44 = type;
        v49 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v48)
        {
          if (v49)
          {
            v51 = *(_DWORD *)(v11 + 176);
            v50 = *(_DWORD *)(v11 + 180);
            *(_DWORD *)buf = 136448002;
            v106 = "nw_protocol_http2_get_output_frames";
            v107 = 2082;
            v108 = (char *)(v11 + 191);
            v109 = 2080;
            v110 = " ";
            v111 = 1024;
            v112 = v50;
            v113 = 1024;
            *(_DWORD *)v114 = v51;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v37;
            *(_WORD *)&v114[10] = 1024;
            *(_DWORD *)&v114[12] = v32;
            *(_WORD *)&v114[16] = 2082;
            *(_QWORD *)&v114[18] = v48;
            _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_create_output_frame, dumping backtrace:%{public}s", buf, 0x42u);
          }
          free(v48);
          goto LABEL_90;
        }
        if (v49)
        {
          v55 = *(_DWORD *)(v11 + 176);
          v54 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447746;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v54;
          v113 = 1024;
          *(_DWORD *)v114 = v55;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_creat"
                "e_output_frame, no backtrace";
LABEL_89:
          _os_log_impl(&dword_182FBE000, v43, v44, v47, buf, 0x38u);
        }
      }
LABEL_90:
      if (v42)
        free(v42);
      goto LABEL_92;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v106 = "http2_create_output_frame";
    v68 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (__nwlog_fault(v68, &type, &v103))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v69 = __nwlog_obj();
        v70 = type;
        if (!os_log_type_enabled(v69, type))
          goto LABEL_184;
        *(_DWORD *)buf = 136446210;
        v106 = "http2_create_output_frame";
        v71 = "%{public}s called with null frame";
LABEL_183:
        _os_log_impl(&dword_182FBE000, v69, v70, v71, buf, 0xCu);
        goto LABEL_184;
      }
      if (!v103)
      {
        v69 = __nwlog_obj();
        v70 = type;
        if (!os_log_type_enabled(v69, type))
          goto LABEL_184;
        *(_DWORD *)buf = 136446210;
        v106 = "http2_create_output_frame";
        v71 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_183;
      }
      v82 = (char *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = type;
      v83 = os_log_type_enabled(v69, type);
      if (!v82)
      {
        if (!v83)
          goto LABEL_184;
        *(_DWORD *)buf = 136446210;
        v106 = "http2_create_output_frame";
        v71 = "%{public}s called with null frame, no backtrace";
        goto LABEL_183;
      }
      if (v83)
      {
        *(_DWORD *)buf = 136446466;
        v106 = "http2_create_output_frame";
        v107 = 2082;
        v108 = v82;
        _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v82);
    }
LABEL_184:
    if (v68)
      free(v68);
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) != 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v88 = *(_DWORD *)(v11 + 176);
    v87 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447490;
    v106 = "nw_protocol_http2_get_output_frames";
    v107 = 2082;
    v108 = (char *)(v11 + 191);
    v109 = 2080;
    v110 = " ";
    v111 = 1024;
    v112 = v87;
    v113 = 1024;
    *(_DWORD *)v114 = v88;
    *(_WORD *)&v114[4] = 1024;
    *(_DWORD *)&v114[6] = v32;
    v89 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (!__nwlog_fault(v89, &type, &v103))
      goto LABEL_209;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v90 = gconnectionLogObj;
      v91 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_209;
      v93 = *(_DWORD *)(v11 + 176);
      v92 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)buf = 136447490;
      v106 = "nw_protocol_http2_get_output_frames";
      v107 = 2082;
      v108 = (char *)(v11 + 191);
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v92;
      v113 = 1024;
      *(_DWORD *)v114 = v93;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v32;
      v94 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u";
    }
    else if (v103)
    {
      v95 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v90 = gconnectionLogObj;
      v91 = type;
      v96 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v95)
      {
        if (v96)
        {
          v98 = *(_DWORD *)(v11 + 176);
          v97 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136447746;
          v106 = "nw_protocol_http2_get_output_frames";
          v107 = 2082;
          v108 = (char *)(v11 + 191);
          v109 = 2080;
          v110 = " ";
          v111 = 1024;
          v112 = v97;
          v113 = 1024;
          *(_DWORD *)v114 = v98;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v32;
          *(_WORD *)&v114[10] = 2082;
          *(_QWORD *)&v114[12] = v95;
          _os_log_impl(&dword_182FBE000, v90, v91, "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u, dumping backtrace:%{public}s", buf, 0x3Cu);
        }
        free(v95);
        goto LABEL_209;
      }
      if (!v96)
      {
LABEL_209:
        if (v89)
          free(v89);
        return 0;
      }
      v102 = *(_DWORD *)(v11 + 176);
      v101 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)buf = 136447490;
      v106 = "nw_protocol_http2_get_output_frames";
      v107 = 2082;
      v108 = (char *)(v11 + 191);
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v101;
      v113 = 1024;
      *(_DWORD *)v114 = v102;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v32;
      v94 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v90 = gconnectionLogObj;
      v91 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_209;
      v100 = *(_DWORD *)(v11 + 176);
      v99 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)buf = 136447490;
      v106 = "nw_protocol_http2_get_output_frames";
      v107 = 2082;
      v108 = (char *)(v11 + 191);
      v109 = 2080;
      v110 = " ";
      v111 = 1024;
      v112 = v99;
      v113 = 1024;
      *(_DWORD *)v114 = v100;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v32;
      v94 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v90, v91, v94, buf, 0x32u);
    goto LABEL_209;
  }
  if (*((__int16 *)handle + 188) < 0)
    return 0;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v14 = gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v25 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447490;
    v106 = "nw_protocol_http2_get_output_frames";
    v107 = 2082;
    v108 = handle + 378;
    v109 = 2080;
    v110 = " ";
    v111 = 1024;
    v112 = v25;
    v113 = 1042;
    *(_DWORD *)v114 = 16;
    *(_WORD *)&v114[4] = 2098;
    *(_QWORD *)&v114[6] = a2;
    v18 = "%{public}s %{public}s%s<i%u> cannot find hash table entry for %{public,uuid_t}.16P";
    goto LABEL_30;
  }
  return result;
}

uint64_t nw_protocol_http2_get_parameters(nw_protocol *a1)
{
  _QWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
      return handle[13];
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_http2_get_parameters";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http2_get_parameters";
        v6 = "%{public}s called with null http2";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http2_get_parameters";
        v6 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http2_get_parameters";
        v6 = "%{public}s called with null http2, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_http2_get_parameters";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_http2_get_parameters";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http2_get_parameters";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http2_get_parameters";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_http2_get_parameters";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_http2_get_parameters";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3)
    free(v3);
  return 0;
}

void nw_protocol_http2_stream_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char *v10;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_stream_get_message_properties";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_http2_stream_get_message_properties";
      v7 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_http2_stream_get_message_properties";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v4)
          return;
LABEL_35:
        free(v4);
        return;
      }
      if (!v9)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_http2_stream_get_message_properties";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_http2_stream_get_message_properties";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }
  if (*(_QWORD *)(a1 + 40))
  {
    if (a3)
    {
      v3 = a3[1] & 0xFFFFFFF8;
      *a3 = -1;
      a3[1] = v3;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_http2_stream_get_message_properties";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_stream_get_message_properties";
    v7 = "%{public}s called with null http2";
    goto LABEL_33;
  }
  if (!v12)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_stream_get_message_properties";
    v7 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_33;
  }
  v10 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11)
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_stream_get_message_properties";
    v7 = "%{public}s called with null http2, no backtrace";
    goto LABEL_33;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    v15 = "nw_protocol_http2_stream_get_message_properties";
    v16 = 2082;
    v17 = v10;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v4)
    goto LABEL_35;
}

uint64_t nw_protocol_http2_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _DWORD *handle;
  nw_frame *tqh_first;
  nw_frame *v5;
  char v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  _BOOL4 v20;
  const char *v21;
  _BOOL4 v22;
  char *backtrace_string;
  _BOOL4 v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v28;
  nw_frame_array_s *v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (((__int16)handle[94] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v13 = handle[92];
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = (char *)handle + 378;
          *(_WORD *)&buf[22] = 2080;
          v28 = " ";
          LOWORD(v29) = 1024;
          *(_DWORD *)((char *)&v29 + 2) = v13;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_25_81469);
      if (_nw_signposts_enabled && kdebug_is_enabled())
      {
        kdebug_trace();
        if (a2)
        {
LABEL_10:
          if (gLogDatapath)
          {
            v14 = __nwlog_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_81659;
          v28 = (const char *)&__block_descriptor_tmp_30_81660;
          v29 = a2;
          v30 = 1;
          tqh_first = a2->tqh_first;
          do
          {
            if (!tqh_first)
              break;
            v5 = (nw_frame *)*((_QWORD *)tqh_first + 4);
            v6 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            tqh_first = v5;
          }
          while ((v6 & 1) != 0);
LABEL_14:
          nw_http2_session_send((uint64_t)handle);
          return 1;
        }
      }
      else if (a2)
      {
        goto LABEL_10;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
      v15 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v25 = 0;
      if (__nwlog_fault(v15, &type, &v25))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (!os_log_type_enabled(v16, type))
            goto LABEL_66;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
          v18 = "%{public}s called with null array";
          goto LABEL_65;
        }
        if (!v25)
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (!os_log_type_enabled(v16, type))
            goto LABEL_66;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
          v18 = "%{public}s called with null array, backtrace limit exceeded";
          goto LABEL_65;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v16 = __nwlog_obj();
        v17 = type;
        v24 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_66;
        }
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
          v18 = "%{public}s called with null array, no backtrace";
LABEL_65:
          _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
        }
      }
LABEL_66:
      if (v15)
        free(v15);
      goto LABEL_14;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25))
      goto LABEL_60;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
        v11 = "%{public}s called with null http2";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (!v25)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
        v11 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v19)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
        v11 = "%{public}s called with null http2, no backtrace";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v19;
      v21 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
    goto LABEL_60;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v25)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v19)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v19;
      v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_42:
      _os_log_impl(&dword_182FBE000, v9, v10, v21, buf, 0x16u);
    }
LABEL_43:
    free(v19);
    goto LABEL_60;
  }
  v9 = __nwlog_obj();
  v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_finalize_output_frames";
    v11 = "%{public}s called with null protocol";
LABEL_59:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
  }
LABEL_60:
  if (v8)
    free(v8);
  return 0;
}

BOOL nw_protocol_http2_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  char *handle;
  __int16 v7;
  int v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  int v12;
  const char *v13;
  char *v14;
  _BOOL4 v15;
  int v16;
  int v17;
  int v18;
  NSObject *v19;
  _BOOL8 result;
  int v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  NSObject *v26;
  int v27;
  int v28;
  NSObject *v29;
  int v30;
  const char *v31;
  char *backtrace_string;
  _BOOL4 v33;
  const char *v34;
  _BOOL4 v35;
  NSObject *v36;
  int v37;
  NSObject *v38;
  int v39;
  NSObject *v40;
  int v41;
  __int16 v42;
  NSObject *v43;
  int v44;
  int v45;
  void *v46;
  _BYTE *v47;
  _BOOL4 v48;
  NSObject *v49;
  int v50;
  NSObject *v51;
  int v52;
  int v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  int v57;
  const char *v58;
  char *v59;
  _BOOL4 v60;
  int v61;
  int v62;
  int v63;
  char *v64;
  int v65;
  NSObject *v66;
  int v67;
  os_log_type_t type[8];
  uint64_t v69;
  uint64_t (*v70)(uint64_t, uint64_t);
  void *v71;
  char *v72;
  char v73;
  os_log_type_t v74;
  uint8_t buf[4];
  const char *v76;
  __int16 v77;
  char *v78;
  __int16 v79;
  const char *v80;
  __int16 v81;
  int v82;
  __int16 v83;
  nw_listen_protocol *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http2_add_listen_handler";
    v22 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v74 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, type, &v74))
      goto LABEL_97;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v74 == OS_LOG_TYPE_DEFAULT)
      {
        v23 = __nwlog_obj();
        v24 = type[0];
        if (!os_log_type_enabled(v23, type[0]))
          goto LABEL_97;
        *(_DWORD *)buf = 136446210;
        v76 = "nw_protocol_http2_add_listen_handler";
        v25 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_96;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type[0];
      v33 = os_log_type_enabled(v23, type[0]);
      if (!backtrace_string)
      {
        if (!v33)
          goto LABEL_97;
        *(_DWORD *)buf = 136446210;
        v76 = "nw_protocol_http2_add_listen_handler";
        v25 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_96;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        v76 = "nw_protocol_http2_add_listen_handler";
        v77 = 2082;
        v78 = backtrace_string;
        v34 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_182FBE000, v23, v24, v34, buf, 0x16u);
      }
LABEL_75:
      free(backtrace_string);
      goto LABEL_97;
    }
    v23 = __nwlog_obj();
    v24 = type[0];
    if (!os_log_type_enabled(v23, type[0]))
      goto LABEL_97;
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http2_add_listen_handler";
    v25 = "%{public}s called with null protocol";
LABEL_96:
    _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0xCu);
LABEL_97:
    if (v22)
      free(v22);
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http2_add_listen_handler";
    v22 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v74 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, type, &v74))
      goto LABEL_97;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type[0];
      if (!os_log_type_enabled(v23, type[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http2_add_listen_handler";
      v25 = "%{public}s called with null http2";
      goto LABEL_96;
    }
    if (v74 == OS_LOG_TYPE_DEFAULT)
    {
      v23 = __nwlog_obj();
      v24 = type[0];
      if (!os_log_type_enabled(v23, type[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v76 = "nw_protocol_http2_add_listen_handler";
      v25 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type[0];
    v35 = os_log_type_enabled(v23, type[0]);
    if (backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        v76 = "nw_protocol_http2_add_listen_handler";
        v77 = 2082;
        v78 = backtrace_string;
        v34 = "%{public}s called with null http2, dumping backtrace:%{public}s";
        goto LABEL_74;
      }
      goto LABEL_75;
    }
    if (!v35)
      goto LABEL_97;
    *(_DWORD *)buf = 136446210;
    v76 = "nw_protocol_http2_add_listen_handler";
    v25 = "%{public}s called with null http2, no backtrace";
    goto LABEL_96;
  }
  v7 = *((_WORD *)handle + 188);
  if (v7 < 0 || !gLogDatapath)
  {
    if (*((_QWORD *)handle + 18))
      goto LABEL_6;
LABEL_50:
    if ((v7 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v36 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v37 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        v76 = "nw_protocol_http2_add_listen_handler";
        v77 = 2082;
        v78 = handle + 378;
        v79 = 2080;
        v80 = " ";
        v81 = 1024;
        v82 = v37;
        _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> added protocol listen handler", buf, 0x26u);
      }
    }
    *((_QWORD *)handle + 18) = a2;
    a2->protocol_handler = a1;
    if ((a3 & 1) != 0)
      nw_protocol_remove_instance((uint64_t)a1);
    if ((*((_WORD *)handle + 188) & 0x1000) == 0)
      return 1;
    if ((*((_WORD *)handle + 188) & 0x8000) == 0)
    {
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v38 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v39 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v76 = "nw_protocol_http2_add_listen_handler";
          v77 = 2082;
          v78 = handle + 378;
          v79 = 2080;
          v80 = " ";
          v81 = 1024;
          v82 = v39;
          _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> waiting for listen handler, resuming processing of connected", buf, 0x26u);
        }
      }
      v28 = *((__int16 *)handle + 188);
      if (v28 < 0)
      {
        if ((v28 & 0x80) == 0)
        {
LABEL_60:
          if ((v28 & 0x8000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v29 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v30 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446978;
              v76 = "nw_protocol_http2_process_connected";
              v77 = 2082;
              v78 = handle + 378;
              v79 = 2080;
              v80 = " ";
              v81 = 1024;
              v82 = v30;
              v31 = "%{public}s %{public}s%s<i%u> not server, processing input without waiting";
LABEL_159:
              _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, v31, buf, 0x26u);
              goto LABEL_104;
            }
          }
          goto LABEL_104;
        }
LABEL_101:
        if (!*((_QWORD *)handle + 18))
        {
          if ((v28 & 0x8000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v51 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
            {
              v52 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446978;
              v76 = "nw_protocol_http2_process_connected";
              v77 = 2082;
              v78 = handle + 378;
              v79 = 2080;
              v80 = " ";
              v81 = 1024;
              v82 = v52;
              _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> no listen handler on server, deferring processing of input and connected state until listen handler is present", buf, 0x26u);
            }
          }
          *((_WORD *)handle + 188) |= 0x1000u;
          return 1;
        }
        if ((v28 & 0x8000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v29 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v65 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            v76 = "nw_protocol_http2_process_connected";
            v77 = 2082;
            v78 = handle + 378;
            v79 = 2080;
            v80 = " ";
            v81 = 1024;
            v82 = v65;
            v31 = "%{public}s %{public}s%s<i%u> listen handler present, processing input without waiting";
            goto LABEL_159;
          }
        }
LABEL_104:
        v42 = *((_WORD *)handle + 188);
        *((_WORD *)handle + 188) = v42 & 0xEFFF;
        if ((v42 & 0xC) != 0)
        {
          if ((v42 & 0x8000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v43 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v44 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136446978;
              v76 = "nw_protocol_http2_process_connected";
              v77 = 2082;
              v78 = handle + 378;
              v79 = 2080;
              v80 = " ";
              v81 = 1024;
              v82 = v44;
              _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> tunnel already connected or closed, ignoring connected event", buf, 0x26u);
            }
          }
          return 1;
        }
        nw_http2_send_settings((uint64_t)handle);
        v45 = *((__int16 *)handle + 188);
        *((_WORD *)handle + 188) |= 4u;
        if ((v45 & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v66 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v67 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            v76 = "nw_protocol_http2_process_connected";
            v77 = 2082;
            v78 = handle + 378;
            v79 = 2080;
            v80 = " ";
            v81 = 1024;
            v82 = v67;
            _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2 tunnel is now connected", buf, 0x26u);
          }
        }
        v46 = (void *)*((_QWORD *)handle + 14);
        if (v46)
        {
          v47 = v46;
          v48 = (v47[231] & 4) == 0;

          if (v48)
          {
            if ((*((__int16 *)handle + 188) & 0x80000000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v49 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v50 = *((_DWORD *)handle + 92);
                *(_DWORD *)buf = 136446978;
                v76 = "nw_protocol_http2_process_connected";
                v77 = 2082;
                v78 = handle + 378;
                v79 = 2080;
                v80 = " ";
                v81 = 1024;
                v82 = v50;
                _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered", buf, 0x26u);
              }
            }
          }
          else
          {
            nw_endpoint_add_edges_for_instance(v47, (unsigned __int8 *)handle, 1);
          }
          goto LABEL_152;
        }
        if (*((__int16 *)handle + 188) < 0)
        {
LABEL_152:
          nw_protocol_http2_process_input((uint64_t)handle);
          v64 = (char *)*((_QWORD *)handle + 19);
          *(_QWORD *)type = MEMORY[0x1E0C809B0];
          v69 = 0x40000000;
          v70 = ___ZL35nw_protocol_http2_process_connectedP17nw_protocol_http2_block_invoke;
          v71 = &__block_descriptor_tmp_46_82346;
          v72 = handle;
          nw_hash_table_apply(v64, (uint64_t)type);
          return 1;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v53 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136446978;
        v76 = "nw_protocol_http2_process_connected";
        v77 = 2082;
        v78 = handle + 378;
        v79 = 2080;
        v80 = " ";
        v81 = 1024;
        v82 = v53;
        v54 = (char *)_os_log_send_and_compose_impl();
        v74 = OS_LOG_TYPE_ERROR;
        v73 = 0;
        if (__nwlog_fault(v54, &v74, &v73))
        {
          if (v74 == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v55 = gconnectionLogObj;
            v56 = v74;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v74))
              goto LABEL_150;
            v57 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            v76 = "nw_protocol_http2_process_connected";
            v77 = 2082;
            v78 = handle + 378;
            v79 = 2080;
            v80 = " ";
            v81 = 1024;
            v82 = v57;
            v58 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
            goto LABEL_149;
          }
          if (!v73)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v55 = gconnectionLogObj;
            v56 = v74;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v74))
              goto LABEL_150;
            v62 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            v76 = "nw_protocol_http2_process_connected";
            v77 = 2082;
            v78 = handle + 378;
            v79 = 2080;
            v80 = " ";
            v81 = 1024;
            v82 = v62;
            v58 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
            goto LABEL_149;
          }
          v59 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v55 = gconnectionLogObj;
          v56 = v74;
          v60 = os_log_type_enabled((os_log_t)gconnectionLogObj, v74);
          if (v59)
          {
            if (v60)
            {
              v61 = *((_DWORD *)handle + 92);
              *(_DWORD *)buf = 136447234;
              v76 = "nw_protocol_http2_process_connected";
              v77 = 2082;
              v78 = handle + 378;
              v79 = 2080;
              v80 = " ";
              v81 = 1024;
              v82 = v61;
              v83 = 2082;
              v84 = (nw_listen_protocol *)v59;
              _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s", buf, 0x30u);
            }
            free(v59);
            goto LABEL_150;
          }
          if (v60)
          {
            v63 = *((_DWORD *)handle + 92);
            *(_DWORD *)buf = 136446978;
            v76 = "nw_protocol_http2_process_connected";
            v77 = 2082;
            v78 = handle + 378;
            v79 = 2080;
            v80 = " ";
            v81 = 1024;
            v82 = v63;
            v58 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_149:
            _os_log_impl(&dword_182FBE000, v55, v56, v58, buf, 0x26u);
          }
        }
LABEL_150:
        if (v54)
          free(v54);
        goto LABEL_152;
      }
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v40 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v41 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v76 = "nw_protocol_http2_process_connected";
          v77 = 2082;
          v78 = handle + 378;
          v79 = 2080;
          v80 = " ";
          v81 = 1024;
          v82 = v41;
          _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    LOWORD(v28) = *((_WORD *)handle + 188);
    if ((v28 & 0x80) == 0)
      goto LABEL_60;
    goto LABEL_101;
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v26 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
  {
    v27 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447234;
    v76 = "nw_protocol_http2_add_listen_handler";
    v77 = 2082;
    v78 = handle + 378;
    v79 = 2080;
    v80 = " ";
    v81 = 1024;
    v82 = v27;
    v83 = 2048;
    v84 = a2;
    _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with listen_protocol %p", buf, 0x30u);
  }
  v7 = *((_WORD *)handle + 188);
  if (!*((_QWORD *)handle + 18))
    goto LABEL_50;
LABEL_6:
  if ((v7 & 0x9000) != 0x1000)
    goto LABEL_32;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v8 = *((_DWORD *)handle + 92);
  *(_DWORD *)buf = 136446978;
  v76 = "nw_protocol_http2_add_listen_handler";
  v77 = 2082;
  v78 = handle + 378;
  v79 = 2080;
  v80 = " ";
  v81 = 1024;
  v82 = v8;
  v9 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v74 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v9, type, &v74))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v10 = gconnectionLogObj;
      v11 = type[0];
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
        goto LABEL_29;
      v12 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v76 = "nw_protocol_http2_add_listen_handler";
      v77 = 2082;
      v78 = handle + 378;
      v79 = 2080;
      v80 = " ";
      v81 = 1024;
      v82 = v12;
      v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time";
      goto LABEL_28;
    }
    if (v74 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v10 = gconnectionLogObj;
      v11 = type[0];
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
        goto LABEL_29;
      v17 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v76 = "nw_protocol_http2_add_listen_handler";
      v77 = 2082;
      v78 = handle + 378;
      v79 = 2080;
      v80 = " ";
      v81 = 1024;
      v82 = v17;
      v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, "
            "backtrace limit exceeded";
      goto LABEL_28;
    }
    v14 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v10 = gconnectionLogObj;
    v11 = type[0];
    v15 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
    if (v14)
    {
      if (v15)
      {
        v16 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v76 = "nw_protocol_http2_add_listen_handler";
        v77 = 2082;
        v78 = handle + 378;
        v79 = 2080;
        v80 = " ";
        v81 = 1024;
        v82 = v16;
        v83 = 2082;
        v84 = (nw_listen_protocol *)v14;
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, dumping backtrace:%{public}s", buf, 0x30u);
      }
      free(v14);
      goto LABEL_29;
    }
    if (v15)
    {
      v18 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      v76 = "nw_protocol_http2_add_listen_handler";
      v77 = 2082;
      v78 = handle + 378;
      v79 = 2080;
      v80 = " ";
      v81 = 1024;
      v82 = v18;
      v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, no backtrace";
LABEL_28:
      _os_log_impl(&dword_182FBE000, v10, v11, v13, buf, 0x26u);
    }
  }
LABEL_29:
  if (v9)
    free(v9);
  v7 = *((_WORD *)handle + 188);
LABEL_32:
  if (v7 < 0)
    return 0;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v19 = gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v21 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136446978;
    v76 = "nw_protocol_http2_add_listen_handler";
    v77 = 2082;
    v78 = handle + 378;
    v79 = 2080;
    v80 = " ";
    v81 = 1024;
    v82 = v21;
    _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> already have a listen handler, ignoring add", buf, 0x26u);
    return 0;
  }
  return result;
}

uint64_t nw_protocol_http2_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  char *handle;
  __int16 v4;
  uint64_t v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  int v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  _BOOL4 v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  nw_listen_protocol *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if ((*((__int16 *)handle + 188) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v11 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v12 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136447234;
          v22 = "nw_protocol_http2_remove_listen_handler";
          v23 = 2082;
          v24 = handle + 378;
          v25 = 2080;
          v26 = " ";
          v27 = 1024;
          v28 = v12;
          v29 = 2048;
          v30 = a2;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with listen_protocol %p", buf, 0x30u);
        }
      }
      if (*((nw_listen_protocol **)handle + 18) == a2)
      {
        *((_QWORD *)handle + 18) = 0;
        a2->protocol_handler = 0;
        if (*((__int16 *)handle + 188) < 0)
        {
LABEL_10:
          v4 = *((_WORD *)handle + 188);
          if ((v4 & 0x80) != 0)
          {
            nw_http2_send_goaway((uint64_t)handle);
          }
          else
          {
            *((_WORD *)handle + 188) = v4 | 2;
            v5 = *((_QWORD *)handle + 11);
            if (v5)
            {
              if (*(_QWORD *)v5)
              {
                dispatch_source_set_timer(*(dispatch_source_t *)v5, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
              }
              else
              {
                *(_OWORD *)(v5 + 32) = xmmword_183C6F190;
                if (*(_BYTE *)(v5 + 48))
                {
                  if (*(_BYTE *)(v5 + 49))
                    nw_queue_source_run_timer(v5, (uint64_t)a2);
                }
              }
            }
          }
          return 1;
        }
      }
      else if (*((__int16 *)handle + 188) < 0)
      {
        goto LABEL_10;
      }
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v13 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v14 = *((_DWORD *)handle + 92);
          *(_DWORD *)buf = 136446978;
          v22 = "nw_protocol_http2_remove_listen_handler";
          v23 = 2082;
          v24 = handle + 378;
          v25 = 2080;
          v26 = " ";
          v27 = 1024;
          v28 = v14;
          _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removed protocol listen handler", buf, 0x26u);
        }
      }
      goto LABEL_10;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_http2_remove_listen_handler";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v7, &type, &v19))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_http2_remove_listen_handler";
        v10 = "%{public}s called with null http2";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (!v19)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_http2_remove_listen_handler";
        v10 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v18 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_http2_remove_listen_handler";
        v10 = "%{public}s called with null http2, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_http2_remove_listen_handler";
      v23 = 2082;
      v24 = backtrace_string;
      v17 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_43;
    }
    goto LABEL_44;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_http2_remove_listen_handler";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v7, &type, &v19))
    goto LABEL_54;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_http2_remove_listen_handler";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v16 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_http2_remove_listen_handler";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_http2_remove_listen_handler";
      v23 = 2082;
      v24 = backtrace_string;
      v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_182FBE000, v8, v9, v17, buf, 0x16u);
    }
LABEL_44:
    free(backtrace_string);
    goto LABEL_54;
  }
  v8 = __nwlog_obj();
  v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_http2_remove_listen_handler";
    v10 = "%{public}s called with null protocol";
LABEL_53:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
  }
LABEL_54:
  if (v7)
    free(v7);
  return 0;
}

uint64_t nw_protocol_http2_get_remote_endpoint(nw_protocol *a1)
{
  _QWORD *handle;
  uint64_t v2;
  uint64_t v3;
  uint64_t (*v4)(nw_protocol *);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v2 = handle[6];
      if (v2 && (v3 = *(_QWORD *)(v2 + 24)) != 0 && (v4 = *(uint64_t (**)(nw_protocol *))(v3 + 136)) != 0)
        return v4(a1->default_input_handler);
      else
        return handle[14];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_http2_get_remote_endpoint";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http2_get_remote_endpoint";
        v9 = "%{public}s called with null http2";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (!v14)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http2_get_remote_endpoint";
        v9 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http2_get_remote_endpoint";
        v9 = "%{public}s called with null http2, no backtrace";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_http2_get_remote_endpoint";
      v18 = 2082;
      v19 = backtrace_string;
      v12 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_24;
    }
    goto LABEL_25;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_http2_get_remote_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
    goto LABEL_35;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v14)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http2_get_remote_endpoint";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http2_get_remote_endpoint";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_http2_get_remote_endpoint";
      v18 = 2082;
      v19 = backtrace_string;
      v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
    }
LABEL_25:
    free(backtrace_string);
    goto LABEL_35;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_http2_get_remote_endpoint";
    v9 = "%{public}s called with null protocol";
LABEL_34:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
  }
LABEL_35:
  if (v6)
    free(v6);
  return 0;
}

void nw_protocol_http2_notify(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(void);
  NSObject *v14;
  int v15;
  char *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  NSObject *v21;
  int v22;
  char *backtrace_string;
  _BOOL4 v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  _BOOL4 v29;
  _QWORD v30[8];
  unsigned int v31;
  char v32;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_http2_notify";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32))
      goto LABEL_80;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null protocol";
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v24 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v35 = "nw_protocol_http2_notify";
          v36 = 2082;
          v37 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_80:
        if (!v17)
          return;
        goto LABEL_81;
      }
      if (!v24)
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_79;
  }
  v6 = *(_QWORD *)(a1 + 40);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_http2_notify";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32))
      goto LABEL_80;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (!os_log_type_enabled(v18, type))
          goto LABEL_80;
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_http2_notify";
        v20 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_79;
      }
      v25 = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v26 = os_log_type_enabled(v18, type);
      if (!v25)
      {
        if (!v26)
          goto LABEL_80;
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_http2_notify";
        v20 = "%{public}s called with null http2, no backtrace";
        goto LABEL_79;
      }
      if (!v26)
        goto LABEL_61;
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_http2_notify";
      v36 = 2082;
      v37 = v25;
      v27 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_60;
    }
    v18 = __nwlog_obj();
    v19 = type;
    if (!os_log_type_enabled(v18, type))
      goto LABEL_80;
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_http2_notify";
    v20 = "%{public}s called with null http2";
LABEL_79:
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
    goto LABEL_80;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_http2_notify";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32))
      goto LABEL_80;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null other_protocol";
      goto LABEL_79;
    }
    if (!v32)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_79;
    }
    v25 = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v28 = os_log_type_enabled(v18, type);
    if (!v25)
    {
      if (!v28)
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_79;
    }
    if (!v28)
      goto LABEL_61;
    *(_DWORD *)buf = 136446466;
    v35 = "nw_protocol_http2_notify";
    v36 = 2082;
    v37 = v25;
    v27 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_60:
    _os_log_impl(&dword_182FBE000, v18, v19, v27, buf, 0x16u);
    goto LABEL_61;
  }
  if (!*(_QWORD *)(v6 + 152))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_http2_notify";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32))
      goto LABEL_80;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null http2->http2_streams_protocol";
      goto LABEL_79;
    }
    if (!v32)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null http2->http2_streams_protocol, backtrace limit exceeded";
      goto LABEL_79;
    }
    v25 = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v29 = os_log_type_enabled(v18, type);
    if (!v25)
    {
      if (!v29)
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_http2_notify";
      v20 = "%{public}s called with null http2->http2_streams_protocol, no backtrace";
      goto LABEL_79;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_http2_notify";
      v36 = 2082;
      v37 = v25;
      v27 = "%{public}s called with null http2->http2_streams_protocol, dumping backtrace:%{public}s";
      goto LABEL_60;
    }
LABEL_61:
    free(v25);
    if (!v17)
      return;
LABEL_81:
    free(v17);
    return;
  }
  if ((*(__int16 *)(v6 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v21 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v22 = *(_DWORD *)(v6 + 368);
      *(_DWORD *)buf = 136446978;
      v35 = "nw_protocol_http2_notify";
      v36 = 2082;
      v37 = (char *)(v6 + 378);
      v38 = 2080;
      v39 = " ";
      v40 = 1024;
      v41 = v22;
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if (a3 > 0x16)
    goto LABEL_21;
  if (((1 << a3) & 0x208080) != 0)
    return;
  if (((1 << a3) & 0x12000) == 0)
  {
    if (a3 == 22)
    {
      if ((*(__int16 *)(v6 + 376) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v14 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          v15 = *(_DWORD *)(v6 + 368);
          *(_DWORD *)buf = 136446978;
          v35 = "nw_protocol_http2_notify";
          v36 = 2082;
          v37 = (char *)(v6 + 378);
          v38 = 2080;
          v39 = " ";
          v40 = 1024;
          v41 = v15;
          _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> restarting all streams", buf, 0x26u);
        }
      }
      *(_WORD *)(v6 + 376) |= 8u;
    }
LABEL_21:
    v16 = *(char **)(v6 + 152);
    v30[0] = MEMORY[0x1E0C809B0];
    v30[1] = 0x40000000;
    v30[2] = ___ZL24nw_protocol_http2_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke;
    v30[3] = &__block_descriptor_tmp_87_82282;
    v30[4] = v6;
    v30[5] = a2;
    v31 = a3;
    v30[6] = a4;
    v30[7] = a5;
    nw_hash_table_apply(v16, (uint64_t)v30);
    return;
  }
  v11 = *(_QWORD *)(a1 + 32);
  if (v11)
  {
    v12 = *(_QWORD *)(v11 + 24);
    if (v12)
    {
      v13 = *(void (**)(void))(v12 + 160);
      if (v13)
        v13();
    }
  }
}

uint64_t nw_protocol_http2_copy_info(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  _BOOL8 v5;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  _BOOL4 v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  _BOOL4 v25;
  const char *v26;
  _BOOL4 v27;
  char *v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_protocol_http2_copy_info";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v13, &type, &v29))
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v16 = "%{public}s called with null protocol";
LABEL_50:
        _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
      }
LABEL_51:
      if (v13)
        free(v13);
      return 0;
    }
    if (!v29)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v32 = "nw_protocol_http2_copy_info";
      v33 = 2082;
      v34 = backtrace_string;
      v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
    }
LABEL_33:
    free(backtrace_string);
    goto LABEL_51;
  }
  v3 = *(_QWORD *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_protocol_http2_copy_info";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v13, &type, &v29))
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v16 = "%{public}s called with null http2";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (!v29)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v16 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v20 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v16 = "%{public}s called with null http2, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v32 = "nw_protocol_http2_copy_info";
      v33 = 2082;
      v34 = backtrace_string;
      v19 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (a2 == 253)
    return *(_QWORD *)(v3 + 144);
  v7 = nw_protocol_common_copy_info(a1, a2);
  v5 = v7;
  if (a2 == 255)
  {
    if (!v7)
      v5 = nw_array_create();
    v8 = *(void **)(v3 + 256);
    if (v8)
      nw_array_append(v5, v8);
    if (a3)
    {
      v9 = *(_QWORD *)(a3 + 56);
      if (v9)
      {
        v10 = *(_QWORD *)(v9 + 32);
        if (v10)
        {
          v11 = *(void **)(v10 + 96);
          if (v11)
            nw_array_append(v5, v11);
          return v5;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        type = OS_LOG_TYPE_ERROR;
        v29 = 0;
        v28 = (char *)_os_log_send_and_compose_impl();
        if (!__nwlog_fault(v28, &type, &v29))
          goto LABEL_73;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v21 = __nwlog_obj();
          v22 = type;
          if (!os_log_type_enabled(v21, type))
            goto LABEL_73;
          *(_DWORD *)buf = 136446210;
          v32 = "nw_protocol_http2_copy_info";
          v23 = "%{public}s called with null stream";
          goto LABEL_72;
        }
        if (!v29)
        {
          v21 = __nwlog_obj();
          v22 = type;
          if (!os_log_type_enabled(v21, type))
            goto LABEL_73;
          *(_DWORD *)buf = 136446210;
          v32 = "nw_protocol_http2_copy_info";
          v23 = "%{public}s called with null stream, backtrace limit exceeded";
          goto LABEL_72;
        }
        v24 = (char *)__nw_create_backtrace_string();
        v21 = __nwlog_obj();
        v22 = type;
        v27 = os_log_type_enabled(v21, type);
        if (v24)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_protocol_http2_copy_info";
            v33 = 2082;
            v34 = v24;
            v26 = "%{public}s called with null stream, dumping backtrace:%{public}s";
            goto LABEL_62;
          }
          goto LABEL_63;
        }
        if (!v27)
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v23 = "%{public}s called with null stream, no backtrace";
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        type = OS_LOG_TYPE_ERROR;
        v29 = 0;
        v28 = (char *)_os_log_send_and_compose_impl();
        if (!__nwlog_fault(v28, &type, &v29))
          goto LABEL_73;
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v29)
          {
            v21 = __nwlog_obj();
            v22 = type;
            if (!os_log_type_enabled(v21, type))
              goto LABEL_73;
            *(_DWORD *)buf = 136446210;
            v32 = "nw_protocol_http2_copy_info";
            v23 = "%{public}s called with null node, backtrace limit exceeded";
            goto LABEL_72;
          }
          v24 = (char *)__nw_create_backtrace_string();
          v21 = __nwlog_obj();
          v22 = type;
          v25 = os_log_type_enabled(v21, type);
          if (!v24)
          {
            if (!v25)
              goto LABEL_73;
            *(_DWORD *)buf = 136446210;
            v32 = "nw_protocol_http2_copy_info";
            v23 = "%{public}s called with null node, no backtrace";
            goto LABEL_72;
          }
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_protocol_http2_copy_info";
            v33 = 2082;
            v34 = v24;
            v26 = "%{public}s called with null node, dumping backtrace:%{public}s";
LABEL_62:
            _os_log_impl(&dword_182FBE000, v21, v22, v26, buf, 0x16u);
          }
LABEL_63:
          free(v24);
          goto LABEL_73;
        }
        v21 = __nwlog_obj();
        v22 = type;
        if (!os_log_type_enabled(v21, type))
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_http2_copy_info";
        v23 = "%{public}s called with null node";
      }
LABEL_72:
      _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0xCu);
LABEL_73:
      if (v28)
        free(v28);
    }
  }
  return v5;
}

uint64_t ___ZL24nw_protocol_http2_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  BOOL v10;
  int v11;
  const char *v12;
  const char *v13;
  NSObject *v14;
  os_log_type_t v15;
  uint64_t v16;
  const char *v17;
  BOOL v18;
  int v19;
  const char *v20;
  const char *v21;
  char *v22;
  _BOOL4 v23;
  uint64_t v24;
  const char *v25;
  BOOL v26;
  int v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  BOOL v31;
  int v32;
  const char *v33;
  uint64_t v34;
  const char *v35;
  BOOL v36;
  int v37;
  const char *v38;
  char *v39;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  const char *v44;
  const char *v45;
  BOOL v46;
  int v47;
  const char *v48;
  NSObject *v49;
  os_log_type_t v50;
  const char *v51;
  char *backtrace_string;
  _BOOL4 v53;
  char v54;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v57;
  __int16 v58;
  void *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  char *v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_protocol_http2_notify_block_invoke";
    v48 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v48, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v49 = __nwlog_obj();
        v50 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_protocol_http2_notify_block_invoke";
          v51 = "%{public}s called with null node";
LABEL_82:
          _os_log_impl(&dword_182FBE000, v49, v50, v51, buf, 0xCu);
        }
      }
      else if (v54)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v49 = __nwlog_obj();
        v50 = type;
        v53 = os_log_type_enabled(v49, type);
        if (backtrace_string)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            v57 = "nw_protocol_http2_notify_block_invoke";
            v58 = 2082;
            v59 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s called with null node, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_83;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_protocol_http2_notify_block_invoke";
          v51 = "%{public}s called with null node, no backtrace";
          goto LABEL_82;
        }
      }
      else
      {
        v49 = __nwlog_obj();
        v50 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_protocol_http2_notify_block_invoke";
          v51 = "%{public}s called with null node, backtrace limit exceeded";
          goto LABEL_82;
        }
      }
    }
LABEL_83:
    if (!v48)
      return 1;
    v39 = (char *)v48;
    goto LABEL_57;
  }
  v4 = *(_QWORD *)(a2 + 16);
  if (!v4)
  {
    v7 = *(_QWORD *)(a1 + 32);
    if (v7 && *(__int16 *)(v7 + 376) < 0)
      return 1;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v8 = *(_QWORD *)(a1 + 32);
    v9 = (const char *)(v8 + 378);
    v10 = v8 == 0;
    v11 = *(_DWORD *)(v8 + 368);
    if (v10)
      v9 = "";
    *(_DWORD *)buf = 136447234;
    v57 = "nw_protocol_http2_notify_block_invoke";
    if (v10)
      v12 = "";
    else
      v12 = " ";
    v58 = 2082;
    v59 = (void *)v9;
    v60 = 2080;
    v61 = v12;
    v62 = 1024;
    v63 = v11;
    v64 = 2048;
    v65 = a2;
    v13 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v13, &type, &v54))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v14 = gconnectionLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_55;
      v16 = *(_QWORD *)(a1 + 32);
      v17 = (const char *)(v16 + 378);
      v18 = v16 == 0;
      if (!v16)
        v17 = "";
      v19 = *(_DWORD *)(v16 + 368);
      if (v18)
        v20 = "";
      else
        v20 = " ";
      *(_DWORD *)buf = 136447234;
      v57 = "nw_protocol_http2_notify_block_invoke";
      v58 = 2082;
      v59 = (void *)v17;
      v60 = 2080;
      v61 = v20;
      v62 = 1024;
      v63 = v19;
      v64 = 2048;
      v65 = a2;
      v21 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify";
    }
    else if (v54)
    {
      v22 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v14 = gconnectionLogObj;
      v15 = type;
      v23 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v22)
      {
        if (v23)
        {
          v24 = *(_QWORD *)(a1 + 32);
          v25 = (const char *)(v24 + 378);
          v26 = v24 == 0;
          if (!v24)
            v25 = "";
          v27 = *(_DWORD *)(v24 + 368);
          if (v26)
            v28 = "";
          else
            v28 = " ";
          *(_DWORD *)buf = 136447490;
          v57 = "nw_protocol_http2_notify_block_invoke";
          v58 = 2082;
          v59 = (void *)v25;
          v60 = 2080;
          v61 = v28;
          v62 = 1024;
          v63 = v27;
          v64 = 2048;
          v65 = a2;
          v66 = 2082;
          v67 = v22;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(v22);
        goto LABEL_55;
      }
      if (!v23)
      {
LABEL_55:
        if (!v13)
          return 1;
        v39 = (char *)v13;
LABEL_57:
        free(v39);
        return 1;
      }
      v34 = *(_QWORD *)(a1 + 32);
      v35 = (const char *)(v34 + 378);
      v36 = v34 == 0;
      if (!v34)
        v35 = "";
      v37 = *(_DWORD *)(v34 + 368);
      if (v36)
        v38 = "";
      else
        v38 = " ";
      *(_DWORD *)buf = 136447234;
      v57 = "nw_protocol_http2_notify_block_invoke";
      v58 = 2082;
      v59 = (void *)v35;
      v60 = 2080;
      v61 = v38;
      v62 = 1024;
      v63 = v37;
      v64 = 2048;
      v65 = a2;
      v21 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v14 = gconnectionLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_55;
      v29 = *(_QWORD *)(a1 + 32);
      v30 = (const char *)(v29 + 378);
      v31 = v29 == 0;
      if (!v29)
        v30 = "";
      v32 = *(_DWORD *)(v29 + 368);
      if (v31)
        v33 = "";
      else
        v33 = " ";
      *(_DWORD *)buf = 136447234;
      v57 = "nw_protocol_http2_notify_block_invoke";
      v58 = 2082;
      v59 = (void *)v30;
      v60 = 2080;
      v61 = v33;
      v62 = 1024;
      v63 = v32;
      v64 = 2048;
      v65 = a2;
      v21 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v14, v15, v21, buf, 0x30u);
    goto LABEL_55;
  }
  v5 = *(_QWORD *)(v4 + 24);
  if (v5 && (v6 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(v5 + 160)) != 0)
  {
    v6(v4, *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 64), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  }
  else
  {
    v41 = *(_QWORD *)(a1 + 32);
    if (!v41 || (*(__int16 *)(v41 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v43 = *(_QWORD *)(a1 + 32);
        v44 = (const char *)(v43 + 378);
        v45 = "";
        v46 = v43 == 0;
        v47 = *(_DWORD *)(v43 + 368);
        v57 = "nw_protocol_http2_notify_block_invoke";
        if (v46)
          v44 = "";
        v58 = 2082;
        *(_DWORD *)buf = 136447234;
        if (!v46)
          v45 = " ";
        v59 = (void *)v44;
        v60 = 2080;
        v61 = v45;
        v62 = 1024;
        v63 = v47;
        v64 = 2048;
        v65 = v4;
        _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> notify callback not set on input handler %p, skipping notify", buf, 0x30u);
      }
    }
  }
  return 1;
}

void nw_http2_send_settings(uint64_t a1)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  int stream_receive_window_size;
  int v5;
  NSObject *v6;
  int v7;
  int v8;
  int connection_receive_window_size;
  NSObject *v10;
  int v11;
  int local_max_webtransport_sessions;
  int v13;
  uint64_t v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  uint64_t v29;
  const char *v30;
  char *v31;
  _BOOL4 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  int v37;
  NSObject *v38;
  int v39;
  NSObject *v40;
  int v41;
  NSObject *v42;
  int v43;
  char v44;
  os_log_type_t type;
  uint8_t v46[4];
  const char *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  int v53;
  _BYTE buf[24];
  __int128 v55;
  int v56;
  int v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v36 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v37 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http2_send_settings";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 378;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&v55 = " ";
      WORD4(v55) = 1024;
      *(_DWORD *)((char *)&v55 + 10) = v37;
      _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  v2 = nw_parameters_copy_protocol_options_legacy(*(void **)(a1 + 104), (nw_protocol *)a1);
  if (v2)
  {
    v3 = v2;
    stream_receive_window_size = nw_http2_get_stream_receive_window_size(v2);
    if (stream_receive_window_size)
    {
      v5 = stream_receive_window_size;
      if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v6 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v7 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_http2_send_settings";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 378;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&v55 = " ";
          WORD4(v55) = 1024;
          *(_DWORD *)((char *)&v55 + 10) = v7;
          HIWORD(v55) = 1024;
          v56 = v5;
          _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> overriding stream receive window size to %u", buf, 0x2Cu);
        }
      }
    }
    else
    {
      v5 = 0x200000;
    }
    connection_receive_window_size = nw_http2_get_connection_receive_window_size(v3);
    if (connection_receive_window_size)
    {
      v8 = connection_receive_window_size;
      if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v10 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v11 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_http2_send_settings";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 378;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&v55 = " ";
          WORD4(v55) = 1024;
          *(_DWORD *)((char *)&v55 + 10) = v11;
          HIWORD(v55) = 1024;
          v56 = v8;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> overriding connection receive window size to %u", buf, 0x2Cu);
        }
      }
    }
    else
    {
      v8 = 10485760;
    }
    local_max_webtransport_sessions = nw_http2_get_local_max_webtransport_sessions(v3);
    if (local_max_webtransport_sessions)
    {
      v13 = local_max_webtransport_sessions;
      if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v42 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v43 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_http2_send_settings";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 378;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&v55 = " ";
          WORD4(v55) = 1024;
          *(_DWORD *)((char *)&v55 + 10) = v43;
          HIWORD(v55) = 1024;
          v56 = v13;
          _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> setting max webtransport sessions to %u", buf, 0x2Cu);
        }
      }
      os_release(v3);
      *(_OWORD *)buf = xmmword_183C6F210;
      *(_DWORD *)&buf[16] = 4;
      *(_DWORD *)&buf[20] = v5;
      v55 = xmmword_183C6F220;
      v56 = 11104;
      v57 = v13;
    }
    else
    {
      os_release(v3);
      *(_OWORD *)buf = xmmword_183C6F210;
      *(_DWORD *)&buf[16] = 4;
      *(_DWORD *)&buf[20] = v5;
      v55 = xmmword_183C6F220;
    }
  }
  else
  {
    *(_OWORD *)buf = xmmword_183C6F210;
    *(_QWORD *)&buf[16] = 0x20000000000004;
    v55 = xmmword_183C6F220;
    v8 = 10485760;
  }
  if (nghttp2_submit_settings())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = nghttp2_strerror();
    *(_DWORD *)v46 = 136446466;
    v47 = "nw_http2_send_settings";
    v48 = 2082;
    v49 = v14;
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v15, &type, &v44))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_41;
      v18 = nghttp2_strerror();
      *(_DWORD *)v46 = 136446466;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = v18;
      v19 = "%{public}s nghttp2_submit_settings: %{public}s failed";
    }
    else if (v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v21)
        {
          v22 = nghttp2_strerror();
          *(_DWORD *)v46 = 136446722;
          v47 = "nw_http2_send_settings";
          v48 = 2082;
          v49 = v22;
          v50 = 2082;
          v51 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s nghttp2_submit_settings: %{public}s failed, dumping backtrace:%{public}s", v46, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_41;
      }
      if (!v21)
      {
LABEL_41:
        if (v15)
          free(v15);
        goto LABEL_43;
      }
      v24 = nghttp2_strerror();
      *(_DWORD *)v46 = 136446466;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = v24;
      v19 = "%{public}s nghttp2_submit_settings: %{public}s failed, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_41;
      v23 = nghttp2_strerror();
      *(_DWORD *)v46 = 136446466;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = v23;
      v19 = "%{public}s nghttp2_submit_settings: %{public}s failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v16, v17, v19, v46, 0x16u);
    goto LABEL_41;
  }
LABEL_43:
  if (v8 == 0xFFFF || !nghttp2_session_set_local_window_size())
    goto LABEL_61;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = nghttp2_strerror();
  *(_DWORD *)v46 = 136446466;
  v47 = "nw_http2_send_settings";
  v48 = 2082;
  v49 = v25;
  v26 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v44 = 0;
  if (__nwlog_fault(v26, &type, &v44))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = gLogObj;
      v28 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_59;
      v29 = nghttp2_strerror();
      *(_DWORD *)v46 = 136446466;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = v29;
      v30 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed";
      goto LABEL_58;
    }
    if (!v44)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = gLogObj;
      v28 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_59;
      v34 = nghttp2_strerror();
      *(_DWORD *)v46 = 136446466;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = v34;
      v30 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, backtrace limit exceeded";
      goto LABEL_58;
    }
    v31 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v27 = gLogObj;
    v28 = type;
    v32 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v31)
    {
      if (v32)
      {
        v33 = nghttp2_strerror();
        *(_DWORD *)v46 = 136446722;
        v47 = "nw_http2_send_settings";
        v48 = 2082;
        v49 = v33;
        v50 = 2082;
        v51 = v31;
        _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, dumping backtrace:%{public}s", v46, 0x20u);
      }
      free(v31);
      goto LABEL_59;
    }
    if (v32)
    {
      v35 = nghttp2_strerror();
      *(_DWORD *)v46 = 136446466;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = v35;
      v30 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, no backtrace";
LABEL_58:
      _os_log_impl(&dword_182FBE000, v27, v28, v30, v46, 0x16u);
    }
  }
LABEL_59:
  if (v26)
    free(v26);
LABEL_61:
  if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v38 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v39 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)v46 = 136446978;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = a1 + 378;
      v50 = 2080;
      v51 = " ";
      v52 = 1024;
      v53 = v39;
      _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> submitted settings to nghttp2", v46, 0x26u);
    }
  }
  nw_http2_session_send(a1);
  if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v40 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v41 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)v46 = 136446978;
      v47 = "nw_http2_send_settings";
      v48 = 2082;
      v49 = a1 + 378;
      v50 = 2080;
      v51 = " ";
      v52 = 1024;
      v53 = v41;
      _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> nghttp2_session_send complete with settings", v46, 0x26u);
    }
  }
}

void nw_protocol_http2_process_input(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  os_log_type_t v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *backtrace_string;
  NSObject *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  os_log_type_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  NSObject *v32;
  int v33;
  NSObject *v34;
  NSObject *v35;
  int v36;
  NSObject *v37;
  int v38;
  int v39;
  int v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  int v44;
  const char *v45;
  char *v46;
  _BOOL4 v47;
  int v48;
  int v49;
  int v50;
  NSObject *v51;
  int v52;
  NSObject *v53;
  int v54;
  _QWORD v55[5];
  char v56;
  _QWORD v57[2];
  uint64_t (*v58)(uint64_t, uint64_t);
  void *v59;
  os_log_type_t *v60;
  uint64_t v61;
  os_log_type_t type[8];
  os_log_type_t *v63;
  uint64_t v64;
  int v65;
  os_log_type_t v66;
  _QWORD v67[2];
  _BYTE buf[24];
  const char *v69;
  _QWORD *v70;
  char *v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v51 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v52 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 378;
      *(_WORD *)&buf[22] = 2080;
      v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v52;
      _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  *(_WORD *)(a1 + 376) |= 0x200u;
  v2 = MEMORY[0x1E0C809B0];
  while (1)
  {
    v67[0] = 0;
    v67[1] = v67;
    v3 = *(_QWORD *)(a1 + 32);
    if (!v3)
      break;
    v4 = *(_QWORD *)(v3 + 24);
    if (!v4)
      break;
    v5 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 80);
    if (!v5)
      break;
    v6 = v5(v3, a1);
    if (!v6)
      goto LABEL_78;
    v7 = v6;
    if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v35 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v36 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 378;
        *(_WORD *)&buf[22] = 2080;
        v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v36;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v7;
        _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received %u frames from output_handler", buf, 0x2Cu);
      }
    }
    *(_QWORD *)type = 0;
    v63 = type;
    v65 = 0;
    v64 = 0x2000000000;
    v57[0] = v2;
    v57[1] = 0x40000000;
    v58 = ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke;
    v59 = &unk_1E14AB9F8;
    v60 = type;
    v61 = a1;
    v8 = v67[0];
    do
    {
      if (!v8)
        break;
      v9 = *(_QWORD *)(v8 + 32);
      v10 = ((uint64_t (*)(_QWORD *))v58)(v57);
      v8 = v9;
    }
    while ((v10 & 1) != 0);
    if (nghttp2_session_consume_connection())
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v11;
      v12 = (char *)_os_log_send_and_compose_impl();
      v66 = OS_LOG_TYPE_ERROR;
      v56 = 0;
      if (!__nwlog_fault(v12, &v66, &v56))
        goto LABEL_29;
      if (v66 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = v66;
        if (os_log_type_enabled((os_log_t)gLogObj, v66))
        {
          v15 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v15;
          v16 = v13;
          v17 = v14;
          v18 = "%{public}s nghttp2_session_consume_connection: %{public}s failed";
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      if (v56)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        v21 = v66;
        v22 = os_log_type_enabled((os_log_t)gLogObj, v66);
        if (backtrace_string)
        {
          if (v22)
          {
            v23 = nghttp2_strerror();
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v23;
            *(_WORD *)&buf[22] = 2082;
            v69 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s nghttp2_session_consume_connection: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_29;
        }
        if (!v22)
        {
LABEL_29:
          if (v12)
            free(v12);
          goto LABEL_31;
        }
        v27 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v27;
        v16 = v20;
        v17 = v21;
        v18 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = gLogObj;
        v25 = v66;
        if (!os_log_type_enabled((os_log_t)gLogObj, v66))
          goto LABEL_29;
        v26 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v26;
        v16 = v24;
        v17 = v25;
        v18 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, backtrace limit exceeded";
      }
LABEL_28:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0x16u);
      goto LABEL_29;
    }
LABEL_31:
    if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v37 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v38 = *(_DWORD *)(a1 + 368);
        v39 = *((_DWORD *)v63 + 6);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 378;
        *(_WORD *)&buf[22] = 2080;
        v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v38;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v39;
        _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> consumed %u bytes on connection", buf, 0x2Cu);
      }
    }
    v28 = *(char **)(a1 + 152);
    v55[0] = v2;
    v55[1] = 0x40000000;
    v55[2] = ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke_48;
    v55[3] = &__block_descriptor_tmp_49_82424;
    v55[4] = a1;
    nw_hash_table_apply(v28, (uint64_t)v55);
    if (gLogDatapath)
    {
      v34 = __nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }
    *(_QWORD *)buf = v2;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_81659;
    v69 = (const char *)&__block_descriptor_tmp_30_81660;
    v70 = v67;
    LOBYTE(v71) = 1;
    v29 = v67[0];
    do
    {
      if (!v29)
        break;
      v30 = *(_QWORD *)(v29 + 32);
      v31 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      v29 = v30;
    }
    while ((v31 & 1) != 0);
    if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v32 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v33 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 378;
        *(_WORD *)&buf[22] = 2080;
        v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v33;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v7;
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> processed %u frames", buf, 0x2Cu);
      }
    }
    _Block_object_dispose(type, 8);
  }
  if (*(__int16 *)(a1 + 376) < 0)
    goto LABEL_80;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v40 = *(_DWORD *)(a1 + 368);
  *(_DWORD *)buf = 136446978;
  *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = a1 + 378;
  *(_WORD *)&buf[22] = 2080;
  v69 = " ";
  LOWORD(v70) = 1024;
  *(_DWORD *)((char *)&v70 + 2) = v40;
  v41 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v66 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v41, type, &v66))
    goto LABEL_76;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v42 = gconnectionLogObj;
    v43 = type[0];
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
    {
      v44 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 378;
      *(_WORD *)&buf[22] = 2080;
      v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v44;
      v45 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback";
      goto LABEL_75;
    }
    goto LABEL_76;
  }
  if (v66 == OS_LOG_TYPE_DEFAULT)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v42 = gconnectionLogObj;
    v43 = type[0];
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
      goto LABEL_76;
    v49 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 378;
    *(_WORD *)&buf[22] = 2080;
    v69 = " ";
    LOWORD(v70) = 1024;
    *(_DWORD *)((char *)&v70 + 2) = v49;
    v45 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, backtrace limit exceeded";
    goto LABEL_75;
  }
  v46 = (char *)__nw_create_backtrace_string();
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v42 = gconnectionLogObj;
  v43 = type[0];
  v47 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
  if (v46)
  {
    if (v47)
    {
      v48 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 378;
      *(_WORD *)&buf[22] = 2080;
      v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v48;
      HIWORD(v70) = 2082;
      v71 = v46;
      _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, dumping backtrace:%{public}s", buf, 0x30u);
    }
    free(v46);
    goto LABEL_76;
  }
  if (v47)
  {
    v50 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 378;
    *(_WORD *)&buf[22] = 2080;
    v69 = " ";
    LOWORD(v70) = 1024;
    *(_DWORD *)((char *)&v70 + 2) = v50;
    v45 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, no backtrace";
LABEL_75:
    _os_log_impl(&dword_182FBE000, v42, v43, v45, buf, 0x26u);
  }
LABEL_76:
  if (v41)
    free(v41);
LABEL_78:
  if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v53 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v54 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 378;
      *(_WORD *)&buf[22] = 2080;
      v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v54;
      _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> about to allow http2 to send pending data", buf, 0x26u);
    }
  }
LABEL_80:
  *(_WORD *)(a1 + 376) &= ~0x200u;
  nw_http2_session_send(a1);
}

uint64_t ___ZL35nw_protocol_http2_process_connectedP17nw_protocol_http2_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t object;
  NSObject *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  BOOL v13;
  int v14;
  const char *v15;
  const char *v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v19;
  const char *v20;
  BOOL v21;
  int v22;
  const char *v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  uint64_t v27;
  const char *v28;
  BOOL v29;
  int v30;
  const char *v31;
  int v32;
  int v33;
  const char *v34;
  NSObject *v35;
  os_log_type_t v36;
  int v37;
  int v38;
  const char *v39;
  uint64_t v40;
  const char *v41;
  BOOL v42;
  int v43;
  const char *v44;
  char *v45;
  _BOOL4 v46;
  int v47;
  int v48;
  uint64_t v49;
  const char *v50;
  BOOL v51;
  int v52;
  const char *v53;
  char *v54;
  int v55;
  int v56;
  int v57;
  int v58;
  NSObject *v60;
  int v61;
  int v62;
  NSObject *v63;
  int v64;
  int v65;
  char v66;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  int v75;
  __int16 v76;
  _BYTE v77[24];
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)nw_hash_node_get_extra(a2);
  if (!v4)
  {
    v10 = *(_QWORD *)(a1 + 32);
    if (v10 && *(__int16 *)(v10 + 376) < 0)
      return 1;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v11 = *(_QWORD *)(a1 + 32);
    v12 = (const char *)(v11 + 378);
    v13 = v11 == 0;
    v14 = *(_DWORD *)(v11 + 368);
    if (v13)
      v12 = "";
    *(_DWORD *)buf = 136447234;
    v69 = "nw_protocol_http2_process_connected_block_invoke";
    if (v13)
      v15 = "";
    else
      v15 = " ";
    v70 = 2082;
    v71 = v12;
    v72 = 2080;
    v73 = v15;
    v74 = 1024;
    v75 = v14;
    v76 = 2048;
    *(_QWORD *)v77 = a2;
    v16 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (!__nwlog_fault(v16, &type, &v66))
      goto LABEL_79;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = gconnectionLogObj;
      v18 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_79;
      v19 = *(_QWORD *)(a1 + 32);
      v20 = (const char *)(v19 + 378);
      v21 = v19 == 0;
      if (!v19)
        v20 = "";
      v22 = *(_DWORD *)(v19 + 368);
      if (v21)
        v23 = "";
      else
        v23 = " ";
      *(_DWORD *)buf = 136447234;
      v69 = "nw_protocol_http2_process_connected_block_invoke";
      v70 = 2082;
      v71 = v20;
      v72 = 2080;
      v73 = v23;
      v74 = 1024;
      v75 = v22;
      v76 = 2048;
      *(_QWORD *)v77 = a2;
      v24 = "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra";
    }
    else if (v66)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = gconnectionLogObj;
      v18 = type;
      v26 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (backtrace_string)
      {
        if (v26)
        {
          v27 = *(_QWORD *)(a1 + 32);
          v28 = (const char *)(v27 + 378);
          v29 = v27 == 0;
          if (!v27)
            v28 = "";
          v30 = *(_DWORD *)(v27 + 368);
          if (v29)
            v31 = "";
          else
            v31 = " ";
          *(_DWORD *)buf = 136447490;
          v69 = "nw_protocol_http2_process_connected_block_invoke";
          v70 = 2082;
          v71 = v28;
          v72 = 2080;
          v73 = v31;
          v74 = 1024;
          v75 = v30;
          v76 = 2048;
          *(_QWORD *)v77 = a2;
          *(_WORD *)&v77[8] = 2082;
          *(_QWORD *)&v77[10] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(backtrace_string);
        goto LABEL_79;
      }
      if (!v26)
      {
LABEL_79:
        if (!v16)
          return 1;
        v54 = (char *)v16;
LABEL_90:
        free(v54);
        return 1;
      }
      v49 = *(_QWORD *)(a1 + 32);
      v50 = (const char *)(v49 + 378);
      v51 = v49 == 0;
      if (!v49)
        v50 = "";
      v52 = *(_DWORD *)(v49 + 368);
      if (v51)
        v53 = "";
      else
        v53 = " ";
      *(_DWORD *)buf = 136447234;
      v69 = "nw_protocol_http2_process_connected_block_invoke";
      v70 = 2082;
      v71 = v50;
      v72 = 2080;
      v73 = v53;
      v74 = 1024;
      v75 = v52;
      v76 = 2048;
      *(_QWORD *)v77 = a2;
      v24 = "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = gconnectionLogObj;
      v18 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_79;
      v40 = *(_QWORD *)(a1 + 32);
      v41 = (const char *)(v40 + 378);
      v42 = v40 == 0;
      if (!v40)
        v41 = "";
      v43 = *(_DWORD *)(v40 + 368);
      if (v42)
        v44 = "";
      else
        v44 = " ";
      *(_DWORD *)buf = 136447234;
      v69 = "nw_protocol_http2_process_connected_block_invoke";
      v70 = 2082;
      v71 = v41;
      v72 = 2080;
      v73 = v44;
      v74 = 1024;
      v75 = v43;
      v76 = 2048;
      *(_QWORD *)v77 = a2;
      v24 = "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v17, v18, v24, buf, 0x30u);
    goto LABEL_79;
  }
  if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v60 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v62 = *(_DWORD *)(v4 + 176);
      v61 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_http2_process_connected_block_invoke";
      v70 = 2082;
      v71 = (const char *)(v4 + 191);
      v72 = 2080;
      v73 = " ";
      v74 = 1024;
      v75 = v61;
      v76 = 1024;
      *(_DWORD *)v77 = v62;
      *(_WORD *)&v77[4] = 1024;
      *(_DWORD *)&v77[6] = v62;
      _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> checking existing stream %d to see if waiting_for_connect", buf, 0x32u);
    }
  }
  v5 = *(unsigned __int16 *)(v4 + 188);
  if ((v5 & 8) != 0)
  {
    if (((v5 | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v63 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v65 = *(_DWORD *)(v4 + 176);
        v64 = *(_DWORD *)(v4 + 180);
        *(_DWORD *)buf = 136447490;
        v69 = "nw_protocol_http2_process_connected_block_invoke";
        v70 = 2082;
        v71 = (const char *)(v4 + 191);
        v72 = 2080;
        v73 = " ";
        v74 = 1024;
        v75 = v64;
        v76 = 1024;
        *(_DWORD *)v77 = v65;
        *(_WORD *)&v77[4] = 1024;
        *(_DWORD *)&v77[6] = v65;
        _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> calling connect on waiting stream %d", buf, 0x32u);
      }
    }
    object = nw_hash_node_get_object(a2);
    if (object)
    {
      if (!nw_http2_stream_connect(*(_QWORD *)(a1 + 32), v4, object)
        && ((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v7 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v9 = *(_DWORD *)(v4 + 176);
          v8 = *(_DWORD *)(v4 + 180);
          *(_DWORD *)buf = 136447746;
          v69 = "nw_protocol_http2_process_connected_block_invoke";
          v70 = 2082;
          v71 = (const char *)(v4 + 191);
          v72 = 2080;
          v73 = " ";
          v74 = 1024;
          v75 = v8;
          v76 = 1024;
          *(_DWORD *)v77 = v9;
          *(_WORD *)&v77[4] = 1024;
          *(_DWORD *)&v77[6] = v9;
          *(_WORD *)&v77[10] = 2048;
          *(_QWORD *)&v77[12] = v4;
          _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> nw_http2_stream_connect failed for stream id %d (%p)", buf, 0x3Cu);
        }
      }
      return 1;
    }
    if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) != 0)
      return 1;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v33 = *(_DWORD *)(v4 + 176);
    v32 = *(_DWORD *)(v4 + 180);
    *(_DWORD *)buf = 136447490;
    v69 = "nw_protocol_http2_process_connected_block_invoke";
    v70 = 2082;
    v71 = (const char *)(v4 + 191);
    v72 = 2080;
    v73 = " ";
    v74 = 1024;
    v75 = v32;
    v76 = 1024;
    *(_DWORD *)v77 = v33;
    *(_WORD *)&v77[4] = 2048;
    *(_QWORD *)&v77[6] = a2;
    v34 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (!__nwlog_fault(v34, &type, &v66))
      goto LABEL_88;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v35 = gconnectionLogObj;
      v36 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_88;
      v38 = *(_DWORD *)(v4 + 176);
      v37 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_http2_process_connected_block_invoke";
      v70 = 2082;
      v71 = (const char *)(v4 + 191);
      v72 = 2080;
      v73 = " ";
      v74 = 1024;
      v75 = v37;
      v76 = 1024;
      *(_DWORD *)v77 = v38;
      *(_WORD *)&v77[4] = 2048;
      *(_QWORD *)&v77[6] = a2;
      v39 = "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object";
    }
    else if (v66)
    {
      v45 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v35 = gconnectionLogObj;
      v36 = type;
      v46 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v45)
      {
        if (v46)
        {
          v48 = *(_DWORD *)(v4 + 176);
          v47 = *(_DWORD *)(v4 + 180);
          *(_DWORD *)buf = 136447746;
          v69 = "nw_protocol_http2_process_connected_block_invoke";
          v70 = 2082;
          v71 = (const char *)(v4 + 191);
          v72 = 2080;
          v73 = " ";
          v74 = 1024;
          v75 = v47;
          v76 = 1024;
          *(_DWORD *)v77 = v48;
          *(_WORD *)&v77[4] = 2048;
          *(_QWORD *)&v77[6] = a2;
          *(_WORD *)&v77[14] = 2082;
          *(_QWORD *)&v77[16] = v45;
          _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object, dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(v45);
        goto LABEL_88;
      }
      if (!v46)
      {
LABEL_88:
        if (!v34)
          return 1;
        v54 = (char *)v34;
        goto LABEL_90;
      }
      v58 = *(_DWORD *)(v4 + 176);
      v57 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_http2_process_connected_block_invoke";
      v70 = 2082;
      v71 = (const char *)(v4 + 191);
      v72 = 2080;
      v73 = " ";
      v74 = 1024;
      v75 = v57;
      v76 = 1024;
      *(_DWORD *)v77 = v58;
      *(_WORD *)&v77[4] = 2048;
      *(_QWORD *)&v77[6] = a2;
      v39 = "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v35 = gconnectionLogObj;
      v36 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_88;
      v56 = *(_DWORD *)(v4 + 176);
      v55 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_http2_process_connected_block_invoke";
      v70 = 2082;
      v71 = (const char *)(v4 + 191);
      v72 = 2080;
      v73 = " ";
      v74 = 1024;
      v75 = v55;
      v76 = 1024;
      *(_DWORD *)v77 = v56;
      *(_WORD *)&v77[4] = 2048;
      *(_QWORD *)&v77[6] = a2;
      v39 = "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v35, v36, v39, buf, 0x36u);
    goto LABEL_88;
  }
  return 1;
}

BOOL nw_http2_stream_connect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  void *v11;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t);
  const char *v14;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  const char *v26;
  NSObject *v27;
  int v28;
  int v29;
  char *backtrace_string;
  _BOOL4 v31;
  NSObject *v32;
  int v33;
  int v34;
  NSObject *v35;
  int v36;
  int v37;
  char *v38;
  _BOOL4 v39;
  const char *v40;
  char *v41;
  _BOOL4 v42;
  const char *v43;
  const char *v44;
  char *v45;
  const char *v46;
  _QWORD v47[6];
  char v48;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  void *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  __int16 v62;
  uint64_t v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_http2_stream_connect";
    v22 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v22, &type, &v48))
      goto LABEL_87;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http2_stream_connect";
      v25 = "%{public}s called with null http2";
    }
    else if (v48)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v31 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_http2_stream_connect";
          v52 = 2082;
          v53 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_87:
        if (v22)
        {
          v45 = (char *)v22;
LABEL_100:
          free(v45);
          return a1 != 0;
        }
        return a1 != 0;
      }
      if (!v31)
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http2_stream_connect";
      v25 = "%{public}s called with null http2, no backtrace";
    }
    else
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http2_stream_connect";
      v25 = "%{public}s called with null http2, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0xCu);
    goto LABEL_87;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v27 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v29 = *(_DWORD *)(a2 + 176);
      v28 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447746;
      v51 = "nw_http2_stream_connect";
      v52 = 2082;
      v53 = (void *)(a2 + 191);
      v54 = 2080;
      v55 = " ";
      v56 = 1024;
      v57 = v28;
      v58 = 1024;
      v59 = v29;
      v60 = 1024;
      v61 = v29;
      v62 = 2048;
      v63 = a2;
      _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d (%p)", buf, 0x3Cu);
    }
  }
  v6 = *(unsigned __int16 *)(a2 + 188);
  v7 = v6 | (*(unsigned __int8 *)(a2 + 190) << 16);
  if ((v6 & 1) == 0)
  {
    if (!*(_QWORD *)(a2 + 32))
    {
      v8 = mach_continuous_approximate_time();
      if (v8 <= 1)
        v9 = 1;
      else
        v9 = v8;
      *(_QWORD *)(a2 + 32) = v9;
      v7 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
    }
    v10 = v7 & 0xFFEFFFF6 | 0x100001;
    *(_WORD *)(a2 + 188) = v10;
    *(_BYTE *)(a2 + 190) = BYTE2(v10);
    v11 = *(void **)(a2 + 96);
    v47[0] = MEMORY[0x1E0C809B0];
    v47[1] = 0x40000000;
    v47[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke;
    v47[3] = &__block_descriptor_tmp_45_82378;
    v47[4] = a2;
    v47[5] = a1;
    nw_http_transaction_metadata_set_event_handler(v11, v47);
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v32 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v34 = *(_DWORD *)(a2 + 176);
        v33 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        v51 = "nw_http2_stream_connect";
        v52 = 2082;
        v53 = (void *)(a2 + 191);
        v54 = 2080;
        v55 = " ";
        v56 = 1024;
        v57 = v33;
        v58 = 1024;
        v59 = v34;
        v60 = 1024;
        v61 = v34;
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> connect complete for stream %d, calling connected", buf, 0x32u);
      }
    }
    v12 = *(_QWORD *)(a3 + 24);
    if (!v12 || (v13 = *(void (**)(uint64_t, uint64_t))(v12 + 40)) == 0)
    {
      __nwlog_obj();
      v14 = *(const char **)(a3 + 16);
      if (!v14)
        v14 = "invalid";
      *(_DWORD *)buf = 136446466;
      v51 = "nw_http2_stream_connect";
      v52 = 2082;
      v53 = (void *)v14;
      v15 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (__nwlog_fault(v15, &type, &v48))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (!os_log_type_enabled(v16, type))
            goto LABEL_98;
          v18 = *(const char **)(a3 + 16);
          if (!v18)
            v18 = "invalid";
LABEL_21:
          *(_DWORD *)buf = 136446466;
          v51 = "nw_http2_stream_connect";
          v52 = 2082;
          v53 = (void *)v18;
          v19 = "%{public}s protocol %{public}s has invalid connected callback";
LABEL_97:
          _os_log_impl(&dword_182FBE000, v16, v17, v19, buf, 0x16u);
          goto LABEL_98;
        }
        if (v48)
        {
          v38 = (char *)__nw_create_backtrace_string();
          v16 = __nwlog_obj();
          v17 = type;
          v39 = os_log_type_enabled(v16, type);
          if (v38)
          {
            if (v39)
            {
              if (*(_QWORD *)(a3 + 16))
                v40 = *(const char **)(a3 + 16);
              else
                v40 = "invalid";
              *(_DWORD *)buf = 136446722;
              v51 = "nw_http2_stream_connect";
              v52 = 2082;
              v53 = (void *)v40;
              v54 = 2082;
              v55 = v38;
              _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v38);
            goto LABEL_98;
          }
          if (!v39)
            goto LABEL_98;
          v46 = *(const char **)(a3 + 16);
          if (!v46)
            v46 = "invalid";
LABEL_96:
          *(_DWORD *)buf = 136446466;
          v51 = "nw_http2_stream_connect";
          v52 = 2082;
          v53 = (void *)v46;
          v19 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
          goto LABEL_97;
        }
        v16 = __nwlog_obj();
        v17 = type;
        if (!os_log_type_enabled(v16, type))
          goto LABEL_98;
        v44 = *(const char **)(a3 + 16);
        if (!v44)
          v44 = "invalid";
LABEL_79:
        *(_DWORD *)buf = 136446466;
        v51 = "nw_http2_stream_connect";
        v52 = 2082;
        v53 = (void *)v44;
        v19 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_97;
      }
      goto LABEL_98;
    }
LABEL_26:
    v13(a3, a1);
    return a1 != 0;
  }
  if ((v7 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v35 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v37 = *(_DWORD *)(a2 + 176);
      v36 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v51 = "nw_http2_stream_connect";
      v52 = 2082;
      v53 = (void *)(a2 + 191);
      v54 = 2080;
      v55 = " ";
      v56 = 1024;
      v57 = v36;
      v58 = 1024;
      v59 = v37;
      v60 = 1024;
      v61 = v37;
      _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream %d is already connected", buf, 0x32u);
    }
  }
  v20 = *(_QWORD *)(a3 + 24);
  if (v20)
  {
    v13 = *(void (**)(uint64_t, uint64_t))(v20 + 40);
    if (v13)
      goto LABEL_26;
  }
  __nwlog_obj();
  v26 = *(const char **)(a3 + 16);
  if (!v26)
    v26 = "invalid";
  *(_DWORD *)buf = 136446466;
  v51 = "nw_http2_stream_connect";
  v52 = 2082;
  v53 = (void *)v26;
  v15 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (__nwlog_fault(v15, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_98;
      v18 = *(const char **)(a3 + 16);
      if (!v18)
        v18 = "invalid";
      goto LABEL_21;
    }
    if (!v48)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_98;
      v44 = *(const char **)(a3 + 16);
      if (!v44)
        v44 = "invalid";
      goto LABEL_79;
    }
    v41 = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v42 = os_log_type_enabled(v16, type);
    if (v41)
    {
      if (v42)
      {
        if (*(_QWORD *)(a3 + 16))
          v43 = *(const char **)(a3 + 16);
        else
          v43 = "invalid";
        *(_DWORD *)buf = 136446722;
        v51 = "nw_http2_stream_connect";
        v52 = 2082;
        v53 = (void *)v43;
        v54 = 2082;
        v55 = v41;
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v41);
      if (v15)
        goto LABEL_99;
      return a1 != 0;
    }
    if (v42)
    {
      v46 = *(const char **)(a3 + 16);
      if (!v46)
        v46 = "invalid";
      goto LABEL_96;
    }
  }
LABEL_98:
  if (v15)
  {
LABEL_99:
    v45 = (char *)v15;
    goto LABEL_100;
  }
  return a1 != 0;
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke(uint64_t a1, void *a2, int a3)
{
  id outbound_message;
  id v6;
  id v7;
  id v8;
  _QWORD *v9;
  id v10;
  int status_code;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  BOOL v17;
  int v18;
  int v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  id v23;
  void *v24;
  id v25;
  id v26;
  id inbound_message;
  uint64_t outbound_body_size;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  BOOL v34;
  int v35;
  int v36;
  uint64_t v37;
  const char *v38;
  id v39;
  id v40;
  _QWORD *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  const char *v46;
  BOOL v47;
  int v48;
  int v49;
  uint64_t v50;
  NSObject *v51;
  uint32_t v52;
  void *v53;
  uint64_t inbound_body_size;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  const char *v58;
  BOOL v59;
  int v60;
  int v61;
  uint64_t v62;
  id v63;
  int v64;
  id v65;
  _QWORD *v66;
  uint64_t v67;
  NSObject *v68;
  uint64_t v69;
  const char *v70;
  const char *v71;
  BOOL v72;
  int v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  const char *v77;
  const char *v78;
  BOOL v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const char *v84;
  BOOL v85;
  int v86;
  const char *v87;
  uint64_t v88;
  uint64_t v89;
  const char *v90;
  BOOL v91;
  int v92;
  const char *v93;
  _QWORD v94[5];
  __int16 v95;
  _QWORD v96[5];
  __int128 v97;
  _QWORD v98[4];
  __int128 v99;
  _QWORD v100[4];
  __int128 v101;
  uint8_t buf[4];
  const char *v103;
  __int16 v104;
  const char *v105;
  __int16 v106;
  const char *v107;
  __int16 v108;
  int v109;
  __int16 v110;
  _QWORD v111[3];

  v111[2] = *MEMORY[0x1E0C80C00];
  switch(a3)
  {
    case 0:
      outbound_message = nw_http_transaction_metadata_get_outbound_message(a2);
      v6 = nw_http_metadata_copy_request(outbound_message);
      v7 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v100[0] = MEMORY[0x1E0C809B0];
        v100[1] = 0x40000000;
        v100[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_2;
        v100[3] = &__block_descriptor_tmp_36_82386;
        v101 = *(_OWORD *)(a1 + 32);
        v8 = v6;
        v9 = v100;
        _nw_http_request_access_method((uint64_t)v8, v9);

      }
      if (!v7)
        goto LABEL_46;
      v10 = v7;
      status_code = _nw_http_response_get_status_code();

      v12 = *(_QWORD *)(a1 + 32);
      if (v12)
      {
        if (((*(unsigned __int16 *)(v12 + 188) | (*(unsigned __int8 *)(v12 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v13 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v14 = *(_QWORD *)(a1 + 32);
            v15 = (const char *)(v14 + 191);
            v16 = "";
            v17 = v14 == 0;
            if (!v14)
              v15 = "";
            v20 = v14 + 176;
            v18 = *(_DWORD *)(v14 + 176);
            v19 = *(_DWORD *)(v20 + 4);
            if (!v17)
              v16 = " ";
            *(_DWORD *)buf = 136447490;
            v103 = "nw_http2_stream_connect_block_invoke";
            v104 = 2082;
            v105 = v15;
            v106 = 2080;
            v107 = v16;
            v108 = 1024;
            v109 = v19;
            v110 = 1024;
            LODWORD(v111[0]) = v18;
            WORD2(v111[0]) = 1024;
            *(_DWORD *)((char *)v111 + 6) = status_code;
            v21 = "%{public}s %{public}s%s<i%u:s%d> [http] sending response header {status=%hu}";
            goto LABEL_43;
          }
        }
      }
      else
      {
        v81 = *(_QWORD *)(a1 + 40);
        if (!v81 || (*(__int16 *)(v81 + 376) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v82 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v83 = *(_QWORD *)(a1 + 40);
            v84 = "";
            v85 = v83 == 0;
            v86 = *(_DWORD *)(v83 + 368);
            v87 = (const char *)(v83 + 378);
            v103 = "nw_http2_stream_connect_block_invoke";
            v104 = 2082;
            if (v85)
              v87 = "";
            *(_DWORD *)buf = 136447234;
            if (!v85)
              v84 = " ";
            v105 = v87;
            v106 = 2080;
            v107 = v84;
            v108 = 1024;
            v109 = v86;
            v110 = 1024;
            LODWORD(v111[0]) = status_code;
            v21 = "%{public}s %{public}s%s<i%u> [http] sending response header {status=%hu}";
            goto LABEL_123;
          }
        }
      }
      goto LABEL_45;
    case 1:
      outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(a2);
      v29 = *(_QWORD *)(a1 + 32);
      if (v29)
      {
        if (((*(unsigned __int16 *)(v29 + 188) | (*(unsigned __int8 *)(v29 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v30 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v31 = *(_QWORD *)(a1 + 32);
            v32 = (const char *)(v31 + 191);
            v33 = "";
            v34 = v31 == 0;
            if (!v31)
              v32 = "";
            v37 = v31 + 176;
            v35 = *(_DWORD *)(v31 + 176);
            v36 = *(_DWORD *)(v37 + 4);
            if (!v34)
              v33 = " ";
            *(_DWORD *)buf = 136447490;
            v103 = "nw_http2_stream_connect_block_invoke";
            v104 = 2082;
            v105 = v32;
            v106 = 2080;
            v107 = v33;
            v108 = 1024;
            v109 = v36;
            v110 = 1024;
            LODWORD(v111[0]) = v35;
            WORD2(v111[0]) = 2048;
            *(_QWORD *)((char *)v111 + 6) = outbound_body_size;
            v38 = "%{public}s %{public}s%s<i%u:s%d> [http] finished sending {body_bytes=%llu}";
            goto LABEL_60;
          }
        }
      }
      else
      {
        v67 = *(_QWORD *)(a1 + 40);
        if (!v67 || (*(__int16 *)(v67 + 376) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v68 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v69 = *(_QWORD *)(a1 + 40);
            v70 = (const char *)(v69 + 378);
            v71 = "";
            v72 = v69 == 0;
            v73 = *(_DWORD *)(v69 + 368);
            v103 = "nw_http2_stream_connect_block_invoke";
            if (v72)
              v70 = "";
            v104 = 2082;
            *(_DWORD *)buf = 136447234;
            if (!v72)
              v71 = " ";
            v105 = v70;
            v106 = 2080;
            v107 = v71;
            v108 = 1024;
            v109 = v73;
            v110 = 2048;
            v111[0] = outbound_body_size;
            v74 = "%{public}s %{public}s%s<i%u> [http] finished sending {body_bytes=%llu}";
            goto LABEL_102;
          }
        }
      }
      return;
    case 2:
      outbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
      v6 = nw_http_metadata_copy_request(outbound_message);
      v39 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v98[0] = MEMORY[0x1E0C809B0];
        v98[1] = 0x40000000;
        v98[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_37;
        v98[3] = &__block_descriptor_tmp_38_82391;
        v99 = *(_OWORD *)(a1 + 32);
        v40 = v6;
        v41 = v98;
        _nw_http_request_access_method((uint64_t)v40, v41);

      }
      if (!v39)
        goto LABEL_46;
      v10 = v39;
      v42 = _nw_http_response_get_status_code();

      v43 = *(_QWORD *)(a1 + 32);
      if (v43)
      {
        if (((*(unsigned __int16 *)(v43 + 188) | (*(unsigned __int8 *)(v43 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v13 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v44 = *(_QWORD *)(a1 + 32);
            v45 = (const char *)(v44 + 191);
            v46 = "";
            v47 = v44 == 0;
            if (!v44)
              v45 = "";
            v50 = v44 + 176;
            v48 = *(_DWORD *)(v44 + 176);
            v49 = *(_DWORD *)(v50 + 4);
            if (!v47)
              v46 = " ";
            *(_DWORD *)buf = 136447490;
            v103 = "nw_http2_stream_connect_block_invoke";
            v104 = 2082;
            v105 = v45;
            v106 = 2080;
            v107 = v46;
            v108 = 1024;
            v109 = v49;
            v110 = 1024;
            LODWORD(v111[0]) = v48;
            WORD2(v111[0]) = 1024;
            *(_DWORD *)((char *)v111 + 6) = v42;
            v21 = "%{public}s %{public}s%s<i%u:s%d> [http] receiving response header {status=%hu}";
LABEL_43:
            v51 = v13;
            v52 = 50;
LABEL_44:
            _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_INFO, v21, buf, v52);
          }
        }
      }
      else
      {
        v88 = *(_QWORD *)(a1 + 40);
        if (!v88 || (*(__int16 *)(v88 + 376) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v82 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v89 = *(_QWORD *)(a1 + 40);
            v90 = "";
            v91 = v89 == 0;
            v92 = *(_DWORD *)(v89 + 368);
            v93 = (const char *)(v89 + 378);
            v103 = "nw_http2_stream_connect_block_invoke";
            v104 = 2082;
            if (v91)
              v93 = "";
            *(_DWORD *)buf = 136447234;
            if (!v91)
              v90 = " ";
            v105 = v93;
            v106 = 2080;
            v107 = v90;
            v108 = 1024;
            v109 = v92;
            v110 = 1024;
            LODWORD(v111[0]) = v42;
            v21 = "%{public}s %{public}s%s<i%u> [http] receiving response header {status=%hu}";
LABEL_123:
            v51 = v82;
            v52 = 44;
            goto LABEL_44;
          }
        }
      }
LABEL_45:
      os_release(v10);
LABEL_46:
      if (v6)
        os_release(v6);
      if (!outbound_message)
        return;
      v53 = outbound_message;
      goto LABEL_77;
    case 3:
      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      v55 = *(_QWORD *)(a1 + 32);
      if (v55)
      {
        if (((*(unsigned __int16 *)(v55 + 188) | (*(unsigned __int8 *)(v55 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v30 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v56 = *(_QWORD *)(a1 + 32);
            v57 = (const char *)(v56 + 191);
            v58 = "";
            v59 = v56 == 0;
            if (!v56)
              v57 = "";
            v62 = v56 + 176;
            v60 = *(_DWORD *)(v56 + 176);
            v61 = *(_DWORD *)(v62 + 4);
            if (!v59)
              v58 = " ";
            *(_DWORD *)buf = 136447490;
            v103 = "nw_http2_stream_connect_block_invoke";
            v104 = 2082;
            v105 = v57;
            v106 = 2080;
            v107 = v58;
            v108 = 1024;
            v109 = v61;
            v110 = 1024;
            LODWORD(v111[0]) = v60;
            WORD2(v111[0]) = 2048;
            *(_QWORD *)((char *)v111 + 6) = inbound_body_size;
            v38 = "%{public}s %{public}s%s<i%u:s%d> [http] finished receiving {body_bytes=%llu}";
LABEL_60:
            _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_INFO, v38, buf, 0x36u);
          }
        }
      }
      else
      {
        v75 = *(_QWORD *)(a1 + 40);
        if (!v75 || (*(__int16 *)(v75 + 376) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v68 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v76 = *(_QWORD *)(a1 + 40);
            v77 = (const char *)(v76 + 378);
            v78 = "";
            v79 = v76 == 0;
            v80 = *(_DWORD *)(v76 + 368);
            v103 = "nw_http2_stream_connect_block_invoke";
            if (v79)
              v77 = "";
            v104 = 2082;
            *(_DWORD *)buf = 136447234;
            if (!v79)
              v78 = " ";
            v105 = v77;
            v106 = 2080;
            v107 = v78;
            v108 = 1024;
            v109 = v80;
            v110 = 2048;
            v111[0] = inbound_body_size;
            v74 = "%{public}s %{public}s%s<i%u> [http] finished receiving {body_bytes=%llu}";
LABEL_102:
            _os_log_impl(&dword_182FBE000, v68, OS_LOG_TYPE_INFO, v74, buf, 0x30u);
          }
        }
      }
      return;
    case 4:
      v22 = MEMORY[0x1E0C809B0];
      v96[0] = MEMORY[0x1E0C809B0];
      v96[1] = 0x40000000;
      v96[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_39;
      v96[3] = &__block_descriptor_tmp_41_82396;
      v96[4] = a2;
      v97 = *(_OWORD *)(a1 + 32);
      v23 = nw_http_transaction_metadata_get_outbound_message(a2);
      v24 = v23;
      if (v23)
      {
        v25 = nw_http_metadata_copy_request(v23);
        v26 = nw_http_metadata_copy_response(v24);
        inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message)
          goto LABEL_65;
        if (v25)
        {
          if (v26)
            goto LABEL_66;
          goto LABEL_64;
        }
      }
      else
      {
        v63 = nw_http_transaction_metadata_get_inbound_message(a2);
        v26 = 0;
        if (!v63)
        {
          v64 = 0;
          inbound_message = 0;
          goto LABEL_80;
        }
        inbound_message = v63;
      }
      v25 = nw_http_metadata_copy_request(inbound_message);
      if (v26)
        goto LABEL_66;
LABEL_64:
      v26 = nw_http_metadata_copy_response(inbound_message);
LABEL_65:
      if (!v26)
      {
        v64 = 0;
        if (!v25)
          goto LABEL_80;
LABEL_69:
        v94[0] = v22;
        v94[1] = 0x40000000;
        v94[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_42;
        v94[3] = &unk_1E14AB990;
        v94[4] = v96;
        v95 = v64;
        v65 = v25;
        v66 = v94;
        _nw_http_request_access_method((uint64_t)v65, v66);

        if (!inbound_message)
          goto LABEL_71;
        goto LABEL_70;
      }
LABEL_66:
      v26 = v26;
      v64 = _nw_http_response_get_status_code();

      if (v25)
        goto LABEL_69;
LABEL_80:
      ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_39((uint64_t)v96, (uint64_t)"", v64);
      v65 = 0;
      if (inbound_message)
LABEL_70:
        os_release(inbound_message);
LABEL_71:
      if (v24)
        os_release(v24);
      if (v26)
        os_release(v26);
      if (v65)
      {
        v53 = v65;
LABEL_77:
        os_release(v53);
      }
      return;
    default:
      return;
  }
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  BOOL v9;
  int v10;
  int v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  BOOL v21;
  int v22;
  int v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v5 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v6 = *(_QWORD *)(a1 + 32);
        v7 = (const char *)(v6 + 191);
        v8 = "";
        v9 = v6 == 0;
        if (!v6)
          v7 = "";
        v12 = v6 + 176;
        v10 = *(_DWORD *)(v6 + 176);
        v11 = *(_DWORD *)(v12 + 4);
        if (!v9)
          v8 = " ";
        v23 = 136447490;
        v24 = "nw_http2_stream_connect_block_invoke";
        v25 = 2082;
        v26 = v7;
        v27 = 2080;
        v28 = v8;
        v29 = 1024;
        v30 = v11;
        v31 = 1024;
        LODWORD(v32[0]) = v10;
        WORD2(v32[0]) = 2082;
        *(_QWORD *)((char *)v32 + 6) = a2;
        v13 = "%{public}s %{public}s%s<i%u:s%d> [http] sending request header {method=\"%{public}s\"}";
        v14 = v5;
        v15 = 54;
LABEL_11:
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, v13, (uint8_t *)&v23, v15);
      }
    }
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 40);
    if (!v16 || (*(__int16 *)(v16 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v18 = *(_QWORD *)(a1 + 40);
        v19 = "";
        v20 = (const char *)(v18 + 378);
        v21 = v18 == 0;
        v22 = *(_DWORD *)(v18 + 368);
        if (v21)
          v20 = "";
        v23 = 136447234;
        v24 = "nw_http2_stream_connect_block_invoke_2";
        if (!v21)
          v19 = " ";
        v25 = 2082;
        v26 = v20;
        v27 = 2080;
        v28 = v19;
        v29 = 1024;
        v30 = v22;
        v31 = 2082;
        v32[0] = a2;
        v13 = "%{public}s %{public}s%s<i%u> [http] sending request header {method=\"%{public}s\"}";
        v14 = v17;
        v15 = 48;
        goto LABEL_11;
      }
    }
  }
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_37(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  BOOL v9;
  int v10;
  int v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  BOOL v21;
  int v22;
  int v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v5 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v6 = *(_QWORD *)(a1 + 32);
        v7 = (const char *)(v6 + 191);
        v8 = "";
        v9 = v6 == 0;
        if (!v6)
          v7 = "";
        v12 = v6 + 176;
        v10 = *(_DWORD *)(v6 + 176);
        v11 = *(_DWORD *)(v12 + 4);
        if (!v9)
          v8 = " ";
        v23 = 136447490;
        v24 = "nw_http2_stream_connect_block_invoke";
        v25 = 2082;
        v26 = v7;
        v27 = 2080;
        v28 = v8;
        v29 = 1024;
        v30 = v11;
        v31 = 1024;
        LODWORD(v32[0]) = v10;
        WORD2(v32[0]) = 2082;
        *(_QWORD *)((char *)v32 + 6) = a2;
        v13 = "%{public}s %{public}s%s<i%u:s%d> [http] receiving request header {method=\"%{public}s\"}";
        v14 = v5;
        v15 = 54;
LABEL_11:
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, v13, (uint8_t *)&v23, v15);
      }
    }
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 40);
    if (!v16 || (*(__int16 *)(v16 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v18 = *(_QWORD *)(a1 + 40);
        v19 = "";
        v20 = (const char *)(v18 + 378);
        v21 = v18 == 0;
        v22 = *(_DWORD *)(v18 + 368);
        if (v21)
          v20 = "";
        v23 = 136447234;
        v24 = "nw_http2_stream_connect_block_invoke";
        if (!v21)
          v19 = " ";
        v25 = 2082;
        v26 = v20;
        v27 = 2080;
        v28 = v19;
        v29 = 1024;
        v30 = v22;
        v31 = 2082;
        v32[0] = a2;
        v13 = "%{public}s %{public}s%s<i%u> [http] receiving request header {method=\"%{public}s\"}";
        v14 = v17;
        v15 = 48;
        goto LABEL_11;
      }
    }
  }
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_39(uint64_t a1, uint64_t a2, int a3)
{
  int start_reason;
  uint64_t start_time;
  uint64_t end_time;
  uint64_t outbound_message_start_time;
  uint64_t outbound_message_end_time;
  uint64_t outbound_body_size;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  const char *v17;
  int v18;
  int v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  const char *v31;
  NSObject *v32;
  uint32_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  const char *v38;
  const char *v39;
  int v40;
  int v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  uint64_t v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  int v53;
  const char *v54;
  const char *v55;
  const char *v56;
  const char *v57;
  const char *v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t inbound_message_end_time;
  uint64_t inbound_body_size;
  uint64_t inbound_message_start_time;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  _BYTE v76[14];
  __int16 v77;
  _BYTE v78[14];
  __int16 v79;
  int v80;
  __int16 v81;
  int v82;
  __int16 v83;
  int v84;
  __int16 v85;
  int v86;
  __int16 v87;
  _BYTE v88[24];
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  start_reason = nw_http_transaction_metadata_get_start_reason(*(void **)(a1 + 32));
  start_time = nw_http_transaction_metadata_get_start_time(*(void **)(a1 + 32));
  end_time = nw_http_transaction_metadata_get_end_time(*(void **)(a1 + 32));
  outbound_message_start_time = nw_http_transaction_metadata_get_outbound_message_start_time(*(void **)(a1 + 32));
  outbound_message_end_time = nw_http_transaction_metadata_get_outbound_message_end_time(*(void **)(a1 + 32));
  inbound_message_start_time = nw_http_transaction_metadata_get_inbound_message_start_time(*(void **)(a1 + 32));
  inbound_message_end_time = nw_http_transaction_metadata_get_inbound_message_end_time(*(void **)(a1 + 32));
  outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(*(void **)(a1 + 32));
  inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(*(void **)(a1 + 32));
  v12 = *(_QWORD *)(a1 + 40);
  if (v12)
  {
    if (((*(unsigned __int16 *)(v12 + 188) | (*(unsigned __int8 *)(v12 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        v14 = *(_QWORD *)(a1 + 40);
        v15 = "";
        if (v14)
          v16 = (const char *)(v14 + 191);
        else
          v16 = "";
        if (v14)
          v15 = " ";
        v60 = outbound_body_size;
        v62 = a2;
        v56 = v16;
        v58 = v15;
        if ((start_reason - 1) > 2)
          v17 = "initial";
        else
          v17 = off_1E14AA478[start_reason - 1];
        v54 = v17;
        v18 = *(_DWORD *)(v14 + 180);
        v53 = *(_DWORD *)(v14 + 176);
        v19 = -1;
        if (start_time && end_time)
        {
          v20 = nw_delta_nanos(start_time, end_time);
          if (v20 > 0xF423FFFFFFFFFLL)
            v19 = -1;
          else
            v19 = v20 / 0xF4240;
        }
        v21 = -1;
        v22 = outbound_message_end_time;
        if (start_time && outbound_message_start_time)
        {
          v23 = nw_delta_nanos(start_time, outbound_message_start_time);
          if (v23 > 0xF423FFFFFFFFFLL)
            v21 = -1;
          else
            v21 = v23 / 0xF4240;
          v22 = outbound_message_end_time;
        }
        v24 = -1;
        if (outbound_message_start_time)
        {
          v25 = inbound_message_start_time;
          if (v22)
          {
            v26 = nw_delta_nanos(outbound_message_start_time, v22);
            if (v26 > 0xF423FFFFFFFFFLL)
              v24 = -1;
            else
              v24 = v26 / 0xF4240;
          }
          v27 = -1;
          if (!start_time)
            goto LABEL_37;
        }
        else
        {
          v25 = inbound_message_start_time;
          v27 = -1;
          if (!start_time)
          {
LABEL_37:
            LODWORD(v29) = -1;
            if (v25 && inbound_message_end_time)
            {
              v30 = nw_delta_nanos(v25, inbound_message_end_time);
              v29 = v30 / 0xF4240;
              if (v30 > 0xF423FFFFFFFFFLL)
                LODWORD(v29) = -1;
            }
            *(_DWORD *)buf = 136449794;
            v68 = "nw_http2_stream_connect_block_invoke";
            v69 = 2082;
            v70 = v56;
            v71 = 2080;
            v72 = v58;
            v73 = 1024;
            v74 = v18;
            v75 = 1024;
            *(_DWORD *)v76 = v53;
            *(_WORD *)&v76[4] = 2080;
            *(_QWORD *)&v76[6] = v54;
            v77 = 1024;
            *(_DWORD *)v78 = v19;
            *(_WORD *)&v78[4] = 2082;
            *(_QWORD *)&v78[6] = v62;
            v79 = 1024;
            v80 = a3;
            v81 = 1024;
            v82 = v21;
            v83 = 1024;
            v84 = v24;
            v85 = 1024;
            v86 = v27;
            v87 = 1024;
            *(_DWORD *)v88 = v29;
            *(_WORD *)&v88[4] = 2048;
            *(_QWORD *)&v88[6] = v60;
            *(_WORD *)&v88[14] = 2048;
            *(_QWORD *)&v88[16] = inbound_body_size;
            v31 = "%{public}s %{public}s%s<i%u:s%d> [http] transaction summary {start_reason=\"%s\", duration_ms=%d, requ"
                  "est_method=\"%{public}s\", response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound"
                  "_start_ms=%d, inbound_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}";
            v32 = v13;
            v33 = 120;
LABEL_42:
            _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
            return;
          }
        }
        if (v25)
        {
          v28 = nw_delta_nanos(start_time, v25);
          if (v28 > 0xF423FFFFFFFFFLL)
            v27 = -1;
          else
            v27 = v28 / 0xF4240;
        }
        goto LABEL_37;
      }
    }
  }
  else
  {
    v34 = *(_QWORD *)(a1 + 48);
    if (!v34 || (*(__int16 *)(v34 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v35 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        v36 = *(_QWORD *)(a1 + 48);
        if (v36)
          v37 = (const char *)(v36 + 378);
        else
          v37 = "";
        v38 = " ";
        if (!v36)
          v38 = "";
        v57 = v37;
        v59 = v38;
        v61 = outbound_body_size;
        v63 = a2;
        if ((start_reason - 1) > 2)
          v39 = "initial";
        else
          v39 = off_1E14AA478[start_reason - 1];
        v55 = v39;
        v40 = *(_DWORD *)(v36 + 368);
        v41 = -1;
        if (start_time && end_time)
        {
          v42 = nw_delta_nanos(start_time, end_time);
          if (v42 > 0xF423FFFFFFFFFLL)
            v41 = -1;
          else
            v41 = v42 / 0xF4240;
        }
        v43 = -1;
        v44 = outbound_message_end_time;
        if (start_time && outbound_message_start_time)
        {
          v45 = nw_delta_nanos(start_time, outbound_message_start_time);
          if (v45 > 0xF423FFFFFFFFFLL)
            v43 = -1;
          else
            v43 = v45 / 0xF4240;
          v44 = outbound_message_end_time;
        }
        v46 = -1;
        if (outbound_message_start_time)
        {
          v47 = inbound_message_start_time;
          if (v44)
          {
            v48 = nw_delta_nanos(outbound_message_start_time, v44);
            if (v48 > 0xF423FFFFFFFFFLL)
              v46 = -1;
            else
              v46 = v48 / 0xF4240;
          }
        }
        else
        {
          v47 = inbound_message_start_time;
        }
        v49 = -1;
        if (start_time && v47)
        {
          v50 = nw_delta_nanos(start_time, v47);
          if (v50 > 0xF423FFFFFFFFFLL)
            v49 = -1;
          else
            v49 = v50 / 0xF4240;
        }
        LODWORD(v51) = -1;
        if (v47)
        {
          if (inbound_message_end_time)
          {
            v52 = nw_delta_nanos(v47, inbound_message_end_time);
            v51 = v52 / 0xF4240;
            if (v52 > 0xF423FFFFFFFFFLL)
              LODWORD(v51) = -1;
          }
        }
        *(_DWORD *)buf = 136449538;
        v68 = "nw_http2_stream_connect_block_invoke";
        v69 = 2082;
        v70 = v57;
        v71 = 2080;
        v72 = v59;
        v73 = 1024;
        v74 = v40;
        v75 = 2080;
        *(_QWORD *)v76 = v55;
        *(_WORD *)&v76[8] = 1024;
        *(_DWORD *)&v76[10] = v41;
        v77 = 2082;
        *(_QWORD *)v78 = v63;
        *(_WORD *)&v78[8] = 1024;
        *(_DWORD *)&v78[10] = a3;
        v79 = 1024;
        v80 = v43;
        v81 = 1024;
        v82 = v46;
        v83 = 1024;
        v84 = v49;
        v85 = 1024;
        v86 = v51;
        v87 = 2048;
        *(_QWORD *)v88 = v61;
        *(_WORD *)&v88[8] = 2048;
        *(_QWORD *)&v88[10] = inbound_body_size;
        v31 = "%{public}s %{public}s%s<i%u> [http] transaction summary {start_reason=\"%s\", duration_ms=%d, request_meth"
              "od=\"%{public}s\", response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound_start_ms=%d"
              ", inbound_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}";
        v32 = v35;
        v33 = 114;
        goto LABEL_42;
      }
    }
  }
}

uint64_t ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_42(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2, *(unsigned __int16 *)(a1 + 40));
}

uint64_t ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  BOOL v16;
  const char *v17;
  int v18;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  const char *v23;
  int v24;
  uint64_t v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  int v33;
  uint64_t v34;
  NSObject *v36;
  _BOOL4 v37;
  uint64_t v38;
  const char *v39;
  BOOL v40;
  const char *v41;
  int v42;
  unsigned int v43;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v43 = 0;
  v3 = nw_frame_unclaimed_bytes(a2, &v43);
  v4 = v43;
  if (v3)
    v5 = v43 == 0;
  else
    v5 = 1;
  v6 = !v5;
  if (!v5)
  {
    v7 = v3;
    v8 = *(_QWORD *)(a1 + 40);
    if ((!v8 || (*(__int16 *)(v8 + 376) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v36 = gconnectionLogObj;
      v37 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      v4 = v43;
      if (v37)
      {
        v38 = *(_QWORD *)(a1 + 40);
        v39 = (const char *)(v38 + 378);
        v40 = v38 == 0;
        v41 = "";
        if (!v38)
          v39 = "";
        v42 = *(_DWORD *)(v38 + 368);
        if (!v40)
          v41 = " ";
        *(_DWORD *)buf = 136447234;
        v45 = "nw_protocol_http2_process_input_block_invoke";
        v46 = 2082;
        v47 = v39;
        v48 = 2080;
        v49 = v41;
        v50 = 1024;
        v51 = v42;
        v52 = 1024;
        v53 = v43;
        _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> processing frame of length %u bytes", buf, 0x2Cu);
        v4 = v43;
      }
      if (!v4)
      {
        v9 = 0;
        goto LABEL_55;
      }
    }
    v9 = 0;
    while (1)
    {
      v10 = MEMORY[0x186DB4424](*(_QWORD *)(*(_QWORD *)(a1 + 40) + 96), v7 + v9, v4 - v9);
      v11 = v10;
      if (v10 < 0)
        break;
      v9 += v10;
      v12 = *(_QWORD *)(a1 + 40);
      if ((!v12 || (*(__int16 *)(v12 + 376) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v13 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v14 = *(_QWORD *)(a1 + 40);
          v15 = (const char *)(v14 + 378);
          v16 = v14 == 0;
          v17 = "";
          if (!v14)
            v15 = "";
          v18 = *(_DWORD *)(v14 + 368);
          if (!v16)
            v17 = " ";
          *(_DWORD *)buf = 136447234;
          v45 = "nw_protocol_http2_process_input_block_invoke";
          v46 = 2082;
          v47 = v15;
          v48 = 2080;
          v49 = v17;
          v50 = 1024;
          v51 = v18;
          v52 = 1024;
          v53 = v9;
          _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> nghttp2_session_mem_recv consumed %u bytes", buf, 0x2Cu);
        }
      }
      v4 = v43;
      if (v9 >= v43)
        goto LABEL_55;
    }
    if (v10 != -902 || (*(_WORD *)(*(_QWORD *)(a1 + 40) + 376) & 0x10) == 0)
    {
      if ((*(_WORD *)(*(_QWORD *)(a1 + 40) + 376) & 0x8000) != 0)
        goto LABEL_54;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v20 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_54;
      v21 = *(_QWORD *)(a1 + 40);
      if (v21)
        v22 = (const char *)(v21 + 378);
      else
        v22 = "";
      if (v21)
        v23 = " ";
      else
        v23 = "";
      v24 = *(_DWORD *)(v21 + 368);
      v25 = nghttp2_strerror();
      *(_DWORD *)buf = 136447490;
      v45 = "nw_protocol_http2_process_input_block_invoke";
      v46 = 2082;
      v47 = v22;
      v48 = 2080;
      v49 = v23;
      v50 = 1024;
      v51 = v24;
      v52 = 1024;
      v53 = v11;
      v54 = 2082;
      v55 = v25;
      v26 = "%{public}s %{public}s%s<i%u> ERROR: Could not process incoming data: %d (%{public}s)";
      v27 = v20;
      v28 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if ((*(_WORD *)(*(_QWORD *)(a1 + 40) + 376) & 0x8000) != 0)
        goto LABEL_54;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v29 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
        goto LABEL_54;
      v30 = *(_QWORD *)(a1 + 40);
      if (v30)
        v31 = (const char *)(v30 + 378);
      else
        v31 = "";
      if (v30)
        v32 = " ";
      else
        v32 = "";
      v33 = *(_DWORD *)(v30 + 368);
      v34 = nghttp2_strerror();
      *(_DWORD *)buf = 136447490;
      v45 = "nw_protocol_http2_process_input_block_invoke";
      v46 = 2082;
      v47 = v31;
      v48 = 2080;
      v49 = v32;
      v50 = 1024;
      v51 = v33;
      v52 = 1024;
      v53 = -902;
      v54 = 2082;
      v55 = v34;
      v26 = "%{public}s %{public}s%s<i%u> Could not process incoming data: %d (%{public}s), closing";
      v27 = v29;
      v28 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl(&dword_182FBE000, v27, v28, v26, buf, 0x36u);
LABEL_54:
    nw_http2_connection_close(*(_QWORD *)(a1 + 40));
LABEL_55:
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v9;
  }
  return v6;
}

uint64_t ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke_48(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t object;
  int v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, _QWORD);
  const char *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  NSObject *v20;
  int v21;
  int v22;
  const char *v23;
  const char *v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)nw_hash_node_get_extra(a2);
  object = nw_hash_node_get_object(a2);
  v6 = *(unsigned __int16 *)(v4 + 188);
  if ((v6 & 1) == 0 || !*(_QWORD *)v4)
    return 1;
  v7 = object;
  if (((v6 | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v20 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v22 = *(_DWORD *)(v4 + 176);
      v21 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)buf = 136447490;
      v28 = "nw_protocol_http2_process_input_block_invoke";
      v29 = 2082;
      v30 = (const char *)(v4 + 191);
      v31 = 2080;
      v32 = " ";
      v33 = 1024;
      v34 = v21;
      v35 = 1024;
      v36 = v22;
      v37 = 1024;
      v38 = v22;
      _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> calling input_available on stream %d", buf, 0x32u);
    }
  }
  if (v7)
  {
    v8 = *(_QWORD *)(v7 + 24);
    if (v8)
    {
      v9 = *(void (**)(uint64_t, _QWORD))(v8 + 64);
      if (v9)
      {
        v9(v7, *(_QWORD *)(a1 + 32));
        return 1;
      }
    }
    __nwlog_obj();
    v11 = *(const char **)(v7 + 16);
    if (!v11)
      v11 = "invalid";
  }
  else
  {
    __nwlog_obj();
    v11 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  v28 = "nw_protocol_http2_process_input_block_invoke";
  v29 = 2082;
  v30 = v11;
  v12 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v12, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_44;
      v15 = "invalid";
      if (v7 && *(_QWORD *)(v7 + 16))
        v15 = *(const char **)(v7 + 16);
      *(_DWORD *)buf = 136446466;
      v28 = "nw_protocol_http2_process_input_block_invoke";
      v29 = 2082;
      v30 = v15;
      v16 = "%{public}s protocol %{public}s has invalid input_available callback";
      goto LABEL_43;
    }
    if (!v25)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_44;
      v23 = "invalid";
      if (v7 && *(_QWORD *)(v7 + 16))
        v23 = *(const char **)(v7 + 16);
      *(_DWORD *)buf = 136446466;
      v28 = "nw_protocol_http2_process_input_block_invoke";
      v29 = 2082;
      v30 = v23;
      v16 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v18 = os_log_type_enabled(v13, type);
    if (backtrace_string)
    {
      if (v18)
      {
        v19 = "invalid";
        if (v7 && *(_QWORD *)(v7 + 16))
          v19 = *(const char **)(v7 + 16);
        *(_DWORD *)buf = 136446722;
        v28 = "nw_protocol_http2_process_input_block_invoke";
        v29 = 2082;
        v30 = v19;
        v31 = 2082;
        v32 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_44;
    }
    if (v18)
    {
      v24 = "invalid";
      if (v7 && *(_QWORD *)(v7 + 16))
        v24 = *(const char **)(v7 + 16);
      *(_DWORD *)buf = 136446466;
      v28 = "nw_protocol_http2_process_input_block_invoke";
      v29 = 2082;
      v30 = v24;
      v16 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_43:
      _os_log_impl(&dword_182FBE000, v13, v14, v16, buf, 0x16u);
    }
  }
LABEL_44:
  if (v12)
    free(v12);
  return 1;
}

void nw_protocol_http2_frame_output_finalizer(nw_frame *a1, int a2, void *a3)
{
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  __int16 v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  _BOOL4 v15;
  const char *v16;
  _QWORD *v17;
  uint64_t stream_from_protocol;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  const char *v24;
  NSObject *v25;
  os_log_type_t v26;
  uint32_t v27;
  uint64_t v28;
  int v29;
  int v30;
  const char *v31;
  NSObject *v32;
  os_log_type_t v33;
  int v34;
  const char *v35;
  uint64_t v36;
  id v37;
  void *v38;
  void *v39;
  int v40;
  NSObject *v41;
  os_log_type_t v42;
  int v43;
  char *v44;
  _BOOL4 v45;
  int v46;
  char *v47;
  _BOOL4 v48;
  int v49;
  void *v50;
  id v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  int v56;
  NSObject *v57;
  int v58;
  int v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  int v64;
  NSObject *v65;
  os_log_type_t v66;
  uint32_t v67;
  int v68;
  int v69;
  const char *v70;
  NSObject *v71;
  os_log_type_t v72;
  int v73;
  const char *v74;
  char *v75;
  _BOOL4 v76;
  int v77;
  int v78;
  char *v79;
  void *v80;
  char *v81;
  _BOOL4 v82;
  char *v83;
  _BOOL4 v84;
  int v85;
  int v86;
  char *v87;
  _BOOL4 v88;
  const char *v89;
  _BOOL4 v90;
  int v91;
  int v92;
  char *backtrace_string;
  _BOOL4 v94;
  NSObject *v95;
  _BOOL4 v96;
  _BOOL4 v97;
  NSObject *v98;
  int v99;
  int v100;
  NSObject *v101;
  int v102;
  int v103;
  uint64_t v104;
  _BOOL4 v105;
  char v106;
  os_log_type_t v107;
  __int128 v108;
  __int128 type;
  uint8_t buf[4];
  const char *v111;
  __int16 v112;
  _BYTE v113[50];
  __int16 v114;
  int v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    v3 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v108) = 0;
    if (!__nwlog_fault(v3, &type, &v108))
      goto LABEL_42;
    if (type != 17)
    {
      if ((_BYTE)v108)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v94 = os_log_type_enabled(v4, (os_log_type_t)type);
        if (backtrace_string)
        {
          if (v94)
          {
            *(_DWORD *)buf = 136446466;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v94)
        {
          *(_DWORD *)buf = 136446210;
          v111 = "nw_protocol_http2_frame_output_finalizer";
          v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_41;
        }
      }
      else
      {
        v4 = __nwlog_obj();
        v5 = type;
        if (os_log_type_enabled(v4, (os_log_type_t)type))
        {
          *(_DWORD *)buf = 136446210;
          v111 = "nw_protocol_http2_frame_output_finalizer";
          v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
      goto LABEL_42;
    }
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, (os_log_type_t)type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    v6 = "%{public}s called with null frame";
LABEL_41:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_42;
  }
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    v3 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v108) = 0;
    if (!__nwlog_fault(v3, &type, &v108))
      goto LABEL_42;
    if (type == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      v6 = "%{public}s http2 output frames should no longer have nonnull context";
      goto LABEL_41;
    }
    if (!(_BYTE)v108)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      v6 = "%{public}s http2 output frames should no longer have nonnull context, backtrace limit exceeded";
      goto LABEL_41;
    }
    v14 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v5 = type;
    v15 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type);
    if (!v14)
    {
      if (!v15)
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      v6 = "%{public}s http2 output frames should no longer have nonnull context, no backtrace";
      goto LABEL_41;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      v112 = 2082;
      *(_QWORD *)v113 = v14;
      v16 = "%{public}s http2 output frames should no longer have nonnull context, dumping backtrace:%{public}s";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v4, v5, v16, buf, 0x16u);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  if (gLogDatapath)
  {
    v95 = __nwlog_obj();
    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      v112 = 2048;
      *(_QWORD *)v113 = a1;
      *(_WORD *)&v113[8] = 1024;
      *(_DWORD *)&v113[10] = a2;
      *(_WORD *)&v113[14] = 2048;
      *(_QWORD *)&v113[16] = 0;
      _os_log_impl(&dword_182FBE000, v95, OS_LOG_TYPE_DEBUG, "%{public}s called with frame %p success %d context %p", buf, 0x26u);
    }
  }
  v9 = *((_WORD *)a1 + 102);
  v10 = (uint64_t *)((char *)a1 + 208);
  if ((v9 & 4) != 0)
  {
    v11 = *v10;
    if (*v10)
    {
      v12 = *((_QWORD *)a1 + 2);
      v13 = (_QWORD *)*((_QWORD *)a1 + 3);
      if (v12)
      {
        *(_QWORD *)(v12 + 24) = v13;
        v13 = (_QWORD *)*((_QWORD *)a1 + 3);
      }
      else
      {
        *(_QWORD *)(v11 + 192) = v13;
      }
      *v13 = v12;
      *((_QWORD *)a1 + 2) = 0;
      *((_QWORD *)a1 + 3) = 0;
      if (!a2)
      {
        if (*(__int16 *)(v11 + 376) < 0 || !gLogDatapath)
          goto LABEL_142;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v28 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          goto LABEL_142;
        v29 = *(_DWORD *)(v11 + 368);
        *(_DWORD *)buf = 136446978;
        v111 = "nw_protocol_http2_frame_output_finalizer";
        v112 = 2082;
        *(_QWORD *)v113 = v11 + 378;
        *(_WORD *)&v113[8] = 2080;
        *(_QWORD *)&v113[10] = " ";
        *(_WORD *)&v113[18] = 1024;
        *(_DWORD *)&v113[20] = v29;
        v24 = "%{public}s %{public}s%s<i%u> disposing of output frame, finalizer called with success == false";
        v25 = v28;
        v26 = OS_LOG_TYPE_DEBUG;
        v27 = 38;
LABEL_30:
        _os_log_impl(&dword_182FBE000, v25, v26, v24, buf, v27);
        goto LABEL_142;
      }
      v17 = (_QWORD *)*((_QWORD *)a1 + 27);
      if (v17)
      {
        stream_from_protocol = nw_http2_get_stream_from_protocol(v11, *((_QWORD *)a1 + 27));
        if (stream_from_protocol)
        {
          v19 = stream_from_protocol;
          v20 = *(unsigned __int16 *)(stream_from_protocol + 188);
          if ((v20 & 1) == 0 && *(int *)(stream_from_protocol + 176) >= 1)
          {
            if (((v20 | (*(unsigned __int8 *)(stream_from_protocol + 190) << 16)) & 0x80000) != 0)
              goto LABEL_142;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v21 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_142;
            v23 = *(_DWORD *)(v19 + 176);
            v22 = *(_DWORD *)(v19 + 180);
            *(_DWORD *)buf = 136447234;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v19 + 191;
            *(_WORD *)&v113[8] = 2080;
            *(_QWORD *)&v113[10] = " ";
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v22;
            *(_WORD *)&v113[24] = 1024;
            *(_DWORD *)&v113[26] = v23;
            v24 = "%{public}s %{public}s%s<i%u:s%d> Cannot send data on a stream that is not open but has a greater than zero stream id";
            v25 = v21;
            v26 = OS_LOG_TYPE_ERROR;
            v27 = 44;
            goto LABEL_30;
          }
          v36 = *(_QWORD *)(stream_from_protocol + 104);
          if (nw_protocol_copy_http_definition_onceToken != -1)
            dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72660);
          v37 = (id)nw_protocol_copy_http_definition_http_definition;
          v38 = nw_frame_copy_metadata_for_protocol((uint64_t)a1, (uint64_t)v37);
          v39 = v38;
          if (v36)
          {
            if (v37)
              os_release(v37);
            if (v39)
            {
              type = 0uLL;
              nw_protocol_metadata_copy_identifier(v39, &type);
              v108 = 0uLL;
              nw_protocol_metadata_copy_identifier(*(void **)(v19 + 104), &v108);
              if (v108 == type)
              {
                os_release(v39);
                goto LABEL_124;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136447234;
              v111 = "nw_http2_save_metadata_from_frame";
              v112 = 1040;
              *(_DWORD *)v113 = 16;
              *(_WORD *)&v113[4] = 2096;
              *(_QWORD *)&v113[6] = &v108;
              *(_WORD *)&v113[14] = 1040;
              *(_DWORD *)&v113[16] = 16;
              *(_WORD *)&v113[20] = 2096;
              *(_QWORD *)&v113[22] = &type;
              v60 = (char *)_os_log_send_and_compose_impl();
              v107 = OS_LOG_TYPE_ERROR;
              v106 = 0;
              if (!__nwlog_fault(v60, &v107, &v106))
                goto LABEL_177;
              if (v107 == OS_LOG_TYPE_FAULT)
              {
                v61 = __nwlog_obj();
                v62 = v107;
                if (os_log_type_enabled(v61, v107))
                {
                  *(_DWORD *)buf = 136447234;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v112 = 1040;
                  *(_DWORD *)v113 = 16;
                  *(_WORD *)&v113[4] = 2096;
                  *(_QWORD *)&v113[6] = &v108;
                  *(_WORD *)&v113[14] = 1040;
                  *(_DWORD *)&v113[16] = 16;
                  *(_WORD *)&v113[20] = 2096;
                  *(_QWORD *)&v113[22] = &type;
                  v63 = "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uuid_"
                        "t}.16P != new %{uuid_t}.16P)";
LABEL_176:
                  _os_log_impl(&dword_182FBE000, v61, v62, v63, buf, 0x2Cu);
                }
              }
              else if (v106)
              {
                v81 = (char *)__nw_create_backtrace_string();
                v61 = __nwlog_obj();
                v62 = v107;
                v82 = os_log_type_enabled(v61, v107);
                if (v81)
                {
                  if (v82)
                  {
                    *(_DWORD *)buf = 136447490;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v112 = 1040;
                    *(_DWORD *)v113 = 16;
                    *(_WORD *)&v113[4] = 2096;
                    *(_QWORD *)&v113[6] = &v108;
                    *(_WORD *)&v113[14] = 1040;
                    *(_DWORD *)&v113[16] = 16;
                    *(_WORD *)&v113[20] = 2096;
                    *(_QWORD *)&v113[22] = &type;
                    *(_WORD *)&v113[30] = 2082;
                    *(_QWORD *)&v113[32] = v81;
                    _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uuid_t}.16P != new %{uuid_t}.16P), dumping backtrace:%{public}s", buf, 0x36u);
                  }
                  free(v81);
                  goto LABEL_177;
                }
                if (v82)
                {
                  *(_DWORD *)buf = 136447234;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v112 = 1040;
                  *(_DWORD *)v113 = 16;
                  *(_WORD *)&v113[4] = 2096;
                  *(_QWORD *)&v113[6] = &v108;
                  *(_WORD *)&v113[14] = 1040;
                  *(_DWORD *)&v113[16] = 16;
                  *(_WORD *)&v113[20] = 2096;
                  *(_QWORD *)&v113[22] = &type;
                  v63 = "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uuid_"
                        "t}.16P != new %{uuid_t}.16P), no backtrace";
                  goto LABEL_176;
                }
              }
              else
              {
                v61 = __nwlog_obj();
                v62 = v107;
                if (os_log_type_enabled(v61, v107))
                {
                  *(_DWORD *)buf = 136447234;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v112 = 1040;
                  *(_DWORD *)v113 = 16;
                  *(_WORD *)&v113[4] = 2096;
                  *(_QWORD *)&v113[6] = &v108;
                  *(_WORD *)&v113[14] = 1040;
                  *(_DWORD *)&v113[16] = 16;
                  *(_WORD *)&v113[20] = 2096;
                  *(_QWORD *)&v113[22] = &type;
                  v63 = "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uuid_"
                        "t}.16P != new %{uuid_t}.16P), backtrace limit exceeded";
                  goto LABEL_176;
                }
              }
LABEL_177:
              if (v60)
                free(v60);
              os_release(v39);
              goto LABEL_208;
            }
            if (((*(unsigned __int16 *)(v19 + 188) | (*(unsigned __int8 *)(v19 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v57 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v59 = *(_DWORD *)(v19 + 176);
                v58 = *(_DWORD *)(v19 + 180);
                *(_DWORD *)buf = 136447490;
                v111 = "nw_http2_save_metadata_from_frame";
                v112 = 2082;
                *(_QWORD *)v113 = v19 + 191;
                *(_WORD *)&v113[8] = 2080;
                *(_QWORD *)&v113[10] = " ";
                *(_WORD *)&v113[18] = 1024;
                *(_DWORD *)&v113[20] = v58;
                *(_WORD *)&v113[24] = 1024;
                *(_DWORD *)&v113[26] = v59;
                *(_WORD *)&v113[30] = 2048;
                *(_QWORD *)&v113[32] = a1;
                _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> no http metadata on frame %p, sending body data only", buf, 0x36u);
              }
            }
LABEL_124:
            if (nw_http2_submit_message(v11, v17, v19, (uint64_t)a1))
            {
              ++*(_WORD *)(v11 + 374);
              nw_http2_session_send(v11);
              return;
            }
            __nwlog_obj();
            v69 = *(_DWORD *)(v19 + 176);
            *(_DWORD *)buf = 136447234;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2048;
            *(_QWORD *)v113 = v17;
            *(_WORD *)&v113[8] = 2048;
            *(_QWORD *)&v113[10] = v19;
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v69;
            *(_WORD *)&v113[24] = 2048;
            *(_QWORD *)&v113[26] = a1;
            v70 = (const char *)_os_log_send_and_compose_impl();
            LOBYTE(type) = 16;
            LOBYTE(v108) = 0;
            if (__nwlog_fault(v70, &type, &v108))
            {
              if (type == 17)
              {
                v71 = __nwlog_obj();
                v72 = type;
                if (!os_log_type_enabled(v71, (os_log_type_t)type))
                  goto LABEL_170;
                v73 = *(_DWORD *)(v19 + 176);
                *(_DWORD *)buf = 136447234;
                v111 = "nw_protocol_http2_frame_output_finalizer";
                v112 = 2048;
                *(_QWORD *)v113 = v17;
                *(_WORD *)&v113[8] = 2048;
                *(_QWORD *)&v113[10] = v19;
                *(_WORD *)&v113[18] = 1024;
                *(_DWORD *)&v113[20] = v73;
                *(_WORD *)&v113[24] = 2048;
                *(_QWORD *)&v113[26] = a1;
                v74 = "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame %p";
LABEL_169:
                _os_log_impl(&dword_182FBE000, v71, v72, v74, buf, 0x30u);
                goto LABEL_170;
              }
              if (!(_BYTE)v108)
              {
                v71 = __nwlog_obj();
                v72 = type;
                if (!os_log_type_enabled(v71, (os_log_type_t)type))
                  goto LABEL_170;
                v85 = *(_DWORD *)(v19 + 176);
                *(_DWORD *)buf = 136447234;
                v111 = "nw_protocol_http2_frame_output_finalizer";
                v112 = 2048;
                *(_QWORD *)v113 = v17;
                *(_WORD *)&v113[8] = 2048;
                *(_QWORD *)&v113[10] = v19;
                *(_WORD *)&v113[18] = 1024;
                *(_DWORD *)&v113[20] = v85;
                *(_WORD *)&v113[24] = 2048;
                *(_QWORD *)&v113[26] = a1;
                v74 = "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame %p"
                      ", backtrace limit exceeded";
                goto LABEL_169;
              }
              v75 = (char *)__nw_create_backtrace_string();
              v71 = __nwlog_obj();
              v72 = type;
              v76 = os_log_type_enabled(v71, (os_log_type_t)type);
              if (!v75)
              {
                if (!v76)
                  goto LABEL_170;
                v86 = *(_DWORD *)(v19 + 176);
                *(_DWORD *)buf = 136447234;
                v111 = "nw_protocol_http2_frame_output_finalizer";
                v112 = 2048;
                *(_QWORD *)v113 = v17;
                *(_WORD *)&v113[8] = 2048;
                *(_QWORD *)&v113[10] = v19;
                *(_WORD *)&v113[18] = 1024;
                *(_DWORD *)&v113[20] = v86;
                *(_WORD *)&v113[24] = 2048;
                *(_QWORD *)&v113[26] = a1;
                v74 = "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame %p, no backtrace";
                goto LABEL_169;
              }
              if (v76)
              {
                v77 = *(_DWORD *)(v19 + 176);
                *(_DWORD *)buf = 136447490;
                v111 = "nw_protocol_http2_frame_output_finalizer";
                v112 = 2048;
                *(_QWORD *)v113 = v17;
                *(_WORD *)&v113[8] = 2048;
                *(_QWORD *)&v113[10] = v19;
                *(_WORD *)&v113[18] = 1024;
                *(_DWORD *)&v113[20] = v77;
                *(_WORD *)&v113[24] = 2048;
                *(_QWORD *)&v113[26] = a1;
                *(_WORD *)&v113[34] = 2082;
                *(_QWORD *)&v113[36] = v75;
                _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame %p, dumping backtrace:%{public}s", buf, 0x3Au);
              }
              free(v75);
            }
LABEL_170:
            if (v70)
            {
              v79 = (char *)v70;
              goto LABEL_141;
            }
LABEL_142:
            if ((*((_WORD *)a1 + 102) & 0x100) == 0
              || !g_channel_check_validity
              || g_channel_check_validity(a1, *((_QWORD *)a1 + 11)))
            {
              v80 = (void *)*((_QWORD *)a1 + 14);
              if (v80)
                free(v80);
            }
            nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
            os_release(a1);
            return;
          }
          *(_QWORD *)(v19 + 104) = v38;
          if (v37)
          {
            os_release(v37);
            v39 = *(void **)(v19 + 104);
          }
          if (v39)
          {
            if (nw_protocol_metadata_is_http(v39))
            {
              v50 = *(void **)(v19 + 104);
              if ((*(_WORD *)(v11 + 376) & 0x80) != 0)
              {
                v51 = nw_http_metadata_copy_response(v50);
                if (!v51)
                {
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v52 = (char *)_os_log_send_and_compose_impl();
                  LOBYTE(type) = 16;
                  LOBYTE(v108) = 0;
                  if (!__nwlog_fault(v52, &type, &v108))
                    goto LABEL_206;
                  if (type == 17)
                  {
                    v53 = __nwlog_obj();
                    v54 = type;
                    if (!os_log_type_enabled(v53, (os_log_type_t)type))
                      goto LABEL_206;
                    *(_DWORD *)buf = 136446210;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v55 = "%{public}s did not find response on frame";
                    goto LABEL_205;
                  }
                  if (!(_BYTE)v108)
                  {
                    v53 = __nwlog_obj();
                    v54 = type;
                    if (!os_log_type_enabled(v53, (os_log_type_t)type))
                      goto LABEL_206;
                    *(_DWORD *)buf = 136446210;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v55 = "%{public}s did not find response on frame, backtrace limit exceeded";
                    goto LABEL_205;
                  }
                  v87 = (char *)__nw_create_backtrace_string();
                  v53 = __nwlog_obj();
                  v54 = type;
                  v90 = os_log_type_enabled(v53, (os_log_type_t)type);
                  if (!v87)
                  {
                    if (!v90)
                      goto LABEL_206;
                    *(_DWORD *)buf = 136446210;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v55 = "%{public}s did not find response on frame, no backtrace";
                    goto LABEL_205;
                  }
                  if (v90)
                  {
                    *(_DWORD *)buf = 136446466;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v112 = 2082;
                    *(_QWORD *)v113 = v87;
                    v89 = "%{public}s did not find response on frame, dumping backtrace:%{public}s";
                    goto LABEL_188;
                  }
LABEL_189:
                  free(v87);
                  if (!v52)
                  {
LABEL_208:
                    if (((*(unsigned __int16 *)(v19 + 188) | (*(unsigned __int8 *)(v19 + 190) << 16)) & 0x80000) == 0
                      && gLogDatapath)
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v98 = gconnectionLogObj;
                      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                      {
                        v100 = *(_DWORD *)(v19 + 176);
                        v99 = *(_DWORD *)(v19 + 180);
                        *(_DWORD *)buf = 136447490;
                        v111 = "nw_protocol_http2_frame_output_finalizer";
                        v112 = 2082;
                        *(_QWORD *)v113 = v19 + 191;
                        *(_WORD *)&v113[8] = 2080;
                        *(_QWORD *)&v113[10] = " ";
                        *(_WORD *)&v113[18] = 1024;
                        *(_DWORD *)&v113[20] = v99;
                        *(_WORD *)&v113[24] = 1024;
                        *(_DWORD *)&v113[26] = v100;
                        *(_WORD *)&v113[30] = 2048;
                        *(_QWORD *)&v113[32] = a1;
                        _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> cannot send on a new stream without outbound metadata for frame %p", buf, 0x36u);
                      }
                    }
                    v91 = *(unsigned __int16 *)(v19 + 188);
                    v92 = v91 | (*(unsigned __int8 *)(v19 + 190) << 16);
                    if ((v91 & 0x40) != 0)
                      return;
                    *(_BYTE *)(v19 + 190) = BYTE2(v92);
                    *(_WORD *)(v19 + 188) = v92 | 0x40;
                    nw_protocol_error(v17, v11);
                    nw_protocol_disconnected(v17, v11);
                    goto LABEL_142;
                  }
LABEL_207:
                  free(v52);
                  goto LABEL_208;
                }
              }
              else
              {
                v51 = nw_http_metadata_copy_request(v50);
                if (!v51)
                {
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v52 = (char *)_os_log_send_and_compose_impl();
                  LOBYTE(type) = 16;
                  LOBYTE(v108) = 0;
                  if (!__nwlog_fault(v52, &type, &v108))
                    goto LABEL_206;
                  if (type == 17)
                  {
                    v53 = __nwlog_obj();
                    v54 = type;
                    if (!os_log_type_enabled(v53, (os_log_type_t)type))
                      goto LABEL_206;
                    *(_DWORD *)buf = 136446210;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v55 = "%{public}s did not find request on frame";
                    goto LABEL_205;
                  }
                  if (!(_BYTE)v108)
                  {
                    v53 = __nwlog_obj();
                    v54 = type;
                    if (!os_log_type_enabled(v53, (os_log_type_t)type))
                      goto LABEL_206;
                    *(_DWORD *)buf = 136446210;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v55 = "%{public}s did not find request on frame, backtrace limit exceeded";
                    goto LABEL_205;
                  }
                  v87 = (char *)__nw_create_backtrace_string();
                  v53 = __nwlog_obj();
                  v54 = type;
                  v88 = os_log_type_enabled(v53, (os_log_type_t)type);
                  if (!v87)
                  {
                    if (!v88)
                      goto LABEL_206;
                    *(_DWORD *)buf = 136446210;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v55 = "%{public}s did not find request on frame, no backtrace";
                    goto LABEL_205;
                  }
                  if (v88)
                  {
                    *(_DWORD *)buf = 136446466;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v112 = 2082;
                    *(_QWORD *)v113 = v87;
                    v89 = "%{public}s did not find request on frame, dumping backtrace:%{public}s";
LABEL_188:
                    _os_log_impl(&dword_182FBE000, v53, v54, v89, buf, 0x16u);
                    goto LABEL_189;
                  }
                  goto LABEL_189;
                }
              }
              os_release(v51);
              if (((*(unsigned __int16 *)(v19 + 188) | (*(unsigned __int8 *)(v19 + 190) << 16)) & 0x80000) == 0
                && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v101 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v103 = *(_DWORD *)(v19 + 176);
                  v102 = *(_DWORD *)(v19 + 180);
                  v104 = *(_QWORD *)(v19 + 104);
                  *(_DWORD *)buf = 136448002;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v112 = 2082;
                  *(_QWORD *)v113 = v19 + 191;
                  *(_WORD *)&v113[8] = 2080;
                  *(_QWORD *)&v113[10] = " ";
                  *(_WORD *)&v113[18] = 1024;
                  *(_DWORD *)&v113[20] = v102;
                  *(_WORD *)&v113[24] = 1024;
                  *(_DWORD *)&v113[26] = v103;
                  *(_WORD *)&v113[30] = 2048;
                  *(_QWORD *)&v113[32] = v104;
                  *(_WORD *)&v113[40] = 2048;
                  *(_QWORD *)&v113[42] = v19;
                  v114 = 1024;
                  v115 = v103;
                  _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> saved outbound metadata %p for stream %p (%d)", buf, 0x46u);
                }
              }
              nw_http_transaction_metadata_set_outbound_message(*(void **)(v19 + 96), *(void **)(v19 + 104));
              nw::http::content_length_manager::set_outbound_message((nw::http::content_length_manager *)(v19 + 40), *(nw_protocol_metadata **)(v19 + 104));
              goto LABEL_124;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v111 = "nw_http2_save_metadata_from_frame";
            v52 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(type) = 16;
            LOBYTE(v108) = 0;
            if (__nwlog_fault(v52, &type, &v108))
            {
              if (type == 17)
              {
                v53 = __nwlog_obj();
                v54 = type;
                if (os_log_type_enabled(v53, (os_log_type_t)type))
                {
                  *(_DWORD *)buf = 136446210;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v55 = "%{public}s metadata must be http";
LABEL_205:
                  _os_log_impl(&dword_182FBE000, v53, v54, v55, buf, 0xCu);
                }
              }
              else if ((_BYTE)v108)
              {
                v87 = (char *)__nw_create_backtrace_string();
                v53 = __nwlog_obj();
                v54 = type;
                v105 = os_log_type_enabled(v53, (os_log_type_t)type);
                if (v87)
                {
                  if (v105)
                  {
                    *(_DWORD *)buf = 136446466;
                    v111 = "nw_http2_save_metadata_from_frame";
                    v112 = 2082;
                    *(_QWORD *)v113 = v87;
                    v89 = "%{public}s metadata must be http, dumping backtrace:%{public}s";
                    goto LABEL_188;
                  }
                  goto LABEL_189;
                }
                if (v105)
                {
                  *(_DWORD *)buf = 136446210;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v55 = "%{public}s metadata must be http, no backtrace";
                  goto LABEL_205;
                }
              }
              else
              {
                v53 = __nwlog_obj();
                v54 = type;
                if (os_log_type_enabled(v53, (os_log_type_t)type))
                {
                  *(_DWORD *)buf = 136446210;
                  v111 = "nw_http2_save_metadata_from_frame";
                  v55 = "%{public}s metadata must be http, backtrace limit exceeded";
                  goto LABEL_205;
                }
              }
            }
          }
          else
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v111 = "nw_http2_save_metadata_from_frame";
            v52 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(type) = 16;
            LOBYTE(v108) = 0;
            if (!__nwlog_fault(v52, &type, &v108))
              goto LABEL_206;
            if (type == 17)
            {
              v53 = __nwlog_obj();
              v54 = type;
              if (!os_log_type_enabled(v53, (os_log_type_t)type))
                goto LABEL_206;
              *(_DWORD *)buf = 136446210;
              v111 = "nw_http2_save_metadata_from_frame";
              v55 = "%{public}s cannot send on a new stream without outbound metadata";
              goto LABEL_205;
            }
            if (!(_BYTE)v108)
            {
              v53 = __nwlog_obj();
              v54 = type;
              if (!os_log_type_enabled(v53, (os_log_type_t)type))
                goto LABEL_206;
              *(_DWORD *)buf = 136446210;
              v111 = "nw_http2_save_metadata_from_frame";
              v55 = "%{public}s cannot send on a new stream without outbound metadata, backtrace limit exceeded";
              goto LABEL_205;
            }
            v83 = (char *)__nw_create_backtrace_string();
            v53 = __nwlog_obj();
            v54 = type;
            v84 = os_log_type_enabled(v53, (os_log_type_t)type);
            if (!v83)
            {
              if (!v84)
                goto LABEL_206;
              *(_DWORD *)buf = 136446210;
              v111 = "nw_http2_save_metadata_from_frame";
              v55 = "%{public}s cannot send on a new stream without outbound metadata, no backtrace";
              goto LABEL_205;
            }
            if (v84)
            {
              *(_DWORD *)buf = 136446466;
              v111 = "nw_http2_save_metadata_from_frame";
              v112 = 2082;
              *(_QWORD *)v113 = v83;
              _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s cannot send on a new stream without outbound metadata, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v83);
          }
LABEL_206:
          if (!v52)
            goto LABEL_208;
          goto LABEL_207;
        }
        if (*(__int16 *)(v11 + 376) < 0)
          goto LABEL_142;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v40 = *(_DWORD *)(v11 + 368);
        *(_DWORD *)buf = 136447234;
        v111 = "nw_protocol_http2_frame_output_finalizer";
        v112 = 2082;
        *(_QWORD *)v113 = v11 + 378;
        *(_WORD *)&v113[8] = 2080;
        *(_QWORD *)&v113[10] = " ";
        *(_WORD *)&v113[18] = 1024;
        *(_DWORD *)&v113[20] = v40;
        *(_WORD *)&v113[24] = 2048;
        *(_QWORD *)&v113[26] = a1;
        v31 = (const char *)_os_log_send_and_compose_impl();
        LOBYTE(type) = 16;
        LOBYTE(v108) = 0;
        if (!__nwlog_fault(v31, &type, &v108))
          goto LABEL_139;
        if (type == 17)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v41 = gconnectionLogObj;
          v42 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type))
          {
            v43 = *(_DWORD *)(v11 + 368);
            *(_DWORD *)buf = 136447234;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v11 + 378;
            *(_WORD *)&v113[8] = 2080;
            *(_QWORD *)&v113[10] = " ";
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v43;
            *(_WORD *)&v113[24] = 2048;
            *(_QWORD *)&v113[26] = a1;
            v35 = "%{public}s %{public}s%s<i%u> stream not found for frame %p";
LABEL_137:
            v65 = v41;
            v66 = v42;
            v67 = 48;
            goto LABEL_138;
          }
        }
        else if ((_BYTE)v108)
        {
          v47 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v41 = gconnectionLogObj;
          v42 = type;
          v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type);
          if (v47)
          {
            if (v48)
            {
              v49 = *(_DWORD *)(v11 + 368);
              *(_DWORD *)buf = 136447490;
              v111 = "nw_protocol_http2_frame_output_finalizer";
              v112 = 2082;
              *(_QWORD *)v113 = v11 + 378;
              *(_WORD *)&v113[8] = 2080;
              *(_QWORD *)&v113[10] = " ";
              *(_WORD *)&v113[18] = 1024;
              *(_DWORD *)&v113[20] = v49;
              *(_WORD *)&v113[24] = 2048;
              *(_QWORD *)&v113[26] = a1;
              *(_WORD *)&v113[34] = 2082;
              *(_QWORD *)&v113[36] = v47;
              _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s %{public}s%s<i%u> stream not found for frame %p, dumping backtrace:%{public}s", buf, 0x3Au);
            }
            free(v47);
            if (!v31)
              goto LABEL_142;
LABEL_140:
            v79 = (char *)v31;
LABEL_141:
            free(v79);
            goto LABEL_142;
          }
          if (v48)
          {
            v78 = *(_DWORD *)(v11 + 368);
            *(_DWORD *)buf = 136447234;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v11 + 378;
            *(_WORD *)&v113[8] = 2080;
            *(_QWORD *)&v113[10] = " ";
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v78;
            *(_WORD *)&v113[24] = 2048;
            *(_QWORD *)&v113[26] = a1;
            v35 = "%{public}s %{public}s%s<i%u> stream not found for frame %p, no backtrace";
            goto LABEL_137;
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v41 = gconnectionLogObj;
          v42 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type))
          {
            v68 = *(_DWORD *)(v11 + 368);
            *(_DWORD *)buf = 136447234;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v11 + 378;
            *(_WORD *)&v113[8] = 2080;
            *(_QWORD *)&v113[10] = " ";
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v68;
            *(_WORD *)&v113[24] = 2048;
            *(_QWORD *)&v113[26] = a1;
            v35 = "%{public}s %{public}s%s<i%u> stream not found for frame %p, backtrace limit exceeded";
            goto LABEL_137;
          }
        }
      }
      else
      {
        if (*(__int16 *)(v11 + 376) < 0)
          goto LABEL_142;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v30 = *(_DWORD *)(v11 + 368);
        *(_DWORD *)buf = 136446978;
        v111 = "nw_protocol_http2_frame_output_finalizer";
        v112 = 2082;
        *(_QWORD *)v113 = v11 + 378;
        *(_WORD *)&v113[8] = 2080;
        *(_QWORD *)&v113[10] = " ";
        *(_WORD *)&v113[18] = 1024;
        *(_DWORD *)&v113[20] = v30;
        v31 = (const char *)_os_log_send_and_compose_impl();
        LOBYTE(type) = 16;
        LOBYTE(v108) = 0;
        if (__nwlog_fault(v31, &type, &v108))
        {
          if (type == 17)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v32 = gconnectionLogObj;
            v33 = type;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type))
              goto LABEL_139;
            v34 = *(_DWORD *)(v11 + 368);
            *(_DWORD *)buf = 136446978;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v11 + 378;
            *(_WORD *)&v113[8] = 2080;
            *(_QWORD *)&v113[10] = " ";
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v34;
            v35 = "%{public}s %{public}s%s<i%u> input_protocol not found";
          }
          else if ((_BYTE)v108)
          {
            v44 = (char *)__nw_create_backtrace_string();
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v32 = gconnectionLogObj;
            v33 = type;
            v45 = os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type);
            if (v44)
            {
              if (v45)
              {
                v46 = *(_DWORD *)(v11 + 368);
                *(_DWORD *)buf = 136447234;
                v111 = "nw_protocol_http2_frame_output_finalizer";
                v112 = 2082;
                *(_QWORD *)v113 = v11 + 378;
                *(_WORD *)&v113[8] = 2080;
                *(_QWORD *)&v113[10] = " ";
                *(_WORD *)&v113[18] = 1024;
                *(_DWORD *)&v113[20] = v46;
                *(_WORD *)&v113[24] = 2082;
                *(_QWORD *)&v113[26] = v44;
                _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s %{public}s%s<i%u> input_protocol not found, dumping backtrace:%{public}s", buf, 0x30u);
              }
              free(v44);
              goto LABEL_139;
            }
            if (!v45)
              goto LABEL_139;
            v64 = *(_DWORD *)(v11 + 368);
            *(_DWORD *)buf = 136446978;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v11 + 378;
            *(_WORD *)&v113[8] = 2080;
            *(_QWORD *)&v113[10] = " ";
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v64;
            v35 = "%{public}s %{public}s%s<i%u> input_protocol not found, no backtrace";
          }
          else
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v32 = gconnectionLogObj;
            v33 = type;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type))
              goto LABEL_139;
            v56 = *(_DWORD *)(v11 + 368);
            *(_DWORD *)buf = 136446978;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v11 + 378;
            *(_WORD *)&v113[8] = 2080;
            *(_QWORD *)&v113[10] = " ";
            *(_WORD *)&v113[18] = 1024;
            *(_DWORD *)&v113[20] = v56;
            v35 = "%{public}s %{public}s%s<i%u> input_protocol not found, backtrace limit exceeded";
          }
          v65 = v32;
          v66 = v33;
          v67 = 38;
LABEL_138:
          _os_log_impl(&dword_182FBE000, v65, v66, v35, buf, v67);
        }
      }
LABEL_139:
      if (!v31)
        goto LABEL_142;
      goto LABEL_140;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    v3 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v108) = 0;
    if (__nwlog_fault(v3, &type, &v108))
    {
      if (type == 17)
      {
        v4 = __nwlog_obj();
        v5 = type;
        if (os_log_type_enabled(v4, (os_log_type_t)type))
        {
          *(_DWORD *)buf = 136446210;
          v111 = "nw_protocol_http2_frame_output_finalizer";
          v6 = "%{public}s called with null http2";
          goto LABEL_41;
        }
      }
      else if ((_BYTE)v108)
      {
        v14 = (char *)__nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v97 = os_log_type_enabled(v4, (os_log_type_t)type);
        if (v14)
        {
          if (v97)
          {
            *(_DWORD *)buf = 136446466;
            v111 = "nw_protocol_http2_frame_output_finalizer";
            v112 = 2082;
            *(_QWORD *)v113 = v14;
            v16 = "%{public}s called with null http2, dumping backtrace:%{public}s";
            goto LABEL_16;
          }
          goto LABEL_17;
        }
        if (v97)
        {
          *(_DWORD *)buf = 136446210;
          v111 = "nw_protocol_http2_frame_output_finalizer";
          v6 = "%{public}s called with null http2, no backtrace";
          goto LABEL_41;
        }
      }
      else
      {
        v4 = __nwlog_obj();
        v5 = type;
        if (os_log_type_enabled(v4, (os_log_type_t)type))
        {
          *(_DWORD *)buf = 136446210;
          v111 = "nw_protocol_http2_frame_output_finalizer";
          v6 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
    }
LABEL_42:
    if (v3)
      goto LABEL_43;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v111 = "nw_protocol_http2_frame_output_finalizer";
  v3 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(type) = 16;
  LOBYTE(v108) = 0;
  if (!__nwlog_fault(v3, &type, &v108))
    goto LABEL_42;
  if (type == 17)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, (os_log_type_t)type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    v6 = "%{public}s called with null output_metadata";
    goto LABEL_41;
  }
  if (!(_BYTE)v108)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (os_log_type_enabled(v4, (os_log_type_t)type))
    {
      *(_DWORD *)buf = 136446210;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      v6 = "%{public}s called with null output_metadata, backtrace limit exceeded";
      goto LABEL_41;
    }
    goto LABEL_42;
  }
  v14 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v96 = os_log_type_enabled(v4, (os_log_type_t)type);
  if (!v14)
  {
    if (v96)
    {
      *(_DWORD *)buf = 136446210;
      v111 = "nw_protocol_http2_frame_output_finalizer";
      v6 = "%{public}s called with null output_metadata, no backtrace";
      goto LABEL_41;
    }
    goto LABEL_42;
  }
  if (v96)
  {
    *(_DWORD *)buf = 136446466;
    v111 = "nw_protocol_http2_frame_output_finalizer";
    v112 = 2082;
    *(_QWORD *)v113 = v14;
    v16 = "%{public}s called with null output_metadata, dumping backtrace:%{public}s";
    goto LABEL_16;
  }
LABEL_17:
  free(v14);
  if (v3)
LABEL_43:
    free(v3);
}

BOOL nw_http2_submit_message(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  _BYTE *v8;
  int v9;
  int v10;
  uint64_t v11;
  _BOOL8 result;
  int v13;
  int v14;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint32_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  int v24;
  int v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  int v29;
  int v30;
  const char *v31;
  int v32;
  uint64_t v33;
  char *backtrace_string;
  _BOOL4 v35;
  int v36;
  int v37;
  int v38;
  int v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  int v43;
  int v44;
  const char *v45;
  uint64_t v46;
  NSObject *v47;
  _BOOL4 v48;
  const char *v49;
  int v50;
  int v51;
  const char *v52;
  int v53;
  int v54;
  uint64_t v55;
  void (*v56)(_QWORD *, uint64_t, uint64_t);
  uint64_t v57;
  void (*v58)(_QWORD *, uint64_t);
  char *v59;
  _BOOL4 v60;
  int v61;
  int v62;
  int v63;
  int v64;
  id v65;
  void *v66;
  uint64_t v67;
  _BOOL4 has_method;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  id v75;
  __int16 v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  unsigned int v80;
  void *v81;
  id v82;
  os_log_type_t *v83;
  id *v84;
  id v85;
  BOOL is_equal_unsafe;
  os_log_type_t *v87;
  char *v88;
  char *v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  NSObject *v99;
  const char *v100;
  const char *v101;
  int v102;
  int v103;
  int v104;
  uint64_t v105;
  char *v106;
  NSObject *v107;
  os_log_type_t v108;
  uint64_t v109;
  const char *v110;
  int v111;
  int v112;
  NSObject *v113;
  os_log_type_t v114;
  uint32_t v115;
  uint64_t v116;
  int v117;
  int v118;
  char *v119;
  NSObject *v120;
  _BOOL4 v121;
  uint64_t v122;
  uint64_t v123;
  NSObject *v124;
  int v125;
  int v126;
  int v127;
  uint64_t v128;
  int v129;
  int v130;
  const char *v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  const char *v136;
  NSObject *v137;
  os_log_type_t v138;
  uint32_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  char v145;
  unsigned __int16 *v146;
  unsigned int v147;
  int v148;
  int v149;
  int v150;
  char *v151;
  NSObject *v152;
  os_log_type_t v153;
  int v154;
  int v155;
  const char *v156;
  int v157;
  int v158;
  NSObject *v159;
  os_log_type_t v160;
  int v161;
  int v162;
  NSObject *v163;
  int v164;
  int v165;
  const char *v166;
  char *v167;
  _BOOL4 v168;
  int v169;
  int v170;
  char *v171;
  _BOOL4 v172;
  int v173;
  int v174;
  int v175;
  int v176;
  NSObject *v177;
  int v178;
  int v179;
  int v180;
  NSObject *v181;
  int v182;
  int v183;
  int v184;
  NSObject *v185;
  int v186;
  int v187;
  uint64_t v188;
  char *v189;
  NSObject *v190;
  os_log_type_t v191;
  uint64_t v192;
  const char *v193;
  NSObject *v194;
  int v195;
  int v196;
  uint64_t v197;
  char *v198;
  _BOOL4 v199;
  uint64_t v200;
  int v201;
  int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  NSObject *v207;
  os_log_type_t v208;
  uint32_t v209;
  NSObject *v210;
  int v211;
  int v212;
  int v213;
  int v214;
  NSObject *v215;
  int v216;
  int v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  int v221;
  int v222;
  NSObject *v223;
  uint32_t v224;
  uint64_t v225;
  int v226;
  int v227;
  void *v228;
  char *v229;
  NSObject *v230;
  os_log_type_t v231;
  int v232;
  int v233;
  uint64_t v234;
  void *v235;
  const char *v236;
  char *v237;
  _BOOL4 v238;
  int v239;
  int v240;
  uint64_t v241;
  void *v242;
  char *v243;
  NSObject *v244;
  os_log_type_t v245;
  const char *v246;
  NSObject *v247;
  int v248;
  int v249;
  int v250;
  int v251;
  uint64_t v252;
  void *v253;
  uint64_t v254;
  int v255;
  int v256;
  char *v257;
  NSObject *v258;
  os_log_type_t v259;
  const char *v260;
  NSObject *v261;
  _BOOL4 v262;
  const char *v263;
  int v264;
  int v265;
  const char *v266;
  char *v267;
  _BOOL4 v268;
  int v269;
  int v270;
  uint64_t v271;
  void *v272;
  const char *v273;
  char *v274;
  NSObject *v275;
  os_log_type_t v276;
  const char *v277;
  const char *v278;
  char *v279;
  _BOOL4 v280;
  void *v281;
  NSObject *v282;
  os_log_type_t v283;
  void *v284;
  os_log_type_t v285;
  char *v286;
  _BOOL4 v287;
  const char *v288;
  char *v289;
  NSObject *v290;
  os_log_type_t v291;
  const char *v292;
  char *v293;
  _BOOL4 v294;
  int v295;
  int v296;
  char *v297;
  os_log_type_t v298;
  _BOOL4 v299;
  os_log_type_t v300;
  _BOOL4 v301;
  NSObject *v302;
  int v303;
  int v304;
  const char *v305;
  char *v306;
  NSObject *v307;
  os_log_type_t v308;
  const char *v309;
  NSObject *v310;
  int v311;
  int v312;
  const char *v313;
  void *v314;
  NSObject *v315;
  os_log_type_t v316;
  const char *v317;
  const char *v318;
  const char *v319;
  NSObject *v320;
  os_log_type_t v321;
  const char *v322;
  char *v323;
  _BOOL4 v324;
  const char *v325;
  const char *v326;
  const char *v327;
  os_log_type_t v328;
  os_log_type_t v329;
  char *v330;
  _BOOL4 v331;
  char *v332;
  _BOOL4 v333;
  char *v334;
  _BOOL4 v335;
  const char *v336;
  _BOOL4 v337;
  _BOOL4 v338;
  NSObject *v339;
  int v340;
  int v341;
  int v342;
  int v343;
  uint64_t v344;
  int v345;
  int v346;
  int v347;
  int v348;
  void *v349;
  BOOL v350;
  void *object;
  char v352;
  _QWORD v353[5];
  os_log_type_t v354[8];
  int v355;
  os_log_type_t type[8];
  uint64_t v357;
  void (*v358)(_QWORD *, char *, int64_t, char *, int64_t, int);
  void *v359;
  _QWORD *v360;
  _QWORD *v361;
  uint64_t v362;
  uint64_t v363;
  _QWORD v364[4];
  _QWORD v365[5];
  _QWORD v366[5];
  uint64_t v367;
  os_log_type_t v368;
  _QWORD buf[3];
  __int128 v370;
  void *v371[3];
  __int16 v372;
  char *v373;
  _QWORD v374[3];
  void *v375;
  os_log_type_t *v376;
  int v377;
  uint64_t v378;

  v378 = *MEMORY[0x1E0C80C00];
  v8 = &unk_1ECD84000;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v210 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v212 = *(_DWORD *)(a3 + 176);
      v211 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(_QWORD *)&v370 = " ";
      WORD4(v370) = 1024;
      *(_DWORD *)((char *)&v370 + 10) = v211;
      HIWORD(v370) = 1024;
      LODWORD(v371[0]) = v212;
      _os_log_impl(&dword_182FBE000, v210, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", (uint8_t *)buf, 0x2Cu);
    }
  }
  v9 = *(unsigned __int16 *)(a3 + 188);
  v10 = v9 | (*(unsigned __int8 *)(a3 + 190) << 16);
  if ((v9 & 1) == 0)
  {
    if ((v10 & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = gconnectionLogObj;
      result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        v14 = *(_DWORD *)(a3 + 176);
        v13 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447746;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = " ";
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v13;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v14;
        WORD2(v371[0]) = 2048;
        *(void **)((char *)v371 + 6) = a2;
        HIWORD(v371[1]) = 2048;
        v371[2] = (void *)a3;
        v15 = "%{public}s %{public}s%s<i%u:s%d> ERROR: Cannot send headers on a stream that is not considered open (proto"
              "col %p, stream %p)";
        v16 = v11;
        v17 = OS_LOG_TYPE_ERROR;
        v18 = 64;
LABEL_9:
        _os_log_impl(&dword_182FBE000, v16, v17, v15, (uint8_t *)buf, v18);
        return 0;
      }
      return result;
    }
    return 0;
  }
  if (!*(_QWORD *)(a3 + 104))
  {
    if ((v10 & 0x80000) != 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v25 = *(_DWORD *)(a3 + 176);
    v24 = *(_DWORD *)(a3 + 180);
    LODWORD(buf[0]) = 136447234;
    *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
    HIWORD(buf[2]) = 2080;
    *(_QWORD *)&v370 = " ";
    WORD4(v370) = 1024;
    *(_DWORD *)((char *)&v370 + 10) = v24;
    HIWORD(v370) = 1024;
    LODWORD(v371[0]) = v25;
    v26 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v374[0]) = 0;
    if (__nwlog_fault(v26, type, v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v27 = gconnectionLogObj;
        v28 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          goto LABEL_97;
        v30 = *(_DWORD *)(a3 + 176);
        v29 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447234;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = " ";
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v29;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v30;
        v31 = "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata";
        goto LABEL_96;
      }
      if (!LOBYTE(v374[0]))
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v27 = gconnectionLogObj;
        v28 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          goto LABEL_97;
        v64 = *(_DWORD *)(a3 + 176);
        v63 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447234;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = " ";
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v63;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v64;
        v31 = "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata, backtrace limit exceeded";
        goto LABEL_96;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v27 = gconnectionLogObj;
      v28 = type[0];
      v35 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
      if (backtrace_string)
      {
        if (v35)
        {
          v37 = *(_DWORD *)(a3 + 176);
          v36 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(_QWORD *)&v370 = " ";
          WORD4(v370) = 1024;
          *(_DWORD *)((char *)&v370 + 10) = v36;
          HIWORD(v370) = 1024;
          LODWORD(v371[0]) = v37;
          WORD2(v371[0]) = 2082;
          *(void **)((char *)v371 + 6) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata, dumping backtrace:%{public}s", (uint8_t *)buf, 0x36u);
        }
        free(backtrace_string);
        goto LABEL_97;
      }
      if (v35)
      {
        v72 = *(_DWORD *)(a3 + 176);
        v71 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447234;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = " ";
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v71;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v72;
        v31 = "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata, no backtrace";
LABEL_96:
        _os_log_impl(&dword_182FBE000, v27, v28, v31, (uint8_t *)buf, 0x2Cu);
      }
    }
LABEL_97:
    if (v26)
      free(v26);
    return 0;
  }
  if ((v9 & 0x100) != 0)
  {
    if (a4)
    {
      v32 = *(_DWORD *)(a4 + 52);
      if (v32 && v32 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60)
        || (v33 = *(_QWORD *)(a4 + 64)) != 0 && (*(_BYTE *)(v33 + 66) & 0x40) != 0)
      {
LABEL_185:
        if (*(_QWORD *)(a3 + 16))
        {
          if ((v10 & 0x80000) != 0 || !v8[1345])
            goto LABEL_195;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v128 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            goto LABEL_195;
          v130 = *(_DWORD *)(a3 + 176);
          v129 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(_QWORD *)&v370 = " ";
          WORD4(v370) = 1024;
          *(_DWORD *)((char *)&v370 + 10) = v129;
          HIWORD(v370) = 1024;
          LODWORD(v371[0]) = v130;
          WORD2(v371[0]) = 2048;
          *(void **)((char *)v371 + 6) = (void *)a4;
          v131 = "%{public}s %{public}s%s<i%u:s%d> stream already has pending data, pending frame %p for future send";
          goto LABEL_465;
        }
        if ((v10 & 2) == 0)
        {
          if ((v10 & 0x80000) != 0 || !v8[1345])
            goto LABEL_195;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v128 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            goto LABEL_195;
          v296 = *(_DWORD *)(a3 + 176);
          v295 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(_QWORD *)&v370 = " ";
          WORD4(v370) = 1024;
          *(_DWORD *)((char *)&v370 + 10) = v295;
          HIWORD(v370) = 1024;
          LODWORD(v371[0]) = v296;
          WORD2(v371[0]) = 2048;
          *(void **)((char *)v371 + 6) = (void *)a4;
          v131 = "%{public}s %{public}s%s<i%u:s%d> stream is not open yet, cannot submit frame %p, pending for future send";
LABEL_465:
          v223 = v128;
          v224 = 54;
LABEL_466:
          _os_log_impl(&dword_182FBE000, v223, OS_LOG_TYPE_DEBUG, v131, (uint8_t *)buf, v224);
LABEL_195:
          nw_http2_enqueue_frame_for_stream(a3, a4);
          return 1;
        }
        if (_nw_signposts_once != -1)
          dispatch_once(&_nw_signposts_once, &__block_literal_global_25_81469);
        if (_nw_signposts_enabled && kdebug_is_enabled())
        {
          kdebug_trace();
          v132 = *(_DWORD *)(a4 + 52);
          if (v132)
          {
LABEL_203:
            if (v132 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60))
              goto LABEL_212;
          }
        }
        else
        {
          v132 = *(_DWORD *)(a4 + 52);
          if (v132)
            goto LABEL_203;
        }
        v133 = *(_QWORD *)(a4 + 64);
        if (!v133 || (*(_BYTE *)(v133 + 66) & 0x40) == 0)
        {
          if (*(__int16 *)(a1 + 376) < 0 || !v8[1345])
            goto LABEL_37;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v134 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            goto LABEL_37;
          v135 = *(_DWORD *)(a1 + 368);
          LODWORD(buf[0]) = 136446978;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = a1 + 378;
          HIWORD(buf[2]) = 2080;
          *(_QWORD *)&v370 = " ";
          WORD4(v370) = 1024;
          *(_DWORD *)((char *)&v370 + 10) = v135;
          v136 = "%{public}s %{public}s%s<i%u> skipping empty frame body";
          v137 = v134;
          v138 = OS_LOG_TYPE_DEBUG;
          v139 = 38;
          goto LABEL_643;
        }
LABEL_212:
        if ((*(_WORD *)(a4 + 204) & 4) != 0)
        {
          v140 = *(_QWORD *)(a4 + 216);
          if (v140)
          {
            v141 = *(_QWORD *)(v140 + 56);
            if (v141)
            {
              v142 = *(_QWORD *)(v141 + 32);
              if (v142)
              {
                v143 = *(_DWORD *)(v142 + 176);
                v374[0] = a4;
                v374[1] = data_source_read_callback;
                v144 = *(_QWORD *)(a4 + 64);
                if (v144)
                {
                  v145 = *(_BYTE *)(v144 + 66);
                  v146 = (unsigned __int16 *)(v142 + 188);
                  v147 = *(unsigned __int16 *)(v142 + 188) | (*(unsigned __int8 *)(v142 + 190) << 16);
                  if ((v145 & 0x40) != 0)
                  {
                    v148 = (v147 >> 19) & 1;
                    if (!v8[1345])
                      LOBYTE(v148) = 1;
                    if ((*(_WORD *)(v142 + 188) & 0x200) == 0)
                    {
                      if ((v148 & 1) == 0)
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v339 = gconnectionLogObj;
                        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                        {
                          v341 = *(_DWORD *)(v142 + 176);
                          v340 = *(_DWORD *)(v142 + 180);
                          LODWORD(buf[0]) = 136447234;
                          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                          WORD2(buf[1]) = 2082;
                          *(_QWORD *)((char *)&buf[1] + 6) = v142 + 191;
                          HIWORD(buf[2]) = 2080;
                          *(_QWORD *)&v370 = " ";
                          WORD4(v370) = 1024;
                          *(_DWORD *)((char *)&v370 + 10) = v340;
                          HIWORD(v370) = 1024;
                          LODWORD(v371[0]) = v341;
                          _os_log_impl(&dword_182FBE000, v339, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> frame is complete, marking end stream", (uint8_t *)buf, 0x2Cu);
                        }
                      }
                      goto LABEL_268;
                    }
                    if ((v148 & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v163 = gconnectionLogObj;
                      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                      {
                        v343 = *(_DWORD *)(v142 + 176);
                        v342 = *(_DWORD *)(v142 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = v142 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(_QWORD *)&v370 = " ";
                        WORD4(v370) = 1024;
                        *(_DWORD *)((char *)&v370 + 10) = v342;
                        HIWORD(v370) = 1024;
                        LODWORD(v371[0]) = v343;
                        v166 = "%{public}s %{public}s%s<i%u:s%d> stream is in CONNECT mode, not marking end stream";
                        goto LABEL_251;
                      }
                    }
                    goto LABEL_268;
                  }
                }
                else
                {
                  v146 = (unsigned __int16 *)(v142 + 188);
                  v147 = *(unsigned __int16 *)(v142 + 188) | (*(unsigned __int8 *)(v142 + 190) << 16);
                }
                if ((v147 & 0x80000) == 0 && v8[1345])
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v163 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    v165 = *(_DWORD *)(v142 + 176);
                    v164 = *(_DWORD *)(v142 + 180);
                    LODWORD(buf[0]) = 136447234;
                    *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                    WORD2(buf[1]) = 2082;
                    *(_QWORD *)((char *)&buf[1] + 6) = v142 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(_QWORD *)&v370 = " ";
                    WORD4(v370) = 1024;
                    *(_DWORD *)((char *)&v370 + 10) = v164;
                    HIWORD(v370) = 1024;
                    LODWORD(v371[0]) = v165;
                    v166 = "%{public}s %{public}s%s<i%u:s%d> frame is not complete, not marking end stream";
LABEL_251:
                    _os_log_impl(&dword_182FBE000, v163, OS_LOG_TYPE_DEBUG, v166, (uint8_t *)buf, 0x2Cu);
                  }
                }
LABEL_268:
                v175 = nghttp2_submit_data();
                if (!v175)
                {
                  if (((*v146 | (*((unsigned __int8 *)v146 + 2) << 16)) & 0x80000) == 0 && v8[1345])
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v181 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      v182 = *(_DWORD *)(v142 + 176);
                      v183 = *(_DWORD *)(v142 + 180);
                      v184 = *(_DWORD *)(a4 + 52);
                      if (v184)
                        v184 -= *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60);
                      LODWORD(buf[0]) = 136447746;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = v142 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v183;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v182;
                      WORD2(v371[0]) = 1024;
                      *(_DWORD *)((char *)v371 + 6) = v184;
                      WORD1(v371[1]) = 1024;
                      HIDWORD(v371[1]) = v143;
                      _os_log_impl(&dword_182FBE000, v181, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> submitted %u bytes on stream %d", (uint8_t *)buf, 0x38u);
                    }
                  }
                  return 1;
                }
                v176 = v175;
                if (v175 == -510)
                {
                  if (((*v146 | (*((unsigned __int8 *)v146 + 2) << 16)) & 0x80000) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v185 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
                    {
                      v187 = *(_DWORD *)(v142 + 176);
                      v186 = *(_DWORD *)(v142 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = v142 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v186;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v187;
                      WORD2(v371[0]) = 1024;
                      *(_DWORD *)((char *)v371 + 6) = v143;
                      _os_log_impl(&dword_182FBE000, v185, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> stream %d is closed, cannot send frames", (uint8_t *)buf, 0x32u);
                    }
                  }
                  goto LABEL_637;
                }
                if (v175 == -529)
                {
                  if (((*v146 | (*((unsigned __int8 *)v146 + 2) << 16)) & 0x80000) == 0 && v8[1345])
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v177 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      v178 = *(_DWORD *)(v142 + 176);
                      v179 = *(_DWORD *)(v142 + 180);
                      v180 = *(_DWORD *)(a4 + 52);
                      if (v180)
                        v180 -= *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60);
                      LODWORD(buf[0]) = 136447746;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = v142 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v179;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v178;
                      WORD2(v371[0]) = 1024;
                      *(_DWORD *)((char *)v371 + 6) = v143;
                      WORD1(v371[1]) = 1024;
                      HIDWORD(v371[1]) = v180;
                      _os_log_impl(&dword_182FBE000, v177, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> already have data outgoing on stream %d, cannot send %u bytes", (uint8_t *)buf, 0x38u);
                    }
                  }
LABEL_345:
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0
                    || !v8[1345])
                  {
                    goto LABEL_195;
                  }
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v220 = gconnectionLogObj;
                  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                    goto LABEL_195;
                  v222 = *(_DWORD *)(a3 + 176);
                  v221 = *(_DWORD *)(a3 + 180);
                  LODWORD(buf[0]) = 136447746;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                  HIWORD(buf[2]) = 2080;
                  *(_QWORD *)&v370 = " ";
                  WORD4(v370) = 1024;
                  *(_DWORD *)((char *)&v370 + 10) = v221;
                  HIWORD(v370) = 1024;
                  LODWORD(v371[0]) = v222;
                  WORD2(v371[0]) = 1024;
                  *(_DWORD *)((char *)v371 + 6) = v222;
                  WORD1(v371[1]) = 2048;
                  *(void **)((char *)&v371[1] + 4) = (void *)a4;
                  v131 = "%{public}s %{public}s%s<i%u:s%d> couldn't send frame on stream %d, adding frame %p to waiting_output_frames";
                  v223 = v220;
                  v224 = 60;
                  goto LABEL_466;
                }
                __nwlog_obj();
                v188 = nghttp2_strerror();
                LODWORD(buf[0]) = 136446722;
                *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                WORD2(buf[1]) = 2082;
                *(_QWORD *)((char *)&buf[1] + 6) = v188;
                HIWORD(buf[2]) = 1024;
                LODWORD(v370) = v143;
                v189 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v366[0]) = 16;
                LOBYTE(v365[0]) = 0;
                if (!__nwlog_fault(v189, v366, v365))
                  goto LABEL_342;
                if (LOBYTE(v366[0]) == 17)
                {
                  v190 = __nwlog_obj();
                  v191 = v366[0];
                  if (!os_log_type_enabled(v190, v366[0]))
                    goto LABEL_342;
                  v192 = nghttp2_strerror();
                  LODWORD(buf[0]) = 136446722;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v192;
                  HIWORD(buf[2]) = 1024;
                  LODWORD(v370) = v143;
                  v193 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed";
                }
                else if (LOBYTE(v365[0]))
                {
                  v198 = (char *)__nw_create_backtrace_string();
                  v190 = __nwlog_obj();
                  v191 = v366[0];
                  v199 = os_log_type_enabled(v190, v366[0]);
                  if (v198)
                  {
                    if (v199)
                    {
                      v200 = nghttp2_strerror();
                      LODWORD(buf[0]) = 136446978;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = v200;
                      HIWORD(buf[2]) = 1024;
                      LODWORD(v370) = v143;
                      WORD2(v370) = 2082;
                      *(_QWORD *)((char *)&v370 + 6) = v198;
                      _os_log_impl(&dword_182FBE000, v190, v191, "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, dumping backtrace:%{public}s", (uint8_t *)buf, 0x26u);
                    }
                    free(v198);
LABEL_342:
                    if (v189)
                      free(v189);
                    if (v176 == -529)
                      goto LABEL_345;
                    if ((*(_WORD *)(a1 + 376) & 8) == 0)
                    {
                      if (v176 != -1)
                      {
                        if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0)
                        {
LABEL_37:
                          nw_frame_cache_return_frame(a1 + 200, a4);
                          return 1;
                        }
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v225 = a3 + 191;
                        v227 = *(_DWORD *)(a3 + 176);
                        v226 = *(_DWORD *)(a3 + 180);
                        v228 = (void *)nghttp2_strerror();
                        LODWORD(buf[0]) = 136447746;
                        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(_QWORD *)&v370 = " ";
                        WORD4(v370) = 1024;
                        *(_DWORD *)((char *)&v370 + 10) = v226;
                        HIWORD(v370) = 1024;
                        LODWORD(v371[0]) = v227;
                        WORD2(v371[0]) = 2080;
                        *(void **)((char *)v371 + 6) = v228;
                        HIWORD(v371[1]) = 2048;
                        v371[2] = (void *)a4;
                        v229 = (char *)_os_log_send_and_compose_impl();
                        LOBYTE(v374[0]) = 16;
                        LOBYTE(v366[0]) = 0;
                        if (__nwlog_fault(v229, v374, v366))
                        {
                          if (LOBYTE(v374[0]) == 17)
                          {
                            if (__nwlog_connection_log::onceToken != -1)
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                            v230 = gconnectionLogObj;
                            v231 = v374[0];
                            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]))
                              goto LABEL_405;
                            v234 = a3 + 176;
                            v232 = *(_DWORD *)(a3 + 176);
                            v233 = *(_DWORD *)(v234 + 4);
                            v235 = (void *)nghttp2_strerror();
                            LODWORD(buf[0]) = 136447746;
                            *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                            WORD2(buf[1]) = 2082;
                            *(_QWORD *)((char *)&buf[1] + 6) = v225;
                            HIWORD(buf[2]) = 2080;
                            *(_QWORD *)&v370 = " ";
                            WORD4(v370) = 1024;
                            *(_DWORD *)((char *)&v370 + 10) = v233;
                            HIWORD(v370) = 1024;
                            LODWORD(v371[0]) = v232;
                            WORD2(v371[0]) = 2080;
                            *(void **)((char *)v371 + 6) = v235;
                            HIWORD(v371[1]) = 2048;
                            v371[2] = (void *)a4;
                            v236 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to cache";
                            goto LABEL_404;
                          }
                          if (!LOBYTE(v366[0]))
                          {
                            if (__nwlog_connection_log::onceToken != -1)
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                            v230 = gconnectionLogObj;
                            v231 = v374[0];
                            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]))
                              goto LABEL_405;
                            v252 = a3 + 176;
                            v250 = *(_DWORD *)(a3 + 176);
                            v251 = *(_DWORD *)(v252 + 4);
                            v253 = (void *)nghttp2_strerror();
                            LODWORD(buf[0]) = 136447746;
                            *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                            WORD2(buf[1]) = 2082;
                            *(_QWORD *)((char *)&buf[1] + 6) = v225;
                            HIWORD(buf[2]) = 2080;
                            *(_QWORD *)&v370 = " ";
                            WORD4(v370) = 1024;
                            *(_DWORD *)((char *)&v370 + 10) = v251;
                            HIWORD(v370) = 1024;
                            LODWORD(v371[0]) = v250;
                            WORD2(v371[0]) = 2080;
                            *(void **)((char *)v371 + 6) = v253;
                            HIWORD(v371[1]) = 2048;
                            v371[2] = (void *)a4;
                            v236 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to ca"
                                   "che, backtrace limit exceeded";
                            goto LABEL_404;
                          }
                          v237 = (char *)__nw_create_backtrace_string();
                          if (__nwlog_connection_log::onceToken != -1)
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                          v230 = gconnectionLogObj;
                          v231 = v374[0];
                          v238 = os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]);
                          if (v237)
                          {
                            if (v238)
                            {
                              v241 = a3 + 176;
                              v239 = *(_DWORD *)(a3 + 176);
                              v240 = *(_DWORD *)(v241 + 4);
                              v242 = (void *)nghttp2_strerror();
                              LODWORD(buf[0]) = 136448002;
                              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                              WORD2(buf[1]) = 2082;
                              *(_QWORD *)((char *)&buf[1] + 6) = v225;
                              HIWORD(buf[2]) = 2080;
                              *(_QWORD *)&v370 = " ";
                              WORD4(v370) = 1024;
                              *(_DWORD *)((char *)&v370 + 10) = v240;
                              HIWORD(v370) = 1024;
                              LODWORD(v371[0]) = v239;
                              WORD2(v371[0]) = 2080;
                              *(void **)((char *)v371 + 6) = v242;
                              HIWORD(v371[1]) = 2048;
                              v371[2] = (void *)a4;
                              v372 = 2082;
                              v373 = v237;
                              _os_log_impl(&dword_182FBE000, v230, v231, "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to cache, dumping backtrace:%{public}s", (uint8_t *)buf, 0x4Au);
                            }
                            free(v237);
                            goto LABEL_405;
                          }
                          if (v238)
                          {
                            v271 = a3 + 176;
                            v269 = *(_DWORD *)(a3 + 176);
                            v270 = *(_DWORD *)(v271 + 4);
                            v272 = (void *)nghttp2_strerror();
                            LODWORD(buf[0]) = 136447746;
                            *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                            WORD2(buf[1]) = 2082;
                            *(_QWORD *)((char *)&buf[1] + 6) = v225;
                            HIWORD(buf[2]) = 2080;
                            *(_QWORD *)&v370 = " ";
                            WORD4(v370) = 1024;
                            *(_DWORD *)((char *)&v370 + 10) = v270;
                            HIWORD(v370) = 1024;
                            LODWORD(v371[0]) = v269;
                            WORD2(v371[0]) = 2080;
                            *(void **)((char *)v371 + 6) = v272;
                            HIWORD(v371[1]) = 2048;
                            v371[2] = (void *)a4;
                            v236 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to ca"
                                   "che, no backtrace";
LABEL_404:
                            _os_log_impl(&dword_182FBE000, v230, v231, v236, (uint8_t *)buf, 0x40u);
                          }
                        }
LABEL_405:
                        if (v229)
                          free(v229);
                        goto LABEL_37;
                      }
                      goto LABEL_632;
                    }
                    goto LABEL_637;
                  }
                  if (!v199)
                    goto LABEL_342;
                  v219 = nghttp2_strerror();
                  LODWORD(buf[0]) = 136446722;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v219;
                  HIWORD(buf[2]) = 1024;
                  LODWORD(v370) = v143;
                  v193 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, no backtrace";
                }
                else
                {
                  v190 = __nwlog_obj();
                  v191 = v366[0];
                  if (!os_log_type_enabled(v190, v366[0]))
                    goto LABEL_342;
                  v218 = nghttp2_strerror();
                  LODWORD(buf[0]) = 136446722;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v218;
                  HIWORD(buf[2]) = 1024;
                  LODWORD(v370) = v143;
                  v193 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, backtrace limit exceeded";
                }
                _os_log_impl(&dword_182FBE000, v190, v191, v193, (uint8_t *)buf, 0x1Cu);
                goto LABEL_342;
              }
              __nwlog_obj();
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v314 = (void *)_os_log_send_and_compose_impl();
              LOBYTE(v374[0]) = 16;
              LOBYTE(v366[0]) = 0;
              if (__nwlog_fault((const char *)v314, v374, v366))
              {
                if (LOBYTE(v374[0]) == 17)
                {
                  v315 = __nwlog_obj();
                  v316 = v374[0];
                  if (!os_log_type_enabled(v315, v374[0]))
                    goto LABEL_629;
                  LODWORD(buf[0]) = 136446210;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                  v317 = "%{public}s called with null stream";
                  goto LABEL_628;
                }
                if (!LOBYTE(v366[0]))
                {
                  v315 = __nwlog_obj();
                  v316 = v374[0];
                  if (!os_log_type_enabled(v315, v374[0]))
                    goto LABEL_629;
                  LODWORD(buf[0]) = 136446210;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                  v317 = "%{public}s called with null stream, backtrace limit exceeded";
                  goto LABEL_628;
                }
                v334 = (char *)__nw_create_backtrace_string();
                v315 = __nwlog_obj();
                v316 = v374[0];
                v338 = os_log_type_enabled(v315, v374[0]);
                if (!v334)
                {
                  if (!v338)
                    goto LABEL_629;
                  LODWORD(buf[0]) = 136446210;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                  v317 = "%{public}s called with null stream, no backtrace";
                  goto LABEL_628;
                }
                if (v338)
                {
                  LODWORD(buf[0]) = 136446466;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v334;
                  v336 = "%{public}s called with null stream, dumping backtrace:%{public}s";
                  goto LABEL_583;
                }
LABEL_584:
                free(v334);
                if (!v314)
                {
LABEL_631:
                  if ((*(_WORD *)(a1 + 376) & 8) == 0)
                  {
LABEL_632:
                    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0)
                      goto LABEL_37;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v344 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                      goto LABEL_37;
                    v346 = *(_DWORD *)(a3 + 176);
                    v345 = *(_DWORD *)(a3 + 180);
                    LODWORD(buf[0]) = 136447490;
                    *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                    WORD2(buf[1]) = 2082;
                    *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(_QWORD *)&v370 = " ";
                    WORD4(v370) = 1024;
                    *(_DWORD *)((char *)&v370 + 10) = v345;
                    HIWORD(v370) = 1024;
                    LODWORD(v371[0]) = v346;
                    WORD2(v371[0]) = 2048;
                    *(void **)((char *)v371 + 6) = (void *)a4;
                    v136 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data, returning frame %p to cache";
                    goto LABEL_642;
                  }
LABEL_637:
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0)
                    goto LABEL_37;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v344 = gconnectionLogObj;
                  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                    goto LABEL_37;
                  v348 = *(_DWORD *)(a3 + 176);
                  v347 = *(_DWORD *)(a3 + 180);
                  LODWORD(buf[0]) = 136447490;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                  HIWORD(buf[2]) = 2080;
                  *(_QWORD *)&v370 = " ";
                  WORD4(v370) = 1024;
                  *(_DWORD *)((char *)&v370 + 10) = v347;
                  HIWORD(v370) = 1024;
                  LODWORD(v371[0]) = v348;
                  WORD2(v371[0]) = 2048;
                  *(void **)((char *)v371 + 6) = (void *)a4;
                  v136 = "%{public}s %{public}s%s<i%u:s%d> tunnel is no longer connected or stream is closed, returning f"
                         "rame %p to cache";
LABEL_642:
                  v137 = v344;
                  v138 = OS_LOG_TYPE_ERROR;
                  v139 = 54;
LABEL_643:
                  _os_log_impl(&dword_182FBE000, v137, v138, v136, (uint8_t *)buf, v139);
                  goto LABEL_37;
                }
LABEL_630:
                free(v314);
                goto LABEL_631;
              }
LABEL_629:
              if (!v314)
                goto LABEL_631;
              goto LABEL_630;
            }
            __nwlog_obj();
            LODWORD(buf[0]) = 136446210;
            *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
            v314 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(v374[0]) = 16;
            LOBYTE(v366[0]) = 0;
            if (!__nwlog_fault((const char *)v314, v374, v366))
              goto LABEL_629;
            if (LOBYTE(v374[0]) == 17)
            {
              v315 = __nwlog_obj();
              v316 = v374[0];
              if (!os_log_type_enabled(v315, v374[0]))
                goto LABEL_629;
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v317 = "%{public}s called with null node";
              goto LABEL_628;
            }
            if (!LOBYTE(v366[0]))
            {
              v315 = __nwlog_obj();
              v316 = v374[0];
              if (!os_log_type_enabled(v315, v374[0]))
                goto LABEL_629;
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v317 = "%{public}s called with null node, backtrace limit exceeded";
              goto LABEL_628;
            }
            v334 = (char *)__nw_create_backtrace_string();
            v315 = __nwlog_obj();
            v316 = v374[0];
            v337 = os_log_type_enabled(v315, v374[0]);
            if (!v334)
            {
              if (!v337)
                goto LABEL_629;
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v317 = "%{public}s called with null node, no backtrace";
              goto LABEL_628;
            }
            if (!v337)
              goto LABEL_584;
            LODWORD(buf[0]) = 136446466;
            *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v334;
            v336 = "%{public}s called with null node, dumping backtrace:%{public}s";
LABEL_583:
            _os_log_impl(&dword_182FBE000, v315, v316, v336, (uint8_t *)buf, 0x16u);
            goto LABEL_584;
          }
          __nwlog_obj();
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
          v314 = (void *)_os_log_send_and_compose_impl();
          LOBYTE(v374[0]) = 16;
          LOBYTE(v366[0]) = 0;
          if (!__nwlog_fault((const char *)v314, v374, v366))
            goto LABEL_629;
          if (LOBYTE(v374[0]) != 17)
          {
            if (!LOBYTE(v366[0]))
            {
              v315 = __nwlog_obj();
              v316 = v374[0];
              if (!os_log_type_enabled(v315, v374[0]))
                goto LABEL_629;
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v317 = "%{public}s called with null input_protocol, backtrace limit exceeded";
              goto LABEL_628;
            }
            v334 = (char *)__nw_create_backtrace_string();
            v315 = __nwlog_obj();
            v316 = v374[0];
            v335 = os_log_type_enabled(v315, v374[0]);
            if (!v334)
            {
              if (!v335)
                goto LABEL_629;
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v317 = "%{public}s called with null input_protocol, no backtrace";
              goto LABEL_628;
            }
            if (!v335)
              goto LABEL_584;
            LODWORD(buf[0]) = 136446466;
            *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v334;
            v336 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
            goto LABEL_583;
          }
          v315 = __nwlog_obj();
          v316 = v374[0];
          if (!os_log_type_enabled(v315, v374[0]))
            goto LABEL_629;
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
          v317 = "%{public}s called with null input_protocol";
        }
        else
        {
          __nwlog_obj();
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
          v314 = (void *)_os_log_send_and_compose_impl();
          LOBYTE(v374[0]) = 16;
          LOBYTE(v366[0]) = 0;
          if (!__nwlog_fault((const char *)v314, v374, v366))
            goto LABEL_629;
          if (LOBYTE(v374[0]) != 17)
          {
            if (!LOBYTE(v366[0]))
            {
              v315 = __nwlog_obj();
              v316 = v374[0];
              if (!os_log_type_enabled(v315, v374[0]))
                goto LABEL_629;
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v317 = "%{public}s called with null output_context, backtrace limit exceeded";
              goto LABEL_628;
            }
            v332 = (char *)__nw_create_backtrace_string();
            v315 = __nwlog_obj();
            v316 = v374[0];
            v333 = os_log_type_enabled(v315, v374[0]);
            if (!v332)
            {
              if (!v333)
                goto LABEL_629;
              LODWORD(buf[0]) = 136446210;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              v317 = "%{public}s called with null output_context, no backtrace";
              goto LABEL_628;
            }
            if (v333)
            {
              LODWORD(buf[0]) = 136446466;
              *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
              WORD2(buf[1]) = 2082;
              *(_QWORD *)((char *)&buf[1] + 6) = v332;
              _os_log_impl(&dword_182FBE000, v315, v316, "%{public}s called with null output_context, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
            }
            free(v332);
            goto LABEL_629;
          }
          v315 = __nwlog_obj();
          v316 = v374[0];
          if (!os_log_type_enabled(v315, v374[0]))
            goto LABEL_629;
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_data";
          v317 = "%{public}s called with null output_context";
        }
LABEL_628:
        _os_log_impl(&dword_182FBE000, v315, v316, v317, (uint8_t *)buf, 0xCu);
        goto LABEL_629;
      }
LABEL_35:
      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0 || !v8[1345])
        goto LABEL_37;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v254 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        goto LABEL_37;
      v256 = *(_DWORD *)(a3 + 176);
      v255 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(_QWORD *)&v370 = " ";
      WORD4(v370) = 1024;
      *(_DWORD *)((char *)&v370 + 10) = v255;
      HIWORD(v370) = 1024;
      LODWORD(v371[0]) = v256;
      v136 = "%{public}s %{public}s%s<i%u:s%d> skipping empty frame body";
      v137 = v254;
      v138 = OS_LOG_TYPE_DEBUG;
      v139 = 44;
      goto LABEL_643;
    }
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
    v243 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v374[0]) = 0;
    if (__nwlog_fault(v243, type, v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v244 = __nwlog_obj();
        v245 = type[0];
        if (!os_log_type_enabled(v244, type[0]))
          goto LABEL_443;
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        v246 = "%{public}s called with null frame";
LABEL_442:
        _os_log_impl(&dword_182FBE000, v244, v245, v246, (uint8_t *)buf, 0xCu);
        goto LABEL_443;
      }
      if (!LOBYTE(v374[0]))
      {
        v244 = __nwlog_obj();
        v245 = type[0];
        if (!os_log_type_enabled(v244, type[0]))
          goto LABEL_443;
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        v246 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_442;
      }
      v267 = (char *)__nw_create_backtrace_string();
      v244 = __nwlog_obj();
      v245 = type[0];
      v268 = os_log_type_enabled(v244, type[0]);
      if (!v267)
      {
        if (!v268)
          goto LABEL_443;
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        v246 = "%{public}s called with null frame, no backtrace";
        goto LABEL_442;
      }
      if (v268)
      {
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v267;
        _os_log_impl(&dword_182FBE000, v244, v245, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
      }
      free(v267);
    }
LABEL_443:
    if (v243)
      free(v243);
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
    v289 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v374[0]) = 0;
    if (!__nwlog_fault(v289, type, v374))
      goto LABEL_459;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v290 = __nwlog_obj();
      v291 = type[0];
      if (!os_log_type_enabled(v290, type[0]))
        goto LABEL_459;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
      v292 = "%{public}s called with null frame";
    }
    else if (LOBYTE(v374[0]))
    {
      v293 = (char *)__nw_create_backtrace_string();
      v290 = __nwlog_obj();
      v291 = type[0];
      v294 = os_log_type_enabled(v290, type[0]);
      if (v293)
      {
        if (v294)
        {
          LODWORD(buf[0]) = 136446466;
          *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = v293;
          _os_log_impl(&dword_182FBE000, v290, v291, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        free(v293);
        goto LABEL_459;
      }
      if (!v294)
      {
LABEL_459:
        if (v289)
          free(v289);
        goto LABEL_35;
      }
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
      v292 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v290 = __nwlog_obj();
      v291 = type[0];
      if (!os_log_type_enabled(v290, type[0]))
        goto LABEL_459;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
      v292 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v290, v291, v292, (uint8_t *)buf, 0xCu);
    goto LABEL_459;
  }
  if ((v10 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v247 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v249 = *(_DWORD *)(a3 + 176);
      v248 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(_QWORD *)&v370 = " ";
      WORD4(v370) = 1024;
      *(_DWORD *)((char *)&v370 + 10) = v248;
      HIWORD(v370) = 1024;
      LODWORD(v371[0]) = v249;
      _os_log_impl(&dword_182FBE000, v247, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", (uint8_t *)buf, 0x2Cu);
    }
  }
  v19 = *(unsigned __int16 *)(a3 + 188);
  v20 = v19 | (*(unsigned __int8 *)(a3 + 190) << 16);
  if ((v19 & 0x100) != 0)
  {
    if ((v20 & 0x80000) != 0)
      goto LABEL_149;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v39 = *(_DWORD *)(a3 + 176);
    v38 = *(_DWORD *)(a3 + 180);
    LODWORD(buf[0]) = 136447490;
    *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
    HIWORD(buf[2]) = 2080;
    *(_QWORD *)&v370 = " ";
    WORD4(v370) = 1024;
    *(_DWORD *)((char *)&v370 + 10) = v38;
    HIWORD(v370) = 1024;
    LODWORD(v371[0]) = v39;
    WORD2(v371[0]) = 1024;
    *(_DWORD *)((char *)v371 + 6) = v39;
    v40 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v374[0]) = 0;
    if (__nwlog_fault(v40, type, v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v41 = gconnectionLogObj;
        v42 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          goto LABEL_147;
        v44 = *(_DWORD *)(a3 + 176);
        v43 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447490;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = " ";
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v43;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v44;
        WORD2(v371[0]) = 1024;
        *(_DWORD *)((char *)v371 + 6) = v44;
        v45 = "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again";
      }
      else if (LOBYTE(v374[0]))
      {
        v59 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v41 = gconnectionLogObj;
        v42 = type[0];
        v60 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
        if (v59)
        {
          if (v60)
          {
            v62 = *(_DWORD *)(a3 + 176);
            v61 = *(_DWORD *)(a3 + 180);
            LODWORD(buf[0]) = 136447746;
            *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
            HIWORD(buf[2]) = 2080;
            *(_QWORD *)&v370 = " ";
            WORD4(v370) = 1024;
            *(_DWORD *)((char *)&v370 + 10) = v61;
            HIWORD(v370) = 1024;
            LODWORD(v371[0]) = v62;
            WORD2(v371[0]) = 1024;
            *(_DWORD *)((char *)v371 + 6) = v62;
            WORD1(v371[1]) = 2082;
            *(void **)((char *)&v371[1] + 4) = v59;
            _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again, dumping backtrace:%{public}s", (uint8_t *)buf, 0x3Cu);
          }
          free(v59);
          goto LABEL_147;
        }
        if (!v60)
          goto LABEL_147;
        v112 = *(_DWORD *)(a3 + 176);
        v111 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447490;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = " ";
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v111;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v112;
        WORD2(v371[0]) = 1024;
        *(_DWORD *)((char *)v371 + 6) = v112;
        v45 = "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v41 = gconnectionLogObj;
        v42 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          goto LABEL_147;
        v74 = *(_DWORD *)(a3 + 176);
        v73 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447490;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = " ";
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v73;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v74;
        WORD2(v371[0]) = 1024;
        *(_DWORD *)((char *)v371 + 6) = v74;
        v45 = "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again, backtrace limit exceeded";
      }
      v113 = v41;
      v114 = v42;
      v115 = 50;
LABEL_146:
      _os_log_impl(&dword_182FBE000, v113, v114, v45, (uint8_t *)buf, v115);
    }
LABEL_147:
    if (!v40)
      goto LABEL_149;
    goto LABEL_148;
  }
  *(_BYTE *)(a3 + 190) = BYTE2(v20);
  *(_WORD *)(a3 + 188) = v20 | 0x100;
  if (a4)
  {
    v21 = *(_QWORD *)(a4 + 64);
    v23 = v21
       && (*(_BYTE *)(v21 + 66) & 0x40) != 0
       && ((v22 = *(_DWORD *)(a4 + 52)) == 0 || v22 == *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60))
       && (v20 & 0x200) == 0;
    goto LABEL_55;
  }
  __nwlog_obj();
  LODWORD(buf[0]) = 136446210;
  *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
  v257 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v374[0]) = 0;
  if (__nwlog_fault(v257, type, v374))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v258 = __nwlog_obj();
      v259 = type[0];
      if (os_log_type_enabled(v258, type[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        v260 = "%{public}s called with null frame";
LABEL_487:
        _os_log_impl(&dword_182FBE000, v258, v259, v260, (uint8_t *)buf, 0xCu);
      }
    }
    else if (LOBYTE(v374[0]))
    {
      v279 = (char *)__nw_create_backtrace_string();
      v258 = __nwlog_obj();
      v259 = type[0];
      v280 = os_log_type_enabled(v258, type[0]);
      if (v279)
      {
        if (v280)
        {
          LODWORD(buf[0]) = 136446466;
          *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = v279;
          _os_log_impl(&dword_182FBE000, v258, v259, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        free(v279);
        goto LABEL_488;
      }
      if (v280)
      {
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        v260 = "%{public}s called with null frame, no backtrace";
        goto LABEL_487;
      }
    }
    else
    {
      v258 = __nwlog_obj();
      v259 = type[0];
      if (os_log_type_enabled(v258, type[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        v260 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_487;
      }
    }
  }
LABEL_488:
  if (v257)
    free(v257);
  v23 = 0;
LABEL_55:
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_25_81469);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  v367 = a3;
  v46 = a3;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
  {
    v46 = a3;
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v261 = gconnectionLogObj;
      v262 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      v46 = v367;
      if (v262)
      {
        v263 = "";
        v265 = *(_DWORD *)(v367 + 176);
        v264 = *(_DWORD *)(v367 + 180);
        v266 = (const char *)(v367 + 191);
        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        if (!v367)
          v266 = "";
        LODWORD(buf[0]) = 136447234;
        if (v367)
          v263 = " ";
        *(_QWORD *)((char *)&buf[1] + 6) = v266;
        HIWORD(buf[2]) = 2080;
        *(_QWORD *)&v370 = v263;
        WORD4(v370) = 1024;
        *(_DWORD *)((char *)&v370 + 10) = v264;
        HIWORD(v370) = 1024;
        LODWORD(v371[0]) = v265;
        _os_log_impl(&dword_182FBE000, v261, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", (uint8_t *)buf, 0x2Cu);
        v46 = v367;
      }
    }
  }
  if (*(_QWORD *)(v46 + 120) == *(_QWORD *)(v46 + 128))
  {
    v350 = v23;
    v65 = nw_http_metadata_copy_request(*(void **)(v46 + 104));
    v66 = v65;
    v67 = MEMORY[0x1E0C809B0];
    if (v65)
    {
      has_method = nw_http_request_has_method(v65, (uint64_t)"CONNECT");
      v69 = v367;
      if (has_method)
      {
        v70 = *(unsigned __int16 *)(v367 + 188) | (*(unsigned __int8 *)(v367 + 190) << 16);
        if ((v70 & 0x10000) == 0)
        {
          v366[0] = v67;
          v366[1] = 0x40000000;
          v366[2] = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke;
          v366[3] = &__block_descriptor_tmp_75_82641;
          v366[4] = v367;
          nw_http_fields_access_value_by_name(v66, (unint64_t)"Capsule-Protocol", v366);
          v365[0] = v67;
          v365[1] = 0x40000000;
          v365[2] = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_2;
          v365[3] = &__block_descriptor_tmp_78_82642;
          v365[4] = v367;
          nw_http_request_access_extended_connect_protocol(v66, v365);
          v69 = v367;
          v70 = *(unsigned __int16 *)(v367 + 188) | (*(unsigned __int8 *)(v367 + 190) << 16);
        }
        *(_BYTE *)(v69 + 190) = BYTE2(v70);
        *(_WORD *)(v69 + 188) = v70 | 0x200;
      }
    }
    else
    {
      v69 = v367;
    }
    v75 = nw_http_metadata_copy_response(*(void **)(v69 + 104));
    object = v75;
    if (v75)
    {
      v76 = (nw_http_response_get_status_code(v75) - 100) < 0x64;
      v77 = v367;
      v79 = *(unsigned __int16 *)(v367 + 188);
      v78 = v367 + 188;
      v80 = v79 & 0xFFFFDFFF | (*(unsigned __int8 *)(v367 + 190) << 16);
      *(_WORD *)(v367 + 188) = v79 & 0xDFFF | (v76 << 13);
      *(_BYTE *)(v78 + 2) = BYTE2(v80);
    }
    else
    {
      v77 = v367;
    }
    buf[0] = 0;
    buf[1] = buf;
    buf[2] = 0x4002000000;
    *(_QWORD *)&v370 = __Block_byref_object_copy__82643;
    *((_QWORD *)&v370 + 1) = __Block_byref_object_dispose__82644;
    memset(v371, 0, sizeof(v371));
    v363 = a1;
    v364[0] = 0;
    v364[1] = v364;
    v364[2] = 0x2000000000;
    v364[3] = 0;
    v81 = *(void **)(v77 + 104);
    *(_QWORD *)type = v67;
    v357 = 0x40000000;
    v358 = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_79;
    v359 = &unk_1E14ABBF8;
    v361 = v364;
    v362 = v77;
    v360 = buf;
    v82 = v81;
    v83 = type;
    if (v82)
    {
      v84 = (id *)v82;
      v85 = v84[1];

      if (nw_protocol_copy_http_definition_onceToken != -1)
        dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72660);
      is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v85, nw_protocol_copy_http_definition_http_definition);

      if (is_equal_unsafe)
      {
        v374[0] = MEMORY[0x1E0C809B0];
        v374[1] = 3221225472;
        v374[2] = __nw_http_metadata_enumerate_modern_header_fields_block_invoke;
        v375 = &unk_1E14A9DD0;
        v87 = v83;
        v376 = v87;
        if (v84[4])
        {
          ((void (*)(_QWORD *))v374[2])(v374);
          v87 = v376;
        }

        goto LABEL_115;
      }
      __nwlog_obj();
      v284 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v374[0]) = 136446210;
      *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
      v349 = (void *)_os_log_send_and_compose_impl();

      v354[0] = OS_LOG_TYPE_ERROR;
      v368 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault((const char *)v349, v354, &v368))
      {
LABEL_593:
        if (v349)
          free(v349);
LABEL_115:

        v88 = *(char **)(buf[1] + 40);
        v89 = *(char **)(buf[1] + 48);
        v8 = &unk_1ECD84000;
        if (v88 == v89)
          goto LABEL_122;
        v90 = *(_QWORD *)(v367 + 120);
        v91 = v89 - v88 - 40;
        if (v91 > 0x27)
        {
          v92 = v91 / 0x28 + 1;
          v93 = v88 + 48;
          v94 = v92 & 0xFFFFFFFFFFFFFFELL;
          do
          {
            v95 = *(v93 - 5);
            v96 = *(v93 - 6) + v90;
            *(v93 - 1) += v90;
            v97 = *v93 + v90;
            *(v93 - 6) = v96;
            *(v93 - 5) = v95 + v90;
            *v93 = v97;
            v93 += 10;
            v94 -= 2;
          }
          while (v94);
          if (v92 == (v92 & 0xFFFFFFFFFFFFFFELL))
          {
LABEL_122:
            if (v350
              && (*(_WORD *)(v367 + 188) & 0x2000) == 0
              && ((*(unsigned __int16 *)(v367 + 188) | (*(unsigned __int8 *)(v367 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v99 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v100 = (const char *)(v367 + 191);
                v101 = "";
                if (!v367)
                  v100 = "";
                v102 = *(_DWORD *)(v367 + 176);
                v103 = *(_DWORD *)(v367 + 180);
                if (v367)
                  v101 = " ";
                LODWORD(v374[0]) = 136447234;
                *(_QWORD *)((char *)v374 + 4) = "nw_http2_stream_make_and_submit_headers";
                WORD2(v374[1]) = 2082;
                *(_QWORD *)((char *)&v374[1] + 6) = v100;
                HIWORD(v374[2]) = 2080;
                v375 = (void *)v101;
                LOWORD(v376) = 1024;
                *(_DWORD *)((char *)&v376 + 2) = v103;
                HIWORD(v376) = 1024;
                v377 = v102;
                _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting end stream flag for headers", (uint8_t *)v374, 0x2Cu);
              }
              v8 = (_BYTE *)&unk_1ECD84000;
            }
            v355 = 0;
            *(_QWORD *)v354 = 0;
            if ((*(_BYTE *)(a1 + 376) & 0x80) == 0)
            {
              v374[0] = 0;
              v374[1] = v374;
              LODWORD(v375) = 16;
              v374[2] = 0x2000000000;
              if (v66)
              {
                v353[0] = MEMORY[0x1E0C809B0];
                v353[1] = 0x40000000;
                v353[2] = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_82;
                v353[3] = &unk_1E14ABC28;
                v353[4] = v374;
                nw_http_fields_access_value_by_name(v66, (unint64_t)"Priority", v353);
              }
              nghttp2_priority_spec_init();
              _Block_object_dispose(v374, 8);
            }
            v104 = nghttp2_submit_headers();
            if ((v104 & 0x80000000) == 0)
            {
LABEL_167:
              _Block_object_dispose(v364, 8);
              _Block_object_dispose(buf, 8);
              if (v371[0])
              {
                v371[1] = v371[0];
                operator delete(v371[0]);
              }
              if (object)
                os_release(object);
              if (v66)
                os_release(v66);
              if (v104 < 0)
                goto LABEL_149;
              if (v104
                && ((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
                && v8[1345])
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v302 = gconnectionLogObj;
                v8 = (_BYTE *)&unk_1ECD84000;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v304 = *(_DWORD *)(a3 + 176);
                  v303 = *(_DWORD *)(a3 + 180);
                  LODWORD(buf[0]) = 136447746;
                  *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                  HIWORD(buf[2]) = 2080;
                  *(_QWORD *)&v370 = " ";
                  WORD4(v370) = 1024;
                  *(_DWORD *)((char *)&v370 + 10) = v303;
                  HIWORD(v370) = 1024;
                  LODWORD(v371[0]) = v304;
                  WORD2(v371[0]) = 2048;
                  *(void **)((char *)v371 + 6) = 0;
                  HIWORD(v371[1]) = 1024;
                  LODWORD(v371[2]) = v104;
                  _os_log_impl(&dword_182FBE000, v302, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> submitted %llu headers, assigned stream %d", (uint8_t *)buf, 0x3Cu);
                }
              }
              v125 = *(_DWORD *)(a3 + 176);
              v126 = *(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16);
              if (v125 == -1)
              {
                if ((*(_WORD *)(a3 + 188) & 0x80) != 0)
                {
                  if ((v126 & 0x80000) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v158 = *(_DWORD *)(a3 + 176);
                    v157 = *(_DWORD *)(a3 + 180);
                    LODWORD(buf[0]) = 136447234;
                    *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                    WORD2(buf[1]) = 2082;
                    *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(_QWORD *)&v370 = " ";
                    WORD4(v370) = 1024;
                    *(_DWORD *)((char *)&v370 + 10) = v157;
                    HIWORD(v370) = 1024;
                    LODWORD(v371[0]) = v158;
                    v151 = (char *)_os_log_send_and_compose_impl();
                    LOBYTE(v374[0]) = 16;
                    LOBYTE(v366[0]) = 0;
                    if (__nwlog_fault(v151, v374, v366))
                    {
                      if (LOBYTE(v374[0]) == 17)
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v159 = gconnectionLogObj;
                        v160 = v374[0];
                        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]))
                          goto LABEL_328;
                        v162 = *(_DWORD *)(a3 + 176);
                        v161 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(_QWORD *)&v370 = " ";
                        WORD4(v370) = 1024;
                        *(_DWORD *)((char *)&v370 + 10) = v161;
                        HIWORD(v370) = 1024;
                        LODWORD(v371[0]) = v162;
                        v156 = "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening";
                      }
                      else if (LOBYTE(v366[0]))
                      {
                        v171 = (char *)__nw_create_backtrace_string();
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v159 = gconnectionLogObj;
                        v160 = v374[0];
                        v172 = os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]);
                        if (v171)
                        {
                          if (v172)
                          {
                            v174 = *(_DWORD *)(a3 + 176);
                            v173 = *(_DWORD *)(a3 + 180);
                            LODWORD(buf[0]) = 136447490;
                            *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                            WORD2(buf[1]) = 2082;
                            *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                            HIWORD(buf[2]) = 2080;
                            *(_QWORD *)&v370 = " ";
                            WORD4(v370) = 1024;
                            *(_DWORD *)((char *)&v370 + 10) = v173;
                            HIWORD(v370) = 1024;
                            LODWORD(v371[0]) = v174;
                            WORD2(v371[0]) = 2082;
                            *(void **)((char *)v371 + 6) = v171;
                            _os_log_impl(&dword_182FBE000, v159, v160, "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening, dumping backtrace:%{public}s", (uint8_t *)buf, 0x36u);
                          }
                          free(v171);
                          goto LABEL_328;
                        }
                        if (!v172)
                          goto LABEL_328;
                        v214 = *(_DWORD *)(a3 + 176);
                        v213 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(_QWORD *)&v370 = " ";
                        WORD4(v370) = 1024;
                        *(_DWORD *)((char *)&v370 + 10) = v213;
                        HIWORD(v370) = 1024;
                        LODWORD(v371[0]) = v214;
                        v156 = "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening, no backtrace";
                      }
                      else
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v159 = gconnectionLogObj;
                        v160 = v374[0];
                        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]))
                          goto LABEL_328;
                        v204 = *(_DWORD *)(a3 + 176);
                        v203 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(_QWORD *)&v370 = " ";
                        WORD4(v370) = 1024;
                        *(_DWORD *)((char *)&v370 + 10) = v203;
                        HIWORD(v370) = 1024;
                        LODWORD(v371[0]) = v204;
                        v156 = "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening, bac"
                               "ktrace limit exceeded";
                      }
                      v207 = v159;
                      v208 = v160;
                      v209 = 44;
                      goto LABEL_327;
                    }
LABEL_328:
                    if (!v151)
                    {
LABEL_330:
                      v8 = &unk_1ECD84000;
                      goto LABEL_331;
                    }
LABEL_329:
                    free(v151);
                    goto LABEL_330;
                  }
LABEL_331:
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
                    && v8[1345])
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v215 = gconnectionLogObj;
                    v8 = (_BYTE *)&unk_1ECD84000;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      v217 = *(_DWORD *)(a3 + 176);
                      v216 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447234;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_headers";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v216;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v217;
                      _os_log_impl(&dword_182FBE000, v215, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> failed to handle new stream id", (uint8_t *)buf, 0x2Cu);
                    }
                  }
                  goto LABEL_149;
                }
                *(_DWORD *)(a3 + 176) = v104;
                if (!nw_http2_add_to_id_table(a1, a3, (uint64_t)a2))
                {
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v194 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                    {
                      v196 = *(_DWORD *)(a3 + 176);
                      v195 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447234;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v195;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v196;
                      _os_log_impl(&dword_182FBE000, v194, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> Failed to add new stream to the id based hash table", (uint8_t *)buf, 0x2Cu);
                    }
                  }
                  *(_DWORD *)(a3 + 176) = -1;
                  goto LABEL_331;
                }
                v126 = *(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16);
                if (*(int *)(a3 + 176) > 0)
                  goto LABEL_179;
              }
              else if (v125 > 0)
              {
LABEL_179:
                if ((v126 & 0x80000) == 0 && v8[1345])
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v310 = gconnectionLogObj;
                  v8 = (_BYTE *)&unk_1ECD84000;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    v312 = *(_DWORD *)(a3 + 176);
                    v311 = *(_DWORD *)(a3 + 180);
                    if ((*(_WORD *)(a1 + 376) & 0x80) != 0)
                      v313 = "response";
                    else
                      v313 = "request";
                    LODWORD(buf[0]) = 136447746;
                    *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                    WORD2(buf[1]) = 2082;
                    *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(_QWORD *)&v370 = " ";
                    WORD4(v370) = 1024;
                    *(_DWORD *)((char *)&v370 + 10) = v311;
                    HIWORD(v370) = 1024;
                    LODWORD(v371[0]) = v312;
                    WORD2(v371[0]) = 2080;
                    *(void **)((char *)v371 + 6) = (void *)v313;
                    HIWORD(v371[1]) = 1024;
                    LODWORD(v371[2]) = v312;
                    _os_log_impl(&dword_182FBE000, v310, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> %s headers submitted on stream %d", (uint8_t *)buf, 0x3Cu);
                  }
                }
                if (a4)
                {
                  v127 = *(_DWORD *)(a4 + 52);
                  if (v127 && v127 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60))
                  {
                    v10 = *(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16);
                    goto LABEL_185;
                  }
                  goto LABEL_35;
                }
                __nwlog_obj();
                LODWORD(buf[0]) = 136446210;
                *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                v306 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v374[0]) = 16;
                LOBYTE(v366[0]) = 0;
                if (__nwlog_fault(v306, v374, v366))
                {
                  if (LOBYTE(v374[0]) == 17)
                  {
                    v307 = __nwlog_obj();
                    v308 = v374[0];
                    if (os_log_type_enabled(v307, v374[0]))
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                      v309 = "%{public}s called with null frame";
LABEL_616:
                      _os_log_impl(&dword_182FBE000, v307, v308, v309, (uint8_t *)buf, 0xCu);
                    }
                  }
                  else if (LOBYTE(v366[0]))
                  {
                    v330 = (char *)__nw_create_backtrace_string();
                    v307 = __nwlog_obj();
                    v308 = v374[0];
                    v331 = os_log_type_enabled(v307, v374[0]);
                    if (v330)
                    {
                      if (v331)
                      {
                        LODWORD(buf[0]) = 136446466;
                        *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = v330;
                        _os_log_impl(&dword_182FBE000, v307, v308, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
                      }
                      free(v330);
                      goto LABEL_617;
                    }
                    if (v331)
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                      v309 = "%{public}s called with null frame, no backtrace";
                      goto LABEL_616;
                    }
                  }
                  else
                  {
                    v307 = __nwlog_obj();
                    v308 = v374[0];
                    if (os_log_type_enabled(v307, v374[0]))
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(_QWORD *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                      v309 = "%{public}s called with null frame, backtrace limit exceeded";
                      goto LABEL_616;
                    }
                  }
                }
LABEL_617:
                if (v306)
                  free(v306);
                v8 = (_BYTE *)&unk_1ECD84000;
                goto LABEL_35;
              }
              if ((v126 & 0x80000) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v150 = *(_DWORD *)(a3 + 176);
                v149 = *(_DWORD *)(a3 + 180);
                LODWORD(buf[0]) = 136447490;
                *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                WORD2(buf[1]) = 2082;
                *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                HIWORD(buf[2]) = 2080;
                *(_QWORD *)&v370 = " ";
                WORD4(v370) = 1024;
                *(_DWORD *)((char *)&v370 + 10) = v149;
                HIWORD(v370) = 1024;
                LODWORD(v371[0]) = v150;
                WORD2(v371[0]) = 2048;
                *(void **)((char *)v371 + 6) = (void *)a3;
                v151 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v374[0]) = 16;
                LOBYTE(v366[0]) = 0;
                if (__nwlog_fault(v151, v374, v366))
                {
                  if (LOBYTE(v374[0]) == 17)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v152 = gconnectionLogObj;
                    v153 = v374[0];
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]))
                    {
                      v155 = *(_DWORD *)(a3 + 176);
                      v154 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v154;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v155;
                      WORD2(v371[0]) = 2048;
                      *(void **)((char *)v371 + 6) = (void *)a3;
                      v156 = "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening";
LABEL_319:
                      v207 = v152;
                      v208 = v153;
                      v209 = 54;
LABEL_327:
                      _os_log_impl(&dword_182FBE000, v207, v208, v156, (uint8_t *)buf, v209);
                      goto LABEL_328;
                    }
                  }
                  else if (LOBYTE(v366[0]))
                  {
                    v167 = (char *)__nw_create_backtrace_string();
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v152 = gconnectionLogObj;
                    v153 = v374[0];
                    v168 = os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]);
                    if (v167)
                    {
                      if (v168)
                      {
                        v170 = *(_DWORD *)(a3 + 176);
                        v169 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447746;
                        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(_QWORD *)&v370 = " ";
                        WORD4(v370) = 1024;
                        *(_DWORD *)((char *)&v370 + 10) = v169;
                        HIWORD(v370) = 1024;
                        LODWORD(v371[0]) = v170;
                        WORD2(v371[0]) = 2048;
                        *(void **)((char *)v371 + 6) = (void *)a3;
                        HIWORD(v371[1]) = 2082;
                        v371[2] = v167;
                        _os_log_impl(&dword_182FBE000, v152, v153, "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening, dumping backtrace:%{public}s", (uint8_t *)buf, 0x40u);
                      }
                      free(v167);
                      if (!v151)
                        goto LABEL_330;
                      goto LABEL_329;
                    }
                    if (v168)
                    {
                      v206 = *(_DWORD *)(a3 + 176);
                      v205 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v205;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v206;
                      WORD2(v371[0]) = 2048;
                      *(void **)((char *)v371 + 6) = (void *)a3;
                      v156 = "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening, no backtrace";
                      goto LABEL_319;
                    }
                  }
                  else
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v152 = gconnectionLogObj;
                    v153 = v374[0];
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, v374[0]))
                    {
                      v202 = *(_DWORD *)(a3 + 176);
                      v201 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(_QWORD *)&v370 = " ";
                      WORD4(v370) = 1024;
                      *(_DWORD *)((char *)&v370 + 10) = v201;
                      HIWORD(v370) = 1024;
                      LODWORD(v371[0]) = v202;
                      WORD2(v371[0]) = 2048;
                      *(void **)((char *)v371 + 6) = (void *)a3;
                      v156 = "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening, backtrace limit exceeded";
                      goto LABEL_319;
                    }
                  }
                }
                goto LABEL_328;
              }
              goto LABEL_331;
            }
            __nwlog_obj();
            v105 = nghttp2_strerror();
            LODWORD(v374[0]) = 136446466;
            *(_QWORD *)((char *)v374 + 4) = "nw_http2_stream_make_and_submit_headers";
            WORD2(v374[1]) = 2082;
            *(_QWORD *)((char *)&v374[1] + 6) = v105;
            v106 = (char *)_os_log_send_and_compose_impl();
            v368 = OS_LOG_TYPE_ERROR;
            v352 = 0;
            if (__nwlog_fault(v106, &v368, &v352))
            {
              if (v368 == OS_LOG_TYPE_FAULT)
              {
                v107 = __nwlog_obj();
                v108 = v368;
                if (os_log_type_enabled(v107, v368))
                {
                  v109 = nghttp2_strerror();
                  LODWORD(v374[0]) = 136446466;
                  *(_QWORD *)((char *)v374 + 4) = "nw_http2_stream_make_and_submit_headers";
                  WORD2(v374[1]) = 2082;
                  *(_QWORD *)((char *)&v374[1] + 6) = v109;
                  v110 = "%{public}s nghttp2_submit_headers: %{public}s failed";
LABEL_162:
                  v124 = v107;
LABEL_163:
                  _os_log_impl(&dword_182FBE000, v124, v108, v110, (uint8_t *)v374, 0x16u);
                }
              }
              else if (v352)
              {
                v119 = (char *)__nw_create_backtrace_string();
                v120 = __nwlog_obj();
                v108 = v368;
                v121 = os_log_type_enabled(v120, v368);
                if (v119)
                {
                  if (v121)
                  {
                    v122 = nghttp2_strerror();
                    LODWORD(v374[0]) = 136446722;
                    *(_QWORD *)((char *)v374 + 4) = "nw_http2_stream_make_and_submit_headers";
                    WORD2(v374[1]) = 2082;
                    *(_QWORD *)((char *)&v374[1] + 6) = v122;
                    HIWORD(v374[2]) = 2082;
                    v375 = v119;
                    _os_log_impl(&dword_182FBE000, v120, v108, "%{public}s nghttp2_submit_headers: %{public}s failed, dumping backtrace:%{public}s", (uint8_t *)v374, 0x20u);
                  }
                  free(v119);
                  goto LABEL_164;
                }
                if (v121)
                {
                  v197 = nghttp2_strerror();
                  LODWORD(v374[0]) = 136446466;
                  *(_QWORD *)((char *)v374 + 4) = "nw_http2_stream_make_and_submit_headers";
                  WORD2(v374[1]) = 2082;
                  *(_QWORD *)((char *)&v374[1] + 6) = v197;
                  v110 = "%{public}s nghttp2_submit_headers: %{public}s failed, no backtrace";
                  v124 = v120;
                  goto LABEL_163;
                }
              }
              else
              {
                v107 = __nwlog_obj();
                v108 = v368;
                if (os_log_type_enabled(v107, v368))
                {
                  v123 = nghttp2_strerror();
                  LODWORD(v374[0]) = 136446466;
                  *(_QWORD *)((char *)v374 + 4) = "nw_http2_stream_make_and_submit_headers";
                  WORD2(v374[1]) = 2082;
                  *(_QWORD *)((char *)&v374[1] + 6) = v123;
                  v110 = "%{public}s nghttp2_submit_headers: %{public}s failed, backtrace limit exceeded";
                  goto LABEL_162;
                }
              }
            }
LABEL_164:
            if (v106)
              free(v106);
            v8 = &unk_1ECD84000;
            goto LABEL_167;
          }
          v88 += 40 * (v92 & 0xFFFFFFFFFFFFFFELL);
        }
        do
        {
          v98 = *((_QWORD *)v88 + 1) + v90;
          *(_QWORD *)v88 += v90;
          *((_QWORD *)v88 + 1) = v98;
          v88 += 40;
        }
        while (v88 != v89);
        goto LABEL_122;
      }
      if (v354[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v282 = objc_claimAutoreleasedReturnValue();
        v285 = v354[0];
        if (os_log_type_enabled(v282, v354[0]))
        {
          LODWORD(v374[0]) = 136446210;
          *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_182FBE000, v282, v285, "%{public}s metadata must be http", (uint8_t *)v374, 0xCu);
        }
LABEL_592:

        goto LABEL_593;
      }
      if (v368 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v282 = objc_claimAutoreleasedReturnValue();
        v329 = v354[0];
        if (os_log_type_enabled(v282, v354[0]))
        {
          LODWORD(v374[0]) = 136446210;
          *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_182FBE000, v282, v329, "%{public}s metadata must be http, backtrace limit exceeded", (uint8_t *)v374, 0xCu);
        }
        goto LABEL_592;
      }
      v297 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v282 = objc_claimAutoreleasedReturnValue();
      v300 = v354[0];
      v301 = os_log_type_enabled(v282, v354[0]);
      if (!v297)
      {
        if (v301)
        {
          LODWORD(v374[0]) = 136446210;
          *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_182FBE000, v282, v300, "%{public}s metadata must be http, no backtrace", (uint8_t *)v374, 0xCu);
        }
        goto LABEL_592;
      }
      if (v301)
      {
        LODWORD(v374[0]) = 136446466;
        *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
        WORD2(v374[1]) = 2082;
        *(_QWORD *)((char *)&v374[1] + 6) = v297;
        _os_log_impl(&dword_182FBE000, v282, v300, "%{public}s metadata must be http, dumping backtrace:%{public}s", (uint8_t *)v374, 0x16u);
      }
    }
    else
    {
      __nwlog_obj();
      v281 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v374[0]) = 136446210;
      *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
      v349 = (void *)_os_log_send_and_compose_impl();

      v354[0] = OS_LOG_TYPE_ERROR;
      v368 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault((const char *)v349, v354, &v368))
        goto LABEL_593;
      if (v354[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v282 = objc_claimAutoreleasedReturnValue();
        v283 = v354[0];
        if (os_log_type_enabled(v282, v354[0]))
        {
          LODWORD(v374[0]) = 136446210;
          *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_182FBE000, v282, v283, "%{public}s called with null metadata", (uint8_t *)v374, 0xCu);
        }
        goto LABEL_592;
      }
      if (v368 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v282 = objc_claimAutoreleasedReturnValue();
        v328 = v354[0];
        if (os_log_type_enabled(v282, v354[0]))
        {
          LODWORD(v374[0]) = 136446210;
          *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_182FBE000, v282, v328, "%{public}s called with null metadata, backtrace limit exceeded", (uint8_t *)v374, 0xCu);
        }
        goto LABEL_592;
      }
      v297 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v282 = objc_claimAutoreleasedReturnValue();
      v298 = v354[0];
      v299 = os_log_type_enabled(v282, v354[0]);
      if (!v297)
      {
        if (v299)
        {
          LODWORD(v374[0]) = 136446210;
          *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_182FBE000, v282, v298, "%{public}s called with null metadata, no backtrace", (uint8_t *)v374, 0xCu);
        }
        goto LABEL_592;
      }
      if (v299)
      {
        LODWORD(v374[0]) = 136446466;
        *(_QWORD *)((char *)v374 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
        WORD2(v374[1]) = 2082;
        *(_QWORD *)((char *)&v374[1] + 6) = v297;
        _os_log_impl(&dword_182FBE000, v282, v298, "%{public}s called with null metadata, dumping backtrace:%{public}s", (uint8_t *)v374, 0x16u);
      }
    }

    free(v297);
    goto LABEL_593;
  }
  if (((*(unsigned __int16 *)(v46 + 188) | (*(unsigned __int8 *)(v46 + 190) << 16)) & 0x80000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v47 = gconnectionLogObj;
    v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    v46 = v367;
    if (v48)
    {
      v49 = "";
      v51 = *(_DWORD *)(v367 + 176);
      v50 = *(_DWORD *)(v367 + 180);
      v52 = (const char *)(v367 + 191);
      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      if (!v367)
        v52 = "";
      LODWORD(buf[0]) = 136447234;
      if (v367)
        v49 = " ";
      *(_QWORD *)((char *)&buf[1] + 6) = v52;
      HIWORD(buf[2]) = 2080;
      *(_QWORD *)&v370 = v49;
      WORD4(v370) = 1024;
      *(_DWORD *)((char *)&v370 + 10) = v50;
      HIWORD(v370) = 1024;
      LODWORD(v371[0]) = v51;
      _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> Already buffered header bytes", (uint8_t *)buf, 0x2Cu);
      v46 = v367;
    }
  }
  v53 = *(unsigned __int16 *)(v46 + 188);
  v54 = v53 | (*(unsigned __int8 *)(v46 + 190) << 16);
  if ((v53 & 0x40) != 0)
    goto LABEL_149;
  *(_BYTE *)(v46 + 190) = BYTE2(v54);
  *(_WORD *)(v46 + 188) = v54 | 0x40;
  v55 = a2[3];
  if (!v55 || (v56 = *(void (**)(_QWORD *, uint64_t, uint64_t))(v55 + 56)) == 0)
  {
    __nwlog_obj();
    v273 = (const char *)a2[2];
    if (!v273)
      v273 = "invalid";
    LODWORD(buf[0]) = 136446466;
    *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = v273;
    v274 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v374[0]) = 0;
    if (__nwlog_fault(v274, type, v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v275 = __nwlog_obj();
        v276 = type[0];
        if (!os_log_type_enabled(v275, type[0]))
          goto LABEL_527;
        v277 = (const char *)a2[2];
        if (!v277)
          v277 = "invalid";
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v277;
        v278 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_526:
        _os_log_impl(&dword_182FBE000, v275, v276, v278, (uint8_t *)buf, 0x16u);
        goto LABEL_527;
      }
      if (!LOBYTE(v374[0]))
      {
        v275 = __nwlog_obj();
        v276 = type[0];
        if (!os_log_type_enabled(v275, type[0]))
          goto LABEL_527;
        v305 = (const char *)a2[2];
        if (!v305)
          v305 = "invalid";
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v305;
        v278 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_526;
      }
      v286 = (char *)__nw_create_backtrace_string();
      v275 = __nwlog_obj();
      v276 = type[0];
      v287 = os_log_type_enabled(v275, type[0]);
      if (!v286)
      {
        if (!v287)
          goto LABEL_527;
        v318 = (const char *)a2[2];
        if (!v318)
          v318 = "invalid";
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v318;
        v278 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
        goto LABEL_526;
      }
      if (v287)
      {
        v288 = (const char *)a2[2];
        if (!v288)
          v288 = "invalid";
        LODWORD(buf[0]) = 136446722;
        *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v288;
        HIWORD(buf[2]) = 2082;
        *(_QWORD *)&v370 = v286;
        _os_log_impl(&dword_182FBE000, v275, v276, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x20u);
      }
      free(v286);
    }
LABEL_527:
    if (v274)
      free(v274);
    v57 = a2[3];
    if (!v57)
      goto LABEL_530;
    goto LABEL_76;
  }
  v56(a2, a1, 22);
  v57 = a2[3];
  if (!v57)
    goto LABEL_530;
LABEL_76:
  v58 = *(void (**)(_QWORD *, uint64_t))(v57 + 48);
  if (v58)
  {
    v58(a2, a1);
    goto LABEL_149;
  }
LABEL_530:
  __nwlog_obj();
  v319 = (const char *)a2[2];
  if (!v319)
    v319 = "invalid";
  LODWORD(buf[0]) = 136446466;
  *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
  WORD2(buf[1]) = 2082;
  *(_QWORD *)((char *)&buf[1] + 6) = v319;
  v40 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v374[0]) = 0;
  if (!__nwlog_fault(v40, type, v374))
    goto LABEL_147;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v320 = __nwlog_obj();
    v321 = type[0];
    if (os_log_type_enabled(v320, type[0]))
    {
      v322 = (const char *)a2[2];
      if (!v322)
        v322 = "invalid";
      LODWORD(buf[0]) = 136446466;
      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = v322;
      v45 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_554:
      v113 = v320;
      v114 = v321;
      v115 = 22;
      goto LABEL_146;
    }
    goto LABEL_147;
  }
  if (!LOBYTE(v374[0]))
  {
    v320 = __nwlog_obj();
    v321 = type[0];
    if (os_log_type_enabled(v320, type[0]))
    {
      v326 = (const char *)a2[2];
      if (!v326)
        v326 = "invalid";
      LODWORD(buf[0]) = 136446466;
      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = v326;
      v45 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_554;
    }
    goto LABEL_147;
  }
  v323 = (char *)__nw_create_backtrace_string();
  v320 = __nwlog_obj();
  v321 = type[0];
  v324 = os_log_type_enabled(v320, type[0]);
  if (!v323)
  {
    if (v324)
    {
      v327 = (const char *)a2[2];
      if (!v327)
        v327 = "invalid";
      LODWORD(buf[0]) = 136446466;
      *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = v327;
      v45 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
      goto LABEL_554;
    }
    goto LABEL_147;
  }
  if (v324)
  {
    v325 = (const char *)a2[2];
    if (!v325)
      v325 = "invalid";
    LODWORD(buf[0]) = 136446722;
    *(_QWORD *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = v325;
    HIWORD(buf[2]) = 2082;
    *(_QWORD *)&v370 = v323;
    _os_log_impl(&dword_182FBE000, v320, v321, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x20u);
  }
  free(v323);
  if (v40)
LABEL_148:
    free(v40);
LABEL_149:
  result = 0;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && v8[1345])
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v116 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      v118 = *(_DWORD *)(a3 + 176);
      v117 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(_QWORD *)((char *)buf + 4) = "nw_http2_submit_message";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(_QWORD *)&v370 = " ";
      WORD4(v370) = 1024;
      *(_DWORD *)((char *)&v370 + 10) = v117;
      HIWORD(v370) = 1024;
      LODWORD(v371[0]) = v118;
      v15 = "%{public}s %{public}s%s<i%u:s%d> failed to send headers";
      v16 = v116;
      v17 = OS_LOG_TYPE_DEBUG;
      v18 = 44;
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke(uint64_t result, char *__s1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;

  v2 = result;
  if (__s1)
  {
    result = strcmp(__s1, "?1");
    v3 = ((_DWORD)result == 0) << 17;
  }
  else
  {
    v3 = 0;
  }
  v4 = *(_QWORD *)(v2 + 32);
  v5 = *(unsigned __int16 *)(v4 + 188);
  v4 += 188;
  v6 = (v5 | (*(unsigned __int8 *)(v4 + 2) << 16)) & 0xFFFDFFFF | v3;
  *(_WORD *)v4 = v6;
  *(_BYTE *)(v4 + 2) = BYTE2(v6);
  return result;
}

uint64_t ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_2(uint64_t result, char *__s1)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;

  v2 = result;
  if (__s1)
  {
    result = strcmp(__s1, "connect-udp");
    if ((_DWORD)result)
    {
      result = strcmp(__s1, "connect-ip");
      v4 = ((_DWORD)result == 0) << 18;
    }
    else
    {
      v4 = 0x40000;
    }
  }
  else
  {
    v4 = 0;
  }
  v5 = *(_QWORD *)(v2 + 32);
  v6 = *(unsigned __int16 *)(v5 + 188);
  v5 += 188;
  v7 = (v6 | (*(unsigned __int8 *)(v5 + 2) << 16)) & 0xFFFBFFFF | v4;
  *(_WORD *)v5 = v7;
  *(_BYTE *)(v5 + 2) = BYTE2(v7);
  return result;
}

__n128 __Block_byref_object_copy__82643(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__82644(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_79(_QWORD *a1, char *__src, int64_t a3, char *a4, int64_t a5, int a6)
{
  uint64_t v12;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  int v33;
  BOOL v34;
  const char *v35;
  const char *v36;
  NSObject *v37;
  uint32_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  BOOL v43;
  int v44;
  int v45;
  uint64_t v46;
  char *v47;
  int64_t v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  _BYTE v58[24];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v12 = a1[6];
  if (v12)
  {
    if (((*(unsigned __int16 *)(v12 + 188) | (*(unsigned __int8 *)(v12 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v39 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v40 = a1[6];
        v41 = (const char *)(v40 + 191);
        v42 = "";
        v43 = v40 == 0;
        if (!v40)
          v41 = "";
        v46 = v40 + 176;
        v44 = *(_DWORD *)(v40 + 176);
        v45 = *(_DWORD *)(v46 + 4);
        if (!v43)
          v42 = " ";
        *(_DWORD *)buf = 136447746;
        v50 = "nw_http2_stream_make_and_submit_headers_block_invoke";
        v51 = 2082;
        v52 = v41;
        v53 = 2080;
        v54 = v42;
        v55 = 1024;
        v56 = v45;
        v57 = 1024;
        *(_DWORD *)v58 = v44;
        *(_WORD *)&v58[4] = 2082;
        *(_QWORD *)&v58[6] = __src;
        *(_WORD *)&v58[14] = 2082;
        *(_QWORD *)&v58[16] = a4;
        v36 = "%{public}s %{public}s%s<i%u:s%d> sending header field %{public}s: %{public}s";
        v37 = v39;
        v38 = 64;
LABEL_44:
        _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, v36, buf, v38);
      }
    }
  }
  else
  {
    v29 = a1[7];
    if ((!v29 || (*(__int16 *)(v29 + 376) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v30 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v31 = a1[7];
        v32 = (const char *)(v31 + 378);
        v33 = *(_DWORD *)(v31 + 368);
        v34 = v31 == 0;
        *(_DWORD *)buf = 136447490;
        if (!v31)
          v32 = "";
        v50 = "nw_http2_stream_make_and_submit_headers_block_invoke";
        v35 = " ";
        if (v34)
          v35 = "";
        v51 = 2082;
        v52 = v32;
        v53 = 2080;
        v54 = v35;
        v55 = 1024;
        v56 = v33;
        v57 = 2082;
        *(_QWORD *)v58 = __src;
        *(_WORD *)&v58[8] = 2082;
        *(_QWORD *)&v58[10] = a4;
        v36 = "%{public}s %{public}s%s<i%u> sending header field %{public}s: %{public}s";
        v37 = v30;
        v38 = 58;
        goto LABEL_44;
      }
    }
  }
  if ((a6 & 0xFFFFFFFE) == 2)
    v13 = 7;
  else
    v13 = 6;
  v14 = *(_QWORD **)(a1[4] + 8);
  v15 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  v16 = v15 + a3;
  v18 = (_QWORD *)v14[6];
  v17 = v14[7];
  if ((unint64_t)v18 >= v17)
  {
    v47 = __src;
    v48 = a5;
    v20 = (_QWORD *)v14[5];
    v21 = 0xCCCCCCCCCCCCCCCDLL * (v18 - v20) + 1;
    if (v21 > 0x666666666666666)
      abort();
    v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - (_QWORD)v20) >> 3);
    if (2 * v22 > v21)
      v21 = 2 * v22;
    if (v22 >= 0x333333333333333)
      v23 = 0x666666666666666;
    else
      v23 = v21;
    if (v23)
    {
      if (v23 > 0x666666666666666)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v24 = (char *)operator new(40 * v23);
    }
    else
    {
      v24 = 0;
    }
    v25 = &v24[8 * (v18 - v20)];
    *(_QWORD *)v25 = v15;
    *((_QWORD *)v25 + 1) = v16;
    v26 = &v24[40 * v23];
    a5 = v48;
    *((_QWORD *)v25 + 2) = a3;
    *((_QWORD *)v25 + 3) = v48;
    v25[32] = v13;
    v19 = v25 + 40;
    if (v18 != v20)
    {
      do
      {
        v27 = *(_OWORD *)(v18 - 5);
        v28 = *(_OWORD *)(v18 - 3);
        *((_QWORD *)v25 - 1) = *(v18 - 1);
        *(_OWORD *)(v25 - 24) = v28;
        *(_OWORD *)(v25 - 40) = v27;
        v25 -= 40;
        v18 -= 5;
      }
      while (v18 != v20);
      v18 = (_QWORD *)v14[5];
    }
    v14[5] = v25;
    v14[6] = v19;
    v14[7] = v26;
    __src = v47;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v18 = v15;
    v18[1] = v16;
    v18[2] = a3;
    v18[3] = a5;
    v19 = v18 + 5;
    *((_BYTE *)v18 + 32) = v13;
  }
  v14[6] = v19;
  std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>(a1[6] + 120, *(char **)(a1[6] + 128), __src, &__src[a3], a3);
  std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>(a1[6] + 120, *(char **)(a1[6] + 128), a4, &a4[a5], a5);
  *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) += a5 + a3;
}

size_t ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_82(size_t result, char *__s)
{
  uint64_t v2;
  char v4;
  int v5;

  v2 = result;
  if (__s
    && (result = strlen(__s), result >= 3)
    && *__s == 117
    && __s[1] == 61
    && (v4 = __s[2], (v4 - 56) >= 0xF8u))
  {
    v5 = dword_183C6F108[(v4 - 48)];
  }
  else
  {
    v5 = 16;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = v5;
  return result;
}

void nw_http2_enqueue_frame_for_stream(uint64_t a1, uint64_t a2)
{
  int v4;
  _QWORD *v5;
  NSObject *v6;
  int v7;
  int v8;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (((*(unsigned __int16 *)(a1 + 188) | (*(unsigned __int8 *)(a1 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v8 = *(_DWORD *)(a1 + 176);
      v7 = *(_DWORD *)(a1 + 180);
      v19 = 136447746;
      v20 = "nw_http2_enqueue_frame_for_stream";
      v21 = 2082;
      v22 = a1 + 191;
      v23 = 2080;
      v24 = " ";
      v25 = 1024;
      v26 = v7;
      v27 = 1024;
      v28 = v8;
      v29 = 1024;
      v30 = v8;
      v31 = 2048;
      v32 = a2;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d, frame %p", (uint8_t *)&v19, 0x3Cu);
    }
  }
  if (((*(unsigned __int16 *)(a1 + 188) | (*(unsigned __int8 *)(a1 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v11 = *(_DWORD *)(a1 + 176);
      v10 = *(_DWORD *)(a1 + 180);
      v19 = 136447746;
      v20 = "nw_http2_set_stream_output_available_pending";
      v21 = 2082;
      v22 = a1 + 191;
      v23 = 2080;
      v24 = " ";
      v25 = 1024;
      v26 = v10;
      v27 = 1024;
      v28 = v11;
      v29 = 1024;
      v30 = v11;
      v31 = 1024;
      LODWORD(v32) = 0;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d, needs output available: %{BOOL}d", (uint8_t *)&v19, 0x38u);
    }
  }
  v4 = *(_WORD *)(a1 + 188) & 0xFFDF | (*(unsigned __int8 *)(a1 + 190) << 16);
  *(_WORD *)(a1 + 188) &= ~0x20u;
  *(_BYTE *)(a1 + 190) = BYTE2(v4);
  *(_QWORD *)(a2 + 16) = 0;
  v5 = *(_QWORD **)(a1 + 24);
  *(_QWORD *)(a2 + 24) = v5;
  *v5 = a2;
  *(_QWORD *)(a1 + 24) = a2 + 16;
  if (((*(unsigned __int16 *)(a1 + 188) | (*(unsigned __int8 *)(a1 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v12 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v13 = (uint64_t *)(a1 + 16);
      v14 = a1 + 191;
      v17 = a1 + 176;
      v15 = *(_DWORD *)(a1 + 176);
      v16 = *(_DWORD *)(v17 + 4);
      v19 = 0;
      nw_frame_array_get_frame_count(v13, 0, &v19);
      v18 = v19;
      v19 = 136447490;
      v20 = "nw_http2_enqueue_frame_for_stream";
      v21 = 2082;
      v22 = v14;
      v23 = 2080;
      v24 = " ";
      v25 = 1024;
      v26 = v16;
      v27 = 1024;
      v28 = v15;
      v29 = 1024;
      v30 = v18;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream now has %u bytes pending", (uint8_t *)&v19, 0x32u);
    }
  }
}

void std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  size_t v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  unint64_t v24;
  BOOL v25;
  char *v26;
  unint64_t v27;
  __int128 *v28;
  _OWORD *v29;
  unint64_t v30;
  __int128 v31;
  char v32;
  size_t v33;
  char *v34;
  char *v35;
  char *v36;
  unint64_t v37;
  char *v38;
  _OWORD *v39;
  unint64_t v40;
  __int128 v41;
  char v42;
  char *v43;
  char *v44;

  if (a5 < 1)
    return;
  v10 = *(char **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    v11 = *(char **)a1;
    v12 = (uint64_t)&v10[a5 - *(_QWORD *)a1];
    if (v12 < 0)
      abort();
    v13 = (char *)(__dst - v11);
    v14 = v9 - (_QWORD)v11;
    if (2 * v14 > v12)
      v12 = 2 * v14;
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v15 = v12;
    if (v15)
    {
      v16 = v15;
      v15 = (size_t)operator new(v15);
    }
    else
    {
      v16 = 0;
    }
    v33 = v15;
    v34 = &v13[v15];
    memcpy(&v13[v15], __src, a5);
    if (v11 == __dst)
    {
      v35 = v34;
    }
    else
    {
      if ((unint64_t)v13 >= 0x20)
      {
        v37 = __dst - v11;
        v36 = __dst;
        v35 = v34;
        if ((unint64_t)&v11[-v33] >= 0x20)
        {
          v36 = &__dst[-(v37 & 0xFFFFFFFFFFFFFFE0)];
          v38 = __dst - 16;
          v39 = (_OWORD *)(v33 + __dst - 16 - v11);
          v40 = v37 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            v41 = *(_OWORD *)v38;
            *(v39 - 1) = *((_OWORD *)v38 - 1);
            *v39 = v41;
            v38 -= 32;
            v39 -= 2;
            v40 -= 32;
          }
          while (v40);
          v35 = &v34[-(v37 & 0xFFFFFFFFFFFFFFE0)];
          if (v37 == (v37 & 0xFFFFFFFFFFFFFFE0))
            goto LABEL_42;
        }
      }
      else
      {
        v36 = __dst;
        v35 = v34;
      }
      do
      {
        v42 = *--v36;
        *--v35 = v42;
      }
      while (v36 != v11);
      v10 = *(char **)(a1 + 8);
    }
LABEL_42:
    v43 = &v34[a5];
    if (v10 != __dst)
      memmove(v43, __dst, v10 - __dst);
    v44 = *(char **)a1;
    *(_QWORD *)a1 = v35;
    *(_QWORD *)(a1 + 8) = &v43[v10 - __dst];
    *(_QWORD *)(a1 + 16) = v33 + v16;
    if (v44)
      operator delete(v44);
    return;
  }
  v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    v18 = &__src[a5];
    v20 = *(char **)(a1 + 8);
LABEL_17:
    v21 = &__dst[a5];
    v22 = &v20[-a5];
    v23 = v20;
    if (&v20[-a5] < v10)
    {
      v24 = &v10[a5] - v20;
      v25 = v24 >= 0x20 && (unint64_t)a5 > 0x1F;
      v26 = &v20[-a5];
      v23 = v20;
      if (!v25)
        goto LABEL_50;
      v27 = v24 & 0xFFFFFFFFFFFFFFE0;
      v26 = &v22[v24 & 0xFFFFFFFFFFFFFFE0];
      v28 = (__int128 *)(v22 + 16);
      v29 = v20 + 16;
      v30 = v24 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v31 = *v28;
        *(v29 - 1) = *(v28 - 1);
        *v29 = v31;
        v28 += 2;
        v29 += 2;
        v30 -= 32;
      }
      while (v30);
      v23 = &v20[v27];
      if (v24 != v27)
      {
LABEL_50:
        do
        {
          v32 = *v26++;
          *v23++ = v32;
        }
        while (v26 != v10);
      }
    }
    *(_QWORD *)(a1 + 8) = v23;
    if (v20 != v21)
      memmove(&__dst[a5], __dst, v20 - v21);
    if (v18 != __src)
      memmove(__dst, __src, v18 - __src);
    return;
  }
  v18 = &__src[v17];
  v19 = a4 - &__src[v17];
  if (a4 != &__src[v17])
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  v20 = &v10[v19];
  *(_QWORD *)(a1 + 8) = &v10[v19];
  if (v17 >= 1)
    goto LABEL_17;
}

BOOL ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  _DWORD *v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  const char *v27;
  uint64_t v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  uint64_t v32;
  const char *v33;
  unint64_t v34;
  unsigned int v35;
  char *backtrace_string;
  _BOOL4 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  char *v45;
  _BOOL4 v46;
  NSObject *v47;
  uint64_t v48;
  const char *v49;
  const char *v50;
  BOOL v51;
  int v52;
  uint64_t v53;
  unsigned int v54;
  char v55;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  const char *v62;
  __int16 v63;
  _BYTE v64[20];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v54 = 0;
  v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v54);
  if (v4)
  {
    if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
      return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
    v8 = *(unsigned __int16 *)(*(_QWORD *)(a1[5] + 8) + 24);
    if (16 - v8 >= (unint64_t)v54)
      v9 = v54;
    else
      v9 = 16 - v8;
    memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) + v8), v4, v9);
    *(_WORD *)(*(_QWORD *)(a1[5] + 8) + 24) += v9;
    v10 = *(_DWORD **)(*(_QWORD *)(a1[6] + 8) + 24);
    if (v10)
    {
      v11 = *(unsigned __int16 *)(*(_QWORD *)(a1[5] + 8) + 24);
      if (!*(_WORD *)(*(_QWORD *)(a1[5] + 8) + 24))
        return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
      v12 = *(unsigned __int8 *)v10;
      if (v12 > 0x3F)
      {
        v19 = v12 >> 6;
        if (v19 == 2)
        {
          if (v11 < 4)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v12 = bswap32(*v10 & 0xFFFFFF7F);
          v13 = 4;
        }
        else if (v19 == 1)
        {
          if (v11 < 2)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v12 = bswap32(*(_WORD *)v10 & 0xFFBF) >> 16;
          v13 = 2;
        }
        else
        {
          if (v11 < 8)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v12 = bswap64(*(_QWORD *)v10 & 0xFFFFFFFFFFFFFF3FLL);
          v13 = 8;
        }
      }
      else
      {
        v13 = 1;
      }
      *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = v12;
      *(_WORD *)(*(_QWORD *)(a1[8] + 8) + 24) = v13;
      v14 = v11 - v13;
      if (!v14)
        return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
      v15 = (_DWORD *)((char *)v10 + v13);
      v16 = *(unsigned __int8 *)v15;
      if (v16 > 0x3F)
      {
        v20 = v16 >> 6;
        if (v20 == 2)
        {
          if (v14 < 4)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v16 = bswap32(*v15 & 0xFFFFFF7F);
          v17 = 4;
        }
        else if (v20 == 1)
        {
          if (v14 < 2)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v16 = bswap32(*(_WORD *)v15 & 0xFFBF) >> 16;
          v17 = 2;
        }
        else
        {
          if (v14 < 8)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v16 = bswap64(*(_QWORD *)v15 & 0xFFFFFFFFFFFFFF3FLL);
          v17 = 8;
        }
      }
      else
      {
        v17 = 1;
      }
      *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24) = v16;
      *(_WORD *)(*(_QWORD *)(a1[8] + 8) + 24) += v17;
      if (*(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24))
        goto LABEL_17;
      v21 = v17;
      if (v14 == v17)
        return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
      v22 = *((unsigned __int8 *)v15 + v17);
      if (v22 > 0x3F)
      {
        v34 = v14 - v21;
        v35 = v22 >> 6;
        if (v35 == 2)
        {
          if (v34 < 4)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v22 = bswap32(*(_DWORD *)((char *)v15 + v21) & 0xFFFFFF7F);
          v23 = 4;
        }
        else if (v35 == 1)
        {
          if (v34 < 2)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v22 = bswap32(*(_WORD *)((_BYTE *)v15 + v21) & 0xFFBF) >> 16;
          v23 = 2;
        }
        else
        {
          if (v34 < 8)
            return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
          v22 = bswap64(*(_QWORD *)((_BYTE *)v15 + v21) & 0xFFFFFFFFFFFFFF3FLL);
          v23 = 8;
        }
      }
      else
      {
        v23 = 1;
      }
      *(_QWORD *)(*(_QWORD *)(a1[10] + 8) + 24) = v22;
      *(_WORD *)(*(_QWORD *)(a1[8] + 8) + 24) += v23;
      v24 = a1[11];
      if ((!v24 || (*(__int16 *)(v24 + 376) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v48 = a1[11];
          v49 = "";
          v50 = (const char *)(v48 + 378);
          v51 = v48 == 0;
          if (!v48)
            v50 = "";
          v52 = *(_DWORD *)(v48 + 368);
          if (!v51)
            v49 = " ";
          v53 = *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24);
          *(_DWORD *)buf = 136447490;
          v58 = "nw_protocol_http2_get_input_frames_block_invoke";
          v59 = 2082;
          v60 = v50;
          v61 = 2080;
          v62 = v49;
          v63 = 1024;
          *(_DWORD *)v64 = v52;
          *(_WORD *)&v64[4] = 2048;
          *(_QWORD *)&v64[6] = v53;
          *(_WORD *)&v64[14] = 1024;
          *(_DWORD *)&v64[16] = v23;
          _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Receiving capsule length %llu, adjusting by %u", buf, 0x36u);
        }
      }
      v25 = *(_QWORD *)(a1[9] + 8);
      v26 = *(_QWORD *)(v25 + 24);
      v27 = (const char *)v23;
      *(_QWORD *)(v25 + 24) = v26 - v23;
      if (v26 >= v23)
      {
LABEL_17:
        v5 = 0;
        *(_WORD *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
        *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
        return v5;
      }
      __nwlog_obj();
      v28 = *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24);
      *(_DWORD *)buf = 136446978;
      v58 = "nw_protocol_http2_get_input_frames_block_invoke";
      v59 = 2082;
      v60 = "capsule_length";
      v61 = 2048;
      v62 = (const char *)v23;
      v63 = 2048;
      *(_QWORD *)v64 = v28;
      v29 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (__nwlog_fault(v29, &type, &v55))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v30 = __nwlog_obj();
          v31 = type;
          if (os_log_type_enabled(v30, type))
          {
            v32 = *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24);
            *(_DWORD *)buf = 136446978;
            v58 = "nw_protocol_http2_get_input_frames_block_invoke";
            v59 = 2082;
            v60 = "capsule_length";
            v61 = 2048;
            v62 = v27;
            v63 = 2048;
            *(_QWORD *)v64 = v32;
            v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_65:
            _os_log_impl(&dword_182FBE000, v30, v31, v33, buf, 0x2Au);
          }
        }
        else if (v55)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v30 = __nwlog_obj();
          v31 = type;
          v37 = os_log_type_enabled(v30, type);
          if (backtrace_string)
          {
            if (v37)
            {
              v38 = *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24);
              *(_DWORD *)buf = 136447234;
              v58 = "nw_protocol_http2_get_input_frames_block_invoke";
              v59 = 2082;
              v60 = "capsule_length";
              v61 = 2048;
              v62 = v27;
              v63 = 2048;
              *(_QWORD *)v64 = v38;
              *(_WORD *)&v64[8] = 2082;
              *(_QWORD *)&v64[10] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(backtrace_string);
            goto LABEL_66;
          }
          if (v37)
          {
            v40 = *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24);
            *(_DWORD *)buf = 136446978;
            v58 = "nw_protocol_http2_get_input_frames_block_invoke";
            v59 = 2082;
            v60 = "capsule_length";
            v61 = 2048;
            v62 = v27;
            v63 = 2048;
            *(_QWORD *)v64 = v40;
            v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_65;
          }
        }
        else
        {
          v30 = __nwlog_obj();
          v31 = type;
          if (os_log_type_enabled(v30, type))
          {
            v39 = *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24);
            *(_DWORD *)buf = 136446978;
            v58 = "nw_protocol_http2_get_input_frames_block_invoke";
            v59 = 2082;
            v60 = "capsule_length";
            v61 = 2048;
            v62 = v27;
            v63 = 2048;
            *(_QWORD *)v64 = v39;
            v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_65;
          }
        }
      }
LABEL_66:
      if (v29)
        free(v29);
      *(_QWORD *)(*(_QWORD *)(a1[9] + 8) + 24) = 0;
      goto LABEL_17;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v58 = "_http_vle_decode";
    v41 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (__nwlog_fault(v41, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v42 = __nwlog_obj();
        v43 = type;
        if (!os_log_type_enabled(v42, type))
          goto LABEL_83;
        *(_DWORD *)buf = 136446210;
        v58 = "_http_vle_decode";
        v44 = "%{public}s called with null *buffer";
        goto LABEL_82;
      }
      if (!v55)
      {
        v42 = __nwlog_obj();
        v43 = type;
        if (!os_log_type_enabled(v42, type))
          goto LABEL_83;
        *(_DWORD *)buf = 136446210;
        v58 = "_http_vle_decode";
        v44 = "%{public}s called with null *buffer, backtrace limit exceeded";
        goto LABEL_82;
      }
      v45 = (char *)__nw_create_backtrace_string();
      v42 = __nwlog_obj();
      v43 = type;
      v46 = os_log_type_enabled(v42, type);
      if (v45)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          v58 = "_http_vle_decode";
          v59 = 2082;
          v60 = v45;
          _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s called with null *buffer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v45);
        goto LABEL_83;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "_http_vle_decode";
        v44 = "%{public}s called with null *buffer, no backtrace";
LABEL_82:
        _os_log_impl(&dword_182FBE000, v42, v43, v44, buf, 0xCu);
      }
    }
LABEL_83:
    if (v41)
      free(v41);
    return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
  }
  v6 = *(_QWORD *)(a2 + 32);
  v7 = *(_QWORD **)(a2 + 40);
  if (v6)
  {
    *(_QWORD *)(v6 + 40) = v7;
    v7 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(a1[12] + 8) = v7;
  }
  *v7 = v6;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v5 = 1;
  nw_frame_finalize(a2);
  return v5;
}

BOOL ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_63(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;
  const void *v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  dispatch_data_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  dispatch_data_t v27;
  NSObject *v28;
  dispatch_data_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  dispatch_data_t concat;
  NSObject *v35;
  uint64_t v36;
  const char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  uint64_t v41;
  _QWORD *v42;
  char *v43;
  _BOOL4 v44;
  char *v45;
  uint64_t v46;
  size_t v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  BOOL v51;
  int v52;
  const char *v53;
  const char *v54;
  NSObject *v55;
  os_log_type_t v56;
  uint64_t v57;
  const char *v58;
  BOOL v59;
  int v60;
  const char *v61;
  const char *v62;
  char *backtrace_string;
  _BOOL4 v64;
  uint64_t v65;
  const char *v66;
  const char *v67;
  int v68;
  uint64_t v69;
  const char *v70;
  BOOL v71;
  int v72;
  const char *v73;
  uint64_t v74;
  const char *v75;
  BOOL v76;
  int v77;
  const char *v78;
  char v80;
  os_log_type_t type;
  unsigned int size;
  int size_4;
  const char *v84;
  __int16 v85;
  void *v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  int v90;
  __int16 v91;
  char *v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  size = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &size);
  v6 = *(_QWORD *)(a1[4] + 8);
  v7 = *(unsigned __int16 *)(v6 + 24);
  if (*(_WORD *)(v6 + 24))
  {
    if (size < v7)
    {
      *(_WORD *)(v6 + 24) = v7 - size;
      v8 = *(_QWORD *)(a2 + 32);
      v9 = *(_QWORD **)(a2 + 40);
      if (v8)
      {
        *(_QWORD *)(v8 + 40) = v9;
        v9 = *(_QWORD **)(a2 + 40);
      }
      else
      {
        *(_QWORD *)(a1[8] + 8) = v9;
      }
      *v9 = v8;
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 40) = 0;
      v22 = 1;
      nw_frame_finalize(a2);
      return v22;
    }
    nw_frame_claim(a2, v5, v7, 0);
    v10 = (const void *)nw_frame_unclaimed_bytes(a2, &size);
    *(_WORD *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
  }
  else
  {
    v10 = (const void *)v4;
  }
  v11 = *(_QWORD *)(a1[5] + 8);
  v12 = *(_QWORD *)(v11 + 24);
  if (!v12)
    return 0;
  v13 = size;
  if (v12 <= size)
  {
    v18 = a1[10];
    if (!v18)
    {
      v29 = dispatch_data_create(v10, v12, 0, 0);
      if (v29)
      {
        v31 = v29;
        v32 = *(_QWORD *)(a1[7] + 8);
        v33 = *(NSObject **)(v32 + 24);
        if (v33)
        {
          concat = dispatch_data_create_concat(v33, v31);
          v35 = *(NSObject **)(*(_QWORD *)(a1[7] + 8) + 24);
          if (v35)
          {
            dispatch_release(v35);
            *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = 0;
          }
          dispatch_release(v31);
          *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = concat;
        }
        else
        {
          *(_QWORD *)(v32 + 24) = v31;
        }
      }
      goto LABEL_87;
    }
    v19 = *(_QWORD *)(v18 + 112);
    if (v19)
    {
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0
        || !g_channel_check_validity
        || g_channel_check_validity(a1[10], *(_QWORD *)(v18 + 88)))
      {
        LODWORD(v19) = *(_DWORD *)(v18 + 52);
        v20 = *(unsigned int *)(v18 + 56);
        if ((_DWORD)v19)
          LODWORD(v19) = v19 - (v20 + *(_DWORD *)(v18 + 60));
        v21 = *(_QWORD *)(v18 + 112) + v20;
        goto LABEL_65;
      }
      LODWORD(v19) = 0;
    }
    v21 = 0;
LABEL_65:
    v46 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
    v47 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
    if (v47 + v46 > v19)
    {
      v48 = a1[11];
      if (v48 && *(__int16 *)(v48 + 376) < 0)
        return 0;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v49 = a1[11];
      v50 = (const char *)(v49 + 378);
      v51 = v49 == 0;
      v52 = *(_DWORD *)(v49 + 368);
      size_4 = 136446978;
      if (v51)
        v50 = "";
      v84 = "nw_protocol_http2_get_input_frames_block_invoke";
      if (v51)
        v53 = "";
      else
        v53 = " ";
      v85 = 2082;
      v86 = (void *)v50;
      v87 = 2080;
      v88 = v53;
      v89 = 1024;
      v90 = v52;
      v54 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v80 = 0;
      if (__nwlog_fault(v54, &type, &v80))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v55 = gconnectionLogObj;
          v56 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            v57 = a1[11];
            v58 = (const char *)(v57 + 378);
            v59 = v57 == 0;
            if (!v57)
              v58 = "";
            v60 = *(_DWORD *)(v57 + 368);
            if (v59)
              v61 = "";
            else
              v61 = " ";
            size_4 = 136446978;
            v84 = "nw_protocol_http2_get_input_frames_block_invoke";
            v85 = 2082;
            v86 = (void *)v58;
            v87 = 2080;
            v88 = v61;
            v89 = 1024;
            v90 = v60;
            v62 = "%{public}s %{public}s%s<i%u> Datagram frame is too short";
LABEL_114:
            _os_log_impl(&dword_182FBE000, v55, v56, v62, (uint8_t *)&size_4, 0x26u);
          }
        }
        else if (v80)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v55 = gconnectionLogObj;
          v56 = type;
          v64 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (!backtrace_string)
          {
            if (!v64)
              goto LABEL_115;
            v74 = a1[11];
            v75 = (const char *)(v74 + 378);
            v76 = v74 == 0;
            if (!v74)
              v75 = "";
            v77 = *(_DWORD *)(v74 + 368);
            if (v76)
              v78 = "";
            else
              v78 = " ";
            size_4 = 136446978;
            v84 = "nw_protocol_http2_get_input_frames_block_invoke";
            v85 = 2082;
            v86 = (void *)v75;
            v87 = 2080;
            v88 = v78;
            v89 = 1024;
            v90 = v77;
            v62 = "%{public}s %{public}s%s<i%u> Datagram frame is too short, no backtrace";
            goto LABEL_114;
          }
          if (v64)
          {
            v65 = a1[11];
            v66 = (const char *)(v65 + 378);
            if (v65)
            {
              v67 = " ";
            }
            else
            {
              v66 = "";
              v67 = "";
            }
            v68 = *(_DWORD *)(v65 + 368);
            size_4 = 136447234;
            v84 = "nw_protocol_http2_get_input_frames_block_invoke";
            v85 = 2082;
            v86 = (void *)v66;
            v87 = 2080;
            v88 = v67;
            v89 = 1024;
            v90 = v68;
            v91 = 2082;
            v92 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s %{public}s%s<i%u> Datagram frame is too short, dumping backtrace:%{public}s", (uint8_t *)&size_4, 0x30u);
          }
          free(backtrace_string);
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v55 = gconnectionLogObj;
          v56 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            v69 = a1[11];
            v70 = (const char *)(v69 + 378);
            v71 = v69 == 0;
            if (!v69)
              v70 = "";
            v72 = *(_DWORD *)(v69 + 368);
            if (v71)
              v73 = "";
            else
              v73 = " ";
            size_4 = 136446978;
            v84 = "nw_protocol_http2_get_input_frames_block_invoke";
            v85 = 2082;
            v86 = (void *)v70;
            v87 = 2080;
            v88 = v73;
            v89 = 1024;
            v90 = v72;
            v62 = "%{public}s %{public}s%s<i%u> Datagram frame is too short, backtrace limit exceeded";
            goto LABEL_114;
          }
        }
      }
LABEL_115:
      if (v54)
      {
        v45 = (char *)v54;
        goto LABEL_117;
      }
      return 0;
    }
    memcpy((void *)(v21 + v46), v10, v47);
    *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) += *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
LABEL_87:
    nw_frame_claim(a2, v30, *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24), 0);
    v22 = 0;
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
    return v22;
  }
  *(_QWORD *)(v11 + 24) = v12 - size;
  v14 = a1[10];
  if (!v14)
  {
    v23 = dispatch_data_create(v10, v13, 0, 0);
    if (v23)
    {
      v24 = v23;
      v25 = *(_QWORD *)(a1[7] + 8);
      v26 = *(NSObject **)(v25 + 24);
      if (v26)
      {
        v27 = dispatch_data_create_concat(v26, v24);
        v28 = *(NSObject **)(*(_QWORD *)(a1[7] + 8) + 24);
        if (v28)
        {
          dispatch_release(v28);
          *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = 0;
        }
        dispatch_release(v24);
        *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = v27;
      }
      else
      {
        *(_QWORD *)(v25 + 24) = v24;
      }
    }
    goto LABEL_47;
  }
  v15 = *(_QWORD *)(v14 + 112);
  if (v15)
  {
    if ((*(_WORD *)(v14 + 204) & 0x100) == 0
      || !g_channel_check_validity
      || g_channel_check_validity(a1[10], *(_QWORD *)(v14 + 88)))
    {
      LODWORD(v15) = *(_DWORD *)(v14 + 52);
      v16 = *(unsigned int *)(v14 + 56);
      if ((_DWORD)v15)
        LODWORD(v15) = v15 - (v16 + *(_DWORD *)(v14 + 60));
      v17 = *(_QWORD *)(v14 + 112) + v16;
      goto LABEL_41;
    }
    LODWORD(v15) = 0;
  }
  v17 = 0;
LABEL_41:
  v36 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
  if (v15 < size + v36)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_4 = 136446210;
    v84 = "nw_protocol_http2_get_input_frames_block_invoke";
    v37 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (!__nwlog_fault(v37, &type, &v80))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v38 = gLogObj;
      v39 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_61;
      size_4 = 136446210;
      v84 = "nw_protocol_http2_get_input_frames_block_invoke";
      v40 = "%{public}s Datagram frame is too short";
    }
    else if (v80)
    {
      v43 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v38 = gLogObj;
      v39 = type;
      v44 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v43)
      {
        if (v44)
        {
          size_4 = 136446466;
          v84 = "nw_protocol_http2_get_input_frames_block_invoke";
          v85 = 2082;
          v86 = v43;
          _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s Datagram frame is too short, dumping backtrace:%{public}s", (uint8_t *)&size_4, 0x16u);
        }
        free(v43);
LABEL_61:
        if (v37)
        {
          v45 = (char *)v37;
LABEL_117:
          free(v45);
          return 0;
        }
        return 0;
      }
      if (!v44)
        goto LABEL_61;
      size_4 = 136446210;
      v84 = "nw_protocol_http2_get_input_frames_block_invoke";
      v40 = "%{public}s Datagram frame is too short, no backtrace";
    }
    else
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type))
        goto LABEL_61;
      size_4 = 136446210;
      v84 = "nw_protocol_http2_get_input_frames_block_invoke";
      v40 = "%{public}s Datagram frame is too short, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v38, v39, v40, (uint8_t *)&size_4, 0xCu);
    goto LABEL_61;
  }
  memcpy((void *)(v17 + v36), v10, size);
  *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) += size;
LABEL_47:
  v41 = *(_QWORD *)(a2 + 32);
  v42 = *(_QWORD **)(a2 + 40);
  if (v41)
  {
    *(_QWORD *)(v41 + 40) = v42;
    v42 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(a1[8] + 8) = v42;
  }
  *v42 = v41;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) != 0;
}

uint64_t ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_66(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  size_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t input_frame;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  BOOL v28;
  int v29;
  int v30;
  uint64_t v31;
  const char *v32;
  NSObject *v33;
  uint32_t v34;
  void *v35;
  char *v36;
  _BOOL4 v37;
  uint64_t v38;
  NSObject *v39;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  _BOOL4 v45;
  _BYTE *v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  const char *v50;
  BOOL v51;
  int v52;
  int v53;
  uint64_t v54;
  const char *v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  uint64_t v67;
  const char *v68;
  char *backtrace_string;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  BOOL v74;
  int v75;
  int v76;
  uint64_t v77;
  const char *v78;
  char *v79;
  NSObject *v80;
  os_log_type_t v81;
  uint64_t v82;
  const char *v83;
  const char *v84;
  int v85;
  int v86;
  uint64_t v87;
  const char *v88;
  char *v89;
  _BOOL4 v90;
  uint64_t v91;
  const char *v92;
  const char *v93;
  int v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v100;
  const char *v101;
  const char *v102;
  int v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  const char *v107;
  const char *v108;
  int v109;
  int v110;
  uint64_t v111;
  NSObject *v112;
  os_log_type_t v113;
  uint32_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  BOOL v119;
  const char *v120;
  const char *v121;
  const char *v122;
  NSObject *v123;
  uint32_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  const char *v128;
  BOOL v129;
  int v130;
  const char *v131;
  uint64_t v132;
  uint64_t v133;
  const char *v134;
  const char *v135;
  BOOL v136;
  int v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  const char *v144;
  const char *v145;
  int v146;
  uint64_t v147;
  int v148;
  NSObject *v149;
  uint32_t v150;
  NSObject *v151;
  _BOOL4 v152;
  const char *v153;
  const char *v154;
  int v155;
  int v156;
  BOOL v157;
  uint64_t v158;
  uint64_t v159;
  const char *v160;
  const char *v161;
  int v162;
  int v163;
  uint64_t v164;
  int v165;
  uint64_t v166;
  NSObject *v167;
  uint64_t v168;
  const char *v169;
  const char *v170;
  int v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  const char *v175;
  BOOL v176;
  int v177;
  const char *v178;
  NSObject *v179;
  os_log_type_t v180;
  uint64_t v181;
  const char *v182;
  BOOL v183;
  int v184;
  const char *v185;
  NSObject *v186;
  uint64_t v187;
  const char *v188;
  const char *v189;
  int v190;
  int v191;
  int v192;
  char *v193;
  _BOOL4 v194;
  uint64_t v195;
  const char *v196;
  BOOL v197;
  int v198;
  const char *v199;
  uint64_t v200;
  const char *v201;
  BOOL v202;
  int v203;
  const char *v204;
  uint64_t v205;
  const char *v206;
  BOOL v207;
  int v208;
  const char *v209;
  char v210;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v213;
  __int16 v214;
  const char *v215;
  __int16 v216;
  uint64_t v217;
  __int16 v218;
  _BYTE v219[36];
  __int16 v220;
  _BOOL4 v221;
  uint64_t v222;

  v222 = *MEMORY[0x1E0C80C00];
  v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  if ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 1) > *(_DWORD *)(a1 + 72))
    return 0;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v6 = *(_DWORD *)(v5 + 24);
  v7 = *(_DWORD *)(a1 + 76);
  v8 = v7 - v6;
  if (v7 <= v6)
    return 0;
  v9 = v4;
  v10 = v4 - v8;
  if (v4 <= v8)
  {
    *(_DWORD *)(v5 + 24) = v6 + v4;
    v17 = *(_QWORD *)(a2 + 32);
    v18 = *(_QWORD **)(a2 + 40);
    if (v17)
    {
      *(_QWORD *)(v17 + 40) = v18;
      v18 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) = v18;
    }
    *v18 = v17;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    v23 = *(_QWORD *)(a1 + 48);
    if (v23)
    {
      v13 = a2;
      if (((*(unsigned __int16 *)(v23 + 188) | (*(unsigned __int8 *)(v23 + 190) << 16)) & 0x80000) == 0)
      {
        v13 = a2;
        if (gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v24 = gconnectionLogObj;
          v13 = a2;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v25 = *(_QWORD *)(a1 + 48);
            v26 = (const char *)(v25 + 191);
            v27 = "";
            v28 = v25 == 0;
            if (!v25)
              v26 = "";
            v31 = v25 + 176;
            v29 = *(_DWORD *)(v25 + 176);
            v30 = *(_DWORD *)(v31 + 4);
            if (!v28)
              v27 = " ";
            *(_DWORD *)buf = 136447490;
            v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            v214 = 2082;
            v215 = v26;
            v216 = 2080;
            v217 = (uint64_t)v27;
            v218 = 1024;
            *(_DWORD *)v219 = v30;
            *(_WORD *)&v219[4] = 1024;
            *(_DWORD *)&v219[6] = v29;
            *(_WORD *)&v219[10] = 1024;
            *(_DWORD *)&v219[12] = v9;
            v32 = "%{public}s %{public}s%s<i%u:s%d> delivering entire incoming frame (%u bytes)";
            v33 = v24;
            v34 = 50;
LABEL_32:
            _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, v32, buf, v34);
            v13 = a2;
          }
        }
      }
    }
    else
    {
      v125 = *(_QWORD *)(a1 + 56);
      if (!v125 || (v13 = a2, (*(__int16 *)(v125 + 376) & 0x80000000) == 0))
      {
        v13 = a2;
        if (gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v126 = gconnectionLogObj;
          v13 = a2;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v127 = *(_QWORD *)(a1 + 56);
            v128 = "";
            v129 = v127 == 0;
            v130 = *(_DWORD *)(v127 + 368);
            v131 = (const char *)(v127 + 378);
            v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            v214 = 2082;
            if (v129)
              v131 = "";
            *(_DWORD *)buf = 136447234;
            if (!v129)
              v128 = " ";
            v215 = v131;
            v216 = 2080;
            v217 = (uint64_t)v128;
            v218 = 1024;
            *(_DWORD *)v219 = v130;
            *(_WORD *)&v219[4] = 1024;
            *(_DWORD *)&v219[6] = v9;
            v32 = "%{public}s %{public}s%s<i%u> delivering entire incoming frame (%u bytes)";
            v33 = v126;
            v34 = 44;
            goto LABEL_32;
          }
        }
      }
    }
LABEL_47:
    v43 = *(_QWORD *)(a1 + 48);
    v44 = *(unsigned __int16 *)(v43 + 188) | (*(unsigned __int8 *)(v43 + 190) << 16);
    if (!*(_QWORD *)(v43 + 112))
    {
      if ((v44 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v48 = *(_QWORD *)(a1 + 48);
          v49 = "";
          v50 = (const char *)(v48 + 191);
          v51 = v48 == 0;
          if (!v48)
            v50 = "";
          v54 = v48 + 176;
          v52 = *(_DWORD *)(v48 + 176);
          v53 = *(_DWORD *)(v54 + 4);
          if (!v51)
            v49 = " ";
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v50;
          v216 = 2080;
          v217 = (uint64_t)v49;
          v218 = 1024;
          *(_DWORD *)v219 = v53;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v52;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v52;
          *(_WORD *)&v219[16] = 2048;
          *(_QWORD *)&v219[18] = a2;
          v55 = "%{public}s %{public}s%s<i%u:s%d> stream %d has no metadata to set on frame %p";
          goto LABEL_203;
        }
      }
LABEL_71:
      v58 = *(_QWORD *)(a1 + 64);
      *(_QWORD *)(v13 + 32) = 0;
      v59 = *(uint64_t **)(v58 + 8);
      *(_QWORD *)(v13 + 40) = v59;
      *v59 = v13;
      *(_QWORD *)(v58 + 8) = v13 + 32;
      v60 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v61 = *(unsigned int *)(v60 + 24) + 1;
      v62 = v61 << 31 >> 31;
      *(_DWORD *)(v60 + 24) = v61;
      if (v62 == v61 && (v62 & 0x8000000000000000) == 0)
        return 1;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v63 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      *(_DWORD *)buf = 136446978;
      v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      v214 = 2082;
      v215 = "return_frame_count";
      v216 = 2048;
      v217 = 1;
      v218 = 2048;
      *(_QWORD *)v219 = v63;
      v64 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v210 = 0;
      if (__nwlog_fault(v64, &type, &v210))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v65 = gLogObj;
          v66 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            v67 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136446978;
            v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            v214 = 2082;
            v215 = "return_frame_count";
            v216 = 2048;
            v217 = 1;
            v218 = 2048;
            *(_QWORD *)v219 = v67;
            v68 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_115:
            _os_log_impl(&dword_182FBE000, v65, v66, v68, buf, 0x2Au);
          }
        }
        else if (v210)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v65 = gLogObj;
          v66 = type;
          v70 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v70)
            {
              v71 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136447234;
              v213 = "nw_protocol_http2_get_input_frames_block_invoke";
              v214 = 2082;
              v215 = "return_frame_count";
              v216 = 2048;
              v217 = 1;
              v218 = 2048;
              *(_QWORD *)v219 = v71;
              *(_WORD *)&v219[8] = 2082;
              *(_QWORD *)&v219[10] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(backtrace_string);
            goto LABEL_116;
          }
          if (v70)
          {
            v98 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136446978;
            v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            v214 = 2082;
            v215 = "return_frame_count";
            v216 = 2048;
            v217 = 1;
            v218 = 2048;
            *(_QWORD *)v219 = v98;
            v68 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_115;
          }
        }
        else
        {
          v65 = __nwlog_obj();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            v97 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136446978;
            v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            v214 = 2082;
            v215 = "return_frame_count";
            v216 = 2048;
            v217 = 1;
            v218 = 2048;
            *(_QWORD *)v219 = v97;
            v68 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_115;
          }
        }
      }
LABEL_116:
      if (v64)
        free(v64);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
      return 1;
    }
    if ((*(_WORD *)(v43 + 188) & 0x1000) != 0)
    {
      v45 = *(_QWORD *)v43 == 0;
      v46 = &unk_1ECD84000;
      if ((v44 & 0x80000) != 0)
        goto LABEL_63;
    }
    else
    {
      v45 = 0;
      v46 = (_BYTE *)&unk_1ECD84000;
      if ((v44 & 0x80000) != 0)
        goto LABEL_63;
    }
    if (v46[1345])
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v151 = gconnectionLogObj;
      v152 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      v43 = *(_QWORD *)(a1 + 48);
      if (v152)
      {
        v153 = (const char *)(v43 + 191);
        v154 = "";
        v156 = *(_DWORD *)(v43 + 176);
        v155 = *(_DWORD *)(v43 + 180);
        v157 = v43 == 0;
        if (!v43)
          v153 = "";
        v158 = *(_QWORD *)(v43 + 112);
        if (!v157)
          v154 = " ";
        *(_DWORD *)buf = 136448258;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v153;
        v216 = 2080;
        v217 = (uint64_t)v154;
        v218 = 1024;
        *(_DWORD *)v219 = v155;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v156;
        *(_WORD *)&v219[10] = 2048;
        *(_QWORD *)&v219[12] = v158;
        *(_WORD *)&v219[20] = 1024;
        *(_DWORD *)&v219[22] = v156;
        *(_WORD *)&v219[26] = 2048;
        *(_QWORD *)&v219[28] = a2;
        v220 = 1024;
        v221 = v45;
        _os_log_impl(&dword_182FBE000, v151, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting metadata %p from stream %d on frame %p, complete %u", buf, 0x4Cu);
        v43 = *(_QWORD *)(a1 + 48);
      }
    }
LABEL_63:
    nw_frame_set_metadata(a2, *(NSObject **)(v43 + 112), 1, v45);
    if (v45)
      v56 = 0x80;
    else
      v56 = 0;
    *(_BYTE *)(a2 + 186) = v56 & 0x80 | *(_BYTE *)(a2 + 186) & 0x7F;
    if (v45)
      *(_WORD *)(*(_QWORD *)(a1 + 48) + 188) |= 0x8000u;
    v57 = *(_QWORD *)(a1 + 48);
    if (v57)
    {
      if (((*(unsigned __int16 *)(v57 + 188) | (*(unsigned __int8 *)(v57 + 190) << 16)) & 0x80000) == 0 && v46[1345])
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v159 = *(_QWORD *)(a1 + 48);
          v160 = (const char *)(v159 + 191);
          v161 = "";
          if (!v159)
            v160 = "";
          v163 = *(_DWORD *)(v159 + 176);
          v162 = *(_DWORD *)(v159 + 180);
          if (v159)
            v161 = " ";
          v164 = **(_QWORD **)(*(_QWORD *)(v159 + 8) + 8);
          v165 = (*(unsigned __int16 *)(v159 + 188) >> 12) & 1;
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v160;
          v216 = 2080;
          v217 = (uint64_t)v161;
          v218 = 1024;
          *(_DWORD *)v219 = v162;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v163;
          *(_WORD *)&v219[10] = 2048;
          *(_QWORD *)&v219[12] = v164;
          *(_WORD *)&v219[20] = 1024;
          *(_DWORD *)&v219[22] = v165;
          v55 = "%{public}s %{public}s%s<i%u:s%d> last frame in input_frames is %p, inbound_message_complete: %u";
LABEL_203:
          v149 = v47;
          v150 = 60;
LABEL_204:
          _os_log_impl(&dword_182FBE000, v149, OS_LOG_TYPE_DEBUG, v55, buf, v150);
          goto LABEL_71;
        }
      }
    }
    else
    {
      v140 = *(_QWORD *)(a1 + 56);
      if ((!v140 || (*(__int16 *)(v140 + 376) & 0x80000000) == 0) && v46[1345])
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v141 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v143 = *(_QWORD *)(a1 + 48);
          v142 = *(_QWORD *)(a1 + 56);
          v144 = (const char *)(v142 + 378);
          v145 = "";
          if (v142)
            v145 = " ";
          else
            v144 = "";
          v146 = *(_DWORD *)(v142 + 368);
          v147 = **(_QWORD **)(*(_QWORD *)(v143 + 8) + 8);
          v148 = (*(unsigned __int16 *)(v143 + 188) >> 12) & 1;
          *(_DWORD *)buf = 136447490;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v144;
          v216 = 2080;
          v217 = (uint64_t)v145;
          v218 = 1024;
          *(_DWORD *)v219 = v146;
          *(_WORD *)&v219[4] = 2048;
          *(_QWORD *)&v219[6] = v147;
          *(_WORD *)&v219[14] = 1024;
          *(_DWORD *)&v219[16] = v148;
          v55 = "%{public}s %{public}s%s<i%u> last frame in input_frames is %p, inbound_message_complete: %u";
          v149 = v141;
          v150 = 54;
          goto LABEL_204;
        }
      }
    }
    goto LABEL_71;
  }
  v11 = *(_QWORD *)(a1 + 48);
  if (v11)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v132 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v133 = *(_QWORD *)(a1 + 48);
        v134 = (const char *)(v133 + 191);
        v135 = "";
        v136 = v133 == 0;
        if (!v133)
          v134 = "";
        v139 = v133 + 176;
        v137 = *(_DWORD *)(v133 + 176);
        v138 = *(_DWORD *)(v139 + 4);
        if (!v136)
          v135 = " ";
        *(_DWORD *)buf = 136447746;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v134;
        v216 = 2080;
        v217 = (uint64_t)v135;
        v218 = 1024;
        *(_DWORD *)v219 = v138;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v137;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        *(_WORD *)&v219[16] = 1024;
        *(_DWORD *)&v219[18] = v9;
        v122 = "%{public}s %{public}s%s<i%u:s%d> remaining space %u less than frame length %u";
        v123 = v132;
        v124 = 56;
LABEL_176:
        _os_log_impl(&dword_182FBE000, v123, OS_LOG_TYPE_DEBUG, v122, buf, v124);
      }
    }
  }
  else
  {
    v115 = *(_QWORD *)(a1 + 56);
    if ((!v115 || (*(__int16 *)(v115 + 376) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v116 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v117 = *(_QWORD *)(a1 + 56);
        v118 = *(_DWORD *)(v117 + 368);
        v119 = v117 == 0;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        if (v117)
          v120 = (const char *)(v117 + 378);
        else
          v120 = "";
        v214 = 2082;
        v121 = " ";
        *(_DWORD *)buf = 136447490;
        if (v119)
          v121 = "";
        v215 = v120;
        v216 = 2080;
        v217 = (uint64_t)v121;
        v218 = 1024;
        *(_DWORD *)v219 = v118;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v8;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v9;
        v122 = "%{public}s %{public}s%s<i%u> remaining space %u less than frame length %u";
        v123 = v116;
        v124 = 50;
        goto LABEL_176;
      }
    }
  }
  input_frame = http2_create_input_frame(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), v8);
  if (!input_frame)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v210 = 0;
    if (!__nwlog_fault(v19, &type, &v210))
      goto LABEL_132;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v21 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      v22 = "%{public}s http2_create_input_frame failed";
    }
    else if (v210)
    {
      v36 = (char *)__nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v21 = type;
      v37 = os_log_type_enabled(v20, type);
      if (v36)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v36;
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s http2_create_input_frame failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v36);
        goto LABEL_132;
      }
      if (!v37)
      {
LABEL_132:
        if (v19)
          free(v19);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      v22 = "%{public}s http2_create_input_frame failed, no backtrace";
    }
    else
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      v22 = "%{public}s http2_create_input_frame failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
    goto LABEL_132;
  }
  v13 = input_frame;
  if (!*(_QWORD *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(_QWORD *)(input_frame + 88)))
  {
    v16 = 0;
    v35 = 0;
  }
  else
  {
    v15 = *(_DWORD *)(v13 + 52);
    v14 = *(unsigned int *)(v13 + 56);
    if (v15)
      v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    else
      v16 = 0;
    v35 = (void *)(*(_QWORD *)(v13 + 112) + v14);
  }
  v38 = *(_QWORD *)(a1 + 48);
  if (v16 == (_DWORD)v8)
  {
    v39 = *(NSObject **)(v38 + 112);
    if (v39)
      nw_frame_set_metadata(v13, v39, 1, 0);
    v40 = (const void *)nw_frame_unclaimed_bytes(a2, 0);
    memcpy(v35, v40, v8);
    nw_frame_claim(a2, v41, v8, 0);
    http2_input_frame_metadata_reset(a2, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), v10);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v8;
    v42 = *(_QWORD *)(a1 + 48);
    if (v42)
    {
      if (((*(unsigned __int16 *)(v42 + 188) | (*(unsigned __int8 *)(v42 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v186 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v187 = *(_QWORD *)(a1 + 48);
          if (v187)
            v188 = (const char *)(v187 + 191);
          else
            v188 = "";
          if (v187)
            v189 = " ";
          else
            v189 = "";
          v191 = *(_DWORD *)(v187 + 176);
          v190 = *(_DWORD *)(v187 + 180);
          v192 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)buf = 136448002;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v188;
          v216 = 2080;
          v217 = (uint64_t)v189;
          v218 = 1024;
          *(_DWORD *)v219 = v190;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v191;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v8;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v9;
          *(_WORD *)&v219[22] = 1024;
          *(_DWORD *)&v219[24] = v192;
          _os_log_impl(&dword_182FBE000, v186, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> delivering partial frame (%u bytes of %u, %u bytes remaining)", buf, 0x3Eu);
        }
      }
    }
    else
    {
      v166 = *(_QWORD *)(a1 + 56);
      if ((!v166 || (*(__int16 *)(v166 + 376) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v167 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v168 = *(_QWORD *)(a1 + 56);
          if (v168)
            v169 = (const char *)(v168 + 378);
          else
            v169 = "";
          if (v168)
            v170 = " ";
          else
            v170 = "";
          v171 = *(_DWORD *)(v168 + 368);
          v172 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v169;
          v216 = 2080;
          v217 = (uint64_t)v170;
          v218 = 1024;
          *(_DWORD *)v219 = v171;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v8;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v9;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v172;
          _os_log_impl(&dword_182FBE000, v167, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> delivering partial frame (%u bytes of %u, %u bytes remaining)", buf, 0x38u);
        }
      }
    }
    goto LABEL_47;
  }
  if (v38)
  {
    if (((*(unsigned __int16 *)(v38 + 188) | (*(unsigned __int8 *)(v38 + 190) << 16)) & 0x80000) != 0)
      goto LABEL_143;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v72 = *(_QWORD *)(a1 + 48);
    v73 = (const char *)(v72 + 191);
    v74 = v72 == 0;
    if (!v72)
      v73 = "";
    v77 = v72 + 176;
    v75 = *(_DWORD *)(v72 + 176);
    v76 = *(_DWORD *)(v77 + 4);
    if (v74)
      v78 = "";
    else
      v78 = " ";
    *(_DWORD *)buf = 136447746;
    v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    v214 = 2082;
    v215 = v73;
    v216 = 2080;
    v217 = (uint64_t)v78;
    v218 = 1024;
    *(_DWORD *)v219 = v76;
    *(_WORD *)&v219[4] = 1024;
    *(_DWORD *)&v219[6] = v75;
    *(_WORD *)&v219[10] = 1024;
    *(_DWORD *)&v219[12] = v16;
    *(_WORD *)&v219[16] = 1024;
    *(_DWORD *)&v219[18] = v8;
    v79 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v210 = 0;
    if (__nwlog_fault(v79, &type, &v210))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v80 = gconnectionLogObj;
        v81 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v82 = *(_QWORD *)(a1 + 48);
          v83 = (const char *)(v82 + 191);
          if (v82)
          {
            v84 = " ";
          }
          else
          {
            v83 = "";
            v84 = "";
          }
          v87 = v82 + 176;
          v85 = *(_DWORD *)(v82 + 176);
          v86 = *(_DWORD *)(v87 + 4);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v83;
          v216 = 2080;
          v217 = (uint64_t)v84;
          v218 = 1024;
          *(_DWORD *)v219 = v86;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v85;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame";
LABEL_139:
          v112 = v80;
          v113 = v81;
          v114 = 56;
LABEL_140:
          _os_log_impl(&dword_182FBE000, v112, v113, v88, buf, v114);
        }
      }
      else
      {
        if (v210)
        {
          v89 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v80 = gconnectionLogObj;
          v81 = type;
          v90 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (v89)
          {
            if (v90)
            {
              v91 = *(_QWORD *)(a1 + 48);
              v92 = (const char *)(v91 + 191);
              if (v91)
              {
                v93 = " ";
              }
              else
              {
                v92 = "";
                v93 = "";
              }
              v96 = v91 + 176;
              v94 = *(_DWORD *)(v91 + 176);
              v95 = *(_DWORD *)(v96 + 4);
              *(_DWORD *)buf = 136448002;
              v213 = "nw_protocol_http2_get_input_frames_block_invoke";
              v214 = 2082;
              v215 = v92;
              v216 = 2080;
              v217 = (uint64_t)v93;
              v218 = 1024;
              *(_DWORD *)v219 = v95;
              *(_WORD *)&v219[4] = 1024;
              *(_DWORD *)&v219[6] = v94;
              *(_WORD *)&v219[10] = 1024;
              *(_DWORD *)&v219[12] = v16;
              *(_WORD *)&v219[16] = 1024;
              *(_DWORD *)&v219[18] = v8;
              *(_WORD *)&v219[22] = 2082;
              *(_QWORD *)&v219[24] = v89;
              _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_input_frame, dumping backtrace:%{public}s", buf, 0x42u);
            }
            free(v89);
            if (!v79)
              goto LABEL_143;
            goto LABEL_142;
          }
          if (!v90)
            goto LABEL_141;
          v106 = *(_QWORD *)(a1 + 48);
          v107 = (const char *)(v106 + 191);
          if (v106)
          {
            v108 = " ";
          }
          else
          {
            v107 = "";
            v108 = "";
          }
          v111 = v106 + 176;
          v109 = *(_DWORD *)(v106 + 176);
          v110 = *(_DWORD *)(v111 + 4);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v107;
          v216 = 2080;
          v217 = (uint64_t)v108;
          v218 = 1024;
          *(_DWORD *)v219 = v110;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v109;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame, no backtrace";
          goto LABEL_139;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v80 = gconnectionLogObj;
        v81 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v100 = *(_QWORD *)(a1 + 48);
          v101 = (const char *)(v100 + 191);
          if (v100)
          {
            v102 = " ";
          }
          else
          {
            v101 = "";
            v102 = "";
          }
          v105 = v100 + 176;
          v103 = *(_DWORD *)(v100 + 176);
          v104 = *(_DWORD *)(v105 + 4);
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v101;
          v216 = 2080;
          v217 = (uint64_t)v102;
          v218 = 1024;
          *(_DWORD *)v219 = v104;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v103;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame, backtrace limit exceeded";
          goto LABEL_139;
        }
      }
    }
  }
  else
  {
    v173 = *(_QWORD *)(a1 + 56);
    if (v173 && *(__int16 *)(v173 + 376) < 0)
      goto LABEL_143;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v174 = *(_QWORD *)(a1 + 56);
    v175 = (const char *)(v174 + 378);
    v176 = v174 == 0;
    v177 = *(_DWORD *)(v174 + 368);
    if (v176)
      v175 = "";
    *(_DWORD *)buf = 136447490;
    v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    if (v176)
      v178 = "";
    else
      v178 = " ";
    v214 = 2082;
    v215 = v175;
    v216 = 2080;
    v217 = (uint64_t)v178;
    v218 = 1024;
    *(_DWORD *)v219 = v177;
    *(_WORD *)&v219[4] = 1024;
    *(_DWORD *)&v219[6] = v16;
    *(_WORD *)&v219[10] = 1024;
    *(_DWORD *)&v219[12] = v8;
    v79 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v210 = 0;
    if (__nwlog_fault(v79, &type, &v210))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v179 = gconnectionLogObj;
        v180 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_141;
        v181 = *(_QWORD *)(a1 + 56);
        v182 = (const char *)(v181 + 378);
        v183 = v181 == 0;
        if (!v181)
          v182 = "";
        v184 = *(_DWORD *)(v181 + 368);
        if (v183)
          v185 = "";
        else
          v185 = " ";
        *(_DWORD *)buf = 136447490;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v182;
        v216 = 2080;
        v217 = (uint64_t)v185;
        v218 = 1024;
        *(_DWORD *)v219 = v184;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_input_frame";
      }
      else if (v210)
      {
        v193 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v179 = gconnectionLogObj;
        v180 = type;
        v194 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v193)
        {
          if (v194)
          {
            v195 = *(_QWORD *)(a1 + 56);
            v196 = (const char *)(v195 + 378);
            v197 = v195 == 0;
            if (!v195)
              v196 = "";
            v198 = *(_DWORD *)(v195 + 368);
            if (v197)
              v199 = "";
            else
              v199 = " ";
            *(_DWORD *)buf = 136447746;
            v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            v214 = 2082;
            v215 = v196;
            v216 = 2080;
            v217 = (uint64_t)v199;
            v218 = 1024;
            *(_DWORD *)v219 = v198;
            *(_WORD *)&v219[4] = 1024;
            *(_DWORD *)&v219[6] = v16;
            *(_WORD *)&v219[10] = 1024;
            *(_DWORD *)&v219[12] = v8;
            *(_WORD *)&v219[16] = 2082;
            *(_QWORD *)&v219[18] = v193;
            _os_log_impl(&dword_182FBE000, v179, v180, "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_input_frame, dumping backtrace:%{public}s", buf, 0x3Cu);
          }
          free(v193);
          goto LABEL_141;
        }
        if (!v194)
          goto LABEL_141;
        v205 = *(_QWORD *)(a1 + 56);
        v206 = (const char *)(v205 + 378);
        v207 = v205 == 0;
        if (!v205)
          v206 = "";
        v208 = *(_DWORD *)(v205 + 368);
        if (v207)
          v209 = "";
        else
          v209 = " ";
        *(_DWORD *)buf = 136447490;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v206;
        v216 = 2080;
        v217 = (uint64_t)v209;
        v218 = 1024;
        *(_DWORD *)v219 = v208;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_"
              "input_frame, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v179 = gconnectionLogObj;
        v180 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_141;
        v200 = *(_QWORD *)(a1 + 56);
        v201 = (const char *)(v200 + 378);
        v202 = v200 == 0;
        if (!v200)
          v201 = "";
        v203 = *(_DWORD *)(v200 + 368);
        if (v202)
          v204 = "";
        else
          v204 = " ";
        *(_DWORD *)buf = 136447490;
        v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        v214 = 2082;
        v215 = v201;
        v216 = 2080;
        v217 = (uint64_t)v204;
        v218 = 1024;
        *(_DWORD *)v219 = v203;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_"
              "input_frame, backtrace limit exceeded";
      }
      v112 = v179;
      v113 = v180;
      v114 = 50;
      goto LABEL_140;
    }
  }
LABEL_141:
  if (v79)
LABEL_142:
    free(v79);
LABEL_143:
  nw_frame_finalize(v13);
  return 0;
}

uint64_t ___ZL39nw_protocol_http2_replace_input_handlerP11nw_protocolS0_S0__block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(nw_frame_get_metadata(a2) + 8) = *(_QWORD *)(a1 + 32);
  return 1;
}

BOOL nw_http2_remove_from_protocol_table(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 node;
  _BOOL8 result;
  NSObject *v7;
  int v8;
  NSObject *v9;
  int v10;
  const char *v11;
  int v12;
  int v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  int v17;
  const char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  int v21;
  int v22;
  int v23;
  NSObject *v24;
  int v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v24 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v25 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      v29 = "nw_http2_remove_from_protocol_table";
      v30 = 2082;
      v31 = a1 + 378;
      v32 = 2080;
      v33 = " ";
      v34 = 1024;
      v35 = v25;
      v36 = 2048;
      v37 = a2;
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for input handler %p", buf, 0x30u);
    }
  }
  v4 = *(_QWORD *)(a1 + 152);
  if (v4)
  {
    node = nw_hash_table_get_node(v4, a2, 8);
    if (node)
    {
      if (nw_hash_table_remove_node(*(_QWORD *)(a1 + 152), node))
      {
        *(_QWORD *)(a2 + 56) = 0;
        result = 1;
        if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v7 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v8 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136447234;
            v29 = "nw_http2_remove_from_protocol_table";
            v30 = 2082;
            v31 = a1 + 378;
            v32 = 2080;
            v33 = " ";
            v34 = 1024;
            v35 = v8;
            v36 = 2048;
            v37 = a2;
            _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removed protocol %p from protocol based table", buf, 0x30u);
          }
          return 1;
        }
        return result;
      }
      if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v13 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        v29 = "nw_http2_remove_from_protocol_table";
        v30 = 2082;
        v31 = a1 + 378;
        v32 = 2080;
        v33 = " ";
        v34 = 1024;
        v35 = v13;
        v36 = 2048;
        v37 = a2;
        v14 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v26 = 0;
        if (!__nwlog_fault(v14, &type, &v26))
          goto LABEL_47;
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v15 = gconnectionLogObj;
          v16 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            goto LABEL_47;
          v17 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          v29 = "nw_http2_remove_from_protocol_table";
          v30 = 2082;
          v31 = a1 + 378;
          v32 = 2080;
          v33 = " ";
          v34 = 1024;
          v35 = v17;
          v36 = 2048;
          v37 = a2;
          v18 = "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table";
        }
        else if (v26)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v15 = gconnectionLogObj;
          v16 = type;
          v20 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (backtrace_string)
          {
            if (v20)
            {
              v21 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447490;
              v29 = "nw_http2_remove_from_protocol_table";
              v30 = 2082;
              v31 = a1 + 378;
              v32 = 2080;
              v33 = " ";
              v34 = 1024;
              v35 = v21;
              v36 = 2048;
              v37 = a2;
              v38 = 2082;
              v39 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table, dumping backtrace:%{public}s", buf, 0x3Au);
            }
            free(backtrace_string);
            goto LABEL_47;
          }
          if (!v20)
          {
LABEL_47:
            if (v14)
              free(v14);
            return 0;
          }
          v23 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          v29 = "nw_http2_remove_from_protocol_table";
          v30 = 2082;
          v31 = a1 + 378;
          v32 = 2080;
          v33 = " ";
          v34 = 1024;
          v35 = v23;
          v36 = 2048;
          v37 = a2;
          v18 = "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table, no backtrace";
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v15 = gconnectionLogObj;
          v16 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            goto LABEL_47;
          v22 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          v29 = "nw_http2_remove_from_protocol_table";
          v30 = 2082;
          v31 = a1 + 378;
          v32 = 2080;
          v33 = " ";
          v34 = 1024;
          v35 = v22;
          v36 = 2048;
          v37 = a2;
          v18 = "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table, backtrace limit exceeded";
        }
        _os_log_impl(&dword_182FBE000, v15, v16, v18, buf, 0x30u);
        goto LABEL_47;
      }
      return 0;
    }
    if (*(__int16 *)(a1 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v12 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      v29 = "nw_http2_remove_from_protocol_table";
      v30 = 2082;
      v31 = a1 + 378;
      v32 = 2080;
      v33 = " ";
      v34 = 1024;
      v35 = v12;
      v36 = 2048;
      v37 = a2;
      v11 = "%{public}s %{public}s%s<i%u> protocol %p is not present in id based table, cannot remove";
      goto LABEL_23;
    }
  }
  else
  {
    if (*(__int16 *)(a1 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v10 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      v29 = "nw_http2_remove_from_protocol_table";
      v30 = 2082;
      v31 = a1 + 378;
      v32 = 2080;
      v33 = " ";
      v34 = 1024;
      v35 = v10;
      v36 = 2048;
      v37 = a2;
      v11 = "%{public}s %{public}s%s<i%u> protocol based table is NULL, cannot remove protocol %p";
LABEL_23:
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, v11, buf, 0x30u);
      return 0;
    }
  }
  return result;
}

uint64_t nw_http2_add_to_protocol_table(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t internal;
  _BOOL8 v7;
  uint64_t v8;
  int v9;
  int v10;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  int v14;
  int v15;
  const char *v16;
  char *v17;
  _BOOL4 v18;
  int v19;
  int v20;
  const char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  int v27;
  int v28;
  int v29;
  int v30;
  char *v31;
  uint64_t v33;
  int v34;
  const char *v35;
  NSObject *v36;
  uint32_t v37;
  uint64_t v38;
  int v39;
  int v40;
  NSObject *v41;
  int v42;
  NSObject *v43;
  int v44;
  int v45;
  NSObject *v46;
  int v47;
  int v48;
  int v49;
  const char *v50;
  NSObject *v51;
  os_log_type_t v52;
  int v53;
  const char *v54;
  char *v55;
  _BOOL4 v56;
  int v57;
  int v58;
  int v59;
  char v60;
  os_log_type_t type;
  char v62;
  uint8_t buf[4];
  const char *v64;
  __int16 v65;
  char *v66;
  __int16 v67;
  const char *v68;
  __int16 v69;
  int v70;
  __int16 v71;
  _BYTE v72[34];
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v38 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v40 = *(_DWORD *)(a3 + 176);
        v39 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447746;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a3 + 191);
        v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v39;
        v71 = 1024;
        *(_DWORD *)v72 = v40;
        *(_WORD *)&v72[4] = 2048;
        *(_QWORD *)&v72[6] = a2;
        *(_WORD *)&v72[14] = 1024;
        *(_DWORD *)&v72[16] = v40;
        v35 = "%{public}s %{public}s%s<i%u:s%d> called for protocol %p, stream %d";
        v36 = v38;
        v37 = 60;
        goto LABEL_69;
      }
    }
  }
  else if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v33 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v34 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447490;
      v64 = "nw_http2_add_to_protocol_table";
      v65 = 2082;
      v66 = (char *)(a1 + 378);
      v67 = 2080;
      v68 = " ";
      v69 = 1024;
      v70 = v34;
      v71 = 2048;
      *(_QWORD *)v72 = a2;
      *(_WORD *)&v72[8] = 1024;
      *(_DWORD *)&v72[10] = -999;
      v35 = "%{public}s %{public}s%s<i%u> called for protocol %p, stream %d";
      v36 = v33;
      v37 = 54;
LABEL_69:
      _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, v35, buf, v37);
    }
  }
  v62 = 0;
  internal = *(_QWORD *)(a1 + 152);
  if (internal)
    goto LABEL_7;
  internal = nw_hash_table_create_internal(0x11u, 8, (const void *(*)(const void *, unsigned int *))nw_http2_get_key, (unsigned int (*)(const void *, unsigned int))nw_http2_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_http2_matches_key, 0);
  if (!internal)
  {
    *(_QWORD *)(a1 + 152) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v64 = "nw_http2_add_to_protocol_table";
    v21 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v60 = 0;
    if (!__nwlog_fault(v21, &type, &v60))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v23 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v64 = "nw_http2_add_to_protocol_table";
      v24 = "%{public}s nw_hash_table_create_no_lock failed";
    }
    else if (v60)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v23 = type;
      v26 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v64 = "nw_http2_add_to_protocol_table";
          v65 = 2082;
          v66 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_54:
        if (v21)
        {
          v31 = (char *)v21;
          goto LABEL_56;
        }
        return 0;
      }
      if (!v26)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v64 = "nw_http2_add_to_protocol_table";
      v24 = "%{public}s nw_hash_table_create_no_lock failed, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v23 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v64 = "nw_http2_add_to_protocol_table";
      v24 = "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
    goto LABEL_54;
  }
  *(_DWORD *)(internal + 48) &= ~2u;
  *(_QWORD *)(a1 + 152) = internal;
LABEL_7:
  v7 = nw_hash_table_add_object(internal, a2, &v62);
  if (!v62)
  {
    if (a3)
    {
      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0)
        return 0;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v10 = *(_DWORD *)(a3 + 176);
      v9 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447746;
      v64 = "nw_http2_add_to_protocol_table";
      v65 = 2082;
      v66 = (char *)(a3 + 191);
      v67 = 2080;
      v68 = " ";
      v69 = 1024;
      v70 = v9;
      v71 = 1024;
      *(_DWORD *)v72 = v10;
      *(_WORD *)&v72[4] = 1042;
      *(_DWORD *)&v72[6] = 16;
      *(_WORD *)&v72[10] = 2098;
      *(_QWORD *)&v72[12] = a2;
      v11 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v60 = 0;
      if (!__nwlog_fault(v11, &type, &v60))
        goto LABEL_47;
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = gconnectionLogObj;
        v13 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v15 = *(_DWORD *)(a3 + 176);
          v14 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447746;
          v64 = "nw_http2_add_to_protocol_table";
          v65 = 2082;
          v66 = (char *)(a3 + 191);
          v67 = 2080;
          v68 = " ";
          v69 = 1024;
          v70 = v14;
          v71 = 1024;
          *(_DWORD *)v72 = v15;
          *(_WORD *)&v72[4] = 1042;
          *(_DWORD *)&v72[6] = 16;
          *(_WORD *)&v72[10] = 2098;
          *(_QWORD *)&v72[12] = a2;
          v16 = "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P";
LABEL_46:
          _os_log_impl(&dword_182FBE000, v12, v13, v16, buf, 0x3Cu);
        }
      }
      else if (v60)
      {
        v17 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = gconnectionLogObj;
        v13 = type;
        v18 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (!v17)
        {
          if (!v18)
            goto LABEL_47;
          v30 = *(_DWORD *)(a3 + 176);
          v29 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447746;
          v64 = "nw_http2_add_to_protocol_table";
          v65 = 2082;
          v66 = (char *)(a3 + 191);
          v67 = 2080;
          v68 = " ";
          v69 = 1024;
          v70 = v29;
          v71 = 1024;
          *(_DWORD *)v72 = v30;
          *(_WORD *)&v72[4] = 1042;
          *(_DWORD *)&v72[6] = 16;
          *(_WORD *)&v72[10] = 2098;
          *(_QWORD *)&v72[12] = a2;
          v16 = "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P, no backtrace";
          goto LABEL_46;
        }
        if (v18)
        {
          v20 = *(_DWORD *)(a3 + 176);
          v19 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136448002;
          v64 = "nw_http2_add_to_protocol_table";
          v65 = 2082;
          v66 = (char *)(a3 + 191);
          v67 = 2080;
          v68 = " ";
          v69 = 1024;
          v70 = v19;
          v71 = 1024;
          *(_DWORD *)v72 = v20;
          *(_WORD *)&v72[4] = 1042;
          *(_DWORD *)&v72[6] = 16;
          *(_WORD *)&v72[10] = 2098;
          *(_QWORD *)&v72[12] = a2;
          *(_WORD *)&v72[20] = 2082;
          *(_QWORD *)&v72[22] = v17;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P, dumping backtrace:%{public}s", buf, 0x46u);
        }
        free(v17);
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = gconnectionLogObj;
        v13 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          v28 = *(_DWORD *)(a3 + 176);
          v27 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447746;
          v64 = "nw_http2_add_to_protocol_table";
          v65 = 2082;
          v66 = (char *)(a3 + 191);
          v67 = 2080;
          v68 = " ";
          v69 = 1024;
          v70 = v27;
          v71 = 1024;
          *(_DWORD *)v72 = v28;
          *(_WORD *)&v72[4] = 1042;
          *(_DWORD *)&v72[6] = 16;
          *(_WORD *)&v72[10] = 2098;
          *(_QWORD *)&v72[12] = a2;
          v16 = "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P, ba"
                "cktrace limit exceeded";
          goto LABEL_46;
        }
      }
LABEL_47:
      if (v11)
      {
        v31 = (char *)v11;
LABEL_56:
        free(v31);
        return 0;
      }
      return 0;
    }
    if (*(__int16 *)(a1 + 376) < 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v49 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447490;
    v64 = "nw_http2_add_to_protocol_table";
    v65 = 2082;
    v66 = (char *)(a1 + 378);
    v67 = 2080;
    v68 = " ";
    v69 = 1024;
    v70 = v49;
    v71 = 1042;
    *(_DWORD *)v72 = 16;
    *(_WORD *)&v72[4] = 2098;
    *(_QWORD *)&v72[6] = a2;
    v50 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v60 = 0;
    if (__nwlog_fault(v50, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v51 = gconnectionLogObj;
        v52 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_107;
        v53 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447490;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a1 + 378);
        v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v53;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(_QWORD *)&v72[6] = a2;
        v54 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P";
        goto LABEL_106;
      }
      if (!v60)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v51 = gconnectionLogObj;
        v52 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_107;
        v58 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447490;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a1 + 378);
        v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v58;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(_QWORD *)&v72[6] = a2;
        v54 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, backtrac"
              "e limit exceeded";
        goto LABEL_106;
      }
      v55 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v51 = gconnectionLogObj;
      v52 = type;
      v56 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v55)
      {
        if (v56)
        {
          v57 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447746;
          v64 = "nw_http2_add_to_protocol_table";
          v65 = 2082;
          v66 = (char *)(a1 + 378);
          v67 = 2080;
          v68 = " ";
          v69 = 1024;
          v70 = v57;
          v71 = 1042;
          *(_DWORD *)v72 = 16;
          *(_WORD *)&v72[4] = 2098;
          *(_QWORD *)&v72[6] = a2;
          *(_WORD *)&v72[14] = 2082;
          *(_QWORD *)&v72[16] = v55;
          _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(v55);
        goto LABEL_107;
      }
      if (v56)
      {
        v59 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447490;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a1 + 378);
        v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v59;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(_QWORD *)&v72[6] = a2;
        v54 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, no backtrace";
LABEL_106:
        _os_log_impl(&dword_182FBE000, v51, v52, v54, buf, 0x36u);
      }
    }
LABEL_107:
    if (!v50)
      return 0;
    v31 = (char *)v50;
    goto LABEL_56;
  }
  v8 = v7;
  if (a3)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v43 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v45 = *(_DWORD *)(a3 + 176);
        v44 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447490;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a3 + 191);
        v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v44;
        v71 = 1024;
        *(_DWORD *)v72 = v45;
        *(_WORD *)&v72[4] = 2048;
        *(_QWORD *)&v72[6] = a2;
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> added protocol %p to protocol hash table", buf, 0x36u);
      }
    }
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v46 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v48 = *(_DWORD *)(a3 + 176);
        v47 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136448002;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a3 + 191);
        v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v47;
        v71 = 1024;
        *(_DWORD *)v72 = v48;
        *(_WORD *)&v72[4] = 2048;
        *(_QWORD *)&v72[6] = a2;
        *(_WORD *)&v72[14] = 2048;
        *(_QWORD *)&v72[16] = v8;
        *(_WORD *)&v72[24] = 2048;
        *(_QWORD *)&v72[26] = a3;
        _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> connecting protocol %p node %p with stream %p", buf, 0x4Au);
      }
    }
    *(_QWORD *)nw_hash_node_get_extra(v8) = a3;
  }
  else if ((*(__int16 *)(a1 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v41 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v42 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      v64 = "nw_http2_add_to_protocol_table";
      v65 = 2082;
      v66 = (char *)(a1 + 378);
      v67 = 2080;
      v68 = " ";
      v69 = 1024;
      v70 = v42;
      v71 = 2048;
      *(_QWORD *)v72 = a2;
      _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> added protocol %p to protocol hash table", buf, 0x30u);
    }
  }
  return v8;
}

void nw_http2_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 8;
}

BOOL nw_http2_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

void ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  int v8;
  int v9;
  const char *v10;
  NSObject *v11;
  os_log_type_t v12;
  int v13;
  const char *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  os_unfair_lock_s *v21;
  os_unfair_lock_s *v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  int v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  int v30;
  const char *v31;
  char *v32;
  _BOOL4 v33;
  int v34;
  char *v35;
  _BOOL4 v36;
  int v37;
  int v38;
  int v39;
  void *v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  int frame_count;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  int v50;
  const char *v51;
  char *v52;
  _BOOL4 v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  void *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t);
  uint64_t v65;
  void (*v66)(uint64_t, uint64_t);
  _QWORD *i;
  _QWORD *v68;
  uint64_t v69;
  uint64_t j;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  const void *v79;
  _QWORD *v80;
  const void *v81;
  NSObject *v82;
  os_log_type_t v83;
  const char *v84;
  NSObject *v85;
  int v86;
  uint64_t v87;
  const char *v88;
  const char *v89;
  char *v90;
  NSObject *v91;
  os_log_type_t v92;
  uint64_t v93;
  const char *v94;
  const char *v95;
  const char *v96;
  char *backtrace_string;
  _BOOL4 v98;
  char *v99;
  _BOOL4 v100;
  char *v101;
  _BOOL4 v102;
  uint64_t v103;
  const char *v104;
  const char *v105;
  uint64_t v106;
  char *v107;
  NSObject *v108;
  os_log_type_t v109;
  uint64_t v110;
  const char *v111;
  NSObject *v112;
  NSObject *v113;
  NSObject *v114;
  NSObject *v115;
  int v116;
  char *v117;
  _BOOL4 v118;
  uint64_t v119;
  uint64_t v120;
  const char *v121;
  const char *v122;
  uint64_t v123;
  const char *v124;
  const char *v125;
  uint64_t v126;
  uint64_t v127;
  char v128;
  os_log_type_t type[8];
  uint64_t v130;
  uint64_t (*v131)(uint64_t, uint64_t);
  void *v132;
  uint64_t v133;
  os_log_type_t v134;
  _BYTE buf[32];
  uint64_t v136;
  uint64_t v137;
  __int16 v138;
  int v139;
  uint64_t v140;

  v140 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
    v3 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v134 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v3, type, &v134))
      goto LABEL_220;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v82 = __nwlog_obj();
      v83 = type[0];
      if (!os_log_type_enabled(v82, type[0]))
        goto LABEL_220;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
      v84 = "%{public}s called with null protocol";
LABEL_219:
      _os_log_impl(&dword_182FBE000, v82, v83, v84, buf, 0xCu);
      goto LABEL_220;
    }
    if (v134 == OS_LOG_TYPE_DEFAULT)
    {
      v82 = __nwlog_obj();
      v83 = type[0];
      if (!os_log_type_enabled(v82, type[0]))
        goto LABEL_220;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
      v84 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v82 = __nwlog_obj();
    v83 = type[0];
    v98 = os_log_type_enabled(v82, type[0]);
    if (!backtrace_string)
    {
      if (!v98)
        goto LABEL_220;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
      v84 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_219;
    }
    if (v98)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v82, v83, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_220:
    if (!v3)
      return;
    goto LABEL_139;
  }
  v3 = *(_QWORD *)(v2 + 40);
  if (v3)
  {
    if ((*(__int16 *)(v3 + 376) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v85 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v86 = *(_DWORD *)(v3 + 368);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v3 + 378;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v136) = 1024;
        *(_DWORD *)((char *)&v136 + 2) = v86;
        _os_log_impl(&dword_182FBE000, v85, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    v4 = *(_QWORD *)(v3 + 88);
    if (v4)
    {
      nw_queue_cancel_source(v4, a2);
      *(_QWORD *)(v3 + 88) = 0;
    }
    v5 = *(_QWORD *)(v3 + 152);
    if (v5)
    {
      v6 = *(_DWORD *)(v5 + 40);
      if (v6)
      {
        if ((*(__int16 *)(v3 + 376) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v7 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v8 = *(_DWORD *)(v3 + 368);
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v3 + 378;
            *(_WORD *)&buf[22] = 2080;
            *(_QWORD *)&buf[24] = " ";
            LOWORD(v136) = 1024;
            *(_DWORD *)((char *)&v136 + 2) = v8;
            HIWORD(v136) = 2048;
            v137 = v3;
            v138 = 1024;
            v139 = v6;
            _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> not destroying http2 %p, still have %u input handlers", buf, 0x36u);
          }
        }
        return;
      }
      nw_protocol_set_input_handler(v2, 0);
      if ((*(__int16 *)(v3 + 376) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v16 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          v17 = *(_DWORD *)(v3 + 368);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v3 + 378;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = " ";
          LOWORD(v136) = 1024;
          *(_DWORD *)((char *)&v136 + 2) = v17;
          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> no more input handlers, destroying", buf, 0x26u);
        }
      }
      v18 = *(_QWORD *)(v3 + 144);
      if (v18)
        (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v18 + 8))(v18, v3, 0);
      v19 = *(char **)(v3 + 160);
      v20 = MEMORY[0x1E0C809B0];
      if (v19)
      {
        *(_QWORD *)type = MEMORY[0x1E0C809B0];
        v130 = 0x40000000;
        v131 = ___ZL25nw_protocol_http2_destroyP11nw_protocol_block_invoke;
        v132 = &__block_descriptor_tmp_58_82983;
        v133 = v3;
        nw_hash_table_apply(v19, (uint64_t)type);
        v21 = *(os_unfair_lock_s **)(v3 + 160);
        if (v21)
        {
          _nw_hash_table_release(v21, v15);
          *(_QWORD *)(v3 + 160) = 0;
        }
      }
      v22 = *(os_unfair_lock_s **)(v3 + 152);
      if (v22)
      {
        _nw_hash_table_release(v22, v15);
        *(_QWORD *)(v3 + 152) = 0;
      }
      if (gLogDatapath)
      {
        v112 = __nwlog_obj();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_182FBE000, v112, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }
      *(_QWORD *)buf = v20;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_81659;
      *(_QWORD *)&buf[24] = &__block_descriptor_tmp_30_81660;
      v136 = v3 + 240;
      LOBYTE(v137) = 0;
      v23 = *(_QWORD *)(v3 + 240);
      do
      {
        if (!v23)
          break;
        v24 = *(_QWORD *)(v23 + 32);
        v25 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v23 = v24;
      }
      while ((v25 & 1) != 0);
      if (!*(_QWORD *)(v3 + 168))
      {
LABEL_73:
        if (gLogDatapath)
        {
          v113 = __nwlog_obj();
          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_release_master_frame_array";
            _os_log_impl(&dword_182FBE000, v113, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
          }
        }
        *(_QWORD *)buf = v20;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke;
        *(_QWORD *)&buf[24] = &__block_descriptor_tmp_31_81662;
        v136 = v3 + 168;
        v43 = *(_QWORD *)(v3 + 168);
        do
        {
          if (!v43)
            break;
          v44 = *(_QWORD *)(v43 + 16);
          v45 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          v43 = v44;
        }
        while ((v45 & 1) != 0);
        if (!*(_QWORD *)(v3 + 184))
        {
LABEL_94:
          if (gLogDatapath)
          {
            v114 = __nwlog_obj();
            if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_release_master_frame_array";
              _os_log_impl(&dword_182FBE000, v114, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }
          *(_QWORD *)buf = v20;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke;
          *(_QWORD *)&buf[24] = &__block_descriptor_tmp_31_81662;
          v136 = v3 + 184;
          v57 = *(_QWORD *)(v3 + 184);
          do
          {
            if (!v57)
              break;
            v58 = *(_QWORD *)(v57 + 16);
            v59 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            v57 = v58;
          }
          while ((v59 & 1) != 0);
          nw_frame_cache_destroy((uint64_t *)(v3 + 200));
          v60 = *(void **)(v3 + 288);
          if (v60)
          {
            v61 = *(void **)(v3 + 296);
            if (v61)
              nw_association_unregister(v60, v61);
          }
          v62 = *(_QWORD *)(v2 + 32);
          if (v62)
          {
            v63 = *(_QWORD *)(v62 + 24);
            if (v63)
            {
              v64 = *(void (**)(uint64_t, uint64_t))(v63 + 8);
              if (v64)
              {
                v64(v62, v2);
                goto LABEL_105;
              }
            }
          }
          __nwlog_obj();
          v87 = *(_QWORD *)(v2 + 32);
          v88 = "invalid";
          if (v87)
          {
            v89 = *(const char **)(v87 + 16);
            if (v89)
              v88 = v89;
          }
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v88;
          v90 = (char *)_os_log_send_and_compose_impl();
          v134 = OS_LOG_TYPE_ERROR;
          v128 = 0;
          if (__nwlog_fault(v90, &v134, &v128))
          {
            if (v134 == OS_LOG_TYPE_FAULT)
            {
              v91 = __nwlog_obj();
              v92 = v134;
              if (!os_log_type_enabled(v91, v134))
                goto LABEL_228;
              v93 = *(_QWORD *)(v2 + 32);
              v94 = "invalid";
              if (v93)
              {
                v95 = *(const char **)(v93 + 16);
                if (v95)
                  v94 = v95;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v94;
              v96 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
              goto LABEL_227;
            }
            if (!v128)
            {
              v91 = __nwlog_obj();
              v92 = v134;
              if (!os_log_type_enabled(v91, v134))
                goto LABEL_228;
              v120 = *(_QWORD *)(v2 + 32);
              v121 = "invalid";
              if (v120)
              {
                v122 = *(const char **)(v120 + 16);
                if (v122)
                  v121 = v122;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v121;
              v96 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
              goto LABEL_227;
            }
            v101 = (char *)__nw_create_backtrace_string();
            v91 = __nwlog_obj();
            v92 = v134;
            v102 = os_log_type_enabled(v91, v134);
            if (v101)
            {
              if (v102)
              {
                v103 = *(_QWORD *)(v2 + 32);
                v104 = "invalid";
                if (v103)
                {
                  v105 = *(const char **)(v103 + 16);
                  if (v105)
                    v104 = v105;
                }
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v104;
                *(_WORD *)&buf[22] = 2082;
                *(_QWORD *)&buf[24] = v101;
                _os_log_impl(&dword_182FBE000, v91, v92, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v101);
              goto LABEL_228;
            }
            if (v102)
            {
              v123 = *(_QWORD *)(v2 + 32);
              v124 = "invalid";
              if (v123)
              {
                v125 = *(const char **)(v123 + 16);
                if (v125)
                  v124 = v125;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v124;
              v96 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_227:
              _os_log_impl(&dword_182FBE000, v91, v92, v96, buf, 0x16u);
            }
          }
LABEL_228:
          if (v90)
            free(v90);
LABEL_105:
          nw_protocol_remove_instance(v2);
          v65 = *(_QWORD *)(v3 + 144);
          if (!v65)
          {
LABEL_110:
            nw_http_connection_metadata_closed(*(void **)(v3 + 256));
            for (i = *(_QWORD **)(v3 + 328); i; i = (_QWORD *)*i)
              (*(void (**)(_QWORD, _QWORD))(i[4] + 16))(i[4], 0);
            if (*(_QWORD *)(v3 + 336))
            {
              v68 = *(_QWORD **)(v3 + 328);
              while (v68)
              {
                v80 = v68;
                v68 = (_QWORD *)*v68;
                if ((v80[5] & 1) != 0)
                {
                  v81 = (const void *)v80[4];
                  if (v81)
                    _Block_release(v81);
                }
                operator delete(v80);
              }
              *(_QWORD *)(v3 + 328) = 0;
              v69 = *(_QWORD *)(v3 + 320);
              if (v69)
              {
                for (j = 0; j != v69; ++j)
                  *(_QWORD *)(*(_QWORD *)(v3 + 312) + 8 * j) = 0;
              }
              *(_QWORD *)(v3 + 336) = 0;
            }
            v71 = *(void **)(v3 + 104);
            if (v71)
            {
              os_release(v71);
              *(_QWORD *)(v3 + 104) = 0;
            }
            v72 = *(void **)(v3 + 112);
            if (v72)
            {
              os_release(v72);
              *(_QWORD *)(v3 + 112) = 0;
            }
            v73 = *(void **)(v3 + 120);
            if (v73)
            {
              os_release(v73);
              *(_QWORD *)(v3 + 120) = 0;
            }
            v74 = *(void **)(v3 + 256);
            if (v74)
            {
              os_release(v74);
              *(_QWORD *)(v3 + 256) = 0;
            }
            v75 = *(void **)(v3 + 280);
            if (v75)
            {
              os_release(v75);
              *(_QWORD *)(v3 + 280) = 0;
            }
            v76 = *(void **)(v3 + 288);
            if (v76)
            {
              os_release(v76);
              *(_QWORD *)(v3 + 288) = 0;
            }
            v77 = *(void **)(v3 + 296);
            if (v77)
            {
              os_release(v77);
              *(_QWORD *)(v3 + 296) = 0;
            }
            v78 = *(void **)(v3 + 304);
            if (v78)
            {
              os_release(v78);
              *(_QWORD *)(v3 + 304) = 0;
            }
            nghttp2_session_del();
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v3 + 352) + 16))(*(_QWORD *)(v3 + 352), 0);
            v79 = *(const void **)(v3 + 352);
            if (v79)
            {
              _Block_release(v79);
              *(_QWORD *)(v3 + 352) = 0;
            }
            if ((*(__int16 *)(v3 + 376) & 0x80000000) == 0 && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v115 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                v116 = *(_DWORD *)(v3 + 368);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v3 + 378;
                *(_WORD *)&buf[22] = 2080;
                *(_QWORD *)&buf[24] = " ";
                LOWORD(v136) = 1024;
                *(_DWORD *)((char *)&v136 + 2) = v116;
                HIWORD(v136) = 2048;
                v137 = v3;
                _os_log_impl(&dword_182FBE000, v115, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> freeing http2 %p", buf, 0x30u);
              }
            }
            std::__destroy_at[abi:nn180100]<nw_protocol_http2,0>(v3);
LABEL_139:
            v40 = (void *)v3;
LABEL_140:
            free(v40);
            return;
          }
          if (*(_QWORD *)v65)
          {
            v66 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)v65 + 8);
            if (v66)
            {
              v66(v65, v2);
LABEL_109:
              *(_QWORD *)(v3 + 144) = 0;
              goto LABEL_110;
            }
          }
          __nwlog_obj();
          v106 = *(_QWORD *)(v3 + 144);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v106;
          v107 = (char *)_os_log_send_and_compose_impl();
          v134 = OS_LOG_TYPE_ERROR;
          v128 = 0;
          if (__nwlog_fault(v107, &v134, &v128))
          {
            if (v134 == OS_LOG_TYPE_FAULT)
            {
              v108 = __nwlog_obj();
              v109 = v134;
              if (!os_log_type_enabled(v108, v134))
                goto LABEL_235;
              v110 = *(_QWORD *)(v3 + 144);
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v110;
              v111 = "%{public}s listen protocol (%p) has invalid disconnected callback";
              goto LABEL_234;
            }
            if (!v128)
            {
              v108 = __nwlog_obj();
              v109 = v134;
              if (!os_log_type_enabled(v108, v134))
                goto LABEL_235;
              v126 = *(_QWORD *)(v3 + 144);
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v126;
              v111 = "%{public}s listen protocol (%p) has invalid disconnected callback, backtrace limit exceeded";
              goto LABEL_234;
            }
            v117 = (char *)__nw_create_backtrace_string();
            v108 = __nwlog_obj();
            v109 = v134;
            v118 = os_log_type_enabled(v108, v134);
            if (v117)
            {
              if (v118)
              {
                v119 = *(_QWORD *)(v3 + 144);
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v119;
                *(_WORD *)&buf[22] = 2082;
                *(_QWORD *)&buf[24] = v117;
                _os_log_impl(&dword_182FBE000, v108, v109, "%{public}s listen protocol (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v117);
              goto LABEL_235;
            }
            if (v118)
            {
              v127 = *(_QWORD *)(v3 + 144);
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v127;
              v111 = "%{public}s listen protocol (%p) has invalid disconnected callback, no backtrace";
LABEL_234:
              _os_log_impl(&dword_182FBE000, v108, v109, v111, buf, 0x16u);
            }
          }
LABEL_235:
          if (v107)
            free(v107);
          goto LABEL_109;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        frame_count = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = frame_count;
        v47 = (char *)_os_log_send_and_compose_impl();
        v134 = OS_LOG_TYPE_ERROR;
        v128 = 0;
        if (__nwlog_fault(v47, &v134, &v128))
        {
          if (v134 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = gLogObj;
            v49 = v134;
            if (!os_log_type_enabled((os_log_t)gLogObj, v134))
              goto LABEL_92;
            v50 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v50;
            v51 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames";
            goto LABEL_91;
          }
          if (!v128)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = gLogObj;
            v49 = v134;
            if (!os_log_type_enabled((os_log_t)gLogObj, v134))
              goto LABEL_92;
            v55 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v55;
            v51 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, backtrace limit exceeded";
            goto LABEL_91;
          }
          v52 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v48 = gLogObj;
          v49 = v134;
          v53 = os_log_type_enabled((os_log_t)gLogObj, v134);
          if (v52)
          {
            if (v53)
            {
              v54 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0);
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v54;
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v52;
              _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v52);
            goto LABEL_92;
          }
          if (v53)
          {
            v56 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 184), 0, 0);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v56;
            v51 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, no backtrace";
LABEL_91:
            _os_log_impl(&dword_182FBE000, v48, v49, v51, buf, 0x12u);
          }
        }
LABEL_92:
        if (v47)
          free(v47);
        goto LABEL_94;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v26;
      v27 = (char *)_os_log_send_and_compose_impl();
      v134 = OS_LOG_TYPE_ERROR;
      v128 = 0;
      if (__nwlog_fault(v27, &v134, &v128))
      {
        if (v134 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = gLogObj;
          v29 = v134;
          if (!os_log_type_enabled((os_log_t)gLogObj, v134))
            goto LABEL_71;
          v30 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v30;
          v31 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames";
          goto LABEL_70;
        }
        if (!v128)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = gLogObj;
          v29 = v134;
          if (!os_log_type_enabled((os_log_t)gLogObj, v134))
            goto LABEL_71;
          v41 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v41;
          v31 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, backtrace limit exceeded";
          goto LABEL_70;
        }
        v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        v29 = v134;
        v36 = os_log_type_enabled((os_log_t)gLogObj, v134);
        if (v35)
        {
          if (v36)
          {
            v37 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0);
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v37;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v35;
            _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v35);
          v20 = MEMORY[0x1E0C809B0];
          goto LABEL_71;
        }
        v20 = MEMORY[0x1E0C809B0];
        if (v36)
        {
          v42 = nw_frame_array_get_frame_count((uint64_t *)(v3 + 168), 0, 0);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v42;
          v31 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, no backtrace";
LABEL_70:
          _os_log_impl(&dword_182FBE000, v28, v29, v31, buf, 0x12u);
        }
      }
LABEL_71:
      if (v27)
        free(v27);
      goto LABEL_73;
    }
    if (*(__int16 *)(v3 + 376) < 0)
      return;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = *(_DWORD *)(v3 + 368);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v3 + 378;
    *(_WORD *)&buf[22] = 2080;
    *(_QWORD *)&buf[24] = " ";
    LOWORD(v136) = 1024;
    *(_DWORD *)((char *)&v136 + 2) = v9;
    v10 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v134 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v10, type, &v134))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v11 = gconnectionLogObj;
        v12 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          goto LABEL_64;
        v13 = *(_DWORD *)(v3 + 368);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v3 + 378;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v136) = 1024;
        *(_DWORD *)((char *)&v136 + 2) = v13;
        v14 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying";
        goto LABEL_63;
      }
      if (v134 == OS_LOG_TYPE_DEFAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v11 = gconnectionLogObj;
        v12 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
          goto LABEL_64;
        v38 = *(_DWORD *)(v3 + 368);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v3 + 378;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v136) = 1024;
        *(_DWORD *)((char *)&v136 + 2) = v38;
        v14 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying, backtrace limit exceeded";
        goto LABEL_63;
      }
      v32 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = gconnectionLogObj;
      v12 = type[0];
      v33 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
      if (v32)
      {
        if (v33)
        {
          v34 = *(_DWORD *)(v3 + 368);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v3 + 378;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = " ";
          LOWORD(v136) = 1024;
          *(_DWORD *)((char *)&v136 + 2) = v34;
          HIWORD(v136) = 2082;
          v137 = (uint64_t)v32;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v32);
        goto LABEL_64;
      }
      if (v33)
      {
        v39 = *(_DWORD *)(v3 + 368);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v3 + 378;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v136) = 1024;
        *(_DWORD *)((char *)&v136 + 2) = v39;
        v14 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying, no backtrace";
LABEL_63:
        _os_log_impl(&dword_182FBE000, v11, v12, v14, buf, 0x26u);
      }
    }
LABEL_64:
    if (!v10)
      return;
    v40 = (void *)v10;
    goto LABEL_140;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
  v3 = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v134 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault((const char *)v3, type, &v134))
    goto LABEL_220;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v82 = __nwlog_obj();
    v83 = type[0];
    if (!os_log_type_enabled(v82, type[0]))
      goto LABEL_220;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
    v84 = "%{public}s called with null http2";
    goto LABEL_219;
  }
  if (v134 == OS_LOG_TYPE_DEFAULT)
  {
    v82 = __nwlog_obj();
    v83 = type[0];
    if (!os_log_type_enabled(v82, type[0]))
      goto LABEL_220;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
    v84 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_219;
  }
  v99 = (char *)__nw_create_backtrace_string();
  v82 = __nwlog_obj();
  v83 = type[0];
  v100 = os_log_type_enabled(v82, type[0]);
  if (!v99)
  {
    if (!v100)
      goto LABEL_220;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
    v84 = "%{public}s called with null http2, no backtrace";
    goto LABEL_219;
  }
  if (v100)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_destroy";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v99;
    _os_log_impl(&dword_182FBE000, v82, v83, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v99);
  if (v3)
    goto LABEL_139;
}

uint64_t ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke_56(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t object;
  uint64_t v5;
  NSObject *v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  object = nw_hash_node_get_object(a2);
  nw_protocol_set_input_handler(v3, object);
  *(_OWORD *)*(_QWORD *)(a1 + 40) = *(_OWORD *)*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48);
  v5 = *(_QWORD *)(a1 + 40);
  if ((!v5 || (*(__int16 *)(v5 + 376) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v8 = *(_QWORD *)(a1 + 40);
      v9 = (const char *)(v8 + 378);
      v10 = "";
      v11 = v8 == 0;
      if (!v8)
        v9 = "";
      v12 = *(_DWORD *)(v8 + 368);
      if (!v11)
        v10 = " ";
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48);
      v14 = 136447234;
      v15 = "nw_protocol_http2_remove_input_handler_block_invoke";
      v16 = 2082;
      v17 = v9;
      v18 = 2080;
      v19 = v10;
      v20 = 1024;
      v21 = v12;
      v22 = 2048;
      v23 = v13;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> reset default input handler to %p", (uint8_t *)&v14, 0x30u);
    }
  }
  return 0;
}

uint64_t ___ZL25nw_protocol_http2_destroyP11nw_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t object;
  uint64_t v5;
  int v6;
  int v7;
  NSObject *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  BOOL v14;
  int v15;
  const char *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint64_t v20;
  const char *v21;
  BOOL v22;
  int v23;
  const char *v24;
  const char *v25;
  char *backtrace_string;
  _BOOL4 v27;
  uint64_t v28;
  const char *v29;
  BOOL v30;
  int v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  BOOL v35;
  int v36;
  const char *v37;
  uint64_t v38;
  const char *v39;
  BOOL v40;
  int v41;
  const char *v42;
  NSObject *v44;
  int v45;
  int v46;
  char v47;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  _BYTE v58[10];
  char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  object = nw_hash_node_get_object(a2);
  if (object)
  {
    v5 = object;
    v6 = *(unsigned __int16 *)(object + 188);
    v7 = v6 | (*(unsigned __int8 *)(object + 190) << 16);
    if ((v6 & 1) == 0 || *(_DWORD *)(object + 176) == -1)
    {
      if ((v7 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v44 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v46 = *(_DWORD *)(v5 + 176);
          v45 = *(_DWORD *)(v5 + 180);
          *(_DWORD *)buf = 136447234;
          v50 = "nw_protocol_http2_destroy_block_invoke";
          v51 = 2082;
          v52 = (const char *)(v5 + 191);
          v53 = 2080;
          v54 = " ";
          v55 = 1024;
          v56 = v45;
          v57 = 1024;
          *(_DWORD *)v58 = v46;
          _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> not closing already closed or invalid stream when destroying", buf, 0x2Cu);
        }
      }
      *(_WORD *)(v5 + 188) &= ~1u;
      *(_DWORD *)(v5 + 176) = -1;
      nw_hash_table_remove_node(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 160), a2);
    }
    else
    {
      if ((v7 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v8 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          v10 = *(_DWORD *)(v5 + 176);
          v9 = *(_DWORD *)(v5 + 180);
          *(_DWORD *)buf = 136447490;
          v50 = "nw_protocol_http2_destroy_block_invoke";
          v51 = 2082;
          v52 = (const char *)(v5 + 191);
          v53 = 2080;
          v54 = " ";
          v55 = 1024;
          v56 = v9;
          v57 = 1024;
          *(_DWORD *)v58 = v10;
          *(_WORD *)&v58[4] = 1024;
          *(_DWORD *)&v58[6] = v10;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> closing stream %d during destroy, did not have an active input_handler", buf, 0x32u);
        }
      }
      nw_http2_stream_close(*(_QWORD *)(a1 + 32), v5);
    }
    nw_http2_stream_destroy((void **)v5);
    return 1;
  }
  v11 = *(_QWORD *)(a1 + 32);
  if (v11 && *(__int16 *)(v11 + 376) < 0)
    return 1;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v12 = *(_QWORD *)(a1 + 32);
  v13 = (const char *)(v12 + 378);
  v14 = v12 == 0;
  v15 = *(_DWORD *)(v12 + 368);
  if (v14)
    v13 = "";
  *(_DWORD *)buf = 136447234;
  v50 = "nw_protocol_http2_destroy_block_invoke";
  if (v14)
    v16 = "";
  else
    v16 = " ";
  v51 = 2082;
  v52 = v13;
  v53 = 2080;
  v54 = v16;
  v55 = 1024;
  v56 = v15;
  v57 = 2048;
  *(_QWORD *)v58 = a2;
  v17 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v47 = 0;
  if (__nwlog_fault(v17, &type, &v47))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v18 = gconnectionLogObj;
      v19 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_63;
      v20 = *(_QWORD *)(a1 + 32);
      v21 = (const char *)(v20 + 378);
      v22 = v20 == 0;
      if (!v20)
        v21 = "";
      v23 = *(_DWORD *)(v20 + 368);
      if (v22)
        v24 = "";
      else
        v24 = " ";
      *(_DWORD *)buf = 136447234;
      v50 = "nw_protocol_http2_destroy_block_invoke";
      v51 = 2082;
      v52 = v21;
      v53 = 2080;
      v54 = v24;
      v55 = 1024;
      v56 = v23;
      v57 = 2048;
      *(_QWORD *)v58 = a2;
      v25 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra";
      goto LABEL_62;
    }
    if (!v47)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v18 = gconnectionLogObj;
      v19 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        goto LABEL_63;
      v33 = *(_QWORD *)(a1 + 32);
      v34 = (const char *)(v33 + 378);
      v35 = v33 == 0;
      if (!v33)
        v34 = "";
      v36 = *(_DWORD *)(v33 + 368);
      if (v35)
        v37 = "";
      else
        v37 = " ";
      *(_DWORD *)buf = 136447234;
      v50 = "nw_protocol_http2_destroy_block_invoke";
      v51 = 2082;
      v52 = v34;
      v53 = 2080;
      v54 = v37;
      v55 = 1024;
      v56 = v36;
      v57 = 2048;
      *(_QWORD *)v58 = a2;
      v25 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, backtrace limit exceeded";
      goto LABEL_62;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v18 = gconnectionLogObj;
    v19 = type;
    v27 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (backtrace_string)
    {
      if (v27)
      {
        v28 = *(_QWORD *)(a1 + 32);
        v29 = (const char *)(v28 + 378);
        v30 = v28 == 0;
        if (!v28)
          v29 = "";
        v31 = *(_DWORD *)(v28 + 368);
        if (v30)
          v32 = "";
        else
          v32 = " ";
        *(_DWORD *)buf = 136447490;
        v50 = "nw_protocol_http2_destroy_block_invoke";
        v51 = 2082;
        v52 = v29;
        v53 = 2080;
        v54 = v32;
        v55 = 1024;
        v56 = v31;
        v57 = 2048;
        *(_QWORD *)v58 = a2;
        *(_WORD *)&v58[8] = 2082;
        v59 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, dumping backtrace:%{public}s", buf, 0x3Au);
      }
      free(backtrace_string);
      goto LABEL_63;
    }
    if (v27)
    {
      v38 = *(_QWORD *)(a1 + 32);
      v39 = (const char *)(v38 + 378);
      v40 = v38 == 0;
      if (!v38)
        v39 = "";
      v41 = *(_DWORD *)(v38 + 368);
      if (v40)
        v42 = "";
      else
        v42 = " ";
      *(_DWORD *)buf = 136447234;
      v50 = "nw_protocol_http2_destroy_block_invoke";
      v51 = 2082;
      v52 = v39;
      v53 = 2080;
      v54 = v42;
      v55 = 1024;
      v56 = v41;
      v57 = 2048;
      *(_QWORD *)v58 = a2;
      v25 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, no backtrace";
LABEL_62:
      _os_log_impl(&dword_182FBE000, v18, v19, v25, buf, 0x30u);
    }
  }
LABEL_63:
  if (v17)
    free(v17);
  return 1;
}

void ___ZL36nw_protocol_http2_set_up_associationP17nw_protocol_http2P13nw_parameters_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t handle;
  uint64_t v5;
  _BOOL8 v6;
  void *v7;
  void *v8;
  void *v9;
  _BOOL4 is_viable;
  int alternate_path_state;
  __int16 v12;
  NSObject *v14;
  int v15;
  __int16 v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  int v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  char *v27;
  _BOOL4 v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  handle = nw_protocol_instance_stub_get_handle(a2);
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_protocol_http2_set_up_association_block_invoke";
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v21, &type, &v29))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_protocol_http2_set_up_association_block_invoke";
      v24 = "%{public}s called with null protocol_handle";
      goto LABEL_66;
    }
    if (!v29)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_protocol_http2_set_up_association_block_invoke";
      v24 = "%{public}s called with null protocol_handle, backtrace limit exceeded";
      goto LABEL_66;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v26 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (!v26)
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_protocol_http2_set_up_association_block_invoke";
      v24 = "%{public}s called with null protocol_handle, no backtrace";
      goto LABEL_66;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v32 = "nw_protocol_http2_set_up_association_block_invoke";
      v33 = 2082;
      v34 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null protocol_handle, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_67:
    if (!v21)
      return;
    goto LABEL_68;
  }
  v5 = *(_QWORD *)(handle + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_protocol_http2_set_up_association_block_invoke";
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v21, &type, &v29))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_protocol_http2_set_up_association_block_invoke";
      v24 = "%{public}s called with null http2";
      goto LABEL_66;
    }
    if (!v29)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_protocol_http2_set_up_association_block_invoke";
      v24 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_66;
    }
    v27 = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v28 = os_log_type_enabled(v22, type);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        v32 = "nw_protocol_http2_set_up_association_block_invoke";
        v33 = 2082;
        v34 = v27;
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v27);
      if (!v21)
        return;
LABEL_68:
      free(v21);
      return;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446210;
      v32 = "nw_protocol_http2_set_up_association_block_invoke";
      v24 = "%{public}s called with null http2, no backtrace";
LABEL_66:
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
      goto LABEL_67;
    }
    goto LABEL_67;
  }
  if ((*(_WORD *)(v5 + 376) & 8) == 0)
  {
    v6 = nw_path_copy_for_flow_registration(a3, *(void **)(v5 + 280));
    if (v6)
    {
      v7 = (void *)v6;
      v8 = *(void **)(v5 + 120);
      if (v8 != v7)
      {
        if (v8)
        {
          os_release(v8);
          *(_QWORD *)(v5 + 120) = 0;
        }
        *(_QWORD *)(v5 + 120) = os_retain(v7);
      }
      v9 = *(void **)(v5 + 304);
      if (v9 && (nw_path_has_proxy_config(v7, v9) & 1) == 0)
      {
        if ((*(__int16 *)(v5 + 376) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v17 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            v18 = *(_DWORD *)(v5 + 368);
            *(_DWORD *)buf = 136446978;
            v32 = "nw_protocol_http2_set_up_association_block_invoke";
            v33 = 2082;
            v34 = (char *)(v5 + 378);
            v35 = 2080;
            v36 = " ";
            v37 = 1024;
            v38 = v18;
            _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Effective proxy configuration lost, treating as a GOAWAY", buf, 0x26u);
          }
        }
        nw_http2_connection_receive_goaway(v5, 0x7FFFFFFFLL);
        goto LABEL_37;
      }
      if ((*(_WORD *)(v5 + 376) & 0x20) != 0)
      {
        is_viable = nw_path_is_viable(v7);
        alternate_path_state = nw_path_get_alternate_path_state(v7, a3);
        v12 = *(_WORD *)(v5 + 376);
        if (is_viable && alternate_path_state == 0)
        {
          if ((v12 & 0x40) != 0)
          {
            if ((*(_WORD *)(v5 + 376) & 0x8000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v19 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
              {
                v20 = *(_DWORD *)(v5 + 368);
                *(_DWORD *)buf = 136446978;
                v32 = "nw_protocol_http2_set_up_association_block_invoke";
                v33 = 2082;
                v34 = (char *)(v5 + 378);
                v35 = 2080;
                v36 = " ";
                v37 = 1024;
                v38 = v20;
                _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Path recovered, recommending that new flows join", buf, 0x26u);
              }
            }
            v16 = *(_WORD *)(v5 + 376) & 0xFFBF;
            goto LABEL_36;
          }
        }
        else if ((v12 & 0x40) == 0)
        {
          if ((*(_WORD *)(v5 + 376) & 0x8000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v14 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
            {
              v15 = *(_DWORD *)(v5 + 368);
              *(_DWORD *)buf = 136446978;
              v32 = "nw_protocol_http2_set_up_association_block_invoke";
              v33 = 2082;
              v34 = (char *)(v5 + 378);
              v35 = 2080;
              v36 = " ";
              v37 = 1024;
              v38 = v15;
              _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Bad path, recommending that new flows not join", buf, 0x26u);
            }
          }
          v16 = *(_WORD *)(v5 + 376) | 0x40;
LABEL_36:
          *(_WORD *)(v5 + 376) = v16;
        }
      }
LABEL_37:
      os_release(v7);
    }
  }
}

uint64_t ___ZL32nw_protocol_http2_input_finishedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t object;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  BOOL v17;
  int v18;
  const char *v19;
  const char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  const char *v24;
  BOOL v25;
  int v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  BOOL v34;
  int v35;
  uint64_t v36;
  void (*v37)(uint64_t, _QWORD);
  const char *v38;
  const char *v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  const char *v43;
  NSObject *v44;
  int v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  void (*v50)(uint64_t, _QWORD, uint64_t);
  uint64_t v51;
  const char *v52;
  char *backtrace_string;
  _BOOL4 v54;
  uint64_t v55;
  const char *v56;
  BOOL v57;
  int v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  const char *v62;
  BOOL v63;
  int v64;
  const char *v65;
  uint64_t v66;
  const char *v67;
  BOOL v68;
  int v69;
  const char *v70;
  char *v71;
  char *v73;
  _BOOL4 v74;
  const char *v75;
  const char *v76;
  const char *v77;
  const char *v78;
  const char *v79;
  char *v80;
  NSObject *v81;
  os_log_type_t v82;
  const char *v83;
  const char *v84;
  char *v85;
  _BOOL4 v86;
  const char *v87;
  const char *v88;
  _BOOL4 v89;
  char *v90;
  _BOOL4 v91;
  const char *v92;
  const char *v93;
  const char *v94;
  const char *v95;
  const char *v96;
  char v97;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  const char *v104;
  __int16 v105;
  int v106;
  __int16 v107;
  _BYTE v108[10];
  char *v109;
  uint64_t v110;

  v110 = *MEMORY[0x1E0C80C00];
  object = nw_hash_node_get_object(a2);
  if (!object)
  {
    v14 = *(_QWORD *)(a1 + 32);
    if (v14 && *(__int16 *)(v14 + 376) < 0)
      return 1;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v15 = *(_QWORD *)(a1 + 32);
    v16 = (const char *)(v15 + 378);
    v17 = v15 == 0;
    v18 = *(_DWORD *)(v15 + 368);
    if (v17)
      v16 = "";
    *(_DWORD *)buf = 136447234;
    v100 = "nw_protocol_http2_input_finished_block_invoke";
    if (v17)
      v19 = "";
    else
      v19 = " ";
    v101 = 2082;
    v102 = v16;
    v103 = 2080;
    v104 = v19;
    v105 = 1024;
    v106 = v18;
    v107 = 2048;
    *(_QWORD *)v108 = a2;
    v20 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v97 = 0;
    if (!__nwlog_fault(v20, &type, &v97))
      goto LABEL_103;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v21 = gconnectionLogObj;
      v22 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v23 = *(_QWORD *)(a1 + 32);
        v24 = (const char *)(v23 + 378);
        v25 = v23 == 0;
        if (!v23)
          v24 = "";
        v26 = *(_DWORD *)(v23 + 368);
        if (v25)
          v27 = "";
        else
          v27 = " ";
        *(_DWORD *)buf = 136447234;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v24;
        v103 = 2080;
        v104 = v27;
        v105 = 1024;
        v106 = v26;
        v107 = 2048;
        *(_QWORD *)v108 = a2;
        v28 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished";
LABEL_102:
        _os_log_impl(&dword_182FBE000, v21, v22, v28, buf, 0x30u);
      }
    }
    else if (v97)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v21 = gconnectionLogObj;
      v22 = type;
      v54 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (!backtrace_string)
      {
        if (!v54)
          goto LABEL_103;
        v66 = *(_QWORD *)(a1 + 32);
        v67 = (const char *)(v66 + 378);
        v68 = v66 == 0;
        if (!v66)
          v67 = "";
        v69 = *(_DWORD *)(v66 + 368);
        if (v68)
          v70 = "";
        else
          v70 = " ";
        *(_DWORD *)buf = 136447234;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v67;
        v103 = 2080;
        v104 = v70;
        v105 = 1024;
        v106 = v69;
        v107 = 2048;
        *(_QWORD *)v108 = a2;
        v28 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished, no backtrace";
        goto LABEL_102;
      }
      if (v54)
      {
        v55 = *(_QWORD *)(a1 + 32);
        v56 = (const char *)(v55 + 378);
        v57 = v55 == 0;
        if (!v55)
          v56 = "";
        v58 = *(_DWORD *)(v55 + 368);
        if (v57)
          v59 = "";
        else
          v59 = " ";
        *(_DWORD *)buf = 136447490;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v56;
        v103 = 2080;
        v104 = v59;
        v105 = 1024;
        v106 = v58;
        v107 = 2048;
        *(_QWORD *)v108 = a2;
        *(_WORD *)&v108[8] = 2082;
        v109 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished, dumping backtrace:%{public}s", buf, 0x3Au);
      }
      free(backtrace_string);
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v21 = gconnectionLogObj;
      v22 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        v61 = *(_QWORD *)(a1 + 32);
        v62 = (const char *)(v61 + 378);
        v63 = v61 == 0;
        if (!v61)
          v62 = "";
        v64 = *(_DWORD *)(v61 + 368);
        if (v63)
          v65 = "";
        else
          v65 = " ";
        *(_DWORD *)buf = 136447234;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v62;
        v103 = 2080;
        v104 = v65;
        v105 = 1024;
        v106 = v64;
        v107 = 2048;
        *(_QWORD *)v108 = a2;
        v28 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished, backtrace limit exceeded";
        goto LABEL_102;
      }
    }
LABEL_103:
    if (v20)
    {
      v71 = (char *)v20;
LABEL_105:
      free(v71);
      return 1;
    }
    return 1;
  }
  v5 = object;
  v6 = *(_QWORD *)nw_hash_node_get_extra(a2);
  if (!v6)
  {
    v29 = *(_QWORD *)(a1 + 32);
    if (!v29 || (*(__int16 *)(v29 + 376) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v30 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        v31 = *(_QWORD *)(a1 + 32);
        v32 = (const char *)(v31 + 378);
        v33 = "";
        v34 = v31 == 0;
        v35 = *(_DWORD *)(v31 + 368);
        if (v34)
          v32 = "";
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        *(_DWORD *)buf = 136446978;
        if (!v34)
          v33 = " ";
        v102 = v32;
        v103 = 2080;
        v104 = v33;
        v105 = 1024;
        v106 = v35;
        _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> input protocol has no stream, masking input_finished with disconnected", buf, 0x26u);
      }
    }
LABEL_41:
    v36 = *(_QWORD *)(v5 + 24);
    if (!v36 || (v37 = *(void (**)(uint64_t, _QWORD))(v36 + 48)) == 0)
    {
      __nwlog_obj();
      v38 = *(const char **)(v5 + 16);
      if (!v38)
        v38 = "invalid";
      *(_DWORD *)buf = 136446466;
      v100 = "nw_protocol_http2_input_finished_block_invoke";
      v101 = 2082;
      v102 = v38;
      v39 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v97 = 0;
      if (__nwlog_fault(v39, &type, &v97))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v40 = __nwlog_obj();
          v41 = type;
          if (!os_log_type_enabled(v40, type))
            goto LABEL_180;
          v42 = *(const char **)(v5 + 16);
          if (!v42)
            v42 = "invalid";
LABEL_50:
          *(_DWORD *)buf = 136446466;
          v100 = "nw_protocol_http2_input_finished_block_invoke";
          v101 = 2082;
          v102 = v42;
          v43 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_179:
          _os_log_impl(&dword_182FBE000, v40, v41, v43, buf, 0x16u);
          goto LABEL_180;
        }
        if (v97)
        {
          v73 = (char *)__nw_create_backtrace_string();
          v40 = __nwlog_obj();
          v41 = type;
          v74 = os_log_type_enabled(v40, type);
          if (v73)
          {
            if (!v74)
              goto LABEL_113;
            v75 = *(const char **)(v5 + 16);
            if (!v75)
              v75 = "invalid";
            goto LABEL_112;
          }
          if (!v74)
            goto LABEL_180;
          v88 = *(const char **)(v5 + 16);
          if (!v88)
            v88 = "invalid";
          goto LABEL_178;
        }
        v40 = __nwlog_obj();
        v41 = type;
        if (!os_log_type_enabled(v40, type))
          goto LABEL_180;
        v78 = *(const char **)(v5 + 16);
        if (!v78)
          v78 = "invalid";
        goto LABEL_126;
      }
      goto LABEL_180;
    }
    goto LABEL_85;
  }
  v7 = *(unsigned __int16 *)(v6 + 188);
  v8 = v7 | (*(unsigned __int8 *)(v6 + 190) << 16);
  if ((v7 & 1) != 0)
  {
    if ((v7 & 0x1000) != 0)
    {
      v60 = *(_QWORD *)(v5 + 24);
      if (!v60 || (v37 = *(void (**)(uint64_t, _QWORD))(v60 + 184)) == 0)
      {
        __nwlog_obj();
        v76 = *(const char **)(v5 + 16);
        if (!v76)
          v76 = "invalid";
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v76;
        v39 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v97 = 0;
        if (__nwlog_fault(v39, &type, &v97))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v40 = __nwlog_obj();
            v41 = type;
            if (!os_log_type_enabled(v40, type))
              goto LABEL_180;
            v77 = *(const char **)(v5 + 16);
            if (!v77)
              v77 = "invalid";
            *(_DWORD *)buf = 136446466;
            v100 = "nw_protocol_http2_input_finished_block_invoke";
            v101 = 2082;
            v102 = v77;
            v43 = "%{public}s protocol %{public}s has invalid input_finished callback";
            goto LABEL_179;
          }
          if (!v97)
          {
            v40 = __nwlog_obj();
            v41 = type;
            if (!os_log_type_enabled(v40, type))
              goto LABEL_180;
            v93 = *(const char **)(v5 + 16);
            if (!v93)
              v93 = "invalid";
            *(_DWORD *)buf = 136446466;
            v100 = "nw_protocol_http2_input_finished_block_invoke";
            v101 = 2082;
            v102 = v93;
            v43 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
            goto LABEL_179;
          }
          v85 = (char *)__nw_create_backtrace_string();
          v40 = __nwlog_obj();
          v41 = type;
          v86 = os_log_type_enabled(v40, type);
          if (!v85)
          {
            if (!v86)
              goto LABEL_180;
            v94 = *(const char **)(v5 + 16);
            if (!v94)
              v94 = "invalid";
            *(_DWORD *)buf = 136446466;
            v100 = "nw_protocol_http2_input_finished_block_invoke";
            v101 = 2082;
            v102 = v94;
            v43 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
            goto LABEL_179;
          }
          if (v86)
          {
            v87 = *(const char **)(v5 + 16);
            if (!v87)
              v87 = "invalid";
            *(_DWORD *)buf = 136446722;
            v100 = "nw_protocol_http2_input_finished_block_invoke";
            v101 = 2082;
            v102 = v87;
            v103 = 2082;
            v104 = v85;
            _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v85);
        }
        goto LABEL_180;
      }
LABEL_85:
      v37(v5, *(_QWORD *)(a1 + 32));
      return 1;
    }
    if ((v8 & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v44 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v46 = *(_DWORD *)(v6 + 176);
        v45 = *(_DWORD *)(v6 + 180);
        *(_DWORD *)buf = 136447234;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = (const char *)(v6 + 191);
        v103 = 2080;
        v104 = " ";
        v105 = 1024;
        v106 = v45;
        v107 = 1024;
        *(_DWORD *)v108 = v46;
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> input finished before a complete message", buf, 0x2Cu);
      }
    }
    v47 = *(unsigned __int16 *)(v6 + 188);
    v48 = v47 | (*(unsigned __int8 *)(v6 + 190) << 16);
    if ((v47 & 0x40) != 0)
      return 1;
    *(_BYTE *)(v6 + 190) = BYTE2(v48);
    *(_WORD *)(v6 + 188) = v48 | 0x40;
    v49 = *(_QWORD *)(v5 + 24);
    if (v49)
    {
      v50 = *(void (**)(uint64_t, _QWORD, uint64_t))(v49 + 56);
      if (v50)
      {
        v50(v5, *(_QWORD *)(a1 + 32), 57);
        goto LABEL_61;
      }
    }
    __nwlog_obj();
    v79 = *(const char **)(v5 + 16);
    if (!v79)
      v79 = "invalid";
    *(_DWORD *)buf = 136446466;
    v100 = "nw_protocol_http2_input_finished_block_invoke";
    v101 = 2082;
    v102 = v79;
    v80 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v97 = 0;
    if (__nwlog_fault(v80, &type, &v97))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v81 = __nwlog_obj();
        v82 = type;
        if (!os_log_type_enabled(v81, type))
          goto LABEL_187;
        v83 = *(const char **)(v5 + 16);
        if (!v83)
          v83 = "invalid";
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v83;
        v84 = "%{public}s protocol %{public}s has invalid error callback";
        goto LABEL_186;
      }
      if (!v97)
      {
        v81 = __nwlog_obj();
        v82 = type;
        if (!os_log_type_enabled(v81, type))
          goto LABEL_187;
        v95 = *(const char **)(v5 + 16);
        if (!v95)
          v95 = "invalid";
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v95;
        v84 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_186;
      }
      v90 = (char *)__nw_create_backtrace_string();
      v81 = __nwlog_obj();
      v82 = type;
      v91 = os_log_type_enabled(v81, type);
      if (v90)
      {
        if (v91)
        {
          v92 = *(const char **)(v5 + 16);
          if (!v92)
            v92 = "invalid";
          *(_DWORD *)buf = 136446722;
          v100 = "nw_protocol_http2_input_finished_block_invoke";
          v101 = 2082;
          v102 = v92;
          v103 = 2082;
          v104 = v90;
          _os_log_impl(&dword_182FBE000, v81, v82, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v90);
        goto LABEL_187;
      }
      if (v91)
      {
        v96 = *(const char **)(v5 + 16);
        if (!v96)
          v96 = "invalid";
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v96;
        v84 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
LABEL_186:
        _os_log_impl(&dword_182FBE000, v81, v82, v84, buf, 0x16u);
      }
    }
LABEL_187:
    if (v80)
      free(v80);
LABEL_61:
    v51 = *(_QWORD *)(v5 + 24);
    if (!v51 || (v37 = *(void (**)(uint64_t, _QWORD))(v51 + 48)) == 0)
    {
      __nwlog_obj();
      v52 = *(const char **)(v5 + 16);
      if (!v52)
        v52 = "invalid";
      *(_DWORD *)buf = 136446466;
      v100 = "nw_protocol_http2_input_finished_block_invoke";
      v101 = 2082;
      v102 = v52;
      v39 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v97 = 0;
      if (__nwlog_fault(v39, &type, &v97))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v40 = __nwlog_obj();
          v41 = type;
          if (!os_log_type_enabled(v40, type))
            goto LABEL_180;
          v42 = *(const char **)(v5 + 16);
          if (!v42)
            v42 = "invalid";
          goto LABEL_50;
        }
        if (v97)
        {
          v73 = (char *)__nw_create_backtrace_string();
          v40 = __nwlog_obj();
          v41 = type;
          v89 = os_log_type_enabled(v40, type);
          if (v73)
          {
            if (!v89)
            {
LABEL_113:
              free(v73);
              if (!v39)
                return 1;
LABEL_181:
              v71 = (char *)v39;
              goto LABEL_105;
            }
            v75 = *(const char **)(v5 + 16);
            if (!v75)
              v75 = "invalid";
LABEL_112:
            *(_DWORD *)buf = 136446722;
            v100 = "nw_protocol_http2_input_finished_block_invoke";
            v101 = 2082;
            v102 = v75;
            v103 = 2082;
            v104 = v73;
            _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
            goto LABEL_113;
          }
          if (!v89)
            goto LABEL_180;
          v88 = *(const char **)(v5 + 16);
          if (!v88)
            v88 = "invalid";
LABEL_178:
          *(_DWORD *)buf = 136446466;
          v100 = "nw_protocol_http2_input_finished_block_invoke";
          v101 = 2082;
          v102 = v88;
          v43 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
          goto LABEL_179;
        }
        v40 = __nwlog_obj();
        v41 = type;
        if (!os_log_type_enabled(v40, type))
          goto LABEL_180;
        v78 = *(const char **)(v5 + 16);
        if (!v78)
          v78 = "invalid";
LABEL_126:
        *(_DWORD *)buf = 136446466;
        v100 = "nw_protocol_http2_input_finished_block_invoke";
        v101 = 2082;
        v102 = v78;
        v43 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_179;
      }
LABEL_180:
      if (!v39)
        return 1;
      goto LABEL_181;
    }
    goto LABEL_85;
  }
  if ((v8 & 0x80000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
    {
      v11 = *(_DWORD *)(v6 + 176);
      v10 = *(_DWORD *)(v6 + 180);
      *(_DWORD *)buf = 136447490;
      v100 = "nw_protocol_http2_input_finished_block_invoke";
      v101 = 2082;
      v102 = (const char *)(v6 + 191);
      v103 = 2080;
      v104 = " ";
      v105 = 1024;
      v106 = v10;
      v107 = 1024;
      *(_DWORD *)v108 = v11;
      *(_WORD *)&v108[4] = 1024;
      *(_DWORD *)&v108[6] = v11;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> stream %d not open, masking input_finished with disconnected", buf, 0x32u);
    }
  }
  v12 = *(unsigned __int16 *)(v6 + 188);
  v13 = v12 | (*(unsigned __int8 *)(v6 + 190) << 16);
  if ((v12 & 0x40) == 0)
  {
    *(_BYTE *)(v6 + 190) = BYTE2(v13);
    *(_WORD *)(v6 + 188) = v13 | 0x40;
    goto LABEL_41;
  }
  return 1;
}

double __nw_protocol_http2_identifier_block_invoke()
{
  double result;

  strcpy((char *)&nw_protocol_http2_identifier::http2_protocol_identifier, "http2");
  *(_QWORD *)&result = 0x200000004;
  qword_1EDCE51FC = 0x200000004;
  return result;
}

uint64_t nw_network_agent_ctl_setsockopt(int a1, int a2, unsigned __int8 *uu, _BYTE *a4, _BYTE *a5, uint64_t a6, int a7, int a8, char a9, char a10, char a11, char a12, char a13, char a14, char a15, char a16, unsigned __int8 a17, unsigned __int8 a18, char a19, const unsigned __int8 *a20,unsigned int a21)
{
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  char *backtrace_string;
  _BOOL4 v36;
  const char *v37;
  _BOOL4 v38;
  _BOOL4 v39;
  _BOOL4 v40;
  char v44;
  os_log_type_t type;
  _BYTE buf[32];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _OWORD v50[7];
  __int128 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
    return nw_network_agent_ctl_setsockopt_inner(a1, 2, 0, 0, 0, 0);
  if (!uu)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
    v27 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
      goto LABEL_122;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null netagent_uuid";
      goto LABEL_121;
    }
    if (!v44)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
      goto LABEL_121;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = type;
    v38 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v38)
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null netagent_uuid, no backtrace";
      goto LABEL_121;
    }
    if (!v38)
      goto LABEL_116;
LABEL_114:
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v37 = "%{public}s called with null netagent_uuid, dumping backtrace:%{public}s";
LABEL_115:
    _os_log_impl(&dword_182FBE000, v28, v29, v37, buf, 0x16u);
    goto LABEL_116;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
    v27 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
      goto LABEL_122;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null domain";
      goto LABEL_121;
    }
    if (!v44)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null domain, backtrace limit exceeded";
      goto LABEL_121;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = type;
    v39 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v39)
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null domain, no backtrace";
      goto LABEL_121;
    }
    if (!v39)
      goto LABEL_116;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v37 = "%{public}s called with null domain, dumping backtrace:%{public}s";
    goto LABEL_115;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
    v27 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v27, &type, &v44))
      goto LABEL_122;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null type";
      goto LABEL_121;
    }
    if (!v44)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_121;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = type;
    v40 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v40)
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null type, no backtrace";
      goto LABEL_121;
    }
    if (!v40)
      goto LABEL_116;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v37 = "%{public}s called with null type, dumping backtrace:%{public}s";
    goto LABEL_115;
  }
  if (!uuid_is_null(uu))
  {
    v52 = 0;
    v51 = 0u;
    v49 = 0u;
    memset(v50, 0, sizeof(v50));
    v47 = 0u;
    v48 = 0u;
    *(_OWORD *)buf = *(_OWORD *)uu;
    *(_OWORD *)&buf[16] = 0u;
    buf[16] = *a4;
    if (buf[16])
    {
      buf[17] = a4[1];
      if (buf[17])
      {
        buf[18] = a4[2];
        if (buf[18])
        {
          buf[19] = a4[3];
          if (buf[19])
          {
            buf[20] = a4[4];
            if (buf[20])
            {
              buf[21] = a4[5];
              if (buf[21])
              {
                buf[22] = a4[6];
                if (buf[22])
                {
                  buf[23] = a4[7];
                  if (buf[23])
                  {
                    buf[24] = a4[8];
                    if (buf[24])
                    {
                      buf[25] = a4[9];
                      if (buf[25])
                      {
                        buf[26] = a4[10];
                        if (buf[26])
                        {
                          buf[27] = a4[11];
                          if (buf[27])
                          {
                            buf[28] = a4[12];
                            if (buf[28])
                            {
                              buf[29] = a4[13];
                              if (buf[29])
                              {
                                buf[30] = a4[14];
                                if (buf[30])
                                {
                                  buf[31] = a4[15];
                                  if (buf[31])
                                  {
                                    LOBYTE(v47) = a4[16];
                                    if ((_BYTE)v47)
                                    {
                                      BYTE1(v47) = a4[17];
                                      if (BYTE1(v47))
                                      {
                                        BYTE2(v47) = a4[18];
                                        if (BYTE2(v47))
                                        {
                                          BYTE3(v47) = a4[19];
                                          if (BYTE3(v47))
                                          {
                                            BYTE4(v47) = a4[20];
                                            if (BYTE4(v47))
                                            {
                                              BYTE5(v47) = a4[21];
                                              if (BYTE5(v47))
                                              {
                                                BYTE6(v47) = a4[22];
                                                if (BYTE6(v47))
                                                {
                                                  BYTE7(v47) = a4[23];
                                                  if (BYTE7(v47))
                                                  {
                                                    BYTE8(v47) = a4[24];
                                                    if (BYTE8(v47))
                                                    {
                                                      BYTE9(v47) = a4[25];
                                                      if (BYTE9(v47))
                                                      {
                                                        BYTE10(v47) = a4[26];
                                                        if (BYTE10(v47))
                                                        {
                                                          BYTE11(v47) = a4[27];
                                                          if (BYTE11(v47))
                                                          {
                                                            BYTE12(v47) = a4[28];
                                                            if (BYTE12(v47))
                                                            {
                                                              BYTE13(v47) = a4[29];
                                                              if (BYTE13(v47))
                                                              {
                                                                BYTE14(v47) = a4[30];
                                                                if (BYTE14(v47))
                                                                  HIBYTE(v47) = 0;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    LOBYTE(v48) = *a5;
    if ((_BYTE)v48)
    {
      BYTE1(v48) = a5[1];
      if (BYTE1(v48))
      {
        BYTE2(v48) = a5[2];
        if (BYTE2(v48))
        {
          BYTE3(v48) = a5[3];
          if (BYTE3(v48))
          {
            BYTE4(v48) = a5[4];
            if (BYTE4(v48))
            {
              BYTE5(v48) = a5[5];
              if (BYTE5(v48))
              {
                BYTE6(v48) = a5[6];
                if (BYTE6(v48))
                {
                  BYTE7(v48) = a5[7];
                  if (BYTE7(v48))
                  {
                    BYTE8(v48) = a5[8];
                    if (BYTE8(v48))
                    {
                      BYTE9(v48) = a5[9];
                      if (BYTE9(v48))
                      {
                        BYTE10(v48) = a5[10];
                        if (BYTE10(v48))
                        {
                          BYTE11(v48) = a5[11];
                          if (BYTE11(v48))
                          {
                            BYTE12(v48) = a5[12];
                            if (BYTE12(v48))
                            {
                              BYTE13(v48) = a5[13];
                              if (BYTE13(v48))
                              {
                                BYTE14(v48) = a5[14];
                                if (BYTE14(v48))
                                {
                                  HIBYTE(v48) = a5[15];
                                  if (HIBYTE(v48))
                                  {
                                    LOBYTE(v49) = a5[16];
                                    if ((_BYTE)v49)
                                    {
                                      BYTE1(v49) = a5[17];
                                      if (BYTE1(v49))
                                      {
                                        BYTE2(v49) = a5[18];
                                        if (BYTE2(v49))
                                        {
                                          BYTE3(v49) = a5[19];
                                          if (BYTE3(v49))
                                          {
                                            BYTE4(v49) = a5[20];
                                            if (BYTE4(v49))
                                            {
                                              BYTE5(v49) = a5[21];
                                              if (BYTE5(v49))
                                              {
                                                BYTE6(v49) = a5[22];
                                                if (BYTE6(v49))
                                                {
                                                  BYTE7(v49) = a5[23];
                                                  if (BYTE7(v49))
                                                  {
                                                    BYTE8(v49) = a5[24];
                                                    if (BYTE8(v49))
                                                    {
                                                      BYTE9(v49) = a5[25];
                                                      if (BYTE9(v49))
                                                      {
                                                        BYTE10(v49) = a5[26];
                                                        if (BYTE10(v49))
                                                        {
                                                          BYTE11(v49) = a5[27];
                                                          if (BYTE11(v49))
                                                          {
                                                            BYTE12(v49) = a5[28];
                                                            if (BYTE12(v49))
                                                            {
                                                              BYTE13(v49) = a5[29];
                                                              if (BYTE13(v49))
                                                              {
                                                                BYTE14(v49) = a5[30];
                                                                if (BYTE14(v49))
                                                                  HIBYTE(v49) = 0;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (a6)
    {
      v31 = 0;
      while (1)
      {
        v32 = *(unsigned __int8 *)(a6 + v31);
        *((_BYTE *)v50 + v31) = v32;
        if (!v32)
          break;
        if (++v31 == 127)
        {
          HIBYTE(v51) = 0;
          break;
        }
      }
    }
    if (a7)
    {
      LODWORD(v52) = v52 | 2;
      v34 = a17;
      v33 = a18;
      if (!a8)
        goto LABEL_82;
    }
    else
    {
      v34 = a17;
      v33 = a18;
      if (!a8)
      {
LABEL_82:
        if (a9)
          goto LABEL_83;
        goto LABEL_97;
      }
    }
    LODWORD(v52) = v52 | 4;
    if (a9)
    {
LABEL_83:
      LODWORD(v52) = v52 | 8;
      if (!a10)
        goto LABEL_84;
      goto LABEL_98;
    }
LABEL_97:
    if (!a10)
    {
LABEL_84:
      if (a11)
        goto LABEL_85;
      goto LABEL_99;
    }
LABEL_98:
    LODWORD(v52) = v52 | 0x10;
    if (a11)
    {
LABEL_85:
      LODWORD(v52) = v52 | 0x20;
      if (!a12)
        goto LABEL_86;
      goto LABEL_100;
    }
LABEL_99:
    if (!a12)
    {
LABEL_86:
      if (a13)
        goto LABEL_87;
      goto LABEL_101;
    }
LABEL_100:
    LODWORD(v52) = v52 | 0x40;
    if (a13)
    {
LABEL_87:
      LODWORD(v52) = v52 | 0x80;
      if (!a14)
        goto LABEL_88;
      goto LABEL_102;
    }
LABEL_101:
    if (!a14)
    {
LABEL_88:
      if (a15)
        goto LABEL_89;
      goto LABEL_103;
    }
LABEL_102:
    LODWORD(v52) = v52 | 0x400;
    if (a15)
    {
LABEL_89:
      LODWORD(v52) = v52 | 0x100;
      if (!a16)
        goto LABEL_90;
      goto LABEL_104;
    }
LABEL_103:
    if (!a16)
    {
LABEL_90:
      if (v34)
        goto LABEL_91;
      goto LABEL_105;
    }
LABEL_104:
    LODWORD(v52) = v52 | 0x10000;
    if (v34)
    {
LABEL_91:
      LODWORD(v52) = v52 | 0x20000;
      if (!v33)
        goto LABEL_92;
      goto LABEL_106;
    }
LABEL_105:
    if (!v33)
    {
LABEL_92:
      if (a19)
        goto LABEL_93;
      goto LABEL_107;
    }
LABEL_106:
    LODWORD(v52) = v52 | 0x200;
    if (a19)
    {
LABEL_93:
      LODWORD(v52) = v52 | 0x800;
      if (!a20)
        return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
      goto LABEL_108;
    }
LABEL_107:
    if (!a20)
      return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
LABEL_108:
    if (a21)
      HIDWORD(v52) = a21;
    return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
  v27 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v44 = 0;
  if (!__nwlog_fault(v27, &type, &v44))
    goto LABEL_122;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = gLogObj;
    v29 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
      v30 = "%{public}s called with null netagent_uuid";
LABEL_121:
      _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0xCu);
      goto LABEL_122;
    }
    goto LABEL_122;
  }
  if (v44)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = gLogObj;
    v29 = type;
    v36 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
        v30 = "%{public}s called with null netagent_uuid, no backtrace";
        goto LABEL_121;
      }
      goto LABEL_122;
    }
    if (!v36)
    {
LABEL_116:
      free(backtrace_string);
      goto LABEL_122;
    }
    goto LABEL_114;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v28 = gLogObj;
  v29 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_network_agent_ctl_setsockopt";
    v30 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
    goto LABEL_121;
  }
LABEL_122:
  if (v27)
    free(v27);
  return 0xFFFFFFFFLL;
}

uint64_t nw_network_agent_ctl_setsockopt_inner(int a1, int a2, const unsigned __int8 *a3, unsigned int a4, const unsigned __int8 *a5, unsigned int a6)
{
  uint64_t v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *v17;
  char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  uint64_t v21;
  int v22;
  NSObject *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  uint64_t result;
  char *v29;
  _BOOL4 v30;
  NSObject *v31;
  void *v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  _BYTE v38[10];
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v8 = a6 + a4;
  if (__CFADD__(a6, a4))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v36 = "nw_network_agent_ctl_setsockopt_inner";
    v37 = 1024;
    *(_DWORD *)v38 = a4;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = a6;
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446722;
          v36 = "nw_network_agent_ctl_setsockopt_inner";
          v37 = 1024;
          *(_DWORD *)v38 = a4;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = a6;
          v12 = "%{public}s Invalid payload values (%u, %u)";
LABEL_35:
          _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0x18u);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        v20 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446978;
            v36 = "nw_network_agent_ctl_setsockopt_inner";
            v37 = 1024;
            *(_DWORD *)v38 = a4;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = a6;
            v39 = 2082;
            v40 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s Invalid payload values (%u, %u), dumping backtrace:%{public}s", buf, 0x22u);
          }
          free(backtrace_string);
          goto LABEL_36;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446722;
          v36 = "nw_network_agent_ctl_setsockopt_inner";
          v37 = 1024;
          *(_DWORD *)v38 = a4;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = a6;
          v12 = "%{public}s Invalid payload values (%u, %u), no backtrace";
          goto LABEL_35;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446722;
          v36 = "nw_network_agent_ctl_setsockopt_inner";
          v37 = 1024;
          *(_DWORD *)v38 = a4;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = a6;
          v12 = "%{public}s Invalid payload values (%u, %u), backtrace limit exceeded";
          goto LABEL_35;
        }
      }
    }
LABEL_36:
    if (v9)
      free(v9);
    return 0xFFFFFFFFLL;
  }
  if (!(a6 + a4))
  {
    v18 = 0;
    goto LABEL_21;
  }
  v17 = (char *)malloc_type_malloc(a6 + a4, 0xF2B69DE5uLL);
  v18 = v17;
  if (v17)
  {
    if (a3)
      goto LABEL_10;
    goto LABEL_12;
  }
  v31 = __nwlog_obj();
  os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v36 = "strict_malloc";
  v37 = 2048;
  *(_QWORD *)v38 = v8;
  v32 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v32);
  if (!(_DWORD)result)
  {
    free(v32);
    v17 = 0;
    if (a3)
    {
LABEL_10:
      v17 = v18;
      if (a4)
      {
        memcpy(v18, a3, a4);
        v17 = &v18[a4];
      }
    }
LABEL_12:
    if (a5 && a6)
      memcpy(v17, a5, a6);
LABEL_21:
    v21 = setsockopt(a1, 2, a2, v18, v8);
    if ((v21 & 0x80000000) == 0)
    {
LABEL_22:
      if (v18)
        free(v18);
      return v21;
    }
    v22 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = gLogObj;
    if (v22 == 2)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "nw_network_agent_ctl_setsockopt_inner";
        v37 = 1024;
        *(_DWORD *)v38 = a2;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 2;
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s setsockopt for message type %u failed %{darwin.errno}d", buf, 0x18u);
      }
      goto LABEL_22;
    }
    *(_DWORD *)buf = 136446722;
    v36 = "nw_network_agent_ctl_setsockopt_inner";
    v37 = 1024;
    *(_DWORD *)v38 = a2;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v22;
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v24, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = gLogObj;
        v26 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_50;
        *(_DWORD *)buf = 136446722;
        v36 = "nw_network_agent_ctl_setsockopt_inner";
        v37 = 1024;
        *(_DWORD *)v38 = a2;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v22;
        v27 = "%{public}s setsockopt for message type %u failed %{darwin.errno}d";
        goto LABEL_49;
      }
      if (!v33)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
          goto LABEL_50;
        *(_DWORD *)buf = 136446722;
        v36 = "nw_network_agent_ctl_setsockopt_inner";
        v37 = 1024;
        *(_DWORD *)v38 = a2;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v22;
        v27 = "%{public}s setsockopt for message type %u failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_49;
      }
      v29 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = gLogObj;
      v26 = type;
      v30 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v29)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446978;
          v36 = "nw_network_agent_ctl_setsockopt_inner";
          v37 = 1024;
          *(_DWORD *)v38 = a2;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = v22;
          v39 = 2082;
          v40 = v29;
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s setsockopt for message type %u failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v29);
        goto LABEL_50;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446722;
        v36 = "nw_network_agent_ctl_setsockopt_inner";
        v37 = 1024;
        *(_DWORD *)v38 = a2;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v22;
        v27 = "%{public}s setsockopt for message type %u failed %{darwin.errno}d, no backtrace";
LABEL_49:
        _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0x18u);
      }
    }
LABEL_50:
    if (v24)
      free(v24);
    goto LABEL_22;
  }
  __break(1u);
  return result;
}

uint64_t nw_network_agent_ctl_simple_setsockopt(int a1, int a2, const unsigned __int8 *a3, unsigned int a4)
{
  return nw_network_agent_ctl_setsockopt_inner(a1, a2, a3, a4, 0, 0);
}

uint64_t nw_network_agent_ctl_send_assign_message(int a1, unsigned __int8 *a2, unsigned int a3)
{
  return nw_network_agent_ctl_setsockopt_inner(a1, 11, a2, a3, 0, 0);
}

uint64_t nw_network_agent_ctl_send_assign_group_message(int a1, unsigned __int8 *a2, unsigned int a3)
{
  return nw_network_agent_ctl_setsockopt_inner(a1, 20, a2, a3, 0, 0);
}

uint64_t nw_network_agent_open_control_socket()
{
  NSObject *v0;
  uint64_t kernel_socket_internal;
  NSObject *v2;
  uint64_t v3;
  int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  int v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  int v14;
  char *v15;
  _BOOL4 v16;
  char *backtrace_string;
  _BOOL4 v18;
  NSObject *v19;
  int v20;
  int v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  char *v26;
  _BOOL4 v27;
  int v28;
  char *v30;
  _BOOL4 v31;
  char *v32;
  _BOOL4 v33;
  char v34;
  os_log_type_t type;
  sockaddr v36[2];
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  _QWORD v42[3];
  _OWORD v43[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v48 = 0;
  v46 = 0u;
  v47 = 0u;
  v45 = 0u;
  v44 = 0u;
  memset(v43, 0, sizeof(v43));
  memset(v36, 0, sizeof(v36));
  if (getuid())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v0 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v38 = "nw_network_agent_open_control_socket";
      _os_log_impl(&dword_182FBE000, v0, OS_LOG_TYPE_DEFAULT, "%{public}s Requesting netagent socket from helper", buf, 0xCu);
    }
    kernel_socket_internal = networkd_privileged_get_kernel_socket_internal(0xCuLL);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s Received netagent socket %d from helper", buf, 0x12u);
    }
    return kernel_socket_internal;
  }
  v3 = socket(32, 2, 2);
  if ((v3 & 0x80000000) != 0)
  {
    v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = v9;
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v10, &type, &v34))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446466;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = v9;
      v13 = "%{public}s cannot create netagent kernel control socket %{darwin.errno}d";
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v18 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446722;
          v38 = "nw_network_agent_open_control_socket";
          v39 = 1024;
          v40 = v9;
          v41 = 2082;
          v42[0] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s cannot create netagent kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_54;
      }
      if (!v18)
      {
LABEL_54:
        if (v10)
          free(v10);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)buf = 136446466;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = v9;
      v13 = "%{public}s cannot create netagent kernel control socket %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446466;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = v9;
      v13 = "%{public}s cannot create netagent kernel control socket %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0x12u);
    goto LABEL_54;
  }
  kernel_socket_internal = v3;
  LODWORD(v43[0]) = 0;
  *((_QWORD *)&v43[1] + 1) = 0;
  v48 = 0;
  v46 = 0u;
  v47 = 0u;
  v45 = 0u;
  v44 = 0u;
  strcpy((char *)v43 + 4, "com.apple.net.netagent");
  if (ioctl(v3, 0xC0644E03uLL, v43))
  {
    v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = kernel_socket_internal;
    v41 = 1024;
    LODWORD(v42[0]) = v4;
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v5, &type, &v34))
      goto LABEL_65;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446722;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      v41 = 1024;
      LODWORD(v42[0]) = v4;
      v8 = "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d";
      goto LABEL_64;
    }
    if (!v34)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446722;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      v41 = 1024;
      LODWORD(v42[0]) = v4;
      v8 = "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_64;
    }
    v15 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v15)
    {
      if (!v16)
        goto LABEL_65;
      *(_DWORD *)buf = 136446722;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      v41 = 1024;
      LODWORD(v42[0]) = v4;
      v8 = "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d, no backtrace";
      goto LABEL_64;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446978;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      v41 = 1024;
      LODWORD(v42[0]) = v4;
      WORD2(v42[0]) = 2082;
      *(_QWORD *)((char *)v42 + 6) = v15;
      _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
    }
    free(v15);
    goto LABEL_65;
  }
  *(_DWORD *)&v36[0].sa_len = 139296;
  *(_DWORD *)&v36[0].sa_data[2] = v43[0];
  memset(&v36[0].sa_data[6], 0, 24);
  if (connect(kernel_socket_internal, v36, 0x20u))
  {
    v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = kernel_socket_internal;
    v41 = 1024;
    LODWORD(v42[0]) = v14;
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v5, &type, &v34))
      goto LABEL_65;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446722;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      v41 = 1024;
      LODWORD(v42[0]) = v14;
      v8 = "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d";
      goto LABEL_64;
    }
    if (!v34)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446722;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      v41 = 1024;
      LODWORD(v42[0]) = v14;
      v8 = "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_64;
    }
    v26 = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v27 = os_log_type_enabled(v6, type);
    if (v26)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446978;
        v38 = "nw_network_agent_open_control_socket";
        v39 = 1024;
        v40 = kernel_socket_internal;
        v41 = 1024;
        LODWORD(v42[0]) = v14;
        WORD2(v42[0]) = 2082;
        *(_QWORD *)((char *)v42 + 6) = v26;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
      }
      free(v26);
      if (!v5)
        goto LABEL_67;
      goto LABEL_66;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446722;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = kernel_socket_internal;
      v41 = 1024;
      LODWORD(v42[0]) = v14;
      v8 = "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d, no backtrace";
LABEL_64:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0x18u);
    }
LABEL_65:
    if (!v5)
    {
LABEL_67:
      close(kernel_socket_internal);
      return 0xFFFFFFFFLL;
    }
LABEL_66:
    free(v5);
    goto LABEL_67;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v19 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = kernel_socket_internal;
    _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully connected netagent socket %d", buf, 0x12u);
  }
  v20 = fcntl(kernel_socket_internal, 3, 0);
  if ((v20 & 0x80000000) == 0)
  {
    if ((fcntl(kernel_socket_internal, 4, v20 | 4u) & 0x80000000) == 0)
      return kernel_socket_internal;
    v21 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = v21;
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v22, &type, &v34))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_90;
      *(_DWORD *)buf = 136446466;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = v21;
      v25 = "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d";
    }
    else if (v34)
    {
      v32 = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v33 = os_log_type_enabled(v23, type);
      if (v32)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446722;
          v38 = "nw_network_agent_open_control_socket";
          v39 = 1024;
          v40 = v21;
          v41 = 2082;
          v42[0] = v32;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v32);
LABEL_90:
        if (!v22)
          return kernel_socket_internal;
LABEL_91:
        free(v22);
        return kernel_socket_internal;
      }
      if (!v33)
        goto LABEL_90;
      *(_DWORD *)buf = 136446466;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = v21;
      v25 = "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d, no backtrace";
    }
    else
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_90;
      *(_DWORD *)buf = 136446466;
      v38 = "nw_network_agent_open_control_socket";
      v39 = 1024;
      v40 = v21;
      v25 = "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_89:
    _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0x12u);
    goto LABEL_90;
  }
  v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  __nwlog_obj();
  *(_DWORD *)buf = 136446466;
  v38 = "nw_network_agent_open_control_socket";
  v39 = 1024;
  v40 = v28;
  v22 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (!__nwlog_fault(v22, &type, &v34))
    goto LABEL_90;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_90;
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = v28;
    v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d";
    goto LABEL_89;
  }
  if (!v34)
  {
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_90;
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = v28;
    v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, backtrace limit exceeded";
    goto LABEL_89;
  }
  v30 = (char *)__nw_create_backtrace_string();
  v23 = __nwlog_obj();
  v24 = type;
  v31 = os_log_type_enabled(v23, type);
  if (!v30)
  {
    if (!v31)
      goto LABEL_90;
    *(_DWORD *)buf = 136446466;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = v28;
    v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, no backtrace";
    goto LABEL_89;
  }
  if (v31)
  {
    *(_DWORD *)buf = 136446722;
    v38 = "nw_network_agent_open_control_socket";
    v39 = 1024;
    v40 = v28;
    v41 = 2082;
    v42[0] = v30;
    _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
  }
  free(v30);
  if (v22)
    goto LABEL_91;
  return kernel_socket_internal;
}

uint64_t nw_network_agent_add_to_interface(uint64_t a1, unsigned __int8 *uu)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  BOOL v8;
  uint64_t v9;
  NSObject *v10;
  char *backtrace_string;
  _BOOL4 v12;
  const char *v13;
  int v14;
  int v15;
  NSObject *v16;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  NSObject *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  char *v27;
  _BOOL4 v28;
  char *v29;
  _BOOL4 v30;
  _BOOL4 v31;
  char v32;
  os_log_type_t v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  _BYTE v37[20];
  __int16 v38;
  char *v39;
  os_log_type_t type[16];
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_network_agent_add_to_interface_internal";
    v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v33 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v4, type, &v33))
      goto LABEL_43;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type[0];
      if (!os_log_type_enabled(v5, type[0]))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_network_agent_add_to_interface_internal";
      v7 = "%{public}s called with null if_name";
      goto LABEL_42;
    }
    if (v33 == OS_LOG_TYPE_DEFAULT)
    {
      v5 = __nwlog_obj();
      v6 = type[0];
      if (!os_log_type_enabled(v5, type[0]))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_network_agent_add_to_interface_internal";
      v7 = "%{public}s called with null if_name, backtrace limit exceeded";
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type[0];
    v31 = os_log_type_enabled(v5, type[0]);
    if (!backtrace_string)
    {
      if (!v31)
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_network_agent_add_to_interface_internal";
      v7 = "%{public}s called with null if_name, no backtrace";
      goto LABEL_42;
    }
    if (!v31)
      goto LABEL_17;
    *(_DWORD *)buf = 136446466;
    v35 = "nw_network_agent_add_to_interface_internal";
    v36 = 2082;
    *(_QWORD *)v37 = backtrace_string;
    v13 = "%{public}s called with null if_name, dumping backtrace:%{public}s";
    goto LABEL_16;
  }
  if (uuid_is_null(uu))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_network_agent_add_to_interface_internal";
    v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v33 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v4, type, &v33))
      goto LABEL_43;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_network_agent_add_to_interface_internal";
        v7 = "%{public}s called with null netagent_uuid";
LABEL_42:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
        goto LABEL_43;
      }
      goto LABEL_43;
    }
    if (v33 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_network_agent_add_to_interface_internal";
        v7 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
        goto LABEL_42;
      }
LABEL_43:
      if (v4)
        free(v4);
      return 22;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type[0];
    v12 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_network_agent_add_to_interface_internal";
        v7 = "%{public}s called with null netagent_uuid, no backtrace";
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    if (!v12)
    {
LABEL_17:
      free(backtrace_string);
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446466;
    v35 = "nw_network_agent_add_to_interface_internal";
    v36 = 2082;
    *(_QWORD *)v37 = backtrace_string;
    v13 = "%{public}s called with null netagent_uuid, dumping backtrace:%{public}s";
LABEL_16:
    _os_log_impl(&dword_182FBE000, v5, v6, v13, buf, 0x16u);
    goto LABEL_17;
  }
  if (getuid())
  {
    v8 = networkd_privileged_set_agent_on_interface_internal((const char *)a1, uu, 0, 0);
    v9 = 0;
    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "nw_network_agent_add_to_interface_internal";
        v36 = 2082;
        *(_QWORD *)v37 = a1;
        *(_WORD *)&v37[8] = 2082;
        *(_QWORD *)&v37[10] = "";
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s networkd_privileged_set_agent_on_interface_internal(%{public}s add%{public}s) failed", buf, 0x20u);
      }
      return 0xFFFFFFFFLL;
    }
    return v9;
  }
  v14 = socket(2, 2, 0);
  if ((v14 & 0x80000000) == 0)
  {
    v15 = v14;
    memset(&type[1], 0, 15);
    type[0] = *(os_log_type_t *)a1;
    if (type[0])
    {
      type[1] = *(os_log_type_t *)(a1 + 1);
      if (type[1])
      {
        type[2] = *(os_log_type_t *)(a1 + 2);
        if (type[2])
        {
          type[3] = *(os_log_type_t *)(a1 + 3);
          if (type[3])
          {
            type[4] = *(os_log_type_t *)(a1 + 4);
            if (type[4])
            {
              type[5] = *(os_log_type_t *)(a1 + 5);
              if (type[5])
              {
                type[6] = *(os_log_type_t *)(a1 + 6);
                if (type[6])
                {
                  type[7] = *(os_log_type_t *)(a1 + 7);
                  if (type[7])
                  {
                    type[8] = *(os_log_type_t *)(a1 + 8);
                    if (type[8])
                    {
                      type[9] = *(os_log_type_t *)(a1 + 9);
                      if (type[9])
                      {
                        type[10] = *(os_log_type_t *)(a1 + 10);
                        if (type[10])
                        {
                          type[11] = *(os_log_type_t *)(a1 + 11);
                          if (type[11])
                          {
                            type[12] = *(os_log_type_t *)(a1 + 12);
                            if (type[12])
                            {
                              type[13] = *(os_log_type_t *)(a1 + 13);
                              if (type[13])
                                type[14] = *(os_log_type_t *)(a1 + 14);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v41 = *(_OWORD *)uu;
    if (!ioctl(v14, 0xC02069A5uLL, type))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v9 = 0;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_network_agent_add_to_interface_internal";
        v36 = 2082;
        *(_QWORD *)v37 = a1;
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully added agent to \"%{public}s\"", buf, 0x16u);
        v9 = 0;
      }
      goto LABEL_81;
    }
    v9 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    if ((_DWORD)v9 == 6)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v35 = "nw_network_agent_add_to_interface_internal";
        v36 = 1024;
        *(_DWORD *)v37 = v15;
        *(_WORD *)&v37[4] = 2082;
        *(_QWORD *)&v37[6] = a1;
        *(_WORD *)&v37[14] = 1024;
        *(_DWORD *)&v37[16] = 6;
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d", buf, 0x22u);
      }
LABEL_81:
      close(v15);
      return v9;
    }
    *(_DWORD *)buf = 136446978;
    v35 = "nw_network_agent_add_to_interface_internal";
    v36 = 1024;
    *(_DWORD *)v37 = v15;
    *(_WORD *)&v37[4] = 2082;
    *(_QWORD *)&v37[6] = a1;
    *(_WORD *)&v37[14] = 1024;
    *(_DWORD *)&v37[16] = v9;
    v23 = (char *)_os_log_send_and_compose_impl();
    v33 = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v23, &v33, &v32))
    {
      if (v33 == OS_LOG_TYPE_FAULT)
      {
        v24 = __nwlog_obj();
        v25 = v33;
        if (!os_log_type_enabled(v24, v33))
          goto LABEL_79;
        *(_DWORD *)buf = 136446978;
        v35 = "nw_network_agent_add_to_interface_internal";
        v36 = 1024;
        *(_DWORD *)v37 = v15;
        *(_WORD *)&v37[4] = 2082;
        *(_QWORD *)&v37[6] = a1;
        *(_WORD *)&v37[14] = 1024;
        *(_DWORD *)&v37[16] = v9;
        v26 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d";
        goto LABEL_78;
      }
      if (!v32)
      {
        v24 = __nwlog_obj();
        v25 = v33;
        if (!os_log_type_enabled(v24, v33))
          goto LABEL_79;
        *(_DWORD *)buf = 136446978;
        v35 = "nw_network_agent_add_to_interface_internal";
        v36 = 1024;
        *(_DWORD *)v37 = v15;
        *(_WORD *)&v37[4] = 2082;
        *(_QWORD *)&v37[6] = a1;
        *(_WORD *)&v37[14] = 1024;
        *(_DWORD *)&v37[16] = v9;
        v26 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_78;
      }
      v29 = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = v33;
      v30 = os_log_type_enabled(v24, v33);
      if (v29)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136447234;
          v35 = "nw_network_agent_add_to_interface_internal";
          v36 = 1024;
          *(_DWORD *)v37 = v15;
          *(_WORD *)&v37[4] = 2082;
          *(_QWORD *)&v37[6] = a1;
          *(_WORD *)&v37[14] = 1024;
          *(_DWORD *)&v37[16] = v9;
          v38 = 2082;
          v39 = v29;
          _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
        }
        free(v29);
        goto LABEL_79;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446978;
        v35 = "nw_network_agent_add_to_interface_internal";
        v36 = 1024;
        *(_DWORD *)v37 = v15;
        *(_WORD *)&v37[4] = 2082;
        *(_QWORD *)&v37[6] = a1;
        *(_WORD *)&v37[14] = 1024;
        *(_DWORD *)&v37[16] = v9;
        v26 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d, no backtrace";
LABEL_78:
        _os_log_impl(&dword_182FBE000, v24, v25, v26, buf, 0x22u);
      }
    }
LABEL_79:
    if (v23)
      free(v23);
    goto LABEL_81;
  }
  v9 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v35 = "nw_network_agent_add_to_interface_internal";
  v36 = 1024;
  *(_DWORD *)v37 = v9;
  v18 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v33 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v18, type, &v33))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      v20 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_72;
      *(_DWORD *)buf = 136446466;
      v35 = "nw_network_agent_add_to_interface_internal";
      v36 = 1024;
      *(_DWORD *)v37 = v9;
      v21 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
      goto LABEL_71;
    }
    if (v33 == OS_LOG_TYPE_DEFAULT)
    {
      v19 = __nwlog_obj();
      v20 = type[0];
      if (!os_log_type_enabled(v19, type[0]))
        goto LABEL_72;
      *(_DWORD *)buf = 136446466;
      v35 = "nw_network_agent_add_to_interface_internal";
      v36 = 1024;
      *(_DWORD *)v37 = v9;
      v21 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_71;
    }
    v27 = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type[0];
    v28 = os_log_type_enabled(v19, type[0]);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446722;
        v35 = "nw_network_agent_add_to_interface_internal";
        v36 = 1024;
        *(_DWORD *)v37 = v9;
        *(_WORD *)&v37[4] = 2082;
        *(_QWORD *)&v37[6] = v27;
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v27);
      goto LABEL_72;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_network_agent_add_to_interface_internal";
      v36 = 1024;
      *(_DWORD *)v37 = v9;
      v21 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
LABEL_71:
      _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0x12u);
    }
  }
LABEL_72:
  if (v18)
    free(v18);
  return v9;
}

uint64_t nw_network_agent_remove_from_interface(uint64_t a1, unsigned __int8 *uu)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  uint64_t v8;
  NSObject *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint32_t v20;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  uint64_t v26;
  char *v27;
  _BOOL4 v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  char v36;
  os_log_type_t v37;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  _BYTE v41[14];
  __int16 v42;
  int v43;
  __int16 v44;
  char *v45;
  os_log_type_t type[16];
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_network_agent_remove_from_interface";
    v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v37 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v4, type, &v37))
      goto LABEL_44;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type[0];
      if (!os_log_type_enabled(v5, type[0]))
        goto LABEL_44;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_network_agent_remove_from_interface";
      v7 = "%{public}s called with null if_name";
      goto LABEL_43;
    }
    if (v37 == OS_LOG_TYPE_DEFAULT)
    {
      v5 = __nwlog_obj();
      v6 = type[0];
      if (!os_log_type_enabled(v5, type[0]))
        goto LABEL_44;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_network_agent_remove_from_interface";
      v7 = "%{public}s called with null if_name, backtrace limit exceeded";
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type[0];
    v35 = os_log_type_enabled(v5, type[0]);
    if (!backtrace_string)
    {
      if (!v35)
        goto LABEL_44;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_network_agent_remove_from_interface";
      v7 = "%{public}s called with null if_name, no backtrace";
      goto LABEL_43;
    }
    if (!v35)
      goto LABEL_17;
    *(_DWORD *)buf = 136446466;
    v39 = "nw_network_agent_remove_from_interface";
    v40 = 2082;
    *(_QWORD *)v41 = backtrace_string;
    v12 = "%{public}s called with null if_name, dumping backtrace:%{public}s";
    goto LABEL_16;
  }
  if (uuid_is_null(uu))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_network_agent_remove_from_interface";
    v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v37 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v4, type, &v37))
      goto LABEL_44;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_network_agent_remove_from_interface";
        v7 = "%{public}s called with null netagent_uuid";
LABEL_43:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
        goto LABEL_44;
      }
      goto LABEL_44;
    }
    if (v37 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_network_agent_remove_from_interface";
        v7 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
        goto LABEL_43;
      }
LABEL_44:
      if (v4)
        free(v4);
      return 22;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type[0];
    v11 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_network_agent_remove_from_interface";
        v7 = "%{public}s called with null netagent_uuid, no backtrace";
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    if (!v11)
    {
LABEL_17:
      free(backtrace_string);
      goto LABEL_44;
    }
    *(_DWORD *)buf = 136446466;
    v39 = "nw_network_agent_remove_from_interface";
    v40 = 2082;
    *(_QWORD *)v41 = backtrace_string;
    v12 = "%{public}s called with null netagent_uuid, dumping backtrace:%{public}s";
LABEL_16:
    _os_log_impl(&dword_182FBE000, v5, v6, v12, buf, 0x16u);
    goto LABEL_17;
  }
  if (getuid())
  {
    v8 = 0;
    if (!networkd_privileged_set_agent_on_interface_internal((const char *)a1, uu, 1, 0))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v39 = "nw_network_agent_remove_from_interface";
        v40 = 2082;
        *(_QWORD *)v41 = a1;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s networkd_privileged_set_agent_on_interface(%{public}s, remove) failed", buf, 0x16u);
      }
      return 0xFFFFFFFFLL;
    }
    return v8;
  }
  v13 = socket(2, 2, 0);
  if ((v13 & 0x80000000) == 0)
  {
    v14 = v13;
    memset(&type[1], 0, 15);
    type[0] = *(os_log_type_t *)a1;
    if (type[0])
    {
      type[1] = *(os_log_type_t *)(a1 + 1);
      if (type[1])
      {
        type[2] = *(os_log_type_t *)(a1 + 2);
        if (type[2])
        {
          type[3] = *(os_log_type_t *)(a1 + 3);
          if (type[3])
          {
            type[4] = *(os_log_type_t *)(a1 + 4);
            if (type[4])
            {
              type[5] = *(os_log_type_t *)(a1 + 5);
              if (type[5])
              {
                type[6] = *(os_log_type_t *)(a1 + 6);
                if (type[6])
                {
                  type[7] = *(os_log_type_t *)(a1 + 7);
                  if (type[7])
                  {
                    type[8] = *(os_log_type_t *)(a1 + 8);
                    if (type[8])
                    {
                      type[9] = *(os_log_type_t *)(a1 + 9);
                      if (type[9])
                      {
                        type[10] = *(os_log_type_t *)(a1 + 10);
                        if (type[10])
                        {
                          type[11] = *(os_log_type_t *)(a1 + 11);
                          if (type[11])
                          {
                            type[12] = *(os_log_type_t *)(a1 + 12);
                            if (type[12])
                            {
                              type[13] = *(os_log_type_t *)(a1 + 13);
                              if (type[13])
                                type[14] = *(os_log_type_t *)(a1 + 14);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v47 = *(_OWORD *)uu;
    if (!ioctl(v13, 0xC02069A6uLL, type))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v39 = "nw_network_agent_remove_from_interface";
        v40 = 2082;
        *(_QWORD *)v41 = a1;
        v17 = "%{public}s Successfully removed agent from \"%{public}s\"";
        v18 = v26;
        v19 = OS_LOG_TYPE_DEFAULT;
        v20 = 22;
        goto LABEL_54;
      }
LABEL_83:
      close(v14);
      return 0;
    }
    v15 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v15 == 6 || v15 == 102)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v39 = "nw_network_agent_remove_from_interface";
        v40 = 1024;
        *(_DWORD *)v41 = v14;
        *(_WORD *)&v41[4] = 2082;
        *(_QWORD *)&v41[6] = a1;
        v42 = 1024;
        v43 = v15;
        v17 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d";
        v18 = v16;
        v19 = OS_LOG_TYPE_ERROR;
        v20 = 34;
LABEL_54:
        _os_log_impl(&dword_182FBE000, v18, v19, v17, buf, v20);
        goto LABEL_83;
      }
      goto LABEL_83;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    v39 = "nw_network_agent_remove_from_interface";
    v40 = 1024;
    *(_DWORD *)v41 = v14;
    *(_WORD *)&v41[4] = 2082;
    *(_QWORD *)&v41[6] = a1;
    v42 = 1024;
    v43 = v15;
    v29 = (char *)_os_log_send_and_compose_impl();
    v37 = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if ((__nwlog_fault(v29, &v37, &v36) & 1) != 0)
    {
      if (v37 == OS_LOG_TYPE_FAULT)
      {
        v30 = __nwlog_obj();
        v31 = v37;
        if (!os_log_type_enabled(v30, v37))
          goto LABEL_81;
        *(_DWORD *)buf = 136446978;
        v39 = "nw_network_agent_remove_from_interface";
        v40 = 1024;
        *(_DWORD *)v41 = v14;
        *(_WORD *)&v41[4] = 2082;
        *(_QWORD *)&v41[6] = a1;
        v42 = 1024;
        v43 = v15;
        v32 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d";
        goto LABEL_80;
      }
      if (!v36)
      {
        v30 = __nwlog_obj();
        v31 = v37;
        if (!os_log_type_enabled(v30, v37))
          goto LABEL_81;
        *(_DWORD *)buf = 136446978;
        v39 = "nw_network_agent_remove_from_interface";
        v40 = 1024;
        *(_DWORD *)v41 = v14;
        *(_WORD *)&v41[4] = 2082;
        *(_QWORD *)&v41[6] = a1;
        v42 = 1024;
        v43 = v15;
        v32 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_80;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = v37;
      v34 = os_log_type_enabled(v30, v37);
      if (v33)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136447234;
          v39 = "nw_network_agent_remove_from_interface";
          v40 = 1024;
          *(_DWORD *)v41 = v14;
          *(_WORD *)&v41[4] = 2082;
          *(_QWORD *)&v41[6] = a1;
          v42 = 1024;
          v43 = v15;
          v44 = 2082;
          v45 = v33;
          _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
        }
        free(v33);
        goto LABEL_81;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446978;
        v39 = "nw_network_agent_remove_from_interface";
        v40 = 1024;
        *(_DWORD *)v41 = v14;
        *(_WORD *)&v41[4] = 2082;
        *(_QWORD *)&v41[6] = a1;
        v42 = 1024;
        v43 = v15;
        v32 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d, no backtrace";
LABEL_80:
        _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0x22u);
      }
    }
LABEL_81:
    if (v29)
      free(v29);
    goto LABEL_83;
  }
  v8 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v39 = "nw_network_agent_remove_from_interface";
  v40 = 1024;
  *(_DWORD *)v41 = v8;
  v22 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v37 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v22, type, &v37))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = gLogObj;
      v24 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_74;
      *(_DWORD *)buf = 136446466;
      v39 = "nw_network_agent_remove_from_interface";
      v40 = 1024;
      *(_DWORD *)v41 = v8;
      v25 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
      goto LABEL_73;
    }
    if (v37 == OS_LOG_TYPE_DEFAULT)
    {
      v23 = __nwlog_obj();
      v24 = type[0];
      if (!os_log_type_enabled(v23, type[0]))
        goto LABEL_74;
      *(_DWORD *)buf = 136446466;
      v39 = "nw_network_agent_remove_from_interface";
      v40 = 1024;
      *(_DWORD *)v41 = v8;
      v25 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_73;
    }
    v27 = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type[0];
    v28 = os_log_type_enabled(v23, type[0]);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446722;
        v39 = "nw_network_agent_remove_from_interface";
        v40 = 1024;
        *(_DWORD *)v41 = v8;
        *(_WORD *)&v41[4] = 2082;
        *(_QWORD *)&v41[6] = v27;
        _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v27);
      goto LABEL_74;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v39 = "nw_network_agent_remove_from_interface";
      v40 = 1024;
      *(_DWORD *)v41 = v8;
      v25 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
LABEL_73:
      _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0x12u);
    }
  }
LABEL_74:
  if (v22)
    free(v22);
  return v8;
}

unsigned int *nw_network_agent_get_agent_from_dictionary(unsigned int *result)
{
  unsigned int *data;
  size_t length;

  length = 0;
  if (result)
  {
    data = (unsigned int *)xpc_dictionary_get_data(result, "data", &length);
    result = 0;
    if (data)
    {
      if (length >= 0xD8)
      {
        if (length == data[53] + 216)
          return data;
        else
          return 0;
      }
    }
  }
  return result;
}

unsigned int *nw_network_agent_truncate_agent_data_in_dictionary(void *a1)
{
  unsigned int *data;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *result;
  size_t v15;
  size_t v16;
  size_t length;
  _OWORD bytes[13];
  unsigned int v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  data = (unsigned int *)xpc_dictionary_get_data(a1, "data", &v16);
  if (data && v16 >= 0xD8 && v16 == data[53] + 216)
  {
    v3 = *((_OWORD *)data + 1);
    bytes[0] = *(_OWORD *)data;
    bytes[1] = v3;
    v4 = *((_OWORD *)data + 2);
    v5 = *((_OWORD *)data + 3);
    v6 = *((_OWORD *)data + 5);
    bytes[4] = *((_OWORD *)data + 4);
    bytes[5] = v6;
    bytes[2] = v4;
    bytes[3] = v5;
    v7 = *((_OWORD *)data + 6);
    v8 = *((_OWORD *)data + 7);
    v9 = *((_OWORD *)data + 9);
    bytes[8] = *((_OWORD *)data + 8);
    bytes[9] = v9;
    bytes[6] = v7;
    bytes[7] = v8;
    v10 = *((_OWORD *)data + 10);
    v11 = *((_OWORD *)data + 12);
    v12 = data[52];
    bytes[11] = *((_OWORD *)data + 11);
    bytes[12] = v11;
    bytes[10] = v10;
    v19 = v12;
    v20 = 0;
    xpc_dictionary_set_data(a1, "data", bytes, 0xD8uLL);
    length = 0;
    v13 = (unsigned int *)xpc_dictionary_get_data(a1, "data", &length);
    result = 0;
    if (!v13)
      return result;
    v15 = length;
    if (length < 0xD8)
      return result;
LABEL_9:
    if (v15 == v13[53] + 216)
      return v13;
    else
      return 0;
  }
  *(_QWORD *)&bytes[0] = 0;
  v13 = (unsigned int *)xpc_dictionary_get_data(a1, "data", (size_t *)bytes);
  result = 0;
  if (v13)
  {
    v15 = *(_QWORD *)&bytes[0];
    if (*(_QWORD *)&bytes[0] >= 0xD8uLL)
      goto LABEL_9;
  }
  return result;
}

BOOL nw_network_agent_copy_dictionary_for_uuid(const unsigned __int8 *a1)
{
  int v2;
  int v3;
  int v4;
  NSObject *v5;
  int v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  size_t v11;
  _OWORD *v12;
  size_t v13;
  int v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  char *v21;
  _BOOL4 v22;
  xpc_object_t v23;
  _BOOL8 result;
  NSObject *v25;
  void *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  char v37;
  os_log_type_t type;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  int buf;
  const char *v54;
  __int16 v55;
  _BYTE v56[18];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  if (!a1 || uuid_is_null(a1))
    return 0;
  v2 = socket(2, 2, 0);
  if (v2 < 0)
  {
    v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    buf = 136446466;
    v54 = "nw_network_agent_copy_struct";
    v55 = 1024;
    *(_DWORD *)v56 = v6;
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v7, &type, &v37))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_33;
      buf = 136446466;
      v54 = "nw_network_agent_copy_struct";
      v55 = 1024;
      *(_DWORD *)v56 = v6;
      v10 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
    }
    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      v20 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v20)
        {
          buf = 136446722;
          v54 = "nw_network_agent_copy_struct";
          v55 = 1024;
          *(_DWORD *)v56 = v6;
          *(_WORD *)&v56[4] = 2082;
          *(_QWORD *)&v56[6] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_33;
      }
      if (!v20)
      {
LABEL_33:
        if (v7)
          free(v7);
        return 0;
      }
      buf = 136446466;
      v54 = "nw_network_agent_copy_struct";
      v55 = 1024;
      *(_DWORD *)v56 = v6;
      v10 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_33;
      buf = 136446466;
      v54 = "nw_network_agent_copy_struct";
      v55 = 1024;
      *(_DWORD *)v56 = v6;
      v10 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v8, v9, v10, (uint8_t *)&buf, 0x12u);
    goto LABEL_33;
  }
  v3 = v2;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = *(_OWORD *)a1;
  v40 = 0u;
  if (ioctl(v2, 0xC0E069A8uLL, &v39))
  {
    v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v54 = "nw_network_agent_copy_struct";
      v55 = 1024;
      *(_DWORD *)v56 = v4;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s SIOCGIFAGENTDATA failed %{darwin.errno}d", (uint8_t *)&buf, 0x12u);
    }
LABEL_46:
    close(v3);
    return 0;
  }
  v11 = DWORD1(v52) + 216;
  v12 = malloc_type_calloc(1uLL, v11, 0xEAFB8F1AuLL);
  if (v12)
  {
    v13 = DWORD1(v52);
    if (!DWORD1(v52))
      goto LABEL_51;
LABEL_13:
    *((_QWORD *)&v52 + 1) = nw_calloc_type<unsigned char>(v13);
    if (ioctl(v3, 0xC0E069A8uLL, &v39))
    {
      v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      buf = 136446466;
      v54 = "nw_network_agent_copy_struct";
      v55 = 1024;
      *(_DWORD *)v56 = v14;
      v15 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (__nwlog_fault(v15, &type, &v37))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (os_log_type_enabled(v16, type))
          {
            buf = 136446466;
            v54 = "nw_network_agent_copy_struct";
            v55 = 1024;
            *(_DWORD *)v56 = v14;
            v18 = "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d";
LABEL_39:
            _os_log_impl(&dword_182FBE000, v16, v17, v18, (uint8_t *)&buf, 0x12u);
          }
        }
        else if (v37)
        {
          v21 = (char *)__nw_create_backtrace_string();
          v16 = __nwlog_obj();
          v17 = type;
          v22 = os_log_type_enabled(v16, type);
          if (v21)
          {
            if (v22)
            {
              buf = 136446722;
              v54 = "nw_network_agent_copy_struct";
              v55 = 1024;
              *(_DWORD *)v56 = v14;
              *(_WORD *)&v56[4] = 2082;
              *(_QWORD *)&v56[6] = v21;
              _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x1Cu);
            }
            free(v21);
            goto LABEL_40;
          }
          if (v22)
          {
            buf = 136446466;
            v54 = "nw_network_agent_copy_struct";
            v55 = 1024;
            *(_DWORD *)v56 = v14;
            v18 = "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d, no backtrace";
            goto LABEL_39;
          }
        }
        else
        {
          v16 = __nwlog_obj();
          v17 = type;
          if (os_log_type_enabled(v16, type))
          {
            buf = 136446466;
            v54 = "nw_network_agent_copy_struct";
            v55 = 1024;
            *(_DWORD *)v56 = v14;
            v18 = "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_39;
          }
        }
      }
LABEL_40:
      if (v15)
        free(v15);
      if (v12)
        free(v12);
      if (*((_QWORD *)&v52 + 1))
      {
        free(*((void **)&v52 + 1));
        *((_QWORD *)&v52 + 1) = 0;
      }
      goto LABEL_46;
    }
LABEL_51:
    v27 = v40;
    *v12 = v39;
    v12[1] = v27;
    v28 = v41;
    v29 = v42;
    v30 = v44;
    v12[4] = v43;
    v12[5] = v30;
    v12[2] = v28;
    v12[3] = v29;
    v31 = v45;
    v32 = v46;
    v33 = v48;
    v12[8] = v47;
    v12[9] = v33;
    v12[6] = v31;
    v12[7] = v32;
    v34 = v49;
    v35 = v50;
    v36 = v51;
    *((_QWORD *)v12 + 26) = v52;
    v12[11] = v35;
    v12[12] = v36;
    v12[10] = v34;
    if (*((_QWORD *)&v52 + 1))
    {
      memcpy((char *)v12 + 216, *((const void **)&v52 + 1), DWORD1(v52));
      if (*((_QWORD *)&v52 + 1))
      {
        free(*((void **)&v52 + 1));
        *((_QWORD *)&v52 + 1) = 0;
      }
    }
    close(v3);
    v23 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_data(v23, "data", v12, *((unsigned int *)v12 + 53) + 216);
    free(v12);
    return (BOOL)v23;
  }
  v25 = __nwlog_obj();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  buf = 136446722;
  v54 = "strict_calloc";
  v55 = 2048;
  *(_QWORD *)v56 = 1;
  *(_WORD *)&v56[8] = 2048;
  *(_QWORD *)&v56[10] = v11;
  v26 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    v13 = DWORD1(v52);
    if (!DWORD1(v52))
      goto LABEL_51;
    goto LABEL_13;
  }
  __break(1u);
  return result;
}

uint64_t nw_network_agent_set_use_count(int a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v12;
  os_log_type_t type;
  uint64_t v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v14 = a2;
  v3 = setsockopt(a1, 2, 16, &v14, 8u);
  if ((v3 & 0x80000000) == 0)
    return v3;
  v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446978;
  v16 = "nw_network_agent_set_use_count";
  v17 = 1024;
  v18 = a1;
  v19 = 2048;
  v20 = v14;
  v21 = 1024;
  v22 = v4;
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_16;
      *(_DWORD *)buf = 136446978;
      v16 = "nw_network_agent_set_use_count";
      v17 = 1024;
      v18 = a1;
      v19 = 2048;
      v20 = v14;
      v21 = 1024;
      v22 = v4;
      v8 = "%{public}s setsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d";
      goto LABEL_15;
    }
    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_16;
      *(_DWORD *)buf = 136446978;
      v16 = "nw_network_agent_set_use_count";
      v17 = 1024;
      v18 = a1;
      v19 = 2048;
      v20 = v14;
      v21 = 1024;
      v22 = v4;
      v8 = "%{public}s setsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_15;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = type;
    v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136447234;
        v16 = "nw_network_agent_set_use_count";
        v17 = 1024;
        v18 = a1;
        v19 = 2048;
        v20 = v14;
        v21 = 1024;
        v22 = v4;
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s setsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
      }
      free(backtrace_string);
      goto LABEL_16;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446978;
      v16 = "nw_network_agent_set_use_count";
      v17 = 1024;
      v18 = a1;
      v19 = 2048;
      v20 = v14;
      v21 = 1024;
      v22 = v4;
      v8 = "%{public}s setsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, no backtrace";
LABEL_15:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0x22u);
    }
  }
LABEL_16:
  if (v5)
    free(v5);
  return v3;
}

uint64_t nw_network_agent_get_use_count(int a1, _QWORD *a2)
{
  uint64_t v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  int v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *v14;
  _BOOL4 v15;
  char *backtrace_string;
  _BOOL4 v17;
  char v19;
  os_log_type_t v20;
  socklen_t v21;
  os_log_type_t type[8];
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  _BYTE v26[14];
  __int16 v27;
  int v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *a2 = 0;
    *(_QWORD *)type = 0;
    v21 = 8;
    v4 = getsockopt(a1, 2, 16, type, &v21);
    if ((v4 & 0x80000000) == 0)
    {
      *a2 = *(_QWORD *)type;
      return v4;
    }
    v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    v24 = "nw_network_agent_get_use_count";
    v25 = 1024;
    *(_DWORD *)v26 = a1;
    *(_WORD *)&v26[4] = 2048;
    *(_QWORD *)&v26[6] = *(_QWORD *)type;
    v27 = 1024;
    v28 = v9;
    v10 = (char *)_os_log_send_and_compose_impl();
    v20 = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v10, &v20, &v19))
      goto LABEL_35;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = v20;
      if (!os_log_type_enabled((os_log_t)gLogObj, v20))
        goto LABEL_35;
      *(_DWORD *)buf = 136446978;
      v24 = "nw_network_agent_get_use_count";
      v25 = 1024;
      *(_DWORD *)v26 = a1;
      *(_WORD *)&v26[4] = 2048;
      *(_QWORD *)&v26[6] = *(_QWORD *)type;
      v27 = 1024;
      v28 = v9;
      v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = v20;
      v17 = os_log_type_enabled((os_log_t)gLogObj, v20);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136447234;
          v24 = "nw_network_agent_get_use_count";
          v25 = 1024;
          *(_DWORD *)v26 = a1;
          *(_WORD *)&v26[4] = 2048;
          *(_QWORD *)&v26[6] = *(_QWORD *)type;
          v27 = 1024;
          v28 = v9;
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s getsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
        }
        free(backtrace_string);
        goto LABEL_35;
      }
      if (!v17)
      {
LABEL_35:
        if (v10)
          free(v10);
        return v4;
      }
      *(_DWORD *)buf = 136446978;
      v24 = "nw_network_agent_get_use_count";
      v25 = 1024;
      *(_DWORD *)v26 = a1;
      *(_WORD *)&v26[4] = 2048;
      *(_QWORD *)&v26[6] = *(_QWORD *)type;
      v27 = 1024;
      v28 = v9;
      v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = v20;
      if (!os_log_type_enabled((os_log_t)gLogObj, v20))
        goto LABEL_35;
      *(_DWORD *)buf = 136446978;
      v24 = "nw_network_agent_get_use_count";
      v25 = 1024;
      *(_DWORD *)v26 = a1;
      *(_WORD *)&v26[4] = 2048;
      *(_QWORD *)&v26[6] = *(_QWORD *)type;
      v27 = 1024;
      v28 = v9;
      v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0x22u);
    goto LABEL_35;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_network_agent_get_use_count";
  v5 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v21) = 0;
  if (__nwlog_fault(v5, type, &v21))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_network_agent_get_use_count";
        v8 = "%{public}s called with null out_use_count";
LABEL_26:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if ((_BYTE)v21)
    {
      v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      v15 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v14)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_network_agent_get_use_count";
          v25 = 2082;
          *(_QWORD *)v26 = v14;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null out_use_count, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v14);
        goto LABEL_27;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_network_agent_get_use_count";
        v8 = "%{public}s called with null out_use_count, no backtrace";
        goto LABEL_26;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_network_agent_get_use_count";
        v8 = "%{public}s called with null out_use_count, backtrace limit exceeded";
        goto LABEL_26;
      }
    }
  }
LABEL_27:
  if (v5)
    free(v5);
  return 0xFFFFFFFFLL;
}

uint64_t nw_network_agent_get_token_count(int a1, _DWORD *a2)
{
  uint64_t v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  int v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *v14;
  _BOOL4 v15;
  char *backtrace_string;
  _BOOL4 v17;
  char v19;
  os_log_type_t v20;
  socklen_t v21;
  os_log_type_t type[4];
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  _BYTE v26[10];
  __int16 v27;
  int v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *a2 = 0;
    v21 = 4;
    *(_DWORD *)type = 0;
    v4 = getsockopt(a1, 2, 23, type, &v21);
    if ((v4 & 0x80000000) == 0)
    {
      *a2 = *(_DWORD *)type;
      return v4;
    }
    v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    v24 = "nw_network_agent_get_token_count";
    v25 = 1024;
    *(_DWORD *)v26 = a1;
    *(_WORD *)&v26[4] = 1024;
    *(_DWORD *)&v26[6] = *(_DWORD *)type;
    v27 = 1024;
    v28 = v9;
    v10 = (char *)_os_log_send_and_compose_impl();
    v20 = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v10, &v20, &v19))
      goto LABEL_35;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = v20;
      if (!os_log_type_enabled((os_log_t)gLogObj, v20))
        goto LABEL_35;
      *(_DWORD *)buf = 136446978;
      v24 = "nw_network_agent_get_token_count";
      v25 = 1024;
      *(_DWORD *)v26 = a1;
      *(_WORD *)&v26[4] = 1024;
      *(_DWORD *)&v26[6] = *(_DWORD *)type;
      v27 = 1024;
      v28 = v9;
      v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %u %{darwin.errno}d";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = v20;
      v17 = os_log_type_enabled((os_log_t)gLogObj, v20);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136447234;
          v24 = "nw_network_agent_get_token_count";
          v25 = 1024;
          *(_DWORD *)v26 = a1;
          *(_WORD *)&v26[4] = 1024;
          *(_DWORD *)&v26[6] = *(_DWORD *)type;
          v27 = 1024;
          v28 = v9;
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s getsockopt for use count failed, handle = %d, use_count = %u %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x28u);
        }
        free(backtrace_string);
        goto LABEL_35;
      }
      if (!v17)
      {
LABEL_35:
        if (v10)
          free(v10);
        return v4;
      }
      *(_DWORD *)buf = 136446978;
      v24 = "nw_network_agent_get_token_count";
      v25 = 1024;
      *(_DWORD *)v26 = a1;
      *(_WORD *)&v26[4] = 1024;
      *(_DWORD *)&v26[6] = *(_DWORD *)type;
      v27 = 1024;
      v28 = v9;
      v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %u %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = v20;
      if (!os_log_type_enabled((os_log_t)gLogObj, v20))
        goto LABEL_35;
      *(_DWORD *)buf = 136446978;
      v24 = "nw_network_agent_get_token_count";
      v25 = 1024;
      *(_DWORD *)v26 = a1;
      *(_WORD *)&v26[4] = 1024;
      *(_DWORD *)&v26[6] = *(_DWORD *)type;
      v27 = 1024;
      v28 = v9;
      v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %u %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0x1Eu);
    goto LABEL_35;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_network_agent_get_token_count";
  v5 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v21) = 0;
  if (__nwlog_fault(v5, type, &v21))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_network_agent_get_token_count";
        v8 = "%{public}s called with null out_use_count";
LABEL_26:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if ((_BYTE)v21)
    {
      v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      v15 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v14)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_network_agent_get_token_count";
          v25 = 2082;
          *(_QWORD *)v26 = v14;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null out_use_count, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v14);
        goto LABEL_27;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_network_agent_get_token_count";
        v8 = "%{public}s called with null out_use_count, no backtrace";
        goto LABEL_26;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_network_agent_get_token_count";
        v8 = "%{public}s called with null out_use_count, backtrace limit exceeded";
        goto LABEL_26;
      }
    }
  }
LABEL_27:
  if (v5)
    free(v5);
  return 0xFFFFFFFFLL;
}

void *nw_protocol_socksv5_copy_definition()
{
  void *result;

  if (nw_protocol_socksv5_copy_definition::onceToken != -1)
    dispatch_once(&nw_protocol_socksv5_copy_definition::onceToken, &__block_literal_global_83487);
  result = (void *)nw_protocol_socksv5_copy_definition::definition;
  if (nw_protocol_socksv5_copy_definition::definition)
    return os_retain((void *)nw_protocol_socksv5_copy_definition::definition);
  return result;
}

BOOL __nw_protocol_socksv5_copy_definition_block_invoke()
{
  nw_protocol_socksv5_copy_definition::definition = (uint64_t)nw_framer_create_definition("socksv5", 0, &__block_literal_global_6_83491);
  return nw_protocol_definition_register((void *)nw_protocol_socksv5_copy_definition::definition);
}

uint64_t __nw_protocol_socksv5_copy_definition_block_invoke_2(uint64_t a1, NSObject *a2)
{
  _DWORD *v3;
  nw_parameters_t v4;
  id *v5;
  id v6;
  id *v7;
  id v8;
  _QWORD *v9;
  const char *v10;
  _QWORD *v11;
  const char *v12;
  uint64_t v13;
  size_t v14;
  NSObject *v15;
  uint64_t result;
  NSObject *v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  char *backtrace_string;
  _BOOL4 v24;
  _QWORD cleanup_handler[5];
  _QWORD output_handler[5];
  _QWORD input_handler[6];
  os_log_type_t output_buffer[7];
  char v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v3 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (v3)
  {
LABEL_2:
    v3[4] = 0;
    v4 = nw_framer_copy_parameters(a2);
    if (v4)
    {
      v5 = v4;
      v6 = v5[23];

      if (v6)
      {
        v7 = (id *)v6;
        v8 = v7[13];

        if (v8)
        {
          v9 = v8;
          v10 = (const char *)v9[2];

          if (v10)
            *(_QWORD *)v3 = xpc_string_create(v10);
          v11 = v9;
          v12 = (const char *)v11[3];

          if (v12)
            *((_QWORD *)v3 + 1) = xpc_string_create(v12);
        }
        os_release(v7);
      }
      os_release(v5);
    }
    v13 = MEMORY[0x1E0C809B0];
    input_handler[0] = MEMORY[0x1E0C809B0];
    input_handler[1] = 0x40000000;
    input_handler[2] = __nw_protocol_socksv5_copy_definition_block_invoke_3;
    input_handler[3] = &__block_descriptor_tmp_11_83496;
    input_handler[4] = v3;
    input_handler[5] = a2;
    nw_framer_set_input_handler(a2, input_handler);
    output_handler[0] = v13;
    output_handler[1] = 0x40000000;
    output_handler[2] = __nw_protocol_socksv5_copy_definition_block_invoke_2_12;
    output_handler[3] = &__block_descriptor_tmp_14_83497;
    output_handler[4] = v3;
    nw_framer_set_output_handler(a2, output_handler);
    cleanup_handler[0] = v13;
    cleanup_handler[1] = 0x40000000;
    cleanup_handler[2] = __nw_protocol_socksv5_copy_definition_block_invoke_3_15;
    cleanup_handler[3] = &__block_descriptor_tmp_17_83498;
    cleanup_handler[4] = v3;
    nw_framer_set_cleanup_handler(a2, cleanup_handler);
    if (a2)
    {
      *(_DWORD *)output_buffer = 261;
      if (*(_QWORD *)v3 && *((_QWORD *)v3 + 1))
      {
        output_buffer[1] = OS_LOG_TYPE_DEBUG;
        output_buffer[3] = OS_LOG_TYPE_DEBUG;
        v14 = 4;
      }
      else
      {
        v14 = 3;
      }
      nw_framer_write_output(a2, (const uint8_t *)output_buffer, v14);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_socksv5_send_hello";
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s Sent client hello", buf, 0xCu);
      }
      v3[4] = 1;
      return 2;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_socksv5_send_hello";
    v19 = (char *)_os_log_send_and_compose_impl();
    output_buffer[0] = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v19, output_buffer, &v29))
    {
      if (output_buffer[0] == OS_LOG_TYPE_FAULT)
      {
        v20 = __nwlog_obj();
        v21 = output_buffer[0];
        if (!os_log_type_enabled(v20, output_buffer[0]))
          goto LABEL_36;
        *(_DWORD *)buf = 136446210;
        v31 = "nw_socksv5_send_hello";
        v22 = "%{public}s called with null framer";
        goto LABEL_35;
      }
      if (!v29)
      {
        v20 = __nwlog_obj();
        v21 = output_buffer[0];
        if (!os_log_type_enabled(v20, output_buffer[0]))
          goto LABEL_36;
        *(_DWORD *)buf = 136446210;
        v31 = "nw_socksv5_send_hello";
        v22 = "%{public}s called with null framer, backtrace limit exceeded";
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v21 = output_buffer[0];
      v24 = os_log_type_enabled(v20, output_buffer[0]);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_socksv5_send_hello";
          v32 = 2082;
          v33 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null framer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_36;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_socksv5_send_hello";
        v22 = "%{public}s called with null framer, no backtrace";
LABEL_35:
        _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
      }
    }
LABEL_36:
    if (v19)
      free(v19);
    return 2;
  }
  v17 = __nwlog_obj();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v31 = "strict_calloc";
  v32 = 2048;
  v33 = 1;
  v34 = 2048;
  v35 = 24;
  v18 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v18);
  if (!(_DWORD)result)
  {
    free(v18);
    goto LABEL_2;
  }
  __break(1u);
  return result;
}

uint64_t __nw_protocol_socksv5_copy_definition_block_invoke_3(uint64_t a1, nw_framer_t framer)
{
  uint64_t v2;
  NSObject *v4;
  NSObject *v5;
  uint64_t (*v6)(uint64_t, unsigned __int8 *);
  void *v7;
  NSObject *v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  NSObject *v12;
  NSObject *v14;
  uint64_t *p_buf;
  _QWORD v17[6];
  _QWORD parse[5];
  uint8_t temp_buffer[8];
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t *v23;
  uint64_t *v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  uint8_t v34[4];
  __int128 v35;
  uint64_t (*v36)(uint64_t);
  void *v37;
  uint64_t *v38;
  uint64_t v39;
  __int128 buf;
  uint64_t v41;
  void *v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  switch(*(_DWORD *)(v2 + 16))
  {
    case 0:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = "nw_protocol_socksv5_copy_definition_block_invoke_3";
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s Reading packets in initial state", (uint8_t *)&buf, 0xCu);
      }
      return 0;
    case 1:
      v5 = *(NSObject **)(a1 + 40);
      *(_WORD *)temp_buffer = 0;
      *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
      *((_QWORD *)&buf + 1) = 0x40000000;
      v6 = ___ZL22nw_socksv5_parse_helloP9nw_framerP10nw_socksv5_block_invoke;
      v7 = &__block_descriptor_tmp_24_83509;
      goto LABEL_6;
    case 2:
      v5 = *(NSObject **)(a1 + 40);
      *(_WORD *)temp_buffer = 0;
      *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
      *((_QWORD *)&buf + 1) = 0x40000000;
      v6 = ___ZL21nw_socksv5_parse_authP9nw_framerP10nw_socksv5_block_invoke;
      v7 = &__block_descriptor_tmp_25_83510;
LABEL_6:
      v41 = (uint64_t)v6;
      v42 = v7;
      v43 = v5;
      v44 = v2;
      nw_framer_parse_input(v5, 2uLL, 2uLL, temp_buffer, &buf);
      return 0;
    case 3:
      v8 = *(NSObject **)(a1 + 40);
      *(_DWORD *)v34 = 0;
      v30 = 0;
      v31 = &v30;
      v33 = 0;
      v32 = 0x2000000000;
      v26 = 0;
      v27 = &v26;
      v28 = 0x2000000000;
      v29 = 0;
      v9 = MEMORY[0x1E0C809B0];
      *(_QWORD *)temp_buffer = MEMORY[0x1E0C809B0];
      v20 = 0x40000000;
      v21 = (uint64_t)___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke;
      v22 = &unk_1E14ABE48;
      v24 = &v30;
      v25 = v8;
      v23 = &v26;
      if (nw_framer_parse_input(v8, 4uLL, 4uLL, v34, temp_buffer))
      {
        if (*((_BYTE *)v27 + 24) != 3)
          goto LABEL_10;
        *(_DWORD *)((char *)&buf + 3) = 0;
        LODWORD(buf) = 0;
        v10 = *((unsigned int *)v31 + 6);
        parse[0] = v9;
        parse[1] = 0x40000000;
        parse[2] = ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_27;
        parse[3] = &unk_1E14ABE70;
        parse[4] = &v30;
        if (nw_framer_parse_input(v8, v10, v10, (uint8_t *)&buf, parse))
        {
LABEL_10:
          bzero(&buf, 0x201uLL);
          v11 = *((unsigned int *)v31 + 6);
          if (v11 < 0x202)
          {
            *(_QWORD *)&v35 = v9;
            *((_QWORD *)&v35 + 1) = 0x40000000;
            v36 = ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_29;
            v37 = &unk_1E14ABE98;
            v38 = &v30;
            v39 = v2;
            if (nw_framer_parse_input(v8, v11, v11, (uint8_t *)&buf, &v35))
            {
              nw_framer_pass_through_input(v8);
              nw_framer_pass_through_output(v8);
              nw_framer_mark_ready(v8);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v12 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v35) = 136446210;
              *(_QWORD *)((char *)&v35 + 4) = "nw_socksv5_parse_connect";
              _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Read length is longer than the destination message, disconnecting", (uint8_t *)&v35, 0xCu);
            }
            nw_framer_mark_failed_with_error(v8, 22);
          }
        }
      }
      _Block_object_dispose(&v26, 8);
      p_buf = &v30;
      goto LABEL_20;
    case 4:
      *(_QWORD *)&buf = 0;
      *((_QWORD *)&buf + 1) = &buf;
      v41 = 0x2000000000;
      v42 = 0;
      *(_QWORD *)temp_buffer = 0;
      v20 = (uint64_t)temp_buffer;
      v21 = 0x2000000000;
      LOBYTE(v22) = 0;
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 0x40000000;
      v17[2] = __nw_protocol_socksv5_copy_definition_block_invoke_7;
      v17[3] = &unk_1E14ABD80;
      v17[4] = &buf;
      v17[5] = temp_buffer;
      nw_framer_parse_input(framer, 1uLL, 0xFFFFFFFFuLL, 0, v17);
      v14 = nw_framer_message_create(*(nw_framer_t *)(a1 + 40));
      nw_framer_deliver_input_no_copy(framer, *(_QWORD *)(*((_QWORD *)&buf + 1) + 24), v14, *(_BYTE *)(v20 + 24));
      if (v14)
        os_release(v14);
      _Block_object_dispose(temp_buffer, 8);
      p_buf = (uint64_t *)&buf;
LABEL_20:
      _Block_object_dispose(p_buf, 8);
      break;
    default:
      return 0;
  }
  return 0;
}

BOOL __nw_protocol_socksv5_copy_definition_block_invoke_2_12(_BOOL8 result, nw_framer_t framer, int a3, size_t output_length)
{
  if (*(_DWORD *)(*(_QWORD *)(result + 32) + 16) == 4)
    return nw_framer_write_output_no_copy(framer, output_length);
  return result;
}

void __nw_protocol_socksv5_copy_definition_block_invoke_3_15(uint64_t a1)
{
  xpc_object_t *v2;

  v2 = *(xpc_object_t **)(a1 + 32);
  if (*v2)
  {
    xpc_release(*v2);
    **(_QWORD **)(a1 + 32) = 0;
    v2 = *(xpc_object_t **)(a1 + 32);
  }
  if (!v2[1]
    || (xpc_release(v2[1]), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = 0, (v2 = *(xpc_object_t **)(a1 + 32)) != 0))
  {
    free(v2);
  }
}

uint64_t ___ZL22nw_socksv5_parse_helloP9nw_framerP10nw_socksv5_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  const char *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  size_t length;
  void *v14;
  size_t v15;
  int v16;
  size_t v18;
  size_t v19;
  const char *string_ptr;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  char v31;
  uint8_t v32[4];
  const char *v33;
  _BYTE buf[34];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _BYTE v63[31];
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*a2 != 5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v8 = *a2;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socksv5_parse_hello_block_invoke";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        v9 = "%{public}s Received invalid SOCKS version %d";
LABEL_22:
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, v9, buf, 0x12u);
      }
LABEL_23:
      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 22);
      return 2;
    }
    if (a2[1] != 2)
    {
      if (!a2[1])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socksv5_parse_hello_block_invoke";
          _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, "%{public}s Received hello. Doing SOCKSv5 with no authentication", buf, 0xCu);
        }
        nw_socksv5_send_connect(*(NSObject **)(a1 + 32), *(_QWORD *)(a1 + 40));
        return 2;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v16 = a2[1];
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socksv5_parse_hello_block_invoke";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        v9 = "%{public}s Received invalid SOCKS method %d";
        goto LABEL_22;
      }
      goto LABEL_23;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socksv5_parse_hello_block_invoke";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s Received hello. Doing SOCKSv5 with username/password authentication", buf, 0xCu);
    }
    v11 = *(NSObject **)(a1 + 32);
    if (v11)
    {
      v12 = *(_QWORD *)(a1 + 40);
      v62 = 0u;
      memset(v63, 0, sizeof(v63));
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v49 = 0u;
      v48 = 0u;
      v47 = 0u;
      v46 = 0u;
      v45 = 0u;
      v44 = 0u;
      v43 = 0u;
      v42 = 0u;
      v41 = 0u;
      v40 = 0u;
      v39 = 0u;
      v38 = 0u;
      v37 = 0u;
      v36 = 0u;
      v35 = 0u;
      memset(&buf[2], 0, 32);
      buf[0] = 1;
      if (*(_QWORD *)v12)
      {
        length = xpc_string_get_length(*(xpc_object_t *)v12);
        v14 = *(void **)(v12 + 8);
        if (v14)
        {
LABEL_19:
          v15 = xpc_string_get_length(v14);
LABEL_28:
          if (length >= 0xFE)
            v18 = 254;
          else
            v18 = length;
          if (v15 >= 0xFE)
            v19 = 254;
          else
            v19 = v15;
          buf[1] = v18;
          if (v18)
          {
            string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)v12);
            strncpy(&buf[2], string_ptr, v18);
          }
          buf[v18 + 2] = v19;
          if (v19)
          {
            v21 = xpc_string_get_string_ptr(*(xpc_object_t *)(v12 + 8));
            strncpy(&buf[v18 + 3], v21, v19);
          }
          v22 = length - 255;
          if (length >= 0xFF)
            v22 = -1;
          v23 = v15 - 255;
          if (v15 >= 0xFF)
            v23 = -1;
          nw_framer_write_output(v11, buf, v22 + v23 + 513);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = gLogObj;
          v6 = 2;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v32 = 136446210;
            v33 = "nw_socksv5_send_auth";
            _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s Sent client auth", v32, 0xCu);
          }
          *(_DWORD *)(v12 + 16) = 2;
          return v6;
        }
      }
      else
      {
        length = 0;
        v14 = *(void **)(v12 + 8);
        if (v14)
          goto LABEL_19;
      }
      v15 = 0;
      goto LABEL_28;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socksv5_send_auth";
    v25 = (char *)_os_log_send_and_compose_impl();
    v32[0] = 16;
    v31 = 0;
    if (__nwlog_fault(v25, v32, &v31))
    {
      if (v32[0] == 17)
      {
        v26 = __nwlog_obj();
        v27 = v32[0];
        if (!os_log_type_enabled(v26, (os_log_type_t)v32[0]))
          goto LABEL_59;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socksv5_send_auth";
        v28 = "%{public}s called with null framer";
        goto LABEL_58;
      }
      if (!v31)
      {
        v26 = __nwlog_obj();
        v27 = v32[0];
        if (!os_log_type_enabled(v26, (os_log_type_t)v32[0]))
          goto LABEL_59;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socksv5_send_auth";
        v28 = "%{public}s called with null framer, backtrace limit exceeded";
        goto LABEL_58;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = v32[0];
      v30 = os_log_type_enabled(v26, (os_log_type_t)v32[0]);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_socksv5_send_auth";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null framer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_59;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socksv5_send_auth";
        v28 = "%{public}s called with null framer, no backtrace";
LABEL_58:
        _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
      }
    }
LABEL_59:
    if (v25)
      free(v25);
    return 2;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socksv5_parse_hello_block_invoke";
    _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s Received NULL server hello", buf, 0xCu);
  }
  return 0;
}

uint64_t ___ZL21nw_socksv5_parse_authP9nw_framerP10nw_socksv5_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  int v4;
  NSObject *v5;
  int v6;
  const char *v7;
  NSObject *v8;
  int v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*a2 == 1)
    {
      v4 = a2[1];
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (!v4)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          v11 = 136446210;
          v12 = "nw_socksv5_parse_auth_block_invoke";
          _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Received authentication success from SOCKS server", (uint8_t *)&v11, 0xCu);
        }
        nw_socksv5_send_connect(*(NSObject **)(a1 + 32), *(_QWORD *)(a1 + 40));
        return 2;
      }
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v6 = a2[1];
        v11 = 136446466;
        v12 = "nw_socksv5_parse_auth_block_invoke";
        v13 = 1024;
        v14 = v6;
        v7 = "%{public}s Received SOCKS auth status %d, failing";
LABEL_11:
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v11, 0x12u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v10 = *a2;
        v11 = 136446466;
        v12 = "nw_socksv5_parse_auth_block_invoke";
        v13 = 1024;
        v14 = v10;
        v7 = "%{public}s Received invalid SOCKS auth version %d";
        goto LABEL_11;
      }
    }
    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 80);
    return 2;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    v11 = 136446210;
    v12 = "nw_socksv5_parse_auth_block_invoke";
    _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s Received NULL server auth", (uint8_t *)&v11, 0xCu);
  }
  return 0;
}

uint64_t ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v4;
  int v5;
  const char *v6;
  NSObject *v7;
  uint64_t result;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v13 = 136446210;
      v14 = "nw_socksv5_parse_connect_block_invoke";
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s Received NULL header", (uint8_t *)&v13, 0xCu);
    }
    return 0;
  }
  if (*a2 == 5)
  {
    if (a2[1])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v5 = a2[1];
        v13 = 136446466;
        v14 = "nw_socksv5_parse_connect_block_invoke";
        v15 = 1024;
        v16 = v5;
        v6 = "%{public}s Received SOCKS connect status %d, failing";
LABEL_11:
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v13, 0x12u);
        goto LABEL_12;
      }
      goto LABEL_12;
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2[3];
    v10 = a2[3];
    switch(v10)
    {
      case 4:
        result = 0;
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 22;
        return result;
      case 3:
        result = 0;
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 5;
        return result;
      case 1:
        result = 0;
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 10;
        return result;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v12 = a2[3];
      v13 = 136446466;
      v14 = "nw_socksv5_parse_connect_block_invoke";
      v15 = 1024;
      v16 = v12;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s Received SOCKS unknown type %d", (uint8_t *)&v13, 0x12u);
    }
    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 48), 22);
    return 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    v9 = *a2;
    v13 = 136446466;
    v14 = "nw_socksv5_parse_connect_block_invoke";
    v15 = 1024;
    v16 = v9;
    v6 = "%{public}s Received invalid SOCKS version %d";
    goto LABEL_11;
  }
LABEL_12:
  nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 48), 22);
  return 4;
}

uint64_t ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_27(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(unsigned __int8 *)(a2 + 4) + 7;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v4 = 136446210;
      v5 = "nw_socksv5_parse_connect_block_invoke";
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s Received NULL fqdn", (uint8_t *)&v4, 0xCu);
    }
  }
  return 0;
}

uint64_t ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_29(uint64_t a1)
{
  NSObject *v2;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    v4 = 136446210;
    v5 = "nw_socksv5_parse_connect_block_invoke";
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s Received complete connect message from SOCKS server", (uint8_t *)&v4, 0xCu);
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16) = 4;
  return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

uint64_t __nw_protocol_socksv5_copy_definition_block_invoke_7(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a4;
  return 0;
}

void nw_socksv5_send_connect(NSObject *a1, uint64_t a2)
{
  nw_endpoint_t v4;
  _BOOL8 v5;
  const sockaddr *address;
  size_t v7;
  const char *hostname;
  const char *v9;
  size_t v10;
  size_t v11;
  NSObject *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char v19;
  uint8_t buf[4];
  const char *v21;
  _BYTE output_buffer[35];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _BYTE v51[30];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = nw_framer_copy_remote_endpoint(a1);
    v5 = nw_endpoint_copy_proxy_original_endpoint(v4);
    if (v4)
      os_release(v4);
    v50 = 0u;
    memset(v51, 0, sizeof(v51));
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v37 = 0u;
    v36 = 0u;
    v35 = 0u;
    v34 = 0u;
    v33 = 0u;
    v32 = 0u;
    v31 = 0u;
    v30 = 0u;
    v29 = 0u;
    v28 = 0u;
    v27 = 0u;
    v26 = 0u;
    v25 = 0u;
    v24 = 0u;
    v23 = 0u;
    *(_WORD *)output_buffer = 261;
    memset(&output_buffer[2], 0, 33);
    if (nw_endpoint_get_type((nw_endpoint_t)v5) == nw_endpoint_type_address)
    {
      address = nw_endpoint_get_address((nw_endpoint_t)v5);
      if (address->sa_family == 30)
      {
        output_buffer[3] = 4;
        *(sockaddr *)&output_buffer[4] = *(sockaddr *)&address->sa_data[6];
        *(_WORD *)&output_buffer[20] = *(_WORD *)address->sa_data;
        v7 = 22;
      }
      else
      {
        output_buffer[3] = 1;
        *(_DWORD *)&output_buffer[4] = *(_DWORD *)&address->sa_data[2];
        *(_WORD *)&output_buffer[8] = *(_WORD *)address->sa_data;
        v7 = 10;
      }
    }
    else
    {
      output_buffer[3] = 3;
      hostname = nw_endpoint_get_hostname((nw_endpoint_t)v5);
      if (hostname)
      {
        v9 = hostname;
        v10 = strlen(hostname);
        if (v10 >= 0xFF)
          v11 = 255;
        else
          v11 = v10;
        output_buffer[4] = v11;
        memcpy(&output_buffer[5], v9, v11);
      }
      else
      {
        v11 = 0;
        output_buffer[4] = 0;
      }
      *(_WORD *)&output_buffer[v11 + 5] = __rev16(nw_endpoint_get_port((nw_endpoint_t)v5));
      v7 = v11 + 7;
    }
    nw_framer_write_output(a1, output_buffer, v7);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v21 = "nw_socksv5_send_connect";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Sent client request", buf, 0xCu);
    }
    *(_DWORD *)(a2 + 16) = 3;
    if (v5)
      os_release((void *)v5);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)output_buffer = 136446210;
  *(_QWORD *)&output_buffer[4] = "nw_socksv5_send_connect";
  v13 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  v19 = 0;
  if (__nwlog_fault(v13, buf, &v19))
  {
    if (buf[0] == 17)
    {
      v14 = __nwlog_obj();
      v15 = buf[0];
      if (!os_log_type_enabled(v14, (os_log_type_t)buf[0]))
        goto LABEL_34;
      *(_DWORD *)output_buffer = 136446210;
      *(_QWORD *)&output_buffer[4] = "nw_socksv5_send_connect";
      v16 = "%{public}s called with null framer";
      goto LABEL_33;
    }
    if (!v19)
    {
      v14 = __nwlog_obj();
      v15 = buf[0];
      if (!os_log_type_enabled(v14, (os_log_type_t)buf[0]))
        goto LABEL_34;
      *(_DWORD *)output_buffer = 136446210;
      *(_QWORD *)&output_buffer[4] = "nw_socksv5_send_connect";
      v16 = "%{public}s called with null framer, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = buf[0];
    v18 = os_log_type_enabled(v14, (os_log_type_t)buf[0]);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)output_buffer = 136446466;
        *(_QWORD *)&output_buffer[4] = "nw_socksv5_send_connect";
        *(_WORD *)&output_buffer[12] = 2082;
        *(_QWORD *)&output_buffer[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null framer, dumping backtrace:%{public}s", output_buffer, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_34;
    }
    if (v18)
    {
      *(_DWORD *)output_buffer = 136446210;
      *(_QWORD *)&output_buffer[4] = "nw_socksv5_send_connect";
      v16 = "%{public}s called with null framer, no backtrace";
LABEL_33:
      _os_log_impl(&dword_182FBE000, v14, v15, v16, output_buffer, 0xCu);
    }
  }
LABEL_34:
  if (v13)
    free(v13);
}

void *nw_protocol_copy_test_definition()
{
  void *result;

  if (nw_protocol_copy_test_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
  result = (void *)nw_protocol_copy_test_definition::test_definition;
  if (nw_protocol_copy_test_definition::test_definition)
    return os_retain((void *)nw_protocol_copy_test_definition::test_definition);
  return result;
}

void __nw_protocol_copy_test_definition_block_invoke()
{
  if (nw_protocol_test_identifier(void)::onceToken != -1)
    dispatch_once(&nw_protocol_test_identifier(void)::onceToken, &__block_literal_global_12_83552);
  nw_protocol_copy_test_definition::test_definition = (uint64_t)nw_protocol_definition_create_with_identifier((__int128 *)&g_test_protocol_identifier);
  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_test_definition::test_definition, (uint64_t)nw_protocol_test_allocate_options, (uint64_t)nw_protocol_test_copy_options, (uint64_t)nw_protocol_test_deallocate_options);
  nw_protocol_definition_set_options_equality_check((void *)nw_protocol_copy_test_definition::test_definition, (uint64_t)nw_protocol_test_options_are_equal);
  nw_protocol_definition_set_metadata_allocator((void *)nw_protocol_copy_test_definition::test_definition, (uint64_t)nw_protocol_test_allocate_metadata, (uint64_t)nw_protocol_test_deallocate_metadata);
}

BOOL nw_protocol_test_allocate_options(nw_protocol_definition *a1)
{
  _OWORD *v1;
  _BOOL8 result;
  NSObject *v3;
  void *v4;

  v1 = malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL);
  if (v1)
    goto LABEL_2;
  v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  v4 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
LABEL_2:
    v1[1] = 0u;
    v1[2] = 0u;
    *v1 = 0u;
    return (BOOL)v1;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_test_copy_options(nw_protocol_definition *a1, _QWORD *a2)
{
  _OWORD *v3;
  const void *v4;
  void *v5;
  char v6;
  const void *v7;
  const void *v8;
  void *v9;
  char v10;
  const void *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  _BOOL8 result;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  NSObject *v20;
  void *v21;
  char *backtrace_string;
  _BOOL4 v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_test_copy_options";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v16, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_protocol_test_copy_options";
          v19 = "%{public}s called with null existing_handle";
LABEL_31:
          _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v17 = __nwlog_obj();
        v18 = type;
        v23 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_protocol_test_copy_options";
            v28 = 2082;
            v29 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_32;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_protocol_test_copy_options";
          v19 = "%{public}s called with null existing_handle, no backtrace";
          goto LABEL_31;
        }
      }
      else
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_protocol_test_copy_options";
          v19 = "%{public}s called with null existing_handle, backtrace limit exceeded";
          goto LABEL_31;
        }
      }
    }
LABEL_32:
    if (v16)
      free(v16);
    return 0;
  }
  v3 = malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL);
  if (v3)
    goto LABEL_3;
  v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v27 = "strict_calloc";
  v28 = 2048;
  v29 = 1;
  v30 = 2048;
  v31 = 48;
  v21 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
LABEL_3:
    v3[1] = 0u;
    v3[2] = 0u;
    *v3 = 0u;
    *(_QWORD *)v3 = *a2;
    v4 = (const void *)a2[1];
    if (v4)
    {
      v5 = _Block_copy(v4);
      v6 = *((_BYTE *)v3 + 16);
      if ((v6 & 1) != 0)
      {
        v7 = (const void *)*((_QWORD *)v3 + 1);
        if (v7)
        {
          _Block_release(v7);
          v6 = *((_BYTE *)v3 + 16);
        }
      }
    }
    else
    {
      v5 = 0;
      v6 = 0;
    }
    *((_QWORD *)v3 + 1) = v5;
    *((_BYTE *)v3 + 16) = v6 | 1;
    v8 = (const void *)a2[3];
    if (v8)
    {
      v9 = _Block_copy(v8);
      v10 = *((_BYTE *)v3 + 32);
      if ((v10 & 1) == 0)
        goto LABEL_14;
    }
    else
    {
      v9 = 0;
      v10 = *((_BYTE *)v3 + 32);
      if ((v10 & 1) == 0)
      {
LABEL_14:
        *((_QWORD *)v3 + 3) = v9;
        *((_BYTE *)v3 + 32) = v10 | 1;
        *((_DWORD *)v3 + 10) = *((_DWORD *)a2 + 10);
        v12 = *((_BYTE *)v3 + 44) & 0xFE | *((_BYTE *)a2 + 44) & 1;
        *((_BYTE *)v3 + 44) = v12;
        v13 = v12 & 0xFFFFFFFD | (2 * ((*((unsigned __int8 *)a2 + 44) >> 1) & 1));
        *((_BYTE *)v3 + 44) = v13;
        v14 = v13 & 0xFFFFFFFB | (4 * ((*((unsigned __int8 *)a2 + 44) >> 2) & 1));
        *((_BYTE *)v3 + 44) = v14;
        *((_BYTE *)v3 + 44) = v14 & 0xF7 | *((_BYTE *)a2 + 44) & 8;
        return (BOOL)v3;
      }
    }
    v11 = (const void *)*((_QWORD *)v3 + 3);
    if (v11)
    {
      _Block_release(v11);
      v10 = *((_BYTE *)v3 + 32);
    }
    goto LABEL_14;
  }
  __break(1u);
  return result;
}

void nw_protocol_test_deallocate_options(nw_protocol_definition *a1, _QWORD *a2)
{
  const void *v3;
  const void *v4;

  if (a2)
  {
    if ((a2[4] & 1) != 0)
    {
      v3 = (const void *)a2[3];
      if (v3)
        _Block_release(v3);
    }
    a2[3] = 0;
    if ((a2[2] & 1) != 0)
    {
      v4 = (const void *)a2[1];
      if (v4)
        _Block_release(v4);
    }
    free(a2);
  }
}

BOOL nw_protocol_test_options_are_equal(nw_protocol_definition *a1, _QWORD *a2, _QWORD *a3)
{
  return *a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] && a2[3] == a3[3] && a2[4] == a3[4] && a2[5] == a3[5];
}

BOOL nw_protocol_test_allocate_metadata(nw_protocol_definition *a1)
{
  void *v1;
  _BOOL8 result;
  NSObject *v3;
  void *v4;

  v1 = malloc_type_calloc(1uLL, 4uLL, 0xEAFB8F1AuLL);
  if (v1)
    return (BOOL)v1;
  v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  v4 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }
  __break(1u);
  return result;
}

void nw_protocol_test_deallocate_metadata(nw_protocol_definition *a1, void *a2)
{
  if (a2)
    free(a2);
}

BOOL ___Z27nw_protocol_test_identifierv_block_invoke()
{
  unk_1EDCF2615 = 0;
  unk_1EDCF2625 = 0;
  unk_1EDCF261D = 0;
  dword_1EDCF262C = 0;
  strcpy((char *)&g_test_protocol_identifier, "test");
  qword_1EDCF26A8 = (uint64_t)nw_protocol_common_get_parameters;
  unk_1EDCF26B0 = nw_protocol_common_get_path;
  qword_1EDCF26B8 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_1EDCF26C0 = nw_protocol_common_get_remote_endpoint;
  qword_1EDCF2658 = (uint64_t)nw_protocol_common_disconnect;
  unk_1EDCF2660 = nw_protocol_common_connected;
  qword_1EDCF2678 = (uint64_t)nw_protocol_common_input_available;
  unk_1EDCF2680 = nw_protocol_common_output_available;
  qword_1EDCF2738 = (uint64_t)nw_protocol_common_reset;
  unk_1EDCF2740 = nw_protocol_common_input_flush;
  qword_1EDCF2718 = (uint64_t)nw_protocol_common_copy_info;
  unk_1EDCF2720 = 0;
  qword_1EDCF26E8 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_1EDCF26F0 = nw_protocol_common_input_finished;
  qword_1EDCF2708 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_1EDCF2710 = nw_protocol_common_waiting_for_output;
  qword_1EDCF26C8 = (uint64_t)nw_protocol_common_register_notification;
  unk_1EDCF26D0 = nw_protocol_common_unregister_notification;
  qword_1EDCF26D8 = (uint64_t)nw_protocol_common_notify;
  unk_1EDCF26E0 = nw_protocol_common_updated_path;
  g_test_protocol_callbacks = (uint64_t)nw_protocol_test_add_input_handler;
  unk_1EDCF2640 = nw_protocol_test_remove_input_handler;
  qword_1EDCF2688 = (uint64_t)nw_protocol_test_get_input_frames;
  unk_1EDCF2690 = nw_protocol_test_get_output_frames;
  qword_1EDCF2698 = (uint64_t)nw_protocol_test_finalize_output_frames;
  unk_1EDCF26A0 = nw_protocol_common_link_state;
  qword_1EDCF2648 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_1EDCF2650 = nw_protocol_test_connect;
  qword_1EDCF2668 = (uint64_t)nw_protocol_test_disconnected;
  unk_1EDCF2670 = nw_protocol_common_error;
  qword_1EDCF26F8 = (uint64_t)nw_protocol_test_output_finished;
  unk_1EDCF2700 = nw_protocol_common_get_output_local_endpoint;
  qword_1EDCF2728 = 0;
  unk_1EDCF2730 = nw_protocol_test_get_message_properties;
  qword_1EDCF2630 = 0x100000004;
  return nw_protocol_register_extended(&g_test_protocol_identifier, (uint64_t)nw_protocol_test_create);
}

BOOL nw_protocol_test_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v4;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v6;
  void *v7;
  void *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  _BOOL8 is_test_protocol;
  nw_protocol *v12;
  NSObject *v13;
  nw_protocol *output_handler;
  NSObject *v15;
  nw_protocol_callbacks *v16;
  nw_protocol_callbacks *v17;
  void (**v18)(_QWORD);
  const void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  char *v32;
  _BOOL4 v33;
  const char *v34;
  char *v35;
  _BOOL4 v36;
  char *v37;
  _BOOL4 v38;
  nw_protocol_identifier *identifier;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  nw_protocol_identifier *v44;
  const char *v45;
  char *backtrace_string;
  _BOOL4 v47;
  _BOOL4 v48;
  char *v49;
  _BOOL4 v50;
  nw_protocol_identifier *v51;
  _BOOL4 v52;
  _BOOL4 v53;
  nw_protocol_identifier *v54;
  nw_protocol_identifier *v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  const char *v59;
  char *v60;
  _BOOL4 v61;
  os_log_type_t type[8];
  os_log_type_t *v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  _BYTE buf[24];
  nw_protocol *v68;
  _QWORD v69[4];

  v69[3] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
    v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (!__nwlog_fault(v20, type, &v66))
      goto LABEL_66;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type[0];
      if (!os_log_type_enabled(v21, type[0]))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
      v23 = "%{public}s called with null protocol";
    }
    else if (v66)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v22 = type[0];
      v47 = os_log_type_enabled(v21, type[0]);
      if (backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_66;
      }
      if (!v47)
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
      v23 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v21 = __nwlog_obj();
      v22 = type[0];
      if (!os_log_type_enabled(v21, type[0]))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
      v23 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_65;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    if ((nw_protocol_common_add_input_handler((uint64_t)a1, (uint64_t)a2) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s failed to add input handler", buf, 0xCu);
      }
      return 0;
    }
    if (a1->handle != &nw_protocol_ref_counted_handle)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
      v20 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v66 = 0;
      if (!__nwlog_fault(v20, type, &v66))
        goto LABEL_66;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v21 = __nwlog_obj();
        v22 = type[0];
        if (!os_log_type_enabled(v21, type[0]))
          goto LABEL_66;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
        v23 = "%{public}s called with null test";
      }
      else if (v66)
      {
        v32 = (char *)__nw_create_backtrace_string();
        v21 = __nwlog_obj();
        v22 = type[0];
        v52 = os_log_type_enabled(v21, type[0]);
        if (v32)
        {
          if (v52)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v32;
            v34 = "%{public}s called with null test, dumping backtrace:%{public}s";
            goto LABEL_48;
          }
          goto LABEL_49;
        }
        if (!v52)
          goto LABEL_66;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
        v23 = "%{public}s called with null test, no backtrace";
      }
      else
      {
        v21 = __nwlog_obj();
        v22 = type[0];
        if (!os_log_type_enabled(v21, type[0]))
          goto LABEL_66;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
        v23 = "%{public}s called with null test, backtrace limit exceeded";
      }
      goto LABEL_65;
    }
    callbacks = a1[1].callbacks;
    if (callbacks)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    v4 = a1->callbacks;
    if (v4)
    {
      get_parameters = (uint64_t (*)(nw_protocol *))v4->get_parameters;
      if (get_parameters)
      {
        v6 = (void *)get_parameters(a1);
LABEL_10:
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v16 = a1[1].callbacks;
          if (v16)
          {
            v17 = (nw_protocol_callbacks *)((char *)v16 - 1);
            a1[1].callbacks = v17;
            if (!v17)
            {
              v18 = *(void (***)(_QWORD))a1[1].flow_id;
              if (v18)
              {
                *(_QWORD *)a1[1].flow_id = 0;
                v18[2](v18);
                _Block_release(v18);
              }
              if ((a1[1].flow_id[8] & 1) != 0)
              {
                v19 = *(const void **)a1[1].flow_id;
                if (v19)
                  _Block_release(v19);
              }
              free(a1);
            }
          }
        }
        if (v6)
        {
          if (nw_protocol_copy_test_definition::onceToken != -1)
            dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
          if (nw_protocol_copy_test_definition::test_definition)
          {
            v7 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
            if (v7)
            {
              v8 = v7;
              v9 = nw_parameters_copy_protocol_options_for_definition(v6, v7);
              if (v9)
              {
                v10 = v9;
                is_test_protocol = nw_protocol_options_is_test_protocol(v9);
                if (is_test_protocol)
                {
                  if (nw_protocol_options_is_test_protocol(v10))
                  {
                    *(_QWORD *)type = 0;
                    v63 = type;
                    v64 = 0x2000000000;
                    v65 = 0;
                    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                    *(_QWORD *)&buf[8] = 0x40000000;
                    *(_QWORD *)&buf[16] = ___ZL38nw_protocol_test_options_get_test_modeP19nw_protocol_options_block_invoke;
                    v68 = (nw_protocol *)&unk_1E14AC048;
                    v69[0] = type;
                    nw_protocol_options_access_handle(v10, buf);
                    v12 = (nw_protocol *)*((_QWORD *)v63 + 3);
                    _Block_object_dispose(type, 8);
LABEL_20:
                    a1[1].output_handler = v12;
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v13 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                    {
                      output_handler = a1[1].output_handler;
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler_block_invoke";
                      *(_WORD *)&buf[12] = 2048;
                      *(_QWORD *)&buf[14] = output_handler;
                      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_INFO, "%{public}s Got test mode flags: %llu", buf, 0x16u);
                    }
LABEL_85:
                    os_release(v8);
                    os_release(v10);
                    return is_test_protocol;
                  }
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode";
                  v56 = (char *)_os_log_send_and_compose_impl();
                  type[0] = OS_LOG_TYPE_ERROR;
                  v66 = 0;
                  if (__nwlog_fault(v56, type, &v66))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v57 = __nwlog_obj();
                      v58 = type[0];
                      if (os_log_type_enabled(v57, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode";
                        v59 = "%{public}s protocol options are not test protocol";
LABEL_175:
                        _os_log_impl(&dword_182FBE000, v57, v58, v59, buf, 0xCu);
                      }
                    }
                    else if (v66)
                    {
                      v60 = (char *)__nw_create_backtrace_string();
                      v57 = __nwlog_obj();
                      v58 = type[0];
                      v61 = os_log_type_enabled(v57, type[0]);
                      if (v60)
                      {
                        if (v61)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v60;
                          _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", buf, 0x16u);
                        }
                        free(v60);
                        goto LABEL_176;
                      }
                      if (v61)
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode";
                        v59 = "%{public}s protocol options are not test protocol, no backtrace";
                        goto LABEL_175;
                      }
                    }
                    else
                    {
                      v57 = __nwlog_obj();
                      v58 = type[0];
                      if (os_log_type_enabled(v57, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode";
                        v59 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
                        goto LABEL_175;
                      }
                    }
                  }
LABEL_176:
                  if (v56)
                    free(v56);
                  v12 = 0;
                  goto LABEL_20;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                v28 = (char *)_os_log_send_and_compose_impl();
                type[0] = OS_LOG_TYPE_ERROR;
                v66 = 0;
                if (__nwlog_fault(v28, type, &v66))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v29 = gLogObj;
                    v30 = type[0];
                    if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                      goto LABEL_83;
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                    v31 = "%{public}s Failed to copy test protocol options";
                    goto LABEL_82;
                  }
                  if (!v66)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v29 = gLogObj;
                    v30 = type[0];
                    if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                      goto LABEL_83;
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                    v31 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
                    goto LABEL_82;
                  }
                  v37 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v29 = gLogObj;
                  v30 = type[0];
                  v38 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
                  if (v37)
                  {
                    if (v38)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v37;
                      _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    free(v37);
                    goto LABEL_83;
                  }
                  if (v38)
                  {
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                    v31 = "%{public}s Failed to copy test protocol options, no backtrace";
LABEL_82:
                    _os_log_impl(&dword_182FBE000, v29, v30, v31, buf, 0xCu);
                  }
                }
LABEL_83:
                if (v28)
                  free(v28);
                goto LABEL_85;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
              v24 = (char *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              v66 = 0;
              if (!__nwlog_fault(v24, type, &v66))
                goto LABEL_75;
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v25 = gLogObj;
                v26 = type[0];
                if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                  v27 = "%{public}s Failed to copy protocol options";
LABEL_74:
                  _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
                }
              }
              else if (v66)
              {
                v35 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v25 = gLogObj;
                v26 = type[0];
                v36 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
                if (v35)
                {
                  if (v36)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v35;
                    _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s", buf, 0x16u);
                  }
                  free(v35);
                  goto LABEL_75;
                }
                if (v36)
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                  v27 = "%{public}s Failed to copy protocol options, no backtrace";
                  goto LABEL_74;
                }
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v25 = gLogObj;
                v26 = type[0];
                if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
                  v27 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
                  goto LABEL_74;
                }
              }
LABEL_75:
              if (v24)
                free(v24);
              os_release(v8);
              return 0;
            }
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
          v20 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v66 = 0;
          if (__nwlog_fault(v20, type, &v66))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v21 = __nwlog_obj();
              v22 = type[0];
              if (!os_log_type_enabled(v21, type[0]))
                goto LABEL_66;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
              v23 = "%{public}s called with null definition";
              goto LABEL_65;
            }
            if (!v66)
            {
              v21 = __nwlog_obj();
              v22 = type[0];
              if (!os_log_type_enabled(v21, type[0]))
                goto LABEL_66;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
              v23 = "%{public}s called with null definition, backtrace limit exceeded";
              goto LABEL_65;
            }
            v32 = (char *)__nw_create_backtrace_string();
            v21 = __nwlog_obj();
            v22 = type[0];
            v33 = os_log_type_enabled(v21, type[0]);
            if (!v32)
            {
              if (!v33)
                goto LABEL_66;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
              v23 = "%{public}s called with null definition, no backtrace";
              goto LABEL_65;
            }
            if (v33)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v32;
              v34 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_48:
              _os_log_impl(&dword_182FBE000, v21, v22, v34, buf, 0x16u);
              goto LABEL_49;
            }
            goto LABEL_49;
          }
          goto LABEL_66;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
        v20 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v66 = 0;
        if (!__nwlog_fault(v20, type, &v66))
          goto LABEL_66;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v21 = __nwlog_obj();
          v22 = type[0];
          if (!os_log_type_enabled(v21, type[0]))
            goto LABEL_66;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
          v23 = "%{public}s called with null parameters";
        }
        else if (v66)
        {
          v32 = (char *)__nw_create_backtrace_string();
          v21 = __nwlog_obj();
          v22 = type[0];
          v53 = os_log_type_enabled(v21, type[0]);
          if (v32)
          {
            if (v53)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v32;
              v34 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
              goto LABEL_48;
            }
            goto LABEL_49;
          }
          if (!v53)
            goto LABEL_66;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
          v23 = "%{public}s called with null parameters, no backtrace";
        }
        else
        {
          v21 = __nwlog_obj();
          v22 = type[0];
          if (!os_log_type_enabled(v21, type[0]))
            goto LABEL_66;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_test_access_options";
          v23 = "%{public}s called with null parameters, backtrace limit exceeded";
        }
LABEL_65:
        _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0xCu);
        goto LABEL_66;
      }
    }
    __nwlog_obj();
    identifier = a1->identifier;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    if (!identifier)
      identifier = (nw_protocol_identifier *)"invalid";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = identifier;
    *(_WORD *)&buf[22] = 2048;
    v68 = a1;
    v41 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (__nwlog_fault(v41, type, &v66))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v42 = __nwlog_obj();
        v43 = type[0];
        if (os_log_type_enabled(v42, type[0]))
        {
          v44 = a1->identifier;
          if (!v44)
            v44 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v44;
          *(_WORD *)&buf[22] = 2048;
          v68 = a1;
          v45 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_150:
          _os_log_impl(&dword_182FBE000, v42, v43, v45, buf, 0x20u);
        }
      }
      else if (v66)
      {
        v49 = (char *)__nw_create_backtrace_string();
        v42 = __nwlog_obj();
        v43 = type[0];
        v50 = os_log_type_enabled(v42, type[0]);
        if (v49)
        {
          if (v50)
          {
            v51 = a1->identifier;
            if (!v51)
              v51 = (nw_protocol_identifier *)"invalid";
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v51;
            *(_WORD *)&buf[22] = 2048;
            v68 = a1;
            LOWORD(v69[0]) = 2082;
            *(_QWORD *)((char *)v69 + 2) = v49;
            _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v49);
          goto LABEL_151;
        }
        if (v50)
        {
          v55 = a1->identifier;
          if (!v55)
            v55 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v55;
          *(_WORD *)&buf[22] = 2048;
          v68 = a1;
          v45 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
          goto LABEL_150;
        }
      }
      else
      {
        v42 = __nwlog_obj();
        v43 = type[0];
        if (os_log_type_enabled(v42, type[0]))
        {
          v54 = a1->identifier;
          if (!v54)
            v54 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v54;
          *(_WORD *)&buf[22] = 2048;
          v68 = a1;
          v45 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
          goto LABEL_150;
        }
      }
    }
LABEL_151:
    if (v41)
      free(v41);
    v6 = 0;
    goto LABEL_10;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
  v20 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v66 = 0;
  if (!__nwlog_fault(v20, type, &v66))
    goto LABEL_66;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type[0];
    if (!os_log_type_enabled(v21, type[0]))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
    v23 = "%{public}s called with null test";
    goto LABEL_65;
  }
  if (!v66)
  {
    v21 = __nwlog_obj();
    v22 = type[0];
    if (!os_log_type_enabled(v21, type[0]))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
    v23 = "%{public}s called with null test, backtrace limit exceeded";
    goto LABEL_65;
  }
  v32 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type[0];
  v48 = os_log_type_enabled(v21, type[0]);
  if (v32)
  {
    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v32;
      v34 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_48;
    }
LABEL_49:
    free(v32);
    if (!v20)
      return 0;
    goto LABEL_67;
  }
  if (v48)
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_add_input_handler";
    v23 = "%{public}s called with null test, no backtrace";
    goto LABEL_65;
  }
LABEL_66:
  if (v20)
LABEL_67:
    free(v20);
  return 0;
}

uint64_t nw_protocol_test_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  int v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *backtrace_string;
  _BOOL4 v14;
  const char *v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  nw_protocol *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      v4 = a3;
      v5 = nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, 0, 0);
      if (v4)
      {
        if (a1[1].output_handler_context)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v6 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_protocol_test_destroy";
            v21 = 2082;
            v22 = a1 + 2;
            _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s Cancelling output frame failure timer", buf, 0x16u);
          }
          nw_queue_cancel_source((uint64_t)a1[1].output_handler_context, v7);
          a1[1].output_handler_context = 0;
        }
        nw_protocol_destroy((uint64_t)&a1[1].output_handler, 0);
      }
      return v5;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_test_remove_input_handler";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_test_remove_input_handler";
        v12 = "%{public}s called with null test";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (!v17)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_test_remove_input_handler";
        v12 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_test_remove_input_handler";
        v12 = "%{public}s called with null test, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_test_remove_input_handler";
      v21 = 2082;
      v22 = (nw_protocol *)backtrace_string;
      v15 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_test_remove_input_handler";
  v9 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v9, &type, &v17))
    goto LABEL_37;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_test_remove_input_handler";
        v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v14 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_test_remove_input_handler";
        v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_test_remove_input_handler";
      v21 = 2082;
      v22 = (nw_protocol *)backtrace_string;
      v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_182FBE000, v10, v11, v15, buf, 0x16u);
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_37;
  }
  v10 = __nwlog_obj();
  v11 = type;
  if (os_log_type_enabled(v10, type))
  {
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_test_remove_input_handler";
    v12 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
  }
LABEL_37:
  if (v9)
    free(v9);
  return 0;
}

uint64_t nw_protocol_test_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, unsigned int a5, nw_frame_array_s *a6)
{
  void *handle;
  _QWORD *p_output_handler;
  nw_protocol **v9;
  uint64_t v11;
  size_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  nw_frame **tqh_last;
  NSObject *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  nw_frame **v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  nw_frame **v28;
  uint64_t v29;
  nw_frame **v30;
  uint64_t v31;
  nw_frame_array_s *v32;
  NSObject *v33;
  const char *v34;
  nw_protocol *output_handler;
  uint64_t v36;
  uint64_t *v37;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v39;
  uint64_t v40;
  void *v41;
  nw_protocol_callbacks *v42;
  void *v43;
  nw_protocol_callbacks *v44;
  uint64_t (*v45)(void);
  int v46;
  nw_protocol *v47;
  uint64_t v48;
  uint64_t v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  nw_protocol_callbacks *v60;
  nw_protocol_callbacks *v61;
  void (**v62)(_QWORD);
  const void *v63;
  nw_protocol_callbacks *v64;
  nw_protocol_callbacks *v65;
  void (**v66)(_QWORD);
  const void *v67;
  nw_protocol_callbacks *v68;
  char v69;
  nw_protocol_callbacks *v70;
  nw_protocol_callbacks *v71;
  void (*error)(nw_protocol *, nw_protocol *, uint64_t);
  char v73;
  nw_protocol_callbacks *v74;
  char v75;
  nw_protocol_callbacks *v76;
  nw_protocol_callbacks *v77;
  void (*disconnected)(nw_protocol *, nw_protocol *);
  nw_protocol *v79;
  char v80;
  nw_protocol_callbacks *v81;
  char v82;
  nw_protocol_callbacks *v83;
  nw_protocol_callbacks *v84;
  void (*disconnect)(nw_protocol *, nw_protocol *);
  nw_protocol *v86;
  nw_protocol *v87;
  nw_protocol_callbacks *v88;
  uint64_t v89;
  void *v90;
  nw_protocol_callbacks *v91;
  void *v92;
  nw_protocol_callbacks *v93;
  uint64_t (*get_input_frames)(nw_protocol *, nw_protocol *);
  int v95;
  BOOL v96;
  nw_protocol *v97;
  uint64_t v98;
  uint64_t v99;
  char v100;
  nw_frame *tqh_first;
  nw_frame *v102;
  char v103;
  pthread_once_t *v104;
  void (*v105)(void);
  void *v106;
  uint64_t v107;
  uint64_t v108;
  nw_protocol *v109;
  nw_frame *v110;
  uint64_t v111;
  nw_frame **v112;
  uint64_t v113;
  uint64_t *v114;
  NSObject *v115;
  void (*v116)(void);
  pthread_once_t *v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  nw_protocol *v121;
  nw_frame **v122;
  nw_protocol *v123;
  nw_protocol *v124;
  nw_frame **v125;
  nw_protocol *v126;
  uint64_t result;
  nw_protocol_callbacks *v128;
  nw_protocol_callbacks *v129;
  void (**v130)(_QWORD);
  const void *v131;
  nw_protocol_callbacks *v132;
  nw_protocol_callbacks *v133;
  void (**v134)(_QWORD);
  const void *v135;
  nw_protocol_callbacks *v136;
  nw_protocol_callbacks *v137;
  void (**v138)(_QWORD);
  const void *v139;
  NSObject *v140;
  os_log_type_t v141;
  const char *v142;
  char *v143;
  char *backtrace_string;
  _BOOL4 v146;
  const char *v147;
  NSObject *v148;
  void *v149;
  _BOOL4 v150;
  NSObject *v151;
  void *v152;
  NSObject *v153;
  void *v154;
  int v155;
  NSObject *v156;
  int v157;
  const char *v158;
  NSObject *v159;
  os_log_type_t v160;
  const char *v161;
  nw_protocol *v162;
  const char *v163;
  const char *v164;
  NSObject *v165;
  os_log_type_t v166;
  const char *v167;
  NSObject *v168;
  NSObject *v169;
  int v170;
  NSObject *v171;
  int v172;
  char *v173;
  _BOOL4 v174;
  const char *v175;
  NSObject *v176;
  os_log_type_t v177;
  uint32_t v178;
  _BOOL4 v179;
  const char *v180;
  NSObject *v181;
  NSObject *v182;
  _BOOL4 v183;
  const char *v184;
  const char *v185;
  NSObject *v186;
  os_log_type_t v187;
  const char *v188;
  const char *v189;
  NSObject *v190;
  uint64_t v191;
  nw_protocol_identifier *identifier;
  char *v193;
  NSObject *v194;
  os_log_type_t v195;
  nw_protocol_identifier *v196;
  const char *v197;
  uint64_t v198;
  nw_protocol_identifier *v199;
  char *v200;
  NSObject *v201;
  os_log_type_t v202;
  nw_protocol_identifier *v203;
  const char *v204;
  uint64_t v205;
  const char *name;
  char *v207;
  NSObject *v208;
  os_log_type_t v209;
  const char *v210;
  const char *v211;
  char *v212;
  NSObject *v213;
  _BOOL4 v214;
  const char *v215;
  NSObject *v216;
  NSObject *v217;
  os_log_type_t v218;
  uint32_t v219;
  NSObject *v220;
  const char *v221;
  const char *v222;
  char *v223;
  NSObject *v224;
  os_log_type_t v225;
  const char *v226;
  uint64_t v227;
  char *v228;
  NSObject *v229;
  os_log_type_t v230;
  const char *v231;
  char *v232;
  NSObject *v233;
  _BOOL4 v234;
  nw_protocol_identifier *v235;
  char *v236;
  NSObject *v237;
  _BOOL4 v238;
  nw_protocol_identifier *v239;
  char *v240;
  NSObject *v241;
  _BOOL4 v242;
  const char *v243;
  const char *v244;
  NSObject *v245;
  os_log_type_t v246;
  char *v247;
  _BOOL4 v248;
  char *v249;
  _BOOL4 v250;
  const char *v251;
  nw_protocol_identifier *v252;
  NSObject *v253;
  nw_protocol_identifier *v254;
  NSObject *v255;
  const char *v256;
  NSObject *v257;
  nw_protocol_identifier *v258;
  nw_protocol_identifier *v259;
  const char *v260;
  char *v261;
  NSObject *v262;
  os_log_type_t v263;
  const char *v264;
  char *v265;
  _BOOL4 v266;
  os_log_type_t type;
  os_log_type_t typea;
  os_log_t log;
  os_log_t loga;
  NSObject *logb;
  NSObject *logc;
  unsigned int v273;
  NSObject *v274;
  NSObject *v275;
  NSObject *v276;
  char *v277;
  os_log_type_t v278;
  int v279;
  char *v280;
  nw_protocol *v281;
  _QWORD v282[2];
  uint64_t (*v283)(_QWORD *);
  void *v284;
  _BYTE *v285;
  uint64_t *v286;
  nw_protocol **v287;
  nw_frame_array_s *v288;
  _QWORD v289[2];
  uint64_t (*v290)(_QWORD *);
  void *v291;
  _BYTE *v292;
  uint64_t *v293;
  nw_frame_array_s *v294;
  _QWORD v295[2];
  uint64_t (*v296)(_QWORD *);
  void *v297;
  _QWORD *v298;
  nw_protocol *v299;
  nw_protocol *v300;
  _QWORD v301[2];
  uint64_t (*v302)(_QWORD *);
  void *v303;
  _BYTE *v304;
  uint64_t *v305;
  _QWORD *v306;
  nw_frame_array_s *v307;
  _QWORD v308[2];
  uint64_t (*v309)(_QWORD *);
  void *v310;
  _BYTE *v311;
  uint64_t *v312;
  _QWORD *v313;
  nw_frame_array_s *v314;
  uint64_t v315;
  uint64_t *v316;
  uint64_t v317;
  int v318;
  char v319;
  os_log_type_t v320;
  os_log_type_t v321[8];
  char v322;
  _BYTE v323[24];
  _BYTE v324[24];
  _BYTE *v325;
  _BYTE buf[24];
  __n128 (*v327)(uint64_t, uint64_t);
  uint64_t (*v328)();
  _QWORD v329[3];
  _BYTE v330[12];
  __int16 v331;
  nw_protocol *v332;
  __int16 v333;
  nw_protocol *v334;
  __int16 v335;
  char *v336;
  uint64_t v337;

  v337 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
    v143 = (char *)_os_log_send_and_compose_impl();
    v323[0] = 16;
    v330[0] = 0;
    if (!__nwlog_fault(v143, v323, v330))
      goto LABEL_272;
    if (v323[0] == 17)
    {
      v140 = __nwlog_obj();
      v141 = v323[0];
      if (os_log_type_enabled(v140, (os_log_type_t)v323[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
        v142 = "%{public}s called with null protocol";
LABEL_271:
        _os_log_impl(&dword_182FBE000, v140, v141, v142, buf, 0xCu);
      }
LABEL_272:
      if (v143)
        free(v143);
      return 0;
    }
    if (!v330[0])
    {
      v140 = __nwlog_obj();
      v141 = v323[0];
      if (os_log_type_enabled(v140, (os_log_type_t)v323[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
        v142 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v140 = __nwlog_obj();
    v141 = v323[0];
    v146 = os_log_type_enabled(v140, (os_log_type_t)v323[0]);
    if (!backtrace_string)
    {
      if (v146)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
        v142 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    if (v146)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v147 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_235:
      _os_log_impl(&dword_182FBE000, v140, v141, v147, buf, 0x16u);
    }
LABEL_236:
    free(backtrace_string);
    goto LABEL_272;
  }
  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle)
    v9 = &a1[1].output_handler;
  else
    v9 = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
    v143 = (char *)_os_log_send_and_compose_impl();
    v323[0] = 16;
    v330[0] = 0;
    if (!__nwlog_fault(v143, v323, v330))
      goto LABEL_272;
    if (v323[0] == 17)
    {
      v140 = __nwlog_obj();
      v141 = v323[0];
      if (os_log_type_enabled(v140, (os_log_type_t)v323[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
        v142 = "%{public}s called with null test";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    if (!v330[0])
    {
      v140 = __nwlog_obj();
      v141 = v323[0];
      if (os_log_type_enabled(v140, (os_log_type_t)v323[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
        v142 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v140 = __nwlog_obj();
    v141 = v323[0];
    v150 = os_log_type_enabled(v140, (os_log_type_t)v323[0]);
    if (!backtrace_string)
    {
      if (v150)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
        v142 = "%{public}s called with null test, no backtrace";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    if (v150)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v147 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_235;
    }
    goto LABEL_236;
  }
  v11 = *p_output_handler;
  if ((*p_output_handler & 0x400) != 0)
  {
    if (a3 <= 0xA)
      v14 = 10;
    else
      v14 = a3;
    v15 = malloc_type_malloc(v14, 0xF2B69DE5uLL);
    if (v15)
    {
      v16 = (uint64_t)v15;
    }
    else
    {
      v148 = __nwlog_obj();
      os_log_type_enabled(v148, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "strict_malloc";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v14;
      v149 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort((uint64_t)v149);
      if ((_DWORD)result)
        goto LABEL_479;
      free(v149);
      v16 = 0;
    }
    v17 = nw_frame_create(0, v16, v14, (uint64_t)__nw_frame_malloc_finalizer, 0);
    v18 = 1;
    nw_frame_set_buffer_used_malloc(v17, 1);
    *(_QWORD *)(v17 + 32) = 0;
    tqh_last = a6->tqh_last;
    *(_QWORD *)(v17 + 40) = tqh_last;
    *tqh_last = (nw_frame *)v17;
    a6->tqh_last = (nw_frame **)(v17 + 32);
    if (gLogDatapath)
    {
      v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 2;
        _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Returning input frame of length 10 with empty metadata", buf, 0x16u);
      }
    }
    return v18;
  }
  if ((v11 & 0x800) == 0)
  {
    if ((v11 & 2) != 0)
    {
      if (gLogDatapath)
      {
        v168 = __nwlog_obj();
        if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 2;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v327) = a4;
          _os_log_impl(&dword_182FBE000, v168, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Overriding max bytes of %u to UINT32_MAX", buf, 0x1Cu);
        }
      }
    }
    else if ((v11 & 0x40) != 0)
    {
      if (gLogDatapath)
      {
        v181 = __nwlog_obj();
        if (os_log_type_enabled(v181, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_test_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 2;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v327) = a4;
          _os_log_impl(&dword_182FBE000, v181, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Overriding max bytes of %u to 1", buf, 0x1Cu);
        }
      }
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3802000000;
    v327 = __Block_byref_object_copy__24;
    v328 = __Block_byref_object_dispose__25;
    v329[0] = 0;
    v329[1] = v329;
    v31 = *p_output_handler;
    v279 = a4;
    if ((*p_output_handler & 4) != 0)
    {
      if (!gLogDatapath)
        goto LABEL_37;
      v33 = __nwlog_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        goto LABEL_37;
      *(_DWORD *)v323 = 136446466;
      *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v323[12] = 2082;
      *(_QWORD *)&v323[14] = a1 + 2;
      v34 = "%{public}s %{public}s Splitting incoming frames";
    }
    else if ((v31 & 0x10) != 0)
    {
      if (!gLogDatapath)
        goto LABEL_37;
      v33 = __nwlog_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        goto LABEL_37;
      *(_DWORD *)v323 = 136446466;
      *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v323[12] = 2082;
      *(_QWORD *)&v323[14] = a1 + 2;
      v34 = "%{public}s %{public}s Using custom frame allocator on incoming frames";
    }
    else
    {
      v32 = a6;
      if ((v31 & 0x20) == 0)
        goto LABEL_38;
      if (!gLogDatapath || (v33 = __nwlog_obj(), !os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)))
      {
LABEL_37:
        v32 = (nw_frame_array_s *)(*(_QWORD *)&buf[8] + 40);
LABEL_38:
        output_handler = a1->output_handler;
        v281 = output_handler;
        if (!output_handler)
        {
          v36 = 0;
          v37 = &v315;
          v315 = 0;
          v316 = &v315;
          v318 = 0;
          v317 = 0x2000000000;
          goto LABEL_62;
        }
        if (output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          v315 = 0;
          v36 = 255;
        }
        else
        {
          v36 = 0;
          v315 = 0;
        }
        v37 = &v315;
        v318 = 0;
        v316 = &v315;
        v317 = 0x2000000000;
        v39 = output_handler->callbacks;
        if (!v39)
        {
LABEL_62:
          v48 = *p_output_handler;
          v49 = MEMORY[0x1E0C809B0];
          if ((*p_output_handler & 4) != 0)
          {
            *((_DWORD *)v37 + 6) = 0;
            v308[0] = v49;
            v308[1] = 0x40000000;
            v309 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v310 = &unk_1E14AC070;
            v313 = p_output_handler;
            v314 = a6;
            v311 = buf;
            v312 = &v315;
            v51 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
            do
            {
              if (!v51)
                break;
              v52 = *(_QWORD *)(v51 + 32);
              v53 = v309(v308);
              v51 = v52;
            }
            while ((v53 & 1) != 0);
          }
          else if ((v48 & 0x10) != 0)
          {
            *((_DWORD *)v37 + 6) = 0;
            v301[0] = v49;
            v301[1] = 0x40000000;
            v302 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_28;
            v303 = &unk_1E14AC098;
            v306 = p_output_handler;
            v307 = a6;
            v304 = buf;
            v305 = &v315;
            v54 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
            do
            {
              if (!v54)
                break;
              v55 = *(_QWORD *)(v54 + 32);
              v56 = v302(v301);
              v54 = v55;
            }
            while ((v56 & 1) != 0);
          }
          else
          {
            if ((v48 & 0x20) == 0)
            {
              if ((v48 & 0x1000) == 0)
                goto LABEL_137;
              if (a2)
              {
                if (a2->handle == &nw_protocol_ref_counted_handle)
                {
                  v68 = a2[1].callbacks;
                  if (v68)
                    a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v68->add_input_handler + 1);
                  *(_QWORD *)v330 = a2;
                  v50 = v330[8] | 1;
                }
                else
                {
                  *(_QWORD *)v330 = a2;
                  v50 = v330[8] & 0xFE;
                }
                v330[8] = v50;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  v70 = a1[1].callbacks;
                  if (v70)
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v70->add_input_handler + 1);
                  *(_QWORD *)v321 = a1;
                  v69 = v322 | 1;
                }
                else
                {
                  *(_QWORD *)v321 = a1;
                  v69 = v322 & 0xFE;
                }
                v322 = v69;
                v71 = a2->callbacks;
                if (v71)
                {
                  error = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v71->error;
                  if (error)
                  {
                    error(a2, a1, 14);
                    goto LABEL_108;
                  }
                }
                v191 = v36;
                __nwlog_obj();
                identifier = a2->identifier;
                *(_DWORD *)v323 = 136446722;
                *(_QWORD *)&v323[4] = "__nw_protocol_error";
                if (!identifier)
                  identifier = (nw_protocol_identifier *)"invalid";
                *(_WORD *)&v323[12] = 2082;
                *(_QWORD *)&v323[14] = identifier;
                *(_WORD *)&v323[22] = 2048;
                *(_QWORD *)v324 = a2;
                v193 = (char *)_os_log_send_and_compose_impl();
                v320 = OS_LOG_TYPE_ERROR;
                v319 = 0;
                if (__nwlog_fault(v193, &v320, &v319))
                {
                  if (v320 == OS_LOG_TYPE_FAULT)
                  {
                    v194 = __nwlog_obj();
                    v195 = v320;
                    if (os_log_type_enabled(v194, v320))
                    {
                      v196 = a2->identifier;
                      if (!v196)
                        v196 = (nw_protocol_identifier *)"invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_error";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v196;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = a2;
                      v197 = "%{public}s protocol %{public}s (%p) has invalid error callback";
LABEL_411:
                      v253 = v194;
LABEL_412:
                      _os_log_impl(&dword_182FBE000, v253, v195, v197, v323, 0x20u);
                    }
                  }
                  else if (v319)
                  {
                    v232 = (char *)__nw_create_backtrace_string();
                    v233 = __nwlog_obj();
                    v195 = v320;
                    v274 = v233;
                    v234 = os_log_type_enabled(v233, v320);
                    if (v232)
                    {
                      if (v234)
                      {
                        v235 = a2->identifier;
                        if (!v235)
                          v235 = (nw_protocol_identifier *)"invalid";
                        *(_DWORD *)v323 = 136446978;
                        *(_QWORD *)&v323[4] = "__nw_protocol_error";
                        *(_WORD *)&v323[12] = 2082;
                        *(_QWORD *)&v323[14] = v235;
                        *(_WORD *)&v323[22] = 2048;
                        *(_QWORD *)v324 = a2;
                        *(_WORD *)&v324[8] = 2082;
                        *(_QWORD *)&v324[10] = v232;
                        _os_log_impl(&dword_182FBE000, v274, v195, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", v323, 0x2Au);
                      }
                      free(v232);
                      goto LABEL_413;
                    }
                    if (v234)
                    {
                      v258 = a2->identifier;
                      if (!v258)
                        v258 = (nw_protocol_identifier *)"invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_error";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v258;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = a2;
                      v197 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
                      v253 = v274;
                      goto LABEL_412;
                    }
                  }
                  else
                  {
                    v194 = __nwlog_obj();
                    v195 = v320;
                    if (os_log_type_enabled(v194, v320))
                    {
                      v252 = a2->identifier;
                      if (!v252)
                        v252 = (nw_protocol_identifier *)"invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_error";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v252;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = a2;
                      v197 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
                      goto LABEL_411;
                    }
                  }
                }
LABEL_413:
                if (v193)
                  free(v193);
                v36 = v191;
                v49 = MEMORY[0x1E0C809B0];
LABEL_108:
                nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v321);
                nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v330);
                if (a2->handle == &nw_protocol_ref_counted_handle)
                {
                  v74 = a2[1].callbacks;
                  if (v74)
                    a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v74->add_input_handler + 1);
                  *(_QWORD *)v330 = a2;
                  v73 = v330[8] | 1;
                }
                else
                {
                  *(_QWORD *)v330 = a2;
                  v73 = v330[8] & 0xFE;
                }
                v330[8] = v73;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  v76 = a1[1].callbacks;
                  if (v76)
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v76->add_input_handler + 1);
                  *(_QWORD *)v321 = a1;
                  v75 = v322 | 1;
                }
                else
                {
                  *(_QWORD *)v321 = a1;
                  v75 = v322 & 0xFE;
                }
                v322 = v75;
                v77 = a2->callbacks;
                if (v77)
                {
                  disconnected = (void (*)(nw_protocol *, nw_protocol *))v77->disconnected;
                  if (disconnected)
                  {
                    disconnected(a2, a1);
LABEL_121:
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v321);
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v330);
                    goto LABEL_122;
                  }
                }
                v198 = v36;
                __nwlog_obj();
                v199 = a2->identifier;
                *(_DWORD *)v323 = 136446722;
                *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                if (!v199)
                  v199 = (nw_protocol_identifier *)"invalid";
                *(_WORD *)&v323[12] = 2082;
                *(_QWORD *)&v323[14] = v199;
                *(_WORD *)&v323[22] = 2048;
                *(_QWORD *)v324 = a2;
                v200 = (char *)_os_log_send_and_compose_impl();
                v320 = OS_LOG_TYPE_ERROR;
                v319 = 0;
                if (__nwlog_fault(v200, &v320, &v319))
                {
                  if (v320 == OS_LOG_TYPE_FAULT)
                  {
                    v201 = __nwlog_obj();
                    v202 = v320;
                    if (os_log_type_enabled(v201, v320))
                    {
                      v203 = a2->identifier;
                      if (!v203)
                        v203 = (nw_protocol_identifier *)"invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v203;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = a2;
                      v204 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
LABEL_420:
                      v255 = v201;
LABEL_421:
                      _os_log_impl(&dword_182FBE000, v255, v202, v204, v323, 0x20u);
                    }
                  }
                  else if (v319)
                  {
                    v236 = (char *)__nw_create_backtrace_string();
                    v237 = __nwlog_obj();
                    v202 = v320;
                    v275 = v237;
                    v238 = os_log_type_enabled(v237, v320);
                    if (v236)
                    {
                      if (v238)
                      {
                        v239 = a2->identifier;
                        if (!v239)
                          v239 = (nw_protocol_identifier *)"invalid";
                        *(_DWORD *)v323 = 136446978;
                        *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                        *(_WORD *)&v323[12] = 2082;
                        *(_QWORD *)&v323[14] = v239;
                        *(_WORD *)&v323[22] = 2048;
                        *(_QWORD *)v324 = a2;
                        *(_WORD *)&v324[8] = 2082;
                        *(_QWORD *)&v324[10] = v236;
                        _os_log_impl(&dword_182FBE000, v275, v202, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", v323, 0x2Au);
                      }
                      free(v236);
                      goto LABEL_422;
                    }
                    if (v238)
                    {
                      v259 = a2->identifier;
                      if (!v259)
                        v259 = (nw_protocol_identifier *)"invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v259;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = a2;
                      v204 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
                      v255 = v275;
                      goto LABEL_421;
                    }
                  }
                  else
                  {
                    v201 = __nwlog_obj();
                    v202 = v320;
                    if (os_log_type_enabled(v201, v320))
                    {
                      v254 = a2->identifier;
                      if (!v254)
                        v254 = (nw_protocol_identifier *)"invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v254;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = a2;
                      v204 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
                      goto LABEL_420;
                    }
                  }
                }
LABEL_422:
                if (v200)
                  free(v200);
                v36 = v198;
                v49 = MEMORY[0x1E0C809B0];
                goto LABEL_121;
              }
              v273 = v36;
              __nwlog_obj();
              *(_DWORD *)v323 = 136446210;
              *(_QWORD *)&v323[4] = "__nw_protocol_error";
              v223 = (char *)_os_log_send_and_compose_impl();
              v330[0] = 16;
              v321[0] = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v223, v330, v321))
              {
                if (v330[0] == 17)
                {
                  v224 = __nwlog_obj();
                  v225 = v330[0];
                  if (!os_log_type_enabled(v224, (os_log_type_t)v330[0]))
                    goto LABEL_453;
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_error";
                  v226 = "%{public}s called with null protocol";
LABEL_452:
                  _os_log_impl(&dword_182FBE000, v224, v225, v226, v323, 0xCu);
                  goto LABEL_453;
                }
                if (v321[0] == OS_LOG_TYPE_DEFAULT)
                {
                  v224 = __nwlog_obj();
                  v225 = v330[0];
                  if (!os_log_type_enabled(v224, (os_log_type_t)v330[0]))
                    goto LABEL_453;
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_error";
                  v226 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_452;
                }
                v247 = (char *)__nw_create_backtrace_string();
                v224 = __nwlog_obj();
                v225 = v330[0];
                v248 = os_log_type_enabled(v224, (os_log_type_t)v330[0]);
                if (!v247)
                {
                  if (!v248)
                    goto LABEL_453;
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_error";
                  v226 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_452;
                }
                if (v248)
                {
                  *(_DWORD *)v323 = 136446466;
                  *(_QWORD *)&v323[4] = "__nw_protocol_error";
                  *(_WORD *)&v323[12] = 2082;
                  *(_QWORD *)&v323[14] = v247;
                  _os_log_impl(&dword_182FBE000, v224, v225, "%{public}s called with null protocol, dumping backtrace:%{public}s", v323, 0x16u);
                }
                free(v247);
              }
LABEL_453:
              if (v223)
                free(v223);
              __nwlog_obj();
              *(_DWORD *)v323 = 136446210;
              *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
              v261 = (char *)_os_log_send_and_compose_impl();
              v330[0] = 16;
              v321[0] = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v261, v330, v321))
                goto LABEL_476;
              if (v330[0] == 17)
              {
                v262 = __nwlog_obj();
                v263 = v330[0];
                if (os_log_type_enabled(v262, (os_log_type_t)v330[0]))
                {
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                  v264 = "%{public}s called with null protocol";
LABEL_475:
                  _os_log_impl(&dword_182FBE000, v262, v263, v264, v323, 0xCu);
                }
              }
              else if (v321[0])
              {
                v265 = (char *)__nw_create_backtrace_string();
                v262 = __nwlog_obj();
                v263 = v330[0];
                v266 = os_log_type_enabled(v262, (os_log_type_t)v330[0]);
                if (v265)
                {
                  if (v266)
                  {
                    *(_DWORD *)v323 = 136446466;
                    *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                    *(_WORD *)&v323[12] = 2082;
                    *(_QWORD *)&v323[14] = v265;
                    _os_log_impl(&dword_182FBE000, v262, v263, "%{public}s called with null protocol, dumping backtrace:%{public}s", v323, 0x16u);
                  }
                  free(v265);
                  goto LABEL_476;
                }
                if (v266)
                {
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                  v264 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_475;
                }
              }
              else
              {
                v262 = __nwlog_obj();
                v263 = v330[0];
                if (os_log_type_enabled(v262, (os_log_type_t)v330[0]))
                {
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_disconnected";
                  v264 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_475;
                }
              }
LABEL_476:
              if (v261)
                free(v261);
              v36 = v273;
              v49 = MEMORY[0x1E0C809B0];
LABEL_122:
              v79 = a1->output_handler;
              if (v79)
              {
                if (v79->handle == &nw_protocol_ref_counted_handle)
                {
                  v81 = v79[1].callbacks;
                  if (v81)
                    v79[1].callbacks = (nw_protocol_callbacks *)((char *)&v81->add_input_handler + 1);
                  *(_QWORD *)v330 = v79;
                  v80 = v330[8] | 1;
                }
                else
                {
                  *(_QWORD *)v330 = a1->output_handler;
                  v80 = v330[8] & 0xFE;
                }
                v330[8] = v80;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  v83 = a1[1].callbacks;
                  if (v83)
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v83->add_input_handler + 1);
                  *(_QWORD *)v321 = a1;
                  v82 = v322 | 1;
                }
                else
                {
                  *(_QWORD *)v321 = a1;
                  v82 = v322 & 0xFE;
                }
                v322 = v82;
                v84 = v79->callbacks;
                if (v84)
                {
                  disconnect = (void (*)(nw_protocol *, nw_protocol *))v84->disconnect;
                  if (disconnect)
                  {
                    disconnect(v79, a1);
LABEL_136:
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v321);
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v330);
                    goto LABEL_137;
                  }
                }
                v205 = v36;
                __nwlog_obj();
                name = v79->identifier->name;
                *(_DWORD *)v323 = 136446722;
                *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                if (!name)
                  name = "invalid";
                *(_WORD *)&v323[12] = 2082;
                *(_QWORD *)&v323[14] = name;
                *(_WORD *)&v323[22] = 2048;
                *(_QWORD *)v324 = v79;
                v207 = (char *)_os_log_send_and_compose_impl();
                v320 = OS_LOG_TYPE_ERROR;
                v319 = 0;
                if (__nwlog_fault(v207, &v320, &v319))
                {
                  if (v320 == OS_LOG_TYPE_FAULT)
                  {
                    v208 = __nwlog_obj();
                    v209 = v320;
                    if (os_log_type_enabled(v208, v320))
                    {
                      v210 = v79->identifier->name;
                      if (!v210)
                        v210 = "invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v210;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = v79;
                      v211 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
LABEL_429:
                      v257 = v208;
LABEL_430:
                      _os_log_impl(&dword_182FBE000, v257, v209, v211, v323, 0x20u);
                    }
                  }
                  else if (v319)
                  {
                    v240 = (char *)__nw_create_backtrace_string();
                    v241 = __nwlog_obj();
                    v209 = v320;
                    v276 = v241;
                    v242 = os_log_type_enabled(v241, v320);
                    if (v240)
                    {
                      if (v242)
                      {
                        v243 = v79->identifier->name;
                        if (!v243)
                          v243 = "invalid";
                        *(_DWORD *)v323 = 136446978;
                        *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                        *(_WORD *)&v323[12] = 2082;
                        *(_QWORD *)&v323[14] = v243;
                        *(_WORD *)&v323[22] = 2048;
                        *(_QWORD *)v324 = v79;
                        *(_WORD *)&v324[8] = 2082;
                        *(_QWORD *)&v324[10] = v240;
                        _os_log_impl(&dword_182FBE000, v276, v209, "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s", v323, 0x2Au);
                      }
                      free(v240);
                      goto LABEL_431;
                    }
                    if (v242)
                    {
                      v260 = v79->identifier->name;
                      if (!v260)
                        v260 = "invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v260;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = v79;
                      v211 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
                      v257 = v276;
                      goto LABEL_430;
                    }
                  }
                  else
                  {
                    v208 = __nwlog_obj();
                    v209 = v320;
                    if (os_log_type_enabled(v208, v320))
                    {
                      v256 = v79->identifier->name;
                      if (!v256)
                        v256 = "invalid";
                      *(_DWORD *)v323 = 136446722;
                      *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                      *(_WORD *)&v323[12] = 2082;
                      *(_QWORD *)&v323[14] = v256;
                      *(_WORD *)&v323[22] = 2048;
                      *(_QWORD *)v324 = v79;
                      v211 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
                      goto LABEL_429;
                    }
                  }
                }
LABEL_431:
                if (v207)
                  free(v207);
                v36 = v205;
                v49 = MEMORY[0x1E0C809B0];
                goto LABEL_136;
              }
              v227 = v36;
              __nwlog_obj();
              *(_DWORD *)v323 = 136446210;
              *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
              v228 = (char *)_os_log_send_and_compose_impl();
              v330[0] = 16;
              v321[0] = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v228, v330, v321))
              {
                if (v330[0] == 17)
                {
                  v229 = __nwlog_obj();
                  v230 = v330[0];
                  if (!os_log_type_enabled(v229, (os_log_type_t)v330[0]))
                    goto LABEL_469;
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                  v231 = "%{public}s called with null protocol";
LABEL_468:
                  _os_log_impl(&dword_182FBE000, v229, v230, v231, v323, 0xCu);
                  goto LABEL_469;
                }
                if (v321[0] == OS_LOG_TYPE_DEFAULT)
                {
                  v229 = __nwlog_obj();
                  v230 = v330[0];
                  if (!os_log_type_enabled(v229, (os_log_type_t)v330[0]))
                    goto LABEL_469;
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                  v231 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_468;
                }
                v249 = (char *)__nw_create_backtrace_string();
                v229 = __nwlog_obj();
                v230 = v330[0];
                v250 = os_log_type_enabled(v229, (os_log_type_t)v330[0]);
                if (!v249)
                {
                  if (!v250)
                    goto LABEL_469;
                  *(_DWORD *)v323 = 136446210;
                  *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                  v231 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_468;
                }
                if (v250)
                {
                  *(_DWORD *)v323 = 136446466;
                  *(_QWORD *)&v323[4] = "__nw_protocol_disconnect";
                  *(_WORD *)&v323[12] = 2082;
                  *(_QWORD *)&v323[14] = v249;
                  _os_log_impl(&dword_182FBE000, v229, v230, "%{public}s called with null protocol, dumping backtrace:%{public}s", v323, 0x16u);
                }
                free(v249);
              }
LABEL_469:
              if (v228)
                free(v228);
              v36 = v227;
              v49 = MEMORY[0x1E0C809B0];
              v86 = (nw_protocol *)*p_output_handler;
              if ((*p_output_handler & 0x40) == 0)
                goto LABEL_162;
LABEL_138:
              if ((BYTE5(a1[3].identifier) & 2) != 0)
              {
                v87 = v281;
                if (gLogDatapath)
                {
                  v182 = __nwlog_obj();
                  v183 = os_log_type_enabled(v182, OS_LOG_TYPE_DEBUG);
                  v87 = v281;
                  if (v183)
                  {
                    *(_DWORD *)v323 = 136446722;
                    *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v323[12] = 2082;
                    *(_QWORD *)&v323[14] = a1 + 2;
                    *(_WORD *)&v323[22] = 1024;
                    *(_DWORD *)v324 = v279;
                    _os_log_impl(&dword_182FBE000, v182, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Seen disconnected, performing a final read with the original maximum bytes %u", v323, 0x1Cu);
                    v87 = v281;
                  }
                }
                *(_QWORD *)v323 = 0;
                *(_QWORD *)&v323[8] = v323;
                *(_QWORD *)&v323[16] = 0x3802000000;
                *(_QWORD *)v324 = __Block_byref_object_copy__24;
                *(_QWORD *)&v324[8] = __Block_byref_object_dispose__25;
                *(_QWORD *)&v324[16] = 0;
                v325 = &v324[16];
                if (!v87)
                  goto LABEL_161;
                v88 = v281->callbacks;
                if (!v88 || !v88->get_output_frames)
                  goto LABEL_161;
                v89 = v49;
                v90 = v281->handle;
                if (v90 == &nw_protocol_ref_counted_handle)
                {
                  v91 = v281[1].callbacks;
                  if (v91)
                    v281[1].callbacks = (nw_protocol_callbacks *)((char *)&v91->add_input_handler + 1);
                }
                v92 = a1->handle;
                if (v92 == &nw_protocol_ref_counted_handle)
                {
                  v93 = a1[1].callbacks;
                  if (v93)
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v93->add_input_handler + 1);
                }
                get_input_frames = (uint64_t (*)(nw_protocol *, nw_protocol *))v88->get_input_frames;
                if (get_input_frames)
                {
                  v95 = get_input_frames(v281, a1);
LABEL_151:
                  v96 = v92 == &nw_protocol_ref_counted_handle;
                  v49 = v89;
                  if (v96 && a1->handle == &nw_protocol_ref_counted_handle)
                  {
                    v132 = a1[1].callbacks;
                    if (v132)
                    {
                      v133 = (nw_protocol_callbacks *)((char *)v132 - 1);
                      a1[1].callbacks = v133;
                      if (!v133)
                      {
                        v134 = *(void (***)(_QWORD))a1[1].flow_id;
                        if (v134)
                        {
                          *(_QWORD *)a1[1].flow_id = 0;
                          v134[2](v134);
                          _Block_release(v134);
                        }
                        if ((a1[1].flow_id[8] & 1) != 0)
                        {
                          v135 = *(const void **)a1[1].flow_id;
                          if (v135)
                            _Block_release(v135);
                        }
                        free(a1);
                      }
                    }
                  }
                  v97 = v281;
                  if (v90 == &nw_protocol_ref_counted_handle && v281->handle == &nw_protocol_ref_counted_handle)
                  {
                    v136 = v281[1].callbacks;
                    if (v136)
                    {
                      v137 = (nw_protocol_callbacks *)((char *)v136 - 1);
                      v281[1].callbacks = v137;
                      if (!v137)
                      {
                        v138 = *(void (***)(_QWORD))v281[1].flow_id;
                        if (v138)
                        {
                          *(_QWORD *)v281[1].flow_id = 0;
                          v138[2](v138);
                          _Block_release(v138);
                          v97 = v281;
                        }
                        if ((v97[1].flow_id[8] & 1) != 0)
                        {
                          v139 = *(const void **)v97[1].flow_id;
                          if (v139)
                          {
                            _Block_release(v139);
                            v97 = v281;
                          }
                        }
                        free(v97);
                      }
                    }
                  }
                  if (v95)
                  {
                    if (gLogDatapath)
                    {
                      v190 = __nwlog_obj();
                      if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)v330 = 136446722;
                        *(_QWORD *)&v330[4] = "nw_protocol_test_get_input_frames";
                        v331 = 2082;
                        v332 = a1 + 2;
                        v333 = 1024;
                        LODWORD(v334) = v95;
                        _os_log_impl(&dword_182FBE000, v190, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got back %u final frames", v330, 0x1Cu);
                      }
                    }
                    v289[0] = v89;
                    v289[1] = 0x40000000;
                    v290 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_32;
                    v291 = &unk_1E14AC0E0;
                    v292 = v323;
                    v293 = &v315;
                    v294 = a6;
                    v98 = *(_QWORD *)(*(_QWORD *)&v323[8] + 40);
                    do
                    {
                      if (!v98)
                        break;
                      v99 = *(_QWORD *)(v98 + 32);
                      v100 = v290(v289);
                      v98 = v99;
                    }
                    while ((v100 & 1) != 0);
                  }
LABEL_161:
                  _Block_object_dispose(v323, 8);
                  v86 = (nw_protocol *)*p_output_handler;
                  goto LABEL_162;
                }
                __nwlog_obj();
                v184 = v281->identifier->name;
                *(_DWORD *)v330 = 136446722;
                *(_QWORD *)&v330[4] = "__nw_protocol_get_input_frames";
                if (!v184)
                  v184 = "invalid";
                v331 = 2082;
                v332 = (nw_protocol *)v184;
                v333 = 2048;
                v334 = v281;
                v185 = (const char *)_os_log_send_and_compose_impl();
                v321[0] = OS_LOG_TYPE_ERROR;
                v320 = OS_LOG_TYPE_DEFAULT;
                v280 = (char *)v185;
                if (__nwlog_fault(v185, v321, &v320))
                {
                  if (v321[0] == OS_LOG_TYPE_FAULT)
                  {
                    v186 = __nwlog_obj();
                    v187 = v321[0];
                    if (os_log_type_enabled(v186, v321[0]))
                    {
                      v188 = v281->identifier->name;
                      if (!v188)
                        v188 = "invalid";
                      *(_DWORD *)v330 = 136446722;
                      *(_QWORD *)&v330[4] = "__nw_protocol_get_input_frames";
                      v331 = 2082;
                      v332 = (nw_protocol *)v188;
                      v333 = 2048;
                      v334 = v281;
                      v189 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_388:
                      v245 = v186;
                      v246 = v187;
LABEL_389:
                      _os_log_impl(&dword_182FBE000, v245, v246, v189, v330, 0x20u);
                    }
                  }
                  else if (v320)
                  {
                    v212 = (char *)__nw_create_backtrace_string();
                    v213 = __nwlog_obj();
                    v278 = v321[0];
                    v214 = os_log_type_enabled(v213, v321[0]);
                    if (v212)
                    {
                      if (v214)
                      {
                        v215 = v281->identifier->name;
                        if (!v215)
                          v215 = "invalid";
                        *(_DWORD *)v330 = 136446978;
                        *(_QWORD *)&v330[4] = "__nw_protocol_get_input_frames";
                        v331 = 2082;
                        v332 = (nw_protocol *)v215;
                        v333 = 2048;
                        v334 = v281;
                        v335 = 2082;
                        v336 = v212;
                        _os_log_impl(&dword_182FBE000, v213, v278, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", v330, 0x2Au);
                      }
                      free(v212);
                      goto LABEL_390;
                    }
                    if (v214)
                    {
                      v251 = v281->identifier->name;
                      if (!v251)
                        v251 = "invalid";
                      *(_DWORD *)v330 = 136446722;
                      *(_QWORD *)&v330[4] = "__nw_protocol_get_input_frames";
                      v331 = 2082;
                      v332 = (nw_protocol *)v251;
                      v333 = 2048;
                      v334 = v281;
                      v189 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
                      v245 = v213;
                      v246 = v278;
                      goto LABEL_389;
                    }
                  }
                  else
                  {
                    v186 = __nwlog_obj();
                    v187 = v321[0];
                    if (os_log_type_enabled(v186, v321[0]))
                    {
                      v244 = v281->identifier->name;
                      if (!v244)
                        v244 = "invalid";
                      *(_DWORD *)v330 = 136446722;
                      *(_QWORD *)&v330[4] = "__nw_protocol_get_input_frames";
                      v331 = 2082;
                      v332 = (nw_protocol *)v244;
                      v333 = 2048;
                      v334 = v281;
                      v189 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
                      goto LABEL_388;
                    }
                  }
                }
LABEL_390:
                if (v280)
                  free(v280);
                v95 = 0;
                goto LABEL_151;
              }
LABEL_162:
              if (((unsigned __int16)v86 & 0x4000) != 0)
              {
                if (gLogDatapath)
                {
                  v169 = __nwlog_obj();
                  if (os_log_type_enabled(v169, OS_LOG_TYPE_DEBUG))
                  {
                    v170 = *((_DWORD *)v316 + 6);
                    *(_DWORD *)v323 = 136446722;
                    *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v323[12] = 2082;
                    *(_QWORD *)&v323[14] = a1 + 2;
                    *(_WORD *)&v323[22] = 1024;
                    *(_DWORD *)v324 = v170;
                    _os_log_impl(&dword_182FBE000, v169, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s before interleaving empty frames, had %u frames", v323, 0x1Cu);
                  }
                }
                *(_QWORD *)v323 = 0;
                *(_QWORD *)&v323[8] = v323;
                *(_QWORD *)&v323[16] = 0x2000000000;
                *(_QWORD *)v324 = 0;
                v282[0] = v49;
                v282[1] = 0x40000000;
                v283 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_34;
                v284 = &unk_1E14AC108;
                v287 = v9;
                v288 = a6;
                v285 = v323;
                v286 = &v315;
                tqh_first = a6->tqh_first;
                do
                {
                  if (!tqh_first)
                    break;
                  v102 = (nw_frame *)*((_QWORD *)tqh_first + 4);
                  v103 = v283(v282);
                  tqh_first = v102;
                }
                while ((v103 & 1) != 0);
                _Block_object_dispose(v323, 8);
                v86 = *v9;
              }
              if (((unsigned __int16)v86 & 0x8000) != 0)
              {
                if (gLogDatapath)
                {
                  v171 = __nwlog_obj();
                  if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
                  {
                    v172 = *((_DWORD *)v316 + 6);
                    *(_DWORD *)v323 = 136446722;
                    *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v323[12] = 2082;
                    *(_QWORD *)&v323[14] = v9 + 4;
                    *(_WORD *)&v323[22] = 1024;
                    *(_DWORD *)v324 = v172;
                    _os_log_impl(&dword_182FBE000, v171, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s before making one byte frames, had %u frames", v323, 0x1Cu);
                  }
                }
                v104 = &nwlog_legacy_init(void)::init_once;
                v105 = nwlog_legacy_init_once;
                v106 = &unk_1ECD84000;
                while (1)
                {
                  v110 = a6->tqh_first;
                  if (!a6->tqh_first)
                    break;
                  *(_QWORD *)v330 = a6->tqh_first;
                  v111 = *((_QWORD *)v110 + 4);
                  v112 = (nw_frame **)*((_QWORD *)v110 + 5);
                  if (v111)
                  {
                    *(_QWORD *)(v111 + 40) = v112;
                    v112 = (nw_frame **)*((_QWORD *)v110 + 5);
                  }
                  else
                  {
                    a6->tqh_last = v112;
                  }
                  *v112 = (nw_frame *)v111;
                  *((_QWORD *)v110 + 4) = 0;
                  *((_QWORD *)v110 + 5) = 0;
                  while (nw_frame_unclaimed_length(*(_DWORD **)v330) >= 2)
                  {
                    v113 = nw_frame_split((uint64_t *)v330, 1u);
                    if (gLogDatapath)
                    {
                      pthread_once(v104, v105);
                      networkd_settings_init();
                      v115 = *((_QWORD *)v106 + 463);
                      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
                      {
                        v116 = v105;
                        v117 = v104;
                        v118 = v36;
                        v119 = *(_QWORD *)v330;
                        v120 = nw_frame_unclaimed_length(*(_DWORD **)v330);
                        *(_DWORD *)v323 = 136447234;
                        *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
                        *(_WORD *)&v323[12] = 2082;
                        *(_QWORD *)&v323[14] = v9 + 4;
                        *(_WORD *)&v323[22] = 2048;
                        *(_QWORD *)v324 = v113;
                        *(_WORD *)&v324[8] = 2048;
                        *(_QWORD *)&v324[10] = v119;
                        v36 = v118;
                        v104 = v117;
                        v105 = v116;
                        v106 = &unk_1ECD84000;
                        *(_WORD *)&v324[18] = 1024;
                        *(_DWORD *)&v324[20] = v120;
                        _os_log_impl(&dword_182FBE000, v115, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s appending one byte frame %p made from existing frame %p (%u bytes)", v323, 0x30u);
                      }
                    }
                    *(_QWORD *)(v113 + 32) = 0;
                    v114 = (uint64_t *)v9[2];
                    *(_QWORD *)(v113 + 40) = v114;
                    *v114 = v113;
                    v9[2] = (nw_protocol *)(v113 + 32);
                  }
                  v107 = *(_QWORD *)v330;
                  v108 = *(_QWORD *)v330;
                  *(_QWORD *)(*(_QWORD *)v330 + 32) = 0;
                  v109 = v9[2];
                  *(_QWORD *)(v107 + 40) = v109;
                  *(_QWORD *)v109->flow_id = v107;
                  v9[2] = (nw_protocol *)(v108 + 32);
                }
                *((_DWORD *)v316 + 6) = 0;
                v121 = v9[1];
                if (v121)
                {
                  v123 = v121->output_handler;
                  v124 = (nw_protocol *)v121->handle;
                  v122 = (nw_frame **)&v121->output_handler;
                  if (v123)
                  {
                    v123->handle = v124;
                    v124 = (nw_protocol *)v121->handle;
                  }
                  else
                  {
                    v9[2] = v124;
                  }
                  *(_QWORD *)v124->flow_id = v123;
                  *v122 = 0;
                  v121->handle = 0;
                  v125 = a6->tqh_last;
                  v121->handle = v125;
                  *v125 = (nw_frame *)v121;
                  a6->tqh_last = v122;
                  *((_DWORD *)v316 + 6) = 1;
                }
              }
              *(_DWORD *)v323 = 0;
              nw_frame_array_get_frame_count((uint64_t *)a6, 1, v323);
              if (gLogDatapath)
              {
                v155 = *(_DWORD *)v323;
                v156 = __nwlog_obj();
                if (os_log_type_enabled(v156, OS_LOG_TYPE_DEBUG))
                {
                  v157 = *((_DWORD *)v316 + 6);
                  *(_DWORD *)v323 = 136446978;
                  *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
                  *(_WORD *)&v323[12] = 2082;
                  *(_QWORD *)&v323[14] = v9 + 4;
                  *(_WORD *)&v323[22] = 1024;
                  *(_DWORD *)v324 = v157;
                  *(_WORD *)&v324[4] = 1024;
                  *(_DWORD *)&v324[6] = v155;
                  _os_log_impl(&dword_182FBE000, v156, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s returning %u frames (total %u bytes)", v323, 0x22u);
                }
              }
              v18 = *((unsigned int *)v316 + 6);
              _Block_object_dispose(&v315, 8);
              v126 = v281;
              if ((v36 & 1) != 0)
              {
                if (v281)
                {
                  if (v281->handle == &nw_protocol_ref_counted_handle)
                  {
                    v128 = v281[1].callbacks;
                    if (v128)
                    {
                      v129 = (nw_protocol_callbacks *)((char *)v128 - 1);
                      v281[1].callbacks = v129;
                      if (!v129)
                      {
                        v130 = *(void (***)(_QWORD))v281[1].flow_id;
                        if (v130)
                        {
                          *(_QWORD *)v281[1].flow_id = 0;
                          v130[2](v130);
                          _Block_release(v130);
                          v126 = v281;
                        }
                        if ((v126[1].flow_id[8] & 1) != 0)
                        {
                          v131 = *(const void **)v126[1].flow_id;
                          if (v131)
                          {
                            _Block_release(v131);
                            v126 = v281;
                          }
                        }
                        free(v126);
                      }
                    }
                  }
                }
              }
              _Block_object_dispose(buf, 8);
              return v18;
            }
            v295[0] = MEMORY[0x1E0C809B0];
            v295[1] = 0x40000000;
            v296 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_30;
            v297 = &__block_descriptor_tmp_31_83877;
            v298 = p_output_handler;
            v299 = a2;
            v300 = a1;
            v57 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
            do
            {
              if (!v57)
                break;
              v58 = *(_QWORD *)(v57 + 32);
              v59 = v296(v295);
              v57 = v58;
            }
            while ((v59 & 1) != 0);
          }
LABEL_137:
          v86 = (nw_protocol *)*p_output_handler;
          if ((*p_output_handler & 0x40) == 0)
            goto LABEL_162;
          goto LABEL_138;
        }
        if (!v39->get_output_frames)
        {
          v37 = &v315;
          goto LABEL_62;
        }
        v40 = v36;
        v41 = output_handler->handle;
        if (v41 == &nw_protocol_ref_counted_handle)
        {
          v42 = output_handler[1].callbacks;
          if (v42)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v42->add_input_handler + 1);
        }
        v43 = a1->handle;
        if (v43 == &nw_protocol_ref_counted_handle)
        {
          v44 = a1[1].callbacks;
          if (v44)
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v44->add_input_handler + 1);
        }
        if (v32)
        {
          v45 = (uint64_t (*)(void))v39->get_input_frames;
          if (v45)
          {
            v46 = v45();
LABEL_56:
            if (v43 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
            {
              v64 = a1[1].callbacks;
              if (v64)
              {
                v65 = (nw_protocol_callbacks *)((char *)v64 - 1);
                a1[1].callbacks = v65;
                if (!v65)
                {
                  v66 = *(void (***)(_QWORD))a1[1].flow_id;
                  if (v66)
                  {
                    *(_QWORD *)a1[1].flow_id = 0;
                    v66[2](v66);
                    _Block_release(v66);
                  }
                  if ((a1[1].flow_id[8] & 1) != 0)
                  {
                    v67 = *(const void **)a1[1].flow_id;
                    if (v67)
                      _Block_release(v67);
                  }
                  free(a1);
                }
              }
            }
            v47 = v281;
            if (v41 == &nw_protocol_ref_counted_handle)
            {
              if (v281)
              {
                if (v281->handle == &nw_protocol_ref_counted_handle)
                {
                  v60 = v281[1].callbacks;
                  if (v60)
                  {
                    v61 = (nw_protocol_callbacks *)((char *)v60 - 1);
                    v281[1].callbacks = v61;
                    if (!v61)
                    {
                      v62 = *(void (***)(_QWORD))v281[1].flow_id;
                      if (v62)
                      {
                        *(_QWORD *)v281[1].flow_id = 0;
                        v62[2](v62);
                        _Block_release(v62);
                        v47 = v281;
                      }
                      if ((v47[1].flow_id[8] & 1) != 0)
                      {
                        v63 = *(const void **)v47[1].flow_id;
                        if (v63)
                        {
                          _Block_release(v63);
                          v47 = v281;
                        }
                      }
                      free(v47);
                    }
                  }
                }
              }
            }
            v37 = v316;
            *((_DWORD *)v316 + 6) = v46;
            v36 = v40;
            goto LABEL_62;
          }
          v162 = output_handler;
          __nwlog_obj();
          v163 = v162->identifier->name;
          *(_DWORD *)v323 = 136446722;
          *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
          if (!v163)
            v163 = "invalid";
          *(_WORD *)&v323[12] = 2082;
          *(_QWORD *)&v323[14] = v163;
          *(_WORD *)&v323[22] = 2048;
          *(_QWORD *)v324 = v162;
          v164 = (const char *)_os_log_send_and_compose_impl();
          v330[0] = 16;
          v321[0] = OS_LOG_TYPE_DEFAULT;
          v277 = (char *)v164;
          if (!__nwlog_fault(v164, v330, v321))
            goto LABEL_346;
          if (v330[0] == 17)
          {
            v165 = __nwlog_obj();
            v166 = v330[0];
            loga = v165;
            if (os_log_type_enabled(v165, (os_log_type_t)v330[0]))
            {
              v167 = v281->identifier->name;
              if (!v167)
                v167 = "invalid";
              *(_DWORD *)v323 = 136446722;
              *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&v323[12] = 2082;
              *(_QWORD *)&v323[14] = v167;
              *(_WORD *)&v323[22] = 2048;
              *(_QWORD *)v324 = v281;
              v161 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_343:
              v217 = loga;
              v218 = v166;
LABEL_344:
              v219 = 32;
              goto LABEL_345;
            }
            goto LABEL_346;
          }
          if (v321[0] == OS_LOG_TYPE_DEFAULT)
          {
            v220 = __nwlog_obj();
            v166 = v330[0];
            loga = v220;
            if (os_log_type_enabled(v220, (os_log_type_t)v330[0]))
            {
              v221 = v281->identifier->name;
              if (!v221)
                v221 = "invalid";
              *(_DWORD *)v323 = 136446722;
              *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&v323[12] = 2082;
              *(_QWORD *)&v323[14] = v221;
              *(_WORD *)&v323[22] = 2048;
              *(_QWORD *)v324 = v281;
              v161 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
              goto LABEL_343;
            }
LABEL_346:
            if (v277)
              free(v277);
            v46 = 0;
            goto LABEL_56;
          }
          v173 = (char *)__nw_create_backtrace_string();
          logc = __nwlog_obj();
          typea = v330[0];
          v179 = os_log_type_enabled(logc, (os_log_type_t)v330[0]);
          if (!v173)
          {
            if (!v179)
              goto LABEL_346;
            v222 = v281->identifier->name;
            if (!v222)
              v222 = "invalid";
            *(_DWORD *)v323 = 136446722;
            *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&v323[12] = 2082;
            *(_QWORD *)&v323[14] = v222;
            *(_WORD *)&v323[22] = 2048;
            *(_QWORD *)v324 = v281;
            v161 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            v217 = logc;
            v218 = typea;
            goto LABEL_344;
          }
          if (!v179)
          {
LABEL_286:
            free(v173);
            goto LABEL_346;
          }
          v180 = v281->identifier->name;
          if (!v180)
            v180 = "invalid";
          *(_DWORD *)v323 = 136446978;
          *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&v323[12] = 2082;
          *(_QWORD *)&v323[14] = v180;
          *(_WORD *)&v323[22] = 2048;
          *(_QWORD *)v324 = v281;
          *(_WORD *)&v324[8] = 2082;
          *(_QWORD *)&v324[10] = v173;
          v175 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s";
          v176 = logc;
          v177 = typea;
          v178 = 42;
LABEL_285:
          _os_log_impl(&dword_182FBE000, v176, v177, v175, v323, v178);
          goto LABEL_286;
        }
        __nwlog_obj();
        *(_DWORD *)v323 = 136446210;
        *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
        v158 = (const char *)_os_log_send_and_compose_impl();
        v330[0] = 16;
        v321[0] = OS_LOG_TYPE_DEFAULT;
        v277 = (char *)v158;
        if (!__nwlog_fault(v158, v330, v321))
          goto LABEL_346;
        if (v330[0] == 17)
        {
          v159 = __nwlog_obj();
          v160 = v330[0];
          log = v159;
          if (!os_log_type_enabled(v159, (os_log_type_t)v330[0]))
            goto LABEL_346;
          *(_DWORD *)v323 = 136446210;
          *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
          v161 = "%{public}s called with null return_array";
        }
        else
        {
          if (v321[0])
          {
            v173 = (char *)__nw_create_backtrace_string();
            logb = __nwlog_obj();
            type = v330[0];
            v174 = os_log_type_enabled(logb, (os_log_type_t)v330[0]);
            if (!v173)
            {
              if (!v174)
                goto LABEL_346;
              *(_DWORD *)v323 = 136446210;
              *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
              v161 = "%{public}s called with null return_array, no backtrace";
              v217 = logb;
              v218 = type;
              v219 = 12;
              goto LABEL_345;
            }
            if (!v174)
              goto LABEL_286;
            *(_DWORD *)v323 = 136446466;
            *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&v323[12] = 2082;
            *(_QWORD *)&v323[14] = v173;
            v175 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
            v176 = logb;
            v177 = type;
            v178 = 22;
            goto LABEL_285;
          }
          v216 = __nwlog_obj();
          v160 = v330[0];
          log = v216;
          if (!os_log_type_enabled(v216, (os_log_type_t)v330[0]))
            goto LABEL_346;
          *(_DWORD *)v323 = 136446210;
          *(_QWORD *)&v323[4] = "__nw_protocol_get_input_frames";
          v161 = "%{public}s called with null return_array, backtrace limit exceeded";
        }
        v217 = log;
        v218 = v160;
        v219 = 12;
LABEL_345:
        _os_log_impl(&dword_182FBE000, v217, v218, v161, v323, v219);
        goto LABEL_346;
      }
      *(_DWORD *)v323 = 136446466;
      *(_QWORD *)&v323[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v323[12] = 2082;
      *(_QWORD *)&v323[14] = a1 + 2;
      v34 = "%{public}s %{public}s Disconnect on input enabled";
    }
    _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, v34, v323, 0x16u);
    goto LABEL_37;
  }
  v21 = malloc_type_malloc(0xAuLL, 0xF2B69DE5uLL);
  if (v21)
  {
    v22 = (uint64_t)v21;
  }
  else
  {
    v151 = __nwlog_obj();
    os_log_type_enabled(v151, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "strict_malloc";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = 10;
    v152 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v152);
    if ((_DWORD)result)
      goto LABEL_479;
    free(v152);
    v22 = 0;
  }
  v23 = nw_frame_create(0, v22, 10, (uint64_t)__nw_frame_malloc_finalizer, 0);
  nw_frame_set_buffer_used_malloc(v23, 1);
  *(_QWORD *)(v23 + 32) = 0;
  v24 = a6->tqh_last;
  *(_QWORD *)(v23 + 40) = v24;
  *v24 = (nw_frame *)v23;
  a6->tqh_last = (nw_frame **)(v23 + 32);
  v25 = malloc_type_malloc(0xAuLL, 0xF2B69DE5uLL);
  if (v25)
  {
    v26 = (uint64_t)v25;
LABEL_25:
    v27 = nw_frame_create(0, v26, 10, (uint64_t)__nw_frame_malloc_finalizer, 0);
    nw_frame_set_buffer_used_malloc(v27, 1);
    *(_QWORD *)(v27 + 32) = 0;
    v28 = a6->tqh_last;
    *(_QWORD *)(v27 + 40) = v28;
    *v28 = (nw_frame *)v27;
    a6->tqh_last = (nw_frame **)(v27 + 32);
    v29 = nw_frame_create(0, 0, 0, (uint64_t)__nw_frame_malloc_finalizer, 0);
    *(_QWORD *)(v29 + 32) = 0;
    v30 = a6->tqh_last;
    *(_QWORD *)(v29 + 40) = v30;
    *v30 = (nw_frame *)v29;
    a6->tqh_last = (nw_frame **)(v29 + 32);
    return 3;
  }
  v153 = __nwlog_obj();
  os_log_type_enabled(v153, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  *(_QWORD *)&buf[4] = "strict_malloc";
  *(_WORD *)&buf[12] = 2048;
  *(_QWORD *)&buf[14] = 10;
  v154 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v154);
  if (!(_DWORD)result)
  {
    free(v154);
    v26 = 0;
    goto LABEL_25;
  }
LABEL_479:
  __break(1u);
  return result;
}

uint64_t nw_protocol_test_get_output_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  _QWORD *p_output_handler;
  nw_protocol *output_handler;
  int v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  uint64_t v17;
  nw_frame_array_s *v18;
  _BYTE *v19;
  nw_protocol *v20;
  void *handle;
  char v22;
  nw_protocol_callbacks *v23;
  nw_frame_array_s *v24;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_output_frames)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *);
  nw_protocol_callbacks *v27;
  void *v28;
  nw_protocol_callbacks *v29;
  int v30;
  BOOL v31;
  nw_protocol *v32;
  char v33;
  uint64_t v34;
  nw_protocol_callbacks *v35;
  nw_protocol_callbacks *v36;
  void (**v37)(_QWORD, _QWORD);
  const void *v38;
  nw_protocol_callbacks *v40;
  nw_protocol_callbacks *v41;
  void (**v42)(_QWORD);
  const void *v43;
  nw_protocol_callbacks *v44;
  nw_protocol_callbacks *v45;
  void (**v46)(_QWORD);
  const void *v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  const char *v51;
  char *v52;
  _BOOL4 v53;
  const char *v54;
  _BOOL4 v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  const char *v59;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  NSObject *v63;
  char *backtrace_string;
  _BOOL4 v65;
  char v66;
  nw_frame_array_s *v67;
  _QWORD v68[2];
  uint64_t (*v69)(_QWORD *);
  void *v70;
  _BYTE *v71;
  _BYTE *v72;
  _QWORD *v73;
  nw_frame_array_s *v74;
  _QWORD v75[6];
  char v76;
  os_log_type_t v77;
  _BYTE type[24];
  int v79;
  _BYTE buf[24];
  __n128 (*v81)(uint64_t, uint64_t);
  uint64_t (*v82)();
  _QWORD v83[3];
  uint8_t v84[4];
  const char *v85;
  __int16 v86;
  char *v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      p_output_handler = &a1[1].output_handler;
      output_handler = a1[1].output_handler;
      if ((output_handler & 0x80) != 0)
      {
        v13 = (BYTE4(a1[3].identifier) + 1) & 3;
        BYTE4(a1[3].identifier) = v13;
        if (v13 == 2)
        {
          if (!gLogDatapath)
            goto LABEL_77;
          v14 = __nwlog_obj();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            goto LABEL_77;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 2;
          v15 = "%{public}s %{public}s Failing every 2nd request for get_output_frames";
          goto LABEL_148;
        }
        if (!v13)
        {
          if (!gLogDatapath)
            goto LABEL_77;
          v14 = __nwlog_obj();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            goto LABEL_77;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 2;
          v15 = "%{public}s %{public}s Failing every 4th request for get_output_frames";
LABEL_148:
          _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, v15, buf, 0x16u);
LABEL_77:
          if (a1[1].output_handler_context)
          {
            if (gLogDatapath)
            {
              v63 = __nwlog_obj();
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = a1 + 2;
                _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Cancelling existing output frame failure timer", buf, 0x16u);
              }
            }
            nw_queue_cancel_source((uint64_t)a1[1].output_handler_context, (uint64_t)a2);
            a1[1].output_handler_context = 0;
          }
          v75[0] = MEMORY[0x1E0C809B0];
          v75[1] = 0x40000000;
          v75[2] = ___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
          v75[3] = &__block_descriptor_tmp_37_83794;
          v75[4] = (char *)a1 + 96;
          v75[5] = a1;
          v34 = 0;
          a1[1].output_handler_context = (void *)nw_queue_context_create_source(0, 2, 3, 0, v75, 0);
          return v34;
        }
      }
      else
      {
        if (((unsigned __int16)output_handler & 0x100) == 0)
          goto LABEL_15;
        BYTE4(a1[3].identifier) = (BYTE4(a1[3].identifier) + 1) & 3;
      }
      if (((unsigned __int16)output_handler & 0x200) == 0 || (arc4random() & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_INFO, "%{public}s Allowing request for get_output_frames to succeed", buf, 0xCu);
        }
LABEL_15:
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x3802000000;
        v81 = __Block_byref_object_copy__24;
        v82 = __Block_byref_object_dispose__25;
        v83[0] = 0;
        v83[1] = v83;
        v17 = *p_output_handler;
        v18 = a6;
        if ((*p_output_handler & 8) != 0)
        {
          if (gLogDatapath)
          {
            v60 = __nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)type = 136446466;
              *(_QWORD *)&type[4] = "nw_protocol_test_get_output_frames";
              *(_WORD *)&type[12] = 2082;
              *(_QWORD *)&type[14] = a1 + 2;
              _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Splitting outgoing frames", type, 0x16u);
            }
          }
          v18 = (nw_frame_array_s *)(*(_QWORD *)&buf[8] + 40);
          v17 = *p_output_handler;
          if ((*p_output_handler & 0x2000) == 0)
          {
LABEL_17:
            v67 = a6;
            if ((v17 & 0x10000) == 0)
              goto LABEL_31;
            goto LABEL_29;
          }
        }
        else if ((v17 & 0x2000) == 0)
        {
          goto LABEL_17;
        }
        if (gLogDatapath)
        {
          v61 = __nwlog_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)type = 136446466;
            *(_QWORD *)&type[4] = "nw_protocol_test_get_output_frames";
            *(_WORD *)&type[12] = 2082;
            *(_QWORD *)&type[14] = a1 + 2;
            _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Capping send size at 1300", type, 0x16u);
          }
        }
        if (a4 >= 0x514)
          a4 = 1300;
        else
          a4 = a4;
        if (a3 >= 0x514)
          a3 = 1300;
        else
          a3 = a3;
        v67 = a6;
        if ((*p_output_handler & 0x10000) == 0)
        {
LABEL_31:
          v19 = type;
          *(_QWORD *)type = 0;
          *(_QWORD *)&type[8] = type;
          v79 = 0;
          *(_QWORD *)&type[16] = 0x2000000000;
          v20 = a1->output_handler;
          if (!v20)
          {
            v22 = 0;
            goto LABEL_36;
          }
          handle = v20->handle;
          if (handle == &nw_protocol_ref_counted_handle)
          {
            callbacks = v20[1].callbacks;
            if (callbacks)
              v20[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
            v22 = -1;
            v23 = v20->callbacks;
            if (!v23)
              goto LABEL_106;
          }
          else
          {
            v22 = 0;
            v23 = v20->callbacks;
            if (!v23)
              goto LABEL_106;
          }
          get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))v23->get_output_frames;
          if (!get_output_frames)
          {
LABEL_106:
            v19 = type;
LABEL_36:
            v24 = v67;
            if ((*(_BYTE *)p_output_handler & 8) == 0)
            {
LABEL_64:
              v34 = *((unsigned int *)v19 + 6);
              if ((v22 & 1) != 0)
              {
                if (v20)
                {
                  if (v20->handle == &nw_protocol_ref_counted_handle)
                  {
                    v35 = v20[1].callbacks;
                    if (v35)
                    {
                      v36 = (nw_protocol_callbacks *)((char *)v35 - 1);
                      v20[1].callbacks = v36;
                      if (!v36)
                      {
                        v37 = *(void (***)(_QWORD, _QWORD))v20[1].flow_id;
                        if (v37)
                        {
                          *(_QWORD *)v20[1].flow_id = 0;
                          ((void (**)(_QWORD, nw_protocol *))v37)[2](v37, a2);
                          _Block_release(v37);
                        }
                        if ((v20[1].flow_id[8] & 1) != 0)
                        {
                          v38 = *(const void **)v20[1].flow_id;
                          if (v38)
                            _Block_release(v38);
                        }
                        free(v20);
                      }
                    }
                  }
                }
              }
              _Block_object_dispose(type, 8);
              _Block_object_dispose(buf, 8);
              return v34;
            }
LABEL_60:
            *((_DWORD *)v19 + 6) = 0;
            v68[0] = MEMORY[0x1E0C809B0];
            v68[1] = 0x40000000;
            v69 = (uint64_t (*)(_QWORD *))___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_38;
            v70 = &unk_1E14AC150;
            v73 = p_output_handler;
            v74 = v24;
            v71 = buf;
            v72 = type;
            a2 = *(nw_protocol **)(*(_QWORD *)&buf[8] + 40);
            do
            {
              if (!a2)
                break;
              v32 = a2->output_handler;
              v33 = v69(v68);
              a2 = v32;
            }
            while ((v33 & 1) != 0);
            v19 = *(_BYTE **)&type[8];
            goto LABEL_64;
          }
          v66 = v22;
          if (handle == &nw_protocol_ref_counted_handle)
          {
            v27 = v20[1].callbacks;
            if (v27)
              v20[1].callbacks = (nw_protocol_callbacks *)((char *)&v27->add_input_handler + 1);
          }
          v28 = a1->handle;
          if (v28 == &nw_protocol_ref_counted_handle)
          {
            v29 = a1[1].callbacks;
            if (v29)
              a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v29->add_input_handler + 1);
          }
          if (v18)
          {
            v30 = get_output_frames(v20, a1, a3, a4, a5, v18);
            goto LABEL_53;
          }
          __nwlog_obj();
          *(_DWORD *)v84 = 136446210;
          v85 = "__nw_protocol_get_output_frames";
          v56 = (char *)_os_log_send_and_compose_impl();
          v77 = OS_LOG_TYPE_ERROR;
          v76 = 0;
          if (__nwlog_fault(v56, &v77, &v76))
          {
            if (v77 == OS_LOG_TYPE_FAULT)
            {
              v57 = __nwlog_obj();
              v58 = v77;
              if (os_log_type_enabled(v57, v77))
              {
                *(_DWORD *)v84 = 136446210;
                v85 = "__nw_protocol_get_output_frames";
                v59 = "%{public}s called with null return_array";
LABEL_153:
                _os_log_impl(&dword_182FBE000, v57, v58, v59, v84, 0xCu);
              }
            }
            else if (v76)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              v57 = __nwlog_obj();
              v58 = v77;
              v65 = os_log_type_enabled(v57, v77);
              if (backtrace_string)
              {
                if (v65)
                {
                  *(_DWORD *)v84 = 136446466;
                  v85 = "__nw_protocol_get_output_frames";
                  v86 = 2082;
                  v87 = backtrace_string;
                  _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s called with null return_array, dumping backtrace:%{public}s", v84, 0x16u);
                }
                free(backtrace_string);
                goto LABEL_154;
              }
              if (v65)
              {
                *(_DWORD *)v84 = 136446210;
                v85 = "__nw_protocol_get_output_frames";
                v59 = "%{public}s called with null return_array, no backtrace";
                goto LABEL_153;
              }
            }
            else
            {
              v57 = __nwlog_obj();
              v58 = v77;
              if (os_log_type_enabled(v57, v77))
              {
                *(_DWORD *)v84 = 136446210;
                v85 = "__nw_protocol_get_output_frames";
                v59 = "%{public}s called with null return_array, backtrace limit exceeded";
                goto LABEL_153;
              }
            }
          }
LABEL_154:
          if (v56)
            free(v56);
          v30 = 0;
LABEL_53:
          v31 = v28 == &nw_protocol_ref_counted_handle;
          v22 = v66;
          if (v31 && a1->handle == &nw_protocol_ref_counted_handle)
          {
            v40 = a1[1].callbacks;
            if (v40)
            {
              v41 = (nw_protocol_callbacks *)((char *)v40 - 1);
              a1[1].callbacks = v41;
              if (!v41)
              {
                v42 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v42)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v42[2](v42);
                  _Block_release(v42);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v43 = *(const void **)a1[1].flow_id;
                  if (v43)
                    _Block_release(v43);
                }
                free(a1);
              }
            }
          }
          v31 = handle == &nw_protocol_ref_counted_handle;
          v24 = v67;
          if (v31 && v20->handle == &nw_protocol_ref_counted_handle)
          {
            v44 = v20[1].callbacks;
            if (v44)
            {
              v45 = (nw_protocol_callbacks *)((char *)v44 - 1);
              v20[1].callbacks = v45;
              if (!v45)
              {
                v46 = *(void (***)(_QWORD))v20[1].flow_id;
                if (v46)
                {
                  *(_QWORD *)v20[1].flow_id = 0;
                  v46[2](v46);
                  _Block_release(v46);
                }
                if ((v20[1].flow_id[8] & 1) != 0)
                {
                  v47 = *(const void **)v20[1].flow_id;
                  if (v47)
                    _Block_release(v47);
                }
                free(v20);
              }
            }
          }
          v19 = *(_BYTE **)&type[8];
          *(_DWORD *)(*(_QWORD *)&type[8] + 24) = v30;
          if ((*(_BYTE *)p_output_handler & 8) == 0)
            goto LABEL_64;
          goto LABEL_60;
        }
LABEL_29:
        if (gLogDatapath)
        {
          v62 = __nwlog_obj();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)type = 136446466;
            *(_QWORD *)&type[4] = "nw_protocol_test_get_output_frames";
            *(_WORD *)&type[12] = 2082;
            *(_QWORD *)&type[14] = a1 + 2;
            _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Requesting UINT32_MAX output frame", type, 0x16u);
          }
        }
        a4 = 0xFFFFFFFFLL;
        goto LABEL_31;
      }
      if (!gLogDatapath)
        goto LABEL_77;
      v14 = __nwlog_obj();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        goto LABEL_77;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 2;
      v15 = "%{public}s %{public}s Failing random request for get_output_frames";
      goto LABEL_148;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
    v48 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v84[0] = 0;
    if (!__nwlog_fault(v48, type, v84))
      goto LABEL_143;
    if (type[0] == 17)
    {
      v49 = __nwlog_obj();
      v50 = type[0];
      if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
        v51 = "%{public}s called with null test";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    if (!v84[0])
    {
      v49 = __nwlog_obj();
      v50 = type[0];
      if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
        v51 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    v52 = (char *)__nw_create_backtrace_string();
    v49 = __nwlog_obj();
    v50 = type[0];
    v55 = os_log_type_enabled(v49, (os_log_type_t)type[0]);
    if (!v52)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
        v51 = "%{public}s called with null test, no backtrace";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    if (v55)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v52;
      v54 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    goto LABEL_116;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
  v48 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v84[0] = 0;
  if (!__nwlog_fault(v48, type, v84))
    goto LABEL_143;
  if (type[0] != 17)
  {
    if (!v84[0])
    {
      v49 = __nwlog_obj();
      v50 = type[0];
      if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
        v51 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    v52 = (char *)__nw_create_backtrace_string();
    v49 = __nwlog_obj();
    v50 = type[0];
    v53 = os_log_type_enabled(v49, (os_log_type_t)type[0]);
    if (!v52)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
        v51 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    if (v53)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v52;
      v54 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_115:
      _os_log_impl(&dword_182FBE000, v49, v50, v54, buf, 0x16u);
    }
LABEL_116:
    free(v52);
    goto LABEL_143;
  }
  v49 = __nwlog_obj();
  v50 = type[0];
  if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_get_output_frames";
    v51 = "%{public}s called with null protocol";
LABEL_142:
    _os_log_impl(&dword_182FBE000, v49, v50, v51, buf, 0xCu);
  }
LABEL_143:
  if (v48)
    free(v48);
  return 0;
}

uint64_t nw_protocol_test_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v5;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v7;
  void *v8;
  void *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  nw_protocol_callbacks *v12;
  nw_protocol_callbacks *v13;
  void (**v14)(_QWORD);
  const void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  char *v30;
  _BOOL4 v31;
  char *v32;
  _BOOL4 v33;
  unsigned __int8 *v34;
  nw_protocol *output_handler;
  void *handle;
  nw_protocol_callbacks *v37;
  nw_protocol_callbacks *v38;
  uint64_t (*finalize_output_frames)(nw_protocol *, nw_frame_array_s *);
  uint64_t v40;
  nw_protocol_callbacks *v42;
  nw_protocol_callbacks *v43;
  void (**v44)(_QWORD);
  const void *v45;
  nw_protocol_identifier *identifier;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  nw_protocol_identifier *v50;
  const char *v51;
  const char *name;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  const char *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  NSObject *v62;
  os_log_type_t v63;
  char *v64;
  _BOOL4 v65;
  nw_protocol_identifier *v66;
  char *v67;
  _BOOL4 v68;
  const char *v69;
  char *backtrace_string;
  _BOOL4 v71;
  const char *v72;
  _BOOL4 v73;
  char *v74;
  _BOOL4 v75;
  _BOOL4 v76;
  char *v77;
  _BOOL4 v78;
  nw_protocol_identifier *v79;
  const char *v80;
  nw_protocol_identifier *v81;
  const char *v82;
  NSObject *v83;
  os_log_type_t v84;
  uint32_t v85;
  _QWORD v86[2];
  uint64_t (*v87)(uint64_t, void *);
  void *v88;
  nw_frame_array_s *v89;
  char v90;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v93;
  __int16 v94;
  nw_protocol_identifier *v95;
  __int16 v96;
  nw_protocol *v97;
  __int16 v98;
  char *v99;
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_test_finalize_output_frames";
    v58 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90))
      goto LABEL_210;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type;
      if (!os_log_type_enabled(v59, type))
        goto LABEL_210;
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_test_finalize_output_frames";
      v61 = "%{public}s called with null protocol";
LABEL_209:
      _os_log_impl(&dword_182FBE000, v59, v60, v61, buf, 0xCu);
      goto LABEL_210;
    }
    if (!v90)
    {
      v59 = __nwlog_obj();
      v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_protocol_test_finalize_output_frames";
        v61 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_209;
      }
      goto LABEL_210;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = __nwlog_obj();
    v60 = type;
    v71 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v71)
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_protocol_test_finalize_output_frames";
        v61 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_209;
      }
      goto LABEL_210;
    }
    if (!v71)
      goto LABEL_163;
    *(_DWORD *)buf = 136446466;
    v93 = "nw_protocol_test_finalize_output_frames";
    v94 = 2082;
    v95 = (nw_protocol_identifier *)backtrace_string;
    v72 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_162:
    _os_log_impl(&dword_182FBE000, v59, v60, v72, buf, 0x16u);
    goto LABEL_163;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_test_finalize_output_frames";
    v58 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90))
      goto LABEL_210;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type;
      if (!os_log_type_enabled(v59, type))
        goto LABEL_210;
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_test_finalize_output_frames";
      v61 = "%{public}s called with null test";
      goto LABEL_209;
    }
    if (!v90)
    {
      v59 = __nwlog_obj();
      v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_protocol_test_finalize_output_frames";
        v61 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_209;
      }
      goto LABEL_210;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = __nwlog_obj();
    v60 = type;
    v73 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v73)
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_protocol_test_finalize_output_frames";
        v61 = "%{public}s called with null test, no backtrace";
        goto LABEL_209;
      }
      goto LABEL_210;
    }
    if (!v73)
      goto LABEL_163;
    *(_DWORD *)buf = 136446466;
    v93 = "nw_protocol_test_finalize_output_frames";
    v94 = 2082;
    v95 = (nw_protocol_identifier *)backtrace_string;
    v72 = "%{public}s called with null test, dumping backtrace:%{public}s";
    goto LABEL_162;
  }
  v86[0] = MEMORY[0x1E0C809B0];
  v86[1] = 0x40000000;
  v87 = ___ZL39nw_protocol_test_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  v88 = &__block_descriptor_tmp_40_83756;
  v89 = a2;
  callbacks = a1[1].callbacks;
  if (callbacks)
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  v5 = a1->callbacks;
  if (v5)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v5->get_parameters;
    if (get_parameters)
    {
      v7 = (void *)get_parameters(a1);
      goto LABEL_8;
    }
  }
  __nwlog_obj();
  identifier = a1->identifier;
  *(_DWORD *)buf = 136446722;
  v93 = "__nw_protocol_get_parameters";
  if (!identifier)
    identifier = (nw_protocol_identifier *)"invalid";
  v94 = 2082;
  v95 = identifier;
  v96 = 2048;
  v97 = a1;
  v47 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v90 = 0;
  if (__nwlog_fault(v47, &type, &v90))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        v50 = a1->identifier;
        if (!v50)
          v50 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v93 = "__nw_protocol_get_parameters";
        v94 = 2082;
        v95 = v50;
        v96 = 2048;
        v97 = a1;
        v51 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_182:
        _os_log_impl(&dword_182FBE000, v48, v49, v51, buf, 0x20u);
      }
    }
    else if (v90)
    {
      v64 = (char *)__nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type;
      v65 = os_log_type_enabled(v48, type);
      if (v64)
      {
        if (v65)
        {
          v66 = a1->identifier;
          if (!v66)
            v66 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446978;
          v93 = "__nw_protocol_get_parameters";
          v94 = 2082;
          v95 = v66;
          v96 = 2048;
          v97 = a1;
          v98 = 2082;
          v99 = v64;
          _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v64);
        goto LABEL_183;
      }
      if (v65)
      {
        v81 = a1->identifier;
        if (!v81)
          v81 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v93 = "__nw_protocol_get_parameters";
        v94 = 2082;
        v95 = v81;
        v96 = 2048;
        v97 = a1;
        v51 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
        goto LABEL_182;
      }
    }
    else
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        v79 = a1->identifier;
        if (!v79)
          v79 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v93 = "__nw_protocol_get_parameters";
        v94 = 2082;
        v95 = v79;
        v96 = 2048;
        v97 = a1;
        v51 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
        goto LABEL_182;
      }
    }
  }
LABEL_183:
  if (v47)
    free(v47);
  v7 = 0;
LABEL_8:
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v12 = a1[1].callbacks;
    if (v12)
    {
      v13 = (nw_protocol_callbacks *)((char *)v12 - 1);
      a1[1].callbacks = v13;
      if (!v13)
      {
        v14 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v14)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v14[2](v14);
          _Block_release(v14);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v15 = *(const void **)a1[1].flow_id;
          if (v15)
            _Block_release(v15);
        }
        free(a1);
      }
    }
  }
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_test_access_options";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (__nwlog_fault(v16, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_test_access_options";
          v19 = "%{public}s called with null parameters";
LABEL_57:
          _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
        }
      }
      else if (v90)
      {
        v74 = (char *)__nw_create_backtrace_string();
        v17 = __nwlog_obj();
        v18 = type;
        v75 = os_log_type_enabled(v17, type);
        if (v74)
        {
          if (v75)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_protocol_test_access_options";
            v94 = 2082;
            v95 = (nw_protocol_identifier *)v74;
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v74);
        }
        else if (v75)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_test_access_options";
          v19 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_57;
        }
      }
      else
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_test_access_options";
          v19 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_57;
        }
      }
    }
LABEL_58:
    if (!v16)
      goto LABEL_77;
    goto LABEL_59;
  }
  if (nw_protocol_copy_test_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
  if (nw_protocol_copy_test_definition::test_definition)
  {
    v8 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
    if (v8)
    {
      v9 = v8;
      v10 = nw_parameters_copy_protocol_options_for_definition(v7, v8);
      if (v10)
      {
        v11 = v10;
        if (nw_protocol_options_is_test_protocol(v10))
        {
          v87((uint64_t)v86, v11);
LABEL_75:
          os_release(v9);
          v34 = v11;
LABEL_76:
          os_release(v34);
          goto LABEL_77;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v93 = "nw_protocol_test_access_options";
        v24 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v90 = 0;
        if (__nwlog_fault(v24, &type, &v90))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v25 = gLogObj;
            v26 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type))
              goto LABEL_73;
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_test_access_options";
            v27 = "%{public}s Failed to copy test protocol options";
            goto LABEL_72;
          }
          if (!v90)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v25 = gLogObj;
            v26 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type))
              goto LABEL_73;
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_test_access_options";
            v27 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
            goto LABEL_72;
          }
          v32 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v25 = gLogObj;
          v26 = type;
          v33 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v32)
          {
            if (v33)
            {
              *(_DWORD *)buf = 136446466;
              v93 = "nw_protocol_test_access_options";
              v94 = 2082;
              v95 = (nw_protocol_identifier *)v32;
              _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v32);
            goto LABEL_73;
          }
          if (v33)
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_test_access_options";
            v27 = "%{public}s Failed to copy test protocol options, no backtrace";
LABEL_72:
            _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
          }
        }
LABEL_73:
        if (v24)
          free(v24);
        goto LABEL_75;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_test_access_options";
      v20 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v90 = 0;
      if (__nwlog_fault(v20, &type, &v90))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          v22 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_test_access_options";
            v23 = "%{public}s Failed to copy protocol options";
LABEL_66:
            _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0xCu);
          }
        }
        else if (v90)
        {
          v30 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          v22 = type;
          v31 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v30)
          {
            if (v31)
            {
              *(_DWORD *)buf = 136446466;
              v93 = "nw_protocol_test_access_options";
              v94 = 2082;
              v95 = (nw_protocol_identifier *)v30;
              _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v30);
            goto LABEL_67;
          }
          if (v31)
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_test_access_options";
            v23 = "%{public}s Failed to copy protocol options, no backtrace";
            goto LABEL_66;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          v22 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_test_access_options";
            v23 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
            goto LABEL_66;
          }
        }
      }
LABEL_67:
      if (v20)
        free(v20);
      v34 = (unsigned __int8 *)v9;
      goto LABEL_76;
    }
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v93 = "nw_protocol_test_access_options";
  v16 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v90 = 0;
  if (!__nwlog_fault(v16, &type, &v90))
    goto LABEL_58;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v17 = __nwlog_obj();
    v18 = type;
    if (!os_log_type_enabled(v17, type))
      goto LABEL_58;
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_test_access_options";
    v19 = "%{public}s called with null definition";
    goto LABEL_57;
  }
  if (!v90)
  {
    v17 = __nwlog_obj();
    v18 = type;
    if (!os_log_type_enabled(v17, type))
      goto LABEL_58;
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_test_access_options";
    v19 = "%{public}s called with null definition, backtrace limit exceeded";
    goto LABEL_57;
  }
  v28 = (char *)__nw_create_backtrace_string();
  v17 = __nwlog_obj();
  v18 = type;
  v29 = os_log_type_enabled(v17, type);
  if (!v28)
  {
    if (!v29)
      goto LABEL_58;
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_test_access_options";
    v19 = "%{public}s called with null definition, no backtrace";
    goto LABEL_57;
  }
  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    v93 = "nw_protocol_test_access_options";
    v94 = 2082;
    v95 = (nw_protocol_identifier *)v28;
    _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v28);
  if (v16)
LABEL_59:
    free(v16);
LABEL_77:
  output_handler = a1->output_handler;
  if (output_handler)
  {
    handle = output_handler->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      v37 = output_handler[1].callbacks;
      if (v37)
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v37->add_input_handler + 1);
    }
    if (a2)
    {
      v38 = output_handler->callbacks;
      if (v38)
      {
        finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v38->finalize_output_frames;
        if (finalize_output_frames)
        {
          v40 = finalize_output_frames(output_handler, a2);
          if (handle != &nw_protocol_ref_counted_handle)
            return v40;
          goto LABEL_85;
        }
      }
      __nwlog_obj();
      name = output_handler->identifier->name;
      *(_DWORD *)buf = 136446722;
      v93 = "__nw_protocol_finalize_output_frames";
      if (!name)
        name = "invalid";
      v94 = 2082;
      v95 = (nw_protocol_identifier *)name;
      v96 = 2048;
      v97 = output_handler;
      v53 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v90 = 0;
      if (__nwlog_fault(v53, &type, &v90))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v54 = __nwlog_obj();
          v55 = type;
          if (!os_log_type_enabled(v54, type))
            goto LABEL_217;
          v56 = output_handler->identifier->name;
          if (!v56)
            v56 = "invalid";
          *(_DWORD *)buf = 136446722;
          v93 = "__nw_protocol_finalize_output_frames";
          v94 = 2082;
          v95 = (nw_protocol_identifier *)v56;
          v96 = 2048;
          v97 = output_handler;
          v57 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_190:
          v83 = v54;
          v84 = v55;
          v85 = 32;
LABEL_216:
          _os_log_impl(&dword_182FBE000, v83, v84, v57, buf, v85);
          goto LABEL_217;
        }
        if (!v90)
        {
          v54 = __nwlog_obj();
          v55 = type;
          if (!os_log_type_enabled(v54, type))
            goto LABEL_217;
          v80 = output_handler->identifier->name;
          if (!v80)
            v80 = "invalid";
          *(_DWORD *)buf = 136446722;
          v93 = "__nw_protocol_finalize_output_frames";
          v94 = 2082;
          v95 = (nw_protocol_identifier *)v80;
          v96 = 2048;
          v97 = output_handler;
          v57 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
          goto LABEL_190;
        }
        v67 = (char *)__nw_create_backtrace_string();
        v54 = __nwlog_obj();
        v55 = type;
        v68 = os_log_type_enabled(v54, type);
        if (!v67)
        {
          if (!v68)
            goto LABEL_217;
          v82 = output_handler->identifier->name;
          if (!v82)
            v82 = "invalid";
          *(_DWORD *)buf = 136446722;
          v93 = "__nw_protocol_finalize_output_frames";
          v94 = 2082;
          v95 = (nw_protocol_identifier *)v82;
          v96 = 2048;
          v97 = output_handler;
          v57 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
          goto LABEL_190;
        }
        if (v68)
        {
          v69 = output_handler->identifier->name;
          if (!v69)
            v69 = "invalid";
          *(_DWORD *)buf = 136446978;
          v93 = "__nw_protocol_finalize_output_frames";
          v94 = 2082;
          v95 = (nw_protocol_identifier *)v69;
          v96 = 2048;
          v97 = output_handler;
          v98 = 2082;
          v99 = v67;
          _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v67);
      }
LABEL_217:
      if (!v53)
        goto LABEL_219;
      goto LABEL_218;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "__nw_protocol_finalize_output_frames";
    v53 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v53, &type, &v90))
      goto LABEL_217;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v62 = __nwlog_obj();
      v63 = type;
      if (!os_log_type_enabled(v62, type))
        goto LABEL_217;
      *(_DWORD *)buf = 136446210;
      v93 = "__nw_protocol_finalize_output_frames";
      v57 = "%{public}s called with null frames";
    }
    else if (v90)
    {
      v77 = (char *)__nw_create_backtrace_string();
      v62 = __nwlog_obj();
      v63 = type;
      v78 = os_log_type_enabled(v62, type);
      if (v77)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          v93 = "__nw_protocol_finalize_output_frames";
          v94 = 2082;
          v95 = (nw_protocol_identifier *)v77;
          _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s called with null frames, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v77);
        if (!v53)
        {
LABEL_219:
          v40 = 0;
          if (handle != &nw_protocol_ref_counted_handle)
            return v40;
LABEL_85:
          if (output_handler->handle == &nw_protocol_ref_counted_handle)
          {
            v42 = output_handler[1].callbacks;
            if (v42)
            {
              v43 = (nw_protocol_callbacks *)((char *)v42 - 1);
              output_handler[1].callbacks = v43;
              if (!v43)
              {
                v44 = *(void (***)(_QWORD))output_handler[1].flow_id;
                if (v44)
                {
                  *(_QWORD *)output_handler[1].flow_id = 0;
                  v44[2](v44);
                  _Block_release(v44);
                }
                if ((output_handler[1].flow_id[8] & 1) != 0)
                {
                  v45 = *(const void **)output_handler[1].flow_id;
                  if (v45)
                    _Block_release(v45);
                }
                free(output_handler);
              }
            }
          }
          return v40;
        }
LABEL_218:
        free(v53);
        goto LABEL_219;
      }
      if (!v78)
        goto LABEL_217;
      *(_DWORD *)buf = 136446210;
      v93 = "__nw_protocol_finalize_output_frames";
      v57 = "%{public}s called with null frames, no backtrace";
    }
    else
    {
      v62 = __nwlog_obj();
      v63 = type;
      if (!os_log_type_enabled(v62, type))
        goto LABEL_217;
      *(_DWORD *)buf = 136446210;
      v93 = "__nw_protocol_finalize_output_frames";
      v57 = "%{public}s called with null frames, backtrace limit exceeded";
    }
    v83 = v62;
    v84 = v63;
    v85 = 12;
    goto LABEL_216;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v93 = "__nw_protocol_finalize_output_frames";
  v58 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v90 = 0;
  if (!__nwlog_fault(v58, &type, &v90))
    goto LABEL_210;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v90)
    {
      v59 = __nwlog_obj();
      v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "__nw_protocol_finalize_output_frames";
        v61 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_209;
      }
      goto LABEL_210;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = __nwlog_obj();
    v60 = type;
    v76 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        v93 = "__nw_protocol_finalize_output_frames";
        v61 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_209;
      }
      goto LABEL_210;
    }
    if (v76)
    {
      *(_DWORD *)buf = 136446466;
      v93 = "__nw_protocol_finalize_output_frames";
      v94 = 2082;
      v95 = (nw_protocol_identifier *)backtrace_string;
      v72 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_162;
    }
LABEL_163:
    free(backtrace_string);
    goto LABEL_210;
  }
  v59 = __nwlog_obj();
  v60 = type;
  if (os_log_type_enabled(v59, type))
  {
    *(_DWORD *)buf = 136446210;
    v93 = "__nw_protocol_finalize_output_frames";
    v61 = "%{public}s called with null protocol";
    goto LABEL_209;
  }
LABEL_210:
  if (v58)
    free(v58);
  return 0;
}

uint64_t nw_protocol_test_connect(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  void *v6;
  nw_protocol_callbacks *v7;
  nw_protocol_callbacks *v8;
  void (*connected)(nw_protocol *, nw_protocol *);
  uint64_t v10;
  nw_protocol *output_handler;
  nw_protocol_callbacks *v13;
  uint64_t (*connect)(nw_protocol *, nw_protocol *);
  void *v15;
  nw_protocol_callbacks *v16;
  nw_protocol_callbacks *v17;
  nw_protocol_callbacks *v18;
  nw_protocol_callbacks *v19;
  void (**v20)(_QWORD);
  const void *v21;
  nw_protocol_callbacks *v22;
  nw_protocol_callbacks *v23;
  void (**v24)(_QWORD);
  const void *v25;
  nw_protocol_callbacks *v26;
  nw_protocol_callbacks *v27;
  void (**v28)(_QWORD);
  const void *v29;
  nw_protocol_callbacks *v30;
  nw_protocol_callbacks *v31;
  void (**v32)(_QWORD);
  const void *v33;
  const char *name;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  const char *v38;
  const char *v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  NSObject *v44;
  char *v45;
  NSObject *v46;
  os_log_type_t v47;
  const char *v48;
  char *v49;
  _BOOL4 v50;
  const char *v51;
  char *backtrace_string;
  _BOOL4 v53;
  const char *v54;
  _BOOL4 v55;
  char *v56;
  _BOOL4 v57;
  const char *v58;
  const char *v59;
  char v60;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v63;
  __int16 v64;
  nw_protocol *v65;
  __int16 v66;
  nw_protocol *v67;
  __int16 v68;
  char *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v63 = "nw_protocol_test_connect";
    v40 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v60 = 0;
    if (!__nwlog_fault(v40, &type, &v60))
      goto LABEL_128;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v60)
      {
        v41 = __nwlog_obj();
        v42 = type;
        if (!os_log_type_enabled(v41, type))
          goto LABEL_128;
        *(_DWORD *)buf = 136446210;
        v63 = "nw_protocol_test_connect";
        v43 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_127;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v41 = __nwlog_obj();
      v42 = type;
      v53 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v53)
          goto LABEL_128;
        *(_DWORD *)buf = 136446210;
        v63 = "nw_protocol_test_connect";
        v43 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_127;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136446466;
        v63 = "nw_protocol_test_connect";
        v64 = 2082;
        v65 = (nw_protocol *)backtrace_string;
        v54 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_101:
        _os_log_impl(&dword_182FBE000, v41, v42, v54, buf, 0x16u);
      }
LABEL_102:
      free(backtrace_string);
      goto LABEL_128;
    }
    v41 = __nwlog_obj();
    v42 = type;
    if (!os_log_type_enabled(v41, type))
      goto LABEL_128;
    *(_DWORD *)buf = 136446210;
    v63 = "nw_protocol_test_connect";
    v43 = "%{public}s called with null protocol";
LABEL_127:
    _os_log_impl(&dword_182FBE000, v41, v42, v43, buf, 0xCu);
LABEL_128:
    if (v40)
      free(v40);
    return 0;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v63 = "nw_protocol_test_connect";
    v40 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v60 = 0;
    if (!__nwlog_fault(v40, &type, &v60))
      goto LABEL_128;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v41 = __nwlog_obj();
      v42 = type;
      if (!os_log_type_enabled(v41, type))
        goto LABEL_128;
      *(_DWORD *)buf = 136446210;
      v63 = "nw_protocol_test_connect";
      v43 = "%{public}s called with null test";
      goto LABEL_127;
    }
    if (!v60)
    {
      v41 = __nwlog_obj();
      v42 = type;
      if (!os_log_type_enabled(v41, type))
        goto LABEL_128;
      *(_DWORD *)buf = 136446210;
      v63 = "nw_protocol_test_connect";
      v43 = "%{public}s called with null test, backtrace limit exceeded";
      goto LABEL_127;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v41 = __nwlog_obj();
    v42 = type;
    v55 = os_log_type_enabled(v41, type);
    if (backtrace_string)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446466;
        v63 = "nw_protocol_test_connect";
        v64 = 2082;
        v65 = (nw_protocol *)backtrace_string;
        v54 = "%{public}s called with null test, dumping backtrace:%{public}s";
        goto LABEL_101;
      }
      goto LABEL_102;
    }
    if (!v55)
      goto LABEL_128;
    *(_DWORD *)buf = 136446210;
    v63 = "nw_protocol_test_connect";
    v43 = "%{public}s called with null test, no backtrace";
    goto LABEL_127;
  }
  if ((BYTE1(a1[1].output_handler) & 0xC) != 0)
  {
    if (gLogDatapath)
    {
      v44 = __nwlog_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v63 = "nw_protocol_test_connect";
        v64 = 2082;
        v65 = a1 + 2;
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Returning connected immediately for test protocol", buf, 0x16u);
      }
    }
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      handle = default_input_handler->handle;
      if (handle == &nw_protocol_ref_counted_handle)
      {
        callbacks = default_input_handler[1].callbacks;
        if (callbacks)
          default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      v6 = a1->handle;
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        v7 = a1[1].callbacks;
        if (v7)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
      }
      v8 = default_input_handler->callbacks;
      if (v8)
      {
        connected = (void (*)(nw_protocol *, nw_protocol *))v8->connected;
        if (connected)
        {
          connected(default_input_handler, a1);
          goto LABEL_15;
        }
      }
      __nwlog_obj();
      name = default_input_handler->identifier->name;
      *(_DWORD *)buf = 136446722;
      v63 = "__nw_protocol_connected";
      if (!name)
        name = "invalid";
      v64 = 2082;
      v65 = (nw_protocol *)name;
      v66 = 2048;
      v67 = default_input_handler;
      v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v60 = 0;
      if (__nwlog_fault(v35, &type, &v60))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v36 = __nwlog_obj();
          v37 = type;
          if (!os_log_type_enabled(v36, type))
            goto LABEL_121;
          v38 = default_input_handler->identifier->name;
          if (!v38)
            v38 = "invalid";
          *(_DWORD *)buf = 136446722;
          v63 = "__nw_protocol_connected";
          v64 = 2082;
          v65 = (nw_protocol *)v38;
          v66 = 2048;
          v67 = default_input_handler;
          v39 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
          goto LABEL_120;
        }
        if (!v60)
        {
          v36 = __nwlog_obj();
          v37 = type;
          if (!os_log_type_enabled(v36, type))
            goto LABEL_121;
          v58 = default_input_handler->identifier->name;
          if (!v58)
            v58 = "invalid";
          *(_DWORD *)buf = 136446722;
          v63 = "__nw_protocol_connected";
          v64 = 2082;
          v65 = (nw_protocol *)v58;
          v66 = 2048;
          v67 = default_input_handler;
          v39 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
          goto LABEL_120;
        }
        v49 = (char *)__nw_create_backtrace_string();
        v36 = __nwlog_obj();
        v37 = type;
        v50 = os_log_type_enabled(v36, type);
        if (v49)
        {
          if (v50)
          {
            v51 = default_input_handler->identifier->name;
            if (!v51)
              v51 = "invalid";
            *(_DWORD *)buf = 136446978;
            v63 = "__nw_protocol_connected";
            v64 = 2082;
            v65 = (nw_protocol *)v51;
            v66 = 2048;
            v67 = default_input_handler;
            v68 = 2082;
            v69 = v49;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v49);
          goto LABEL_121;
        }
        if (v50)
        {
          v59 = default_input_handler->identifier->name;
          if (!v59)
            v59 = "invalid";
          *(_DWORD *)buf = 136446722;
          v63 = "__nw_protocol_connected";
          v64 = 2082;
          v65 = (nw_protocol *)v59;
          v66 = 2048;
          v67 = default_input_handler;
          v39 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_120:
          _os_log_impl(&dword_182FBE000, v36, v37, v39, buf, 0x20u);
        }
      }
LABEL_121:
      if (v35)
        free(v35);
LABEL_15:
      if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
      {
        v22 = a1[1].callbacks;
        if (v22)
        {
          v23 = (nw_protocol_callbacks *)((char *)v22 - 1);
          a1[1].callbacks = v23;
          if (!v23)
          {
            v24 = *(void (***)(_QWORD))a1[1].flow_id;
            if (v24)
            {
              *(_QWORD *)a1[1].flow_id = 0;
              v24[2](v24);
              _Block_release(v24);
            }
            if ((a1[1].flow_id[8] & 1) != 0)
            {
              v25 = *(const void **)a1[1].flow_id;
              if (v25)
                _Block_release(v25);
            }
            free(a1);
          }
        }
      }
      if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
      {
        v26 = default_input_handler[1].callbacks;
        if (v26)
        {
          v27 = (nw_protocol_callbacks *)((char *)v26 - 1);
          default_input_handler[1].callbacks = v27;
          if (!v27)
          {
            v28 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
            if (v28)
            {
              *(_QWORD *)default_input_handler[1].flow_id = 0;
              v28[2](v28);
              _Block_release(v28);
            }
            if ((default_input_handler[1].flow_id[8] & 1) != 0)
            {
              v29 = *(const void **)default_input_handler[1].flow_id;
              if (v29)
                _Block_release(v29);
            }
            free(default_input_handler);
            return 1;
          }
        }
      }
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v63 = "__nw_protocol_connected";
    v45 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v60 = 0;
    if (__nwlog_fault(v45, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v46 = __nwlog_obj();
        v47 = type;
        if (!os_log_type_enabled(v46, type))
          goto LABEL_136;
        *(_DWORD *)buf = 136446210;
        v63 = "__nw_protocol_connected";
        v48 = "%{public}s called with null protocol";
        goto LABEL_135;
      }
      if (!v60)
      {
        v46 = __nwlog_obj();
        v47 = type;
        if (!os_log_type_enabled(v46, type))
          goto LABEL_136;
        *(_DWORD *)buf = 136446210;
        v63 = "__nw_protocol_connected";
        v48 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_135;
      }
      v56 = (char *)__nw_create_backtrace_string();
      v46 = __nwlog_obj();
      v47 = type;
      v57 = os_log_type_enabled(v46, type);
      if (v56)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446466;
          v63 = "__nw_protocol_connected";
          v64 = 2082;
          v65 = (nw_protocol *)v56;
          _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v56);
        goto LABEL_136;
      }
      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        v63 = "__nw_protocol_connected";
        v48 = "%{public}s called with null protocol, no backtrace";
LABEL_135:
        _os_log_impl(&dword_182FBE000, v46, v47, v48, buf, 0xCu);
      }
    }
LABEL_136:
    if (v45)
      free(v45);
    return 1;
  }
  output_handler = a1->output_handler;
  if (!output_handler)
    return 0;
  v13 = output_handler->callbacks;
  if (!v13)
    return 0;
  connect = (uint64_t (*)(nw_protocol *, nw_protocol *))v13->connect;
  if (!connect)
    return 0;
  v15 = output_handler->handle;
  if (v15 == &nw_protocol_ref_counted_handle)
  {
    v16 = output_handler[1].callbacks;
    if (v16)
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v16->add_input_handler + 1);
  }
  v17 = a1[1].callbacks;
  if (v17)
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v17->add_input_handler + 1);
  v10 = connect(output_handler, a1);
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v30 = a1[1].callbacks;
    if (v30)
    {
      v31 = (nw_protocol_callbacks *)((char *)v30 - 1);
      a1[1].callbacks = v31;
      if (!v31)
      {
        v32 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v32)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v32[2](v32);
          _Block_release(v32);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v33 = *(const void **)a1[1].flow_id;
          if (v33)
            _Block_release(v33);
        }
        free(a1);
      }
    }
  }
  if (v15 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
  {
    v18 = output_handler[1].callbacks;
    if (v18)
    {
      v19 = (nw_protocol_callbacks *)((char *)v18 - 1);
      output_handler[1].callbacks = v19;
      if (!v19)
      {
        v20 = *(void (***)(_QWORD))output_handler[1].flow_id;
        if (v20)
        {
          *(_QWORD *)output_handler[1].flow_id = 0;
          v20[2](v20);
          _Block_release(v20);
        }
        if ((output_handler[1].flow_id[8] & 1) != 0)
        {
          v21 = *(const void **)output_handler[1].flow_id;
          if (v21)
            _Block_release(v21);
        }
        free(output_handler);
      }
    }
  }
  return v10;
}

void nw_protocol_test_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  void *v6;
  nw_protocol_callbacks *v7;
  nw_protocol_callbacks *v8;
  void (*disconnected)(nw_protocol *, nw_protocol *);
  nw_protocol_callbacks *v10;
  nw_protocol_callbacks *v11;
  void (**v12)(_QWORD);
  const void *v13;
  nw_protocol_callbacks *v14;
  nw_protocol_callbacks *v15;
  void (**v16)(_QWORD);
  const void *v17;
  nw_protocol *v18;
  const char *name;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  const char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  NSObject *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  char *backtrace_string;
  _BOOL4 v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  _BOOL4 v38;
  const char *v39;
  const char *v40;
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  nw_protocol *v46;
  __int16 v47;
  nw_protocol *v48;
  __int16 v49;
  char *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v44 = "nw_protocol_test_disconnected";
    v25 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v25, &type, &v41))
      goto LABEL_105;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_test_disconnected";
      v28 = "%{public}s called with null protocol";
    }
    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v34 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_protocol_test_disconnected";
          v45 = 2082;
          v46 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_105:
        if (!v25)
          return;
        goto LABEL_106;
      }
      if (!v34)
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_test_disconnected";
      v28 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_test_disconnected";
      v28 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_104;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v44 = "nw_protocol_test_disconnected";
    v25 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v25, &type, &v41))
      goto LABEL_105;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        v44 = "nw_protocol_test_disconnected";
        v28 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_104;
      }
      v35 = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v36 = os_log_type_enabled(v26, type);
      if (!v35)
      {
        if (!v36)
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        v44 = "nw_protocol_test_disconnected";
        v28 = "%{public}s called with null test, no backtrace";
        goto LABEL_104;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_protocol_test_disconnected";
        v45 = 2082;
        v46 = (nw_protocol *)v35;
        v37 = "%{public}s called with null test, dumping backtrace:%{public}s";
LABEL_78:
        _os_log_impl(&dword_182FBE000, v26, v27, v37, buf, 0x16u);
      }
LABEL_79:
      free(v35);
      if (!v25)
        return;
LABEL_106:
      v18 = (nw_protocol *)v25;
LABEL_35:
      free(v18);
      return;
    }
    v26 = __nwlog_obj();
    v27 = type;
    if (!os_log_type_enabled(v26, type))
      goto LABEL_105;
    *(_DWORD *)buf = 136446210;
    v44 = "nw_protocol_test_disconnected";
    v28 = "%{public}s called with null test";
LABEL_104:
    _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
    goto LABEL_105;
  }
  if (gLogDatapath)
  {
    v29 = __nwlog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v44 = "nw_protocol_test_disconnected";
      v45 = 2082;
      v46 = a1 + 2;
      _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s disconnected", buf, 0x16u);
    }
  }
  BYTE5(a1[3].identifier) |= 2u;
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v44 = "__nw_protocol_disconnected";
    v25 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v25, &type, &v41))
      goto LABEL_105;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v44 = "__nw_protocol_disconnected";
      v28 = "%{public}s called with null protocol";
      goto LABEL_104;
    }
    if (!v41)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v44 = "__nw_protocol_disconnected";
      v28 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_104;
    }
    v35 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v38 = os_log_type_enabled(v26, type);
    if (!v35)
    {
      if (!v38)
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v44 = "__nw_protocol_disconnected";
      v28 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_104;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v35;
      v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_78;
    }
    goto LABEL_79;
  }
  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = default_input_handler[1].callbacks;
    if (callbacks)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  v6 = a1->handle;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = a1[1].callbacks;
    if (v7)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
  }
  v8 = default_input_handler->callbacks;
  if (v8)
  {
    disconnected = (void (*)(nw_protocol *, nw_protocol *))v8->disconnected;
    if (disconnected)
    {
      disconnected(default_input_handler, a1);
      goto LABEL_14;
    }
  }
  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v44 = "__nw_protocol_disconnected";
  if (!name)
    name = "invalid";
  v45 = 2082;
  v46 = (nw_protocol *)name;
  v47 = 2048;
  v48 = default_input_handler;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v20, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
        goto LABEL_90;
      v23 = default_input_handler->identifier->name;
      if (!v23)
        v23 = "invalid";
      *(_DWORD *)buf = 136446722;
      v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v23;
      v47 = 2048;
      v48 = default_input_handler;
      v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
      goto LABEL_89;
    }
    if (!v41)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
        goto LABEL_90;
      v39 = default_input_handler->identifier->name;
      if (!v39)
        v39 = "invalid";
      *(_DWORD *)buf = 136446722;
      v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v39;
      v47 = 2048;
      v48 = default_input_handler;
      v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_89;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v21 = __nwlog_obj();
    v22 = type;
    v31 = os_log_type_enabled(v21, type);
    if (v30)
    {
      if (v31)
      {
        v32 = default_input_handler->identifier->name;
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v44 = "__nw_protocol_disconnected";
        v45 = 2082;
        v46 = (nw_protocol *)v32;
        v47 = 2048;
        v48 = default_input_handler;
        v49 = 2082;
        v50 = v30;
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_90;
    }
    if (v31)
    {
      v40 = default_input_handler->identifier->name;
      if (!v40)
        v40 = "invalid";
      *(_DWORD *)buf = 136446722;
      v44 = "__nw_protocol_disconnected";
      v45 = 2082;
      v46 = (nw_protocol *)v40;
      v47 = 2048;
      v48 = default_input_handler;
      v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_89:
      _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    }
  }
LABEL_90:
  if (v20)
    free(v20);
LABEL_14:
  if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    v10 = a1[1].callbacks;
    if (v10)
    {
      v11 = (nw_protocol_callbacks *)((char *)v10 - 1);
      a1[1].callbacks = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v12)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v13 = *(const void **)a1[1].flow_id;
          if (v13)
            _Block_release(v13);
        }
        free(a1);
      }
    }
  }
  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    v14 = default_input_handler[1].callbacks;
    if (v14)
    {
      v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
      default_input_handler[1].callbacks = v15;
      if (!v15)
      {
        v16 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
        if (v16)
        {
          *(_QWORD *)default_input_handler[1].flow_id = 0;
          v16[2](v16);
          _Block_release(v16);
        }
        if ((default_input_handler[1].flow_id[8] & 1) != 0)
        {
          v17 = *(const void **)default_input_handler[1].flow_id;
          if (v17)
            _Block_release(v17);
        }
        v18 = default_input_handler;
        goto LABEL_35;
      }
    }
  }
}

void nw_protocol_test_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v5;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v7;
  void *v8;
  void *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  nw_protocol_callbacks *v12;
  nw_protocol_callbacks *v13;
  void (**v14)(_QWORD);
  const void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  char *v31;
  _BOOL4 v32;
  char *v33;
  _BOOL4 v34;
  unsigned __int8 *v35;
  nw_protocol *output_handler;
  void *handle;
  nw_protocol_callbacks *v38;
  void *v39;
  nw_protocol_callbacks *v40;
  nw_protocol_callbacks *v41;
  void (*output_finished)(nw_protocol *, nw_protocol *);
  nw_protocol_callbacks *v43;
  nw_protocol_callbacks *v44;
  void (**v45)(_QWORD);
  const void *v46;
  nw_protocol_callbacks *v47;
  nw_protocol_callbacks *v48;
  void (**v49)(_QWORD);
  const void *v50;
  nw_protocol *v51;
  nw_protocol_identifier *identifier;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  nw_protocol_identifier *v56;
  const char *v57;
  const char *name;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  const char *v62;
  const char *v63;
  const char *v64;
  NSObject *v65;
  os_log_type_t v66;
  const char *v67;
  NSObject *v68;
  char *v69;
  _BOOL4 v70;
  nw_protocol_identifier *v71;
  char *v72;
  _BOOL4 v73;
  const char *v74;
  char *backtrace_string;
  _BOOL4 v76;
  char *v77;
  _BOOL4 v78;
  const char *v79;
  char *v80;
  _BOOL4 v81;
  _BOOL4 v82;
  _BOOL4 v83;
  nw_protocol_identifier *v84;
  const char *v85;
  nw_protocol_identifier *v86;
  const char *v87;
  _QWORD v88[2];
  uint64_t (*v89)(uint64_t, void *);
  void *v90;
  nw_protocol *v91;
  nw_protocol *v92;
  char v93;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v96;
  __int16 v97;
  nw_protocol *v98;
  __int16 v99;
  nw_protocol *v100;
  __int16 v101;
  char *v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_output_finished";
    v64 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v64, &type, &v93))
      goto LABEL_231;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v65 = __nwlog_obj();
      v66 = type;
      if (!os_log_type_enabled(v65, type))
        goto LABEL_231;
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_output_finished";
      v67 = "%{public}s called with null protocol";
    }
    else if (v93)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v65 = __nwlog_obj();
      v66 = type;
      v76 = os_log_type_enabled(v65, type);
      if (backtrace_string)
      {
        if (v76)
        {
          *(_DWORD *)buf = 136446466;
          v96 = "nw_protocol_test_output_finished";
          v97 = 2082;
          v98 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_231:
        if (!v64)
          return;
        goto LABEL_232;
      }
      if (!v76)
        goto LABEL_231;
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_output_finished";
      v67 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v65 = __nwlog_obj();
      v66 = type;
      if (!os_log_type_enabled(v65, type))
        goto LABEL_231;
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_output_finished";
      v67 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_230;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_output_finished";
    v64 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v64, &type, &v93))
      goto LABEL_231;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v93)
      {
        v65 = __nwlog_obj();
        v66 = type;
        if (!os_log_type_enabled(v65, type))
          goto LABEL_231;
        *(_DWORD *)buf = 136446210;
        v96 = "nw_protocol_test_output_finished";
        v67 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_230;
      }
      v77 = (char *)__nw_create_backtrace_string();
      v65 = __nwlog_obj();
      v66 = type;
      v78 = os_log_type_enabled(v65, type);
      if (!v77)
      {
        if (!v78)
          goto LABEL_231;
        *(_DWORD *)buf = 136446210;
        v96 = "nw_protocol_test_output_finished";
        v67 = "%{public}s called with null test, no backtrace";
        goto LABEL_230;
      }
      if (v78)
      {
        *(_DWORD *)buf = 136446466;
        v96 = "nw_protocol_test_output_finished";
        v97 = 2082;
        v98 = (nw_protocol *)v77;
        v79 = "%{public}s called with null test, dumping backtrace:%{public}s";
LABEL_182:
        _os_log_impl(&dword_182FBE000, v65, v66, v79, buf, 0x16u);
      }
LABEL_183:
      free(v77);
      if (!v64)
        return;
LABEL_232:
      v51 = (nw_protocol *)v64;
LABEL_111:
      free(v51);
      return;
    }
    v65 = __nwlog_obj();
    v66 = type;
    if (!os_log_type_enabled(v65, type))
      goto LABEL_231;
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_output_finished";
    v67 = "%{public}s called with null test";
LABEL_230:
    _os_log_impl(&dword_182FBE000, v65, v66, v67, buf, 0xCu);
    goto LABEL_231;
  }
  if (gLogDatapath)
  {
    v68 = __nwlog_obj();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v96 = "nw_protocol_test_output_finished";
      v97 = 2082;
      v98 = a1 + 2;
      _os_log_impl(&dword_182FBE000, v68, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s output_finished", buf, 0x16u);
    }
  }
  v88[0] = MEMORY[0x1E0C809B0];
  v88[1] = 0x40000000;
  v89 = ___ZL32nw_protocol_test_output_finishedP11nw_protocolS0__block_invoke;
  v90 = &__block_descriptor_tmp_41_83641;
  v91 = a1;
  v92 = a2;
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_access_options";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (__nwlog_fault(v16, &type, &v93))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          v19 = "%{public}s called with null test";
LABEL_60:
          _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
        }
      }
      else if (v93)
      {
        v80 = (char *)__nw_create_backtrace_string();
        v17 = __nwlog_obj();
        v18 = type;
        v81 = os_log_type_enabled(v17, type);
        if (v80)
        {
          if (v81)
          {
            *(_DWORD *)buf = 136446466;
            v96 = "nw_protocol_test_access_options";
            v97 = 2082;
            v98 = (nw_protocol *)v80;
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null test, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v80);
        }
        else if (v81)
        {
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          v19 = "%{public}s called with null test, no backtrace";
          goto LABEL_60;
        }
      }
      else
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          v19 = "%{public}s called with null test, backtrace limit exceeded";
          goto LABEL_60;
        }
      }
    }
LABEL_61:
    if (!v16)
      goto LABEL_80;
    goto LABEL_62;
  }
  callbacks = a1[1].callbacks;
  if (callbacks)
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  v5 = a1->callbacks;
  if (v5)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v5->get_parameters;
    if (get_parameters)
    {
      v7 = (void *)get_parameters(a1);
      goto LABEL_10;
    }
  }
  __nwlog_obj();
  identifier = a1->identifier;
  *(_DWORD *)buf = 136446722;
  v96 = "__nw_protocol_get_parameters";
  if (!identifier)
    identifier = (nw_protocol_identifier *)"invalid";
  v97 = 2082;
  v98 = (nw_protocol *)identifier;
  v99 = 2048;
  v100 = a1;
  v53 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v93 = 0;
  if (__nwlog_fault(v53, &type, &v93))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v54 = __nwlog_obj();
      v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        v56 = a1->identifier;
        if (!v56)
          v56 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v96 = "__nw_protocol_get_parameters";
        v97 = 2082;
        v98 = (nw_protocol *)v56;
        v99 = 2048;
        v100 = a1;
        v57 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_201:
        _os_log_impl(&dword_182FBE000, v54, v55, v57, buf, 0x20u);
      }
    }
    else if (v93)
    {
      v69 = (char *)__nw_create_backtrace_string();
      v54 = __nwlog_obj();
      v55 = type;
      v70 = os_log_type_enabled(v54, type);
      if (v69)
      {
        if (v70)
        {
          v71 = a1->identifier;
          if (!v71)
            v71 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446978;
          v96 = "__nw_protocol_get_parameters";
          v97 = 2082;
          v98 = (nw_protocol *)v71;
          v99 = 2048;
          v100 = a1;
          v101 = 2082;
          v102 = v69;
          _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v69);
        goto LABEL_202;
      }
      if (v70)
      {
        v86 = a1->identifier;
        if (!v86)
          v86 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v96 = "__nw_protocol_get_parameters";
        v97 = 2082;
        v98 = (nw_protocol *)v86;
        v99 = 2048;
        v100 = a1;
        v57 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
        goto LABEL_201;
      }
    }
    else
    {
      v54 = __nwlog_obj();
      v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        v84 = a1->identifier;
        if (!v84)
          v84 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v96 = "__nw_protocol_get_parameters";
        v97 = 2082;
        v98 = (nw_protocol *)v84;
        v99 = 2048;
        v100 = a1;
        v57 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
        goto LABEL_201;
      }
    }
  }
LABEL_202:
  if (v53)
    free(v53);
  v7 = 0;
LABEL_10:
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v12 = a1[1].callbacks;
    if (v12)
    {
      v13 = (nw_protocol_callbacks *)((char *)v12 - 1);
      a1[1].callbacks = v13;
      if (!v13)
      {
        v14 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v14)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v14[2](v14);
          _Block_release(v14);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v15 = *(const void **)a1[1].flow_id;
          if (v15)
            _Block_release(v15);
        }
        free(a1);
      }
    }
  }
  if (v7)
  {
    if (nw_protocol_copy_test_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
    if (nw_protocol_copy_test_definition::test_definition)
    {
      v8 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
      if (v8)
      {
        v9 = v8;
        v10 = nw_parameters_copy_protocol_options_for_definition(v7, v8);
        if (v10)
        {
          v11 = v10;
          if (nw_protocol_options_is_test_protocol(v10))
          {
            v89((uint64_t)v88, v11);
LABEL_78:
            os_release(v9);
            v35 = v11;
LABEL_79:
            os_release(v35);
            goto LABEL_80;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          v24 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v93 = 0;
          if (__nwlog_fault(v24, &type, &v93))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v25 = gLogObj;
              v26 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type))
                goto LABEL_76;
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              v27 = "%{public}s Failed to copy test protocol options";
              goto LABEL_75;
            }
            if (!v93)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v25 = gLogObj;
              v26 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type))
                goto LABEL_76;
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              v27 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
              goto LABEL_75;
            }
            v33 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v25 = gLogObj;
            v26 = type;
            v34 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v33)
            {
              if (v34)
              {
                *(_DWORD *)buf = 136446466;
                v96 = "nw_protocol_test_access_options";
                v97 = 2082;
                v98 = (nw_protocol *)v33;
                _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v33);
              goto LABEL_76;
            }
            if (v34)
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              v27 = "%{public}s Failed to copy test protocol options, no backtrace";
LABEL_75:
              _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
            }
          }
LABEL_76:
          if (v24)
            free(v24);
          goto LABEL_78;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v96 = "nw_protocol_test_access_options";
        v20 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v93 = 0;
        if (__nwlog_fault(v20, &type, &v93))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v21 = gLogObj;
            v22 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              v23 = "%{public}s Failed to copy protocol options";
LABEL_69:
              _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0xCu);
            }
          }
          else if (v93)
          {
            v31 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v21 = gLogObj;
            v22 = type;
            v32 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v31)
            {
              if (v32)
              {
                *(_DWORD *)buf = 136446466;
                v96 = "nw_protocol_test_access_options";
                v97 = 2082;
                v98 = (nw_protocol *)v31;
                _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v31);
              goto LABEL_70;
            }
            if (v32)
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              v23 = "%{public}s Failed to copy protocol options, no backtrace";
              goto LABEL_69;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v21 = gLogObj;
            v22 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              v23 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
              goto LABEL_69;
            }
          }
        }
LABEL_70:
        if (v20)
          free(v20);
        v35 = (unsigned __int8 *)v9;
        goto LABEL_79;
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_access_options";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v16, &type, &v93))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      v19 = "%{public}s called with null definition";
      goto LABEL_60;
    }
    if (!v93)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      v19 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_60;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v29 = os_log_type_enabled(v17, type);
    if (!v28)
    {
      if (!v29)
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      v19 = "%{public}s called with null definition, no backtrace";
      goto LABEL_60;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v96 = "nw_protocol_test_access_options";
      v97 = 2082;
      v98 = (nw_protocol *)v28;
      v30 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_182FBE000, v17, v18, v30, buf, 0x16u);
      goto LABEL_44;
    }
    goto LABEL_44;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v96 = "nw_protocol_test_access_options";
  v16 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v93 = 0;
  if (!__nwlog_fault(v16, &type, &v93))
    goto LABEL_61;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v17 = __nwlog_obj();
    v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      v19 = "%{public}s called with null parameters";
      goto LABEL_60;
    }
    goto LABEL_61;
  }
  if (!v93)
  {
    v17 = __nwlog_obj();
    v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      v19 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_60;
    }
    goto LABEL_61;
  }
  v28 = (char *)__nw_create_backtrace_string();
  v17 = __nwlog_obj();
  v18 = type;
  v83 = os_log_type_enabled(v17, type);
  if (!v28)
  {
    if (v83)
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      v19 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_60;
    }
    goto LABEL_61;
  }
  if (v83)
  {
    *(_DWORD *)buf = 136446466;
    v96 = "nw_protocol_test_access_options";
    v97 = 2082;
    v98 = (nw_protocol *)v28;
    v30 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
    goto LABEL_43;
  }
LABEL_44:
  free(v28);
  if (v16)
LABEL_62:
    free(v16);
LABEL_80:
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "__nw_protocol_output_finished";
    v64 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v64, &type, &v93))
      goto LABEL_231;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v65 = __nwlog_obj();
      v66 = type;
      if (!os_log_type_enabled(v65, type))
        goto LABEL_231;
      *(_DWORD *)buf = 136446210;
      v96 = "__nw_protocol_output_finished";
      v67 = "%{public}s called with null protocol";
      goto LABEL_230;
    }
    if (!v93)
    {
      v65 = __nwlog_obj();
      v66 = type;
      if (!os_log_type_enabled(v65, type))
        goto LABEL_231;
      *(_DWORD *)buf = 136446210;
      v96 = "__nw_protocol_output_finished";
      v67 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_230;
    }
    v77 = (char *)__nw_create_backtrace_string();
    v65 = __nwlog_obj();
    v66 = type;
    v82 = os_log_type_enabled(v65, type);
    if (!v77)
    {
      if (!v82)
        goto LABEL_231;
      *(_DWORD *)buf = 136446210;
      v96 = "__nw_protocol_output_finished";
      v67 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_230;
    }
    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      v96 = "__nw_protocol_output_finished";
      v97 = 2082;
      v98 = (nw_protocol *)v77;
      v79 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_182;
    }
    goto LABEL_183;
  }
  handle = output_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    v38 = output_handler[1].callbacks;
    if (v38)
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v38->add_input_handler + 1);
  }
  v39 = a1->handle;
  if (v39 == &nw_protocol_ref_counted_handle)
  {
    v40 = a1[1].callbacks;
    if (v40)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v40->add_input_handler + 1);
  }
  v41 = output_handler->callbacks;
  if (v41)
  {
    output_finished = (void (*)(nw_protocol *, nw_protocol *))v41->output_finished;
    if (output_finished)
    {
      output_finished(output_handler, a1);
      goto LABEL_90;
    }
  }
  __nwlog_obj();
  name = output_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v96 = "__nw_protocol_output_finished";
  if (!name)
    name = "invalid";
  v97 = 2082;
  v98 = (nw_protocol *)name;
  v99 = 2048;
  v100 = output_handler;
  v59 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v93 = 0;
  if (__nwlog_fault(v59, &type, &v93))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v60 = __nwlog_obj();
      v61 = type;
      if (!os_log_type_enabled(v60, type))
        goto LABEL_210;
      v62 = output_handler->identifier->name;
      if (!v62)
        v62 = "invalid";
      *(_DWORD *)buf = 136446722;
      v96 = "__nw_protocol_output_finished";
      v97 = 2082;
      v98 = (nw_protocol *)v62;
      v99 = 2048;
      v100 = output_handler;
      v63 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback";
      goto LABEL_209;
    }
    if (!v93)
    {
      v60 = __nwlog_obj();
      v61 = type;
      if (!os_log_type_enabled(v60, type))
        goto LABEL_210;
      v85 = output_handler->identifier->name;
      if (!v85)
        v85 = "invalid";
      *(_DWORD *)buf = 136446722;
      v96 = "__nw_protocol_output_finished";
      v97 = 2082;
      v98 = (nw_protocol *)v85;
      v99 = 2048;
      v100 = output_handler;
      v63 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded";
      goto LABEL_209;
    }
    v72 = (char *)__nw_create_backtrace_string();
    v60 = __nwlog_obj();
    v61 = type;
    v73 = os_log_type_enabled(v60, type);
    if (v72)
    {
      if (v73)
      {
        v74 = output_handler->identifier->name;
        if (!v74)
          v74 = "invalid";
        *(_DWORD *)buf = 136446978;
        v96 = "__nw_protocol_output_finished";
        v97 = 2082;
        v98 = (nw_protocol *)v74;
        v99 = 2048;
        v100 = output_handler;
        v101 = 2082;
        v102 = v72;
        _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v72);
      goto LABEL_210;
    }
    if (v73)
    {
      v87 = output_handler->identifier->name;
      if (!v87)
        v87 = "invalid";
      *(_DWORD *)buf = 136446722;
      v96 = "__nw_protocol_output_finished";
      v97 = 2082;
      v98 = (nw_protocol *)v87;
      v99 = 2048;
      v100 = output_handler;
      v63 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace";
LABEL_209:
      _os_log_impl(&dword_182FBE000, v60, v61, v63, buf, 0x20u);
    }
  }
LABEL_210:
  if (v59)
    free(v59);
LABEL_90:
  if (v39 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    v43 = a1[1].callbacks;
    if (v43)
    {
      v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
      a1[1].callbacks = v44;
      if (!v44)
      {
        v45 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v45)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v45[2](v45);
          _Block_release(v45);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v46 = *(const void **)a1[1].flow_id;
          if (v46)
            _Block_release(v46);
        }
        free(a1);
      }
    }
  }
  if (handle == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
  {
    v47 = output_handler[1].callbacks;
    if (v47)
    {
      v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
      output_handler[1].callbacks = v48;
      if (!v48)
      {
        v49 = *(void (***)(_QWORD))output_handler[1].flow_id;
        if (v49)
        {
          *(_QWORD *)output_handler[1].flow_id = 0;
          v49[2](v49);
          _Block_release(v49);
        }
        if ((output_handler[1].flow_id[8] & 1) != 0)
        {
          v50 = *(const void **)output_handler[1].flow_id;
          if (v50)
            _Block_release(v50);
        }
        v51 = output_handler;
        goto LABEL_111;
      }
    }
  }
}

void nw_protocol_test_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, uint64_t);
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t);
  void *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  void (**v30)(_QWORD);
  const void *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  char *v40;
  _BOOL4 v41;
  const char *v42;
  char *v43;
  _BOOL4 v44;
  char *v45;
  _BOOL4 v46;
  uint64_t v47;
  uint64_t v48;
  void (**v49)(_QWORD);
  const void *v50;
  unsigned __int8 *v51;
  const char *v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  const char *v57;
  char *v58;
  _BOOL4 v59;
  const char *v60;
  char *backtrace_string;
  _BOOL4 v62;
  _BOOL4 v63;
  _BOOL4 v64;
  _BOOL4 v65;
  const char *v66;
  const char *v67;
  _QWORD v68[6];
  char v69;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  void *v74;
  __int16 v75;
  uint64_t v76;
  __int16 v77;
  char *v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_get_message_properties";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (!__nwlog_fault(v24, &type, &v69))
      goto LABEL_89;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v69)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v62 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v62)
          {
            *(_DWORD *)buf = 136446466;
            v72 = "nw_protocol_test_get_message_properties";
            v73 = 2082;
            v74 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v62)
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_get_message_properties";
          v27 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_get_message_properties";
          v27 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
      goto LABEL_89;
    }
    v25 = __nwlog_obj();
    v26 = type;
    if (!os_log_type_enabled(v25, type))
      goto LABEL_89;
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_get_message_properties";
    v27 = "%{public}s called with null protocol";
LABEL_88:
    _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
    goto LABEL_89;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_get_message_properties";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (!__nwlog_fault(v24, &type, &v69))
      goto LABEL_89;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v69)
      {
        v40 = (char *)__nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v63 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v63)
          {
            *(_DWORD *)buf = 136446466;
            v72 = "nw_protocol_test_get_message_properties";
            v73 = 2082;
            v74 = v40;
            v42 = "%{public}s called with null test, dumping backtrace:%{public}s";
            goto LABEL_63;
          }
LABEL_64:
          free(v40);
          if (!v24)
            return;
          goto LABEL_90;
        }
        if (v63)
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_get_message_properties";
          v27 = "%{public}s called with null test, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_get_message_properties";
          v27 = "%{public}s called with null test, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
      goto LABEL_89;
    }
    v25 = __nwlog_obj();
    v26 = type;
    if (!os_log_type_enabled(v25, type))
      goto LABEL_89;
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_get_message_properties";
    v27 = "%{public}s called with null test";
    goto LABEL_88;
  }
  if (!a3)
    return;
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 24);
    if (v6)
    {
      v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 248);
      v8 = &nw_protocol_ref_counted_handle;
      if (v7)
      {
        v9 = *(void **)(v5 + 40);
        if (v9 == &nw_protocol_ref_counted_handle)
        {
          v10 = *(_QWORD *)(v5 + 88);
          if (v10)
            *(_QWORD *)(v5 + 88) = v10 + 1;
        }
        v11 = *(_QWORD *)(a1 + 88);
        if (v11)
          *(_QWORD *)(a1 + 88) = v11 + 1;
        v7(v5, a1, a3);
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          v28 = *(_QWORD *)(a1 + 88);
          if (v28)
          {
            v29 = v28 - 1;
            *(_QWORD *)(a1 + 88) = v29;
            if (!v29)
            {
              v30 = *(void (***)(_QWORD))(a1 + 64);
              if (v30)
              {
                *(_QWORD *)(a1 + 64) = 0;
                v30[2](v30);
                _Block_release(v30);
              }
              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                v31 = *(const void **)(a1 + 64);
                if (v31)
                  _Block_release(v31);
              }
              free((void *)a1);
            }
          }
        }
        if (v9 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
        {
          v47 = *(_QWORD *)(v5 + 88);
          if (v47)
          {
            v48 = v47 - 1;
            *(_QWORD *)(v5 + 88) = v48;
            if (!v48)
            {
              v49 = *(void (***)(_QWORD))(v5 + 64);
              if (v49)
              {
                *(_QWORD *)(v5 + 64) = 0;
                v49[2](v49);
                _Block_release(v49);
              }
              if ((*(_BYTE *)(v5 + 72) & 1) != 0)
              {
                v50 = *(const void **)(v5 + 64);
                if (v50)
                  _Block_release(v50);
              }
              free((void *)v5);
            }
          }
        }
        v8 = *(void **)(a1 + 40);
      }
    }
    else
    {
      v8 = &nw_protocol_ref_counted_handle;
    }
  }
  else
  {
    v8 = &nw_protocol_ref_counted_handle;
  }
  v68[0] = MEMORY[0x1E0C809B0];
  v68[1] = 0x40000000;
  v68[2] = ___ZL39nw_protocol_test_get_message_propertiesP11nw_protocolS0_P30nw_protocol_message_properties_block_invoke;
  v68[3] = &__block_descriptor_tmp_42_83583;
  v68[4] = a1 + 96;
  v68[5] = a3;
  if (v8 != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_access_options";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (!__nwlog_fault(v24, &type, &v69))
      goto LABEL_89;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v69)
      {
        v40 = (char *)__nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v64 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136446466;
            v72 = "nw_protocol_test_access_options";
            v73 = 2082;
            v74 = v40;
            v42 = "%{public}s called with null test, dumping backtrace:%{public}s";
            goto LABEL_63;
          }
          goto LABEL_64;
        }
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v27 = "%{public}s called with null test, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v27 = "%{public}s called with null test, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
      goto LABEL_89;
    }
    v25 = __nwlog_obj();
    v26 = type;
    if (!os_log_type_enabled(v25, type))
      goto LABEL_89;
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_access_options";
    v27 = "%{public}s called with null test";
    goto LABEL_88;
  }
  v12 = *(_QWORD *)(a1 + 88);
  if (v12)
    *(_QWORD *)(a1 + 88) = v12 + 1;
  v13 = *(_QWORD *)(a1 + 24);
  if (v13)
  {
    v14 = *(uint64_t (**)(uint64_t))(v13 + 112);
    if (v14)
    {
      v15 = (void *)v14(a1);
      goto LABEL_22;
    }
  }
  __nwlog_obj();
  v52 = *(const char **)(a1 + 16);
  *(_DWORD *)buf = 136446722;
  v72 = "__nw_protocol_get_parameters";
  if (!v52)
    v52 = "invalid";
  v73 = 2082;
  v74 = (void *)v52;
  v75 = 2048;
  v76 = a1;
  v53 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v69 = 0;
  if (__nwlog_fault(v53, &type, &v69))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v54 = __nwlog_obj();
      v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        v56 = *(const char **)(a1 + 16);
        if (!v56)
          v56 = "invalid";
        *(_DWORD *)buf = 136446722;
        v72 = "__nw_protocol_get_parameters";
        v73 = 2082;
        v74 = (void *)v56;
        v75 = 2048;
        v76 = a1;
        v57 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_171:
        _os_log_impl(&dword_182FBE000, v54, v55, v57, buf, 0x20u);
      }
    }
    else if (v69)
    {
      v58 = (char *)__nw_create_backtrace_string();
      v54 = __nwlog_obj();
      v55 = type;
      v59 = os_log_type_enabled(v54, type);
      if (v58)
      {
        if (v59)
        {
          v60 = *(const char **)(a1 + 16);
          if (!v60)
            v60 = "invalid";
          *(_DWORD *)buf = 136446978;
          v72 = "__nw_protocol_get_parameters";
          v73 = 2082;
          v74 = (void *)v60;
          v75 = 2048;
          v76 = a1;
          v77 = 2082;
          v78 = v58;
          _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v58);
        goto LABEL_172;
      }
      if (v59)
      {
        v67 = *(const char **)(a1 + 16);
        if (!v67)
          v67 = "invalid";
        *(_DWORD *)buf = 136446722;
        v72 = "__nw_protocol_get_parameters";
        v73 = 2082;
        v74 = (void *)v67;
        v75 = 2048;
        v76 = a1;
        v57 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
        goto LABEL_171;
      }
    }
    else
    {
      v54 = __nwlog_obj();
      v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        v66 = *(const char **)(a1 + 16);
        if (!v66)
          v66 = "invalid";
        *(_DWORD *)buf = 136446722;
        v72 = "__nw_protocol_get_parameters";
        v73 = 2082;
        v74 = (void *)v66;
        v75 = 2048;
        v76 = a1;
        v57 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
        goto LABEL_171;
      }
    }
  }
LABEL_172:
  if (v53)
    free(v53);
  v15 = 0;
LABEL_22:
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a1 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a1 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a1 + 64);
        if (v22)
        {
          *(_QWORD *)(a1 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a1 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a1);
      }
    }
  }
  if (!v15)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_access_options";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v24, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v27 = "%{public}s called with null parameters";
          goto LABEL_88;
        }
      }
      else if (v69)
      {
        v40 = (char *)__nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v65 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136446466;
            v72 = "nw_protocol_test_access_options";
            v73 = 2082;
            v74 = v40;
            v42 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
            goto LABEL_63;
          }
          goto LABEL_64;
        }
        if (v65)
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v27 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v27 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
    }
LABEL_89:
    if (!v24)
      return;
LABEL_90:
    free(v24);
    return;
  }
  if (nw_protocol_copy_test_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
  if (!nw_protocol_copy_test_definition::test_definition
    || (v16 = (unsigned __int8 *)os_retain((void *)nw_protocol_copy_test_definition::test_definition)) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_access_options";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (!__nwlog_fault(v24, &type, &v69))
      goto LABEL_89;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_test_access_options";
      v27 = "%{public}s called with null definition";
      goto LABEL_88;
    }
    if (!v69)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_test_access_options";
      v27 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_88;
    }
    v40 = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v41 = os_log_type_enabled(v25, type);
    if (!v40)
    {
      if (!v41)
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_test_access_options";
      v27 = "%{public}s called with null definition, no backtrace";
      goto LABEL_88;
    }
    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      v72 = "nw_protocol_test_access_options";
      v73 = 2082;
      v74 = v40;
      v42 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_63:
      _os_log_impl(&dword_182FBE000, v25, v26, v42, buf, 0x16u);
      goto LABEL_64;
    }
    goto LABEL_64;
  }
  v17 = v16;
  v18 = nw_parameters_copy_protocol_options_for_definition(v15, v16);
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_access_options";
    v32 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v32, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = gLogObj;
        v34 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v35 = "%{public}s Failed to copy protocol options";
LABEL_97:
          _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
        }
      }
      else if (v69)
      {
        v43 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = gLogObj;
        v34 = type;
        v44 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v43)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            v72 = "nw_protocol_test_access_options";
            v73 = 2082;
            v74 = v43;
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v43);
          goto LABEL_98;
        }
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v35 = "%{public}s Failed to copy protocol options, no backtrace";
          goto LABEL_97;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = gLogObj;
        v34 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_test_access_options";
          v35 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
          goto LABEL_97;
        }
      }
    }
LABEL_98:
    if (v32)
      free(v32);
    v51 = v17;
    goto LABEL_107;
  }
  v19 = v18;
  if (!nw_protocol_options_is_test_protocol(v18))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v72 = "nw_protocol_test_access_options";
    v36 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (!__nwlog_fault(v36, &type, &v69))
      goto LABEL_104;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = gLogObj;
      v38 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_test_access_options";
      v39 = "%{public}s Failed to copy test protocol options";
    }
    else if (v69)
    {
      v45 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = gLogObj;
      v38 = type;
      v46 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v45)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          v72 = "nw_protocol_test_access_options";
          v73 = 2082;
          v74 = v45;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v45);
        goto LABEL_104;
      }
      if (!v46)
      {
LABEL_104:
        if (v36)
          free(v36);
        goto LABEL_106;
      }
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_test_access_options";
      v39 = "%{public}s Failed to copy test protocol options, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = gLogObj;
      v38 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_test_access_options";
      v39 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v37, v38, v39, buf, 0xCu);
    goto LABEL_104;
  }
  ___ZL39nw_protocol_test_get_message_propertiesP11nw_protocolS0_P30nw_protocol_message_properties_block_invoke((uint64_t)v68, v19);
LABEL_106:
  os_release(v17);
  v51 = v19;
LABEL_107:
  os_release(v51);
}

uint64_t nw_protocol_test_create(const nw_protocol_identifier *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v3;

  v3 = nw_protocol_new(120, (uint64_t)a3, (uint64_t)&g_test_protocol_identifier, (uint64_t)&g_test_protocol_callbacks);
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_BYTE *)(v3 + 117) &= 0xFCu;
  *(_QWORD *)(v3 + 16) = v3 + 8;
  *(_BYTE *)(v3 + 116) = 0;
  return v3 - 96;
}

uint64_t ___ZL39nw_protocol_test_get_message_propertiesP11nw_protocolS0_P30nw_protocol_message_properties_block_invoke(uint64_t a1, void *a2)
{
  int v4;
  _DWORD *v5;
  unsigned int v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  unsigned __int8 v17;
  __int16 v18;
  int v19;
  char v20;
  os_log_type_t type;
  _BYTE buf[24];
  __int128 v23;
  int *v24;
  char *v25;
  __int16 *v26;
  unsigned __int8 *v27;
  _BYTE v28[24];
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  v18 = 0;
  v17 = 0;
  if (nw_protocol_options_is_test_protocol(a2))
  {
    *(_QWORD *)v28 = 0;
    *(_QWORD *)&v28[8] = v28;
    *(_QWORD *)&v28[16] = 0x2000000000;
    v29 = 0;
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZL47nw_protocol_test_options_get_message_propertiesP19nw_protocol_optionsPjPbS2_S2__block_invoke;
    *(_QWORD *)&v23 = &unk_1E14AC1D8;
    *((_QWORD *)&v23 + 1) = v28;
    v24 = &v19;
    v25 = (char *)&v18 + 1;
    v26 = &v18;
    v27 = &v17;
    nw_protocol_options_access_handle(a2, buf);
    v4 = *(unsigned __int8 *)(*(_QWORD *)&v28[8] + 24);
    _Block_object_dispose(v28, 8);
    if (v4)
    {
      if (gLogDatapath)
      {
        v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          v13 = *(_QWORD *)(a1 + 32);
          if (v13)
            v14 = (const char *)(v13 + 32);
          else
            v14 = "";
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_protocol_test_get_message_properties_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v14;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v23) = v19;
          WORD2(v23) = 1024;
          *(_DWORD *)((char *)&v23 + 6) = HIBYTE(v18);
          WORD5(v23) = 1024;
          HIDWORD(v23) = v18;
          LOWORD(v24) = 1024;
          *(_DWORD *)((char *)&v24 + 2) = v17;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s setting maximum_message_size %u, frame_as_message %{BOOL}d, allow_discontiguous_messages %{BOOL}d, receive_single_message %{BOOL}d", buf, 0x2Eu);
        }
      }
      v5 = *(_DWORD **)(a1 + 40);
      v6 = v5[1] & 0xFFFFFFFE | HIBYTE(v18);
      *v5 = v19;
      v5[1] = v6;
      *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4) = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4) & 0xFFFFFFFD | (2 * v18);
      *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4) = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4) & 0xFFFFFFFB | (4 * v17);
    }
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)v28 = 136446210;
  *(_QWORD *)&v28[4] = "nw_protocol_test_options_get_message_properties";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v8, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_25;
      *(_DWORD *)v28 = 136446210;
      *(_QWORD *)&v28[4] = "nw_protocol_test_options_get_message_properties";
      v11 = "%{public}s protocol options are not test protocol";
      goto LABEL_24;
    }
    if (!v20)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_25;
      *(_DWORD *)v28 = 136446210;
      *(_QWORD *)&v28[4] = "nw_protocol_test_options_get_message_properties";
      v11 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v16 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)v28 = 136446466;
        *(_QWORD *)&v28[4] = "nw_protocol_test_options_get_message_properties";
        *(_WORD *)&v28[12] = 2082;
        *(_QWORD *)&v28[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", v28, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_25;
    }
    if (v16)
    {
      *(_DWORD *)v28 = 136446210;
      *(_QWORD *)&v28[4] = "nw_protocol_test_options_get_message_properties";
      v11 = "%{public}s protocol options are not test protocol, no backtrace";
LABEL_24:
      _os_log_impl(&dword_182FBE000, v9, v10, v11, v28, 0xCu);
    }
  }
LABEL_25:
  if (v8)
    free(v8);
  return 1;
}

BOOL nw_protocol_options_is_test_protocol(void *a1)
{
  id *v1;
  id v2;
  void *v3;
  _BOOL8 is_equal_unsafe;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = a1;
    v2 = v1[1];

    if (nw_protocol_copy_test_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
    if (nw_protocol_copy_test_definition::test_definition)
      v3 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
    else
      v3 = 0;
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v2, (uint64_t)v3);
    if (v2)
      os_release(v2);
    if (v3)
      os_release(v3);
    return is_equal_unsafe;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_options_is_test_protocol";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_test_protocol";
        v9 = "%{public}s called with null options";
LABEL_25:
        _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_options_is_test_protocol";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_26;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_test_protocol";
        v9 = "%{public}s called with null options, no backtrace";
        goto LABEL_25;
      }
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_test_protocol";
        v9 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_25;
      }
    }
  }
LABEL_26:
  if (v6)
    free(v6);
  return 0;
}

uint64_t ___ZL47nw_protocol_test_options_get_message_propertiesP19nw_protocol_optionsPjPbS2_S2__block_invoke(uint64_t a1, uint64_t a2)
{
  BOOL *v2;
  BOOL *v3;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 44) & 1;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v2 = *(BOOL **)(a1 + 48);
    **(_DWORD **)(a1 + 40) = *(_DWORD *)(a2 + 40);
    *v2 = (*(_BYTE *)(a2 + 44) & 2) != 0;
    v3 = *(BOOL **)(a1 + 64);
    **(_BYTE **)(a1 + 56) = (*(_BYTE *)(a2 + 44) & 4) != 0;
    *v3 = (*(_BYTE *)(a2 + 44) & 8) != 0;
  }
  return 1;
}

uint64_t ___ZL32nw_protocol_test_output_finishedP11nw_protocolS0__block_invoke(uint64_t a1, void *a2)
{
  uint64_t event_handler;

  event_handler = nw_protocol_test_options_get_event_handler(a2, 1);
  if (event_handler)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(event_handler + 16))(event_handler, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  return 1;
}

uint64_t nw_protocol_test_options_get_event_handler(void *a1, int a2)
{
  char v2;
  uint64_t v4;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _QWORD v15[5];
  char v16;
  char v17;
  os_log_type_t type;
  _BYTE buf[24];
  void (*v20)(uint64_t, uint64_t);
  void (*v21)(uint64_t);
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
      v9 = "%{public}s called with null options";
LABEL_44:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      goto LABEL_45;
    }
    if (!v17)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
        v9 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
        v9 = "%{public}s called with null options, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v11)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v12 = "%{public}s called with null options, dumping backtrace:%{public}s";
LABEL_30:
    _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
    goto LABEL_31;
  }
  v2 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
      v9 = "%{public}s called with null event";
      goto LABEL_44;
    }
    if (!v17)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
        v9 = "%{public}s called with null event, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
        v9 = "%{public}s called with null event, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v13)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v12 = "%{public}s called with null event, dumping backtrace:%{public}s";
    goto LABEL_30;
  }
  if (nw_protocol_options_is_test_protocol(a1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3002000000;
    v20 = __Block_byref_object_copy__83673;
    v21 = __Block_byref_object_dispose__83674;
    v22 = 0;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 0x40000000;
    v15[2] = __nw_protocol_test_options_get_event_handler_block_invoke;
    v15[3] = &unk_1E14ABFC0;
    v16 = v2;
    v15[4] = buf;
    nw_protocol_options_access_handle(a1, v15);
    v4 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);
    return v4;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v6, &type, &v17))
    goto LABEL_45;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
        v9 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
        v9 = "%{public}s protocol options are not test protocol, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v12 = "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
LABEL_31:
    free(backtrace_string);
    goto LABEL_45;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_event_handler";
    v9 = "%{public}s protocol options are not test protocol";
    goto LABEL_44;
  }
LABEL_45:
  if (v6)
    free(v6);
  return 0;
}

void __Block_byref_object_copy__83673(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 135);
}

void __Block_byref_object_dispose__83674(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 135);
}

uint64_t __nw_protocol_test_options_get_event_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 40) == 1)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = *(_QWORD *)(a2 + 24);
    return 1;
  }
  if (!*(_BYTE *)(a1 + 40))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v12 = "nw_protocol_test_options_get_event_handler_block_invoke";
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v9 = 0;
    if (!__nwlog_fault(v2, &type, &v9))
      goto LABEL_18;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_test_options_get_event_handler_block_invoke";
      v5 = "%{public}s Invalid event supplied";
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      v7 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v12 = "nw_protocol_test_options_get_event_handler_block_invoke";
          v13 = 2082;
          v14 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s Invalid event supplied, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (!v7)
      {
LABEL_18:
        if (v2)
          free(v2);
        return 1;
      }
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_test_options_get_event_handler_block_invoke";
      v5 = "%{public}s Invalid event supplied, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_test_options_get_event_handler_block_invoke";
      v5 = "%{public}s Invalid event supplied, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    goto LABEL_18;
  }
  return 1;
}

uint64_t ___ZL39nw_protocol_test_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, void *a2)
{
  uint64_t finalize_output_frames_handler;

  finalize_output_frames_handler = nw_protocol_test_options_get_finalize_output_frames_handler(a2);
  if (finalize_output_frames_handler)
    (*(void (**)(uint64_t, _QWORD))(finalize_output_frames_handler + 16))(finalize_output_frames_handler, *(_QWORD *)(a1 + 32));
  return 1;
}

uint64_t nw_protocol_test_options_get_finalize_output_frames_handler(void *a1)
{
  uint64_t v2;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  _QWORD v10[5];
  char v11;
  os_log_type_t type;
  _BYTE buf[24];
  void (*v14)(uint64_t, uint64_t);
  void (*v15)(uint64_t);
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (nw_protocol_options_is_test_protocol(a1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3002000000;
    v14 = __Block_byref_object_copy__83673;
    v15 = __Block_byref_object_dispose__83674;
    v16 = 0;
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = __nw_protocol_test_options_get_finalize_output_frames_handler_block_invoke;
    v10[3] = &unk_1E14ABF70;
    v10[4] = buf;
    nw_protocol_options_access_handle(a1, v10);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);
    return v2;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
        v7 = "%{public}s protocol options are not test protocol";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
        v7 = "%{public}s protocol options are not test protocol, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
        v7 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v4)
    free(v4);
  return 0;
}

uint64_t __nw_protocol_test_options_get_finalize_output_frames_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = *(_QWORD *)(a2 + 8);
  return 1;
}

void ___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  void (**v16)(_QWORD);
  const void *v17;
  const char *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  NSObject *v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  char *v31;
  _BOOL4 v32;
  const char *v33;
  char *backtrace_string;
  _BOOL4 v35;
  const char *v36;
  const char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  char *v41;
  _BOOL4 v42;
  char v43;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  void *v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v24 = __nwlog_obj();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      v25 = *(_QWORD *)(a1 + 32);
      if (v25)
        v26 = (const char *)(v25 + 32);
      else
        v26 = "";
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_test_get_output_frames_block_invoke";
      v47 = 2082;
      v48 = (void *)v26;
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Calling output_available", buf, 0x16u);
    }
  }
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_get_input_handler";
    v27 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (!__nwlog_fault(v27, &type, &v43))
      goto LABEL_79;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v46 = "__nw_protocol_get_input_handler";
      v30 = "%{public}s called with null protocol";
    }
    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = type;
      v35 = os_log_type_enabled(v28, type);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          v46 = "__nw_protocol_get_input_handler";
          v47 = 2082;
          v48 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_79;
      }
      if (!v35)
      {
LABEL_79:
        if (v27)
          free(v27);
        goto LABEL_81;
      }
      *(_DWORD *)buf = 136446210;
      v46 = "__nw_protocol_get_input_handler";
      v30 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v46 = "__nw_protocol_get_input_handler";
      v30 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0xCu);
    goto LABEL_79;
  }
  v3 = *(_QWORD *)(v2 + 48);
  if (v3)
  {
    v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      v5 = *(_QWORD *)(v3 + 88);
      if (v5)
        *(_QWORD *)(v3 + 88) = v5 + 1;
    }
    v6 = *(void **)(v2 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v2 + 88);
      if (v7)
        *(_QWORD *)(v2 + 88) = v7 + 1;
    }
    v8 = *(_QWORD *)(v3 + 24);
    if (v8)
    {
      v9 = *(void (**)(uint64_t, uint64_t))(v8 + 72);
      if (v9)
      {
        v9(v3, v2);
        goto LABEL_13;
      }
    }
    __nwlog_obj();
    v18 = *(const char **)(v3 + 16);
    *(_DWORD *)buf = 136446722;
    v46 = "__nw_protocol_output_available";
    if (!v18)
      v18 = "invalid";
    v47 = 2082;
    v48 = (void *)v18;
    v49 = 2048;
    v50 = v3;
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (__nwlog_fault(v19, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v20 = __nwlog_obj();
        v21 = type;
        if (!os_log_type_enabled(v20, type))
          goto LABEL_72;
        v22 = *(const char **)(v3 + 16);
        if (!v22)
          v22 = "invalid";
        *(_DWORD *)buf = 136446722;
        v46 = "__nw_protocol_output_available";
        v47 = 2082;
        v48 = (void *)v22;
        v49 = 2048;
        v50 = v3;
        v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback";
        goto LABEL_71;
      }
      if (!v43)
      {
        v20 = __nwlog_obj();
        v21 = type;
        if (!os_log_type_enabled(v20, type))
          goto LABEL_72;
        v36 = *(const char **)(v3 + 16);
        if (!v36)
          v36 = "invalid";
        *(_DWORD *)buf = 136446722;
        v46 = "__nw_protocol_output_available";
        v47 = 2082;
        v48 = (void *)v36;
        v49 = 2048;
        v50 = v3;
        v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded";
        goto LABEL_71;
      }
      v31 = (char *)__nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v21 = type;
      v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          v33 = *(const char **)(v3 + 16);
          if (!v33)
            v33 = "invalid";
          *(_DWORD *)buf = 136446978;
          v46 = "__nw_protocol_output_available";
          v47 = 2082;
          v48 = (void *)v33;
          v49 = 2048;
          v50 = v3;
          v51 = 2082;
          v52 = v31;
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v31);
        goto LABEL_72;
      }
      if (v32)
      {
        v37 = *(const char **)(v3 + 16);
        if (!v37)
          v37 = "invalid";
        *(_DWORD *)buf = 136446722;
        v46 = "__nw_protocol_output_available";
        v47 = 2082;
        v48 = (void *)v37;
        v49 = 2048;
        v50 = v3;
        v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace";
LABEL_71:
        _os_log_impl(&dword_182FBE000, v20, v21, v23, buf, 0x20u);
      }
    }
LABEL_72:
    if (v19)
      free(v19);
LABEL_13:
    if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
    {
      v10 = *(_QWORD *)(v2 + 88);
      if (v10)
      {
        v11 = v10 - 1;
        *(_QWORD *)(v2 + 88) = v11;
        if (!v11)
        {
          v12 = *(void (***)(_QWORD))(v2 + 64);
          if (v12)
          {
            *(_QWORD *)(v2 + 64) = 0;
            v12[2](v12);
            _Block_release(v12);
          }
          if ((*(_BYTE *)(v2 + 72) & 1) != 0)
          {
            v13 = *(const void **)(v2 + 64);
            if (v13)
              _Block_release(v13);
          }
          free((void *)v2);
        }
      }
    }
    if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
    {
      v14 = *(_QWORD *)(v3 + 88);
      if (v14)
      {
        v15 = v14 - 1;
        *(_QWORD *)(v3 + 88) = v15;
        if (!v15)
        {
          v16 = *(void (***)(_QWORD))(v3 + 64);
          if (v16)
          {
            *(_QWORD *)(v3 + 64) = 0;
            v16[2](v16);
            _Block_release(v16);
          }
          if ((*(_BYTE *)(v3 + 72) & 1) != 0)
          {
            v17 = *(const void **)(v3 + 64);
            if (v17)
              _Block_release(v17);
          }
          goto LABEL_33;
        }
      }
    }
    return;
  }
LABEL_81:
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v46 = "__nw_protocol_output_available";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v43 = 0;
  if (!__nwlog_fault((const char *)v3, &type, &v43))
    goto LABEL_96;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v38 = __nwlog_obj();
    v39 = type;
    if (!os_log_type_enabled(v38, type))
      goto LABEL_96;
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    v40 = "%{public}s called with null protocol";
  }
  else if (v43)
  {
    v41 = (char *)__nw_create_backtrace_string();
    v38 = __nwlog_obj();
    v39 = type;
    v42 = os_log_type_enabled(v38, type);
    if (v41)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v46 = "__nw_protocol_output_available";
        v47 = 2082;
        v48 = v41;
        _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v41);
      if (v3)
        goto LABEL_33;
      return;
    }
    if (!v42)
      goto LABEL_96;
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    v40 = "%{public}s called with null protocol, no backtrace";
  }
  else
  {
    v38 = __nwlog_obj();
    v39 = type;
    if (!os_log_type_enabled(v38, type))
      goto LABEL_96;
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    v40 = "%{public}s called with null protocol, backtrace limit exceeded";
  }
  _os_log_impl(&dword_182FBE000, v38, v39, v40, buf, 0xCu);
LABEL_96:
  if (v3)
LABEL_33:
    free((void *)v3);
}

__n128 __Block_byref_object_copy__24(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_38(_QWORD *a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v4;
  _QWORD *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  const char *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v17;
  uint64_t v18;
  BOOL v19;
  const char *v20;
  const char *v21;
  unsigned int v22;
  NSObject *log;
  _DWORD *v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  unsigned int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unsigned int v34;
  uint64_t v35;

  v2 = (_DWORD *)a2;
  v35 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 48) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v6 = nw_frame_unclaimed_length((_DWORD *)a2);
  v24 = v2;
  if (gLogDatapath)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      v18 = a1[6];
      v19 = v18 == 0;
      *(_DWORD *)buf = 136446978;
      v20 = (const char *)(v18 + 32);
      v26 = "nw_protocol_test_get_output_frames_block_invoke";
      if (v19)
        v20 = "";
      v27 = 2082;
      v28 = v20;
      v29 = 1024;
      v30 = v6;
      v31 = 1024;
      v32 = 11;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Splitting frame of size %u into chunks of size %u", buf, 0x22u);
    }
  }
  if (v6 >= 0xC)
  {
    do
    {
      v7 = nw_frame_split((uint64_t *)&v24, 0xBu);
      v8 = nw_frame_unclaimed_length(v24);
      v9 = a1[7];
      *(_QWORD *)(v7 + 32) = 0;
      v10 = *(uint64_t **)(v9 + 8);
      *(_QWORD *)(v7 + 40) = v10;
      *v10 = v7;
      *(_QWORD *)(v9 + 8) = v7 + 32;
      ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
      if (gLogDatapath)
      {
        log = __nwlog_obj();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          v11 = a1[6];
          if (v11)
            v12 = (const char *)(v11 + 32);
          else
            v12 = "";
          v21 = v12;
          v22 = *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
          v13 = nw_frame_unclaimed_length((_DWORD *)v7);
          *(_DWORD *)buf = 136447234;
          v26 = "nw_protocol_test_get_output_frames_block_invoke";
          v27 = 2082;
          v28 = v21;
          v29 = 1024;
          v30 = v22;
          v31 = 1024;
          v32 = v13;
          v33 = 1024;
          v34 = v8;
          _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Split frame into small frame %u of size %u, remaining frame of size %u", buf, 0x28u);
        }
      }
    }
    while (v8 > 0xB);
    v2 = v24;
  }
  v14 = a1[7];
  *((_QWORD *)v2 + 4) = 0;
  v15 = *(_QWORD **)(v14 + 8);
  *((_QWORD *)v2 + 5) = v15;
  *v15 = v2;
  *(_QWORD *)(v14 + 8) = v2 + 8;
  ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  return 1;
}

void __nw_frame_malloc_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  void *buffer;

  buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0);
  if (buffer)
    free(buffer);
  nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
  if (a1)
    os_release(a1);
}

uint64_t ___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v4;
  _QWORD *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  const char *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v17;
  uint64_t v18;
  BOOL v19;
  const char *v20;
  const char *v21;
  unsigned int v22;
  NSObject *log;
  _DWORD *v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  unsigned int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unsigned int v34;
  uint64_t v35;

  v2 = (_DWORD *)a2;
  v35 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 48) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v6 = nw_frame_unclaimed_length((_DWORD *)a2);
  v24 = v2;
  if (gLogDatapath)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      v18 = a1[6];
      v19 = v18 == 0;
      *(_DWORD *)buf = 136446978;
      v20 = (const char *)(v18 + 32);
      v26 = "nw_protocol_test_get_input_frames_block_invoke";
      if (v19)
        v20 = "";
      v27 = 2082;
      v28 = v20;
      v29 = 1024;
      v30 = v6;
      v31 = 1024;
      v32 = 11;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Splitting frame of size %u into chunks of size %u", buf, 0x22u);
    }
  }
  if (v6 >= 0xC)
  {
    do
    {
      v7 = nw_frame_split((uint64_t *)&v24, 0xBu);
      v8 = nw_frame_unclaimed_length(v24);
      v9 = a1[7];
      *(_QWORD *)(v7 + 32) = 0;
      v10 = *(uint64_t **)(v9 + 8);
      *(_QWORD *)(v7 + 40) = v10;
      *v10 = v7;
      *(_QWORD *)(v9 + 8) = v7 + 32;
      ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
      if (gLogDatapath)
      {
        log = __nwlog_obj();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          v11 = a1[6];
          if (v11)
            v12 = (const char *)(v11 + 32);
          else
            v12 = "";
          v21 = v12;
          v22 = *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
          v13 = nw_frame_unclaimed_length((_DWORD *)v7);
          *(_DWORD *)buf = 136447234;
          v26 = "nw_protocol_test_get_input_frames_block_invoke";
          v27 = 2082;
          v28 = v21;
          v29 = 1024;
          v30 = v22;
          v31 = 1024;
          v32 = v13;
          v33 = 1024;
          v34 = v8;
          _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Split frame into small frame %u of size %u, remaining frame of size %u", buf, 0x28u);
        }
      }
    }
    while (v8 > 0xB);
    v2 = v24;
  }
  v14 = a1[7];
  *((_QWORD *)v2 + 4) = 0;
  v15 = *(_QWORD **)(v14 + 8);
  *((_QWORD *)v2 + 5) = v15;
  *v15 = v2;
  *(_QWORD *)(v14 + 8) = v2 + 8;
  ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  return 1;
}

BOOL ___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_28(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  const void *v9;
  size_t v10;
  int v11;
  char *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  _BOOL8 result;
  NSObject *v19;
  void *v20;
  NSObject *v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  void *v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  size_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 48) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  if (!*(_QWORD *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
  {
    v9 = 0;
    v8 = 0;
LABEL_13:
    v10 = 1;
    v11 = 1;
    goto LABEL_14;
  }
  v6 = *(_DWORD *)(a2 + 52);
  if (!v6)
  {
    v8 = 0;
    v9 = (const void *)(*(_QWORD *)(a2 + 112) + *(unsigned int *)(a2 + 56));
    goto LABEL_13;
  }
  v7 = *(unsigned int *)(a2 + 56);
  v8 = v6 - (v7 + *(_DWORD *)(a2 + 60));
  v9 = (const void *)(*(_QWORD *)(a2 + 112) + v7);
  v10 = v8 + 1;
  if (v8 == -1)
  {
    v24 = __nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v27 = "strict_malloc";
    v25 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v25);
    if (result)
      goto LABEL_30;
    free(v25);
    v10 = 0;
    v11 = 0;
    v8 = -1;
  }
  else
  {
    v11 = v8 + 1;
  }
LABEL_14:
  v12 = (char *)malloc_type_malloc(v10, 0xF2B69DE5uLL);
  if (!v12)
  {
    v19 = __nwlog_obj();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v27 = "strict_malloc";
    v28 = 2048;
    v29 = v10;
    v20 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v20);
    if (!result)
    {
      free(v20);
      memcpy((void *)1, v9, v8);
      v15 = nw_frame_create(0, 0, v11, (uint64_t)__nw_frame_custom_finalizer, 0);
      if (v15)
        goto LABEL_16;
      goto LABEL_18;
    }
LABEL_30:
    __break(1u);
    return result;
  }
  v13 = v12;
  memcpy(v12 + 1, v9, v8);
  v15 = nw_frame_create(0, (uint64_t)v13, v11, (uint64_t)__nw_frame_custom_finalizer, 0);
  if (v15)
  {
LABEL_16:
    *(_WORD *)(v15 + 204) |= 1u;
    nw_frame_claim(v15, v14, 1, 0);
    goto LABEL_18;
  }
  free(v13);
LABEL_18:
  if (gLogDatapath)
  {
    v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      v22 = a1[6];
      *(_DWORD *)buf = 136446978;
      v27 = "nw_protocol_test_get_input_frames_block_invoke";
      if (v22)
        v23 = (const char *)(v22 + 32);
      else
        v23 = "";
      v28 = 2082;
      v29 = (size_t)v23;
      v30 = 2048;
      v31 = v15;
      v32 = 2048;
      v33 = a2;
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Created new frame %p from frame %p", buf, 0x2Au);
    }
  }
  nw_frame_finalize(a2);
  v16 = a1[7];
  *(_QWORD *)(v15 + 32) = 0;
  v17 = *(uint64_t **)(v16 + 8);
  *(_QWORD *)(v15 + 40) = v17;
  *v17 = v15;
  *(_QWORD *)(v16 + 8) = v15 + 32;
  ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  return 1;
}

uint64_t ___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_30(_QWORD *a1, _DWORD *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  void (**v15)(_QWORD);
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(_QWORD);
  const void *v20;
  NSObject *v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  NSObject *v30;
  uint64_t v31;
  const char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  NSObject *v36;
  os_log_type_t v37;
  const char *v38;
  char *backtrace_string;
  _BOOL4 v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  char *v44;
  _BOOL4 v45;
  const char *v46;
  const char *v47;
  char v48;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  void *v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  char *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v3 = nw_frame_unclaimed_length(a2);
  if (gLogDatapath)
  {
    v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      v22 = a1[4];
      *(_DWORD *)buf = 136446722;
      v51 = "nw_protocol_test_get_input_frames_block_invoke";
      if (v22)
        v23 = (const char *)(v22 + 32);
      else
        v23 = "";
      v52 = 2082;
      v53 = (void *)v23;
      v54 = 1024;
      LODWORD(v55) = v3;
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Disconnect on input: frame_length %u", buf, 0x1Cu);
    }
  }
  if (v3 && (*(_BYTE *)(a1[4] + 117) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v30 = __nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        v31 = a1[4];
        if (v31)
          v32 = (const char *)(v31 + 32);
        else
          v32 = "";
        *(_DWORD *)buf = 136446466;
        v51 = "nw_protocol_test_get_input_frames_block_invoke";
        v52 = 2082;
        v53 = (void *)v32;
        _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Disconnecting on input", buf, 0x16u);
      }
    }
    v4 = a1[5];
    if (v4)
    {
      v5 = a1[6];
      v6 = *(void **)(v4 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        v7 = *(_QWORD *)(v4 + 88);
        if (v7)
          *(_QWORD *)(v4 + 88) = v7 + 1;
      }
      if (v5)
      {
        v8 = *(void **)(v5 + 40);
        if (v8 == &nw_protocol_ref_counted_handle)
        {
          v9 = *(_QWORD *)(v5 + 88);
          if (v9)
            *(_QWORD *)(v5 + 88) = v9 + 1;
        }
        v10 = *(_QWORD *)(v4 + 24);
        if (v10)
        {
          v11 = *(void (**)(uint64_t, uint64_t))(v10 + 48);
          if (v11)
          {
            v11(v4, v5);
LABEL_16:
            if (v8 != &nw_protocol_ref_counted_handle)
              goto LABEL_18;
            if (*(_UNKNOWN **)(v5 + 40) != &nw_protocol_ref_counted_handle)
              goto LABEL_18;
            v17 = *(_QWORD *)(v5 + 88);
            if (!v17)
              goto LABEL_18;
            v18 = v17 - 1;
            *(_QWORD *)(v5 + 88) = v18;
            if (v18)
              goto LABEL_18;
            v19 = *(void (***)(_QWORD))(v5 + 64);
            if (v19)
            {
              *(_QWORD *)(v5 + 64) = 0;
              v19[2](v19);
              _Block_release(v19);
            }
            if ((*(_BYTE *)(v5 + 72) & 1) != 0)
            {
              v20 = *(const void **)(v5 + 64);
              if (v20)
                _Block_release(v20);
            }
            goto LABEL_37;
          }
        }
        __nwlog_obj();
        v24 = *(const char **)(v4 + 16);
        *(_DWORD *)buf = 136446722;
        v51 = "__nw_protocol_disconnected";
        if (!v24)
          v24 = "invalid";
        v52 = 2082;
        v53 = (void *)v24;
        v54 = 2048;
        v55 = v4;
        v25 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v48 = 0;
        if (__nwlog_fault(v25, &type, &v48))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v26 = __nwlog_obj();
            v27 = type;
            if (!os_log_type_enabled(v26, type))
              goto LABEL_92;
            v28 = *(const char **)(v4 + 16);
            if (!v28)
              v28 = "invalid";
            *(_DWORD *)buf = 136446722;
            v51 = "__nw_protocol_disconnected";
            v52 = 2082;
            v53 = (void *)v28;
            v54 = 2048;
            v55 = v4;
            v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
            goto LABEL_91;
          }
          if (!v48)
          {
            v26 = __nwlog_obj();
            v27 = type;
            if (!os_log_type_enabled(v26, type))
              goto LABEL_92;
            v46 = *(const char **)(v4 + 16);
            if (!v46)
              v46 = "invalid";
            *(_DWORD *)buf = 136446722;
            v51 = "__nw_protocol_disconnected";
            v52 = 2082;
            v53 = (void *)v46;
            v54 = 2048;
            v55 = v4;
            v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
            goto LABEL_91;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          v26 = __nwlog_obj();
          v27 = type;
          v40 = os_log_type_enabled(v26, type);
          if (backtrace_string)
          {
            if (v40)
            {
              v41 = *(const char **)(v4 + 16);
              if (!v41)
                v41 = "invalid";
              *(_DWORD *)buf = 136446978;
              v51 = "__nw_protocol_disconnected";
              v52 = 2082;
              v53 = (void *)v41;
              v54 = 2048;
              v55 = v4;
              v56 = 2082;
              v57 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(backtrace_string);
            goto LABEL_92;
          }
          if (v40)
          {
            v47 = *(const char **)(v4 + 16);
            if (!v47)
              v47 = "invalid";
            *(_DWORD *)buf = 136446722;
            v51 = "__nw_protocol_disconnected";
            v52 = 2082;
            v53 = (void *)v47;
            v54 = 2048;
            v55 = v4;
            v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_91:
            _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
          }
        }
LABEL_92:
        if (v25)
          free(v25);
        goto LABEL_16;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v51 = "__nw_protocol_disconnected";
      v5 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault((const char *)v5, &type, &v48))
        goto LABEL_106;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v36 = __nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type))
          goto LABEL_106;
        *(_DWORD *)buf = 136446210;
        v51 = "__nw_protocol_disconnected";
        v38 = "%{public}s called with null other_protocol";
      }
      else if (v48)
      {
        v44 = (char *)__nw_create_backtrace_string();
        v36 = __nwlog_obj();
        v37 = type;
        v45 = os_log_type_enabled(v36, type);
        if (v44)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            v51 = "__nw_protocol_disconnected";
            v52 = 2082;
            v53 = v44;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v44);
          if (!v5)
            goto LABEL_18;
          goto LABEL_37;
        }
        if (!v45)
        {
LABEL_106:
          if (!v5)
          {
LABEL_18:
            if (v6 != &nw_protocol_ref_counted_handle)
              goto LABEL_20;
            if (*(_UNKNOWN **)(v4 + 40) != &nw_protocol_ref_counted_handle)
              goto LABEL_20;
            v13 = *(_QWORD *)(v4 + 88);
            if (!v13)
              goto LABEL_20;
            v14 = v13 - 1;
            *(_QWORD *)(v4 + 88) = v14;
            if (v14)
              goto LABEL_20;
            v15 = *(void (***)(_QWORD))(v4 + 64);
            if (v15)
            {
              *(_QWORD *)(v4 + 64) = 0;
              v15[2](v15);
              _Block_release(v15);
            }
            if ((*(_BYTE *)(v4 + 72) & 1) != 0)
            {
              v16 = *(const void **)(v4 + 64);
              if (v16)
                _Block_release(v16);
            }
            goto LABEL_29;
          }
LABEL_37:
          free((void *)v5);
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        v51 = "__nw_protocol_disconnected";
        v38 = "%{public}s called with null other_protocol, no backtrace";
      }
      else
      {
        v36 = __nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type))
          goto LABEL_106;
        *(_DWORD *)buf = 136446210;
        v51 = "__nw_protocol_disconnected";
        v38 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v36, v37, v38, buf, 0xCu);
      goto LABEL_106;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "__nw_protocol_disconnected";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_101;
        *(_DWORD *)buf = 136446210;
        v51 = "__nw_protocol_disconnected";
        v35 = "%{public}s called with null protocol";
        goto LABEL_100;
      }
      if (!v48)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_101;
        *(_DWORD *)buf = 136446210;
        v51 = "__nw_protocol_disconnected";
        v35 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_100;
      }
      v42 = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v43 = os_log_type_enabled(v33, type);
      if (v42)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "__nw_protocol_disconnected";
          v52 = 2082;
          v53 = v42;
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v42);
        if (!v4)
          goto LABEL_20;
LABEL_29:
        free((void *)v4);
LABEL_20:
        result = 0;
        *(_BYTE *)(a1[4] + 117) |= 1u;
        return result;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        v51 = "__nw_protocol_disconnected";
        v35 = "%{public}s called with null protocol, no backtrace";
LABEL_100:
        _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
      }
    }
LABEL_101:
    if (!v4)
      goto LABEL_20;
    goto LABEL_29;
  }
  return 1;
}

uint64_t *nw::retained_ptr<nw_protocol *>::~retained_ptr(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  void (**v6)(_QWORD);
  const void *v7;

  if ((a1[1] & 1) != 0)
  {
    v2 = *a1;
    if (*a1)
    {
      if (*(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        v4 = *(_QWORD *)(v2 + 88);
        if (v4)
        {
          v5 = v4 - 1;
          *(_QWORD *)(v2 + 88) = v5;
          if (!v5)
          {
            v6 = *(void (***)(_QWORD))(v2 + 64);
            if (v6)
            {
              *(_QWORD *)(v2 + 64) = 0;
              v6[2](v6);
              _Block_release(v6);
            }
            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              v7 = *(const void **)(v2 + 64);
              if (v7)
                _Block_release(v7);
            }
            free((void *)v2);
          }
        }
      }
    }
  }
  *a1 = 0;
  return a1;
}

uint64_t ___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_32(_QWORD *a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  v3 = *(_QWORD *)(a2 + 32);
  v4 = *(_QWORD **)(a2 + 40);
  v2 = (_QWORD *)(a2 + 32);
  if (v3)
  {
    *(_QWORD *)(v3 + 40) = v4;
    v4 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 48) = v4;
  }
  *v4 = v3;
  *v2 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v5 = a1[6];
  v6 = *(_QWORD **)(v5 + 8);
  *(_QWORD *)(a2 + 40) = v6;
  *v6 = a2;
  *(_QWORD *)(v5 + 8) = v2;
  ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  return 1;
}

uint64_t ___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_34(_QWORD *a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  _DWORD *v18;
  const char *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _DWORD *v25;
  char *backtrace_string;
  _BOOL4 v27;
  _DWORD *v28;
  char *v29;
  _BOOL4 v30;
  _DWORD *v31;
  _DWORD *v32;
  _DWORD *v33;
  NSObject *v35;
  uint64_t v36;
  const char *v37;
  _DWORD *v38;
  int v39;
  char v40;
  os_log_type_t type;
  _DWORD *v42;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  const char *v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  _DWORD *v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v42 = a2;
  v3 = nw_frame_split((uint64_t *)&v42, 0);
  if (gLogDatapath)
  {
    v35 = __nwlog_obj();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      v36 = a1[6];
      if (v36)
        v37 = (const char *)(v36 + 32);
      else
        v37 = "";
      v38 = v42;
      v39 = nw_frame_unclaimed_length(v42);
      *(_DWORD *)buf = 136447234;
      v44 = "nw_protocol_test_get_input_frames_block_invoke";
      v45 = 2082;
      v46 = v37;
      v47 = 2048;
      v48 = v3;
      v49 = 2048;
      v50 = v38;
      v51 = 1024;
      LODWORD(v52) = v39;
      _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s inserting empty frame %p before existing frame %p (%u bytes)", buf, 0x30u);
    }
  }
  v4 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  v5 = (uint64_t *)a1[7];
  v6 = v3 + 32;
  if (v4)
  {
    v7 = v5 + 1;
    v9 = *(_QWORD *)(v4 + 32);
    v8 = (uint64_t *)(v4 + 32);
    *(_QWORD *)(v3 + 32) = v9;
    v10 = (uint64_t *)(v9 + 40);
    if (v9)
      v7 = v10;
    *v7 = v6;
    *v8 = v3;
    *(_QWORD *)(v3 + 40) = v8;
    v11 = *(_QWORD *)(a1[5] + 8);
    v12 = *(unsigned int *)(v11 + 24) + 1;
    v13 = v12 << 31 >> 31;
    *(_DWORD *)(v11 + 24) = v12;
    if (v13 != v12 || v13 < 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
      *(_DWORD *)buf = 136446978;
      v44 = "nw_protocol_test_get_input_frames_block_invoke";
      v45 = 2082;
      v46 = "count";
      v47 = 2048;
      v48 = 1;
      v49 = 2048;
      v50 = v14;
      v15 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v40 = 0;
      if (!__nwlog_fault(v15, &type, &v40))
        goto LABEL_40;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_40;
LABEL_10:
        v18 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
        *(_DWORD *)buf = 136446978;
        v44 = "nw_protocol_test_get_input_frames_block_invoke";
        v45 = 2082;
        v46 = "count";
        v47 = 2048;
        v48 = 1;
        v49 = 2048;
        v50 = v18;
        v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_39:
        _os_log_impl(&dword_182FBE000, v16, v17, v19, buf, 0x2Au);
        goto LABEL_40;
      }
      if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = type;
        v27 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v27)
          {
            v28 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            v44 = "nw_protocol_test_get_input_frames_block_invoke";
            v45 = 2082;
            v46 = "count";
            v47 = 2048;
            v48 = 1;
            v49 = 2048;
            v50 = v28;
            v51 = 2082;
            v52 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          goto LABEL_40;
        }
        if (!v27)
          goto LABEL_40;
        goto LABEL_38;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_40;
      goto LABEL_32;
    }
  }
  else
  {
    v20 = *v5;
    *(_QWORD *)(v3 + 32) = *v5;
    if (v20)
      v21 = (uint64_t *)(v20 + 40);
    else
      v21 = v5 + 1;
    *v21 = v6;
    *v5 = v3;
    *(_QWORD *)(v3 + 40) = v5;
    v22 = *(_QWORD *)(a1[5] + 8);
    v23 = *(unsigned int *)(v22 + 24) + 1;
    v24 = v23 << 31 >> 31;
    *(_DWORD *)(v22 + 24) = v23;
    if (v24 != v23 || v24 < 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
      *(_DWORD *)buf = 136446978;
      v44 = "nw_protocol_test_get_input_frames_block_invoke";
      v45 = 2082;
      v46 = "count";
      v47 = 2048;
      v48 = 1;
      v49 = 2048;
      v50 = v25;
      v15 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v40 = 0;
      if (!__nwlog_fault(v15, &type, &v40))
        goto LABEL_40;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_40;
        goto LABEL_10;
      }
      if (v40)
      {
        v29 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = type;
        v30 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v29)
        {
          if (v30)
          {
            v31 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            v44 = "nw_protocol_test_get_input_frames_block_invoke";
            v45 = 2082;
            v46 = "count";
            v47 = 2048;
            v48 = 1;
            v49 = 2048;
            v50 = v31;
            v51 = 2082;
            v52 = v29;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v29);
          if (!v15)
            goto LABEL_42;
          goto LABEL_41;
        }
        if (!v30)
        {
LABEL_40:
          if (!v15)
          {
LABEL_42:
            *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = -1;
            goto LABEL_43;
          }
LABEL_41:
          free(v15);
          goto LABEL_42;
        }
LABEL_38:
        v33 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
        *(_DWORD *)buf = 136446978;
        v44 = "nw_protocol_test_get_input_frames_block_invoke";
        v45 = 2082;
        v46 = "count";
        v47 = 2048;
        v48 = 1;
        v49 = 2048;
        v50 = v33;
        v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_39;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_40;
LABEL_32:
      v32 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
      *(_DWORD *)buf = 136446978;
      v44 = "nw_protocol_test_get_input_frames_block_invoke";
      v45 = 2082;
      v46 = "count";
      v47 = 2048;
      v48 = 1;
      v49 = 2048;
      v50 = v32;
      v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
      goto LABEL_39;
    }
  }
LABEL_43:
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v42;
  return 1;
}

uint64_t ___ZL38nw_protocol_test_options_get_test_modeP19nw_protocol_options_block_invoke(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

NWConcrete_nw_protocol_options *nw_protocol_test_create_options()
{
  void *v0;
  NWConcrete_nw_protocol_options *options;

  if (nw_protocol_copy_test_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
  if (!nw_protocol_copy_test_definition::test_definition)
    return nw_protocol_create_options(0);
  v0 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
  options = nw_protocol_create_options(v0);
  if (v0)
    os_release(v0);
  return options;
}

void nw_protocol_test_options_set_test_mode(void *a1, int a2, char a3)
{
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  _QWORD v12[4];
  int v13;
  char v14;
  char v15;
  os_log_type_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (nw_protocol_options_is_test_protocol(a1))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __nw_protocol_test_options_set_test_mode_block_invoke;
    v12[3] = &__block_descriptor_tmp_4_83969;
    v14 = a3;
    v13 = a2;
    nw_protocol_options_access_handle(a1, v12);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_test_options_set_test_mode";
  v6 = (char *)_os_log_send_and_compose_impl();
  v16 = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = v16;
      if (!os_log_type_enabled(v7, v16))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_test_options_set_test_mode";
      v9 = "%{public}s protocol options are not test protocol";
      goto LABEL_17;
    }
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = v16;
      if (!os_log_type_enabled(v7, v16))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_test_options_set_test_mode";
      v9 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = v16;
    v11 = os_log_type_enabled(v7, v16);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "nw_protocol_test_options_set_test_mode";
        v19 = 2082;
        v20 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_test_options_set_test_mode";
      v9 = "%{public}s protocol options are not test protocol, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_18:
  if (v6)
    free(v6);
}

uint64_t __nw_protocol_test_options_set_test_mode_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 36))
    v2 = *a2 | (1 << *(_DWORD *)(a1 + 32));
  else
    v2 = 0;
  *a2 = v2;
  return 1;
}

BOOL nw_protocol_test_options_get_test_mode_enabled(void *a1, int a2)
{
  _BOOL8 v4;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  _QWORD v14[5];
  int v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (nw_protocol_options_is_test_protocol(a1))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2000000000;
      v19 = 0;
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 0x40000000;
      v14[2] = __nw_protocol_test_options_get_test_mode_enabled_block_invoke;
      v14[3] = &unk_1E14ABF20;
      v14[4] = buf;
      v15 = a2;
      nw_protocol_options_access_handle(a1, v14);
      v4 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
      _Block_object_dispose(buf, 8);
      return v4;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v6, &type, &v16))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
        v9 = "%{public}s protocol options are not test protocol";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v16)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
        v9 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
        v9 = "%{public}s protocol options are not test protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v12 = "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v6, &type, &v16))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
        v9 = "%{public}s called with null mode, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
        v9 = "%{public}s called with null mode, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v12 = "%{public}s called with null mode, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_test_options_get_test_mode_enabled";
    v9 = "%{public}s called with null mode";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
  }
LABEL_32:
  if (v6)
    free(v6);
  return 0;
}

uint64_t __nw_protocol_test_options_get_test_mode_enabled_block_invoke(uint64_t a1, _QWORD *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*a2 & (1 << *(_DWORD *)(a1 + 40))) != 0;
  return 1;
}

void nw_protocol_test_options_set_finalize_output_frames_handler(void *a1, uint64_t a2)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  _QWORD v10[5];
  char v11;
  os_log_type_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (nw_protocol_options_is_test_protocol(a1))
  {
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = __nw_protocol_test_options_set_finalize_output_frames_handler_block_invoke;
    v10[3] = &unk_1E14ABF48;
    v10[4] = a2;
    nw_protocol_options_access_handle(a1, v10);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_test_options_set_finalize_output_frames_handler";
  v4 = (char *)_os_log_send_and_compose_impl();
  v12 = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &v12, &v11))
  {
    if (v12 == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = v12;
      if (!os_log_type_enabled(v5, v12))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_test_options_set_finalize_output_frames_handler";
      v7 = "%{public}s protocol options are not test protocol";
      goto LABEL_17;
    }
    if (!v11)
    {
      v5 = __nwlog_obj();
      v6 = v12;
      if (!os_log_type_enabled(v5, v12))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_test_options_set_finalize_output_frames_handler";
      v7 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = v12;
    v9 = os_log_type_enabled(v5, v12);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v14 = "nw_protocol_test_options_set_finalize_output_frames_handler";
        v15 = 2082;
        v16 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_test_options_set_finalize_output_frames_handler";
      v7 = "%{public}s protocol options are not test protocol, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_18:
  if (v4)
    free(v4);
}

uint64_t __nw_protocol_test_options_set_finalize_output_frames_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;
  void *v4;
  char v5;
  const void *v6;

  v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    v4 = _Block_copy(v3);
    v5 = *(_BYTE *)(a2 + 16);
    if ((v5 & 1) == 0)
      goto LABEL_7;
  }
  else
  {
    v4 = 0;
    v5 = *(_BYTE *)(a2 + 16);
    if ((v5 & 1) == 0)
      goto LABEL_7;
  }
  v6 = *(const void **)(a2 + 8);
  if (v6)
  {
    _Block_release(v6);
    v5 = *(_BYTE *)(a2 + 16);
  }
LABEL_7:
  *(_QWORD *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 16) = v5 | 1;
  return 1;
}

void nw_protocol_test_options_set_event_handler(void *a1, int a2, uint64_t a3)
{
  char v3;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  _QWORD v16[5];
  char v17;
  char v18;
  os_log_type_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_test_options_set_event_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    v19 = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v6, &v19, &v18))
      goto LABEL_47;
    if (v19 != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        v7 = __nwlog_obj();
        v8 = v19;
        if (!os_log_type_enabled(v7, v19))
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_test_options_set_event_handler";
        v9 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_46;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = v19;
      v11 = os_log_type_enabled(v7, v19);
      if (!backtrace_string)
      {
        if (!v11)
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_test_options_set_event_handler";
        v9 = "%{public}s called with null options, no backtrace";
        goto LABEL_46;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v21 = "nw_protocol_test_options_set_event_handler";
        v22 = 2082;
        v23 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_47;
    }
    v7 = __nwlog_obj();
    v8 = v19;
    if (!os_log_type_enabled(v7, v19))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_test_options_set_event_handler";
    v9 = "%{public}s called with null options";
LABEL_46:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_47;
  }
  v3 = a2;
  if (a2)
  {
    if (nw_protocol_options_is_test_protocol(a1))
    {
      v16[0] = MEMORY[0x1E0C809B0];
      v16[1] = 0x40000000;
      v16[2] = __nw_protocol_test_options_set_event_handler_block_invoke;
      v16[3] = &unk_1E14ABF98;
      v17 = v3;
      v16[4] = a3;
      nw_protocol_options_access_handle(a1, v16);
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_test_options_set_event_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    v19 = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v6, &v19, &v18))
    {
      if (v19 == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = v19;
        if (!os_log_type_enabled(v7, v19))
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_test_options_set_event_handler";
        v9 = "%{public}s protocol options are not test protocol";
        goto LABEL_46;
      }
      if (!v18)
      {
        v7 = __nwlog_obj();
        v8 = v19;
        if (!os_log_type_enabled(v7, v19))
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_test_options_set_event_handler";
        v9 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
        goto LABEL_46;
      }
      v12 = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = v19;
      v15 = os_log_type_enabled(v7, v19);
      if (!v12)
      {
        if (!v15)
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_test_options_set_event_handler";
        v9 = "%{public}s protocol options are not test protocol, no backtrace";
        goto LABEL_46;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v21 = "nw_protocol_test_options_set_event_handler";
        v22 = 2082;
        v23 = v12;
        v14 = "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
LABEL_47:
    if (v6)
      goto LABEL_48;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_protocol_test_options_set_event_handler";
  v6 = (char *)_os_log_send_and_compose_impl();
  v19 = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v6, &v19, &v18))
    goto LABEL_47;
  if (v19 == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = v19;
    if (!os_log_type_enabled(v7, v19))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_test_options_set_event_handler";
    v9 = "%{public}s called with null event";
    goto LABEL_46;
  }
  if (!v18)
  {
    v7 = __nwlog_obj();
    v8 = v19;
    if (!os_log_type_enabled(v7, v19))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_test_options_set_event_handler";
    v9 = "%{public}s called with null event, backtrace limit exceeded";
    goto LABEL_46;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = v19;
  v13 = os_log_type_enabled(v7, v19);
  if (!v12)
  {
    if (!v13)
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_test_options_set_event_handler";
    v9 = "%{public}s called with null event, no backtrace";
    goto LABEL_46;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "nw_protocol_test_options_set_event_handler";
    v22 = 2082;
    v23 = v12;
    v14 = "%{public}s called with null event, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v7, v8, v14, buf, 0x16u);
  }
LABEL_32:
  free(v12);
  if (v6)
LABEL_48:
    free(v6);
}

uint64_t __nw_protocol_test_options_set_event_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  const void *v7;
  void *v8;
  char v9;
  char *backtrace_string;
  _BOOL4 v11;
  const void *v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 40) == 1)
  {
    v7 = *(const void **)(a1 + 32);
    if (v7)
    {
      v8 = _Block_copy(v7);
      v9 = *(_BYTE *)(a2 + 32);
      if ((v9 & 1) == 0)
        goto LABEL_18;
    }
    else
    {
      v8 = 0;
      v9 = *(_BYTE *)(a2 + 32);
      if ((v9 & 1) == 0)
      {
LABEL_18:
        *(_QWORD *)(a2 + 24) = v8;
        *(_BYTE *)(a2 + 32) = v9 | 1;
        return 1;
      }
    }
    v12 = *(const void **)(a2 + 24);
    if (v12)
    {
      _Block_release(v12);
      v9 = *(_BYTE *)(a2 + 32);
    }
    goto LABEL_18;
  }
  if (*(_BYTE *)(a1 + 40))
    return 1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_test_options_set_event_handler_block_invoke";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v2, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_test_options_set_event_handler_block_invoke";
      v5 = "%{public}s Invalid event supplied";
      goto LABEL_23;
    }
    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_test_options_set_event_handler_block_invoke";
      v5 = "%{public}s Invalid event supplied, backtrace limit exceeded";
      goto LABEL_23;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = type;
    v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v17 = "nw_protocol_test_options_set_event_handler_block_invoke";
        v18 = 2082;
        v19 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s Invalid event supplied, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_24;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_test_options_set_event_handler_block_invoke";
      v5 = "%{public}s Invalid event supplied, no backtrace";
LABEL_23:
      _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_24:
  if (v2)
    free(v2);
  return 1;
}

void nw_protocol_test_options_set_message_properties(void *a1, int a2, char a3, char a4, char a5)
{
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  _QWORD v16[4];
  int v17;
  char v18;
  char v19;
  char v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (nw_protocol_options_is_test_protocol(a1))
  {
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 0x40000000;
    v16[2] = __nw_protocol_test_options_set_message_properties_block_invoke;
    v16[3] = &__block_descriptor_tmp_10_84013;
    v17 = a2;
    v18 = a3;
    v19 = a4;
    v20 = a5;
    nw_protocol_options_access_handle(a1, v16);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_protocol_test_options_set_message_properties";
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v10, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_test_options_set_message_properties";
      v13 = "%{public}s protocol options are not test protocol";
      goto LABEL_17;
    }
    if (!v21)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_test_options_set_message_properties";
      v13 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v15 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_test_options_set_message_properties";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_test_options_set_message_properties";
      v13 = "%{public}s protocol options are not test protocol, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    }
  }
LABEL_18:
  if (v10)
    free(v10);
}

uint64_t __nw_protocol_test_options_set_message_properties_block_invoke(uint64_t a1, uint64_t a2)
{
  char v2;
  char v3;
  char v4;

  v2 = *(_BYTE *)(a2 + 44) | 1;
  *(_BYTE *)(a2 + 44) = v2;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 32);
  v3 = v2 & 0xFD | (2 * *(_BYTE *)(a1 + 36));
  *(_BYTE *)(a2 + 44) = v3;
  v4 = v3 & 0xFB | (4 * *(_BYTE *)(a1 + 37));
  *(_BYTE *)(a2 + 44) = v4;
  *(_BYTE *)(a2 + 44) = v4 & 0xF7 | (8 * *(_BYTE *)(a1 + 38));
  return 1;
}

id *nw_protocol_test_create_metadata()
{
  void *v0;
  id *singleton;

  if (nw_protocol_copy_test_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
  if (!nw_protocol_copy_test_definition::test_definition)
    return nw_protocol_metadata_create_singleton(0);
  v0 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
  singleton = nw_protocol_metadata_create_singleton(v0);
  if (v0)
    os_release(v0);
  return singleton;
}

BOOL nw_protocol_metadata_is_test_protocol(void *a1)
{
  id *v1;
  id v2;
  void *v3;
  _BOOL8 is_equal_unsafe;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = a1;
    v2 = v1[1];

    if (nw_protocol_copy_test_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83549);
    if (nw_protocol_copy_test_definition::test_definition)
      v3 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
    else
      v3 = 0;
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v2, (uint64_t)v3);
    if (v2)
      os_release(v2);
    if (v3)
      os_release(v3);
    return is_equal_unsafe;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_metadata_is_test_protocol";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_metadata_is_test_protocol";
        v9 = "%{public}s called with null metadata";
LABEL_25:
        _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_metadata_is_test_protocol";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_26;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_metadata_is_test_protocol";
        v9 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_25;
      }
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_metadata_is_test_protocol";
        v9 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_25;
      }
    }
  }
LABEL_26:
  if (v6)
    free(v6);
  return 0;
}

void sub_183B41BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_183B42538(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183B42590(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183B425FC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183B42888(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

const char *nw_browse_descriptor_get_description(void *a1, int a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  const char **v6;
  void (**v7)(_QWORD);
  const char *v8;
  id v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  _QWORD aBlock[4];
  os_unfair_lock_s *v21;
  os_unfair_lock_s *v22;
  char v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    v8 = "<NULL>";
    goto LABEL_15;
  }
  v5 = 8;
  if (a2)
    v5 = 10;
  v6 = (const char **)&v3[v5];
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_browse_descriptor_get_description_block_invoke;
  aBlock[3] = &unk_1E14AC250;
  v22 = &v3[v5];
  v21 = v3;
  v23 = a2;
  v7 = (void (**)(_QWORD))_Block_copy(aBlock);
  os_unfair_lock_lock(v4 + 12);
  v7[2](v7);
  os_unfair_lock_unlock(v4 + 12);

  v8 = *v6;
  if (!*v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_browse_descriptor_get_description";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_browse_descriptor_get_description";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s description is NULL", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v25 = "nw_browse_descriptor_get_description";
            v26 = 2082;
            v27 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s description is NULL, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v10)
            goto LABEL_12;
          goto LABEL_11;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_browse_descriptor_get_description";
          _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s description is NULL, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_browse_descriptor_get_description";
          _os_log_impl(&dword_182FBE000, v11, v17, "%{public}s description is NULL, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v10)
    {
LABEL_12:
      v8 = "?";
      goto LABEL_13;
    }
LABEL_11:
    free(v10);
    goto LABEL_12;
  }
LABEL_13:

LABEL_15:
  return v8;
}

void sub_183B43090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

uint64_t __nw_browse_descriptor_get_description_block_invoke(uint64_t result)
{
  char **v1;
  uint64_t v2;
  int v3;
  const char *v4;

  v1 = *(char ***)(result + 40);
  if (!*v1)
  {
    v2 = *(_QWORD *)(result + 32);
    v3 = *(_DWORD *)(v2 + 8);
    if (v3 == 2)
    {
      return asprintf(v1, "<nw_browse_descriptor application_service %s bundle_id=%s device_types=%x>");
    }
    else if (v3 == 1)
    {
      v4 = *(const char **)(v2 + 24);
      if (*(_BYTE *)(result + 48) && v4 && strcmp(*(const char **)(v2 + 24), "local"))
        strcmp(v4, "local.");
      return asprintf(v1, "<nw_browse_descriptor bonjour %s.%s %s>");
    }
    else if (v3)
    {
      return asprintf(v1, "<nw_browse_descriptor custom type %d>");
    }
    else
    {
      return asprintf(*(char ***)(result + 40), "<nw_browse_descriptor invalid>");
    }
  }
  return result;
}

nw_browse_descriptor_t nw_browse_descriptor_create_bonjour_service(const char *type, const char *domain)
{
  NWConcrete_nw_browse_descriptor *v4;
  NWConcrete_nw_browse_descriptor *v5;
  char *v6;
  size_t v7;
  char *v8;
  NWConcrete_nw_browse_descriptor *v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  nw_browse_descriptor_t result;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  NSObject *v23;
  void *v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  NSObject *v28;
  void *v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t typea;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!type)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_browse_descriptor_create_bonjour_service";
    v20 = (char *)_os_log_send_and_compose_impl();

    typea = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v20, &typea, &v31))
    {
      if (typea == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = typea;
        if (os_log_type_enabled(v21, typea))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null type", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v26 = typea;
        v27 = os_log_type_enabled(v21, typea);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            v34 = "nw_browse_descriptor_create_bonjour_service";
            v35 = 2082;
            v36 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null type, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_51;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null type, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v30 = typea;
        if (os_log_type_enabled(v21, typea))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl(&dword_182FBE000, v21, v30, "%{public}s called with null type, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_51:
    if (v20)
      free(v20);
    return 0;
  }
  v4 = objc_alloc_init(NWConcrete_nw_browse_descriptor);
  v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v34 = "nw_browse_descriptor_create_bonjour_service";
    v11 = (char *)_os_log_send_and_compose_impl();

    typea = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v11, &typea, &v31))
    {
      if (typea == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v13 = typea;
        if (os_log_type_enabled(v12, typea))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s [nw_browse_descriptor init] failed", buf, 0xCu);
        }
      }
      else if (v31)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v16 = typea;
        v17 = os_log_type_enabled(v12, typea);
        if (v15)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v34 = "nw_browse_descriptor_create_bonjour_service";
            v35 = 2082;
            v36 = v15;
            _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s [nw_browse_descriptor init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v15);
          if (!v11)
            goto LABEL_17;
          goto LABEL_16;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s [nw_browse_descriptor init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v18 = typea;
        if (os_log_type_enabled(v12, typea))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_browse_descriptor_create_bonjour_service";
          _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s [nw_browse_descriptor init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v11)
      goto LABEL_17;
LABEL_16:
    free(v11);
    goto LABEL_17;
  }
  *((_DWORD *)v4 + 2) = 1;
  v6 = strdup(type);
  if (!v6)
  {
    __nwlog_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v34 = "strict_strdup";
    v24 = (void *)_os_log_send_and_compose_impl();

    result = (nw_browse_descriptor_t)__nwlog_abort((uint64_t)v24);
    if ((_DWORD)result)
      goto LABEL_54;
    free(v24);
  }
  *((_QWORD *)v5 + 2) = v6;
  v7 = strlen(type) - 1;
  if (type[v7] == 46)
    v6[v7] = 0;
  if (!domain)
    goto LABEL_9;
  v8 = strdup(domain);
  if (v8)
  {
LABEL_8:
    *((_QWORD *)v5 + 3) = v8;
LABEL_9:
    *((_BYTE *)v5 + 112) &= ~1u;
    v9 = v5;
LABEL_17:

    return (nw_browse_descriptor_t)v5;
  }
  __nwlog_obj();
  v28 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v34 = "strict_strdup";
  v29 = (void *)_os_log_send_and_compose_impl();

  result = (nw_browse_descriptor_t)__nwlog_abort((uint64_t)v29);
  if (!(_DWORD)result)
  {
    free(v29);
    goto LABEL_8;
  }
LABEL_54:
  __break(1u);
  return result;
}

const char *__cdecl nw_browse_descriptor_get_bonjour_service_type(nw_browse_descriptor_t descriptor)
{
  nw_browse_descriptor_t v1;
  nw_browse_descriptor_t v2;
  const char *isa;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = descriptor;
  v2 = v1;
  if (v1)
  {
    isa = (const char *)v1[2].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_get_bonjour_service_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_bonjour_service_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_get_bonjour_service_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_bonjour_service_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_bonjour_service_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  isa = 0;
LABEL_3:

  return isa;
}

const char *__cdecl nw_browse_descriptor_get_bonjour_service_domain(nw_browse_descriptor_t descriptor)
{
  nw_browse_descriptor_t v1;
  nw_browse_descriptor_t v2;
  const char *isa;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = descriptor;
  v2 = v1;
  if (v1)
  {
    isa = (const char *)v1[3].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_get_bonjour_service_domain";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_bonjour_service_domain";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_get_bonjour_service_domain";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_bonjour_service_domain";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_bonjour_service_domain";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  isa = 0;
LABEL_3:

  return isa;
}

BOOL nw_browse_descriptor_create_application_service_with_bundle_id(const char *a1, const char *a2)
{
  NWConcrete_nw_browse_descriptor *v4;
  NWConcrete_nw_browse_descriptor *v5;
  char *v6;
  char *v7;
  NWConcrete_nw_browse_descriptor *v8;
  id v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  _BOOL8 result;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  NSObject *v22;
  void *v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  NSObject *v27;
  void *v28;
  os_log_type_t v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v19, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null application_service_name", buf, 0xCu);
        }
      }
      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        v26 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null application_service_name, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null application_service_name, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_182FBE000, v20, v29, "%{public}s called with null application_service_name, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_50:
    if (v19)
      free(v19);
    return 0;
  }
  v4 = objc_alloc_init(NWConcrete_nw_browse_descriptor);
  v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s [nw_browse_descriptor init] failed", buf, 0xCu);
        }
      }
      else if (v30)
      {
        v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v11, type);
        if (v14)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
            v34 = 2082;
            v35 = v14;
            _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s [nw_browse_descriptor init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v14);
          if (!v10)
            goto LABEL_15;
          goto LABEL_14;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s [nw_browse_descriptor init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_182FBE000, v11, v17, "%{public}s [nw_browse_descriptor init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v10)
      goto LABEL_15;
LABEL_14:
    free(v10);
    goto LABEL_15;
  }
  *((_DWORD *)v4 + 2) = 2;
  v6 = strdup(a1);
  if (v6)
  {
    *((_QWORD *)v5 + 9) = v6;
    if (!a2)
    {
LABEL_7:
      v8 = v5;
LABEL_15:

      return (BOOL)v5;
    }
  }
  else
  {
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v33 = "strict_strdup";
    v23 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v23);
    if (result)
      goto LABEL_53;
    free(v23);
    *((_QWORD *)v5 + 9) = 0;
    if (!a2)
      goto LABEL_7;
  }
  v7 = strdup(a2);
  if (v7)
  {
LABEL_6:
    *((_QWORD *)v5 + 10) = v7;
    goto LABEL_7;
  }
  __nwlog_obj();
  v27 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v33 = "strict_strdup";
  v28 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    goto LABEL_6;
  }
LABEL_53:
  __break(1u);
  return result;
}

nw_browse_descriptor_t nw_browse_descriptor_create_application_service(const char *application_service_name)
{
  if (nw_utilities_get_self_name::onceToken != -1)
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44028);
  return (nw_browse_descriptor_t)nw_browse_descriptor_create_application_service_with_bundle_id(application_service_name, (const char *)nw_utilities_get_self_name::name);
}

const char *__cdecl nw_browse_descriptor_get_application_service_name(nw_browse_descriptor_t descriptor)
{
  nw_browse_descriptor_t v1;
  nw_browse_descriptor_t v2;
  const char *isa;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *v8;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = descriptor;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_application_service_name";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_application_service_name";
          _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v19)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_application_service_name";
          _os_log_impl(&dword_182FBE000, v6, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_application_service_name";
          _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_get_application_service_name";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v5)
    {
LABEL_23:
      isa = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v5);
    goto LABEL_23;
  }
  if (LODWORD(v1[1].isa) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_application_service_name";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_application_service_name";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
      }
    }
    else if (v19)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_browse_descriptor_get_application_service_name";
          v23 = 2082;
          v24 = v8;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
        if (!v5)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_application_service_name";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_application_service_name";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_20;
  }
  isa = (const char *)v1[9].isa;
LABEL_24:

  return isa;
}

uint64_t nw_browse_descriptor_get_type(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_get_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_get_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_browse_descriptor_get_bundle_id(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *v8;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_bundle_id";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_bundle_id";
          _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v19)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_bundle_id";
          _os_log_impl(&dword_182FBE000, v6, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_bundle_id";
          _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_get_bundle_id";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v5)
    {
LABEL_23:
      v3 = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v5);
    goto LABEL_23;
  }
  if (*((_DWORD *)v1 + 2) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_bundle_id";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_bundle_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
      }
    }
    else if (v19)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_browse_descriptor_get_bundle_id";
          v23 = 2082;
          v24 = v8;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
        if (!v5)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_bundle_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_bundle_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_20;
  }
  v3 = *((_QWORD *)v1 + 10);
LABEL_24:

  return v3;
}

void nw_browse_descriptor_set_device_types(void *a1, int a2)
{
  id v3;
  void *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_set_device_types";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_device_types";
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (!v19)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_device_types";
          _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_device_types";
          _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_set_device_types";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v6)
      goto LABEL_23;
LABEL_22:
    free(v6);
    goto LABEL_23;
  }
  if (*((_DWORD *)v3 + 2) == 2)
  {
    *((_DWORD *)v3 + 22) = a2;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v22 = "nw_browse_descriptor_set_device_types";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_21;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_device_types";
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
    }
LABEL_20:

    goto LABEL_21;
  }
  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v12 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_device_types";
      _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_20;
  }
  v9 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  v10 = type;
  v11 = os_log_type_enabled(v7, type);
  if (!v9)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_device_types";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
    }
    goto LABEL_20;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_browse_descriptor_set_device_types";
    v23 = 2082;
    v24 = v9;
    _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v9);
  if (v6)
    goto LABEL_22;
LABEL_23:

}

uint64_t nw_browse_descriptor_get_device_types(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *v8;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_device_types";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_device_types";
          _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v19)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_device_types";
          _os_log_impl(&dword_182FBE000, v6, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_device_types";
          _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_get_device_types";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v5)
    {
LABEL_23:
      v3 = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v5);
    goto LABEL_23;
  }
  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_device_types";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_device_types";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
      }
    }
    else if (v19)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_browse_descriptor_get_device_types";
          v23 = 2082;
          v24 = v8;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
        if (!v5)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_device_types";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_device_types";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_20;
  }
  v3 = v1[22];
LABEL_24:

  return v3;
}

BOOL nw_browse_descriptor_is_device_type_set(void *a1, int a2)
{
  id v3;
  void *v4;
  _BOOL8 v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = (*((_DWORD *)v3 + 22) & a2) != 0;
    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_browse_descriptor_is_device_type_set";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browse_descriptor_is_device_type_set";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_browse_descriptor_is_device_type_set";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browse_descriptor_is_device_type_set";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browse_descriptor_is_device_type_set";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
  v5 = 0;
LABEL_3:

  return v5;
}

void nw_browse_descriptor_set_browse_scope(void *a1, int a2)
{
  id v3;
  void *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_set_browse_scope";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_browse_scope";
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (!v19)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_browse_scope";
          _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_browse_scope";
          _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_set_browse_scope";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v6)
      goto LABEL_23;
LABEL_22:
    free(v6);
    goto LABEL_23;
  }
  if (*((_DWORD *)v3 + 2) == 2)
  {
    *((_DWORD *)v3 + 23) = a2;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v22 = "nw_browse_descriptor_set_browse_scope";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_21;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_browse_scope";
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
    }
LABEL_20:

    goto LABEL_21;
  }
  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v12 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_browse_scope";
      _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_20;
  }
  v9 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  v10 = type;
  v11 = os_log_type_enabled(v7, type);
  if (!v9)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_browse_scope";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
    }
    goto LABEL_20;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_browse_descriptor_set_browse_scope";
    v23 = 2082;
    v24 = v9;
    _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v9);
  if (v6)
    goto LABEL_22;
LABEL_23:

}

uint64_t nw_browse_descriptor_get_browse_scope(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *v8;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_browse_scope";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_browse_scope";
          _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v19)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_browse_scope";
          _os_log_impl(&dword_182FBE000, v6, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_browse_scope";
          _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_get_browse_scope";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v5)
    {
LABEL_23:
      v3 = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v5);
    goto LABEL_23;
  }
  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_browse_scope";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_browse_scope";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
      }
    }
    else if (v19)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_browse_descriptor_get_browse_scope";
          v23 = 2082;
          v24 = v8;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
        if (!v5)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_browse_scope";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_browse_scope";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_20;
  }
  v3 = v1[23];
LABEL_24:

  return v3;
}

BOOL nw_browse_descriptor_is_browse_scope_set(void *a1, int a2)
{
  id v3;
  void *v4;
  _BOOL8 v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = (*((_DWORD *)v3 + 23) & a2) != 0;
    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_browse_descriptor_is_browse_scope_set";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browse_descriptor_is_browse_scope_set";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_browse_descriptor_is_browse_scope_set";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browse_descriptor_is_browse_scope_set";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browse_descriptor_is_browse_scope_set";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
  v5 = 0;
LABEL_3:

  return v5;
}

void nw_browse_descriptor_add_device_filter(void *a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  _BOOL8 v5;
  void *v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_browse_descriptor_add_device_filter";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browse_descriptor_add_device_filter";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_browse_descriptor_add_device_filter";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9)
          goto LABEL_6;
LABEL_41:
        free(v9);
        goto LABEL_6;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browse_descriptor_add_device_filter";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browse_descriptor_add_device_filter";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (a2)
  {
    if (!v3[13])
    {
      v5 = nw_array_create();
      v6 = (void *)v4[13];
      v4[13] = v5;

    }
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", a2, 1);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    nw_array_append(v4[13], v7);

    goto LABEL_6;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_browse_descriptor_add_device_filter";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_browse_descriptor_add_device_filter";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null device_filters", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_browse_descriptor_add_device_filter";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null device_filters, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_browse_descriptor_add_device_filter";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null device_filters, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_browse_descriptor_add_device_filter";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null device_filters, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_41;
LABEL_6:

}

void sub_183B46EC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_browse_descriptor_get_device_filter_count(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_browse_descriptor_get_device_filter_count";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (__nwlog_fault(v4, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_browse_descriptor_get_device_filter_count";
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null descriptor", buf, 0xCu);
        }
      }
      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            v14 = "nw_browse_descriptor_get_device_filter_count";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v9)
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_browse_descriptor_get_device_filter_count";
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_browse_descriptor_get_device_filter_count";
          _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v4)
      free(v4);
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 104);
  if (v1)
    return (uint64_t)(*(_QWORD *)(v1 + 24) - *(_QWORD *)(v1 + 16)) >> 3;
  return 0;
}

void nw_browse_descriptor_enumerate_device_filters(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  unsigned __int8 *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD v21[4];
  id v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_browse_descriptor_enumerate_device_filters";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_browse_descriptor_enumerate_device_filters";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_browse_descriptor_enumerate_device_filters";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_browse_descriptor_enumerate_device_filters";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_browse_descriptor_enumerate_device_filters";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v6 = (unsigned __int8 *)v3[13];
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = __nw_browse_descriptor_enumerate_device_filters_block_invoke;
    v21[3] = &unk_1E14AC278;
    v22 = v4;
    nw_array_apply(v6, (uint64_t)v21);

    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_browse_descriptor_enumerate_device_filters";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_browse_descriptor_enumerate_device_filters";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_browse_descriptor_enumerate_device_filters";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null enumerator, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_browse_descriptor_enumerate_device_filters";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_browse_descriptor_enumerate_device_filters";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerator, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

uint64_t __nw_browse_descriptor_enumerate_device_filters_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;

  v4 = a3;
  objc_msgSend(v4, "cStringUsingEncoding:", 1);
  v5 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

  return v5;
}

void sub_183B476A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_browse_descriptor_clear_device_filters(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)*((_QWORD *)v1 + 13);
    *((_QWORD *)v1 + 13) = 0;

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_browse_descriptor_clear_device_filters";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_browse_descriptor_clear_device_filters";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_browse_descriptor_clear_device_filters";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_browse_descriptor_clear_device_filters";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_browse_descriptor_clear_device_filters";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

NWConcrete_nw_browse_descriptor *nw_browse_descriptor_create_custom(unsigned int a1, void *a2, void *a3)
{
  NSObject *v6;
  id v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  id v12;
  os_log_type_t v13;
  NWConcrete_nw_browse_descriptor *v14;
  NWConcrete_nw_browse_descriptor *v15;
  void *v16;
  void *v17;
  NWConcrete_nw_browse_descriptor *v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _BOOL4 v23;
  id v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  os_log_type_t v28;
  os_log_type_t v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  void *v35;
  os_log_type_t v36;
  char *v37;
  os_log_type_t v38;
  _BOOL4 v39;
  os_log_type_t v40;
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  _WORD v46[17];

  *(_QWORD *)&v46[13] = *MEMORY[0x1E0C80C00];
  v6 = a2;
  v7 = a3;
  if (v6)
  {
    if (a1 <= 0x3E7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v44 = "nw_browse_descriptor_create_custom";
      v45 = 1024;
      *(_DWORD *)v46 = 1000;
      v9 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v41 = 0;
      if (!__nwlog_fault(v9, &type, &v41))
        goto LABEL_52;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1000;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s Custom browse descriptor type values must start at %d", buf, 0x12u);
        }
LABEL_51:

        goto LABEL_52;
      }
      if (!v41)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v28 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1000;
          _os_log_impl(&dword_182FBE000, v10, v28, "%{public}s Custom browse descriptor type values must start at %d, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v20 = type;
      v21 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1000;
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s Custom browse descriptor type values must start at %d, no backtrace", buf, 0x12u);
        }
        goto LABEL_51;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446722;
        v44 = "nw_browse_descriptor_create_custom";
        v45 = 1024;
        *(_DWORD *)v46 = 1000;
        v46[2] = 2082;
        *(_QWORD *)&v46[3] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s Custom browse descriptor type values must start at %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
LABEL_27:

      free(backtrace_string);
      if (!v9)
        goto LABEL_54;
      goto LABEL_53;
    }
    if (dispatch_data_get_size(v6) >= 0x401)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v44 = "nw_browse_descriptor_create_custom";
      v45 = 1024;
      *(_DWORD *)v46 = 1024;
      v9 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v41 = 0;
      if (!__nwlog_fault(v9, &type, &v41))
        goto LABEL_52;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1024;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
        }
        goto LABEL_51;
      }
      if (!v41)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1024;
          _os_log_impl(&dword_182FBE000, v10, v29, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v22 = type;
      v23 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_browse_descriptor_create_custom";
          v45 = 1024;
          *(_DWORD *)v46 = 1024;
          _os_log_impl(&dword_182FBE000, v10, v22, "%{public}s Custom data size must be no larger than %d, no backtrace", buf, 0x12u);
        }
        goto LABEL_51;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446722;
        v44 = "nw_browse_descriptor_create_custom";
        v45 = 1024;
        *(_DWORD *)v46 = 1024;
        v46[2] = 2082;
        *(_QWORD *)&v46[3] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v22, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      goto LABEL_27;
    }
    v14 = objc_alloc_init(NWConcrete_nw_browse_descriptor);
    v15 = v14;
    if (v14)
    {
      *((_DWORD *)v14 + 2) = a1;
      objc_storeStrong((id *)v14 + 7, a2);
      if (v7)
      {
        v16 = _Block_copy(v7);
        v17 = (void *)*((_QWORD *)v15 + 8);
        *((_QWORD *)v15 + 8) = v16;

      }
      v18 = v15;
      goto LABEL_63;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v44 = "nw_browse_descriptor_create_custom";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (__nwlog_fault(v25, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = (id)gLogObj;
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "nw_browse_descriptor_create_custom";
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s [nw_browse_descriptor init] failed", buf, 0xCu);
        }
      }
      else if (v41)
      {
        v30 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        v32 = os_log_type_enabled(v26, type);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v44 = "nw_browse_descriptor_create_custom";
            v45 = 2082;
            *(_QWORD *)v46 = v30;
            _os_log_impl(&dword_182FBE000, v26, v31, "%{public}s [nw_browse_descriptor init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v30);
          if (!v25)
            goto LABEL_63;
          goto LABEL_62;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v44 = "nw_browse_descriptor_create_custom";
          _os_log_impl(&dword_182FBE000, v26, v31, "%{public}s [nw_browse_descriptor init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "nw_browse_descriptor_create_custom";
          _os_log_impl(&dword_182FBE000, v26, v33, "%{public}s [nw_browse_descriptor init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v25)
    {
LABEL_63:

      goto LABEL_64;
    }
LABEL_62:
    free(v25);
    goto LABEL_63;
  }
  __nwlog_obj();
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v44 = "nw_browse_descriptor_create_custom";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v9, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_browse_descriptor_create_custom";
        _os_log_impl(&dword_182FBE000, v10, v36, "%{public}s called with null custom_data", buf, 0xCu);
      }
      goto LABEL_51;
    }
    if (!v41)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v40 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_browse_descriptor_create_custom";
        _os_log_impl(&dword_182FBE000, v10, v40, "%{public}s called with null custom_data, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_51;
    }
    v37 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v38 = type;
    v39 = os_log_type_enabled(v10, type);
    if (!v37)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_browse_descriptor_create_custom";
        _os_log_impl(&dword_182FBE000, v10, v38, "%{public}s called with null custom_data, no backtrace", buf, 0xCu);
      }
      goto LABEL_51;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v44 = "nw_browse_descriptor_create_custom";
      v45 = 2082;
      *(_QWORD *)v46 = v37;
      _os_log_impl(&dword_182FBE000, v10, v38, "%{public}s called with null custom_data, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v37);
  }
LABEL_52:
  if (v9)
LABEL_53:
    free(v9);
LABEL_54:
  v15 = 0;
LABEL_64:

  return v15;
}

void sub_183B483D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_browse_descriptor_copy_custom_data(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *v8;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  _WORD v24[17];

  *(_QWORD *)&v24[13] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_copy_custom_data";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_copy_custom_data";
          _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v19)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_copy_custom_data";
          _os_log_impl(&dword_182FBE000, v6, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_copy_custom_data";
          _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_data";
        v23 = 2082;
        *(_QWORD *)v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v5)
    {
LABEL_23:
      v3 = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v5);
    goto LABEL_23;
  }
  if (*((_DWORD *)v1 + 2) <= 0x3E7u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v22 = "nw_browse_descriptor_copy_custom_data";
    v23 = 1024;
    *(_DWORD *)v24 = 1000;
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_data";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Custom browse type values must start at %d", buf, 0x12u);
      }
    }
    else if (v19)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446722;
          v22 = "nw_browse_descriptor_copy_custom_data";
          v23 = 1024;
          *(_DWORD *)v24 = 1000;
          v24[2] = 2082;
          *(_QWORD *)&v24[3] = v8;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Custom browse type values must start at %d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v8);
        if (!v5)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_data";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Custom browse type values must start at %d, no backtrace", buf, 0x12u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_data";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s Custom browse type values must start at %d, backtrace limit exceeded", buf, 0x12u);
      }
    }
    goto LABEL_20;
  }
  v3 = v1[7];
LABEL_24:

  return v3;
}

BOOL nw_browse_descriptor_is_custom_type(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_DWORD *)v1 + 2) > 0x3E7u;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_is_custom_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_is_custom_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_is_custom_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_is_custom_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_is_custom_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void *nw_browse_descriptor_copy_custom_browse_block(void *a1)
{
  const void **v1;
  const void **v2;
  void *v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *v8;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  _WORD v24[17];

  *(_QWORD *)&v24[13] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_copy_custom_browse_block";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_copy_custom_browse_block";
          _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v19)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_copy_custom_browse_block";
          _os_log_impl(&dword_182FBE000, v6, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_copy_custom_browse_block";
          _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_browse_block";
        v23 = 2082;
        *(_QWORD *)v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v5)
    {
LABEL_23:
      v3 = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v5);
    goto LABEL_23;
  }
  if (*((_DWORD *)v1 + 2) <= 0x3E7u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v22 = "nw_browse_descriptor_copy_custom_browse_block";
    v23 = 1024;
    *(_DWORD *)v24 = 1000;
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_browse_block";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Custom browse type values must start at %d", buf, 0x12u);
      }
    }
    else if (v19)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446722;
          v22 = "nw_browse_descriptor_copy_custom_browse_block";
          v23 = 1024;
          *(_DWORD *)v24 = 1000;
          v24[2] = 2082;
          *(_QWORD *)&v24[3] = v8;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Custom browse type values must start at %d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v8);
        if (!v5)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_browse_block";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Custom browse type values must start at %d, no backtrace", buf, 0x12u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_copy_custom_browse_block";
        v23 = 1024;
        *(_DWORD *)v24 = 1000;
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s Custom browse type values must start at %d, backtrace limit exceeded", buf, 0x12u);
      }
    }
    goto LABEL_20;
  }
  v3 = _Block_copy(v1[8]);
LABEL_24:

  return v3;
}

BOOL nw_browse_descriptor_is_meta_query(void *a1)
{
  const char **v1;
  const char **v2;
  const char *v3;
  _BOOL8 v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_browse_descriptor_is_meta_query";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_browse_descriptor_is_meta_query";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_browse_descriptor_is_meta_query";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_browse_descriptor_is_meta_query";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_browse_descriptor_is_meta_query";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_21:
    if (v6)
      free(v6);
    goto LABEL_23;
  }
  if (*((_DWORD *)v1 + 2) != 1 || (v3 = v1[2]) == 0)
  {
LABEL_23:
    v4 = 0;
    goto LABEL_24;
  }
  v4 = strcmp(v3, "_services._dns-sd._udp") == 0;
LABEL_24:

  return v4;
}

void nw_browse_descriptor_set_include_txt_record(nw_browse_descriptor_t descriptor, BOOL include_txt_record)
{
  nw_browse_descriptor_t v3;
  nw_browse_descriptor_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = descriptor;
  v4 = v3;
  if (v3)
  {
    LOBYTE(v3[14].isa) = (uint64_t)v3[14].isa & 0xFE | include_txt_record;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_set_include_txt_record";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_set_include_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_set_include_txt_record";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_set_include_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_set_include_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

BOOL nw_browse_descriptor_get_include_txt_record(nw_browse_descriptor_t descriptor)
{
  nw_browse_descriptor_t v1;
  nw_browse_descriptor_t v2;
  BOOL v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = descriptor;
  v2 = v1;
  if (v1)
  {
    v3 = (uint64_t)v1[14].isa & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_get_include_txt_record";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_include_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_get_include_txt_record";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_include_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_include_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_browse_descriptor_set_sign_results(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 2;
    else
      v5 = 0;
    *((_BYTE *)v3 + 112) = *((_BYTE *)v3 + 112) & 0xFD | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_browse_descriptor_set_sign_results";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_descriptor_set_sign_results";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_browse_descriptor_set_sign_results";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_descriptor_set_sign_results";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_descriptor_set_sign_results";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

uint64_t nw_browse_descriptor_get_sign_results(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[112] >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_get_sign_results";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_sign_results";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_get_sign_results";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_sign_results";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_sign_results";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_browse_descriptor_set_discover_application_service_endpoints_only(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 4;
    else
      v5 = 0;
    *((_BYTE *)v3 + 112) = *((_BYTE *)v3 + 112) & 0xFB | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_browse_descriptor_set_discover_application_service_endpoints_only";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_descriptor_set_discover_application_service_endpoints_only";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_browse_descriptor_set_discover_application_service_endpoints_only";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_descriptor_set_discover_application_service_endpoints_only";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_descriptor_set_discover_application_service_endpoints_only";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

uint64_t nw_browse_descriptor_get_discover_application_service_endpoints_only(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[112] >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_descriptor_get_discover_application_service_endpoints_only";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_discover_application_service_endpoints_only";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_descriptor_get_discover_application_service_endpoints_only";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_discover_application_service_endpoints_only";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_descriptor_get_discover_application_service_endpoints_only";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_browse_descriptor_set_invitation_scope(void *a1, int a2)
{
  id v3;
  void *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_set_invitation_scope";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_invitation_scope";
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (!v19)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_invitation_scope";
          _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_set_invitation_scope";
          _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_set_invitation_scope";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v6)
      goto LABEL_23;
LABEL_22:
    free(v6);
    goto LABEL_23;
  }
  if (*((_DWORD *)v3 + 2) == 2)
  {
    *((_DWORD *)v3 + 24) = a2;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v22 = "nw_browse_descriptor_set_invitation_scope";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_21;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_invitation_scope";
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
    }
LABEL_20:

    goto LABEL_21;
  }
  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v12 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_invitation_scope";
      _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_20;
  }
  v9 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  v10 = type;
  v11 = os_log_type_enabled(v7, type);
  if (!v9)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_browse_descriptor_set_invitation_scope";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
    }
    goto LABEL_20;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_browse_descriptor_set_invitation_scope";
    v23 = 2082;
    v24 = v9;
    _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v9);
  if (v6)
    goto LABEL_22;
LABEL_23:

}

uint64_t nw_browse_descriptor_get_invitation_scope(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *v8;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_invitation_scope";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v5, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_invitation_scope";
          _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null descriptor", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v19)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_invitation_scope";
          _os_log_impl(&dword_182FBE000, v6, v18, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_browse_descriptor_get_invitation_scope";
          _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_browse_descriptor_get_invitation_scope";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v5)
    {
LABEL_23:
      v3 = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v5);
    goto LABEL_23;
  }
  if (v1[2] != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_browse_descriptor_get_invitation_scope";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_invitation_scope";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Browse descriptor not of type application service", buf, 0xCu);
      }
    }
    else if (v19)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (v8)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_browse_descriptor_get_invitation_scope";
          v23 = 2082;
          v24 = v8;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v8);
        if (!v5)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_invitation_scope";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s Browse descriptor not of type application service, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_browse_descriptor_get_invitation_scope";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s Browse descriptor not of type application service, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_20;
  }
  v3 = v1[24];
LABEL_24:

  return v3;
}

void sub_183B4B13C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_association *nw_association_create(void *a1, void *a2)
{
  id v4;
  id v5;
  NWConcrete_nw_association *v6;
  id v7;
  id v8;
  void *v9;
  NWConcrete_nw_association *v10;
  OS_nw_path_parameters *v11;
  OS_nw_path_parameters *path_parameters;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t receiver;
  void *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  char *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  os_log_type_t v36;
  os_log_type_t v37;
  char v38;
  objc_super v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  char *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = a2;
  v6 = [NWConcrete_nw_association alloc];
  v7 = v4;
  v8 = v5;
  v9 = v8;
  if (v6)
  {
    if (v7)
    {
      if (v8)
      {
        v39.receiver = v6;
        v39.super_class = (Class)NWConcrete_nw_association;
        v10 = (NWConcrete_nw_association *)objc_msgSendSuper2(&v39, sel_init);
        v6 = v10;
        if (v10)
        {
          objc_storeStrong((id *)&v10->endpoint, a1);
          v11 = (OS_nw_path_parameters *)nw_parameters_copy_path_parameters(v9, 1);
          path_parameters = v6->path_parameters;
          v6->path_parameters = v11;

          *((_BYTE *)v6 + 76) |= 1u;
          goto LABEL_6;
        }
        __nwlog_obj();
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
        v23 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v38 = 0;
        if ((__nwlog_fault(v23, &type, &v38) & 1) == 0)
          goto LABEL_61;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446210;
            v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v38)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v33 = type;
          v34 = os_log_type_enabled(v24, type);
          if (backtrace_string)
          {
            if (v34)
            {
              *(_DWORD *)buf = 136446466;
              v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
              v43 = 2082;
              v44 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_61;
          }
          if (v34)
          {
            *(_DWORD *)buf = 136446210;
            v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v37 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446210;
            v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            _os_log_impl(&dword_182FBE000, v24, v37, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

LABEL_61:
        if (v23)
          free(v23);
        goto LABEL_63;
      }
      __nwlog_obj();
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
      v19 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(v39.receiver) = 16;
      type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v19, &v39, &type))
        goto LABEL_55;
      if (LOBYTE(v39.receiver) == 17)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        receiver = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_182FBE000, v20, receiver, "%{public}s called with null _parameters", buf, 0xCu);
        }
      }
      else if (type)
      {
        v29 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v30 = (os_log_type_t)v39.receiver;
        v31 = os_log_type_enabled(v20, (os_log_type_t)v39.receiver);
        if (v29)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            v43 = 2082;
            v44 = v29;
            _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s called with null _parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v29);
          goto LABEL_55;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s called with null _parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v36 = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_182FBE000, v20, v36, "%{public}s called with null _parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

LABEL_55:
      if (v19)
        free(v19);
LABEL_51:

LABEL_63:
      v6 = 0;
      goto LABEL_6;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
    v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v39.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &v39, &type))
    {
      if (LOBYTE(v39.receiver) == 17)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v17 = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v16, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null _endpoint", buf, 0xCu);
        }
      }
      else if (type)
      {
        v26 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v27 = (os_log_type_t)v39.receiver;
        v28 = os_log_type_enabled(v16, (os_log_type_t)v39.receiver);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            v43 = 2082;
            v44 = v26;
            _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null _endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v26);
          goto LABEL_49;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null _endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v35 = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v16, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_182FBE000, v16, v35, "%{public}s called with null _endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_49:
    if (v15)
      free(v15);
    goto LABEL_51;
  }
LABEL_6:

  return v6;
}

void sub_183B4B8AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183B4B8C0()
{
  void *v0;
  void *v1;
  void *v2;

  JUMPOUT(0x183B4B8B0);
}

void __nw_association_create_with_evaluator_block_invoke(uint64_t a1, void *a2)
{
  nw_association_update_paths(*(void **)(a1 + 32), a2);
}

void nw_association_update_paths(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  id v6;
  uint64_t v7;
  char *v8;
  _QWORD *v9;
  void *v10;
  char *v11;
  int v12;
  BOOL v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  _QWORD v28[4];
  id v29;
  BOOL v30;
  _QWORD v31[4];
  id v32;
  _QWORD v33[4];
  id v34;
  id v35;
  id v36;
  char v37;
  os_log_type_t v38;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_association_update_paths";
    v15 = (char *)_os_log_send_and_compose_impl();

    v38 = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v15, &v38, &v37))
      goto LABEL_45;
    if (v38 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = v38;
      if (os_log_type_enabled(v16, v38))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_association_update_paths";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = v38;
      v22 = os_log_type_enabled(v16, v38);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_association_update_paths";
          v41 = 2082;
          v42 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v15)
          goto LABEL_11;
LABEL_46:
        free(v15);
        goto LABEL_11;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_association_update_paths";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = v38;
      if (os_log_type_enabled(v16, v38))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_association_update_paths";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_44:

    goto LABEL_45;
  }
  if (v4)
  {
    v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
    nw_context_assert_queue(v6);
    v7 = MEMORY[0x1E0C809B0];
    if (*((_QWORD *)v3 + 4))
    {
      v8 = (char *)*((_QWORD *)v3 + 7);
      if (v8)
      {
        v33[0] = MEMORY[0x1E0C809B0];
        v33[1] = 3221225472;
        v33[2] = ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke;
        v33[3] = &unk_1E14AC318;
        v34 = v3;
        v35 = v5;
        v36 = v6;
        nw_hash_table_apply(v8, (uint64_t)v33);

      }
    }
    v9 = nw_path_copy_without_parameters(v5);
    v10 = (void *)*((_QWORD *)v3 + 4);
    *((_QWORD *)v3 + 4) = v9;

    v11 = (char *)*((_QWORD *)v3 + 5);
    if (v11)
    {
      v12 = *((_DWORD *)v3 + 18);
      v13 = v12 != 0;
      if (v12)
      {
        v31[0] = v7;
        v31[1] = 3221225472;
        v31[2] = ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke_82;
        v31[3] = &unk_1E14AC340;
        v32 = v5;
        nw_hash_table_apply(v11, (uint64_t)v31);

        v11 = (char *)*((_QWORD *)v3 + 5);
      }
      v28[0] = v7;
      v28[1] = 3221225472;
      v28[2] = ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke_2;
      v28[3] = &unk_1E14AC368;
      v30 = v13;
      v29 = v5;
      nw_hash_table_apply(v11, (uint64_t)v28);

    }
    goto LABEL_11;
  }
  __nwlog_obj();
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v40 = "nw_association_update_paths";
  v15 = (char *)_os_log_send_and_compose_impl();

  v38 = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (!__nwlog_fault(v15, &v38, &v37))
    goto LABEL_45;
  if (v38 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v19 = v38;
    if (os_log_type_enabled(v16, v38))
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_association_update_paths";
      _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null path", buf, 0xCu);
    }
    goto LABEL_44;
  }
  if (!v37)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v27 = v38;
    if (os_log_type_enabled(v16, v38))
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_association_update_paths";
      _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_44;
  }
  v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  v24 = v38;
  v25 = os_log_type_enabled(v16, v38);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_association_update_paths";
      _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null path, no backtrace", buf, 0xCu);
    }
    goto LABEL_44;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    v40 = "nw_association_update_paths";
    v41 = 2082;
    v42 = v23;
    _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v15)
    goto LABEL_46;
LABEL_11:

}

void sub_183B4BEC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t extra;
  uint64_t *v6;
  uint64_t v7;
  time_t v8;
  time_t v9;
  int v10;
  void *v11;
  void *v12;
  _QWORD *v13;
  id v14;
  id v15;
  uint64_t v16;
  uint64_t (*v17)(_QWORD *, uint64_t, BOOL, id, id);
  uint64_t v18;
  id v19;
  const char *logging_description;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  const char *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  os_log_type_t v31;
  const char *v32;
  os_log_type_t v33;
  const char *v34;
  void *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  void *v43;
  char v44;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  void *v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  char *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  nw_hash_node_get_object(a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  extra = nw_hash_node_get_extra(a2);
  v6 = (uint64_t *)extra;
  v43 = v4;
  if (!*(_QWORD *)(extra + 32))
    goto LABEL_7;
  v7 = *(_QWORD *)(extra + 40);
  v8 = time(0);
  v9 = v6[4];
  v10 = v8 > v9;
  v11 = *(void **)(a1 + 40);
  v12 = *(void **)(*(_QWORD *)(a1 + 32) + 32);
  v13 = v4;
  v14 = v12;
  v15 = v11;
  if (!v13)
  {
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_protocol_definition_should_flush_cache";
    v36 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (__nwlog_fault(v36, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_protocol_definition_should_flush_cache";
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s called with null definition", buf, 0xCu);
        }
      }
      else if (v44)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v40 = type;
        v41 = os_log_type_enabled(v37, type);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            v47 = "nw_protocol_definition_should_flush_cache";
            v48 = 2082;
            v49 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_57;
        }
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_protocol_definition_should_flush_cache";
          _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_protocol_definition_should_flush_cache";
          _os_log_impl(&dword_182FBE000, v37, v42, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_57:
    if (v36)
      free(v36);

    v4 = v43;
    goto LABEL_22;
  }
  v16 = v13[9];
  if (v16)
  {
    v17 = *(uint64_t (**)(_QWORD *, uint64_t, BOOL, id, id))(v16 + 64);
    if (v17)
      v10 = v17(v13, v7, v8 > v9, v14, v15);
  }

  v4 = v43;
  if (!v10)
    goto LABEL_22;
LABEL_7:
  v18 = v6[5];
  if (v18)
    nw_protocol_definition_deallocate_cache_entry(v4, v18);
  nw_context_remove_cache_entry(*(void **)(a1 + 48), v6);
  if (nw_hash_table_remove_node(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56), a2)
    || nw_path_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16)))
  {
    goto LABEL_22;
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v19 = (id)gconnectionLogObj;
  logging_description = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 32) + 8));
  *(_DWORD *)buf = 136446722;
  v47 = "nw_association_update_paths_block_invoke";
  v48 = 2082;
  v49 = (void *)logging_description;
  v50 = 2048;
  v51 = a2;
  v21 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v44 = 0;
  if (__nwlog_fault(v21, &type, &v44))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v22 = (id)gconnectionLogObj;
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        v24 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 32) + 8));
        *(_DWORD *)buf = 136446722;
        v47 = "nw_association_update_paths_block_invoke";
        v48 = 2082;
        v49 = (void *)v24;
        v50 = 2048;
        v51 = a2;
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p", buf, 0x20u);
      }
    }
    else if (v44)
    {
      v26 = __nw_create_backtrace_string();
      if (v26)
      {
        v27 = (char *)v26;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v28 = (id)gconnectionLogObj;
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          v30 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 32) + 8));
          *(_DWORD *)buf = 136446978;
          v47 = "nw_association_update_paths_block_invoke";
          v48 = 2082;
          v49 = (void *)v30;
          v50 = 2048;
          v51 = a2;
          v52 = 2082;
          v53 = v27;
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v27);
        v4 = v43;
        if (v21)
          goto LABEL_21;
        goto LABEL_22;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v22 = (id)gconnectionLogObj;
      v33 = type;
      if (os_log_type_enabled(v22, type))
      {
        v34 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 32) + 8));
        *(_DWORD *)buf = 136446722;
        v47 = "nw_association_update_paths_block_invoke";
        v48 = 2082;
        v49 = (void *)v34;
        v50 = 2048;
        v51 = a2;
        _os_log_impl(&dword_182FBE000, v22, v33, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v22 = (id)gconnectionLogObj;
      v31 = type;
      if (os_log_type_enabled(v22, type))
      {
        v32 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 32) + 8));
        *(_DWORD *)buf = 136446722;
        v47 = "nw_association_update_paths_block_invoke";
        v48 = 2082;
        v49 = (void *)v32;
        v50 = 2048;
        v51 = a2;
        _os_log_impl(&dword_182FBE000, v22, v31, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded", buf, 0x20u);
      }
    }

  }
  v4 = v43;
  if (v21)
LABEL_21:
    free(v21);
LABEL_22:

  return 1;
}

void sub_183B4C5F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke_82(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t extra;
  void (**v6)(void *, void *, _QWORD);

  nw_hash_node_get_object(a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  extra = nw_hash_node_get_extra(a2);
  if ((*(_BYTE *)(extra + 8) & 1) != 0)
  {
    v6 = (void (**)(void *, void *, _QWORD))_Block_copy(*(const void **)extra);
    v6[2](v6, v4, *(_QWORD *)(a1 + 32));

  }
  return 1;
}

void sub_183B4C6B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke_2(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t extra;
  void (**v6)(void *, void *, _QWORD);

  nw_hash_node_get_object(a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  extra = nw_hash_node_get_extra(a2);
  if (!*(_BYTE *)(a1 + 40) || (*(_BYTE *)(extra + 8) & 1) == 0)
  {
    v6 = (void (**)(void *, void *, _QWORD))_Block_copy(*(const void **)extra);
    v6[2](v6, v4, *(_QWORD *)(a1 + 32));

  }
  return 1;
}

void sub_183B4C740(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void __nw_association_update_with_evaluator_block_invoke(uint64_t a1, void *a2)
{
  nw_association_update_paths(*(void **)(a1 + 32), a2);
}

id nw_association_copy_endpoint(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[1];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_association_copy_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_association_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_association_copy_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_association_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_association_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_association_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

void nw_association_activate(void *a1, void *a2, int a3, int a4)
{
  id v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  void *v12;
  os_unfair_lock_s *v13;
  os_unfair_lock_s *v14;
  id *v15;
  id v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  NWConcrete_nw_association *v20;
  _QWORD v21[4];
  NWConcrete_nw_association *v22;

  v7 = a1;
  v9 = a2;
  v10 = *((_QWORD *)v7 + 8);
  if (v10)
  {
    nw_queue_cancel_source(v10, v8);
    *((_QWORD *)v7 + 8) = 0;
  }
  if ((*((_BYTE *)v7 + 76) & 1) != 0)
  {
    *((_BYTE *)v7 + 76) &= ~1u;
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(*((void **)v7 + 1), v9);
    v12 = (void *)*((_QWORD *)v7 + 3);
    *((_QWORD *)v7 + 3) = evaluator_for_endpoint;

    v13 = (os_unfair_lock_s *)*((_QWORD *)v7 + 3);
    if (v13)
    {
      v14 = v13 + 24;
      v15 = v13;
      os_unfair_lock_lock(v14);
      v16 = v15[6];
      os_unfair_lock_unlock(v14);

    }
    else
    {
      v16 = 0;
    }
    v17 = nw_path_copy_without_parameters(v16);
    v18 = (void *)*((_QWORD *)v7 + 4);
    *((_QWORD *)v7 + 4) = v17;

    nw_path_evaluator_set_logging(*((void **)v7 + 3));
    v19 = (void *)*((_QWORD *)v7 + 3);
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = ___ZL23nw_association_activateP25NWConcrete_nw_associationPU27objcproto16OS_nw_parameters8NSObjectbb_block_invoke;
    v21[3] = &unk_1E14AC2C8;
    v20 = (NWConcrete_nw_association *)v7;
    v22 = v20;
    nw_path_evaluator_set_update_handler(v19, 0, v21);
    if (a4)
      nw_association_schedule_deactivation(v20);

  }
  else if (a3)
  {
    nw_path_evaluator_force_update(*((void **)v7 + 3), 0);
  }

}

void sub_183B4CB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void ___ZL23nw_association_activateP25NWConcrete_nw_associationPU27objcproto16OS_nw_parameters8NSObjectbb_block_invoke(uint64_t a1, void *a2)
{
  nw_association_update_paths(*(void **)(a1 + 32), a2);
}

void nw_association_schedule_deactivation(NWConcrete_nw_association *a1)
{
  NWConcrete_nw_association *v1;
  uint64_t *v2;
  nw_hash_table *handles;
  id v4;
  id v5;
  uint64_t *v6;
  uint64_t association_dormant_delay;
  uint64_t v8;
  dispatch_time_t v9;
  uint64_t v10;
  NSObject *v11;
  const char *logging_description;
  _QWORD v13[4];
  id v14;
  uint64_t *v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (uint64_t *)v1;
  if ((*((_BYTE *)v1 + 76) & 1) == 0)
  {
    handles = v1->handles;
    if (!handles || !*((_DWORD *)handles + 10))
    {
      v4 = nw_path_parameters_copy_context(v1->path_parameters);
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 3221225472;
      v13[2] = ___ZL36nw_association_schedule_deactivationP25NWConcrete_nw_association_block_invoke;
      v13[3] = &unk_1E14ACE68;
      v5 = v4;
      v14 = v5;
      v6 = v2;
      v15 = v6;
      v6[8] = nw_queue_context_create_source(v5, 2, 3, 0, v13, 0);
      association_dormant_delay = nw_context_get_association_dormant_delay(v5);
      if (!association_dormant_delay)
        association_dormant_delay = 1000
                                  * networkd_settings_get_int64_with_default((const char *)nw_setting_association_dormant_delay, 10);
      v8 = v6[8];
      v9 = dispatch_time(0x8000000000000000, 1000000 * association_dormant_delay);
      nw_queue_set_timer_values(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0x989680uLL);
      nw_queue_activate_source(v6[8], v10);
      if (!nw_path_parameters_get_logging_disabled(v2[2]))
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v11 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          logging_description = nw_endpoint_get_logging_description((void *)v6[1]);
          *(_DWORD *)buf = 136446722;
          v17 = "nw_association_schedule_deactivation";
          v18 = 2082;
          v19 = logging_description;
          v20 = 2048;
          v21 = association_dormant_delay;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s <nw_association %{public}s> will become dormant after %lldms of inactivity", buf, 0x20u);
        }

      }
    }
  }

}

void sub_183B4CDBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void ___ZL36nw_association_schedule_deactivationP25NWConcrete_nw_association_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  void *v7;
  NSObject *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  NSObject *v12;
  const char *logging_description;
  void *v14;
  uint64_t v15;
  os_unfair_lock_s *v16;
  id v17;
  const char *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  uint64_t v23;
  os_unfair_lock_s *v24;
  id v25;
  const char *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  char *backtrace_string;
  os_log_type_t v32;
  _BOOL4 v33;
  const char *v34;
  char *v35;
  os_log_type_t v36;
  _BOOL4 v37;
  const char *v38;
  os_log_type_t v39;
  const char *v40;
  os_log_type_t v41;
  const char *v42;
  const char *v43;
  const char *v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  nw_context_assert_queue(*(void **)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(v3 + 40);
  if (v4 && *(_DWORD *)(v4 + 40))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    v6 = *(const char **)(a1 + 40);
    *(_DWORD *)buf = 136446466;
    v48 = "nw_association_schedule_deactivation_block_invoke";
    v49 = 2114;
    v50 = v6;
    v7 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v7))
      goto LABEL_79;
    free(v7);
    v3 = *(_QWORD *)(a1 + 40);
  }
  if ((*(_BYTE *)(v3 + 76) & 1) == 0)
    goto LABEL_8;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  v9 = *(const char **)(a1 + 40);
  *(_DWORD *)buf = 136446466;
  v48 = "nw_association_schedule_deactivation_block_invoke";
  v49 = 2114;
  v50 = v9;
  v10 = (void *)_os_log_send_and_compose_impl();

  if (__nwlog_abort((uint64_t)v10))
  {
LABEL_79:
    __break(1u);
    return;
  }
  free(v10);
  v3 = *(_QWORD *)(a1 + 40);
LABEL_8:
  v11 = *(_QWORD *)(v3 + 64);
  if (v11)
  {
    nw_queue_cancel_source(v11, v2);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 64) = 0;
    v3 = *(_QWORD *)(a1 + 40);
  }
  if (!nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 16)))
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v12 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      logging_description = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
      *(_DWORD *)buf = 136446466;
      v48 = "nw_association_schedule_deactivation_block_invoke";
      v49 = 2082;
      v50 = logging_description;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_INFO, "%{public}s <nw_association %{public}s> becoming dormant", buf, 0x16u);
    }

  }
  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 76) |= 1u;
  nw_path_evaluator_cancel(*(void **)(*(_QWORD *)(a1 + 40) + 24));
  v14 = *(void **)(*(_QWORD *)(a1 + 40) + 24);
  *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) = 0;

  v16 = *(os_unfair_lock_s **)(*(_QWORD *)(a1 + 40) + 48);
  if (v16)
  {
    if (v16[10]._os_unfair_lock_opaque)
    {
      if (nw_path_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16)))
        goto LABEL_31;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = (id)gconnectionLogObj;
      v18 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
      *(_DWORD *)buf = 136446466;
      v48 = "nw_association_schedule_deactivation_block_invoke";
      v49 = 2082;
      v50 = v18;
      v19 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v45 = 0;
      if ((__nwlog_fault(v19, &type, &v45) & 1) == 0)
      {
LABEL_28:
        if (!v19)
          goto LABEL_31;
        goto LABEL_29;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v20 = (id)gconnectionLogObj;
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          v22 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
          *(_DWORD *)buf = 136446466;
          v48 = "nw_association_schedule_deactivation_block_invoke";
          v49 = 2082;
          v50 = v22;
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s <nw_association %{public}s> dormant, but connected flow handles is non-empty", buf, 0x16u);
        }
LABEL_27:

        goto LABEL_28;
      }
      if (!v45)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v20 = (id)gconnectionLogObj;
        v39 = type;
        if (os_log_type_enabled(v20, type))
        {
          v40 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
          *(_DWORD *)buf = 136446466;
          v48 = "nw_association_schedule_deactivation_block_invoke";
          v49 = 2082;
          v50 = v40;
          _os_log_impl(&dword_182FBE000, v20, v39, "%{public}s <nw_association %{public}s> dormant, but connected flow handles is non-empty, backtrace limit exceeded", buf, 0x16u);
        }
        goto LABEL_27;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v20 = (id)gconnectionLogObj;
      v32 = type;
      v33 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (v33)
        {
          v43 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
          *(_DWORD *)buf = 136446466;
          v48 = "nw_association_schedule_deactivation_block_invoke";
          v49 = 2082;
          v50 = v43;
          _os_log_impl(&dword_182FBE000, v20, v32, "%{public}s <nw_association %{public}s> dormant, but connected flow handles is non-empty, no backtrace", buf, 0x16u);
        }
        goto LABEL_27;
      }
      if (v33)
      {
        v34 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446722;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v34;
        v51 = 2082;
        v52 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v20, v32, "%{public}s <nw_association %{public}s> dormant, but connected flow handles is non-empty, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(backtrace_string);
      if (v19)
LABEL_29:
        free(v19);
    }
    else
    {
      _nw_hash_table_release(v16, v15);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 48) = 0;
    }
  }
LABEL_31:
  v23 = *(_QWORD *)(a1 + 40);
  v24 = *(os_unfair_lock_s **)(v23 + 40);
  if (!v24)
    return;
  if (!v24[10]._os_unfair_lock_opaque)
  {
    _nw_hash_table_release(v24, v15);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 40) = 0;
    return;
  }
  if (nw_path_parameters_get_logging_disabled(*(_QWORD *)(v23 + 16)))
    return;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v25 = (id)gconnectionLogObj;
  v26 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
  *(_DWORD *)buf = 136446466;
  v48 = "nw_association_schedule_deactivation_block_invoke";
  v49 = 2082;
  v50 = v26;
  v27 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if ((__nwlog_fault(v27, &type, &v45) & 1) != 0)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v28 = (id)gconnectionLogObj;
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        v30 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446466;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v30;
        _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty", buf, 0x16u);
      }
    }
    else if (v45)
    {
      v35 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v28 = (id)gconnectionLogObj;
      v36 = type;
      v37 = os_log_type_enabled(v28, type);
      if (v35)
      {
        if (v37)
        {
          v38 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
          *(_DWORD *)buf = 136446722;
          v48 = "nw_association_schedule_deactivation_block_invoke";
          v49 = 2082;
          v50 = v38;
          v51 = 2082;
          v52 = v35;
          _os_log_impl(&dword_182FBE000, v28, v36, "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v35);
        if (v27)
          goto LABEL_44;
        return;
      }
      if (v37)
      {
        v44 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446466;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v44;
        _os_log_impl(&dword_182FBE000, v28, v36, "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty, no backtrace", buf, 0x16u);
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v28 = (id)gconnectionLogObj;
      v41 = type;
      if (os_log_type_enabled(v28, type))
      {
        v42 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446466;
        v48 = "nw_association_schedule_deactivation_block_invoke";
        v49 = 2082;
        v50 = v42;
        _os_log_impl(&dword_182FBE000, v28, v41, "%{public}s <nw_association %{public}s> dormant, but handles hash table is non-empty, backtrace limit exceeded", buf, 0x16u);
      }
    }

  }
  if (v27)
LABEL_44:
    free(v27);
}

void sub_183B4D768(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_association_mark_flow_disconnected(void *a1, void *a2)
{
  id v3;
  char *v4;
  char *v5;
  id v6;
  uint64_t v7;
  id v8;
  const char *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  id v14;
  const char *logging_description;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  const char *v20;
  char *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  os_log_type_t v29;
  const char *v30;
  os_log_type_t v31;
  const char *v32;
  os_log_type_t v33;
  const char *v34;
  os_log_type_t v35;
  const char *v36;
  uint64_t v37;
  _BOOL8 node;
  _BOOL8 v39;
  id v40;
  const char *v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  NSObject *v45;
  const char *v46;
  const char *v47;
  const char *v48;
  char *v49;
  NSObject *v50;
  os_log_type_t v51;
  const char *v52;
  os_log_type_t v53;
  const char *v54;
  os_log_type_t v55;
  const char *v56;
  void *v57;
  os_log_type_t v58;
  void *v59;
  os_log_type_t v60;
  char *backtrace_string;
  os_log_type_t v62;
  _BOOL4 v63;
  os_log_type_t v64;
  _BOOL4 v65;
  os_log_type_t v66;
  os_log_type_t v67;
  char v68;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v71;
  __int16 v72;
  void *v73;
  __int16 v74;
  char *v75;
  __int16 v76;
  char *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_association_mark_flow_disconnected";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v16, &type, &v68))
      goto LABEL_106;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_182FBE000, v17, v58, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v68)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v62 = type;
      v63 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446466;
          v71 = "nw_association_mark_flow_disconnected";
          v72 = 2082;
          v73 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v62, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_106;
      }
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_182FBE000, v17, v62, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v66 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_182FBE000, v17, v66, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_140:

    goto LABEL_106;
  }
  if (!v4)
  {
    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_association_mark_flow_disconnected";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v16, &type, &v68))
      goto LABEL_106;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v60 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_182FBE000, v17, v60, "%{public}s called with null handle", buf, 0xCu);
      }
      goto LABEL_140;
    }
    if (!v68)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v67 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_182FBE000, v17, v67, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_140;
    }
    v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    v64 = type;
    v65 = os_log_type_enabled(v17, type);
    if (!v21)
    {
      if (v65)
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_association_mark_flow_disconnected";
        _os_log_impl(&dword_182FBE000, v17, v64, "%{public}s called with null handle, no backtrace", buf, 0xCu);
      }
      goto LABEL_140;
    }
    if (v65)
    {
      *(_DWORD *)buf = 136446466;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      v73 = v21;
      _os_log_impl(&dword_182FBE000, v17, v64, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_31;
  }
  v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);

  v7 = *((_QWORD *)v3 + 5);
  if (!v7)
  {
    if (nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
      goto LABEL_108;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v14 = (id)gconnectionLogObj;
    logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446466;
    v71 = "nw_association_mark_flow_disconnected";
    v72 = 2082;
    v73 = (void *)logging_description;
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v16, &type, &v68))
      goto LABEL_106;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = (id)gconnectionLogObj;
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        v19 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v19;
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s <nw_association %{public}s> does not have a handle hash table", buf, 0x16u);
      }
      goto LABEL_140;
    }
    if (!v68)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = (id)gconnectionLogObj;
      v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        v30 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v30;
        _os_log_impl(&dword_182FBE000, v17, v29, "%{public}s <nw_association %{public}s> does not have a handle hash table, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_140;
    }
    v20 = __nw_create_backtrace_string();
    if (!v20)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = (id)gconnectionLogObj;
      v31 = type;
      if (os_log_type_enabled(v17, type))
      {
        v32 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v32;
        _os_log_impl(&dword_182FBE000, v17, v31, "%{public}s <nw_association %{public}s> does not have a handle hash table, no backtrace", buf, 0x16u);
      }
      goto LABEL_140;
    }
    v21 = (char *)v20;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v17 = (id)gconnectionLogObj;
    v22 = type;
    if (os_log_type_enabled(v17, type))
    {
      v23 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446722;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      v73 = (void *)v23;
      v74 = 2082;
      v75 = v21;
      _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s <nw_association %{public}s> does not have a handle hash table, dumping backtrace:%{public}s", buf, 0x20u);
    }
LABEL_31:

    free(v21);
    if (!v16)
      goto LABEL_108;
    goto LABEL_107;
  }
  if (!nw_hash_table_get_node(v7, (uint64_t)v5, 0) && !nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v8 = (id)gconnectionLogObj;
    v9 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446722;
    v71 = "nw_association_mark_flow_disconnected";
    v72 = 2082;
    v73 = (void *)v9;
    v74 = 2048;
    v75 = v5;
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v10, &type, &v68))
    {
LABEL_61:
      if (!v10)
        goto LABEL_63;
      goto LABEL_62;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        v13 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v13;
        v74 = 2048;
        v75 = v5;
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s <nw_association %{public}s> does not have handle %p registered", buf, 0x20u);
      }
LABEL_60:

      goto LABEL_61;
    }
    if (!v68)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      v33 = type;
      if (os_log_type_enabled(v11, type))
      {
        v34 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v34;
        v74 = 2048;
        v75 = v5;
        _os_log_impl(&dword_182FBE000, v11, v33, "%{public}s <nw_association %{public}s> does not have handle %p registered, backtrace limit exceeded", buf, 0x20u);
      }
      goto LABEL_60;
    }
    v24 = __nw_create_backtrace_string();
    if (!v24)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      v35 = type;
      if (os_log_type_enabled(v11, type))
      {
        v36 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v36;
        v74 = 2048;
        v75 = v5;
        _os_log_impl(&dword_182FBE000, v11, v35, "%{public}s <nw_association %{public}s> does not have handle %p registered, no backtrace", buf, 0x20u);
      }
      goto LABEL_60;
    }
    v25 = (char *)v24;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v26 = (id)gconnectionLogObj;
    v27 = type;
    if (os_log_type_enabled(v26, type))
    {
      v28 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      v73 = (void *)v28;
      v74 = 2048;
      v75 = v5;
      v76 = 2082;
      v77 = v25;
      _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s <nw_association %{public}s> does not have handle %p registered, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(v25);
    if (v10)
LABEL_62:
      free(v10);
  }
LABEL_63:
  v37 = *((_QWORD *)v3 + 6);
  if (!v37)
  {
    if (nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
      goto LABEL_108;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v45 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
    {
      v46 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446466;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      v73 = (void *)v46;
      _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_INFO, "%{public}s <nw_association %{public}s> does not have a connected flow hash table", buf, 0x16u);
    }
LABEL_81:

    goto LABEL_108;
  }
  node = nw_hash_table_get_node(v37, (uint64_t)v5, 0);
  if (!node)
  {
    if (nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
      goto LABEL_108;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v45 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
    {
      v47 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446722;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      v73 = (void *)v47;
      v74 = 2048;
      v75 = v5;
      _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_INFO, "%{public}s <nw_association %{public}s> does not have connected flow %p registered", buf, 0x20u);
    }
    goto LABEL_81;
  }
  v39 = node;
  if (nw_hash_table_remove_node(*((_QWORD *)v3 + 6), node)
    || nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
  {
    goto LABEL_108;
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v40 = (id)gconnectionLogObj;
  v41 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
  *(_DWORD *)buf = 136446722;
  v71 = "nw_association_mark_flow_disconnected";
  v72 = 2082;
  v73 = (void *)v41;
  v74 = 2048;
  v75 = (char *)v39;
  v16 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v68 = 0;
  if (__nwlog_fault(v16, &type, &v68))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = (id)gconnectionLogObj;
      v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        v44 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v44;
        v74 = 2048;
        v75 = (char *)v39;
        _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p", buf, 0x20u);
      }
    }
    else if (v68)
    {
      v48 = __nw_create_backtrace_string();
      if (v48)
      {
        v49 = (char *)v48;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v50 = (id)gconnectionLogObj;
        v51 = type;
        if (os_log_type_enabled(v50, type))
        {
          v52 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
          *(_DWORD *)buf = 136446978;
          v71 = "nw_association_mark_flow_disconnected";
          v72 = 2082;
          v73 = (void *)v52;
          v74 = 2048;
          v75 = (char *)v39;
          v76 = 2082;
          v77 = v49;
          _os_log_impl(&dword_182FBE000, v50, v51, "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v49);
        if (v16)
          goto LABEL_107;
        goto LABEL_108;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = (id)gconnectionLogObj;
      v55 = type;
      if (os_log_type_enabled(v42, type))
      {
        v56 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v56;
        v74 = 2048;
        v75 = (char *)v39;
        _os_log_impl(&dword_182FBE000, v42, v55, "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v42 = (id)gconnectionLogObj;
      v53 = type;
      if (os_log_type_enabled(v42, type))
      {
        v54 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v54;
        v74 = 2048;
        v75 = (char *)v39;
        _os_log_impl(&dword_182FBE000, v42, v53, "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p, backtrace limit exceeded", buf, 0x20u);
      }
    }

  }
LABEL_106:
  if (v16)
LABEL_107:
    free(v16);
LABEL_108:

}

void sub_183B4E838(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

NWConcrete_nw_path_flow_registration *nw_association_create_flow(uint64_t a1, int a2, int a3, int a4, int a5, _OWORD *a6, _DWORD *a7)
{
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
    return nw_path_evaluator_create_flow_inner(*(void **)(a1 + 24), a2, a3, a5, a4, a6, 0, 0, a7);
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_association_create_flow";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_association_create_flow";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_association_create_flow";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_association_create_flow";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_association_create_flow";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v9)
    free(v9);
  return 0;
}

void nw_association_clear_cached_content_for_protocol(void *a1, void *a2)
{
  nw_association_set_cached_content_for_protocol(a1, a2, 0, 0);
}

NWConcrete_nw_interface_status_monitor *nw_connection_create_interface_status_monitor(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  id v5;
  void *v6;
  dispatch_queue_t *v7;
  dispatch_queue_t *v8;
  NWConcrete_nw_interface_status_monitor *v9;
  OS_nw_channel *v10;
  OS_nw_channel *channel;
  void *v12;
  void *v13;
  OS_nw_interface *v14;
  OS_nw_interface *interface;
  NWConcrete_nw_interface_status_monitor *v16;
  _QWORD *v17;
  NSObject *v18;
  int v19;
  void *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  void *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  void *v29;
  os_log_type_t v30;
  void *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  char *v35;
  os_log_type_t v36;
  _BOOL4 v37;
  char *backtrace_string;
  os_log_type_t v39;
  _BOOL4 v40;
  char *v41;
  os_log_type_t v42;
  _BOOL4 v43;
  char *v44;
  os_log_type_t v45;
  _BOOL4 v46;
  os_log_type_t v47;
  os_log_type_t v48;
  os_log_type_t v49;
  os_log_type_t v50;
  char v51;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v54;
  __int16 v55;
  char *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[2];

    v5 = nw_parameters_copy_context(v4);
    v6 = v5;
    if (!v5)
    {
      __nwlog_obj();
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v54 = "nw_connection_create_interface_status_monitor";
      v26 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (!__nwlog_fault(v26, &type, &v51))
        goto LABEL_87;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_connection_create_interface_status_monitor";
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v51)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v39 = type;
        v40 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446466;
            v54 = "nw_connection_create_interface_status_monitor";
            v55 = 2082;
            v56 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v27, v39, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v26)
            goto LABEL_89;
          goto LABEL_88;
        }
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_connection_create_interface_status_monitor";
          _os_log_impl(&dword_182FBE000, v27, v39, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_connection_create_interface_status_monitor";
          _os_log_impl(&dword_182FBE000, v27, v48, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_86;
    }
    v7 = (dispatch_queue_t *)v5;
    v8 = v7;
    if (((_BYTE)v7[17] & 8) == 0)
      dispatch_assert_queue_V2(v7[1]);

    if ((*((_BYTE *)v3 + 109) & 0x40) != 0)
    {
      v9 = objc_alloc_init(NWConcrete_nw_interface_status_monitor);
      if (v9)
      {
        v10 = (OS_nw_channel *)nw_endpoint_handler_copy_channel(v3[18]);
        channel = v9->channel;
        v9->channel = v10;

        if (v9->channel)
        {
          v12 = (void *)nw_endpoint_handler_copy_connected_path(v3[18]);
          v13 = v12;
          if (v12)
          {
            v14 = (OS_nw_interface *)nw_path_copy_interface(v12);
            interface = v9->interface;
            v9->interface = v14;

          }
          v16 = v9;

          goto LABEL_19;
        }
        v17 = v3[2];
        if (v17 && !nw_path_parameters_get_logging_disabled(v17[13]))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v18 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
          {
            v19 = *((_DWORD *)v3 + 112);
            *(_DWORD *)buf = 136446466;
            v54 = "nw_connection_create_interface_status_monitor";
            v55 = 1024;
            LODWORD(v56) = v19;
            _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_INFO, "%{public}s [C%u] Cannot start an interface monitor, channel is not available", buf, 0x12u);
          }

        }
LABEL_18:
        v16 = 0;
LABEL_19:

LABEL_20:
        goto LABEL_21;
      }
      __nwlog_obj();
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v54 = "nw_connection_create_interface_status_monitor";
      v32 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (__nwlog_fault(v32, &type, &v51))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v33 = objc_claimAutoreleasedReturnValue();
          v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v54 = "nw_connection_create_interface_status_monitor";
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null monitor", buf, 0xCu);
          }
        }
        else if (v51)
        {
          v44 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v33 = objc_claimAutoreleasedReturnValue();
          v45 = type;
          v46 = os_log_type_enabled(v33, type);
          if (v44)
          {
            if (v46)
            {
              *(_DWORD *)buf = 136446466;
              v54 = "nw_connection_create_interface_status_monitor";
              v55 = 2082;
              v56 = v44;
              _os_log_impl(&dword_182FBE000, v33, v45, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v44);
            goto LABEL_93;
          }
          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            v54 = "nw_connection_create_interface_status_monitor";
            _os_log_impl(&dword_182FBE000, v33, v45, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v33 = objc_claimAutoreleasedReturnValue();
          v50 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v54 = "nw_connection_create_interface_status_monitor";
            _os_log_impl(&dword_182FBE000, v33, v50, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_93:
      if (v32)
        free(v32);
      goto LABEL_18;
    }
    __nwlog_obj();
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v54 = "nw_connection_create_interface_status_monitor";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v26, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_connection_create_interface_status_monitor";
          _os_log_impl(&dword_182FBE000, v27, v30, "%{public}s called with null connection->endpoint_handler_connected", buf, 0xCu);
        }
LABEL_86:

        goto LABEL_87;
      }
      if (!v51)
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v49 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_connection_create_interface_status_monitor";
          _os_log_impl(&dword_182FBE000, v27, v49, "%{public}s called with null connection->endpoint_handler_connected, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_86;
      }
      v41 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v42 = type;
      v43 = os_log_type_enabled(v27, type);
      if (!v41)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_connection_create_interface_status_monitor";
          _os_log_impl(&dword_182FBE000, v27, v42, "%{public}s called with null connection->endpoint_handler_connected, no backtrace", buf, 0xCu);
        }
        goto LABEL_86;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        v54 = "nw_connection_create_interface_status_monitor";
        v55 = 2082;
        v56 = v41;
        _os_log_impl(&dword_182FBE000, v27, v42, "%{public}s called with null connection->endpoint_handler_connected, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v41);
    }
LABEL_87:
    if (!v26)
    {
LABEL_89:
      v16 = 0;
      goto LABEL_20;
    }
LABEL_88:
    free(v26);
    goto LABEL_89;
  }
  __nwlog_obj();
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v54 = "nw_connection_create_interface_status_monitor";
  v22 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (__nwlog_fault(v22, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v54 = "nw_connection_create_interface_status_monitor";
        _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v51)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      v37 = os_log_type_enabled(v23, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v54 = "nw_connection_create_interface_status_monitor";
          v55 = 2082;
          v56 = v35;
          _os_log_impl(&dword_182FBE000, v23, v36, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v35);
        goto LABEL_78;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v54 = "nw_connection_create_interface_status_monitor";
        _os_log_impl(&dword_182FBE000, v23, v36, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v54 = "nw_connection_create_interface_status_monitor";
        _os_log_impl(&dword_182FBE000, v23, v47, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_78:
  if (v22)
    free(v22);
  v16 = 0;
LABEL_21:

  return v16;
}

void sub_183B4F914(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

id nw_interface_status_monitor_copy_interface(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[1];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_status_monitor_copy_interface";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_status_monitor_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_status_monitor_copy_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_status_monitor_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_status_monitor_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_interface_status_monitor_cancel(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  void *v8;
  NSObject *v9;
  id v10;
  const void *v11;
  void *v12;
  NSObject *v13;
  id v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  _QWORD v27[4];
  id v28;
  _QWORD block[4];
  id v30;
  char v31;
  os_log_type_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 72) |= 1u;
    v3 = (void *)v1[2];
    v1[2] = 0;

    v5 = v2[7];
    if (v5)
    {
      nw_queue_cancel_source(v5, v4);
      v2[7] = 0;
    }
    v6 = v2[8];
    if (v6)
    {
      nw_queue_cancel_source(v6, v4);
      v2[8] = 0;
    }
    v7 = (const void *)v2[5];
    if (v7 && v2[6])
    {
      v8 = _Block_copy(v7);
      v9 = v2[6];
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __nw_interface_status_monitor_cancel_block_invoke;
      block[3] = &unk_1E14AC390;
      v30 = v8;
      v10 = v8;
      dispatch_async(v9, block);

    }
    v11 = (const void *)v2[3];
    if (v11 && v2[4])
    {
      v12 = _Block_copy(v11);
      v13 = v2[4];
      v27[0] = MEMORY[0x1E0C809B0];
      v27[1] = 3221225472;
      v27[2] = __nw_interface_status_monitor_cancel_block_invoke_2;
      v27[3] = &unk_1E14AC390;
      v28 = v12;
      v14 = v12;
      dispatch_async(v13, v27);

    }
    v15 = (void *)v2[5];
    v2[5] = 0;

    v16 = (void *)v2[6];
    v2[6] = 0;

    v17 = (void *)v2[3];
    v2[3] = 0;

    v18 = (void *)v2[4];
    v2[4] = 0;

    goto LABEL_13;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v34 = "nw_interface_status_monitor_cancel";
  v20 = (char *)_os_log_send_and_compose_impl();

  v32 = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (__nwlog_fault(v20, &v32, &v31))
  {
    if (v32 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = v32;
      if (os_log_type_enabled(v21, v32))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_interface_status_monitor_cancel";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v24 = v32;
      v25 = os_log_type_enabled(v21, v32);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_interface_status_monitor_cancel";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_interface_status_monitor_cancel";
        _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v26 = v32;
      if (os_log_type_enabled(v21, v32))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_interface_status_monitor_cancel";
        _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_30:
  if (v20)
    free(v20);
LABEL_13:

}

void sub_183B4FFB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_interface_status_monitor_cancel_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __nw_interface_status_monitor_cancel_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void nw_interface_status_monitor_set_update_handler(void *a1, void *a2, void *a3)
{
  id v5;
  NSObject *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  int v15;
  uint64_t source;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  void *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  char *v31;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  _BOOL4 v35;
  os_log_type_t v36;
  os_log_type_t v37;
  os_log_type_t v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  char *v43;
  _BOOL4 v44;
  _QWORD block[4];
  id v46;
  int v47;
  _QWORD v48[4];
  id v49;
  _QWORD v50[4];
  id v51;
  os_log_type_t type[8];
  uint64_t v53;
  void (*v54)(uint64_t);
  void *v55;
  uint64_t v56;
  char v57;
  os_log_type_t v58;
  _BYTE buf[24];
  void *v60;
  _QWORD *v61;
  uint64_t v62;
  uint8_t v63[4];
  const char *v64;
  __int16 v65;
  char *v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
    v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v63[0] = 0;
    if (!__nwlog_fault(v21, type, v63))
      goto LABEL_70;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type[0];
      if (os_log_type_enabled(v22, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v63[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v29 = type[0];
      v30 = os_log_type_enabled(v22, type[0]);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_70:
        if (!v21)
          goto LABEL_14;
LABEL_71:
        free(v21);
        goto LABEL_14;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v36 = type[0];
      if (os_log_type_enabled(v22, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v36, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_69:

    goto LABEL_70;
  }
  if (!v7)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
    v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v63[0] = 0;
    if (!__nwlog_fault(v21, type, v63))
      goto LABEL_70;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v25 = type[0];
      if (os_log_type_enabled(v22, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (!v63[0])
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v37 = type[0];
      if (os_log_type_enabled(v22, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v37, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_69;
    }
    v31 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    v32 = type[0];
    v33 = os_log_type_enabled(v22, type[0]);
    if (!v31)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v32, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v31;
      _os_log_impl(&dword_182FBE000, v22, v32, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_44;
  }
  if (!v6)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
    v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v63[0] = 0;
    if (!__nwlog_fault(v21, type, v63))
      goto LABEL_70;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v27 = type[0];
      if (os_log_type_enabled(v22, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s called with null queue", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (!v63[0])
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v38 = type[0];
      if (os_log_type_enabled(v22, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v38, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_69;
    }
    v31 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    v34 = type[0];
    v35 = os_log_type_enabled(v22, type[0]);
    if (!v31)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v22, v34, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_update_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v31;
      _os_log_impl(&dword_182FBE000, v22, v34, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_44:

    free(v31);
    if (!v21)
      goto LABEL_14;
    goto LABEL_71;
  }
  if ((*((_BYTE *)v5 + 72) & 1) != 0 || !*((_QWORD *)v5 + 2))
  {
    v50[0] = MEMORY[0x1E0C809B0];
    v50[1] = 3221225472;
    v50[2] = __nw_interface_status_monitor_set_update_handler_block_invoke;
    v50[3] = &unk_1E14AC390;
    v51 = v7;
    dispatch_async(v6, v50);

    goto LABEL_14;
  }
  v9 = _Block_copy(v7);
  v10 = (void *)*((_QWORD *)v5 + 5);
  *((_QWORD *)v5 + 5) = v9;

  objc_storeStrong((id *)v5 + 6, a2);
  if (!*((_QWORD *)v5 + 8))
  {
    v11 = *((_QWORD *)v5 + 2);
    v12 = MEMORY[0x1E0C809B0];
    v48[0] = MEMORY[0x1E0C809B0];
    v48[1] = 3221225472;
    v48[2] = __nw_interface_status_monitor_set_update_handler_block_invoke_2;
    v48[3] = &unk_1E14AC3E0;
    v49 = v5;
    if (v11)
    {
      nw_context_assert_queue(*(void **)(v11 + 152));
      if (*(_QWORD *)(v11 + 136))
      {
        v13 = os_channel_configure_interface_advisory();
        if (v13)
        {
          LODWORD(source) = v13;
          *((_QWORD *)v5 + 8) = 0;
        }
        else
        {
          dispatch_group_enter(*(dispatch_group_t *)(v11 + 208));
          v14 = *(void **)(v11 + 152);
          v15 = *(_DWORD *)(v11 + 432);
          *(_QWORD *)buf = v12;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = __nw_channel_create_interface_advisory_source_block_invoke;
          v60 = &unk_1E14ACA00;
          v61 = v48;
          v62 = v11;
          *(_QWORD *)type = v12;
          v53 = 0x40000000;
          v54 = __nw_channel_create_interface_advisory_source_block_invoke_2;
          v55 = &__block_descriptor_tmp_11_86445;
          v56 = v11;
          source = nw_queue_context_create_source(v14, v15, 5, 4u, buf, type);
          nw_queue_activate_source(source, v17);
          *((_QWORD *)v5 + 8) = source;
          if (source)
          {
LABEL_12:

            goto LABEL_14;
          }
        }
      }
      else
      {
        LODWORD(source) = 6;
        *((_QWORD *)v5 + 8) = 0;
      }
LABEL_11:
      v18 = (void *)*((_QWORD *)v5 + 5);
      *((_QWORD *)v5 + 5) = 0;

      v19 = (void *)*((_QWORD *)v5 + 6);
      *((_QWORD *)v5 + 6) = 0;

      block[0] = v12;
      block[1] = 3221225472;
      block[2] = __nw_interface_status_monitor_set_update_handler_block_invoke_4;
      block[3] = &unk_1E14AC408;
      v46 = v8;
      v47 = source;
      dispatch_async(v6, block);

      goto LABEL_12;
    }
    __nwlog_obj();
    *(_DWORD *)v63 = 136446210;
    v64 = "nw_channel_create_interface_advisory_source";
    v39 = (char *)_os_log_send_and_compose_impl();
    v58 = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (__nwlog_fault(v39, &v58, &v57))
    {
      if (v58 == OS_LOG_TYPE_FAULT)
      {
        v40 = __nwlog_obj();
        v41 = v58;
        if (os_log_type_enabled(v40, v58))
        {
          *(_DWORD *)v63 = 136446210;
          v64 = "nw_channel_create_interface_advisory_source";
          v42 = "%{public}s called with null channel";
LABEL_81:
          _os_log_impl(&dword_182FBE000, v40, v41, v42, v63, 0xCu);
        }
      }
      else if (v57)
      {
        v43 = (char *)__nw_create_backtrace_string();
        v40 = __nwlog_obj();
        v41 = v58;
        v44 = os_log_type_enabled(v40, v58);
        if (v43)
        {
          if (v44)
          {
            *(_DWORD *)v63 = 136446466;
            v64 = "nw_channel_create_interface_advisory_source";
            v65 = 2082;
            v66 = v43;
            _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s called with null channel, dumping backtrace:%{public}s", v63, 0x16u);
          }
          free(v43);
          goto LABEL_82;
        }
        if (v44)
        {
          *(_DWORD *)v63 = 136446210;
          v64 = "nw_channel_create_interface_advisory_source";
          v42 = "%{public}s called with null channel, no backtrace";
          goto LABEL_81;
        }
      }
      else
      {
        v40 = __nwlog_obj();
        v41 = v58;
        if (os_log_type_enabled(v40, v58))
        {
          *(_DWORD *)v63 = 136446210;
          v64 = "nw_channel_create_interface_advisory_source";
          v42 = "%{public}s called with null channel, backtrace limit exceeded";
          goto LABEL_81;
        }
      }
    }
LABEL_82:
    if (v39)
      free(v39);
    LODWORD(source) = 0;
    v12 = MEMORY[0x1E0C809B0];
    *((_QWORD *)v5 + 8) = 0;
    goto LABEL_11;
  }
LABEL_14:

}

uint64_t __nw_interface_status_monitor_set_update_handler_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __nw_interface_status_monitor_set_update_handler_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  void *v8;
  void *v9;
  NSObject *v10;
  _QWORD v11[4];
  id v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  _QWORD v16[4];

  v8 = _Block_copy(*(const void **)(*(_QWORD *)(a1 + 32) + 40));
  v9 = v8;
  if (v8 && (v10 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 48)) != 0)
  {
    v16[0] = 0;
    v16[1] = v16;
    v16[2] = 0x2020000000;
    v16[3] = a2;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = __nw_interface_status_monitor_set_update_handler_block_invoke_3;
    v11[3] = &unk_1E14AC3B8;
    v12 = v8;
    v13 = v16;
    v14 = a3;
    v15 = a4;
    dispatch_async(v10, v11);

    _Block_object_dispose(v16, 8);
  }
  else if (a2)
  {
    free(a2);
  }

}

uint64_t __nw_interface_status_monitor_set_update_handler_block_invoke_4(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;

  v1 = *(_DWORD *)(a1 + 40);
  if (v1)
    v2 = v1;
  else
    v2 = 22;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0, 0, v2);
}

void __nw_interface_status_monitor_set_update_handler_block_invoke_3(uint64_t a1)
{
  void *v2;

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void nw_interface_status_monitor_set_packet_event_handler(void *a1, void *a2, void *a3)
{
  id v5;
  NSObject *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  int v14;
  uint64_t source;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  os_log_type_t v24;
  void *v25;
  os_log_type_t v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  os_log_type_t v36;
  os_log_type_t v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  _QWORD block[4];
  id v45;
  int v46;
  _QWORD v47[4];
  id v48;
  _QWORD v49[4];
  id v50;
  os_log_type_t type[8];
  uint64_t v52;
  void (*v53)(uint64_t);
  void *v54;
  uint64_t v55;
  char v56;
  os_log_type_t v57;
  _BYTE buf[24];
  void *v59;
  _QWORD *v60;
  uint64_t v61;
  uint8_t v62[4];
  const char *v63;
  __int16 v64;
  char *v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
    v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v62[0] = 0;
    if (!__nwlog_fault(v20, type, v62))
      goto LABEL_68;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v62[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v28 = type[0];
      v29 = os_log_type_enabled(v21, type[0]);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v28, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_68:
        if (!v20)
          goto LABEL_13;
LABEL_69:
        free(v20);
        goto LABEL_13;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v28, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v35 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v35, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_67:

    goto LABEL_68;
  }
  if (!v7)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
    v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v62[0] = 0;
    if (!__nwlog_fault(v20, type, v62))
      goto LABEL_68;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v24 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_67;
    }
    if (!v62[0])
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v36 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v36, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_67;
    }
    v30 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    v31 = type[0];
    v32 = os_log_type_enabled(v21, type[0]);
    if (!v30)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v31, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_67;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v30;
      _os_log_impl(&dword_182FBE000, v21, v31, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_43;
  }
  if (!v6)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
    v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v62[0] = 0;
    if (!__nwlog_fault(v20, type, v62))
      goto LABEL_68;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v26 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null queue", buf, 0xCu);
      }
      goto LABEL_67;
    }
    if (!v62[0])
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v37 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v37, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_67;
    }
    v30 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    v33 = type[0];
    v34 = os_log_type_enabled(v21, type[0]);
    if (!v30)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
        _os_log_impl(&dword_182FBE000, v21, v33, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_67;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_interface_status_monitor_set_packet_event_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v30;
      _os_log_impl(&dword_182FBE000, v21, v33, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_43:

    free(v30);
    if (!v20)
      goto LABEL_13;
    goto LABEL_69;
  }
  if ((*((_BYTE *)v5 + 72) & 1) != 0 || !*((_QWORD *)v5 + 2))
  {
    v49[0] = MEMORY[0x1E0C809B0];
    v49[1] = 3221225472;
    v49[2] = __nw_interface_status_monitor_set_packet_event_handler_block_invoke;
    v49[3] = &unk_1E14AC390;
    v50 = v7;
    dispatch_async(v6, v49);

    goto LABEL_13;
  }
  v9 = _Block_copy(v7);
  v10 = (void *)*((_QWORD *)v5 + 3);
  *((_QWORD *)v5 + 3) = v9;

  objc_storeStrong((id *)v5 + 4, a2);
  if (!*((_QWORD *)v5 + 7))
  {
    v11 = *((_QWORD *)v5 + 2);
    v12 = MEMORY[0x1E0C809B0];
    v47[0] = MEMORY[0x1E0C809B0];
    v47[1] = 3221225472;
    v47[2] = __nw_interface_status_monitor_set_packet_event_handler_block_invoke_2;
    v47[3] = &unk_1E14AC458;
    v48 = v5;
    if (v11)
    {
      nw_context_assert_queue(*(void **)(v11 + 152));
      if (*(_QWORD *)(v11 + 136))
      {
        dispatch_group_enter(*(dispatch_group_t *)(v11 + 208));
        v13 = *(void **)(v11 + 152);
        v14 = *(_DWORD *)(v11 + 432);
        *(_QWORD *)buf = v12;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __nw_channel_create_event_source_block_invoke;
        v59 = &unk_1E14AC9B8;
        v60 = v47;
        v61 = v11;
        *(_QWORD *)type = v12;
        v52 = 0x40000000;
        v53 = __nw_channel_create_event_source_block_invoke_8;
        v54 = &__block_descriptor_tmp_9_86428;
        v55 = v11;
        source = nw_queue_context_create_source(v13, v14, 5, 2u, buf, type);
        nw_queue_activate_source(source, v16);
        *((_QWORD *)v5 + 7) = source;
        if (source)
        {
LABEL_11:

          goto LABEL_13;
        }
      }
      else
      {
        LODWORD(source) = 6;
        *((_QWORD *)v5 + 7) = 0;
      }
LABEL_10:
      v17 = (void *)*((_QWORD *)v5 + 3);
      *((_QWORD *)v5 + 3) = 0;

      v18 = (void *)*((_QWORD *)v5 + 4);
      *((_QWORD *)v5 + 4) = 0;

      block[0] = v12;
      block[1] = 3221225472;
      block[2] = __nw_interface_status_monitor_set_packet_event_handler_block_invoke_4;
      block[3] = &unk_1E14AC408;
      v45 = v8;
      v46 = source;
      dispatch_async(v6, block);

      goto LABEL_11;
    }
    __nwlog_obj();
    *(_DWORD *)v62 = 136446210;
    v63 = "nw_channel_create_event_source";
    v38 = (char *)_os_log_send_and_compose_impl();
    v57 = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (__nwlog_fault(v38, &v57, &v56))
    {
      if (v57 == OS_LOG_TYPE_FAULT)
      {
        v39 = __nwlog_obj();
        v40 = v57;
        if (os_log_type_enabled(v39, v57))
        {
          *(_DWORD *)v62 = 136446210;
          v63 = "nw_channel_create_event_source";
          v41 = "%{public}s called with null channel";
LABEL_79:
          _os_log_impl(&dword_182FBE000, v39, v40, v41, v62, 0xCu);
        }
      }
      else if (v56)
      {
        v42 = (char *)__nw_create_backtrace_string();
        v39 = __nwlog_obj();
        v40 = v57;
        v43 = os_log_type_enabled(v39, v57);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)v62 = 136446466;
            v63 = "nw_channel_create_event_source";
            v64 = 2082;
            v65 = v42;
            _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s called with null channel, dumping backtrace:%{public}s", v62, 0x16u);
          }
          free(v42);
          goto LABEL_80;
        }
        if (v43)
        {
          *(_DWORD *)v62 = 136446210;
          v63 = "nw_channel_create_event_source";
          v41 = "%{public}s called with null channel, no backtrace";
          goto LABEL_79;
        }
      }
      else
      {
        v39 = __nwlog_obj();
        v40 = v57;
        if (os_log_type_enabled(v39, v57))
        {
          *(_DWORD *)v62 = 136446210;
          v63 = "nw_channel_create_event_source";
          v41 = "%{public}s called with null channel, backtrace limit exceeded";
          goto LABEL_79;
        }
      }
    }
LABEL_80:
    if (v38)
      free(v38);
    LODWORD(source) = 0;
    v12 = MEMORY[0x1E0C809B0];
    *((_QWORD *)v5 + 7) = 0;
    goto LABEL_10;
  }
LABEL_13:

}

uint64_t __nw_interface_status_monitor_set_packet_event_handler_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __nw_interface_status_monitor_set_packet_event_handler_block_invoke_2(uint64_t a1, int a2, void *a3, uint64_t a4, int a5)
{
  void *v10;
  void *v11;
  NSObject *v12;
  _QWORD v13[4];
  id v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  int v18;
  _QWORD v19[4];

  v10 = _Block_copy(*(const void **)(*(_QWORD *)(a1 + 32) + 24));
  v11 = v10;
  if (v10 && (v12 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 32)) != 0)
  {
    v19[0] = 0;
    v19[1] = v19;
    v19[2] = 0x2020000000;
    v19[3] = a3;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_interface_status_monitor_set_packet_event_handler_block_invoke_3;
    v13[3] = &unk_1E14AC430;
    v14 = v10;
    v15 = v19;
    v16 = a4;
    v17 = a2;
    v18 = a5;
    dispatch_async(v12, v13);

    _Block_object_dispose(v19, 8);
  }
  else if (a3)
  {
    free(a3);
  }

}

uint64_t __nw_interface_status_monitor_set_packet_event_handler_block_invoke_4(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;

  v1 = *(_DWORD *)(a1 + 40);
  if (v1)
    v2 = v1;
  else
    v2 = 22;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0, 0, 0, v2);
}

void __nw_interface_status_monitor_set_packet_event_handler_block_invoke_3(uint64_t a1)
{
  void *v2;

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void ___ZL26nw_protocol_ipv6_callbacksv_block_invoke()
{
  nw_protocol_ipv6_callbacks(void)::callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler((_QWORD *)nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_add_input_handler);
  nw_protocol_callbacks_set_replace_input_handler(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_replace_input_handler);
  nw_protocol_callbacks_set_remove_input_handler(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_remove_input_handler);
  nw_protocol_callbacks_set_get_input_frames(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_get_input_frames);
  nw_protocol_callbacks_set_get_output_frames(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_get_output_frames);
  nw_protocol_callbacks_set_finalize_output_frames(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_finalize_output_frames);
  nw_protocol_callbacks_set_connected(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_connected);
  nw_protocol_callbacks_set_disconnected(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_disconnected);
  nw_protocol_callbacks_set_get_message_properties(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_get_message_properties);
  nw_protocol_callbacks_set_copy_info(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_copy_info);
  nw_protocol_callbacks_set_updated_path(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_updated_path);
  nw_protocol_callbacks_set_notify(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_notify);
  nw_protocol_callbacks_set_error(nw_protocol_ipv6_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv6_error);
}

uint64_t nw_protocol_ipv6_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol_identifier *identifier;
  nw_protocol_callbacks *callbacks;
  NSObject *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  nw_protocol_callbacks *v11;
  void *handle;
  nw_protocol_callbacks *v13;
  nw_protocol_callbacks *v14;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v16;
  void *v17;
  nw_protocol_callbacks *v18;
  nw_protocol_callbacks *v19;
  uint64_t (*get_local_endpoint)(nw_protocol *);
  NSObject *v21;
  void *v22;
  _BOOL4 v23;
  nw_protocol_callbacks *v24;
  char *v25;
  _BOOL4 v26;
  nw_protocol_callbacks *v27;
  nw_protocol_callbacks *v28;
  void (**v29)(_QWORD);
  const void *v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *v35;
  _BOOL4 v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  char *v41;
  _BOOL4 v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  const char *v46;
  char *v47;
  _BOOL4 v48;
  char *v49;
  NSObject *v50;
  os_log_type_t v51;
  const char *v52;
  char *v53;
  _BOOL4 v54;
  NSObject *v55;
  nw_protocol_identifier *v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  nw_protocol_identifier *v60;
  const char *v61;
  nw_protocol_identifier *v62;
  char *v63;
  NSObject *v64;
  os_log_type_t v65;
  nw_protocol_identifier *v66;
  const char *v67;
  char *v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  char *v72;
  _BOOL4 v73;
  nw_protocol_identifier *v74;
  char *v75;
  _BOOL4 v76;
  nw_protocol_identifier *v77;
  char *backtrace_string;
  _BOOL4 v79;
  const char *v80;
  _BOOL4 v81;
  _BOOL4 v82;
  _BOOL4 v83;
  nw_protocol_identifier *v84;
  nw_protocol_identifier *v85;
  nw_protocol_identifier *v86;
  nw_protocol_identifier *v87;
  nw_protocol_callbacks *v88;
  uint64_t (*get_remote_endpoint)(nw_protocol *);
  nw_protocol *default_input_handler;
  void *v91;
  nw_protocol_callbacks *v92;
  nw_protocol_callbacks *v93;
  uint64_t (*get_path)(nw_protocol *);
  void *v95;
  unsigned __int8 *v96;
  unsigned __int8 *v97;
  unsigned __int8 *v98;
  uint64_t v99;
  char *v100;
  unint64_t v101;
  int v102;
  int hop_limit;
  char v104;
  char v105;
  char v106;
  char v107;
  uint64_t v108;
  nw_protocol_callbacks *v110;
  nw_protocol_callbacks *v111;
  void (**v112)(_QWORD);
  const void *v113;
  nw_protocol_callbacks *v114;
  nw_protocol_callbacks *v115;
  void (**v116)(_QWORD);
  const void *v117;
  nw_protocol_callbacks *v118;
  nw_protocol_callbacks *v119;
  void (**v120)(_QWORD);
  const void *v121;
  const char *name;
  char *v123;
  NSObject *v124;
  os_log_type_t v125;
  const char *v126;
  const char *v127;
  nw_protocol_identifier *v128;
  char *v129;
  NSObject *v130;
  os_log_type_t v131;
  nw_protocol_identifier *v132;
  const char *v133;
  char *v134;
  NSObject *v135;
  os_log_type_t v136;
  const char *v137;
  char *v138;
  _BOOL4 v139;
  const char *v140;
  char *v141;
  NSObject *v142;
  _BOOL4 v143;
  nw_protocol_identifier *v144;
  char *v145;
  _BOOL4 v146;
  const char *v147;
  const char *v148;
  nw_protocol_identifier *v149;
  NSObject *v150;
  nw_protocol_identifier *v151;
  NSObject *log;
  char v153;
  os_log_type_t v154;
  os_log_type_t type[16];
  uint8_t buf[4];
  const char *v157;
  __int16 v158;
  nw_protocol_identifier *v159;
  __int16 v160;
  nw_protocol *v161;
  __int16 v162;
  char *v163;
  uint64_t v164;

  v164 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "nw_protocol_ipv6_add_input_handler";
    v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v68, type, &v154))
      goto LABEL_363;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v154 == OS_LOG_TYPE_DEFAULT)
      {
        v69 = __nwlog_obj();
        v70 = type[0];
        if (os_log_type_enabled(v69, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v157 = "nw_protocol_ipv6_add_input_handler";
          v71 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_362;
        }
        goto LABEL_363;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = type[0];
      v79 = os_log_type_enabled(v69, type[0]);
      if (!backtrace_string)
      {
        if (v79)
        {
          *(_DWORD *)buf = 136446210;
          v157 = "nw_protocol_ipv6_add_input_handler";
          v71 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_362;
        }
        goto LABEL_363;
      }
      if (!v79)
        goto LABEL_187;
      *(_DWORD *)buf = 136446466;
      v157 = "nw_protocol_ipv6_add_input_handler";
      v158 = 2082;
      v159 = (nw_protocol_identifier *)backtrace_string;
      v80 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_186;
    }
    v69 = __nwlog_obj();
    v70 = type[0];
    if (!os_log_type_enabled(v69, type[0]))
      goto LABEL_363;
    *(_DWORD *)buf = 136446210;
    v157 = "nw_protocol_ipv6_add_input_handler";
    v71 = "%{public}s called with null protocol";
LABEL_362:
    _os_log_impl(&dword_182FBE000, v69, v70, v71, buf, 0xCu);
    goto LABEL_363;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "nw_protocol_ipv6_add_input_handler";
    v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v68, type, &v154))
      goto LABEL_363;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v154 == OS_LOG_TYPE_DEFAULT)
      {
        v69 = __nwlog_obj();
        v70 = type[0];
        if (os_log_type_enabled(v69, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v157 = "nw_protocol_ipv6_add_input_handler";
          v71 = "%{public}s called with null ipv6, backtrace limit exceeded";
          goto LABEL_362;
        }
        goto LABEL_363;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = type[0];
      v81 = os_log_type_enabled(v69, type[0]);
      if (!backtrace_string)
      {
        if (v81)
        {
          *(_DWORD *)buf = 136446210;
          v157 = "nw_protocol_ipv6_add_input_handler";
          v71 = "%{public}s called with null ipv6, no backtrace";
          goto LABEL_362;
        }
        goto LABEL_363;
      }
      if (!v81)
        goto LABEL_187;
      *(_DWORD *)buf = 136446466;
      v157 = "nw_protocol_ipv6_add_input_handler";
      v158 = 2082;
      v159 = (nw_protocol_identifier *)backtrace_string;
      v80 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_186;
    }
    v69 = __nwlog_obj();
    v70 = type[0];
    if (!os_log_type_enabled(v69, type[0]))
      goto LABEL_363;
    *(_DWORD *)buf = 136446210;
    v157 = "nw_protocol_ipv6_add_input_handler";
    v71 = "%{public}s called with null ipv6";
    goto LABEL_362;
  }
  if (a1->default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "nw_protocol_ipv6_add_input_handler";
    v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v68, type, &v154))
      goto LABEL_363;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v69 = __nwlog_obj();
      v70 = type[0];
      if (!os_log_type_enabled(v69, type[0]))
        goto LABEL_363;
      *(_DWORD *)buf = 136446210;
      v157 = "nw_protocol_ipv6_add_input_handler";
      v71 = "%{public}s Default input handler already exists";
      goto LABEL_362;
    }
    if (v154 == OS_LOG_TYPE_DEFAULT)
    {
      v69 = __nwlog_obj();
      v70 = type[0];
      if (os_log_type_enabled(v69, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v157 = "nw_protocol_ipv6_add_input_handler";
        v71 = "%{public}s Default input handler already exists, backtrace limit exceeded";
        goto LABEL_362;
      }
      goto LABEL_363;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v69 = __nwlog_obj();
    v70 = type[0];
    v82 = os_log_type_enabled(v69, type[0]);
    if (!backtrace_string)
    {
      if (v82)
      {
        *(_DWORD *)buf = 136446210;
        v157 = "nw_protocol_ipv6_add_input_handler";
        v71 = "%{public}s Default input handler already exists, no backtrace";
        goto LABEL_362;
      }
      goto LABEL_363;
    }
    if (!v82)
      goto LABEL_187;
    *(_DWORD *)buf = 136446466;
    v157 = "nw_protocol_ipv6_add_input_handler";
    v158 = 2082;
    v159 = (nw_protocol_identifier *)backtrace_string;
    v80 = "%{public}s Default input handler already exists, dumping backtrace:%{public}s";
LABEL_186:
    _os_log_impl(&dword_182FBE000, v69, v70, v80, buf, 0x16u);
    goto LABEL_187;
  }
  if (!a2)
  {
    if (!strncmp("invalid", "quic", 4uLL))
      goto LABEL_152;
    nw_protocol_set_flow_id_from_protocol(a1, 0);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "__nw_protocol_get_output_handler";
    v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v7, type, &v154))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v8 = __nwlog_obj();
        v9 = type[0];
        if (!os_log_type_enabled(v8, type[0]))
          goto LABEL_57;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_output_handler";
        v10 = "%{public}s called with null protocol";
LABEL_56:
        _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
        goto LABEL_57;
      }
      if (v154 == OS_LOG_TYPE_DEFAULT)
      {
        v8 = __nwlog_obj();
        v9 = type[0];
        if (!os_log_type_enabled(v8, type[0]))
          goto LABEL_57;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_output_handler";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_56;
      }
      v25 = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type[0];
      v26 = os_log_type_enabled(v8, type[0]);
      if (!v25)
      {
        if (!v26)
          goto LABEL_57;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_output_handler";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_56;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v157 = "__nw_protocol_get_output_handler";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v25;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v25);
    }
LABEL_57:
    if (v7)
      free(v7);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "__nw_protocol_set_output_handler";
    v31 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v31, type, &v154))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v32 = __nwlog_obj();
        v33 = type[0];
        if (!os_log_type_enabled(v32, type[0]))
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_set_output_handler";
        v34 = "%{public}s called with null protocol";
LABEL_72:
        _os_log_impl(&dword_182FBE000, v32, v33, v34, buf, 0xCu);
        goto LABEL_73;
      }
      if (v154 == OS_LOG_TYPE_DEFAULT)
      {
        v32 = __nwlog_obj();
        v33 = type[0];
        if (!os_log_type_enabled(v32, type[0]))
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_set_output_handler";
        v34 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_72;
      }
      v35 = (char *)__nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = type[0];
      v36 = os_log_type_enabled(v32, type[0]);
      if (!v35)
      {
        if (!v36)
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_set_output_handler";
        v34 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_72;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v157 = "__nw_protocol_set_output_handler";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v35;
        _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v35);
    }
LABEL_73:
    if (v31)
      free(v31);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "__nw_protocol_get_parameters";
    v37 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v37, type, &v154))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v38 = __nwlog_obj();
        v39 = type[0];
        if (!os_log_type_enabled(v38, type[0]))
          goto LABEL_89;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_parameters";
        v40 = "%{public}s called with null protocol";
LABEL_88:
        _os_log_impl(&dword_182FBE000, v38, v39, v40, buf, 0xCu);
        goto LABEL_89;
      }
      if (v154 == OS_LOG_TYPE_DEFAULT)
      {
        v38 = __nwlog_obj();
        v39 = type[0];
        if (!os_log_type_enabled(v38, type[0]))
          goto LABEL_89;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_parameters";
        v40 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_88;
      }
      v41 = (char *)__nw_create_backtrace_string();
      v38 = __nwlog_obj();
      v39 = type[0];
      v42 = os_log_type_enabled(v38, type[0]);
      if (!v41)
      {
        if (!v42)
          goto LABEL_89;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_parameters";
        v40 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_88;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v157 = "__nw_protocol_get_parameters";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v41;
        _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v41);
    }
LABEL_89:
    if (v37)
      free(v37);
    BYTE4(a1[3].output_handler_context) = nw_parameters_get_ip_protocol(0);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "__nw_protocol_get_local_endpoint";
    v43 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v43, type, &v154))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v44 = __nwlog_obj();
        v45 = type[0];
        if (!os_log_type_enabled(v44, type[0]))
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_local_endpoint";
        v46 = "%{public}s called with null protocol";
LABEL_104:
        _os_log_impl(&dword_182FBE000, v44, v45, v46, buf, 0xCu);
        goto LABEL_105;
      }
      if (v154 == OS_LOG_TYPE_DEFAULT)
      {
        v44 = __nwlog_obj();
        v45 = type[0];
        if (!os_log_type_enabled(v44, type[0]))
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_local_endpoint";
        v46 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_104;
      }
      v47 = (char *)__nw_create_backtrace_string();
      v44 = __nwlog_obj();
      v45 = type[0];
      v48 = os_log_type_enabled(v44, type[0]);
      if (!v47)
      {
        if (!v48)
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_local_endpoint";
        v46 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_104;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446466;
        v157 = "__nw_protocol_get_local_endpoint";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v47;
        _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v47);
    }
LABEL_105:
    if (v43)
      free(v43);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "__nw_protocol_get_remote_endpoint";
    v49 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v49, type, &v154))
      goto LABEL_121;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v50 = __nwlog_obj();
      v51 = type[0];
      if (os_log_type_enabled(v50, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_remote_endpoint";
        v52 = "%{public}s called with null protocol";
LABEL_120:
        _os_log_impl(&dword_182FBE000, v50, v51, v52, buf, 0xCu);
      }
    }
    else if (v154)
    {
      v53 = (char *)__nw_create_backtrace_string();
      v50 = __nwlog_obj();
      v51 = type[0];
      v54 = os_log_type_enabled(v50, type[0]);
      if (v53)
      {
        if (v54)
        {
          *(_DWORD *)buf = 136446466;
          v157 = "__nw_protocol_get_remote_endpoint";
          v158 = 2082;
          v159 = (nw_protocol_identifier *)v53;
          _os_log_impl(&dword_182FBE000, v50, v51, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v53);
        goto LABEL_121;
      }
      if (v54)
      {
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_remote_endpoint";
        v52 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_120;
      }
    }
    else
    {
      v50 = __nwlog_obj();
      v51 = type[0];
      if (os_log_type_enabled(v50, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v157 = "__nw_protocol_get_remote_endpoint";
        v52 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_120;
      }
    }
LABEL_121:
    if (v49)
      free(v49);
    v21 = 0;
    v16 = 0;
    v55 = 0;
    goto LABEL_227;
  }
  if (a2->identifier)
    identifier = a2->identifier;
  else
    identifier = (nw_protocol_identifier *)"invalid";
  if (!strncmp(identifier->name, "quic", 4uLL))
  {
LABEL_152:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "nw_protocol_ipv6_add_input_handler";
    v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v154 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v68, type, &v154))
      goto LABEL_363;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v69 = __nwlog_obj();
      v70 = type[0];
      if (os_log_type_enabled(v69, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v157 = "nw_protocol_ipv6_add_input_handler";
        v71 = "%{public}s Attempt to add quic to ip";
        goto LABEL_362;
      }
LABEL_363:
      if (v68)
        free(v68);
      return 0;
    }
    if (v154 == OS_LOG_TYPE_DEFAULT)
    {
      v69 = __nwlog_obj();
      v70 = type[0];
      if (os_log_type_enabled(v69, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v157 = "nw_protocol_ipv6_add_input_handler";
        v71 = "%{public}s Attempt to add quic to ip, backtrace limit exceeded";
        goto LABEL_362;
      }
      goto LABEL_363;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v69 = __nwlog_obj();
    v70 = type[0];
    v83 = os_log_type_enabled(v69, type[0]);
    if (!backtrace_string)
    {
      if (v83)
      {
        *(_DWORD *)buf = 136446210;
        v157 = "nw_protocol_ipv6_add_input_handler";
        v71 = "%{public}s Attempt to add quic to ip, no backtrace";
        goto LABEL_362;
      }
      goto LABEL_363;
    }
    if (v83)
    {
      *(_DWORD *)buf = 136446466;
      v157 = "nw_protocol_ipv6_add_input_handler";
      v158 = 2082;
      v159 = (nw_protocol_identifier *)backtrace_string;
      v80 = "%{public}s Attempt to add quic to ip, dumping backtrace:%{public}s";
      goto LABEL_186;
    }
LABEL_187:
    free(backtrace_string);
    goto LABEL_363;
  }
  a1->default_input_handler = a2;
  if (a2->handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = a2[1].callbacks;
    if (callbacks)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  nw_protocol_set_flow_id_from_protocol(a1, a2);
  if (a2->output_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v157 = "nw_protocol_ipv6_add_input_handler";
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s Output handler already exists for protocol being added as input handler", buf, 0xCu);
    }
  }
  else
  {
    a2->output_handler = a1;
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      v11 = a1[1].callbacks;
      if (v11)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v11->add_input_handler + 1);
    }
  }
  handle = a2->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    v13 = a2[1].callbacks;
    if (v13)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v13->add_input_handler + 1);
  }
  v14 = a2->callbacks;
  if (v14)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v14->get_parameters;
    if (get_parameters)
    {
      v16 = (void *)get_parameters(a2);
      if (handle != &nw_protocol_ref_counted_handle)
        goto LABEL_30;
      goto LABEL_29;
    }
  }
  __nwlog_obj();
  v56 = a2->identifier;
  if (!v56)
    v56 = (nw_protocol_identifier *)"invalid";
  *(_DWORD *)buf = 136446722;
  v157 = "__nw_protocol_get_parameters";
  v158 = 2082;
  v159 = v56;
  v160 = 2048;
  v161 = a2;
  v57 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v154 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v57, type, &v154))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v58 = __nwlog_obj();
      v59 = type[0];
      if (!os_log_type_enabled(v58, type[0]))
        goto LABEL_209;
      v60 = a2->identifier;
      if (!v60)
        v60 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_parameters";
      v158 = 2082;
      v159 = v60;
      v160 = 2048;
      v161 = a2;
      v61 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_208:
      _os_log_impl(&dword_182FBE000, v58, v59, v61, buf, 0x20u);
      goto LABEL_209;
    }
    if (v154 == OS_LOG_TYPE_DEFAULT)
    {
      v58 = __nwlog_obj();
      v59 = type[0];
      if (!os_log_type_enabled(v58, type[0]))
        goto LABEL_209;
      v84 = a2->identifier;
      if (!v84)
        v84 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_parameters";
      v158 = 2082;
      v159 = v84;
      v160 = 2048;
      v161 = a2;
      v61 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
      goto LABEL_208;
    }
    v72 = (char *)__nw_create_backtrace_string();
    v58 = __nwlog_obj();
    v59 = type[0];
    v73 = os_log_type_enabled(v58, type[0]);
    if (!v72)
    {
      if (!v73)
        goto LABEL_209;
      v86 = a2->identifier;
      if (!v86)
        v86 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_parameters";
      v158 = 2082;
      v159 = v86;
      v160 = 2048;
      v161 = a2;
      v61 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
      goto LABEL_208;
    }
    if (v73)
    {
      v74 = a2->identifier;
      if (!v74)
        v74 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446978;
      v157 = "__nw_protocol_get_parameters";
      v158 = 2082;
      v159 = v74;
      v160 = 2048;
      v161 = a2;
      v162 = 2082;
      v163 = v72;
      _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v72);
  }
LABEL_209:
  if (v57)
    free(v57);
  v16 = 0;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_29:
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      v27 = a2[1].callbacks;
      if (v27)
      {
        v28 = (nw_protocol_callbacks *)((char *)v27 - 1);
        a2[1].callbacks = v28;
        if (!v28)
        {
          v29 = *(void (***)(_QWORD))a2[1].flow_id;
          if (v29)
          {
            *(_QWORD *)a2[1].flow_id = 0;
            v29[2](v29);
            _Block_release(v29);
          }
          if ((a2[1].flow_id[8] & 1) != 0)
          {
            v30 = *(const void **)a2[1].flow_id;
            if (v30)
              _Block_release(v30);
          }
          free(a2);
        }
      }
    }
  }
LABEL_30:
  BYTE4(a1[3].output_handler_context) = nw_parameters_get_ip_protocol(v16);
  v17 = a2->handle;
  if (v17 == &nw_protocol_ref_counted_handle)
  {
    v18 = a2[1].callbacks;
    if (v18)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
  }
  v19 = a2->callbacks;
  if (v19)
  {
    get_local_endpoint = (uint64_t (*)(nw_protocol *))v19->get_local_endpoint;
    if (get_local_endpoint)
    {
      v21 = get_local_endpoint(a2);
      if (v17 != &nw_protocol_ref_counted_handle)
        goto LABEL_36;
      goto LABEL_221;
    }
  }
  __nwlog_obj();
  v62 = a2->identifier;
  if (!v62)
    v62 = (nw_protocol_identifier *)"invalid";
  *(_DWORD *)buf = 136446722;
  v157 = "__nw_protocol_get_local_endpoint";
  v158 = 2082;
  v159 = v62;
  v160 = 2048;
  v161 = a2;
  v63 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v154 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v63, type, &v154))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v64 = __nwlog_obj();
      v65 = type[0];
      if (!os_log_type_enabled(v64, type[0]))
        goto LABEL_218;
      v66 = a2->identifier;
      if (!v66)
        v66 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v66;
      v160 = 2048;
      v161 = a2;
      v67 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback";
LABEL_217:
      _os_log_impl(&dword_182FBE000, v64, v65, v67, buf, 0x20u);
      goto LABEL_218;
    }
    if (v154 == OS_LOG_TYPE_DEFAULT)
    {
      v64 = __nwlog_obj();
      v65 = type[0];
      if (!os_log_type_enabled(v64, type[0]))
        goto LABEL_218;
      v85 = a2->identifier;
      if (!v85)
        v85 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v85;
      v160 = 2048;
      v161 = a2;
      v67 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded";
      goto LABEL_217;
    }
    v75 = (char *)__nw_create_backtrace_string();
    v64 = __nwlog_obj();
    v65 = type[0];
    v76 = os_log_type_enabled(v64, type[0]);
    if (!v75)
    {
      if (!v76)
        goto LABEL_218;
      v87 = a2->identifier;
      if (!v87)
        v87 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v87;
      v160 = 2048;
      v161 = a2;
      v67 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace";
      goto LABEL_217;
    }
    if (v76)
    {
      v77 = a2->identifier;
      if (!v77)
        v77 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446978;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v77;
      v160 = 2048;
      v161 = a2;
      v162 = 2082;
      v163 = v75;
      _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v75);
  }
LABEL_218:
  if (v63)
    free(v63);
  v21 = 0;
  if (v17 != &nw_protocol_ref_counted_handle)
    goto LABEL_36;
LABEL_221:
  if (a2->handle != &nw_protocol_ref_counted_handle)
  {
    v23 = 0;
    goto LABEL_223;
  }
  v118 = a2[1].callbacks;
  if (v118)
  {
    v119 = (nw_protocol_callbacks *)((char *)v118 - 1);
    a2[1].callbacks = v119;
    if (!v119)
    {
      v120 = *(void (***)(_QWORD))a2[1].flow_id;
      if (v120)
      {
        *(_QWORD *)a2[1].flow_id = 0;
        v120[2](v120);
        _Block_release(v120);
      }
      if ((a2[1].flow_id[8] & 1) != 0)
      {
        v121 = *(const void **)a2[1].flow_id;
        if (v121)
          _Block_release(v121);
      }
      free(a2);
    }
  }
LABEL_36:
  v22 = a2->handle;
  v23 = v22 == &nw_protocol_ref_counted_handle;
  if (v22 == &nw_protocol_ref_counted_handle)
  {
    v24 = a2[1].callbacks;
    if (v24)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v24->add_input_handler + 1);
  }
LABEL_223:
  v88 = a2->callbacks;
  if (v88)
  {
    get_remote_endpoint = (uint64_t (*)(nw_protocol *))v88->get_remote_endpoint;
    if (get_remote_endpoint)
    {
      v55 = get_remote_endpoint(a2);
      if (!v23)
        goto LABEL_227;
      goto LABEL_226;
    }
  }
  __nwlog_obj();
  v128 = a2->identifier;
  if (!v128)
    v128 = (nw_protocol_identifier *)"invalid";
  *(_DWORD *)buf = 136446722;
  v157 = "__nw_protocol_get_remote_endpoint";
  v158 = 2082;
  v159 = v128;
  v160 = 2048;
  v161 = a2;
  v129 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v154 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v129, type, &v154))
    goto LABEL_344;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v130 = __nwlog_obj();
    v131 = type[0];
    if (!os_log_type_enabled(v130, type[0]))
      goto LABEL_344;
    v132 = a2->identifier;
    if (!v132)
      v132 = (nw_protocol_identifier *)"invalid";
    *(_DWORD *)buf = 136446722;
    v157 = "__nw_protocol_get_remote_endpoint";
    v158 = 2082;
    v159 = v132;
    v160 = 2048;
    v161 = a2;
    v133 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback";
LABEL_342:
    v150 = v130;
LABEL_343:
    _os_log_impl(&dword_182FBE000, v150, v131, v133, buf, 0x20u);
    goto LABEL_344;
  }
  if (v154 == OS_LOG_TYPE_DEFAULT)
  {
    v130 = __nwlog_obj();
    v131 = type[0];
    if (!os_log_type_enabled(v130, type[0]))
      goto LABEL_344;
    v149 = a2->identifier;
    if (!v149)
      v149 = (nw_protocol_identifier *)"invalid";
    *(_DWORD *)buf = 136446722;
    v157 = "__nw_protocol_get_remote_endpoint";
    v158 = 2082;
    v159 = v149;
    v160 = 2048;
    v161 = a2;
    v133 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded";
    goto LABEL_342;
  }
  v141 = (char *)__nw_create_backtrace_string();
  v142 = __nwlog_obj();
  v131 = type[0];
  log = v142;
  v143 = os_log_type_enabled(v142, type[0]);
  if (v141)
  {
    if (v143)
    {
      v144 = a2->identifier;
      if (!v144)
        v144 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446978;
      v157 = "__nw_protocol_get_remote_endpoint";
      v158 = 2082;
      v159 = v144;
      v160 = 2048;
      v161 = a2;
      v162 = 2082;
      v163 = v141;
      _os_log_impl(&dword_182FBE000, log, v131, "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v141);
  }
  else if (v143)
  {
    v151 = a2->identifier;
    if (!v151)
      v151 = (nw_protocol_identifier *)"invalid";
    *(_DWORD *)buf = 136446722;
    v157 = "__nw_protocol_get_remote_endpoint";
    v158 = 2082;
    v159 = v151;
    v160 = 2048;
    v161 = a2;
    v133 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace";
    v150 = log;
    goto LABEL_343;
  }
LABEL_344:
  if (v129)
    free(v129);
  v55 = 0;
  if (v23)
  {
LABEL_226:
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      v114 = a2[1].callbacks;
      if (v114)
      {
        v115 = (nw_protocol_callbacks *)((char *)v114 - 1);
        a2[1].callbacks = v115;
        if (!v115)
        {
          v116 = *(void (***)(_QWORD))a2[1].flow_id;
          if (v116)
          {
            *(_QWORD *)a2[1].flow_id = 0;
            v116[2](v116);
            _Block_release(v116);
          }
          if ((a2[1].flow_id[8] & 1) != 0)
          {
            v117 = *(const void **)a2[1].flow_id;
            if (v117)
              _Block_release(v117);
          }
          free(a2);
        }
      }
    }
  }
LABEL_227:
  if (nw_endpoint_get_address_family(v21) == 30)
    *(sockaddr *)&a1[2].callbacks = *(sockaddr *)&nw_endpoint_get_address(v21)->sa_data[6];
  if (nw_endpoint_get_address_family(v55) == 30)
    *(sockaddr *)&a1[2].handle = *(sockaddr *)&nw_endpoint_get_address(v55)->sa_data[6];
  *(_OWORD *)type = *(_OWORD *)a1->flow_id;
  LODWORD(a1[3].default_input_handler) = net_flowhash((int *)type, 0x10u, flowhash_seed) & 0xFFFF0F00;
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v157 = "__nw_protocol_get_path";
    v134 = (char *)_os_log_send_and_compose_impl();
    v154 = OS_LOG_TYPE_ERROR;
    v153 = 0;
    if (!__nwlog_fault(v134, &v154, &v153))
      goto LABEL_369;
    if (v154 == OS_LOG_TYPE_FAULT)
    {
      v135 = __nwlog_obj();
      v136 = v154;
      if (!os_log_type_enabled(v135, v154))
        goto LABEL_369;
      *(_DWORD *)buf = 136446210;
      v157 = "__nw_protocol_get_path";
      v137 = "%{public}s called with null protocol";
    }
    else if (v153)
    {
      v145 = (char *)__nw_create_backtrace_string();
      v135 = __nwlog_obj();
      v136 = v154;
      v146 = os_log_type_enabled(v135, v154);
      if (v145)
      {
        if (v146)
        {
          *(_DWORD *)buf = 136446466;
          v157 = "__nw_protocol_get_path";
          v158 = 2082;
          v159 = (nw_protocol_identifier *)v145;
          _os_log_impl(&dword_182FBE000, v135, v136, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v145);
        goto LABEL_369;
      }
      if (!v146)
      {
LABEL_369:
        if (v134)
          free(v134);
        goto LABEL_241;
      }
      *(_DWORD *)buf = 136446210;
      v157 = "__nw_protocol_get_path";
      v137 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v135 = __nwlog_obj();
      v136 = v154;
      if (!os_log_type_enabled(v135, v154))
        goto LABEL_369;
      *(_DWORD *)buf = 136446210;
      v157 = "__nw_protocol_get_path";
      v137 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v135, v136, v137, buf, 0xCu);
    goto LABEL_369;
  }
  v91 = default_input_handler->handle;
  if (v91 == &nw_protocol_ref_counted_handle)
  {
    v92 = default_input_handler[1].callbacks;
    if (v92)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v92->add_input_handler + 1);
  }
  v93 = default_input_handler->callbacks;
  if (!v93 || (get_path = (uint64_t (*)(nw_protocol *))v93->get_path) == 0)
  {
    __nwlog_obj();
    name = default_input_handler->identifier->name;
    *(_DWORD *)buf = 136446722;
    v157 = "__nw_protocol_get_path";
    if (!name)
      name = "invalid";
    v158 = 2082;
    v159 = (nw_protocol_identifier *)name;
    v160 = 2048;
    v161 = default_input_handler;
    v123 = (char *)_os_log_send_and_compose_impl();
    v154 = OS_LOG_TYPE_ERROR;
    v153 = 0;
    if (__nwlog_fault(v123, &v154, &v153))
    {
      if (v154 == OS_LOG_TYPE_FAULT)
      {
        v124 = __nwlog_obj();
        v125 = v154;
        if (!os_log_type_enabled(v124, v154))
          goto LABEL_334;
        v126 = default_input_handler->identifier->name;
        if (!v126)
          v126 = "invalid";
        *(_DWORD *)buf = 136446722;
        v157 = "__nw_protocol_get_path";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v126;
        v160 = 2048;
        v161 = default_input_handler;
        v127 = "%{public}s protocol %{public}s (%p) has invalid get_path callback";
LABEL_333:
        _os_log_impl(&dword_182FBE000, v124, v125, v127, buf, 0x20u);
        goto LABEL_334;
      }
      if (!v153)
      {
        v124 = __nwlog_obj();
        v125 = v154;
        if (!os_log_type_enabled(v124, v154))
          goto LABEL_334;
        v147 = default_input_handler->identifier->name;
        if (!v147)
          v147 = "invalid";
        *(_DWORD *)buf = 136446722;
        v157 = "__nw_protocol_get_path";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v147;
        v160 = 2048;
        v161 = default_input_handler;
        v127 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, backtrace limit exceeded";
        goto LABEL_333;
      }
      v138 = (char *)__nw_create_backtrace_string();
      v124 = __nwlog_obj();
      v125 = v154;
      v139 = os_log_type_enabled(v124, v154);
      if (!v138)
      {
        if (!v139)
          goto LABEL_334;
        v148 = default_input_handler->identifier->name;
        if (!v148)
          v148 = "invalid";
        *(_DWORD *)buf = 136446722;
        v157 = "__nw_protocol_get_path";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v148;
        v160 = 2048;
        v161 = default_input_handler;
        v127 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, no backtrace";
        goto LABEL_333;
      }
      if (v139)
      {
        v140 = default_input_handler->identifier->name;
        if (!v140)
          v140 = "invalid";
        *(_DWORD *)buf = 136446978;
        v157 = "__nw_protocol_get_path";
        v158 = 2082;
        v159 = (nw_protocol_identifier *)v140;
        v160 = 2048;
        v161 = default_input_handler;
        v162 = 2082;
        v163 = v138;
        _os_log_impl(&dword_182FBE000, v124, v125, "%{public}s protocol %{public}s (%p) has invalid get_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v138);
    }
LABEL_334:
    if (v123)
      free(v123);
    v95 = 0;
    if (v91 != &nw_protocol_ref_counted_handle)
      goto LABEL_239;
    goto LABEL_238;
  }
  v95 = (void *)get_path(default_input_handler);
  if (v91 == &nw_protocol_ref_counted_handle)
  {
LABEL_238:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v110 = default_input_handler[1].callbacks;
      if (v110)
      {
        v111 = (nw_protocol_callbacks *)((char *)v110 - 1);
        default_input_handler[1].callbacks = v111;
        if (!v111)
        {
          v112 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v112)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v112[2](v112);
            _Block_release(v112);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v113 = *(const void **)default_input_handler[1].flow_id;
            if (v113)
              _Block_release(v113);
          }
          free(default_input_handler);
        }
      }
    }
  }
LABEL_239:
  if (v95)
  {
    LODWORD(a1[3].output_handler_context) = nw_path_get_maximum_packet_size(v95);
    LODWORD(a1[3].handle) = nw_path_get_mtu(v95);
  }
LABEL_241:
  v96 = nw_parameters_copy_protocol_options_legacy(v16, a1);
  if (v96)
  {
    v97 = v96;
    v98 = v97;
    v99 = 0;
    HIBYTE(a1[3].output_handler_context) = 0;
    v100 = (char *)&a1[3].output_handler_context + 7;
    v101 = 84;
    while (1)
    {
      v102 = v97[v99 + 48];
      v100[v99] = v102;
      if (!v102)
        break;
      --v101;
      ++v99;
      if (v101 <= 1)
      {
        v100[v99] = 0;
        break;
      }
    }

    hop_limit = nw_ip_options_get_hop_limit(v98);
    if (hop_limit)
      v104 = hop_limit;
    else
      v104 = 64;
    BYTE5(a1[3].output_handler_context) = v104;
    if (nw_ip_options_get_use_minimum_mtu(v98))
      v105 = 2;
    else
      v105 = 0;
    BYTE6(a1[3].output_handler_context) = BYTE6(a1[3].output_handler_context) & 0xFD | v105;
    if (nw_ip_options_get_calculate_receive_time(v98))
      v106 = 4;
    else
      v106 = 0;
    BYTE6(a1[3].output_handler_context) = BYTE6(a1[3].output_handler_context) & 0xFB | v106;
    if (nw_ip_options_get_receive_hop_limit(v98))
      v107 = 16;
    else
      v107 = 0;
    BYTE6(a1[3].output_handler_context) = BYTE6(a1[3].output_handler_context) & 0xEF | v107;
    os_release(v98);
  }
  else
  {
    BYTE5(a1[3].output_handler_context) = 64;
  }
  v108 = 1;
  nw_protocol_ip_register_segmentation_offload_notification(a1, 1);
  return v108;
}

uint64_t nw_protocol_ipv6_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  nw_protocol_identifier *identifier;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv6_replace_input_handler";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_74;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v13)
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv6_replace_input_handler";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_74;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_protocol_ipv6_replace_input_handler";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_75;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_75;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v11 = "%{public}s called with null protocol";
    goto LABEL_74;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv6_replace_input_handler";
        v11 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_74;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v15)
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv6_replace_input_handler";
        v11 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_74;
      }
      if (!v15)
        goto LABEL_52;
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v24 = 2082;
      v25 = v14;
      v16 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_75;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v11 = "%{public}s called with null ipv6";
LABEL_74:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_75;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv6_replace_input_handler";
        v11 = "%{public}s called with null old_input_protocol, backtrace limit exceeded";
        goto LABEL_74;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v17)
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv6_replace_input_handler";
        v11 = "%{public}s called with null old_input_protocol, no backtrace";
        goto LABEL_74;
      }
      if (!v17)
        goto LABEL_52;
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v24 = 2082;
      v25 = v14;
      v16 = "%{public}s called with null old_input_protocol, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_75;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v11 = "%{public}s called with null old_input_protocol";
    goto LABEL_74;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v11 = "%{public}s called with null new_input_protocol";
      goto LABEL_74;
    }
    if (!v20)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v11 = "%{public}s called with null new_input_protocol, backtrace limit exceeded";
      goto LABEL_74;
    }
    v14 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v18 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v18)
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v11 = "%{public}s called with null new_input_protocol, no backtrace";
      goto LABEL_74;
    }
    if (!v18)
      goto LABEL_52;
    *(_DWORD *)buf = 136446466;
    v23 = "nw_protocol_ipv6_replace_input_handler";
    v24 = 2082;
    v25 = v14;
    v16 = "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s";
LABEL_51:
    _os_log_impl(&dword_182FBE000, v9, v10, v16, buf, 0x16u);
    goto LABEL_52;
  }
  if (a3->identifier)
    identifier = a3->identifier;
  else
    identifier = (nw_protocol_identifier *)"invalid";
  if (strncmp(identifier->name, "quic", 4uLL))
    return nw_protocol_common_replace_input_handler((uint64_t)a1, a2, (uint64_t)a3);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_protocol_ipv6_replace_input_handler";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v8, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v11 = "%{public}s Attempt to add quic to ip";
      goto LABEL_74;
    }
    if (!v20)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v11 = "%{public}s Attempt to add quic to ip, backtrace limit exceeded";
      goto LABEL_74;
    }
    v14 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v19 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v19)
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v11 = "%{public}s Attempt to add quic to ip, no backtrace";
      goto LABEL_74;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_ipv6_replace_input_handler";
      v24 = 2082;
      v25 = v14;
      v16 = "%{public}s Attempt to add quic to ip, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
LABEL_52:
    free(v14);
    if (!v8)
      return 0;
    goto LABEL_76;
  }
LABEL_75:
  if (v8)
LABEL_76:
    free(v8);
  return 0;
}

uint64_t nw_protocol_ipv6_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  void *handle;
  nw_protocol **p_output_handler;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v9;
  void (**v10)(_QWORD);
  const void *v11;
  nw_protocol *default_input_handler;
  nw_protocol *output_handler;
  nw_protocol_callbacks *v15;
  void (*remove_input_handler)(nw_protocol *, nw_protocol *, uint64_t);
  void *v17;
  nw_protocol_callbacks *v18;
  nw_protocol_callbacks *v19;
  nw_protocol_callbacks *v20;
  void (**v21)(_QWORD);
  const void *v22;
  nw_protocol_callbacks *v23;
  _QWORD *output_handler_context;
  uint64_t v25;
  _QWORD *v26;
  nw_protocol *v27;
  nw_protocol_identifier *identifier;
  nw_protocol *v29;
  nw_protocol *v30;
  nw_protocol_identifier *v31;
  nw_protocol *v32;
  nw_protocol_callbacks *v33;
  nw_protocol_callbacks *v34;
  void (**v35)(_QWORD);
  const void *v36;
  nw_protocol_callbacks *v37;
  nw_protocol_callbacks *v38;
  void (**v39)(_QWORD);
  const void *v40;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  char *v44;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  char *backtrace_string;
  _BOOL4 v51;
  const char *v52;
  _BOOL4 v53;
  char *v54;
  _BOOL4 v55;
  char v56;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  char *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv6_remove_input_handler";
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (!__nwlog_fault(v44, &type, &v56))
      goto LABEL_117;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v56)
      {
        v41 = __nwlog_obj();
        v42 = type;
        if (!os_log_type_enabled(v41, type))
          goto LABEL_117;
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_ipv6_remove_input_handler";
        v43 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_116;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v41 = __nwlog_obj();
      v42 = type;
      v51 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v51)
          goto LABEL_117;
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_ipv6_remove_input_handler";
        v43 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_116;
      }
      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        v59 = "nw_protocol_ipv6_remove_input_handler";
        v60 = 2082;
        v61 = backtrace_string;
        v52 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_99:
        _os_log_impl(&dword_182FBE000, v41, v42, v52, buf, 0x16u);
      }
LABEL_100:
      free(backtrace_string);
      goto LABEL_117;
    }
    v41 = __nwlog_obj();
    v42 = type;
    if (!os_log_type_enabled(v41, type))
      goto LABEL_117;
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv6_remove_input_handler";
    v43 = "%{public}s called with null protocol";
LABEL_116:
    _os_log_impl(&dword_182FBE000, v41, v42, v43, buf, 0xCu);
LABEL_117:
    if (v44)
      free(v44);
    return 0;
  }
  handle = a1->handle;
  if (handle == &nw_protocol_ref_counted_handle)
    p_output_handler = &a1[1].output_handler;
  else
    p_output_handler = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv6_remove_input_handler";
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (!__nwlog_fault(v44, &type, &v56))
      goto LABEL_117;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v41 = __nwlog_obj();
      v42 = type;
      if (!os_log_type_enabled(v41, type))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v59 = "nw_protocol_ipv6_remove_input_handler";
      v43 = "%{public}s called with null ipv6";
      goto LABEL_116;
    }
    if (!v56)
    {
      v41 = __nwlog_obj();
      v42 = type;
      if (!os_log_type_enabled(v41, type))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v59 = "nw_protocol_ipv6_remove_input_handler";
      v43 = "%{public}s called with null ipv6, backtrace limit exceeded";
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v41 = __nwlog_obj();
    v42 = type;
    v53 = os_log_type_enabled(v41, type);
    if (backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446466;
        v59 = "nw_protocol_ipv6_remove_input_handler";
        v60 = 2082;
        v61 = backtrace_string;
        v52 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
        goto LABEL_99;
      }
      goto LABEL_100;
    }
    if (!v53)
      goto LABEL_117;
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv6_remove_input_handler";
    v43 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_116;
  }
  if (a2)
  {
    if (a2->output_handler == a1)
    {
      callbacks = a1[1].callbacks;
      if (callbacks)
      {
        v9 = (nw_protocol_callbacks *)((char *)callbacks - 1);
        a1[1].callbacks = v9;
        if (!v9)
        {
          v10 = *(void (***)(_QWORD))a1[1].flow_id;
          if (v10)
          {
            *(_QWORD *)a1[1].flow_id = 0;
            v10[2](v10);
            _Block_release(v10);
          }
          if ((a1[1].flow_id[8] & 1) != 0)
          {
            v11 = *(const void **)a1[1].flow_id;
            if (v11)
              _Block_release(v11);
          }
          free(a1);
        }
      }
      a2->output_handler = 0;
    }
    goto LABEL_18;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v59 = "__nw_protocol_get_output_handler";
  v46 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v56 = 0;
  if (__nwlog_fault(v46, &type, &v56))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (!os_log_type_enabled(v47, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      v59 = "__nw_protocol_get_output_handler";
      v49 = "%{public}s called with null protocol";
      goto LABEL_121;
    }
    if (!v56)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (!os_log_type_enabled(v47, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      v59 = "__nw_protocol_get_output_handler";
      v49 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_121;
    }
    v54 = (char *)__nw_create_backtrace_string();
    v47 = __nwlog_obj();
    v48 = type;
    v55 = os_log_type_enabled(v47, type);
    if (v54)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446466;
        v59 = "__nw_protocol_get_output_handler";
        v60 = 2082;
        v61 = v54;
        _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v54);
      goto LABEL_122;
    }
    if (v55)
    {
      *(_DWORD *)buf = 136446210;
      v59 = "__nw_protocol_get_output_handler";
      v49 = "%{public}s called with null protocol, no backtrace";
LABEL_121:
      _os_log_impl(&dword_182FBE000, v47, v48, v49, buf, 0xCu);
    }
  }
LABEL_122:
  if (v46)
    free(v46);
LABEL_18:
  if (a1->default_input_handler != a2)
    return 0;
  nw_protocol_ip_register_segmentation_offload_notification(a1, 0);
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v19 = default_input_handler[1].callbacks;
      if (v19)
      {
        v20 = (nw_protocol_callbacks *)((char *)v19 - 1);
        default_input_handler[1].callbacks = v20;
        if (!v20)
        {
          v21 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v21)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v21[2](v21);
            _Block_release(v21);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v22 = *(const void **)default_input_handler[1].flow_id;
            if (v22)
              _Block_release(v22);
          }
          free(default_input_handler);
        }
      }
    }
    a1->default_input_handler = 0;
  }
  output_handler = a1->output_handler;
  if (output_handler)
  {
    v15 = output_handler->callbacks;
    if (v15)
    {
      remove_input_handler = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v15->remove_input_handler;
      if (remove_input_handler)
      {
        v17 = output_handler->handle;
        if (v17 == &nw_protocol_ref_counted_handle)
        {
          v18 = output_handler[1].callbacks;
          if (v18)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
        }
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v23 = a1[1].callbacks;
          if (v23)
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v23->add_input_handler + 1);
          remove_input_handler(output_handler, a1, a3);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v33 = a1[1].callbacks;
            if (v33)
            {
              v34 = (nw_protocol_callbacks *)((char *)v33 - 1);
              a1[1].callbacks = v34;
              if (!v34)
              {
                v35 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v35)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v35[2](v35);
                  _Block_release(v35);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v36 = *(const void **)a1[1].flow_id;
                  if (v36)
                    _Block_release(v36);
                }
                free(a1);
              }
            }
          }
        }
        else
        {
          remove_input_handler(output_handler, a1, a3);
        }
        if (v17 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v37 = output_handler[1].callbacks;
          if (v37)
          {
            v38 = (nw_protocol_callbacks *)((char *)v37 - 1);
            output_handler[1].callbacks = v38;
            if (!v38)
            {
              v39 = *(void (***)(_QWORD))output_handler[1].flow_id;
              if (v39)
              {
                *(_QWORD *)output_handler[1].flow_id = 0;
                v39[2](v39);
                _Block_release(v39);
              }
              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                v40 = *(const void **)output_handler[1].flow_id;
                if (v40)
                  _Block_release(v40);
              }
              free(output_handler);
            }
          }
        }
      }
    }
  }
  if ((_DWORD)a3)
  {
    while (1)
    {
      output_handler_context = a1[2].output_handler_context;
      if (!output_handler_context)
        break;
      v25 = output_handler_context[4];
      v26 = (_QWORD *)output_handler_context[5];
      if (v25)
      {
        *(_QWORD *)(v25 + 40) = v26;
        v26 = (_QWORD *)output_handler_context[5];
      }
      else
      {
        *(_QWORD *)a1[3].flow_id = v26;
      }
      *v26 = v25;
      output_handler_context[4] = 0;
      output_handler_context[5] = 0;
      nw_frame_finalize((uint64_t)output_handler_context);
    }
    while (1)
    {
      v27 = p_output_handler[13];
      if (!v27)
        break;
      identifier = v27->identifier;
      v29 = (nw_protocol *)v27->callbacks;
      if (identifier)
      {
        *(_QWORD *)&identifier->name[24] = v29;
        v29 = (nw_protocol *)v27->callbacks;
      }
      else
      {
        p_output_handler[14] = v29;
      }
      *(_QWORD *)v29->flow_id = identifier;
      v27->identifier = 0;
      v27->callbacks = 0;
      nw_frame_free_buffer((uint64_t)v27);
      os_release(v27);
    }
    while (1)
    {
      v30 = p_output_handler[15];
      if (!v30)
        break;
      v31 = v30->identifier;
      v32 = (nw_protocol *)v30->callbacks;
      if (v31)
      {
        *(_QWORD *)&v31->name[24] = v32;
        v32 = (nw_protocol *)v30->callbacks;
      }
      else
      {
        p_output_handler[16] = v32;
      }
      *(_QWORD *)v32->flow_id = v31;
      v30->identifier = 0;
      v30->callbacks = 0;
      nw_frame_free_buffer((uint64_t)v30);
      os_release(v30);
    }
    nw_protocol_destroy((uint64_t)p_output_handler, 0);
  }
  return 1;
}

uint64_t nw_protocol_ipv6_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  void *handle;
  nw_protocol **v8;
  int v9;
  int v10;
  nw_protocol *output_handler;
  nw_frame_array_s *v12;
  void *v13;
  nw_protocol_callbacks *callbacks;
  void *v15;
  nw_protocol_callbacks *v16;
  nw_protocol_callbacks *v17;
  uint64_t (*get_input_frames)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  int v19;
  nw_frame *tqh_first;
  nw_frame *v21;
  char v22;
  int v23;
  BOOL v24;
  int v25;
  nw_protocol *v26;
  void *v27;
  nw_protocol_callbacks *v28;
  void *v29;
  nw_protocol_callbacks *v30;
  nw_protocol_callbacks *v31;
  uint64_t (*v32)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, _QWORD *);
  int v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  nw_protocol_callbacks *v40;
  nw_protocol_callbacks *v41;
  void (**v42)(_QWORD);
  const void *v43;
  nw_protocol_callbacks *v44;
  nw_protocol_callbacks *v45;
  void (**v46)(_QWORD);
  const void *v47;
  const char *v48;
  const char *v49;
  os_log_type_t v50;
  const char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  char *v55;
  uint64_t v56;
  os_log_type_t v57;
  NSObject *v58;
  os_log_type_t v59;
  const char *v60;
  char *v61;
  _BOOL4 v62;
  const char *v63;
  NSObject *v64;
  int v65;
  const char *v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  _BOOL4 v70;
  os_log_type_t v71;
  const char *v72;
  const char *v73;
  uint64_t v74;
  os_log_type_t v75;
  nw_frame **v76;
  int v77;
  int v78;
  NSObject *v79;
  nw_protocol_callbacks *v80;
  nw_protocol_callbacks *v81;
  void (**v82)(_QWORD);
  const void *v83;
  nw_protocol_callbacks *v84;
  nw_protocol_callbacks *v85;
  void (**v86)(_QWORD);
  const void *v87;
  const char *name;
  const char *v89;
  NSObject *v90;
  os_log_type_t v91;
  const char *v92;
  NSObject *v93;
  os_log_type_t v94;
  const char *v95;
  const char *v96;
  NSObject *v97;
  os_log_type_t v98;
  uint32_t v99;
  char *v100;
  _BOOL4 v101;
  const char *v102;
  NSObject *v103;
  os_log_type_t v104;
  const char *v105;
  uint32_t v106;
  _BOOL4 v107;
  NSObject *v108;
  os_log_type_t v109;
  const char *v110;
  const char *v111;
  NSObject *v112;
  os_log_type_t v113;
  char *v114;
  NSObject *v115;
  os_log_type_t v116;
  const char *v117;
  char *v118;
  _BOOL4 v119;
  uint64_t v120;
  NSObject *v122;
  os_log_type_t v123;
  const char *v124;
  char *v125;
  NSObject *v127;
  char *backtrace_string;
  _BOOL4 v129;
  const char *v130;
  _BOOL4 v131;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  os_log_type_t type[8];
  os_log_type_t typea;
  os_log_type_t typeb[8];
  os_log_type_t typec[8];
  os_log_type_t typed[8];
  os_log_type_t typee;
  os_log_type_t typef;
  os_log_type_t typeg[8];
  os_log_type_t typeh[8];
  char *v144;
  char *v145;
  char *v146;
  nw_protocol **p_output_handler;
  unsigned int v149;
  unsigned int v150;
  _QWORD v152[2];
  uint64_t (*v153)(uint64_t, uint64_t);
  void *v154;
  _QWORD *v155;
  nw_protocol **v156;
  _QWORD v157[2];
  uint64_t (*v158)(_QWORD *);
  void *v159;
  uint64_t *v160;
  os_log_type_t *v161;
  _BYTE *v162;
  nw_protocol **v163;
  _QWORD *v164;
  uint64_t *v165;
  uint64_t v166;
  uint64_t *v167;
  uint64_t v168;
  int v169;
  _QWORD v170[2];
  char v171;
  _QWORD v172[2];
  uint64_t (*v173)(_QWORD *);
  void *v174;
  _QWORD *v175;
  _QWORD *v176;
  uint64_t *v177;
  os_log_type_t *v178;
  nw_frame_array_s *v179;
  nw_protocol **v180;
  uint64_t *v181;
  _QWORD v182[3];
  char v183;
  uint64_t v184;
  nw_frame **v185;
  _QWORD v186[3];
  char v187;
  os_log_type_t v188[8];
  os_log_type_t *v189;
  uint64_t v190;
  int v191;
  uint64_t v192;
  uint64_t *v193;
  uint64_t v194;
  int v195;
  char v196;
  os_log_type_t v197;
  _BYTE buf[24];
  const char *v199;
  __int16 v200;
  char *v201;
  __int16 v202;
  int v203;
  __int16 v204;
  const char *v205;
  uint64_t v206;

  v206 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
    v125 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v125, &v192, v188))
      goto LABEL_245;
    if (v192 == 17)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
        v124 = "%{public}s called with null protocol";
LABEL_244:
        _os_log_impl(&dword_182FBE000, v122, v123, v124, buf, 0xCu);
      }
LABEL_245:
      if (v125)
        free(v125);
      return 0;
    }
    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
        v124 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v122 = __nwlog_obj();
    v123 = v192;
    v129 = os_log_type_enabled(v122, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v129)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
        v124 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v129)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v130 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_234:
      _os_log_impl(&dword_182FBE000, v122, v123, v130, buf, 0x16u);
    }
LABEL_235:
    free(backtrace_string);
    goto LABEL_245;
  }
  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle)
    v8 = &a1[1].output_handler;
  else
    v8 = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
    v125 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v125, &v192, v188))
      goto LABEL_245;
    if (v192 == 17)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
        v124 = "%{public}s called with null ipv6";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
        v124 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v122 = __nwlog_obj();
    v123 = v192;
    v131 = os_log_type_enabled(v122, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v131)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
        v124 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v131)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v130 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_234;
    }
    goto LABEL_235;
  }
  if (a3 >= 0xFFFFFFD8)
    v9 = -1;
  else
    v9 = a3 + 40;
  v10 = a4 + 40;
  if (a4 >= 0xFFFFFFD8)
    v10 = -1;
  v149 = v10;
  v150 = v9;
  v192 = 0;
  v193 = &v192;
  v195 = 0;
  v194 = 0x2000000000;
  v146 = (char *)&a1[3].output_handler_context + 7;
  output_handler = a1->output_handler;
  if (!output_handler)
  {
LABEL_195:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
    v114 = (char *)_os_log_send_and_compose_impl();
    v188[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v186[0]) = 0;
    if (!__nwlog_fault(v114, v188, v186))
      goto LABEL_209;
    if (v188[0] == OS_LOG_TYPE_FAULT)
    {
      v115 = __nwlog_obj();
      v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0]))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v117 = "%{public}s called with null protocol";
    }
    else if (LOBYTE(v186[0]))
    {
      v118 = (char *)__nw_create_backtrace_string();
      v115 = __nwlog_obj();
      v116 = v188[0];
      v119 = os_log_type_enabled(v115, v188[0]);
      if (v118)
      {
        if (v119)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v118;
          _os_log_impl(&dword_182FBE000, v115, v116, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v118);
LABEL_209:
        if (v114)
          free(v114);
        *((_DWORD *)v193 + 6) = 0;
LABEL_212:
        if ((BYTE6(a1[3].output_handler_context) & 1) == 0)
        {
          if (gLogDatapath)
          {
            v127 = __nwlog_obj();
            if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v146;
              *(_WORD *)&buf[22] = 2080;
              v199 = " ";
              v200 = 2048;
              v201 = (char *)p_output_handler;
              _os_log_impl(&dword_182FBE000, v127, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p No IPv6 input frames", buf, 0x2Au);
            }
          }
        }
        goto LABEL_214;
      }
      if (!v119)
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v117 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v115 = __nwlog_obj();
      v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0]))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v117 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v115, v116, v117, buf, 0xCu);
    goto LABEL_209;
  }
  v12 = a6;
  while (2)
  {
    v13 = output_handler->handle;
    if (v13 == &nw_protocol_ref_counted_handle)
    {
      callbacks = output_handler[1].callbacks;
      if (callbacks)
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
    v15 = a1->handle;
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      v16 = a1[1].callbacks;
      if (v16)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v16->add_input_handler + 1);
    }
    if (!v12)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v96 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      v145 = (char *)v96;
      if (!__nwlog_fault(v96, v188, v186))
        goto LABEL_186;
      if (v188[0] == OS_LOG_TYPE_FAULT)
      {
        v97 = __nwlog_obj();
        v98 = v188[0];
        *(_QWORD *)typed = v97;
        if (!os_log_type_enabled(v97, v188[0]))
          goto LABEL_186;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        v93 = *(NSObject **)typed;
        v94 = v98;
        v95 = "%{public}s called with null return_array";
        v99 = 12;
        goto LABEL_185;
      }
      if (LOBYTE(v186[0]))
      {
        v100 = (char *)__nw_create_backtrace_string();
        logb = __nwlog_obj();
        typef = v188[0];
        v107 = os_log_type_enabled(logb, v188[0]);
        if (v100)
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v100;
            v103 = logb;
            v104 = typef;
            v105 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
            v106 = 22;
LABEL_174:
            _os_log_impl(&dword_182FBE000, v103, v104, v105, buf, v106);
          }
LABEL_175:
          free(v100);
          goto LABEL_186;
        }
        if (v107)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v93 = logb;
          v94 = typef;
          v95 = "%{public}s called with null return_array, no backtrace";
          v99 = 12;
          goto LABEL_185;
        }
      }
      else
      {
        v112 = __nwlog_obj();
        v113 = v188[0];
        *(_QWORD *)typeh = v112;
        if (os_log_type_enabled(v112, v188[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v93 = *(NSObject **)typeh;
          v94 = v113;
          v95 = "%{public}s called with null return_array, backtrace limit exceeded";
          v99 = 12;
          goto LABEL_185;
        }
      }
LABEL_186:
      if (v145)
        free(v145);
      v19 = 0;
      if (v15 != &nw_protocol_ref_counted_handle)
        goto LABEL_26;
      goto LABEL_25;
    }
    v17 = output_handler->callbacks;
    if (!v17
      || (get_input_frames = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v17->get_input_frames) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      name = output_handler->identifier->name;
      if (!name)
        name = "invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = name;
      *(_WORD *)&buf[22] = 2048;
      v199 = (const char *)output_handler;
      v89 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      v145 = (char *)v89;
      if (__nwlog_fault(v89, v188, v186))
      {
        if (v188[0] == OS_LOG_TYPE_FAULT)
        {
          v90 = __nwlog_obj();
          v91 = v188[0];
          *(_QWORD *)typec = v90;
          if (!os_log_type_enabled(v90, v188[0]))
            goto LABEL_186;
          v92 = output_handler->identifier->name;
          if (!v92)
            v92 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v92;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v93 = *(NSObject **)typec;
          v94 = v91;
          v95 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_184:
          v99 = 32;
LABEL_185:
          _os_log_impl(&dword_182FBE000, v93, v94, v95, buf, v99);
          goto LABEL_186;
        }
        if (!LOBYTE(v186[0]))
        {
          v108 = __nwlog_obj();
          v109 = v188[0];
          *(_QWORD *)typeg = v108;
          if (!os_log_type_enabled(v108, v188[0]))
            goto LABEL_186;
          v110 = output_handler->identifier->name;
          if (!v110)
            v110 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v110;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v93 = *(NSObject **)typeg;
          v94 = v109;
          v95 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
          goto LABEL_184;
        }
        v100 = (char *)__nw_create_backtrace_string();
        loga = __nwlog_obj();
        typee = v188[0];
        v101 = os_log_type_enabled(loga, v188[0]);
        if (!v100)
        {
          if (!v101)
            goto LABEL_186;
          v111 = output_handler->identifier->name;
          if (!v111)
            v111 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v111;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v93 = loga;
          v94 = typee;
          v95 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
          goto LABEL_184;
        }
        if (v101)
        {
          v102 = output_handler->identifier->name;
          if (!v102)
            v102 = "invalid";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v102;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v200 = 2082;
          v201 = v100;
          v103 = loga;
          v104 = typee;
          v105 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s";
          v106 = 42;
          goto LABEL_174;
        }
        goto LABEL_175;
      }
      goto LABEL_186;
    }
    v19 = get_input_frames(output_handler, a1, v150, v149, a5, v12);
    if (v15 == &nw_protocol_ref_counted_handle)
    {
LABEL_25:
      if (a1->handle == &nw_protocol_ref_counted_handle)
      {
        v84 = a1[1].callbacks;
        if (v84)
        {
          v85 = (nw_protocol_callbacks *)((char *)v84 - 1);
          a1[1].callbacks = v85;
          if (!v85)
          {
            v86 = *(void (***)(_QWORD))a1[1].flow_id;
            if (v86)
            {
              *(_QWORD *)a1[1].flow_id = 0;
              v86[2](v86);
              _Block_release(v86);
            }
            if ((a1[1].flow_id[8] & 1) != 0)
            {
              v87 = *(const void **)a1[1].flow_id;
              if (v87)
                _Block_release(v87);
            }
            free(a1);
          }
        }
      }
    }
LABEL_26:
    if (v13 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v80 = output_handler[1].callbacks;
      if (v80)
      {
        v81 = (nw_protocol_callbacks *)((char *)v80 - 1);
        output_handler[1].callbacks = v81;
        if (!v81)
        {
          v82 = *(void (***)(_QWORD))output_handler[1].flow_id;
          if (v82)
          {
            *(_QWORD *)output_handler[1].flow_id = 0;
            v82[2](v82);
            _Block_release(v82);
          }
          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            v83 = *(const void **)output_handler[1].flow_id;
            if (v83)
              _Block_release(v83);
          }
          free(output_handler);
        }
      }
    }
    *((_DWORD *)v193 + 6) = v19;
    if (!v19)
      goto LABEL_212;
    *(_QWORD *)v188 = 0;
    v189 = v188;
    v191 = 0;
    v190 = 0x2000000000;
    v186[0] = 0;
    v186[1] = v186;
    v186[2] = 0x2000000000;
    v187 = 0;
    v182[0] = 0;
    v182[1] = v182;
    v182[2] = 0x2000000000;
    v183 = 0;
    v184 = 0;
    v185 = (nw_frame **)&v184;
    v172[0] = MEMORY[0x1E0C809B0];
    v172[1] = 0x40000000;
    v173 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_ipv6_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    v174 = &unk_1E14AC6D0;
    v175 = v186;
    v176 = v182;
    v179 = v12;
    v180 = v8;
    v181 = &v184;
    v177 = &v192;
    v178 = v188;
    tqh_first = v12->tqh_first;
    do
    {
      if (!tqh_first)
        break;
      v21 = (nw_frame *)*((_QWORD *)tqh_first + 4);
      v22 = v173(v172);
      tqh_first = v21;
    }
    while ((v22 & 1) != 0);
    v171 = 0;
    do
    {
      v25 = nw_protocol_ipv6_process_reassembly((uint64_t)v8, 0, (uint64_t)&v184, 0, &v171);
      *((_DWORD *)v193 + 6) += v25;
      if (!v171)
        break;
      v170[0] = 0;
      v170[1] = v170;
      v166 = 0;
      v167 = &v166;
      v169 = 0;
      v168 = 0x2000000000;
      v26 = a1->output_handler;
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        v55 = (char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        if (!__nwlog_fault(v55, &v197, &v196))
          goto LABEL_127;
        if (v197 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = gLogObj;
          v57 = v197;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            v58 = v56;
            v59 = v57;
            v60 = "%{public}s called with null protocol";
            goto LABEL_126;
          }
          goto LABEL_127;
        }
        if (v196)
        {
          v67 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v68 = gLogObj;
          v69 = v197;
          v70 = os_log_type_enabled((os_log_t)gLogObj, v197);
          if (v67)
          {
            if (v70)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v67;
              _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v67);
            goto LABEL_127;
          }
          if (!v70)
          {
LABEL_127:
            if (v55)
              free(v55);
            v33 = 0;
            goto LABEL_52;
          }
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = v68;
          v59 = v69;
          v60 = "%{public}s called with null protocol, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v74 = gLogObj;
          v75 = v197;
          if (!os_log_type_enabled((os_log_t)gLogObj, v197))
            goto LABEL_127;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = v74;
          v59 = v75;
          v60 = "%{public}s called with null protocol, backtrace limit exceeded";
        }
LABEL_126:
        _os_log_impl(&dword_182FBE000, v58, v59, v60, buf, 0xCu);
        goto LABEL_127;
      }
      v27 = v26->handle;
      if (v27 == &nw_protocol_ref_counted_handle)
      {
        v28 = v26[1].callbacks;
        if (v28)
          v26[1].callbacks = (nw_protocol_callbacks *)((char *)&v28->add_input_handler + 1);
      }
      v29 = a1->handle;
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        v30 = a1[1].callbacks;
        if (v30)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v30->add_input_handler + 1);
      }
      v31 = v26->callbacks;
      if (!v31
        || (v32 = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, _QWORD *))v31->get_input_frames) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v48 = v26->identifier->name;
        if (!v48)
          v48 = "invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v48;
        *(_WORD *)&buf[22] = 2048;
        v199 = (const char *)v26;
        v49 = (const char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        v144 = (char *)v49;
        if (__nwlog_fault(v49, &v197, &v196))
        {
          if (v197 != OS_LOG_TYPE_FAULT)
          {
            if (v196)
            {
              v61 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              log = gLogObj;
              typea = v197;
              v62 = os_log_type_enabled((os_log_t)gLogObj, v197);
              if (v61)
              {
                if (v62)
                {
                  v63 = v26->identifier->name;
                  if (!v63)
                    v63 = "invalid";
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v63;
                  *(_WORD *)&buf[22] = 2048;
                  v199 = (const char *)v26;
                  v200 = 2082;
                  v201 = v61;
                  _os_log_impl(&dword_182FBE000, log, typea, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }
                free(v61);
                goto LABEL_118;
              }
              if (!v62)
                goto LABEL_118;
              v73 = v26->identifier->name;
              if (!v73)
                v73 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v73;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              v52 = log;
              v53 = typea;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v71 = v197;
              *(_QWORD *)typeb = gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, v197))
                goto LABEL_118;
              v72 = v26->identifier->name;
              if (!v72)
                v72 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v72;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              v52 = *(NSObject **)typeb;
              v53 = v71;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            }
LABEL_117:
            _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0x20u);
            goto LABEL_118;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v50 = v197;
          *(_QWORD *)type = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            v51 = v26->identifier->name;
            if (!v51)
              v51 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v51;
            *(_WORD *)&buf[22] = 2048;
            v199 = (const char *)v26;
            v52 = *(NSObject **)type;
            v53 = v50;
            v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
            goto LABEL_117;
          }
        }
LABEL_118:
        if (v144)
          free(v144);
        v33 = 0;
        if (v29 != &nw_protocol_ref_counted_handle)
          goto LABEL_50;
LABEL_49:
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v40 = a1[1].callbacks;
          if (v40)
          {
            v41 = (nw_protocol_callbacks *)((char *)v40 - 1);
            a1[1].callbacks = v41;
            if (!v41)
            {
              v42 = *(void (***)(_QWORD))a1[1].flow_id;
              if (v42)
              {
                *(_QWORD *)a1[1].flow_id = 0;
                v42[2](v42);
                _Block_release(v42);
              }
              if ((a1[1].flow_id[8] & 1) != 0)
              {
                v43 = *(const void **)a1[1].flow_id;
                if (v43)
                  _Block_release(v43);
              }
              free(a1);
            }
          }
        }
        goto LABEL_50;
      }
      v33 = v32(v26, a1, 1, 0xFFFFFFFFLL, 1, v170);
      if (v29 == &nw_protocol_ref_counted_handle)
        goto LABEL_49;
LABEL_50:
      if (v27 == &nw_protocol_ref_counted_handle && v26->handle == &nw_protocol_ref_counted_handle)
      {
        v44 = v26[1].callbacks;
        if (v44)
        {
          v45 = (nw_protocol_callbacks *)((char *)v44 - 1);
          v26[1].callbacks = v45;
          if (!v45)
          {
            v46 = *(void (***)(_QWORD))v26[1].flow_id;
            if (v46)
            {
              *(_QWORD *)v26[1].flow_id = 0;
              v46[2](v46);
              _Block_release(v46);
            }
            if ((v26[1].flow_id[8] & 1) != 0)
            {
              v47 = *(const void **)v26[1].flow_id;
              if (v47)
                _Block_release(v47);
            }
            free(v26);
          }
        }
      }
LABEL_52:
      v169 = v33;
      if (*((_DWORD *)v167 + 6))
      {
        if ((BYTE6(a1[3].output_handler_context) & 1) == 0)
        {
          if (gLogDatapath)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v64 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              v65 = *((_DWORD *)v167 + 6);
              v66 = "s";
              if (v65 == 1)
                v66 = "";
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v146;
              *(_WORD *)&buf[22] = 2080;
              v199 = " ";
              v200 = 2048;
              v201 = (char *)p_output_handler;
              v202 = 1024;
              v203 = v65;
              v204 = 2080;
              v205 = v66;
              _os_log_impl(&dword_182FBE000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Found %u IPv6 extra fragment%s", buf, 0x3Au);
            }
          }
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2000000000;
        LOBYTE(v199) = 0;
        v157[0] = MEMORY[0x1E0C809B0];
        v157[1] = 0x40000000;
        v158 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_ipv6_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_36;
        v159 = &unk_1E14AC6F8;
        v164 = v170;
        v165 = &v184;
        v160 = &v166;
        v161 = v188;
        v162 = buf;
        v163 = v8;
        v34 = v170[0];
        do
        {
          if (!v34)
            break;
          v35 = *(_QWORD *)(v34 + 32);
          v36 = v158(v157);
          v34 = v35;
        }
        while ((v36 & 1) != 0);
        v152[0] = MEMORY[0x1E0C809B0];
        v152[1] = 0x40000000;
        v153 = ___ZL33nw_protocol_ipv6_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2;
        v154 = &__block_descriptor_tmp_38_85390;
        v155 = v170;
        v156 = v8;
        v37 = v170[0];
        do
        {
          if (!v37)
            break;
          v38 = *(_QWORD *)(v37 + 32);
          v39 = ((uint64_t (*)(_QWORD *))v153)(v152);
          v37 = v38;
        }
        while ((v39 & 1) != 0);
        if (*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
          v23 = 34;
        else
          v23 = 0;
        _Block_object_dispose(buf, 8);
      }
      else
      {
        v23 = 34;
      }
      _Block_object_dispose(&v166, 8);
      if (v23)
        v24 = 1;
      else
        v24 = v171 == 0;
    }
    while (!v24);
    v12 = a6;
    if (v184)
    {
      *a6->tqh_last = (nw_frame *)v184;
      v76 = v185;
      *(_QWORD *)(v184 + 40) = a6->tqh_last;
      a6->tqh_last = v76;
      v184 = 0;
      v185 = (nw_frame **)&v184;
    }
    *((_DWORD *)v193 + 6) += *((_DWORD *)v189 + 6);
    v77 = nw_protocol_ipv6_process_reassembly((uint64_t)v8, 0, (uint64_t)a6, 1, 0);
    v78 = *((_DWORD *)v193 + 6) + v77;
    *((_DWORD *)v193 + 6) = v78;
    if (!v78)
    {
      if ((BYTE6(a1[3].output_handler_context) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v79 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v146;
          *(_WORD *)&buf[22] = 2080;
          v199 = " ";
          v200 = 2048;
          v201 = (char *)p_output_handler;
          _os_log_impl(&dword_182FBE000, v79, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Dropped inbound packets, checking for more", buf, 0x2Au);
        }
      }
      _Block_object_dispose(v182, 8);
      _Block_object_dispose(v186, 8);
      _Block_object_dispose(v188, 8);
      output_handler = a1->output_handler;
      if (!output_handler)
        goto LABEL_195;
      continue;
    }
    break;
  }
  _Block_object_dispose(v182, 8);
  _Block_object_dispose(v186, 8);
  _Block_object_dispose(v188, 8);
LABEL_214:
  v120 = *((unsigned int *)v193 + 6);
  _Block_object_dispose(&v192, 8);
  return v120;
}

uint64_t nw_protocol_ipv6_get_output_frames(nw_protocol *a1, nw_protocol *a2, size_t count, unsigned int a4, int a5, nw_frame_array_s *a6)
{
  int v8;
  _BOOL8 v9;
  uint64_t v10;
  uint64_t v11;
  nw_protocol *output_handler;
  uint64_t v13;
  uint64_t v14;
  nw_protocol *v15;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v18;
  nw_protocol_callbacks *v19;
  uint64_t (*get_output_frames)(nw_protocol *, nw_protocol *, uint64_t, uint64_t);
  uint64_t v21;
  nw_frame *tqh_first;
  nw_frame *v23;
  char v24;
  nw_protocol_callbacks *v25;
  nw_protocol_callbacks *v26;
  void (**v27)(_QWORD);
  const void *v28;
  nw_protocol_callbacks *v29;
  nw_protocol_callbacks *v30;
  void (**v31)(_QWORD);
  const void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  const char *v36;
  char *backtrace_string;
  _BOOL4 v38;
  nw_frame **tqh_last;
  const char *name;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  const char *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  NSObject *v55;
  os_log_type_t v56;
  char *v57;
  _BOOL4 v58;
  const char *v59;
  char *v60;
  _BOOL4 v61;
  const char *v62;
  _BOOL4 v63;
  char *v64;
  _BOOL4 v65;
  char *v66;
  _BOOL4 v67;
  const char *v68;
  const char *v69;
  NSObject *v70;
  os_log_type_t v71;
  uint32_t v72;
  _QWORD v73[2];
  uint64_t (*v74)(_QWORD *);
  void *v75;
  nw_protocol **p_output_handler;
  nw_protocol *v77;
  char v78;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v81;
  __int16 v82;
  _BYTE v83[18];
  __int16 v84;
  char *v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      v8 = count;
      if (a5
        && LODWORD(a1[3].output_handler_context) < count
        && (BYTE6(a1[3].output_handler_context) & 8) == 0)
      {
        v9 = nw_calloc_type<unsigned char>(count);
        v10 = nw_frame_create(0, v9, v8, (uint64_t)nw_protocol_ipv6_frame_output_finalizer, (uint64_t)&a1[1].output_handler);
        v11 = v10;
        if (v10)
        {
          *(_WORD *)(v10 + 204) |= 1u;
          *(_QWORD *)(v10 + 16) = 0;
          output_handler = a1[3].output_handler;
          *(_QWORD *)(v10 + 24) = output_handler;
          *(_QWORD *)output_handler->flow_id = v10;
          a1[3].output_handler = (nw_protocol *)(v10 + 16);
LABEL_65:
          *(_QWORD *)(v11 + 32) = 0;
          tqh_last = a6->tqh_last;
          *(_QWORD *)(v11 + 40) = tqh_last;
          *tqh_last = (nw_frame *)v11;
          a6->tqh_last = (nw_frame **)(v11 + 32);
          return 1;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        v81 = "nw_protocol_ipv6_create_output_frame";
        v82 = 1024;
        *(_DWORD *)v83 = v8;
        v33 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v78 = 0;
        if (__nwlog_fault(v33, &type, &v78))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v34 = gLogObj;
            v35 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)buf = 136446466;
              v81 = "nw_protocol_ipv6_create_output_frame";
              v82 = 1024;
              *(_DWORD *)v83 = v8;
              v36 = "%{public}s nw_frame_create(%u) failed";
LABEL_60:
              _os_log_impl(&dword_182FBE000, v34, v35, v36, buf, 0x12u);
            }
          }
          else if (v78)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v34 = gLogObj;
            v35 = type;
            v38 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (backtrace_string)
            {
              if (v38)
              {
                *(_DWORD *)buf = 136446722;
                v81 = "nw_protocol_ipv6_create_output_frame";
                v82 = 1024;
                *(_DWORD *)v83 = v8;
                *(_WORD *)&v83[4] = 2082;
                *(_QWORD *)&v83[6] = backtrace_string;
                _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s nw_frame_create(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(backtrace_string);
              goto LABEL_61;
            }
            if (v38)
            {
              *(_DWORD *)buf = 136446466;
              v81 = "nw_protocol_ipv6_create_output_frame";
              v82 = 1024;
              *(_DWORD *)v83 = v8;
              v36 = "%{public}s nw_frame_create(%u) failed, no backtrace";
              goto LABEL_60;
            }
          }
          else
          {
            v34 = __nwlog_obj();
            v35 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446466;
              v81 = "nw_protocol_ipv6_create_output_frame";
              v82 = 1024;
              *(_DWORD *)v83 = v8;
              v36 = "%{public}s nw_frame_create(%u) failed, backtrace limit exceeded";
              goto LABEL_60;
            }
          }
        }
LABEL_61:
        if (v33)
          free(v33);
        if (v9)
          free((void *)v9);
        goto LABEL_65;
      }
      if (count >= 0xFFFFFFD8)
        v13 = 0xFFFFFFFFLL;
      else
        v13 = (count + 40);
      if (a4 >= 0xFFFFFFD8)
        v14 = 0xFFFFFFFFLL;
      else
        v14 = a4 + 40;
      v15 = a1->output_handler;
      if (v15)
      {
        handle = v15->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = v15[1].callbacks;
          if (callbacks)
            v15[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
        v18 = a1[1].callbacks;
        if (v18)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
        if (a6)
        {
          v19 = v15->callbacks;
          if (v19)
          {
            get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t))v19->get_output_frames;
            if (get_output_frames)
            {
              v21 = get_output_frames(v15, a1, v13, v14);
              goto LABEL_24;
            }
          }
          __nwlog_obj();
          name = v15->identifier->name;
          *(_DWORD *)buf = 136446722;
          v81 = "__nw_protocol_get_output_frames";
          if (!name)
            name = "invalid";
          v82 = 2082;
          *(_QWORD *)v83 = name;
          *(_WORD *)&v83[8] = 2048;
          *(_QWORD *)&v83[10] = v15;
          v42 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v78 = 0;
          if (__nwlog_fault(v42, &type, &v78))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v43 = __nwlog_obj();
              v44 = type;
              if (!os_log_type_enabled(v43, type))
                goto LABEL_154;
              v45 = v15->identifier->name;
              if (!v45)
                v45 = "invalid";
              *(_DWORD *)buf = 136446722;
              v81 = "__nw_protocol_get_output_frames";
              v82 = 2082;
              *(_QWORD *)v83 = v45;
              *(_WORD *)&v83[8] = 2048;
              *(_QWORD *)&v83[10] = v15;
              v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_131:
              v70 = v43;
              v71 = v44;
              v72 = 32;
LABEL_153:
              _os_log_impl(&dword_182FBE000, v70, v71, v46, buf, v72);
              goto LABEL_154;
            }
            if (!v78)
            {
              v43 = __nwlog_obj();
              v44 = type;
              if (!os_log_type_enabled(v43, type))
                goto LABEL_154;
              v68 = v15->identifier->name;
              if (!v68)
                v68 = "invalid";
              *(_DWORD *)buf = 136446722;
              v81 = "__nw_protocol_get_output_frames";
              v82 = 2082;
              *(_QWORD *)v83 = v68;
              *(_WORD *)&v83[8] = 2048;
              *(_QWORD *)&v83[10] = v15;
              v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
              goto LABEL_131;
            }
            v57 = (char *)__nw_create_backtrace_string();
            v43 = __nwlog_obj();
            v44 = type;
            v58 = os_log_type_enabled(v43, type);
            if (!v57)
            {
              if (!v58)
                goto LABEL_154;
              v69 = v15->identifier->name;
              if (!v69)
                v69 = "invalid";
              *(_DWORD *)buf = 136446722;
              v81 = "__nw_protocol_get_output_frames";
              v82 = 2082;
              *(_QWORD *)v83 = v69;
              *(_WORD *)&v83[8] = 2048;
              *(_QWORD *)&v83[10] = v15;
              v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
              goto LABEL_131;
            }
            if (v58)
            {
              v59 = v15->identifier->name;
              if (!v59)
                v59 = "invalid";
              *(_DWORD *)buf = 136446978;
              v81 = "__nw_protocol_get_output_frames";
              v82 = 2082;
              *(_QWORD *)v83 = v59;
              *(_WORD *)&v83[8] = 2048;
              *(_QWORD *)&v83[10] = v15;
              v84 = 2082;
              v85 = v57;
              _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v57);
          }
LABEL_154:
          if (!v42)
          {
LABEL_156:
            v21 = 0;
LABEL_24:
            if (a1->handle == &nw_protocol_ref_counted_handle)
            {
              v25 = a1[1].callbacks;
              if (v25)
              {
                v26 = (nw_protocol_callbacks *)((char *)v25 - 1);
                a1[1].callbacks = v26;
                if (!v26)
                {
                  v27 = *(void (***)(_QWORD))a1[1].flow_id;
                  if (v27)
                  {
                    *(_QWORD *)a1[1].flow_id = 0;
                    v27[2](v27);
                    _Block_release(v27);
                  }
                  if ((a1[1].flow_id[8] & 1) != 0)
                  {
                    v28 = *(const void **)a1[1].flow_id;
                    if (v28)
                      _Block_release(v28);
                  }
                  free(a1);
                }
              }
            }
            if (handle == &nw_protocol_ref_counted_handle && v15->handle == &nw_protocol_ref_counted_handle)
            {
              v29 = v15[1].callbacks;
              if (v29)
              {
                v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
                v15[1].callbacks = v30;
                if (!v30)
                {
                  v31 = *(void (***)(_QWORD))v15[1].flow_id;
                  if (v31)
                  {
                    *(_QWORD *)v15[1].flow_id = 0;
                    v31[2](v31);
                    _Block_release(v31);
                  }
                  if ((v15[1].flow_id[8] & 1) != 0)
                  {
                    v32 = *(const void **)v15[1].flow_id;
                    if (v32)
                      _Block_release(v32);
                  }
                  free(v15);
                }
              }
            }
LABEL_27:
            v73[0] = MEMORY[0x1E0C809B0];
            v73[1] = 0x40000000;
            v74 = (uint64_t (*)(_QWORD *))___ZL34nw_protocol_ipv6_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v75 = &__block_descriptor_tmp_45_85347;
            p_output_handler = &a1[1].output_handler;
            v77 = a1;
            tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first)
                break;
              v23 = (nw_frame *)*((_QWORD *)tqh_first + 4);
              v24 = v74(v73);
              tqh_first = v23;
            }
            while ((v24 & 1) != 0);
            return v21;
          }
LABEL_155:
          free(v42);
          goto LABEL_156;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v81 = "__nw_protocol_get_output_frames";
        v42 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v78 = 0;
        if (!__nwlog_fault(v42, &type, &v78))
          goto LABEL_154;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v55 = __nwlog_obj();
          v56 = type;
          if (!os_log_type_enabled(v55, type))
            goto LABEL_154;
          *(_DWORD *)buf = 136446210;
          v81 = "__nw_protocol_get_output_frames";
          v46 = "%{public}s called with null return_array";
        }
        else if (v78)
        {
          v66 = (char *)__nw_create_backtrace_string();
          v55 = __nwlog_obj();
          v56 = type;
          v67 = os_log_type_enabled(v55, type);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446466;
              v81 = "__nw_protocol_get_output_frames";
              v82 = 2082;
              *(_QWORD *)v83 = v66;
              _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null return_array, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v66);
            if (!v42)
              goto LABEL_156;
            goto LABEL_155;
          }
          if (!v67)
            goto LABEL_154;
          *(_DWORD *)buf = 136446210;
          v81 = "__nw_protocol_get_output_frames";
          v46 = "%{public}s called with null return_array, no backtrace";
        }
        else
        {
          v55 = __nwlog_obj();
          v56 = type;
          if (!os_log_type_enabled(v55, type))
            goto LABEL_154;
          *(_DWORD *)buf = 136446210;
          v81 = "__nw_protocol_get_output_frames";
          v46 = "%{public}s called with null return_array, backtrace limit exceeded";
        }
        v70 = v55;
        v71 = v56;
        v72 = 12;
        goto LABEL_153;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v81 = "__nw_protocol_get_output_frames";
      v51 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (__nwlog_fault(v51, &type, &v78))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v52 = __nwlog_obj();
          v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            v81 = "__nw_protocol_get_output_frames";
            v54 = "%{public}s called with null protocol";
LABEL_146:
            _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0xCu);
          }
        }
        else if (v78)
        {
          v64 = (char *)__nw_create_backtrace_string();
          v52 = __nwlog_obj();
          v53 = type;
          v65 = os_log_type_enabled(v52, type);
          if (v64)
          {
            if (v65)
            {
              *(_DWORD *)buf = 136446466;
              v81 = "__nw_protocol_get_output_frames";
              v82 = 2082;
              *(_QWORD *)v83 = v64;
              _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v64);
            goto LABEL_147;
          }
          if (v65)
          {
            *(_DWORD *)buf = 136446210;
            v81 = "__nw_protocol_get_output_frames";
            v54 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_146;
          }
        }
        else
        {
          v52 = __nwlog_obj();
          v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            v81 = "__nw_protocol_get_output_frames";
            v54 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_146;
          }
        }
      }
LABEL_147:
      if (v51)
        free(v51);
      v21 = 0;
      goto LABEL_27;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v81 = "nw_protocol_ipv6_get_output_frames";
    v47 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v47, &type, &v78))
      goto LABEL_141;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null ipv6";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (!v78)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    v60 = (char *)__nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = type;
    v63 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      v81 = "nw_protocol_ipv6_get_output_frames";
      v82 = 2082;
      *(_QWORD *)v83 = v60;
      v62 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_106;
    }
    goto LABEL_107;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v81 = "nw_protocol_ipv6_get_output_frames";
  v47 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v78 = 0;
  if (!__nwlog_fault(v47, &type, &v78))
    goto LABEL_141;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v78)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    v60 = (char *)__nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = type;
    v61 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        v81 = "nw_protocol_ipv6_get_output_frames";
        v50 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v81 = "nw_protocol_ipv6_get_output_frames";
      v82 = 2082;
      *(_QWORD *)v83 = v60;
      v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_106:
      _os_log_impl(&dword_182FBE000, v48, v49, v62, buf, 0x16u);
    }
LABEL_107:
    free(v60);
    goto LABEL_141;
  }
  v48 = __nwlog_obj();
  v49 = type;
  if (os_log_type_enabled(v48, type))
  {
    *(_DWORD *)buf = 136446210;
    v81 = "nw_protocol_ipv6_get_output_frames";
    v50 = "%{public}s called with null protocol";
LABEL_140:
    _os_log_impl(&dword_182FBE000, v48, v49, v50, buf, 0xCu);
  }
LABEL_141:
  if (v47)
    free(v47);
  return 0;
}

uint64_t nw_protocol_ipv6_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  nw_frame *tqh_first;
  nw_frame *v5;
  char v6;
  nw_protocol *output_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v10;
  uint64_t (*finalize_output_frames)(nw_protocol *, nw_frame_array_s *);
  uint64_t v12;
  nw_protocol_callbacks *v14;
  nw_protocol_callbacks *v15;
  void (**v16)(_QWORD);
  const void *v17;
  const char *name;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  const char *v36;
  const char *v37;
  _QWORD v38[2];
  uint64_t (*v39)(uint64_t, uint64_t);
  void *v40;
  nw_protocol **p_output_handler;
  nw_frame_array_s *v42;
  nw_protocol *v43;
  char v44;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  void *v49;
  __int16 v50;
  nw_protocol *v51;
  __int16 v52;
  char *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_protocol_ipv6_finalize_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_90;
      *(_DWORD *)buf = 136446210;
      v47 = "nw_protocol_ipv6_finalize_output_frames";
      v27 = "%{public}s called with null protocol";
LABEL_89:
      _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
      goto LABEL_90;
    }
    if (!v44)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv6_finalize_output_frames";
        v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v32 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv6_finalize_output_frames";
        v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (!v32)
      goto LABEL_63;
    *(_DWORD *)buf = 136446466;
    v47 = "nw_protocol_ipv6_finalize_output_frames";
    v48 = 2082;
    v49 = backtrace_string;
    v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_62:
    _os_log_impl(&dword_182FBE000, v25, v26, v33, buf, 0x16u);
    goto LABEL_63;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_protocol_ipv6_finalize_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_90;
      *(_DWORD *)buf = 136446210;
      v47 = "nw_protocol_ipv6_finalize_output_frames";
      v27 = "%{public}s called with null ipv6";
      goto LABEL_89;
    }
    if (!v44)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv6_finalize_output_frames";
        v27 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v34 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv6_finalize_output_frames";
        v27 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (!v34)
      goto LABEL_63;
    *(_DWORD *)buf = 136446466;
    v47 = "nw_protocol_ipv6_finalize_output_frames";
    v48 = 2082;
    v49 = backtrace_string;
    v33 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
    goto LABEL_62;
  }
  v38[0] = MEMORY[0x1E0C809B0];
  v38[1] = 0x40000000;
  v39 = ___ZL39nw_protocol_ipv6_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  v40 = &__block_descriptor_tmp_49_85279;
  p_output_handler = &a1[1].output_handler;
  v42 = a2;
  v43 = a1;
  tqh_first = a2->tqh_first;
  do
  {
    if (!tqh_first)
      break;
    v5 = (nw_frame *)*((_QWORD *)tqh_first + 4);
    v6 = ((uint64_t (*)(_QWORD *))v39)(v38);
    tqh_first = v5;
  }
  while ((v6 & 1) != 0);
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "__nw_protocol_finalize_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_protocol_finalize_output_frames";
        v27 = "%{public}s called with null protocol";
        goto LABEL_89;
      }
LABEL_90:
      if (v24)
        free(v24);
      return 0;
    }
    if (!v44)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_protocol_finalize_output_frames";
        v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v35 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_protocol_finalize_output_frames";
        v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_protocol_finalize_output_frames";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_62;
    }
LABEL_63:
    free(backtrace_string);
    goto LABEL_90;
  }
  handle = output_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = output_handler[1].callbacks;
    if (callbacks)
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  v10 = output_handler->callbacks;
  if (v10)
  {
    finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v10->finalize_output_frames;
    if (finalize_output_frames)
    {
      v12 = finalize_output_frames(output_handler, a2);
      if (handle != &nw_protocol_ref_counted_handle)
        return v12;
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  name = output_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v47 = "__nw_protocol_finalize_output_frames";
  if (!name)
    name = "invalid";
  v48 = 2082;
  v49 = (void *)name;
  v50 = 2048;
  v51 = output_handler;
  v19 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v44 = 0;
  if (!__nwlog_fault(v19, &type, &v44))
    goto LABEL_73;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_73;
    v22 = output_handler->identifier->name;
    if (!v22)
      v22 = "invalid";
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v22;
    v50 = 2048;
    v51 = output_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_72:
    _os_log_impl(&dword_182FBE000, v20, v21, v23, buf, 0x20u);
    goto LABEL_73;
  }
  if (!v44)
  {
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_73;
    v36 = output_handler->identifier->name;
    if (!v36)
      v36 = "invalid";
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v36;
    v50 = 2048;
    v51 = output_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
    goto LABEL_72;
  }
  v28 = (char *)__nw_create_backtrace_string();
  v20 = __nwlog_obj();
  v21 = type;
  v29 = os_log_type_enabled(v20, type);
  if (!v28)
  {
    if (!v29)
      goto LABEL_73;
    v37 = output_handler->identifier->name;
    if (!v37)
      v37 = "invalid";
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v37;
    v50 = 2048;
    v51 = output_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
    goto LABEL_72;
  }
  if (v29)
  {
    v30 = output_handler->identifier->name;
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446978;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v30;
    v50 = 2048;
    v51 = output_handler;
    v52 = 2082;
    v53 = v28;
    _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v28);
LABEL_73:
  if (v19)
    free(v19);
  v12 = 0;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_13:
    if (output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v14 = output_handler[1].callbacks;
      if (v14)
      {
        v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
        output_handler[1].callbacks = v15;
        if (!v15)
        {
          v16 = *(void (***)(_QWORD))output_handler[1].flow_id;
          if (v16)
          {
            *(_QWORD *)output_handler[1].flow_id = 0;
            v16[2](v16);
            _Block_release(v16);
          }
          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            v17 = *(const void **)output_handler[1].flow_id;
            if (v17)
              _Block_release(v17);
          }
          free(output_handler);
        }
      }
    }
  }
  return v12;
}

void nw_protocol_ipv6_connected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*connected)(nw_protocol *, nw_protocol *);
  void *handle;
  nw_protocol_callbacks *v8;
  void *v9;
  nw_protocol_callbacks *v10;
  nw_protocol_callbacks *v11;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v13;
  id v14;
  id v15;
  void *v16;
  nw_protocol_identifier *stats_region;
  nw_protocol *output_handler;
  nw_protocol_callbacks *v19;
  void (*get_message_properties)(nw_protocol *, nw_protocol *, _BYTE *);
  void *v21;
  nw_protocol_callbacks *v22;
  nw_protocol_callbacks *v23;
  nw_protocol_callbacks *v24;
  nw_protocol_callbacks *v25;
  void (**v26)(_QWORD);
  const void *v27;
  nw_protocol *v28;
  nw_protocol_callbacks *v29;
  nw_protocol_callbacks *v30;
  void (*v31)(nw_protocol *, nw_protocol *);
  nw_protocol_callbacks *v32;
  nw_protocol_callbacks *v33;
  nw_protocol_callbacks *v34;
  nw_protocol_callbacks *v35;
  void (**v36)(_QWORD);
  const void *v37;
  nw_protocol_callbacks *v38;
  nw_protocol_callbacks *v39;
  void (**v40)(_QWORD);
  const void *v41;
  nw_protocol *v42;
  nw_protocol_callbacks *v43;
  nw_protocol_callbacks *v44;
  void (**v45)(_QWORD);
  const void *v46;
  nw_protocol_callbacks *v47;
  nw_protocol_callbacks *v48;
  void (**v49)(_QWORD);
  const void *v50;
  nw_protocol_callbacks *v51;
  nw_protocol_callbacks *v52;
  void (**v53)(_QWORD);
  const void *v54;
  const char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  NSObject *v59;
  const char *name;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  const char *v64;
  const char *v65;
  char *backtrace_string;
  _BOOL4 v67;
  char *v68;
  _BOOL4 v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  char *v74;
  _BOOL4 v75;
  const char *v76;
  char *v77;
  _BOOL4 v78;
  const char *v79;
  NSObject *v80;
  const char *v81;
  void *v82;
  char v83;
  os_log_type_t type;
  _BYTE buf[12];
  __int16 v86;
  char *v87;
  __int16 v88;
  const char *v89;
  __int16 v90;
  char *p_output_handler;
  __int16 v92;
  void *v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
    v55 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (!__nwlog_fault(v55, &type, &v83))
      goto LABEL_171;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
      v58 = "%{public}s called with null protocol";
      goto LABEL_170;
    }
    if (!v83)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
      v58 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_170;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type;
    v67 = os_log_type_enabled(v56, type);
    if (!backtrace_string)
    {
      if (!v67)
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
      v58 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_170;
    }
    if (v67)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
      v86 = 2082;
      v87 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_171:
    if (!v55)
      return;
    goto LABEL_172;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
    v55 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (!__nwlog_fault(v55, &type, &v83))
      goto LABEL_171;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
      v58 = "%{public}s called with null ipv6";
      goto LABEL_170;
    }
    if (!v83)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
      v58 = "%{public}s called with null ipv6, backtrace limit exceeded";
      goto LABEL_170;
    }
    v68 = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type;
    v69 = os_log_type_enabled(v56, type);
    if (v68)
    {
      if (v69)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
        v86 = 2082;
        v87 = v68;
        _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s called with null ipv6, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v68);
      if (!v55)
        return;
LABEL_172:
      v42 = (nw_protocol *)v55;
LABEL_88:
      free(v42);
      return;
    }
    if (v69)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
      v58 = "%{public}s called with null ipv6, no backtrace";
LABEL_170:
      _os_log_impl(&dword_182FBE000, v56, v57, v58, buf, 0xCu);
      goto LABEL_171;
    }
    goto LABEL_171;
  }
  if ((BYTE6(a1[3].output_handler_context) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v59 = __nwlog_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
        v86 = 2082;
        v87 = (char *)&a1[3].output_handler_context + 7;
        v88 = 2080;
        v89 = " ";
        v90 = 2048;
        p_output_handler = (char *)&a1[1].output_handler;
        _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Got a connected event from the lower layer", buf, 0x2Au);
      }
    }
  }
  default_input_handler = a1->default_input_handler;
  if (a1->output_handler != a2)
  {
    if (!default_input_handler)
      return;
    callbacks = default_input_handler->callbacks;
    if (!callbacks)
      return;
    if (!a2)
      return;
    connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
    if (!connected)
      return;
    handle = default_input_handler->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      v8 = default_input_handler[1].callbacks;
      if (v8)
        default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v8->add_input_handler + 1);
    }
    if (a2->handle != &nw_protocol_ref_counted_handle)
    {
      connected(default_input_handler, a2);
      goto LABEL_77;
    }
    v23 = a2[1].callbacks;
    if (v23)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v23->add_input_handler + 1);
    connected(default_input_handler, a2);
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      v24 = a2[1].callbacks;
      if (v24)
      {
        v25 = (nw_protocol_callbacks *)((char *)v24 - 1);
        a2[1].callbacks = v25;
        if (!v25)
        {
          v26 = *(void (***)(_QWORD))a2[1].flow_id;
          if (v26)
          {
            *(_QWORD *)a2[1].flow_id = 0;
            v26[2](v26);
            _Block_release(v26);
          }
          if ((a2[1].flow_id[8] & 1) != 0)
          {
            v27 = *(const void **)a2[1].flow_id;
            if (v27)
              _Block_release(v27);
          }
          v28 = a2;
LABEL_76:
          free(v28);
          goto LABEL_77;
        }
      }
    }
    goto LABEL_77;
  }
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v70 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (__nwlog_fault(v70, &type, &v83))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v71 = __nwlog_obj();
        v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol";
LABEL_188:
          _os_log_impl(&dword_182FBE000, v71, v72, v73, buf, 0xCu);
        }
      }
      else if (v83)
      {
        v77 = (char *)__nw_create_backtrace_string();
        v71 = __nwlog_obj();
        v72 = type;
        v78 = os_log_type_enabled(v71, type);
        if (v77)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
            v86 = 2082;
            v87 = v77;
            _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v77);
          goto LABEL_189;
        }
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_188;
        }
      }
      else
      {
        v71 = __nwlog_obj();
        v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_188;
        }
      }
    }
LABEL_189:
    if (v70)
      free(v70);
    v13 = 0;
    goto LABEL_23;
  }
  v9 = default_input_handler->handle;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    v10 = default_input_handler[1].callbacks;
    if (v10)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v10->add_input_handler + 1);
  }
  v11 = default_input_handler->callbacks;
  if (v11)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v11->get_parameters;
    if (get_parameters)
    {
      v13 = (void *)get_parameters(default_input_handler);
      if (v9 != &nw_protocol_ref_counted_handle)
        goto LABEL_23;
      goto LABEL_22;
    }
  }
  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
  if (!name)
    name = "invalid";
  v86 = 2082;
  v87 = (char *)name;
  v88 = 2048;
  v89 = (const char *)default_input_handler;
  v61 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v83 = 0;
  if (!__nwlog_fault(v61, &type, &v83))
    goto LABEL_180;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v62 = __nwlog_obj();
    v63 = type;
    if (!os_log_type_enabled(v62, type))
      goto LABEL_180;
    v64 = default_input_handler->identifier->name;
    if (!v64)
      v64 = "invalid";
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v64;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_179:
    _os_log_impl(&dword_182FBE000, v62, v63, v65, buf, 0x20u);
    goto LABEL_180;
  }
  if (!v83)
  {
    v62 = __nwlog_obj();
    v63 = type;
    if (!os_log_type_enabled(v62, type))
      goto LABEL_180;
    v79 = default_input_handler->identifier->name;
    if (!v79)
      v79 = "invalid";
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v79;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_179;
  }
  v82 = v9;
  v74 = (char *)__nw_create_backtrace_string();
  v62 = __nwlog_obj();
  v63 = type;
  v75 = os_log_type_enabled(v62, type);
  if (!v74)
  {
    v9 = v82;
    if (!v75)
      goto LABEL_180;
    v81 = default_input_handler->identifier->name;
    if (!v81)
      v81 = "invalid";
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v81;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_179;
  }
  if (v75)
  {
    v76 = default_input_handler->identifier->name;
    if (!v76)
      v76 = "invalid";
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v76;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v90 = 2082;
    p_output_handler = v74;
    _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v74);
  v9 = v82;
LABEL_180:
  if (v61)
    free(v61);
  v13 = 0;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
LABEL_22:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v43 = default_input_handler[1].callbacks;
      if (v43)
      {
        v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
        default_input_handler[1].callbacks = v44;
        if (!v44)
        {
          v45 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v45)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v45[2](v45);
            _Block_release(v45);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v46 = *(const void **)default_input_handler[1].flow_id;
            if (v46)
              _Block_release(v46);
          }
          free(default_input_handler);
        }
      }
    }
  }
LABEL_23:
  v14 = nw_parameters_copy_context(v13);
  v15 = nw_path_copy_flow_registration(v14, (uint64_t)a1);
  if (v15)
  {
    v16 = v15;
    stats_region = (nw_protocol_identifier *)nw_path_flow_registration_get_stats_region(v15, (uint64_t)a1->identifier->name);
    a1[2].identifier = stats_region;
    if (!stats_region)
    {
      if ((BYTE6(a1[3].output_handler_context) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v80 = __nwlog_obj();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv6_connected";
            v86 = 2082;
            v87 = (char *)&a1[3].output_handler_context + 7;
            v88 = 2080;
            v89 = " ";
            v90 = 2048;
            p_output_handler = (char *)&a1[1].output_handler;
            v92 = 2048;
            v93 = &g_ip6_stats;
            _os_log_impl(&dword_182FBE000, v80, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p ipv6->ip6_stats is NULL setting to global %p", buf, 0x34u);
          }
        }
      }
      a1[2].identifier = (nw_protocol_identifier *)&g_ip6_stats;
    }
    os_release(v16);
  }
  if (v14)
    os_release(v14);
  *(_QWORD *)buf = 0;
  output_handler = a1->output_handler;
  if (output_handler)
  {
    v19 = output_handler->callbacks;
    if (v19)
    {
      get_message_properties = (void (*)(nw_protocol *, nw_protocol *, _BYTE *))v19->get_message_properties;
      if (get_message_properties)
      {
        v21 = output_handler->handle;
        if (v21 == &nw_protocol_ref_counted_handle)
        {
          v22 = output_handler[1].callbacks;
          if (v22)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v22->add_input_handler + 1);
        }
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v29 = a1[1].callbacks;
          if (v29)
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v29->add_input_handler + 1);
          get_message_properties(output_handler, a1, buf);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v47 = a1[1].callbacks;
            if (v47)
            {
              v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
              a1[1].callbacks = v48;
              if (!v48)
              {
                v49 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v49)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v49[2](v49);
                  _Block_release(v49);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v50 = *(const void **)a1[1].flow_id;
                  if (v50)
                    _Block_release(v50);
                }
                free(a1);
              }
            }
          }
        }
        else
        {
          get_message_properties(output_handler, a1, buf);
        }
        if (v21 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v51 = output_handler[1].callbacks;
          if (v51)
          {
            v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
            output_handler[1].callbacks = v52;
            if (!v52)
            {
              v53 = *(void (***)(_QWORD))output_handler[1].flow_id;
              if (v53)
              {
                *(_QWORD *)output_handler[1].flow_id = 0;
                v53[2](v53);
                _Block_release(v53);
              }
              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                v54 = *(const void **)output_handler[1].flow_id;
                if (v54)
                  _Block_release(v54);
              }
              free(output_handler);
            }
          }
        }
        if ((*(_DWORD *)buf - 1) <= 0xFFFFFFFD)
          HIDWORD(a1[3].handle) = *(_DWORD *)buf;
      }
    }
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
    return;
  v30 = default_input_handler->callbacks;
  if (!v30)
    return;
  v31 = (void (*)(nw_protocol *, nw_protocol *))v30->connected;
  if (!v31)
    return;
  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    v32 = default_input_handler[1].callbacks;
    if (v32)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    v31(default_input_handler, a1);
    goto LABEL_77;
  }
  v33 = a1[1].callbacks;
  if (v33)
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v33->add_input_handler + 1);
  v31(default_input_handler, a1);
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v34 = a1[1].callbacks;
    if (v34)
    {
      v35 = (nw_protocol_callbacks *)((char *)v34 - 1);
      a1[1].callbacks = v35;
      if (!v35)
      {
        v36 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v36)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v36[2](v36);
          _Block_release(v36);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v37 = *(const void **)a1[1].flow_id;
          if (v37)
            _Block_release(v37);
        }
        v28 = a1;
        goto LABEL_76;
      }
    }
  }
LABEL_77:
  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    v38 = default_input_handler[1].callbacks;
    if (v38)
    {
      v39 = (nw_protocol_callbacks *)((char *)v38 - 1);
      default_input_handler[1].callbacks = v39;
      if (!v39)
      {
        v40 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
        if (v40)
        {
          *(_QWORD *)default_input_handler[1].flow_id = 0;
          v40[2](v40);
          _Block_release(v40);
        }
        if ((default_input_handler[1].flow_id[8] & 1) != 0)
        {
          v41 = *(const void **)default_input_handler[1].flow_id;
          if (v41)
            _Block_release(v41);
        }
        v42 = default_input_handler;
        goto LABEL_88;
      }
    }
  }
}

void nw_protocol_ipv6_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t default_input_handler;
  uint64_t v4;
  void (*v5)(uint64_t, nw_protocol *);
  void *v6;
  uint64_t v7;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v9;
  nw_protocol_callbacks *v10;
  void (**v11)(_QWORD);
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  void (**v15)(_QWORD);
  const void *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_ipv6_disconnected";
    default_input_handler = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault((const char *)default_input_handler, &type, &v24))
      goto LABEL_59;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v24)
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (!os_log_type_enabled(v17, type))
          goto LABEL_59;
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_ipv6_disconnected";
        v19 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_58;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v21 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (!v21)
          goto LABEL_59;
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_ipv6_disconnected";
        v19 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_58;
      }
      if (!v21)
      {
LABEL_48:
        free(backtrace_string);
        if (!default_input_handler)
          return;
LABEL_30:
        free((void *)default_input_handler);
        return;
      }
      *(_DWORD *)buf = 136446466;
      v27 = "nw_protocol_ipv6_disconnected";
      v28 = 2082;
      v29 = backtrace_string;
      v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_47:
      _os_log_impl(&dword_182FBE000, v17, v18, v22, buf, 0x16u);
      goto LABEL_48;
    }
    v17 = __nwlog_obj();
    v18 = type;
    if (!os_log_type_enabled(v17, type))
      goto LABEL_59;
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_ipv6_disconnected";
    v19 = "%{public}s called with null protocol";
LABEL_58:
    _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
LABEL_59:
    if (!default_input_handler)
      return;
    goto LABEL_30;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_ipv6_disconnected";
    default_input_handler = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault((const char *)default_input_handler, &type, &v24))
      goto LABEL_59;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_59;
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_ipv6_disconnected";
      v19 = "%{public}s called with null ipv6";
      goto LABEL_58;
    }
    if (!v24)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_59;
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_ipv6_disconnected";
      v19 = "%{public}s called with null ipv6, backtrace limit exceeded";
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v23 = os_log_type_enabled(v17, type);
    if (backtrace_string)
    {
      if (!v23)
        goto LABEL_48;
      *(_DWORD *)buf = 136446466;
      v27 = "nw_protocol_ipv6_disconnected";
      v28 = 2082;
      v29 = backtrace_string;
      v22 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_47;
    }
    if (!v23)
      goto LABEL_59;
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_ipv6_disconnected";
    v19 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_58;
  }
  a1[2].identifier = 0;
  default_input_handler = (uint64_t)a1->default_input_handler;
  if (default_input_handler)
  {
    v4 = *(_QWORD *)(default_input_handler + 24);
    if (v4)
    {
      v5 = *(void (**)(uint64_t, nw_protocol *))(v4 + 48);
      if (v5)
      {
        v6 = *(void **)(default_input_handler + 40);
        if (v6 == &nw_protocol_ref_counted_handle)
        {
          v7 = *(_QWORD *)(default_input_handler + 88);
          if (v7)
            *(_QWORD *)(default_input_handler + 88) = v7 + 1;
        }
        callbacks = a1[1].callbacks;
        if (callbacks)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        v5(default_input_handler, a1);
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v9 = a1[1].callbacks;
          if (v9)
          {
            v10 = (nw_protocol_callbacks *)((char *)v9 - 1);
            a1[1].callbacks = v10;
            if (!v10)
            {
              v11 = *(void (***)(_QWORD))a1[1].flow_id;
              if (v11)
              {
                *(_QWORD *)a1[1].flow_id = 0;
                v11[2](v11);
                _Block_release(v11);
              }
              if ((a1[1].flow_id[8] & 1) != 0)
              {
                v12 = *(const void **)a1[1].flow_id;
                if (v12)
                  _Block_release(v12);
              }
              free(a1);
            }
          }
        }
        if (v6 == &nw_protocol_ref_counted_handle
          && *(_UNKNOWN **)(default_input_handler + 40) == &nw_protocol_ref_counted_handle)
        {
          v13 = *(_QWORD *)(default_input_handler + 88);
          if (v13)
          {
            v14 = v13 - 1;
            *(_QWORD *)(default_input_handler + 88) = v14;
            if (!v14)
            {
              v15 = *(void (***)(_QWORD))(default_input_handler + 64);
              if (v15)
              {
                *(_QWORD *)(default_input_handler + 64) = 0;
                v15[2](v15);
                _Block_release(v15);
              }
              if ((*(_BYTE *)(default_input_handler + 72) & 1) != 0)
              {
                v16 = *(const void **)(default_input_handler + 64);
                if (v16)
                  _Block_release(v16);
              }
              goto LABEL_30;
            }
          }
        }
      }
    }
  }
}

void nw_protocol_ipv6_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char *v10;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv6_get_message_properties";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_ipv6_get_message_properties";
      v7 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_ipv6_get_message_properties";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v4)
          return;
LABEL_35:
        free(v4);
        return;
      }
      if (!v9)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_ipv6_get_message_properties";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_ipv6_get_message_properties";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      v3 = a3[1] & 0xFFFFFFF8 | 1;
      *a3 = *(_DWORD *)(a1 + 248);
      a3[1] = v3;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_ipv6_get_message_properties";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv6_get_message_properties";
    v7 = "%{public}s called with null ipv6";
    goto LABEL_33;
  }
  if (!v12)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv6_get_message_properties";
    v7 = "%{public}s called with null ipv6, backtrace limit exceeded";
    goto LABEL_33;
  }
  v10 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11)
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv6_get_message_properties";
    v7 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_33;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    v15 = "nw_protocol_ipv6_get_message_properties";
    v16 = 2082;
    v17 = v10;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null ipv6, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v4)
    goto LABEL_35;
}

BOOL nw_protocol_ipv6_copy_info(uint64_t a1, int a2, _QWORD *a3)
{
  char *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  NSObject *v13;
  void *v14;
  _BOOL8 result;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv6_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_36;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_36;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_ipv6_copy_info";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v11)
          goto LABEL_36;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_ipv6_copy_info";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_ipv6_copy_info";
        v21 = 2082;
        v22 = (uint64_t)backtrace_string;
        v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
        _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
      }
LABEL_26:
      free(backtrace_string);
      goto LABEL_36;
    }
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv6_copy_info";
    v9 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
LABEL_36:
    if (v6)
      free(v6);
    return 0;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv6_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv6_copy_info";
      v9 = "%{public}s called with null ipv6";
      goto LABEL_35;
    }
    if (!v17)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv6_copy_info";
      v9 = "%{public}s called with null ipv6, backtrace limit exceeded";
      goto LABEL_35;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v16 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_ipv6_copy_info";
        v21 = 2082;
        v22 = (uint64_t)backtrace_string;
        v12 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
        goto LABEL_25;
      }
      goto LABEL_26;
    }
    if (!v16)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv6_copy_info";
    v9 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_35;
  }
  if (a2 != 5)
    return 0;
  v5 = (char *)malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
  if (v5)
    goto LABEL_5;
  v13 = __nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v20 = "strict_calloc";
  v21 = 2048;
  v22 = 1;
  v23 = 2048;
  v24 = 184;
  v14 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
LABEL_5:
    *(_OWORD *)(v5 + 8) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(v5 + 24) = *(_OWORD *)(a1 + 120);
    *((_QWORD *)v5 + 5) = *(_QWORD *)(a1 + 96);
    if (a3)
      *a3 = 184;
    return (BOOL)v5;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_ipv6_updated_path(nw_protocol *a1, nw_protocol *a2, nw_path *a3)
{
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_ipv6_updated_path";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_ipv6_updated_path";
      v9 = "%{public}s called with null protocol";
LABEL_44:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      goto LABEL_45;
    }
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv6_updated_path";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv6_updated_path";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v11)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    v18 = "nw_protocol_ipv6_updated_path";
    v19 = 2082;
    v20 = backtrace_string;
    v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_30:
    _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
    goto LABEL_31;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_ipv6_updated_path";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_ipv6_updated_path";
      v9 = "%{public}s called with null ipv6";
      goto LABEL_44;
    }
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv6_updated_path";
        v9 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv6_updated_path";
        v9 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v13)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    v18 = "nw_protocol_ipv6_updated_path";
    v19 = 2082;
    v20 = backtrace_string;
    v12 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
    goto LABEL_30;
  }
  if (a3)
  {
    LODWORD(a1[3].output_handler_context) = nw_path_get_maximum_packet_size(a3);
    LODWORD(a1[3].handle) = nw_path_get_mtu(a3);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_ipv6_updated_path";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v6, &type, &v15))
    goto LABEL_45;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv6_updated_path";
        v9 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv6_updated_path";
        v9 = "%{public}s called with null path, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v18 = "nw_protocol_ipv6_updated_path";
      v19 = 2082;
      v20 = backtrace_string;
      v12 = "%{public}s called with null path, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
LABEL_31:
    free(backtrace_string);
    goto LABEL_45;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_ipv6_updated_path";
    v9 = "%{public}s called with null path";
    goto LABEL_44;
  }
LABEL_45:
  if (v6)
    free(v6);
  return 0;
}

void nw_protocol_ipv6_notify(uint64_t a1, uint64_t a2, unsigned int a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v8;
  char v9;
  NSObject *v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t);
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  void (**v20)(_QWORD);
  const void *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  char *backtrace_string;
  _BOOL4 v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  _BOOL4 v31;
  const char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  const char *v36;
  _BOOL4 v37;
  _BOOL4 v38;
  _BOOL4 v39;
  char *v40;
  _BOOL4 v41;
  const char *v42;
  const char *v43;
  const char *v44;
  char *v45;
  char v46;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  void *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  char *v55;
  __int16 v56;
  int v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null protocol";
    }
    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v27 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          v49 = "nw_protocol_ipv6_notify";
          v50 = 2082;
          v51 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_131:
        if (!v22)
          return;
        goto LABEL_132;
      }
      if (!v27)
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_130;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv6_notify";
        v25 = "%{public}s called with null ipv6, backtrace limit exceeded";
        goto LABEL_130;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v29 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v29)
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv6_notify";
        v25 = "%{public}s called with null ipv6, no backtrace";
        goto LABEL_130;
      }
      if (!v29)
        goto LABEL_99;
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv6_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_131;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v25 = "%{public}s called with null ipv6";
LABEL_130:
    _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0xCu);
    goto LABEL_131;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv6_notify";
        v25 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_130;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v31 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v31)
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv6_notify";
        v25 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_130;
      }
      if (!v31)
        goto LABEL_99;
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv6_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_131;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v25 = "%{public}s called with null other_protocol";
    goto LABEL_130;
  }
  v8 = a1 + 96;
  if (a3 == 17)
  {
    if (*(_QWORD *)(a1 + 32) != a2)
      goto LABEL_13;
    v12 = *(void **)(a2 + 40);
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      v13 = *(_QWORD *)(a2 + 88);
      if (v13)
        *(_QWORD *)(a2 + 88) = v13 + 1;
    }
    v14 = *(_QWORD *)(a2 + 24);
    if (v14)
    {
      v15 = *(uint64_t (**)(uint64_t))(v14 + 200);
      if (v15)
      {
        v16 = v15(a2);
        if (v12 != &nw_protocol_ref_counted_handle)
        {
LABEL_22:
          if (v16)
          {
            if (nw_endpoint_get_address_family(v16) == 30)
            {
              *(sockaddr *)(a1 + 152) = *(sockaddr *)&nw_endpoint_get_address(v16)->sa_data[6];
              if ((*(_BYTE *)(a1 + 254) & 1) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v17 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)buf = 136446978;
                  v49 = "nw_protocol_ipv6_notify";
                  v50 = 2082;
                  v51 = (void *)(a1 + 255);
                  v52 = 2080;
                  v53 = " ";
                  v54 = 2048;
                  v55 = (char *)v8;
                  _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p updated local address", buf, 0x2Au);
                }
              }
            }
          }
          goto LABEL_13;
        }
LABEL_21:
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          v18 = *(_QWORD *)(a2 + 88);
          if (v18)
          {
            v19 = v18 - 1;
            *(_QWORD *)(a2 + 88) = v19;
            if (!v19)
            {
              v20 = *(void (***)(_QWORD))(a2 + 64);
              if (v20)
              {
                *(_QWORD *)(a2 + 64) = 0;
                v20[2](v20);
                _Block_release(v20);
              }
              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                v21 = *(const void **)(a2 + 64);
                if (v21)
                  _Block_release(v21);
              }
              free((void *)a2);
            }
          }
        }
        goto LABEL_22;
      }
    }
    __nwlog_obj();
    v32 = *(const char **)(a2 + 16);
    *(_DWORD *)buf = 136446722;
    v49 = "__nw_protocol_get_output_local_endpoint";
    if (!v32)
      v32 = "invalid";
    v50 = 2082;
    v51 = (void *)v32;
    v52 = 2048;
    v53 = (const char *)a2;
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    v45 = (char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v45, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_138;
        v35 = *(const char **)(a2 + 16);
        if (!v35)
          v35 = "invalid";
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v35;
        v52 = 2048;
        v53 = (const char *)a2;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback";
LABEL_137:
        _os_log_impl(&dword_182FBE000, v33, v34, v36, buf, 0x20u);
        goto LABEL_138;
      }
      if (!v46)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_138;
        v43 = *(const char **)(a2 + 16);
        if (!v43)
          v43 = "invalid";
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v43;
        v52 = 2048;
        v53 = (const char *)a2;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, backtrace limit exceeded";
        goto LABEL_137;
      }
      v40 = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v41 = os_log_type_enabled(v33, type);
      if (!v40)
      {
        v8 = a1 + 96;
        if (!v41)
          goto LABEL_138;
        v44 = *(const char **)(a2 + 16);
        if (!v44)
          v44 = "invalid";
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v44;
        v52 = 2048;
        v53 = (const char *)a2;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, no backtrace";
        goto LABEL_137;
      }
      if (v41)
      {
        v42 = *(const char **)(a2 + 16);
        if (!v42)
          v42 = "invalid";
        *(_DWORD *)buf = 136446978;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v42;
        v52 = 2048;
        v53 = (const char *)a2;
        v54 = 2082;
        v55 = v40;
        _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v40);
      v8 = a1 + 96;
    }
LABEL_138:
    if (v45)
      free(v45);
    v16 = 0;
    if (v12 != &nw_protocol_ref_counted_handle)
      goto LABEL_22;
    goto LABEL_21;
  }
  if (a3 != 14)
  {
LABEL_13:
    nw_protocol_common_notify(a1, a2, a3);
    return;
  }
  if (*(_QWORD *)(a1 + 48) != a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv6_notify";
        v25 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv6->protocol)), backtrace limit exceeded";
        goto LABEL_130;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v37 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v37)
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv6_notify";
        v25 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv6->protocol)), no backtrace";
        goto LABEL_130;
      }
      if (!v37)
        goto LABEL_99;
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv6_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv6->protocol)), dumping back"
            "trace:%{public}s";
      goto LABEL_98;
    }
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_131;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v25 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv6->protocol))";
    goto LABEL_130;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null (val != nil)";
      goto LABEL_130;
    }
    if (!v46)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null (val != nil), backtrace limit exceeded";
      goto LABEL_130;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type;
    v38 = os_log_type_enabled(v23, type);
    if (!v28)
    {
      if (!v38)
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null (val != nil), no backtrace";
      goto LABEL_130;
    }
    if (!v38)
      goto LABEL_99;
    *(_DWORD *)buf = 136446466;
    v49 = "nw_protocol_ipv6_notify";
    v50 = 2082;
    v51 = v28;
    v30 = "%{public}s called with null (val != nil), dumping backtrace:%{public}s";
LABEL_98:
    _os_log_impl(&dword_182FBE000, v23, v24, v30, buf, 0x16u);
    goto LABEL_99;
  }
  if (a5 != 1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv6_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null (len == sizeof(BOOL))";
      goto LABEL_130;
    }
    if (!v46)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null (len == sizeof(BOOL)), backtrace limit exceeded";
      goto LABEL_130;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type;
    v39 = os_log_type_enabled(v23, type);
    if (!v28)
    {
      if (!v39)
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv6_notify";
      v25 = "%{public}s called with null (len == sizeof(BOOL)), no backtrace";
      goto LABEL_130;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv6_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null (len == sizeof(BOOL)), dumping backtrace:%{public}s";
      goto LABEL_98;
    }
LABEL_99:
    free(v28);
    if (!v22)
      return;
LABEL_132:
    free(v22);
    return;
  }
  v9 = *(_BYTE *)(a1 + 254);
  *(_BYTE *)(a1 + 254) = v9 & 0xF7 | (8 * *a4);
  if ((v9 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v11 = (*(unsigned __int8 *)(a1 + 254) >> 3) & 1;
      *(_DWORD *)buf = 136447234;
      v49 = "nw_protocol_ipv6_notify";
      v50 = 2082;
      v51 = (void *)(a1 + 255);
      v52 = 2080;
      v53 = " ";
      v54 = 2048;
      v55 = (char *)(a1 + 96);
      v56 = 1024;
      v57 = v11;
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p segmentation offload notify enable %d", buf, 0x30u);
    }
  }
}

void nw_protocol_ipv6_error(nw_protocol *a1, nw_protocol *a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char *v8;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv6_error";
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_ipv6_error";
      v5 = "%{public}s called with null protocol";
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_protocol_ipv6_error";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_33:
        if (!v2)
          return;
        goto LABEL_34;
      }
      if (!v7)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_ipv6_error";
      v5 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_ipv6_error";
      v5 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_32:
    _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    goto LABEL_33;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    if (a1->default_input_handler)
      nw_protocol_common_error((uint64_t)a1, (uint64_t)a2);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_protocol_ipv6_error";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10))
    goto LABEL_33;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv6_error";
    v5 = "%{public}s called with null ipv6";
    goto LABEL_32;
  }
  if (!v10)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv6_error";
    v5 = "%{public}s called with null ipv6, backtrace limit exceeded";
    goto LABEL_32;
  }
  v8 = (char *)__nw_create_backtrace_string();
  v3 = __nwlog_obj();
  v4 = type;
  v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9)
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv6_error";
    v5 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_32;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    v13 = "nw_protocol_ipv6_error";
    v14 = 2082;
    v15 = v8;
    _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null ipv6, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v8);
  if (v2)
LABEL_34:
    free(v2);
}

uint64_t ___ZL39nw_protocol_ipv6_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  NSObject *v14;
  _BOOL4 v15;
  const char *v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *backtrace_string;
  _BOOL4 v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  int v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (nw_frame_get_finalizer_context(a2) == *(_QWORD *)(a1 + 32))
  {
    v11 = *(_QWORD *)(a2 + 32);
    v12 = *(_QWORD **)(a2 + 40);
    if (v11)
    {
      *(_QWORD *)(v11 + 40) = v12;
      v12 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) = v12;
    }
    *v12 = v11;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
  }
  else
  {
    nw_frame_unclaim(a2, v4, 0x28u, 0);
    v30 = 0;
    v5 = (_DWORD *)nw_frame_unclaimed_bytes(a2, &v30);
    v6 = *(_QWORD *)(a1 + 32);
    if (v5)
    {
      v7 = v5;
      v8 = *(_QWORD *)(v6 + 48);
      if (v8)
        ++*(_QWORD *)(v8 + 192);
      v9 = *(_DWORD *)(v6 + 144) & 0xFFFFFF0F;
      *v5 = v9;
      if (a2)
      {
        v10 = v9 | ((*(_BYTE *)(a2 + 186) & 3) << 12);
        *v5 = v10;
        if (*(_BYTE *)(a2 + 184))
          *v5 = v10 | (*(unsigned __int8 *)(a2 + 184) << 22);
LABEL_8:
        *(_BYTE *)v7 = 96;
        *((_BYTE *)v7 + 6) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + 156);
        *((_BYTE *)v7 + 7) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + 157);
        *(_OWORD *)(v7 + 2) = *(_OWORD *)(*(_QWORD *)(a1 + 32) + 56);
        *(_OWORD *)(v7 + 6) = *(_OWORD *)(*(_QWORD *)(a1 + 32) + 72);
        *((_WORD *)v7 + 2) = bswap32((unsigned __int16)v30 - 40) >> 16;
        ++**(_QWORD **)(a1 + 32);
        return 1;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v34 = "__nw_frame_get_ecn_flag";
      v18 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v31 = 0;
      if (__nwlog_fault(v18, &type, &v31))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v19 = __nwlog_obj();
          v20 = type;
          if (!os_log_type_enabled(v19, type))
            goto LABEL_37;
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_get_ecn_flag";
          v21 = "%{public}s called with null frame";
LABEL_36:
          _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
          goto LABEL_37;
        }
        if (!v31)
        {
          v19 = __nwlog_obj();
          v20 = type;
          if (!os_log_type_enabled(v19, type))
            goto LABEL_37;
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_get_ecn_flag";
          v21 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_36;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v19 = __nwlog_obj();
        v20 = type;
        v23 = os_log_type_enabled(v19, type);
        if (!backtrace_string)
        {
          if (!v23)
            goto LABEL_37;
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_get_ecn_flag";
          v21 = "%{public}s called with null frame, no backtrace";
          goto LABEL_36;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "__nw_frame_get_ecn_flag";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
      }
LABEL_37:
      if (v18)
        free(v18);
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v34 = "__nw_frame_get_dscp_value";
      v24 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v31 = 0;
      if (!__nwlog_fault(v24, &type, &v31))
        goto LABEL_53;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
          goto LABEL_53;
        *(_DWORD *)buf = 136446210;
        v34 = "__nw_frame_get_dscp_value";
        v27 = "%{public}s called with null frame";
      }
      else if (v31)
      {
        v28 = (char *)__nw_create_backtrace_string();
        v25 = __nwlog_obj();
        v26 = type;
        v29 = os_log_type_enabled(v25, type);
        if (v28)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v34 = "__nw_frame_get_dscp_value";
            v35 = 2082;
            v36 = v28;
            _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v28);
          goto LABEL_53;
        }
        if (!v29)
        {
LABEL_53:
          if (v24)
            free(v24);
          goto LABEL_8;
        }
        *(_DWORD *)buf = 136446210;
        v34 = "__nw_frame_get_dscp_value";
        v27 = "%{public}s called with null frame, no backtrace";
      }
      else
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
          goto LABEL_53;
        *(_DWORD *)buf = 136446210;
        v34 = "__nw_frame_get_dscp_value";
        v27 = "%{public}s called with null frame, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
      goto LABEL_53;
    }
    if (!v6 || (*(_BYTE *)(v6 + 158) & 1) == 0)
    {
      v14 = __nwlog_obj();
      v15 = os_log_type_enabled(v14, OS_LOG_TYPE_INFO);
      v6 = *(_QWORD *)(a1 + 32);
      if (v15)
      {
        v16 = (const char *)(v6 + 159);
        if (!v6)
          v16 = "";
        *(_DWORD *)buf = 136446978;
        v34 = "nw_protocol_ipv6_finalize_output_frames_block_invoke";
        v35 = 2082;
        v36 = (void *)v16;
        v17 = " ";
        if (!v6)
          v17 = "";
        v37 = 2080;
        v38 = v17;
        v39 = 2048;
        v40 = v6;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
        v6 = *(_QWORD *)(a1 + 32);
      }
    }
    *(_QWORD *)(v6 + 48) = 0;
  }
  return 1;
}

void nw_protocol_ipv6_frame_output_finalizer(nw_frame *a1, int a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint32_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint32_t v11;
  unsigned int v12;
  int v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t, _QWORD *, _QWORD, _QWORD, uint64_t, _QWORD *);
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  BOOL v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t, _QWORD *);
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  void (**v44)(_QWORD);
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  void (**v48)(_QWORD);
  const void *v49;
  uint64_t v50;
  uint64_t v51;
  void (**v52)(_QWORD);
  const void *v53;
  const char *v54;
  const char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  const char *v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  char *v64;
  _BOOL4 v65;
  const char *v66;
  const char *v67;
  char *v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  const char *v72;
  char *backtrace_string;
  _BOOL4 v74;
  NSObject *v75;
  _BOOL4 v76;
  NSObject *v77;
  os_log_type_t v78;
  const char *v79;
  char *v80;
  _BOOL4 v81;
  const char *v82;
  NSObject *v83;
  const char *v84;
  NSObject *v85;
  os_log_type_t v86;
  const char *v87;
  char *v88;
  _BOOL4 v89;
  const char *v90;
  const char *v91;
  os_log_type_t type;
  os_log_t log;
  NSObject *loga;
  char *v95;
  _QWORD v96[2];
  uint64_t (*v97)(uint64_t, uint64_t);
  void *v98;
  _QWORD *v99;
  _QWORD *v100;
  _QWORD *v101;
  nw_frame *v102;
  uint64_t v103;
  unsigned int v104;
  uint32_t v105;
  _QWORD v106[2];
  uint64_t (*v107)(uint64_t, uint64_t);
  void *v108;
  _QWORD *v109;
  _QWORD v110[2];
  _QWORD v111[3];
  int v112;
  unsigned int v113;
  char v114;
  os_log_type_t v115;
  uint8_t buf[4];
  const char *v117;
  __int16 v118;
  char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  char *v123;
  __int16 v124;
  unsigned int v125;
  __int16 v126;
  unsigned int v127;
  uint64_t v128;

  v128 = *MEMORY[0x1E0C80C00];
  if (!a2)
    goto LABEL_49;
  v113 = 0;
  v5 = nw_frame_unclaimed_bytes((uint64_t)a1, &v113);
  if (!v5 || !v113)
    goto LABEL_49;
  v6 = v5;
  v111[0] = 0;
  v111[1] = v111;
  v112 = 0;
  v111[2] = 0x2000000000;
  v7 = arc4random();
  v110[0] = 0;
  v110[1] = v110;
  v8 = *(a3 - 8);
  v9 = MEMORY[0x1E0C809B0];
  v10 = (_QWORD *)&unk_183BA7000;
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v117 = "__nw_protocol_get_output_frames";
    v60 = (char *)_os_log_send_and_compose_impl();
    v115 = OS_LOG_TYPE_ERROR;
    v114 = 0;
    if (!__nwlog_fault(v60, &v115, &v114))
      goto LABEL_152;
    if (v115 == OS_LOG_TYPE_FAULT)
    {
      v61 = __nwlog_obj();
      v62 = v115;
      if (!os_log_type_enabled(v61, v115))
        goto LABEL_152;
      *(_DWORD *)buf = 136446210;
      v117 = "__nw_protocol_get_output_frames";
      v63 = "%{public}s called with null protocol";
    }
    else if (v114)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v61 = __nwlog_obj();
      v62 = v115;
      v74 = os_log_type_enabled(v61, v115);
      if (backtrace_string)
      {
        if (v74)
        {
          *(_DWORD *)buf = 136446466;
          v117 = "__nw_protocol_get_output_frames";
          v118 = 2082;
          v119 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        v10 = (_QWORD *)&unk_183BA7000;
        goto LABEL_152;
      }
      v10 = (_QWORD *)&unk_183BA7000;
      if (!v74)
      {
LABEL_152:
        if (v60)
          free(v60);
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      v117 = "__nw_protocol_get_output_frames";
      v63 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v61 = __nwlog_obj();
      v62 = v115;
      if (!os_log_type_enabled(v61, v115))
        goto LABEL_152;
      *(_DWORD *)buf = 136446210;
      v117 = "__nw_protocol_get_output_frames";
      v63 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v61, v62, v63, buf, 0xCu);
    goto LABEL_152;
  }
  v11 = v7;
  v12 = *((_DWORD *)a3 + 38);
  v13 = *((_DWORD *)a3 + 35);
  v14 = *(void **)(v8 + 40);
  if (v14 == &nw_protocol_ref_counted_handle)
  {
    v15 = *(_QWORD *)(v8 + 88);
    if (v15)
      *(_QWORD *)(v8 + 88) = v15 + 1;
  }
  v16 = (void *)*(a3 - 7);
  if (v16 == &nw_protocol_ref_counted_handle)
  {
    v17 = *(a3 - 1);
    if (v17)
      *(a3 - 1) = v17 + 1;
  }
  v18 = *(_QWORD *)(v8 + 24);
  if (v18)
  {
    v19 = *(uint64_t (**)(uint64_t, _QWORD *, _QWORD, _QWORD, uint64_t, _QWORD *))(v18 + 88);
    if (v19)
    {
      v20 = v19(v8, a3 - 12, v13 + v13 * (v113 / v12), v13 + v13 * (v113 / v12), 32, v110);
      if (v16 != &nw_protocol_ref_counted_handle)
        goto LABEL_15;
      goto LABEL_14;
    }
  }
  __nwlog_obj();
  v54 = *(const char **)(v8 + 16);
  *(_DWORD *)buf = 136446722;
  v117 = "__nw_protocol_get_output_frames";
  if (!v54)
    v54 = "invalid";
  v118 = 2082;
  v119 = (char *)v54;
  v120 = 2048;
  v121 = (const char *)v8;
  v55 = (const char *)_os_log_send_and_compose_impl();
  v115 = OS_LOG_TYPE_ERROR;
  v114 = 0;
  v95 = (char *)v55;
  if (__nwlog_fault(v55, &v115, &v114))
  {
    if (v115 == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = v115;
      log = v56;
      if (!os_log_type_enabled(v56, v115))
        goto LABEL_129;
      v58 = *(const char **)(v8 + 16);
      if (!v58)
        v58 = "invalid";
      *(_DWORD *)buf = 136446722;
      v117 = "__nw_protocol_get_output_frames";
      v118 = 2082;
      v119 = (char *)v58;
      v120 = 2048;
      v121 = (const char *)v8;
      v59 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_127:
      v85 = log;
      v86 = v57;
LABEL_128:
      _os_log_impl(&dword_182FBE000, v85, v86, v59, buf, 0x20u);
      goto LABEL_129;
    }
    if (!v114)
    {
      v83 = __nwlog_obj();
      v57 = v115;
      log = v83;
      if (!os_log_type_enabled(v83, v115))
        goto LABEL_129;
      v84 = *(const char **)(v8 + 16);
      if (!v84)
        v84 = "invalid";
      *(_DWORD *)buf = 136446722;
      v117 = "__nw_protocol_get_output_frames";
      v118 = 2082;
      v119 = (char *)v84;
      v120 = 2048;
      v121 = (const char *)v8;
      v59 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
      goto LABEL_127;
    }
    v64 = (char *)__nw_create_backtrace_string();
    loga = __nwlog_obj();
    type = v115;
    v65 = os_log_type_enabled(loga, v115);
    if (v64)
    {
      if (v65)
      {
        v66 = *(const char **)(v8 + 16);
        if (!v66)
          v66 = "invalid";
        *(_DWORD *)buf = 136446978;
        v117 = "__nw_protocol_get_output_frames";
        v118 = 2082;
        v119 = (char *)v66;
        v120 = 2048;
        v121 = (const char *)v8;
        v122 = 2082;
        v123 = v64;
        _os_log_impl(&dword_182FBE000, loga, type, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v64);
    }
    else if (v65)
    {
      v87 = *(const char **)(v8 + 16);
      if (!v87)
        v87 = "invalid";
      *(_DWORD *)buf = 136446722;
      v117 = "__nw_protocol_get_output_frames";
      v118 = 2082;
      v119 = (char *)v87;
      v120 = 2048;
      v121 = (const char *)v8;
      v59 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
      v85 = loga;
      v86 = type;
      goto LABEL_128;
    }
  }
LABEL_129:
  if (v95)
    free(v95);
  v20 = 0;
  if (v16 == &nw_protocol_ref_counted_handle)
  {
LABEL_14:
    if ((_UNKNOWN *)*(a3 - 7) == &nw_protocol_ref_counted_handle)
    {
      v42 = *(a3 - 1);
      if (v42)
      {
        v43 = v42 - 1;
        *(a3 - 1) = v43;
        if (!v43)
        {
          v44 = (void (**)(_QWORD))*(a3 - 4);
          if (v44)
          {
            *(a3 - 4) = 0;
            v44[2](v44);
            _Block_release(v44);
          }
          if ((*(_BYTE *)(a3 - 3) & 1) != 0)
          {
            v45 = (const void *)*(a3 - 4);
            if (v45)
              _Block_release(v45);
          }
          free(a3 - 12);
        }
      }
    }
  }
LABEL_15:
  v9 = MEMORY[0x1E0C809B0];
  if (v14 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v8 + 40) == &nw_protocol_ref_counted_handle)
  {
    v46 = *(_QWORD *)(v8 + 88);
    if (v46)
    {
      v47 = v46 - 1;
      *(_QWORD *)(v8 + 88) = v47;
      if (!v47)
      {
        v48 = *(void (***)(_QWORD))(v8 + 64);
        if (v48)
        {
          *(_QWORD *)(v8 + 64) = 0;
          v48[2](v48);
          _Block_release(v48);
        }
        if ((*(_BYTE *)(v8 + 72) & 1) != 0)
        {
          v49 = *(const void **)(v8 + 64);
          if (v49)
            _Block_release(v49);
        }
        free((void *)v8);
      }
    }
  }
  v10 = &unk_183BA7000;
  if (!v20)
  {
LABEL_27:
    if ((*((_BYTE *)a3 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        v117 = "nw_protocol_ipv6_frame_output_finalizer";
        v118 = 2082;
        v119 = (char *)a3 + 159;
        v120 = 2080;
        v121 = " ";
        v122 = 2048;
        v123 = (char *)a3;
        v124 = 1024;
        v125 = v113;
        _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Not enough bytes to fragment %u", buf, 0x30u);
      }
    }
    v106[0] = v9;
    v106[1] = v10[197];
    v107 = ___ZL39nw_protocol_ipv6_frame_output_finalizerP8nw_framebPv_block_invoke;
    v108 = &__block_descriptor_tmp_46_85349;
    v109 = v110;
    v29 = v110[0];
    do
    {
      if (!v29)
        break;
      v30 = *(_QWORD *)(v29 + 32);
      v31 = ((uint64_t (*)(_QWORD *))v107)(v106);
      v29 = v30;
    }
    while ((v31 & 1) != 0);
    goto LABEL_48;
  }
  v21 = 0;
  v22 = v113;
  v23 = v110[0];
  while (v23)
  {
    v27 = *(_DWORD *)(v23 + 52);
    if (v27)
      v27 -= *(_DWORD *)(v23 + 56) + *(_DWORD *)(v23 + 60);
    v23 = *(_QWORD *)(v23 + 32);
    v24 = __CFADD__(v21, v27);
    v25 = v21 + v27;
    v21 += v27;
    if (v24)
      v26 = -1;
    else
      v26 = v25;
    if (v26 >= v113)
      goto LABEL_34;
  }
  if (v21 < v113)
    goto LABEL_27;
LABEL_34:
  if ((*((_BYTE *)a3 + 158) & 1) == 0 && gLogDatapath)
  {
    v75 = __nwlog_obj();
    v76 = os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG);
    v22 = v113;
    if (v76)
    {
      *(_DWORD *)buf = 136447490;
      v117 = "nw_protocol_ipv6_frame_output_finalizer";
      v118 = 2082;
      v119 = (char *)a3 + 159;
      v120 = 2080;
      v121 = " ";
      v122 = 2048;
      v123 = (char *)a3;
      v124 = 1024;
      v125 = v20;
      v126 = 1024;
      v127 = v113;
      _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Got %u packets to fragment %u bytes", buf, 0x36u);
      v22 = v113;
    }
    v10 = (_QWORD *)&unk_183BA7000;
    v9 = MEMORY[0x1E0C809B0];
  }
  v96[0] = v9;
  v96[1] = v10[197];
  v97 = ___ZL39nw_protocol_ipv6_frame_output_finalizerP8nw_framebPv_block_invoke_47;
  v98 = &unk_1E14AC818;
  v99 = v111;
  v100 = v110;
  v101 = a3;
  v102 = a1;
  v104 = v22;
  v105 = v11;
  v103 = v6;
  v32 = v110[0];
  do
  {
    if (!v32)
      break;
    v33 = *(_QWORD *)(v32 + 32);
    v34 = ((uint64_t (*)(_QWORD *))v97)(v96);
    v32 = v33;
  }
  while ((v34 & 1) != 0);
  v35 = *(a3 - 8);
  if (v35)
  {
    v36 = *(void **)(v35 + 40);
    if (v36 == &nw_protocol_ref_counted_handle)
    {
      v37 = *(_QWORD *)(v35 + 88);
      if (v37)
        *(_QWORD *)(v35 + 88) = v37 + 1;
    }
    v38 = *(_QWORD *)(v35 + 24);
    if (v38)
    {
      v39 = *(void (**)(uint64_t, _QWORD *))(v38 + 96);
      if (v39)
      {
        v39(v35, v110);
LABEL_46:
        if (v36 != &nw_protocol_ref_counted_handle)
          goto LABEL_48;
        if (*(_UNKNOWN **)(v35 + 40) != &nw_protocol_ref_counted_handle)
          goto LABEL_48;
        v50 = *(_QWORD *)(v35 + 88);
        if (!v50)
          goto LABEL_48;
        v51 = v50 - 1;
        *(_QWORD *)(v35 + 88) = v51;
        if (v51)
          goto LABEL_48;
        v52 = *(void (***)(_QWORD))(v35 + 64);
        if (v52)
        {
          *(_QWORD *)(v35 + 64) = 0;
          v52[2](v52);
          _Block_release(v52);
        }
        if ((*(_BYTE *)(v35 + 72) & 1) != 0)
        {
          v53 = *(const void **)(v35 + 64);
          if (v53)
            _Block_release(v53);
        }
        goto LABEL_76;
      }
    }
    __nwlog_obj();
    v67 = *(const char **)(v35 + 16);
    *(_DWORD *)buf = 136446722;
    v117 = "__nw_protocol_finalize_output_frames";
    if (!v67)
      v67 = "invalid";
    v118 = 2082;
    v119 = (char *)v67;
    v120 = 2048;
    v121 = (const char *)v35;
    v68 = (char *)_os_log_send_and_compose_impl();
    v115 = OS_LOG_TYPE_ERROR;
    v114 = 0;
    if (__nwlog_fault(v68, &v115, &v114))
    {
      if (v115 == OS_LOG_TYPE_FAULT)
      {
        v69 = __nwlog_obj();
        v70 = v115;
        if (!os_log_type_enabled(v69, v115))
          goto LABEL_159;
        v71 = *(const char **)(v35 + 16);
        if (!v71)
          v71 = "invalid";
        *(_DWORD *)buf = 136446722;
        v117 = "__nw_protocol_finalize_output_frames";
        v118 = 2082;
        v119 = (char *)v71;
        v120 = 2048;
        v121 = (const char *)v35;
        v72 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
        goto LABEL_158;
      }
      if (!v114)
      {
        v69 = __nwlog_obj();
        v70 = v115;
        if (!os_log_type_enabled(v69, v115))
          goto LABEL_159;
        v90 = *(const char **)(v35 + 16);
        if (!v90)
          v90 = "invalid";
        *(_DWORD *)buf = 136446722;
        v117 = "__nw_protocol_finalize_output_frames";
        v118 = 2082;
        v119 = (char *)v90;
        v120 = 2048;
        v121 = (const char *)v35;
        v72 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_158;
      }
      v80 = (char *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = v115;
      v81 = os_log_type_enabled(v69, v115);
      if (v80)
      {
        if (v81)
        {
          v82 = *(const char **)(v35 + 16);
          if (!v82)
            v82 = "invalid";
          *(_DWORD *)buf = 136446978;
          v117 = "__nw_protocol_finalize_output_frames";
          v118 = 2082;
          v119 = (char *)v82;
          v120 = 2048;
          v121 = (const char *)v35;
          v122 = 2082;
          v123 = v80;
          _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v80);
        goto LABEL_159;
      }
      if (v81)
      {
        v91 = *(const char **)(v35 + 16);
        if (!v91)
          v91 = "invalid";
        *(_DWORD *)buf = 136446722;
        v117 = "__nw_protocol_finalize_output_frames";
        v118 = 2082;
        v119 = (char *)v91;
        v120 = 2048;
        v121 = (const char *)v35;
        v72 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_158:
        _os_log_impl(&dword_182FBE000, v69, v70, v72, buf, 0x20u);
      }
    }
LABEL_159:
    if (v68)
      free(v68);
    goto LABEL_46;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v117 = "__nw_protocol_finalize_output_frames";
  v35 = _os_log_send_and_compose_impl();
  v115 = OS_LOG_TYPE_ERROR;
  v114 = 0;
  if (!__nwlog_fault((const char *)v35, &v115, &v114))
  {
LABEL_166:
    if (!v35)
      goto LABEL_48;
    goto LABEL_76;
  }
  if (v115 == OS_LOG_TYPE_FAULT)
  {
    v77 = __nwlog_obj();
    v78 = v115;
    if (!os_log_type_enabled(v77, v115))
      goto LABEL_166;
    *(_DWORD *)buf = 136446210;
    v117 = "__nw_protocol_finalize_output_frames";
    v79 = "%{public}s called with null protocol";
LABEL_165:
    _os_log_impl(&dword_182FBE000, v77, v78, v79, buf, 0xCu);
    goto LABEL_166;
  }
  if (!v114)
  {
    v77 = __nwlog_obj();
    v78 = v115;
    if (!os_log_type_enabled(v77, v115))
      goto LABEL_166;
    *(_DWORD *)buf = 136446210;
    v117 = "__nw_protocol_finalize_output_frames";
    v79 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_165;
  }
  v88 = (char *)__nw_create_backtrace_string();
  v77 = __nwlog_obj();
  v78 = v115;
  v89 = os_log_type_enabled(v77, v115);
  if (!v88)
  {
    if (!v89)
      goto LABEL_166;
    *(_DWORD *)buf = 136446210;
    v117 = "__nw_protocol_finalize_output_frames";
    v79 = "%{public}s called with null protocol, no backtrace";
    goto LABEL_165;
  }
  if (v89)
  {
    *(_DWORD *)buf = 136446466;
    v117 = "__nw_protocol_finalize_output_frames";
    v118 = 2082;
    v119 = v88;
    _os_log_impl(&dword_182FBE000, v77, v78, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v88);
  if (!v35)
    goto LABEL_48;
LABEL_76:
  free((void *)v35);
LABEL_48:
  _Block_object_dispose(v111, 8);
LABEL_49:
  nw_frame_free_buffer((uint64_t)a1);
  v40 = *((_QWORD *)a1 + 2);
  v41 = (_QWORD *)*((_QWORD *)a1 + 3);
  if (v40)
  {
    *(_QWORD *)(v40 + 24) = v41;
    v41 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    a3[16] = v41;
  }
  *v41 = v40;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  os_release(a1);
}

uint64_t ___ZL34nw_protocol_ipv6_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, _DWORD *a2)
{
  int v3;
  unsigned int v4;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 158) & 2) != 0)
  {
    v4 = nw_frame_unclaimed_length(a2);
    if (v4 >= 0x500)
      v3 = v4 - 1280;
    else
      v3 = 0;
  }
  else
  {
    v3 = 0;
  }
  nw_frame_claim((uint64_t)a2, (uint64_t)a2, 40, v3);
  return 1;
}

uint64_t ___ZL39nw_protocol_ipv6_frame_output_finalizerP8nw_framebPv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL39nw_protocol_ipv6_frame_output_finalizerP8nw_framebPv_block_invoke_47(uint64_t a1, uint64_t a2)
{
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v22;
  _BOOL4 v23;
  const char *v24;
  const char *v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  NSObject *v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  int v34;
  int v35;
  unint64_t v36;
  char *backtrace_string;
  _BOOL4 v38;
  char *v39;
  unsigned int v40;
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  void *v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_DWORD *)(a1 + 72)
    || (v40 = 0, v4 = (unsigned int *)nw_frame_unclaimed_bytes(a2, &v40), v5 = v40, v40 <= 0x2F))
  {
    v6 = *(_QWORD *)(a2 + 32);
    v7 = *(_QWORD **)(a2 + 40);
    if (v6)
    {
      *(_QWORD *)(v6 + 40) = v7;
      v7 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) = v7;
    }
    *v7 = v6;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
    return 1;
  }
  v8 = v4;
  v9 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    v10 = *(_DWORD *)(v9 + 136);
    if (v40 > v10)
    {
      v40 = *(_DWORD *)(v9 + 136);
      v5 = v10;
    }
    v11 = v5 - 48;
    v12 = (*(_DWORD *)(a1 + 72) - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    if ((v11 & 0xFFFFFFF8) >= v12)
      v13 = v12;
    else
      v13 = v11 & 0xFFFFFFF8;
    v14 = *(_QWORD *)(v9 + 48);
    if (v14)
      ++*(_QWORD *)(v14 + 232);
    v15 = *(_DWORD *)(v9 + 144) & 0xFFFFFF0F;
    *v4 = v15;
    v16 = *(_QWORD *)(a1 + 56);
    if (v16)
    {
      v17 = (*(_BYTE *)(v16 + 186) & 3) << 20;
LABEL_17:
      *v8 = v15 | bswap32(v17);
      *(_BYTE *)v8 = 96;
      *((_BYTE *)v8 + 6) = 44;
      *((_BYTE *)v8 + 7) = *(_BYTE *)(*(_QWORD *)(a1 + 48) + 157);
      *(_OWORD *)(v8 + 2) = *(_OWORD *)(*(_QWORD *)(a1 + 48) + 56);
      *(_OWORD *)(v8 + 6) = *(_OWORD *)(*(_QWORD *)(a1 + 48) + 72);
      *((_WORD *)v8 + 2) = bswap32(v13 + 8) >> 16;
      v18 = *(_QWORD *)(a1 + 48);
      *((_BYTE *)v8 + 40) = *(_BYTE *)(v18 + 156);
      *((_BYTE *)v8 + 41) = 0;
      v8[11] = *(_DWORD *)(a1 + 76);
      *((_WORD *)v8 + 21) = (bswap32(*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)) >> 16) | ((v11 <= v12) << 8);
      ++*(_QWORD *)v18;
      if ((*(_BYTE *)(v18 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v30 = __nwlog_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            v31 = *(_QWORD *)(a1 + 48);
            v32 = (const char *)(v31 + 159);
            v33 = "";
            if (!v31)
              v32 = "";
            v34 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            if (v31)
              v33 = " ";
            v35 = *(_DWORD *)(a1 + 76);
            *(_DWORD *)buf = 136447746;
            v44 = "nw_protocol_ipv6_frame_output_finalizer_block_invoke";
            v45 = 2082;
            v46 = (void *)v32;
            v47 = 2080;
            v48 = v33;
            v49 = 2048;
            v50 = v31;
            v51 = 1024;
            v52 = v13;
            v53 = 1024;
            v54 = v34;
            v55 = 1024;
            v56 = v35;
            _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Writing fragment of length %u at offset %u with ID %u", buf, 0x3Cu);
          }
        }
      }
      memcpy(v8 + 12, (const void *)(*(_QWORD *)(a1 + 64) + *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)), v13);
      nw_frame_claim(a2, v19, v13 + 48, 0);
      nw_frame_collapse(a2);
      nw_frame_unclaim(a2, v20, v13 + 48, 0);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v13;
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v44 = "__nw_frame_get_ecn_flag";
    v26 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    v39 = (char *)v26;
    if (__nwlog_fault(v26, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v27 = __nwlog_obj();
        v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v44 = "__nw_frame_get_ecn_flag";
          v29 = "%{public}s called with null frame";
LABEL_49:
          _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
        }
      }
      else
      {
        v36 = v11;
        if (v41)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v27 = __nwlog_obj();
          v28 = type;
          v38 = os_log_type_enabled(v27, type);
          if (backtrace_string)
          {
            if (v38)
            {
              *(_DWORD *)buf = 136446466;
              v44 = "__nw_frame_get_ecn_flag";
              v45 = 2082;
              v46 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            v11 = v36;
            goto LABEL_50;
          }
          v11 = v36;
          if (v38)
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_get_ecn_flag";
            v29 = "%{public}s called with null frame, no backtrace";
            goto LABEL_49;
          }
        }
        else
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (os_log_type_enabled(v27, type))
          {
            *(_DWORD *)buf = 136446210;
            v44 = "__nw_frame_get_ecn_flag";
            v29 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_49;
          }
        }
      }
    }
LABEL_50:
    if (v39)
      free(v39);
    v17 = 0;
    v15 = *v8;
    goto LABEL_17;
  }
  if (!v9 || (*(_BYTE *)(v9 + 158) & 1) == 0)
  {
    v22 = __nwlog_obj();
    v23 = os_log_type_enabled(v22, OS_LOG_TYPE_INFO);
    v9 = *(_QWORD *)(a1 + 48);
    if (v23)
    {
      v24 = (const char *)(v9 + 159);
      if (!v9)
        v24 = "";
      *(_DWORD *)buf = 136446978;
      v44 = "nw_protocol_ipv6_frame_output_finalizer_block_invoke";
      v45 = 2082;
      v46 = (void *)v24;
      v25 = " ";
      if (!v9)
        v25 = "";
      v47 = 2080;
      v48 = v25;
      v49 = 2048;
      v50 = v9;
      _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Fragment frame is no longer valid", buf, 0x2Au);
      v9 = *(_QWORD *)(a1 + 48);
    }
  }
  *(_QWORD *)(v9 + 48) = 0;
  return 1;
}

uint64_t ___ZL33nw_protocol_ipv6_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2, __n128 a3, __n128 a4)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  const char *v16;
  int v17;
  uint64_t v18;
  _QWORD *v19;
  char *v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *backtrace_string;
  _BOOL4 v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  char *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1[4] + 8);
  if (!*(_BYTE *)(v6 + 24))
  {
    if (a2)
    {
      v8 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
      goto LABEL_12;
    }
LABEL_49:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "__nw_frame_is_single_ip_aggregate";
    v32 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v32, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "__nw_frame_is_single_ip_aggregate";
          v35 = "%{public}s called with null frame";
LABEL_62:
          _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
        }
      }
      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = type;
        v37 = os_log_type_enabled(v33, type);
        if (backtrace_string)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446466;
            v41 = "__nw_frame_is_single_ip_aggregate";
            v42 = 2082;
            v43 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_63;
        }
        if (v37)
        {
          *(_DWORD *)buf = 136446210;
          v41 = "__nw_frame_is_single_ip_aggregate";
          v35 = "%{public}s called with null frame, no backtrace";
          goto LABEL_62;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "__nw_frame_is_single_ip_aggregate";
          v35 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_62;
        }
      }
    }
LABEL_63:
    if (v32)
      free(v32);
    LOBYTE(v17) = 0;
    v6 = *(_QWORD *)(a1[4] + 8);
    goto LABEL_13;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "__nw_frame_is_packet_chain_member";
    v26 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v26, &type, &v38))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v41 = "__nw_frame_is_packet_chain_member";
      v29 = "%{public}s called with null frame";
    }
    else if (v38)
    {
      v30 = (char *)__nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v28 = type;
      v31 = os_log_type_enabled(v27, type);
      if (v30)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v41 = "__nw_frame_is_packet_chain_member";
          v42 = 2082;
          v43 = v30;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v30);
        goto LABEL_47;
      }
      if (!v31)
      {
LABEL_47:
        if (v26)
          free(v26);
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      v41 = "__nw_frame_is_packet_chain_member";
      v29 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v41 = "__nw_frame_is_packet_chain_member";
      v29 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
    goto LABEL_47;
  }
  v7 = *(unsigned __int16 *)(a2 + 204);
  v8 = v7 | (*(unsigned __int8 *)(a2 + 206) << 16);
  if ((v7 & 0x40) == 0)
  {
LABEL_12:
    v17 = (v8 >> 7) & 1;
LABEL_13:
    *(_BYTE *)(v6 + 24) = v17;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = nw_protocol_ipv6_process_input_frame(a1[9], a2, a1[8], a1[10], (_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24), (_DWORD *)(*(_QWORD *)(a1[7] + 8) + 24), a3, a4);
    if (*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
      return 1;
    --*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
    goto LABEL_15;
  }
  if (*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
    return 1;
  v9 = *(_QWORD *)(a1[6] + 8);
  v10 = *(_DWORD *)(v9 + 24);
  *(_DWORD *)(v9 + 24) = v10 - 1;
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
    *(_DWORD *)buf = 136446978;
    v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
    v42 = 2082;
    v43 = "count";
    v44 = 2048;
    v45 = 1;
    v46 = 2048;
    v47 = v11;
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v12, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v15 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
          v42 = 2082;
          v43 = "count";
          v44 = 2048;
          v45 = 1;
          v46 = 2048;
          v47 = v15;
          v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_29:
          _os_log_impl(&dword_182FBE000, v13, v14, v16, buf, 0x2Au);
        }
      }
      else if (v38)
      {
        v21 = (char *)__nw_create_backtrace_string();
        v13 = __nwlog_obj();
        v14 = type;
        v22 = os_log_type_enabled(v13, type);
        if (v21)
        {
          if (v22)
          {
            v23 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
            v42 = 2082;
            v43 = "count";
            v44 = 2048;
            v45 = 1;
            v46 = 2048;
            v47 = v23;
            v48 = 2082;
            v49 = v21;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v21);
          goto LABEL_30;
        }
        if (v22)
        {
          v25 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
          v42 = 2082;
          v43 = "count";
          v44 = 2048;
          v45 = 1;
          v46 = 2048;
          v47 = v25;
          v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_29;
        }
      }
      else
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          v24 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v41 = "nw_protocol_ipv6_get_input_frames_block_invoke";
          v42 = 2082;
          v43 = "count";
          v44 = 2048;
          v45 = 1;
          v46 = 2048;
          v47 = v24;
          v16 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }
LABEL_30:
    if (v12)
      free(v12);
    *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = 0;
  }
LABEL_15:
  v18 = *(_QWORD *)(a2 + 32);
  v19 = *(_QWORD **)(a2 + 40);
  if (v18)
  {
    *(_QWORD *)(v18 + 40) = v19;
    v19 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(a1[8] + 8) = v19;
  }
  *v19 = v18;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t nw_protocol_ipv6_process_reassembly(uint64_t a1, int a2, uint64_t a3, int a4, _BYTE *a5)
{
  uint64_t v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  const char *v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *backtrace_string;
  _BOOL4 v36;
  char *v37;
  _BOOL4 v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  int i;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  NSObject *v53;
  int v54;
  NSObject *v55;
  int v56;
  NSObject *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  NSObject *v62;
  int v63;
  char *v64;
  _BOOL4 v65;
  NSObject *log;
  os_log_type_t v67;
  uint64_t v68;
  char *v69;
  os_log_type_t type[8];
  uint64_t v71;
  uint64_t (*v72)(uint64_t, uint64_t);
  void *v73;
  uint64_t v74;
  _QWORD v75[3];
  int v76;
  unsigned int v77;
  _QWORD v78[2];
  uint64_t (*v79)(_QWORD *);
  void *v80;
  uint64_t *v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  __int16 v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  char v91;
  _BYTE buf[32];
  __int128 v93;
  _BYTE v94[12];
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 88);
  if (!v8)
  {
    v12 = 0;
    goto LABEL_82;
  }
  if (!a5 && *(_DWORD *)(a1 + 148) == a2 && a4 == 0)
  {
    v12 = 0;
LABEL_83:
    *(_DWORD *)(a1 + 148) = a2;
    return v12;
  }
  if (!a3)
  {
    v12 = 0;
    if (!a4)
      goto LABEL_82;
    goto LABEL_75;
  }
  v88 = 0;
  v89 = &v88;
  v90 = 0x2000000000;
  v91 = 0;
  v84 = 0;
  v85 = &v84;
  v86 = 0x2000000000;
  v87 = 0;
  v13 = MEMORY[0x1E0C809B0];
  v78[0] = MEMORY[0x1E0C809B0];
  v78[1] = 0x40000000;
  v79 = (uint64_t (*)(_QWORD *))___ZL43nw_protocol_ipv6_append_reassembled_packetsP16nw_protocol_ipv6P16nw_frame_array_sPb_block_invoke;
  v80 = &unk_1E14AC768;
  v82 = &v88;
  v83 = a1;
  v81 = &v84;
  do
  {
    if (!v8)
      break;
    v14 = *(_QWORD *)(v8 + 32);
    v15 = v79(v78);
    v8 = v14;
  }
  while ((v15 & 1) != 0);
  if (!*((_BYTE *)v89 + 24))
  {
    if ((*(_BYTE *)(a1 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v62 = __nwlog_obj();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
        {
          v63 = *(_DWORD *)(a1 + 148);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = " ";
          LOWORD(v93) = 2048;
          *(_QWORD *)((char *)&v93 + 2) = a1;
          WORD5(v93) = 1024;
          HIDWORD(v93) = v63;
          _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Fragments for IPv6 Fragment ID %u incomplete", buf, 0x30u);
        }
      }
    }
    v12 = 0;
    if (a5)
      *a5 = 1;
    goto LABEL_74;
  }
  v16 = *((unsigned __int16 *)v85 + 12) + 40;
  v17 = nw_calloc_type<unsigned char>(*((unsigned __int16 *)v85 + 12) + 40);
  v18 = nw_frame_create(0, v17, v16, (uint64_t)nw_protocol_ipv6_frame_input_finalizer, a1);
  if (!v18)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    v31 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v75[0]) = 0;
    if (__nwlog_fault(v31, type, v75))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v32 = __nwlog_obj();
        v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v16;
          v34 = "%{public}s nw_frame_create(%u) failed";
LABEL_54:
          _os_log_impl(&dword_182FBE000, v32, v33, v34, buf, 0x12u);
        }
      }
      else if (LOBYTE(v75[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v32 = __nwlog_obj();
        v33 = type[0];
        v36 = os_log_type_enabled(v32, type[0]);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v16;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s nw_frame_create(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(backtrace_string);
          goto LABEL_55;
        }
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v16;
          v34 = "%{public}s nw_frame_create(%u) failed, no backtrace";
          goto LABEL_54;
        }
      }
      else
      {
        v32 = __nwlog_obj();
        v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v16;
          v34 = "%{public}s nw_frame_create(%u) failed, backtrace limit exceeded";
          goto LABEL_54;
        }
      }
    }
LABEL_55:
    if (v31)
      free(v31);
    if (v17)
      free((void *)v17);
    v12 = 0;
    goto LABEL_74;
  }
  v19 = v18;
  if ((*(_BYTE *)(a1 + 158) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v55 = __nwlog_obj();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        v56 = *(_DWORD *)(a1 + 148);
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v93) = 2048;
        *(_QWORD *)((char *)&v93 + 2) = a1;
        WORD5(v93) = 1024;
        HIDWORD(v93) = v56;
        *(_WORD *)v94 = 1024;
        *(_DWORD *)&v94[2] = v16;
        _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Fragments for IPv6 Fragment ID %u are complete, aggregate length %u", buf, 0x36u);
      }
    }
  }
  v20 = *(_QWORD *)(a1 + 88);
  v77 = 0;
  v21 = nw_frame_unclaimed_bytes(v20, &v77);
  if (v21)
  {
    if (v77 > 0x27)
    {
      v23 = *(_QWORD *)(v21 + 32);
      v24 = *(_OWORD *)(v21 + 16);
      *(_OWORD *)v17 = *(_OWORD *)v21;
      *(_OWORD *)(v17 + 16) = v24;
      *(_QWORD *)(v17 + 32) = v23;
      *(_WORD *)(v17 + 4) = bswap32(*((unsigned __int16 *)v85 + 12)) >> 16;
      if ((*(_WORD *)(v19 + 204) & 8) == 0)
      {
        v25 = v19 + 120;
        v26 = *(void **)(v19 + 168);
        if (v26)
        {
          os_release(v26);
          v25 = v19 + 120;
          *(_QWORD *)(v19 + 168) = 0;
        }
        v27 = *(_QWORD *)(v19 + 64);
        *(_BYTE *)(v19 + 186) |= 0x40u;
        if (v27)
        {
          if (v27 != v25)
          {
            v28 = v25;
            __nwlog_obj();
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v27;
            *(_WORD *)&buf[22] = 2048;
            v68 = v28;
            *(_QWORD *)&buf[24] = v28;
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v75[0]) = 0;
            v69 = (char *)_os_log_send_and_compose_impl();
            if (__nwlog_fault(v69, type, v75))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                v29 = __nwlog_obj();
                v67 = type[0];
                if (os_log_type_enabled(v29, type[0]))
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v27;
                  *(_WORD *)&buf[22] = 2048;
                  *(_QWORD *)&buf[24] = v68;
                  v30 = "%{public}s Existing metadata %p doesn't match expected %p";
LABEL_62:
                  v39 = v29;
LABEL_63:
                  _os_log_impl(&dword_182FBE000, v39, v67, v30, buf, 0x20u);
                }
              }
              else if (LOBYTE(v75[0]))
              {
                v37 = (char *)__nw_create_backtrace_string();
                log = __nwlog_obj();
                v67 = type[0];
                v38 = os_log_type_enabled(log, type[0]);
                if (v37)
                {
                  if (v38)
                  {
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v27;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)&buf[24] = v68;
                    LOWORD(v93) = 2082;
                    *(_QWORD *)((char *)&v93 + 2) = v37;
                    _os_log_impl(&dword_182FBE000, log, v67, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
                  }
                  free(v37);
                  goto LABEL_64;
                }
                if (v38)
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v27;
                  *(_WORD *)&buf[22] = 2048;
                  *(_QWORD *)&buf[24] = v68;
                  v30 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
                  v39 = log;
                  goto LABEL_63;
                }
              }
              else
              {
                v29 = __nwlog_obj();
                v67 = type[0];
                if (os_log_type_enabled(v29, type[0]))
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v27;
                  *(_WORD *)&buf[22] = 2048;
                  *(_QWORD *)&buf[24] = v68;
                  v30 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
                  goto LABEL_62;
                }
              }
            }
LABEL_64:
            if (v69)
              free(v69);
            v13 = MEMORY[0x1E0C809B0];
          }
        }
        else
        {
          *(_QWORD *)(v19 + 64) = v25;
          *(_QWORD *)(v19 + 72) = v25;
          *(_QWORD *)(v19 + 120) = 0;
          *(_QWORD *)(v19 + 128) = v19 + 64;
        }
      }
      nw_frame_claim(v19, v22, 40, 0);
      v75[0] = 0;
      v75[1] = v75;
      v76 = 40;
      v75[2] = 0x2000000000;
      *(_QWORD *)buf = v13;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL43nw_protocol_ipv6_append_reassembled_packetsP16nw_protocol_ipv6P16nw_frame_array_sPb_block_invoke_41;
      *(_QWORD *)&buf[24] = &unk_1E14AC790;
      *(_QWORD *)&v93 = v75;
      *((_QWORD *)&v93 + 1) = a1;
      *(_DWORD *)&v94[8] = v16;
      *(_QWORD *)v94 = v17;
      v40 = *(_QWORD *)(a1 + 88);
      do
      {
        if (!v40)
          break;
        v41 = *(_QWORD *)(v40 + 32);
        v42 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v40 = v41;
      }
      while ((v42 & 1) != 0);
      *(_QWORD *)(v19 + 16) = 0;
      v43 = *(uint64_t **)(a1 + 112);
      *(_QWORD *)(v19 + 24) = v43;
      *v43 = v19;
      *(_QWORD *)(a1 + 112) = v19 + 16;
      *(_QWORD *)(v19 + 32) = 0;
      v44 = *(uint64_t **)(a3 + 8);
      *(_QWORD *)(v19 + 40) = v44;
      *v44 = v19;
      *(_QWORD *)(a3 + 8) = v19 + 32;
      *(_QWORD *)type = v13;
      v71 = 0x40000000;
      v72 = ___ZL43nw_protocol_ipv6_append_reassembled_packetsP16nw_protocol_ipv6P16nw_frame_array_sPb_block_invoke_43;
      v73 = &__block_descriptor_tmp_44_85461;
      v74 = a1;
      v45 = *(_QWORD *)(a1 + 88);
      do
      {
        if (!v45)
          break;
        v46 = *(_QWORD *)(v45 + 32);
        v47 = ((uint64_t (*)(os_log_type_t *))v72)(type);
        v45 = v46;
      }
      while ((v47 & 1) != 0);
      _Block_object_dispose(v75, 8);
      v12 = 1;
      goto LABEL_74;
    }
    if ((*(_BYTE *)(a1 + 158) & 1) != 0)
    {
LABEL_115:
      os_release((void *)v19);
      v12 = 0;
      goto LABEL_74;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136447234;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 159;
    *(_WORD *)&buf[22] = 2080;
    *(_QWORD *)&buf[24] = " ";
    LOWORD(v93) = 2048;
    *(_QWORD *)((char *)&v93 + 2) = a1;
    WORD5(v93) = 1024;
    HIDWORD(v93) = v77;
    v58 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v75[0]) = 0;
    if (__nwlog_fault(v58, type, v75))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v59 = __nwlog_obj();
        v60 = type[0];
        if (!os_log_type_enabled(v59, type[0]))
          goto LABEL_113;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v93) = 2048;
        *(_QWORD *)((char *)&v93 + 2) = a1;
        WORD5(v93) = 1024;
        HIDWORD(v93) = v77;
        v61 = "%{public}s %{public}s%s%p Invalid first IPv6 reassembly frame (length %u)";
        goto LABEL_112;
      }
      if (!LOBYTE(v75[0]))
      {
        v59 = __nwlog_obj();
        v60 = type[0];
        if (!os_log_type_enabled(v59, type[0]))
          goto LABEL_113;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v93) = 2048;
        *(_QWORD *)((char *)&v93 + 2) = a1;
        WORD5(v93) = 1024;
        HIDWORD(v93) = v77;
        v61 = "%{public}s %{public}s%s%p Invalid first IPv6 reassembly frame (length %u), backtrace limit exceeded";
        goto LABEL_112;
      }
      v64 = (char *)__nw_create_backtrace_string();
      v59 = __nwlog_obj();
      v60 = type[0];
      v65 = os_log_type_enabled(v59, type[0]);
      if (v64)
      {
        if (v65)
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = " ";
          LOWORD(v93) = 2048;
          *(_QWORD *)((char *)&v93 + 2) = a1;
          WORD5(v93) = 1024;
          HIDWORD(v93) = v77;
          *(_WORD *)v94 = 2082;
          *(_QWORD *)&v94[2] = v64;
          _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s %{public}s%s%p Invalid first IPv6 reassembly frame (length %u), dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(v64);
        goto LABEL_113;
      }
      if (v65)
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v93) = 2048;
        *(_QWORD *)((char *)&v93 + 2) = a1;
        WORD5(v93) = 1024;
        HIDWORD(v93) = v77;
        v61 = "%{public}s %{public}s%s%p Invalid first IPv6 reassembly frame (length %u), no backtrace";
LABEL_112:
        _os_log_impl(&dword_182FBE000, v59, v60, v61, buf, 0x30u);
      }
    }
LABEL_113:
    if (v58)
      free(v58);
    goto LABEL_115;
  }
  if ((*(_BYTE *)(a1 + 158) & 1) == 0)
  {
    v57 = __nwlog_obj();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_append_reassembled_packets";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 159;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = " ";
      LOWORD(v93) = 2048;
      *(_QWORD *)((char *)&v93 + 2) = a1;
      _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
    }
  }
  *(_QWORD *)(a1 + 48) = 0;
  v12 = 0;
LABEL_74:
  _Block_object_dispose(&v84, 8);
  _Block_object_dispose(&v88, 8);
  if (!a4)
    goto LABEL_82;
LABEL_75:
  for (i = 0; ; ++i)
  {
    v49 = *(_QWORD *)(a1 + 88);
    if (!v49)
      break;
    v50 = *(_QWORD *)(v49 + 32);
    v51 = *(_QWORD **)(v49 + 40);
    if (v50)
    {
      *(_QWORD *)(v50 + 40) = v51;
      v51 = *(_QWORD **)(v49 + 40);
    }
    else
    {
      *(_QWORD *)(a1 + 96) = v51;
    }
    *v51 = v50;
    *(_QWORD *)(v49 + 32) = 0;
    *(_QWORD *)(v49 + 40) = 0;
    nw_frame_finalize(v49);
  }
  if (i)
  {
    if ((*(_BYTE *)(a1 + 158) & 1) == 0)
    {
      v53 = __nwlog_obj();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        v54 = *(_DWORD *)(a1 + 148);
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_reassembly";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v93) = 2048;
        *(_QWORD *)((char *)&v93 + 2) = a1;
        WORD5(v93) = 1024;
        HIDWORD(v93) = v54;
        *(_WORD *)v94 = 1024;
        *(_DWORD *)&v94[2] = i;
        _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Failed to reassemble IPv6 Fragmentation ID %u, dropping %u frames", buf, 0x36u);
      }
    }
  }
LABEL_82:
  if (!a5)
    goto LABEL_83;
  return v12;
}

uint64_t ___ZL33nw_protocol_ipv6_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_36(_QWORD *a1, uint64_t a2, __n128 a3, __n128 a4)
{
  uint64_t v6;
  _QWORD *v7;

  if (!nw_protocol_ipv6_process_input_frame(a1[7], a2, a1[8], a1[9], (_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24), (_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24), a3, a4))
  {
    --*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v6 = *(_QWORD *)(a2 + 32);
    v7 = *(_QWORD **)(a2 + 40);
    if (v6)
    {
      *(_QWORD *)(v6 + 40) = v7;
      v7 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(a1[8] + 8) = v7;
    }
    *v7 = v6;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
    *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  }
  return 1;
}

uint64_t ___ZL33nw_protocol_ipv6_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 32);
  v4 = *(_QWORD **)(a2 + 40);
  if (v3)
  {
    *(_QWORD *)(v3 + 40) = v4;
    v4 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v4;
  }
  *v4 = v3;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5 || (*(_BYTE *)(v5 + 158) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 40);
      v8 = (const char *)(v7 + 159);
      if (!v7)
        v8 = "";
      v11 = 136446978;
      v12 = "nw_protocol_ipv6_get_input_frames_block_invoke_2";
      v13 = 2082;
      v14 = v8;
      if (v7)
        v9 = " ";
      else
        v9 = "";
      v15 = 2080;
      v16 = v9;
      v17 = 2048;
      v18 = v7;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Dropping unused IPv6 extra fragment", (uint8_t *)&v11, 0x2Au);
    }
  }
  return 1;
}

BOOL nw_protocol_ipv6_process_input_frame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, __n128 a7, __n128 a8)
{
  uint64_t v14;
  int v15;
  unsigned int v16;
  int *v17;
  _QWORD *v18;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  int v24;
  _QWORD *v25;
  char v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  os_log_type_t v32;
  const char *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  _BOOL4 v37;
  NSObject *v38;
  os_log_type_t v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  unsigned int v44;
  const char *v45;
  unsigned __int8 *v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  unsigned __int8 *v50;
  int v51;
  unsigned int v52;
  const char *v53;
  _BOOL4 v54;
  char v55;
  __int16 v56;
  const char *v57;
  char *v58;
  uint64_t v59;
  os_log_type_t v60;
  const char *v61;
  char *v62;
  os_log_type_t v63;
  _BOOL4 v64;
  int v65;
  char v66;
  __int16 v67;
  uint64_t v68;
  const char *v69;
  NSObject *v70;
  uint32_t v71;
  NSObject *v72;
  os_log_type_t v73;
  char v74;
  __int16 v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  _QWORD *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  uint64_t *v85;
  uint64_t *v86;
  uint64_t v87;
  _QWORD *v88;
  _QWORD *v89;
  uint64_t *v90;
  _BOOL8 result;
  NSObject *v92;
  NSObject *v93;
  NSObject *v94;
  char *v95;
  NSObject *v96;
  os_log_type_t v97;
  const char *v98;
  NSObject *v99;
  NSObject *v100;
  uint64_t v101;
  NSObject *v102;
  uint64_t v103;
  NSObject *v104;
  const char *v105;
  NSObject *v106;
  uint64_t v107;
  NSObject *v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  char *backtrace_string;
  _BOOL4 v113;
  const char *v114;
  _BOOL4 v115;
  _BOOL4 v116;
  _BOOL4 v117;
  NSObject *log;
  unsigned int v119;
  int v120;
  NSObject *v121;
  __n128 v122;
  __n128 v123;
  unsigned __int32 v124;
  unsigned __int32 v125;
  __n128 v126;
  __n128 v127;
  NSObject *v128;
  int v129;
  int v130;
  uint64_t v131;
  _DWORD *v132;
  unsigned int v133;
  uint64_t v134;
  _DWORD *v135;
  _QWORD v136[2];
  uint64_t (*v137)(uint64_t, uint64_t);
  void *v138;
  _BYTE *v139;
  uint64_t v140;
  uint64_t v141;
  __int16 v142;
  char v143;
  os_log_type_t v144;
  _BYTE buf[24];
  const char *v146;
  __int16 v147;
  uint64_t v148;
  __int16 v149;
  __int128 v150;
  uint64_t v151;

  v151 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    v95 = (char *)_os_log_send_and_compose_impl();
    v144 = OS_LOG_TYPE_ERROR;
    v143 = 0;
    if (!__nwlog_fault(v95, &v144, &v143))
      goto LABEL_232;
    if (v144 == OS_LOG_TYPE_FAULT)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null ipv6";
      goto LABEL_231;
    }
    if (!v143)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null ipv6, backtrace limit exceeded";
      goto LABEL_231;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v96 = __nwlog_obj();
    v97 = v144;
    v113 = os_log_type_enabled(v96, v144);
    if (!backtrace_string)
    {
      if (!v113)
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null ipv6, no backtrace";
      goto LABEL_231;
    }
    if (!v113)
      goto LABEL_214;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v114 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
LABEL_213:
    _os_log_impl(&dword_182FBE000, v96, v97, v114, buf, 0x16u);
    goto LABEL_214;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    v95 = (char *)_os_log_send_and_compose_impl();
    v144 = OS_LOG_TYPE_ERROR;
    v143 = 0;
    if (!__nwlog_fault(v95, &v144, &v143))
      goto LABEL_232;
    if (v144 == OS_LOG_TYPE_FAULT)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null frame";
      goto LABEL_231;
    }
    if (!v143)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_231;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v96 = __nwlog_obj();
    v97 = v144;
    v115 = os_log_type_enabled(v96, v144);
    if (!backtrace_string)
    {
      if (!v115)
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null frame, no backtrace";
      goto LABEL_231;
    }
    if (!v115)
      goto LABEL_214;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v114 = "%{public}s called with null frame, dumping backtrace:%{public}s";
    goto LABEL_213;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    v95 = (char *)_os_log_send_and_compose_impl();
    v144 = OS_LOG_TYPE_ERROR;
    v143 = 0;
    if (!__nwlog_fault(v95, &v144, &v143))
      goto LABEL_232;
    if (v144 == OS_LOG_TYPE_FAULT)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null count";
      goto LABEL_231;
    }
    if (!v143)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null count, backtrace limit exceeded";
      goto LABEL_231;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v96 = __nwlog_obj();
    v97 = v144;
    v116 = os_log_type_enabled(v96, v144);
    if (!backtrace_string)
    {
      if (!v116)
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null count, no backtrace";
      goto LABEL_231;
    }
    if (!v116)
      goto LABEL_214;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v114 = "%{public}s called with null count, dumping backtrace:%{public}s";
    goto LABEL_213;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    v95 = (char *)_os_log_send_and_compose_impl();
    v144 = OS_LOG_TYPE_ERROR;
    v143 = 0;
    if (!__nwlog_fault(v95, &v144, &v143))
      goto LABEL_232;
    if (v144 == OS_LOG_TYPE_FAULT)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null reassembly_count";
      goto LABEL_231;
    }
    if (!v143)
    {
      v96 = __nwlog_obj();
      v97 = v144;
      if (!os_log_type_enabled(v96, v144))
        goto LABEL_232;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      v98 = "%{public}s called with null reassembly_count, backtrace limit exceeded";
      goto LABEL_231;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v96 = __nwlog_obj();
    v97 = v144;
    v117 = os_log_type_enabled(v96, v144);
    if (backtrace_string)
    {
      if (v117)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v114 = "%{public}s called with null reassembly_count, dumping backtrace:%{public}s";
        goto LABEL_213;
      }
LABEL_214:
      free(backtrace_string);
      goto LABEL_232;
    }
    if (!v117)
      goto LABEL_232;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
    v98 = "%{public}s called with null reassembly_count, no backtrace";
LABEL_231:
    _os_log_impl(&dword_182FBE000, v96, v97, v98, buf, 0xCu);
LABEL_232:
    if (v95)
      free(v95);
    return 0;
  }
  if (!*(_QWORD *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
  {
    v16 = 0;
    v17 = 0;
  }
  else
  {
    v15 = *(_DWORD *)(a2 + 52);
    v14 = *(unsigned int *)(a2 + 56);
    if (v15)
      v16 = v15 - (v14 + *(_DWORD *)(a2 + 60));
    else
      v16 = 0;
    v17 = (int *)(*(_QWORD *)(a2 + 112) + v14);
  }
  if ((*(_WORD *)(a2 + 204) & 0x80) != 0)
    v16 = *(unsigned __int16 *)(a2 + 196);
  if (v17)
  {
    v18 = *(_QWORD **)(a1 + 48);
    if (v18)
      ++*v18;
    if (v16 <= 0x27)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        v100 = __nwlog_obj();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          v146 = " ";
          v147 = 2048;
          v148 = a1;
          v149 = 1024;
          LODWORD(v150) = v16;
          _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Received IPv6 packet with incorrect length %u", buf, 0x30u);
        }
      }
      v101 = *(_QWORD *)(a1 + 48);
      if (v101)
      {
        result = 0;
        ++*(_QWORD *)(v101 + 8);
        return result;
      }
      return 0;
    }
    if ((*(_BYTE *)v17 & 0xF0) != 0x60)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        v102 = __nwlog_obj();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          v146 = " ";
          v147 = 2048;
          v148 = a1;
          _os_log_impl(&dword_182FBE000, v102, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Not an IPv6 packet", buf, 0x2Au);
        }
      }
      v103 = *(_QWORD *)(a1 + 48);
      if (v103)
      {
        result = 0;
        ++*(_QWORD *)(v103 + 48);
        return result;
      }
      return 0;
    }
    if (*((_QWORD *)v17 + 1) != *(_QWORD *)(a1 + 72) || *((_QWORD *)v17 + 2) != *(_QWORD *)(a1 + 80))
    {
      if ((*(_BYTE *)(a1 + 158) & 1) != 0)
        return 0;
      v104 = __nwlog_obj();
      result = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 159;
      *(_WORD *)&buf[22] = 2080;
      v146 = " ";
      v147 = 2048;
      v148 = a1;
      v105 = "%{public}s %{public}s%s%p Received remote address that did not match";
LABEL_185:
      _os_log_impl(&dword_182FBE000, v104, OS_LOG_TYPE_ERROR, v105, buf, 0x2Au);
      return 0;
    }
    if (*((_QWORD *)v17 + 3) != *(_QWORD *)(a1 + 56) || *((_QWORD *)v17 + 4) != *(_QWORD *)(a1 + 64))
    {
      if ((*(_BYTE *)(a1 + 158) & 1) != 0)
        return 0;
      v104 = __nwlog_obj();
      result = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 159;
      *(_WORD *)&buf[22] = 2080;
      v146 = " ";
      v147 = 2048;
      v148 = a1;
      v105 = "%{public}s %{public}s%s%p Received local address that did not match";
      goto LABEL_185;
    }
    v134 = a4;
    v135 = a6;
    v21 = bswap32(*((unsigned __int16 *)v17 + 2)) >> 16;
    v22 = v21 + 40;
    if (v21 + 40 > (unint64_t)v16)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        v106 = __nwlog_obj();
        if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 159;
          *(_WORD *)&buf[22] = 2080;
          v146 = " ";
          v147 = 2048;
          v148 = a1;
          v149 = 1024;
          LODWORD(v150) = v21;
          WORD2(v150) = 1024;
          *(_DWORD *)((char *)&v150 + 6) = v16;
          _os_log_impl(&dword_182FBE000, v106, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Received IPv6 packet with incorrect length, expected %u received %u", buf, 0x36u);
        }
      }
      v107 = *(_QWORD *)(a1 + 48);
      if (v107)
      {
        result = 0;
        ++*(_QWORD *)(v107 + 16);
        return result;
      }
      return 0;
    }
    if (v21 + 40 != v16 && (*(_BYTE *)(a1 + 158) & 1) == 0)
    {
      v108 = __nwlog_obj();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        v146 = " ";
        v147 = 2048;
        v148 = a1;
        v149 = 1024;
        LODWORD(v150) = v21;
        WORD2(v150) = 1024;
        *(_DWORD *)((char *)&v150 + 6) = (unsigned __int16)(v16 - 40);
        _os_log_impl(&dword_182FBE000, v108, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Received length mismatch with IPv6 %u != %u", buf, 0x36u);
      }
    }
    v23 = *v17;
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xFC | (*v17 >> 12) & 3;
    v24 = (v23 >> 12) & 3;
    switch(v24)
    {
      case 3:
        v25 = (_QWORD *)(a1 + 32);
        break;
      case 2:
        v25 = (_QWORD *)(a1 + 24);
        break;
      case 1:
        v25 = (_QWORD *)(a1 + 16);
        break;
      default:
        goto LABEL_40;
    }
    ++*v25;
LABEL_40:
    v26 = *(_BYTE *)(a1 + 158);
    if ((v26 & 4) != 0)
    {
      v109 = mach_continuous_time();
      v110 = *(_WORD *)(a2 + 204) & 0xFFEF | (*(unsigned __int8 *)(a2 + 206) << 16);
      *(_WORD *)(a2 + 204) &= ~0x10u;
      *(_BYTE *)(a2 + 206) = BYTE2(v110);
      *(_QWORD *)(a2 + 152) = v109;
      v26 = *(_BYTE *)(a1 + 158);
    }
    v131 = a3;
    v132 = a5;
    v133 = v16;
    if ((v26 & 0x10) != 0)
      *(_BYTE *)(a2 + 185) = *((_BYTE *)v17 + 7);
    if ((*(_WORD *)(a2 + 204) & 8) != 0)
      goto LABEL_65;
    v27 = a2 + 120;
    v28 = *(void **)(a2 + 168);
    if (v28)
    {
      os_release(v28);
      *(_QWORD *)(a2 + 168) = 0;
    }
    v29 = *(_QWORD *)(a2 + 64);
    *(_BYTE *)(a2 + 186) |= 0x40u;
    if (v29)
    {
      if (v29 != v27)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v29;
        *(_WORD *)&buf[22] = 2048;
        v146 = (const char *)(a2 + 120);
        v30 = (char *)_os_log_send_and_compose_impl();
        v144 = OS_LOG_TYPE_ERROR;
        v143 = 0;
        if (!__nwlog_fault(v30, &v144, &v143))
          goto LABEL_63;
        if (v144 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = gLogObj;
          v32 = v144;
          if (!os_log_type_enabled((os_log_t)gLogObj, v144))
            goto LABEL_63;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2048;
          v146 = (const char *)(a2 + 120);
          v33 = "%{public}s Existing metadata %p doesn't match expected %p";
        }
        else
        {
          if (v143)
          {
            v34 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v35 = gLogObj;
            v36 = v144;
            v37 = os_log_type_enabled((os_log_t)gLogObj, v144);
            if (v34)
            {
              if (v37)
              {
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v29;
                *(_WORD *)&buf[22] = 2048;
                v146 = (const char *)(a2 + 120);
                v147 = 2082;
                v148 = (uint64_t)v34;
                _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
              }
              free(v34);
              goto LABEL_63;
            }
            if (!v37)
            {
LABEL_63:
              if (v30)
                free(v30);
              goto LABEL_65;
            }
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v29;
            *(_WORD *)&buf[22] = 2048;
            v146 = (const char *)(a2 + 120);
            v33 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
            v38 = v35;
            v39 = v36;
LABEL_62:
            _os_log_impl(&dword_182FBE000, v38, v39, v33, buf, 0x20u);
            goto LABEL_63;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = gLogObj;
          v32 = v144;
          if (!os_log_type_enabled((os_log_t)gLogObj, v144))
            goto LABEL_63;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2048;
          v146 = (const char *)(a2 + 120);
          v33 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
        }
        v38 = v31;
        v39 = v32;
        goto LABEL_62;
      }
    }
    else
    {
      *(_QWORD *)(a2 + 64) = v27;
      *(_QWORD *)(a2 + 72) = v27;
      *(_QWORD *)(a2 + 120) = 0;
      *(_QWORD *)(a2 + 128) = a2 + 64;
    }
LABEL_65:
    v40 = *((unsigned __int8 *)v17 + 6);
    if (v40 == *(unsigned __int8 *)(a1 + 156))
    {
      LOWORD(v41) = 0;
      v42 = 0;
      LOBYTE(v43) = 0;
      v44 = 40;
      goto LABEL_112;
    }
    v43 = 0;
    v42 = 0;
    v41 = 0;
    v44 = 40;
    a7.n128_u64[0] = 136447490;
    v45 = "%{public}s %{public}s%s%p Received IPv6 extension type %u length %u";
    a8.n128_u64[0] = 136447746;
    while (1)
    {
      if ((*(_WORD *)(a2 + 204) & 0x80) != 0)
      {
        v124 = a7.n128_u32[0];
        if ((*(_BYTE *)(a1 + 158) & 1) != 0)
          goto LABEL_112;
        v130 = v42;
        v55 = v43;
        v56 = v41;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        v146 = " ";
        v147 = 2048;
        v148 = a1;
        v149 = 1024;
        LODWORD(v150) = v133;
        v57 = (const char *)_os_log_send_and_compose_impl();
        v144 = OS_LOG_TYPE_ERROR;
        v58 = (char *)v57;
        v143 = 0;
        if (__nwlog_fault(v57, &v144, &v143))
        {
          if (v144 != OS_LOG_TYPE_FAULT)
          {
            if (v143)
            {
              v62 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v63 = v144;
              v121 = gLogObj;
              v64 = os_log_type_enabled((os_log_t)gLogObj, v144);
              if (v62)
              {
                if (v64)
                {
                  *(_DWORD *)buf = v124;
                  *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = a1 + 159;
                  *(_WORD *)&buf[22] = 2080;
                  v146 = " ";
                  v147 = 2048;
                  v148 = a1;
                  v149 = 1024;
                  LODWORD(v150) = v133;
                  WORD2(v150) = 2082;
                  *(_QWORD *)((char *)&v150 + 6) = v62;
                  _os_log_impl(&dword_182FBE000, v121, v63, "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u, dumping backtrace:%{public}s", buf, 0x3Au);
                }
                free(v62);
                goto LABEL_109;
              }
              if (!v64)
                goto LABEL_109;
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 1024;
              LODWORD(v150) = v133;
              v61 = "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u, no backtrace";
              v72 = v121;
              v73 = v63;
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v59 = gLogObj;
              v60 = v144;
              if (!os_log_type_enabled((os_log_t)gLogObj, v144))
                goto LABEL_109;
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 1024;
              LODWORD(v150) = v133;
              v61 = "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u, backtrace limit exceeded";
LABEL_107:
              v72 = v59;
              v73 = v60;
            }
            _os_log_impl(&dword_182FBE000, v72, v73, v61, buf, 0x30u);
            goto LABEL_109;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v59 = gLogObj;
          v60 = v144;
          if (os_log_type_enabled((os_log_t)gLogObj, v144))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 159;
            *(_WORD *)&buf[22] = 2080;
            v146 = " ";
            v147 = 2048;
            v148 = a1;
            v149 = 1024;
            LODWORD(v150) = v133;
            v61 = "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u";
            goto LABEL_107;
          }
        }
LABEL_109:
        if (v58)
          free(v58);
        LOWORD(v41) = v56;
        LOBYTE(v43) = v55;
        v42 = v130;
LABEL_112:
        if (v40 == *(unsigned __int8 *)(a1 + 156))
        {
          v74 = v43;
          v75 = v41;
          v76 = v42;
          *v135 += nw_protocol_ipv6_process_reassembly(a1, v42, v134, 0, 0);
          if (v76)
          {
            v78 = *(_QWORD *)(a2 + 32);
            v79 = *(_QWORD **)(a2 + 40);
            v80 = (_QWORD *)(a2 + 32);
            if (v78)
            {
              *(_QWORD *)(v78 + 40) = v79;
              v79 = *(_QWORD **)(a2 + 40);
            }
            else
            {
              *(_QWORD *)(v131 + 8) = v79;
            }
            *v79 = v78;
            *v80 = 0;
            *(_QWORD *)(a2 + 40) = 0;
            if (v75)
            {
              if ((v74 & 1) != 0)
              {
                *(_QWORD *)buf = 0;
                *(_QWORD *)&buf[8] = buf;
                *(_QWORD *)&buf[16] = 0x2000000000;
                LOBYTE(v146) = 0;
                v136[0] = MEMORY[0x1E0C809B0];
                v136[1] = 0x40000000;
                v137 = ___ZL36nw_protocol_ipv6_process_input_frameP16nw_protocol_ipv6P8nw_frameP16nw_frame_array_sS4_PjS5__block_invoke;
                v138 = &unk_1E14AC740;
                v142 = v75;
                v140 = a1;
                v141 = a2;
                v139 = buf;
                v82 = *(_QWORD *)(a1 + 88);
                do
                {
                  if (!v82)
                    break;
                  v83 = *(_QWORD *)(v82 + 32);
                  v84 = ((uint64_t (*)(_QWORD *))v137)(v136);
                  v82 = v83;
                }
                while ((v84 & 1) != 0);
                if (!*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
                {
                  *(_QWORD *)(a2 + 32) = 0;
                  v85 = *(uint64_t **)(a1 + 96);
                  *(_QWORD *)(a2 + 40) = v85;
                  *v85 = a2;
                  *(_QWORD *)(a1 + 96) = v80;
                }
                _Block_object_dispose(buf, 8);
              }
              else
              {
                v90 = *(uint64_t **)(a1 + 96);
                *(_QWORD *)(a2 + 40) = v90;
                *v90 = a2;
                *(_QWORD *)(a1 + 96) = v80;
              }
            }
            else
            {
              v87 = *(_QWORD *)(a1 + 88);
              v86 = (uint64_t *)(a1 + 88);
              *(_QWORD *)(a2 + 32) = v87;
              v88 = (_QWORD *)(v87 + 40);
              if (v87)
                v89 = v88;
              else
                v89 = v86 + 1;
              *v89 = v80;
              *v86 = a2;
              *(_QWORD *)(a2 + 40) = v86;
            }
            --*v132;
          }
          else
          {
            v81 = *(_QWORD *)(a1 + 48);
            if (v81)
              ++*(_QWORD *)(v81 + 104);
            nw_frame_claim(a2, v77, v44, v133 - v22);
            ++*(_QWORD *)(a1 + 8);
          }
          return 1;
        }
        v111 = *(_QWORD *)(a1 + 48);
        if (v111)
        {
          result = 0;
          ++*(_QWORD *)(v111 + 160);
          return result;
        }
        return 0;
      }
      if (v40 > 43)
      {
        if (v40 != 60)
        {
          if (v40 != 44)
            goto LABEL_100;
          if ((unint64_t)v44 + 8 > v22)
          {
            v65 = v42;
            v66 = v43;
            v67 = v41;
            if ((*(_BYTE *)(a1 + 158) & 1) != 0
              || (v94 = __nwlog_obj(), !os_log_type_enabled(v94, OS_LOG_TYPE_ERROR)))
            {
              v40 = 44;
            }
            else
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 2048;
              *(_QWORD *)&v150 = v22;
              _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %lu", buf, 0x34u);
              v40 = 44;
            }
            goto LABEL_104;
          }
          v46 = (unsigned __int8 *)v17 + v44;
          v40 = *v46;
          v44 += 8;
          v42 = *((_DWORD *)v46 + 1);
          v47 = *((unsigned __int16 *)v46 + 1);
          v41 = bswap32(v47 & 0xFFFFF8FF) >> 16;
          v43 = (v47 >> 8) & 1;
          if ((*(_BYTE *)(a1 + 158) & 1) == 0 && gLogDatapath)
          {
            v122 = a7;
            v126 = a8;
            v48 = *((_DWORD *)v46 + 1);
            v49 = v41;
            v128 = __nwlog_obj();
            if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = v126.n128_u32[0];
              *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 1024;
              LODWORD(v150) = v49;
              WORD2(v150) = 1024;
              *(_DWORD *)((char *)&v150 + 6) = (unsigned __int16)(v47 & 0x100) >> 8;
              WORD5(v150) = 1024;
              HIDWORD(v150) = v48;
              _os_log_impl(&dword_182FBE000, v128, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Received IPv6 fragment offset %u more %u id %u", buf, 0x3Cu);
              a7 = v122;
              a8 = v126;
              v42 = v48;
              v41 = v49;
              v43 = (v47 >> 8) & 1;
            }
            else
            {
              v41 = v49;
              v43 = (v47 >> 8) & 1;
              v42 = v48;
              a7 = v122;
              a8 = v126;
            }
            v45 = "%{public}s %{public}s%s%p Received IPv6 extension type %u length %u";
          }
          goto LABEL_69;
        }
      }
      else if (v40 && v40 != 43)
      {
LABEL_100:
        v65 = v42;
        v66 = v43;
        v67 = v41;
        if ((*(_BYTE *)(a1 + 158) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v68 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 159;
            *(_WORD *)&buf[22] = 2080;
            v146 = " ";
            v147 = 2048;
            v148 = a1;
            v149 = 1024;
            LODWORD(v150) = v40;
            v69 = "%{public}s %{public}s%s%p Don't know how to handle IPv6 next protocol %u";
            v70 = v68;
            v71 = 48;
            goto LABEL_103;
          }
        }
LABEL_104:
        LOWORD(v41) = v67;
        LOBYTE(v43) = v66;
        v42 = v65;
        goto LABEL_112;
      }
      if ((unint64_t)v44 + 2 > v22)
      {
        v65 = v42;
        v66 = v43;
        v67 = v41;
        if ((*(_BYTE *)(a1 + 158) & 1) != 0)
          goto LABEL_104;
        v92 = __nwlog_obj();
        if (!os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
          goto LABEL_104;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        v146 = " ";
        v147 = 2048;
        v148 = a1;
        v149 = 2048;
        *(_QWORD *)&v150 = v22;
        v69 = "%{public}s %{public}s%s%p IPv6 extension header cannot fit in packet length %lu";
        v70 = v92;
        v71 = 52;
LABEL_103:
        _os_log_impl(&dword_182FBE000, v70, OS_LOG_TYPE_ERROR, v69, buf, v71);
        goto LABEL_104;
      }
      v50 = (unsigned __int8 *)v17 + v44;
      v51 = 8 * v50[1] + 8;
      v52 = v51 + v44;
      if (v51 + v44 > v22)
      {
        v125 = a7.n128_u32[0];
        v65 = v42;
        v66 = v43;
        v67 = v41;
        if ((*(_BYTE *)(a1 + 158) & 1) != 0)
          goto LABEL_104;
        v93 = __nwlog_obj();
        if (!os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
          goto LABEL_104;
        *(_DWORD *)buf = v125;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        v146 = " ";
        v147 = 2048;
        v148 = a1;
        v149 = 1024;
        LODWORD(v150) = v51;
        WORD2(v150) = 2048;
        *(_QWORD *)((char *)&v150 + 6) = v22;
        v69 = "%{public}s %{public}s%s%p IPv6 extension header length %u cannot fit in packet length %lu";
        v70 = v93;
        v71 = 58;
        goto LABEL_103;
      }
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v119 = v41;
          v120 = v43;
          v129 = v42;
          v123 = a7;
          v127 = a8;
          v53 = v45;
          log = __nwlog_obj();
          v54 = os_log_type_enabled(log, OS_LOG_TYPE_DEBUG);
          a7 = v123;
          a8 = v127;
          v45 = v53;
          v42 = v129;
          v41 = v119;
          v43 = v120;
          if (v54)
          {
            *(_DWORD *)buf = v123.n128_u32[0];
            *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 159;
            *(_WORD *)&buf[22] = 2080;
            v146 = " ";
            v147 = 2048;
            v148 = a1;
            v149 = 1024;
            LODWORD(v150) = v40;
            WORD2(v150) = 1024;
            *(_DWORD *)((char *)&v150 + 6) = v51;
            _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, v53, buf, 0x36u);
            a7 = v123;
            a8 = v127;
            v45 = v53;
            v42 = v129;
            v41 = v119;
            v43 = v120;
          }
        }
      }
      v40 = *v50;
      v44 = v52;
LABEL_69:
      if (v40 == *(unsigned __int8 *)(a1 + 156))
        goto LABEL_112;
    }
  }
  if ((*(_BYTE *)(a1 + 158) & 1) == 0)
  {
    v99 = __nwlog_obj();
    if (os_log_type_enabled(v99, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv6_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 159;
      *(_WORD *)&buf[22] = 2080;
      v146 = " ";
      v147 = 2048;
      v148 = a1;
      _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
    }
  }
  result = 0;
  *(_QWORD *)(a1 + 48) = 0;
  return result;
}

uint64_t ___ZL36nw_protocol_ipv6_process_input_frameP16nw_protocol_ipv6P8nw_frameP16nw_frame_array_sS4_PjS5__block_invoke(uint64_t a1, uint64_t a2)
{
  int fragment_values_for_frame;
  uint64_t result;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  unsigned __int16 v13;

  v13 = 0;
  v12 = 0;
  v11 = 0;
  fragment_values_for_frame = nw_protocol_ipv6_get_fragment_values_for_frame(*(_QWORD *)(a1 + 40), a2, 0, &v13, 0, &v11, &v12);
  result = 0;
  if (fragment_values_for_frame)
  {
    result = 1;
    if (v12 + v13 == *(unsigned __int16 *)(a1 + 56))
    {
      v6 = *(_QWORD *)(a1 + 48);
      v7 = (_QWORD *)(*(_QWORD *)(a1 + 40) + 96);
      v9 = *(_QWORD *)(a2 + 32);
      v8 = (_QWORD *)(a2 + 32);
      *(_QWORD *)(v6 + 32) = v9;
      v10 = (_QWORD *)(v9 + 40);
      if (v9)
        v7 = v10;
      *v7 = v6 + 32;
      *v8 = v6;
      *(_QWORD *)(v6 + 40) = v8;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      return 0;
    }
  }
  return result;
}

uint64_t nw_protocol_ipv6_get_fragment_values_for_frame(uint64_t a1, uint64_t a2, _BYTE *a3, _WORD *a4, _DWORD *a5, _QWORD *a6, _DWORD *a7)
{
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  char v18;
  unsigned int v19;
  unint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  int v23;
  _DWORD *v24;
  int v26;
  NSObject *v27;
  int v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  const char *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  char *backtrace_string;
  _BOOL4 v41;
  uint64_t v42;
  char v44;
  os_log_type_t type;
  unsigned int v46;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  _DWORD v56[9];

  *(_QWORD *)&v56[7] = *MEMORY[0x1E0C80C00];
  v46 = 0;
  v12 = nw_frame_unclaimed_bytes(a2, &v46);
  if (!v12)
  {
    if (!a1 || (*(_BYTE *)(a1 + 158) & 1) == 0)
    {
      v31 = __nwlog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        v32 = (const char *)(a1 + 159);
        if (!a1)
          v32 = "";
        *(_DWORD *)buf = 136446978;
        v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
        v49 = 2082;
        v50 = v32;
        v33 = " ";
        if (!a1)
          v33 = "";
        v51 = 2080;
        v52 = v33;
        v53 = 2048;
        v54 = a1;
        _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
      }
    }
    v18 = 0;
    *(_QWORD *)(a1 + 48) = 0;
    return v18 & 1;
  }
  v13 = v46;
  if (v46 <= 0x27)
  {
    if (a1)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) != 0)
      {
LABEL_79:
        v18 = 0;
        return v18 & 1;
      }
      v34 = " ";
    }
    else
    {
      v34 = "";
    }
    __nwlog_obj();
    if (a1)
      v35 = (const char *)(a1 + 159);
    else
      v35 = "";
    *(_DWORD *)buf = 136447234;
    v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
    v49 = 2082;
    v50 = v35;
    v51 = 2080;
    v52 = v34;
    v53 = 2048;
    v54 = a1;
    v55 = 1024;
    v56[0] = v46;
    v36 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (__nwlog_fault(v36, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v37 = __nwlog_obj();
        v38 = type;
        if (!os_log_type_enabled(v37, type))
          goto LABEL_77;
        *(_DWORD *)buf = 136447234;
        v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
        v49 = 2082;
        v50 = v35;
        v51 = 2080;
        v52 = v34;
        v53 = 2048;
        v54 = a1;
        v55 = 1024;
        v56[0] = v46;
        v39 = "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %u";
        goto LABEL_76;
      }
      if (!v44)
      {
        v37 = __nwlog_obj();
        v38 = type;
        if (!os_log_type_enabled(v37, type))
          goto LABEL_77;
        *(_DWORD *)buf = 136447234;
        v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
        v49 = 2082;
        v50 = v35;
        v51 = 2080;
        v52 = v34;
        v53 = 2048;
        v54 = a1;
        v55 = 1024;
        v56[0] = v46;
        v39 = "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %u, backtrace limit exceeded";
        goto LABEL_76;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type;
      v41 = os_log_type_enabled(v37, type);
      if (backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136447490;
          v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
          v49 = 2082;
          v50 = v35;
          v51 = 2080;
          v52 = v34;
          v53 = 2048;
          v54 = a1;
          v55 = 1024;
          v56[0] = v46;
          LOWORD(v56[1]) = 2082;
          *(_QWORD *)((char *)&v56[1] + 2) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %u, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(backtrace_string);
        goto LABEL_77;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136447234;
        v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
        v49 = 2082;
        v50 = v35;
        v51 = 2080;
        v52 = v34;
        v53 = 2048;
        v54 = a1;
        v55 = 1024;
        v56[0] = v46;
        v39 = "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %u, no backtrace";
LABEL_76:
        _os_log_impl(&dword_182FBE000, v37, v38, v39, buf, 0x30u);
      }
    }
LABEL_77:
    if (v36)
      free(v36);
    goto LABEL_79;
  }
  v14 = v12;
  v15 = bswap32(*(unsigned __int16 *)(v12 + 4)) >> 16;
  v16 = *(unsigned __int8 *)(v12 + 6);
  v17 = *(unsigned __int8 *)(a1 + 156);
  if (v16 != v17)
  {
    v42 = a1;
    v18 = 0;
    v20 = v15 + 40;
    v19 = 40;
    while (1)
    {
      if (v16 > 43)
      {
        if (v16 == 60)
          goto LABEL_22;
        if (v16 != 44)
          goto LABEL_26;
        if ((unint64_t)v19 + 8 > v20)
        {
          v26 = v15;
          if ((*(_BYTE *)(v42 + 158) & 1) == 0)
          {
            v30 = __nwlog_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136447234;
              v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
              v49 = 2082;
              v50 = (const char *)(v42 + 159);
              v51 = 2080;
              v52 = " ";
              v53 = 2048;
              v54 = v42;
              v55 = 2048;
              *(_QWORD *)v56 = v20;
              a1 = v42;
              _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %lu", buf, 0x34u);
              v16 = 44;
              goto LABEL_46;
            }
          }
          v16 = 44;
LABEL_45:
          a1 = v42;
          goto LABEL_46;
        }
        v21 = (unsigned __int8 *)(v12 + v19);
        v16 = *v21;
        if (a5)
          *a5 = *((_DWORD *)v21 + 1);
        if (a3)
          *a3 = v21[3] & 1;
        v19 += 8;
        if (a4)
          *a4 = bswap32(*((_WORD *)v21 + 1) & 0xF8FF) >> 16;
        v18 = 1;
        if (v16 == v17)
        {
LABEL_25:
          v16 = v17;
LABEL_26:
          a1 = v42;
          goto LABEL_27;
        }
      }
      else
      {
        if (v16 && v16 != 43)
          goto LABEL_26;
LABEL_22:
        if ((unint64_t)v19 + 2 > v20)
        {
          v26 = v15;
          if ((*(_BYTE *)(v42 + 158) & 1) == 0)
          {
            v27 = __nwlog_obj();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136447234;
              v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
              v49 = 2082;
              v50 = (const char *)(v42 + 159);
              v51 = 2080;
              v52 = " ";
              v53 = 2048;
              v54 = v42;
              v55 = 2048;
              *(_QWORD *)v56 = v20;
              a1 = v42;
              _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p IPv6 extension header cannot fit in packet length %lu", buf, 0x34u);
LABEL_46:
              v24 = a7;
              LODWORD(v15) = v26;
              goto LABEL_28;
            }
          }
          goto LABEL_45;
        }
        v22 = (unsigned __int8 *)(v12 + v19);
        v23 = 8 * v22[1] + 8;
        if (v23 + v19 > v13)
        {
          v28 = v15;
          if ((*(_BYTE *)(v42 + 158) & 1) != 0
            || (v29 = __nwlog_obj(), !os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)))
          {
            a1 = v42;
          }
          else
          {
            *(_DWORD *)buf = 136447490;
            v48 = "nw_protocol_ipv6_get_fragment_values_for_frame";
            v49 = 2082;
            v50 = (const char *)(v42 + 159);
            v51 = 2080;
            v52 = " ";
            v53 = 2048;
            v54 = v42;
            v55 = 1024;
            v56[0] = v23;
            LOWORD(v56[1]) = 2048;
            *(_QWORD *)((char *)&v56[1] + 2) = v20;
            a1 = v42;
            _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p IPv6 extension header length %u cannot fit in packet length %lu", buf, 0x3Au);
          }
          v24 = a7;
          LODWORD(v15) = v28;
          goto LABEL_28;
        }
        v16 = *v22;
        v19 += v23;
        if (v16 == v17)
          goto LABEL_25;
      }
    }
  }
  v18 = 0;
  v19 = 40;
LABEL_27:
  v24 = a7;
LABEL_28:
  if (a6 && v24 && v16 == *(unsigned __int8 *)(a1 + 156))
  {
    *a6 = v14 + v19;
    *v24 = v15 - v19 + 40;
  }
  return v18 & 1;
}

uint64_t ___ZL43nw_protocol_ipv6_append_reassembled_packetsP16nw_protocol_ipv6P16nw_frame_array_sPb_block_invoke(_QWORD *a1, uint64_t a2)
{
  int fragment_values_for_frame;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  unsigned int v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  const char *v12;
  const char *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned __int16 v23;
  char v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  fragment_values_for_frame = nw_protocol_ipv6_get_fragment_values_for_frame(a1[6], a2, &v24, &v23, &v22, &v21, &v20);
  result = 0;
  if (fragment_values_for_frame)
  {
    v5 = a1[6];
    if (!v5 || (*(_BYTE *)(v5 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v15 = __nwlog_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          v16 = a1[6];
          v17 = "";
          v18 = (const char *)(v16 + 159);
          if (v16)
            v17 = " ";
          else
            v18 = "";
          v19 = *(unsigned __int16 *)(*(_QWORD *)(a1[4] + 8) + 24);
          *(_DWORD *)buf = 136448002;
          v26 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
          v27 = 2082;
          v28 = v18;
          v29 = 2080;
          v30 = v17;
          v31 = 2048;
          v32 = v16;
          v33 = 1024;
          v34 = v22;
          v35 = 1024;
          v36 = v20;
          v37 = 1024;
          v38 = v23;
          v39 = 1024;
          v40 = v19;
          _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Examining fragment for IPv6 Fragment ID %u, length %u offset %u aggregate length %u", buf, 0x42u);
        }
      }
    }
    v6 = *(_QWORD *)(a1[4] + 8);
    if (v23 == *(unsigned __int16 *)(v6 + 24))
    {
      v7 = __CFADD__(v23, v20);
      v8 = v23 + v20;
      *(_WORD *)(v6 + 24) = v8;
      if (!v7 && v8 < 0x10000)
      {
        result = 1;
        if (v24)
          return result;
        goto LABEL_18;
      }
      v9 = a1[6];
      if (!v9 || (*(_BYTE *)(v9 + 158) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        LODWORD(result) = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
        {
LABEL_18:
          *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = result;
          return 0;
        }
        v11 = a1[6];
        v12 = "";
        v13 = (const char *)(v11 + 159);
        if (v11)
          v12 = " ";
        else
          v13 = "";
        v14 = *(unsigned __int16 *)(*(_QWORD *)(a1[4] + 8) + 24);
        *(_DWORD *)buf = 136447490;
        v26 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
        v27 = 2082;
        v28 = v13;
        v29 = 2080;
        v30 = v12;
        v31 = 2048;
        v32 = v11;
        v33 = 1024;
        v34 = v20;
        v35 = 1024;
        v36 = v14;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Cannot add %u to existing offset %u", buf, 0x36u);
      }
    }
    LOBYTE(result) = 0;
    goto LABEL_18;
  }
  return result;
}

void nw_protocol_ipv6_frame_input_finalizer(nw_frame *a1, BOOL a2, _QWORD *a3)
{
  uint64_t v5;
  _QWORD *v6;

  nw_frame_free_buffer((uint64_t)a1);
  v5 = *((_QWORD *)a1 + 2);
  v6 = (_QWORD *)*((_QWORD *)a1 + 3);
  if (v5)
  {
    *(_QWORD *)(v5 + 24) = v6;
    v6 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    a3[14] = v6;
  }
  *v6 = v5;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  os_release(a1);
}

uint64_t ___ZL43nw_protocol_ipv6_append_reassembled_packetsP16nw_protocol_ipv6P16nw_frame_array_sPb_block_invoke_41(uint64_t a1, uint64_t a2)
{
  int fragment_values_for_frame;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  int v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  int v20;
  const char *v21;
  char *backtrace_string;
  _BOOL4 v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  int v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  int v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  int v39;
  const char *v40;
  int v41;
  uint64_t v42;
  const char *v43;
  const char *v44;
  int v45;
  int v46;
  char *v47;
  _BOOL4 v48;
  uint64_t v49;
  const char *v50;
  const char *v51;
  int v52;
  int v53;
  uint64_t v54;
  const char *v55;
  const char *v56;
  int v57;
  int v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  int v62;
  int v63;
  char v64;
  os_log_type_t type;
  _DWORD __n[4];
  __int16 v67;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  uint64_t v75;
  __int16 v76;
  int v77;
  __int16 v78;
  int v79;
  __int16 v80;
  char *v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v67 = 0;
  *(_QWORD *)&__n[1] = 0;
  __n[0] = 0;
  fragment_values_for_frame = nw_protocol_ipv6_get_fragment_values_for_frame(*(_QWORD *)(a1 + 40), a2, 0, &v67, 0, &__n[1], __n);
  result = 0;
  if (fragment_values_for_frame)
  {
    v5 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if ((__n[0] + v5) <= *(_DWORD *)(a1 + 56))
    {
      memcpy((void *)(*(_QWORD *)(a1 + 48) + v5), *(const void **)&__n[1], __n[0]);
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v7 = *(_DWORD *)(v6 + 24);
      v8 = __CFADD__(v7, __n[0]);
      *(_DWORD *)(v6 + 24) = v7 + __n[0];
      if (!v8)
        return 1;
      v9 = *(_QWORD *)(a1 + 40);
      if (v9 && (*(_BYTE *)(v9 + 158) & 1) != 0)
        return 0;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = *(_QWORD *)(a1 + 40);
      v11 = (const char *)(v10 + 159);
      if (v10)
      {
        v12 = " ";
      }
      else
      {
        v11 = "";
        v12 = "";
      }
      v13 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
      v70 = 2082;
      v71 = v11;
      v72 = 2080;
      v73 = v12;
      v74 = 2048;
      v75 = v10;
      v76 = 1024;
      v77 = __n[0];
      v78 = 1024;
      v79 = v13;
      v14 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v64 = 0;
      if (__nwlog_fault(v14, &type, &v64))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = gLogObj;
          v16 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_36;
          v17 = *(_QWORD *)(a1 + 40);
          v18 = (const char *)(v17 + 159);
          if (v17)
          {
            v19 = " ";
          }
          else
          {
            v18 = "";
            v19 = "";
          }
          v20 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136447490;
          v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
          v70 = 2082;
          v71 = v18;
          v72 = 2080;
          v73 = v19;
          v74 = 2048;
          v75 = v17;
          v76 = 1024;
          v77 = __n[0];
          v78 = 1024;
          v79 = v20;
          v21 = "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u";
          goto LABEL_35;
        }
        if (!v64)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = gLogObj;
          v16 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_36;
          v28 = *(_QWORD *)(a1 + 40);
          v29 = (const char *)(v28 + 159);
          if (v28)
          {
            v30 = " ";
          }
          else
          {
            v29 = "";
            v30 = "";
          }
          v31 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136447490;
          v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
          v70 = 2082;
          v71 = v29;
          v72 = 2080;
          v73 = v30;
          v74 = 2048;
          v75 = v28;
          v76 = 1024;
          v77 = __n[0];
          v78 = 1024;
          v79 = v31;
          v21 = "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u, backtrace limit exceeded";
          goto LABEL_35;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        v16 = type;
        v23 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!backtrace_string)
        {
          if (!v23)
            goto LABEL_36;
          v32 = *(_QWORD *)(a1 + 40);
          v33 = (const char *)(v32 + 159);
          if (v32)
          {
            v34 = " ";
          }
          else
          {
            v33 = "";
            v34 = "";
          }
          v35 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136447490;
          v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
          v70 = 2082;
          v71 = v33;
          v72 = 2080;
          v73 = v34;
          v74 = 2048;
          v75 = v32;
          v76 = 1024;
          v77 = __n[0];
          v78 = 1024;
          v79 = v35;
          v21 = "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u, no backtrace";
          goto LABEL_35;
        }
        if (v23)
        {
          v24 = *(_QWORD *)(a1 + 40);
          v25 = (const char *)(v24 + 159);
          if (v24)
          {
            v26 = " ";
          }
          else
          {
            v25 = "";
            v26 = "";
          }
          v27 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136447746;
          v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
          v70 = 2082;
          v71 = v25;
          v72 = 2080;
          v73 = v26;
          v74 = 2048;
          v75 = v24;
          v76 = 1024;
          v77 = __n[0];
          v78 = 1024;
          v79 = v27;
          v80 = 2082;
          v81 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u, dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(backtrace_string);
      }
LABEL_36:
      if (!v14)
        return 0;
LABEL_37:
      free(v14);
      return 0;
    }
    v36 = *(_QWORD *)(a1 + 40);
    if (v36 && (*(_BYTE *)(v36 + 158) & 1) != 0)
      return 0;
    __nwlog_obj();
    v37 = *(_QWORD *)(a1 + 40);
    v38 = (const char *)(v37 + 159);
    if (!v37)
      v38 = "";
    v39 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v37)
      v40 = " ";
    else
      v40 = "";
    v41 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)buf = 136447490;
    v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
    v70 = 2082;
    v71 = v38;
    v72 = 2080;
    v73 = v40;
    v74 = 2048;
    v75 = v37;
    v76 = 1024;
    v77 = __n[0] + v39;
    v78 = 1024;
    v79 = v41;
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v64 = 0;
    if (!__nwlog_fault(v14, &type, &v64))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_36;
      v42 = *(_QWORD *)(a1 + 40);
      v43 = (const char *)(v42 + 159);
      if (v42)
      {
        v44 = " ";
      }
      else
      {
        v43 = "";
        v44 = "";
      }
      v45 = __n[0] + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v46 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
      v70 = 2082;
      v71 = v43;
      v72 = 2080;
      v73 = v44;
      v74 = 2048;
      v75 = v42;
      v76 = 1024;
      v77 = v45;
      v78 = 1024;
      v79 = v46;
      v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u)";
    }
    else if (v64)
    {
      v47 = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v48 = os_log_type_enabled(v15, type);
      if (v47)
      {
        if (v48)
        {
          v49 = *(_QWORD *)(a1 + 40);
          v50 = (const char *)(v49 + 159);
          if (v49)
          {
            v51 = " ";
          }
          else
          {
            v50 = "";
            v51 = "";
          }
          v52 = __n[0] + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v53 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136447746;
          v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
          v70 = 2082;
          v71 = v50;
          v72 = 2080;
          v73 = v51;
          v74 = 2048;
          v75 = v49;
          v76 = 1024;
          v77 = v52;
          v78 = 1024;
          v79 = v53;
          v80 = 2082;
          v81 = v47;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(v47);
        if (!v14)
          return 0;
        goto LABEL_37;
      }
      if (!v48)
        goto LABEL_36;
      v59 = *(_QWORD *)(a1 + 40);
      v60 = (const char *)(v59 + 159);
      if (v59)
      {
        v61 = " ";
      }
      else
      {
        v60 = "";
        v61 = "";
      }
      v62 = __n[0] + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v63 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
      v70 = 2082;
      v71 = v60;
      v72 = 2080;
      v73 = v61;
      v74 = 2048;
      v75 = v59;
      v76 = 1024;
      v77 = v62;
      v78 = 1024;
      v79 = v63;
      v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), no backtrace";
    }
    else
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_36;
      v54 = *(_QWORD *)(a1 + 40);
      v55 = (const char *)(v54 + 159);
      if (v54)
      {
        v56 = " ";
      }
      else
      {
        v55 = "";
        v56 = "";
      }
      v57 = __n[0] + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v58 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136447490;
      v69 = "nw_protocol_ipv6_append_reassembled_packets_block_invoke";
      v70 = 2082;
      v71 = v55;
      v72 = 2080;
      v73 = v56;
      v74 = 2048;
      v75 = v54;
      v76 = 1024;
      v77 = v57;
      v78 = 1024;
      v79 = v58;
      v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v15, v16, v21, buf, 0x36u);
    goto LABEL_36;
  }
  return result;
}

uint64_t ___ZL43nw_protocol_ipv6_append_reassembled_packetsP16nw_protocol_ipv6P16nw_frame_array_sPb_block_invoke_43(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

void nw_protocol_ip_register_segmentation_offload_notification(nw_protocol *a1, int a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *v4;
  void (*register_notification)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  void *handle;
  nw_protocol_callbacks *v7;
  nw_protocol_callbacks *callbacks;
  void (*unregister_notification)(nw_protocol *, nw_protocol *, uint64_t);
  nw_protocol_callbacks *v10;
  nw_protocol_callbacks *v11;
  nw_protocol_callbacks *v12;
  nw_protocol_callbacks *v13;
  nw_protocol_callbacks *v14;
  void (**v15)(_QWORD);
  const void *v16;
  nw_protocol_callbacks *v17;
  nw_protocol_callbacks *v18;
  void (**v19)(_QWORD);
  const void *v20;

  default_input_handler = a1->default_input_handler;
  if (!a2)
  {
    if (!default_input_handler)
      return;
    callbacks = default_input_handler->callbacks;
    if (!callbacks)
      return;
    unregister_notification = (void (*)(nw_protocol *, nw_protocol *, uint64_t))callbacks->unregister_notification;
    if (!unregister_notification)
      return;
    handle = default_input_handler->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      v10 = default_input_handler[1].callbacks;
      if (v10)
        default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v10->add_input_handler + 1);
    }
    if (a1->handle != &nw_protocol_ref_counted_handle)
    {
      unregister_notification(default_input_handler, a1, 14);
      goto LABEL_25;
    }
    v12 = a1[1].callbacks;
    if (v12)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v12->add_input_handler + 1);
    unregister_notification(default_input_handler, a1, 14);
LABEL_24:
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      v17 = a1[1].callbacks;
      if (v17)
      {
        v18 = (nw_protocol_callbacks *)((char *)v17 - 1);
        a1[1].callbacks = v18;
        if (!v18)
        {
          v19 = *(void (***)(_QWORD))a1[1].flow_id;
          if (v19)
          {
            *(_QWORD *)a1[1].flow_id = 0;
            v19[2](v19);
            _Block_release(v19);
          }
          if ((a1[1].flow_id[8] & 1) != 0)
          {
            v20 = *(const void **)a1[1].flow_id;
            if (v20)
              _Block_release(v20);
          }
          free(a1);
        }
      }
    }
    goto LABEL_25;
  }
  if (!default_input_handler)
    return;
  v4 = default_input_handler->callbacks;
  if (!v4)
    return;
  register_notification = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v4->register_notification;
  if (!register_notification)
    return;
  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    v7 = default_input_handler[1].callbacks;
    if (v7)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v11 = a1[1].callbacks;
    if (v11)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v11->add_input_handler + 1);
    register_notification(default_input_handler, a1, 14, 0, 0);
    goto LABEL_24;
  }
  register_notification(default_input_handler, a1, 14, 0, 0);
LABEL_25:
  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    v13 = default_input_handler[1].callbacks;
    if (v13)
    {
      v14 = (nw_protocol_callbacks *)((char *)v13 - 1);
      default_input_handler[1].callbacks = v14;
      if (!v14)
      {
        v15 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
        if (v15)
        {
          *(_QWORD *)default_input_handler[1].flow_id = 0;
          v15[2](v15);
          _Block_release(v15);
        }
        if ((default_input_handler[1].flow_id[8] & 1) != 0)
        {
          v16 = *(const void **)default_input_handler[1].flow_id;
          if (v16)
            _Block_release(v16);
        }
        free(default_input_handler);
      }
    }
  }
}

void ___ZL26nw_protocol_ipv4_callbacksv_block_invoke()
{
  nw_protocol_ipv4_callbacks(void)::callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler((_QWORD *)nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_add_input_handler);
  nw_protocol_callbacks_set_replace_input_handler(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_replace_input_handler);
  nw_protocol_callbacks_set_remove_input_handler(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_remove_input_handler);
  nw_protocol_callbacks_set_get_input_frames(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_get_input_frames);
  nw_protocol_callbacks_set_get_output_frames(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_get_output_frames);
  nw_protocol_callbacks_set_finalize_output_frames(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_finalize_output_frames);
  nw_protocol_callbacks_set_connected(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_connected);
  nw_protocol_callbacks_set_disconnected(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_disconnected);
  nw_protocol_callbacks_set_get_message_properties(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_get_message_properties);
  nw_protocol_callbacks_set_copy_info(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_copy_info);
  nw_protocol_callbacks_set_updated_path(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_updated_path);
  nw_protocol_callbacks_set_notify(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_notify);
  nw_protocol_callbacks_set_error(nw_protocol_ipv4_callbacks(void)::callbacks, (uint64_t)nw_protocol_ipv4_error);
}

uint64_t nw_protocol_ipv4_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  nw_protocol_identifier *identifier;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv4_replace_input_handler";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_74;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v13)
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv4_replace_input_handler";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_74;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_protocol_ipv4_replace_input_handler";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_75;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_75;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v11 = "%{public}s called with null protocol";
    goto LABEL_74;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv4_replace_input_handler";
        v11 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_74;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v15)
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv4_replace_input_handler";
        v11 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_74;
      }
      if (!v15)
        goto LABEL_52;
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v24 = 2082;
      v25 = v14;
      v16 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_75;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v11 = "%{public}s called with null ipv4";
LABEL_74:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_75;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv4_replace_input_handler";
        v11 = "%{public}s called with null old_input_protocol, backtrace limit exceeded";
        goto LABEL_74;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v17)
          goto LABEL_75;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_ipv4_replace_input_handler";
        v11 = "%{public}s called with null old_input_protocol, no backtrace";
        goto LABEL_74;
      }
      if (!v17)
        goto LABEL_52;
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v24 = 2082;
      v25 = v14;
      v16 = "%{public}s called with null old_input_protocol, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_75;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v11 = "%{public}s called with null old_input_protocol";
    goto LABEL_74;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v11 = "%{public}s called with null new_input_protocol";
      goto LABEL_74;
    }
    if (!v20)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v11 = "%{public}s called with null new_input_protocol, backtrace limit exceeded";
      goto LABEL_74;
    }
    v14 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v18 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v18)
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v11 = "%{public}s called with null new_input_protocol, no backtrace";
      goto LABEL_74;
    }
    if (!v18)
      goto LABEL_52;
    *(_DWORD *)buf = 136446466;
    v23 = "nw_protocol_ipv4_replace_input_handler";
    v24 = 2082;
    v25 = v14;
    v16 = "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s";
LABEL_51:
    _os_log_impl(&dword_182FBE000, v9, v10, v16, buf, 0x16u);
    goto LABEL_52;
  }
  if (a3->identifier)
    identifier = a3->identifier;
  else
    identifier = (nw_protocol_identifier *)"invalid";
  if (strncmp(identifier->name, "quic", 4uLL))
    return nw_protocol_common_replace_input_handler((uint64_t)a1, a2, (uint64_t)a3);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_protocol_ipv4_replace_input_handler";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v8, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v11 = "%{public}s Attempt to add quic to ip";
      goto LABEL_74;
    }
    if (!v20)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v11 = "%{public}s Attempt to add quic to ip, backtrace limit exceeded";
      goto LABEL_74;
    }
    v14 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v19 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v19)
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v11 = "%{public}s Attempt to add quic to ip, no backtrace";
      goto LABEL_74;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_ipv4_replace_input_handler";
      v24 = 2082;
      v25 = v14;
      v16 = "%{public}s Attempt to add quic to ip, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
LABEL_52:
    free(v14);
    if (!v8)
      return 0;
    goto LABEL_76;
  }
LABEL_75:
  if (v8)
LABEL_76:
    free(v8);
  return 0;
}

void nw_protocol_ipv4_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char *v10;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv4_get_message_properties";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_ipv4_get_message_properties";
      v7 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_ipv4_get_message_properties";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v4)
          return;
LABEL_35:
        free(v4);
        return;
      }
      if (!v9)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_ipv4_get_message_properties";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_ipv4_get_message_properties";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      v3 = a3[1] & 0xFFFFFFF8 | 1;
      *a3 = *(_DWORD *)(a1 + 208);
      a3[1] = v3;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_ipv4_get_message_properties";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv4_get_message_properties";
    v7 = "%{public}s called with null ipv4";
    goto LABEL_33;
  }
  if (!v12)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv4_get_message_properties";
    v7 = "%{public}s called with null ipv4, backtrace limit exceeded";
    goto LABEL_33;
  }
  v10 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11)
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_ipv4_get_message_properties";
    v7 = "%{public}s called with null ipv4, no backtrace";
    goto LABEL_33;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    v15 = "nw_protocol_ipv4_get_message_properties";
    v16 = 2082;
    v17 = v10;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null ipv4, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v4)
    goto LABEL_35;
}

void nw_protocol_ipv4_error(nw_protocol *a1, nw_protocol *a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char *v8;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv4_error";
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_ipv4_error";
      v5 = "%{public}s called with null protocol";
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_protocol_ipv4_error";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_33:
        if (!v2)
          return;
        goto LABEL_34;
      }
      if (!v7)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_ipv4_error";
      v5 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_ipv4_error";
      v5 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_32:
    _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    goto LABEL_33;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    if (a1->default_input_handler)
      nw_protocol_common_error((uint64_t)a1, (uint64_t)a2);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_protocol_ipv4_error";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10))
    goto LABEL_33;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv4_error";
    v5 = "%{public}s called with null ipv4";
    goto LABEL_32;
  }
  if (!v10)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv4_error";
    v5 = "%{public}s called with null ipv4, backtrace limit exceeded";
    goto LABEL_32;
  }
  v8 = (char *)__nw_create_backtrace_string();
  v3 = __nwlog_obj();
  v4 = type;
  v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9)
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_ipv4_error";
    v5 = "%{public}s called with null ipv4, no backtrace";
    goto LABEL_32;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    v13 = "nw_protocol_ipv4_error";
    v14 = 2082;
    v15 = v8;
    _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null ipv4, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v8);
  if (v2)
LABEL_34:
    free(v2);
}

uint64_t nw_ipv4_checksum(unsigned __int16 *a1)
{
  unsigned int v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if ((a1 & 3) != 0)
  {
    v1 = vaddlvq_u16(*(uint16x8_t *)a1) + a1[8] + a1[9];
    LODWORD(v2) = HIWORD(v1) + (unsigned __int16)v1 + ((HIWORD(v1) + (unsigned __int16)v1) >> 16);
  }
  else
  {
    v3 = vaddlvq_u32(*(uint32x4_t *)a1);
    v4 = ((v3 + *((unsigned int *)a1 + 4)) >> 32) + (v3 + *((_DWORD *)a1 + 4));
    v2 = (((v4 >> 16) + (unsigned __int16)v4) >> 16) + (unsigned __int16)(WORD1(v4) + v4);
    LOWORD(v2) = WORD1(v2) + v2;
  }
  return (unsigned __int16)~(_WORD)v2;
}

void nw_protocol_ipv4_frame_output_finalizer(nw_frame *a1, int a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, _QWORD *, _QWORD, _QWORD, uint64_t, _QWORD *);
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t, _QWORD *);
  void *buffer;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  void (**v41)(_QWORD);
  const void *v42;
  uint64_t v43;
  uint64_t v44;
  void (**v45)(_QWORD);
  const void *v46;
  uint64_t v47;
  uint64_t v48;
  void (**v49)(_QWORD);
  const void *v50;
  const char *v51;
  const char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  const char *v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  const char *v60;
  char *backtrace_string;
  _BOOL4 v62;
  const char *v63;
  const char *v64;
  char *v65;
  NSObject *v66;
  os_log_type_t v67;
  const char *v68;
  const char *v69;
  char *v70;
  _BOOL4 v71;
  NSObject *v72;
  _BOOL4 v73;
  NSObject *v74;
  os_log_type_t v75;
  const char *v76;
  char *v77;
  _BOOL4 v78;
  const char *v79;
  NSObject *v80;
  const char *v81;
  NSObject *v82;
  os_log_type_t v83;
  const char *v84;
  char *v85;
  _BOOL4 v86;
  const char *v87;
  const char *v88;
  os_log_type_t type;
  os_log_t log;
  NSObject *loga;
  char *v92;
  _QWORD v93[2];
  uint64_t (*v94)(uint64_t, uint64_t);
  void *v95;
  _QWORD *v96;
  _QWORD *v97;
  _QWORD *v98;
  nw_frame *v99;
  uint64_t v100;
  unsigned int v101;
  __int16 v102;
  _QWORD v103[2];
  uint64_t (*v104)(uint64_t, uint64_t);
  void *v105;
  _QWORD *v106;
  _QWORD v107[2];
  __int16 __buf;
  _QWORD v109[3];
  int v110;
  unsigned int v111;
  char v112;
  os_log_type_t v113;
  uint8_t buf[4];
  const char *v115;
  __int16 v116;
  char *v117;
  __int16 v118;
  const char *v119;
  __int16 v120;
  char *v121;
  __int16 v122;
  unsigned int v123;
  __int16 v124;
  unsigned int v125;
  uint64_t v126;

  v126 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v111 = 0;
    v5 = nw_frame_unclaimed_bytes((uint64_t)a1, &v111);
    if (v5)
    {
      if (v111)
      {
        v6 = v5;
        v109[0] = 0;
        v109[1] = v109;
        v110 = 0;
        v109[2] = 0x2000000000;
        __buf = 0;
        arc4random_buf(&__buf, 2uLL);
        v107[0] = 0;
        v107[1] = v107;
        v7 = *(a3 - 8);
        if (v7)
        {
          v8 = *((_DWORD *)a3 + 28);
          v9 = *((_DWORD *)a3 + 30);
          v10 = *(void **)(v7 + 40);
          if (v10 == &nw_protocol_ref_counted_handle)
          {
            v11 = *(_QWORD *)(v7 + 88);
            if (v11)
              *(_QWORD *)(v7 + 88) = v11 + 1;
          }
          v12 = (void *)*(a3 - 7);
          if (v12 == &nw_protocol_ref_counted_handle)
          {
            v13 = *(a3 - 1);
            if (v13)
              *(a3 - 1) = v13 + 1;
          }
          v14 = *(_QWORD *)(v7 + 24);
          if (v14)
          {
            v15 = *(uint64_t (**)(uint64_t, _QWORD *, _QWORD, _QWORD, uint64_t, _QWORD *))(v14 + 88);
            if (v15)
            {
              v16 = v15(v7, a3 - 12, v9 + v9 * (v111 / v8), v9 + v9 * (v111 / v8), 32, v107);
              if (v12 != &nw_protocol_ref_counted_handle)
                goto LABEL_15;
              goto LABEL_14;
            }
          }
          __nwlog_obj();
          v51 = *(const char **)(v7 + 16);
          *(_DWORD *)buf = 136446722;
          v115 = "__nw_protocol_get_output_frames";
          if (!v51)
            v51 = "invalid";
          v116 = 2082;
          v117 = (char *)v51;
          v118 = 2048;
          v119 = (const char *)v7;
          v52 = (const char *)_os_log_send_and_compose_impl();
          v113 = OS_LOG_TYPE_ERROR;
          v112 = 0;
          v92 = (char *)v52;
          if (__nwlog_fault(v52, &v113, &v112))
          {
            if (v113 == OS_LOG_TYPE_FAULT)
            {
              v53 = __nwlog_obj();
              v54 = v113;
              log = v53;
              if (!os_log_type_enabled(v53, v113))
                goto LABEL_131;
              v55 = *(const char **)(v7 + 16);
              if (!v55)
                v55 = "invalid";
              *(_DWORD *)buf = 136446722;
              v115 = "__nw_protocol_get_output_frames";
              v116 = 2082;
              v117 = (char *)v55;
              v118 = 2048;
              v119 = (const char *)v7;
              v56 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_129:
              v82 = log;
              v83 = v54;
LABEL_130:
              _os_log_impl(&dword_182FBE000, v82, v83, v56, buf, 0x20u);
              goto LABEL_131;
            }
            if (!v112)
            {
              v80 = __nwlog_obj();
              v54 = v113;
              log = v80;
              if (!os_log_type_enabled(v80, v113))
                goto LABEL_131;
              v81 = *(const char **)(v7 + 16);
              if (!v81)
                v81 = "invalid";
              *(_DWORD *)buf = 136446722;
              v115 = "__nw_protocol_get_output_frames";
              v116 = 2082;
              v117 = (char *)v81;
              v118 = 2048;
              v119 = (const char *)v7;
              v56 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
              goto LABEL_129;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            loga = __nwlog_obj();
            type = v113;
            v62 = os_log_type_enabled(loga, v113);
            if (backtrace_string)
            {
              if (v62)
              {
                v63 = *(const char **)(v7 + 16);
                if (!v63)
                  v63 = "invalid";
                *(_DWORD *)buf = 136446978;
                v115 = "__nw_protocol_get_output_frames";
                v116 = 2082;
                v117 = (char *)v63;
                v118 = 2048;
                v119 = (const char *)v7;
                v120 = 2082;
                v121 = backtrace_string;
                _os_log_impl(&dword_182FBE000, loga, type, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
              }
              free(backtrace_string);
            }
            else if (v62)
            {
              v84 = *(const char **)(v7 + 16);
              if (!v84)
                v84 = "invalid";
              *(_DWORD *)buf = 136446722;
              v115 = "__nw_protocol_get_output_frames";
              v116 = 2082;
              v117 = (char *)v84;
              v118 = 2048;
              v119 = (const char *)v7;
              v56 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
              v82 = loga;
              v83 = type;
              goto LABEL_130;
            }
          }
LABEL_131:
          if (v92)
            free(v92);
          v16 = 0;
          if (v12 != &nw_protocol_ref_counted_handle)
          {
LABEL_15:
            if (v10 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v7 + 40) == &nw_protocol_ref_counted_handle)
            {
              v43 = *(_QWORD *)(v7 + 88);
              if (v43)
              {
                v44 = v43 - 1;
                *(_QWORD *)(v7 + 88) = v44;
                if (!v44)
                {
                  v45 = *(void (***)(_QWORD))(v7 + 64);
                  if (v45)
                  {
                    *(_QWORD *)(v7 + 64) = 0;
                    v45[2](v45);
                    _Block_release(v45);
                  }
                  if ((*(_BYTE *)(v7 + 72) & 1) != 0)
                  {
                    v46 = *(const void **)(v7 + 64);
                    if (v46)
                      _Block_release(v46);
                  }
                  free((void *)v7);
                }
              }
            }
            if (v16)
            {
              v17 = 0;
              v18 = v111;
              v19 = v107[0];
              while (v19)
              {
                v23 = *(_DWORD *)(v19 + 52);
                if (v23)
                  v23 -= *(_DWORD *)(v19 + 56) + *(_DWORD *)(v19 + 60);
                v19 = *(_QWORD *)(v19 + 32);
                v20 = __CFADD__(v17, v23);
                v21 = v17 + v23;
                v17 += v23;
                if (v20)
                  v22 = -1;
                else
                  v22 = v21;
                if (v22 >= v111)
                  goto LABEL_34;
              }
              if (v17 < v111)
                goto LABEL_27;
LABEL_34:
              if ((a3[17] & 1) == 0)
              {
                if (gLogDatapath)
                {
                  v72 = __nwlog_obj();
                  v73 = os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG);
                  v18 = v111;
                  if (v73)
                  {
                    *(_DWORD *)buf = 136447490;
                    v115 = "nw_protocol_ipv4_frame_output_finalizer";
                    v116 = 2082;
                    v117 = (char *)a3 + 137;
                    v118 = 2080;
                    v119 = " ";
                    v120 = 2048;
                    v121 = (char *)a3;
                    v122 = 1024;
                    v123 = v16;
                    v124 = 1024;
                    v125 = v111;
                    _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Got %u packets to fragment %u bytes", buf, 0x36u);
                    v18 = v111;
                  }
                }
              }
              v93[0] = MEMORY[0x1E0C809B0];
              v93[1] = 0x40000000;
              v94 = ___ZL39nw_protocol_ipv4_frame_output_finalizerP8nw_framebPv_block_invoke_30;
              v95 = &unk_1E14AC648;
              v101 = v18;
              v96 = v109;
              v97 = v107;
              v98 = a3;
              v99 = a1;
              v102 = __buf;
              v100 = v6;
              v28 = v107[0];
              do
              {
                if (!v28)
                  break;
                v29 = *(_QWORD *)(v28 + 32);
                v30 = ((uint64_t (*)(_QWORD *))v94)(v93);
                v28 = v29;
              }
              while ((v30 & 1) != 0);
              v31 = *(a3 - 8);
              if (v31)
              {
                v32 = *(void **)(v31 + 40);
                if (v32 == &nw_protocol_ref_counted_handle)
                {
                  v33 = *(_QWORD *)(v31 + 88);
                  if (v33)
                    *(_QWORD *)(v31 + 88) = v33 + 1;
                }
                v34 = *(_QWORD *)(v31 + 24);
                if (v34)
                {
                  v35 = *(void (**)(uint64_t, _QWORD *))(v34 + 96);
                  if (v35)
                  {
                    v35(v31, v107);
LABEL_46:
                    if (v32 != &nw_protocol_ref_counted_handle)
                      goto LABEL_48;
                    if (*(_UNKNOWN **)(v31 + 40) != &nw_protocol_ref_counted_handle)
                      goto LABEL_48;
                    v47 = *(_QWORD *)(v31 + 88);
                    if (!v47)
                      goto LABEL_48;
                    v48 = v47 - 1;
                    *(_QWORD *)(v31 + 88) = v48;
                    if (v48)
                      goto LABEL_48;
                    v49 = *(void (***)(_QWORD))(v31 + 64);
                    if (v49)
                    {
                      *(_QWORD *)(v31 + 64) = 0;
                      v49[2](v49);
                      _Block_release(v49);
                    }
                    if ((*(_BYTE *)(v31 + 72) & 1) != 0)
                    {
                      v50 = *(const void **)(v31 + 64);
                      if (v50)
                        _Block_release(v50);
                    }
                    goto LABEL_78;
                  }
                }
                __nwlog_obj();
                v64 = *(const char **)(v31 + 16);
                *(_DWORD *)buf = 136446722;
                v115 = "__nw_protocol_finalize_output_frames";
                if (!v64)
                  v64 = "invalid";
                v116 = 2082;
                v117 = (char *)v64;
                v118 = 2048;
                v119 = (const char *)v31;
                v65 = (char *)_os_log_send_and_compose_impl();
                v113 = OS_LOG_TYPE_ERROR;
                v112 = 0;
                if (__nwlog_fault(v65, &v113, &v112))
                {
                  if (v113 == OS_LOG_TYPE_FAULT)
                  {
                    v66 = __nwlog_obj();
                    v67 = v113;
                    if (!os_log_type_enabled(v66, v113))
                      goto LABEL_161;
                    v68 = *(const char **)(v31 + 16);
                    if (!v68)
                      v68 = "invalid";
                    *(_DWORD *)buf = 136446722;
                    v115 = "__nw_protocol_finalize_output_frames";
                    v116 = 2082;
                    v117 = (char *)v68;
                    v118 = 2048;
                    v119 = (const char *)v31;
                    v69 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
                    goto LABEL_160;
                  }
                  if (!v112)
                  {
                    v66 = __nwlog_obj();
                    v67 = v113;
                    if (!os_log_type_enabled(v66, v113))
                      goto LABEL_161;
                    v87 = *(const char **)(v31 + 16);
                    if (!v87)
                      v87 = "invalid";
                    *(_DWORD *)buf = 136446722;
                    v115 = "__nw_protocol_finalize_output_frames";
                    v116 = 2082;
                    v117 = (char *)v87;
                    v118 = 2048;
                    v119 = (const char *)v31;
                    v69 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
                    goto LABEL_160;
                  }
                  v77 = (char *)__nw_create_backtrace_string();
                  v66 = __nwlog_obj();
                  v67 = v113;
                  v78 = os_log_type_enabled(v66, v113);
                  if (v77)
                  {
                    if (v78)
                    {
                      v79 = *(const char **)(v31 + 16);
                      if (!v79)
                        v79 = "invalid";
                      *(_DWORD *)buf = 136446978;
                      v115 = "__nw_protocol_finalize_output_frames";
                      v116 = 2082;
                      v117 = (char *)v79;
                      v118 = 2048;
                      v119 = (const char *)v31;
                      v120 = 2082;
                      v121 = v77;
                      _os_log_impl(&dword_182FBE000, v66, v67, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
                    }
                    free(v77);
                    goto LABEL_161;
                  }
                  if (v78)
                  {
                    v88 = *(const char **)(v31 + 16);
                    if (!v88)
                      v88 = "invalid";
                    *(_DWORD *)buf = 136446722;
                    v115 = "__nw_protocol_finalize_output_frames";
                    v116 = 2082;
                    v117 = (char *)v88;
                    v118 = 2048;
                    v119 = (const char *)v31;
                    v69 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_160:
                    _os_log_impl(&dword_182FBE000, v66, v67, v69, buf, 0x20u);
                  }
                }
LABEL_161:
                if (v65)
                  free(v65);
                goto LABEL_46;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              v115 = "__nw_protocol_finalize_output_frames";
              v31 = _os_log_send_and_compose_impl();
              v113 = OS_LOG_TYPE_ERROR;
              v112 = 0;
              if (__nwlog_fault((const char *)v31, &v113, &v112))
              {
                if (v113 == OS_LOG_TYPE_FAULT)
                {
                  v74 = __nwlog_obj();
                  v75 = v113;
                  if (!os_log_type_enabled(v74, v113))
                    goto LABEL_168;
                  *(_DWORD *)buf = 136446210;
                  v115 = "__nw_protocol_finalize_output_frames";
                  v76 = "%{public}s called with null protocol";
                  goto LABEL_167;
                }
                if (!v112)
                {
                  v74 = __nwlog_obj();
                  v75 = v113;
                  if (!os_log_type_enabled(v74, v113))
                    goto LABEL_168;
                  *(_DWORD *)buf = 136446210;
                  v115 = "__nw_protocol_finalize_output_frames";
                  v76 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_167;
                }
                v85 = (char *)__nw_create_backtrace_string();
                v74 = __nwlog_obj();
                v75 = v113;
                v86 = os_log_type_enabled(v74, v113);
                if (v85)
                {
                  if (v86)
                  {
                    *(_DWORD *)buf = 136446466;
                    v115 = "__nw_protocol_finalize_output_frames";
                    v116 = 2082;
                    v117 = v85;
                    _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }
                  free(v85);
                  if (!v31)
                    goto LABEL_48;
LABEL_78:
                  free((void *)v31);
LABEL_48:
                  _Block_object_dispose(v109, 8);
                  goto LABEL_49;
                }
                if (v86)
                {
                  *(_DWORD *)buf = 136446210;
                  v115 = "__nw_protocol_finalize_output_frames";
                  v76 = "%{public}s called with null protocol, no backtrace";
LABEL_167:
                  _os_log_impl(&dword_182FBE000, v74, v75, v76, buf, 0xCu);
                }
              }
LABEL_168:
              if (!v31)
                goto LABEL_48;
              goto LABEL_78;
            }
LABEL_27:
            if ((a3[17] & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v24 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_protocol_ipv4_frame_output_finalizer";
                v116 = 2082;
                v117 = (char *)a3 + 137;
                v118 = 2080;
                v119 = " ";
                v120 = 2048;
                v121 = (char *)a3;
                v122 = 1024;
                v123 = v111;
                _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Not enough bytes to fragment %u", buf, 0x30u);
              }
            }
            v103[0] = MEMORY[0x1E0C809B0];
            v103[1] = 0x40000000;
            v104 = ___ZL39nw_protocol_ipv4_frame_output_finalizerP8nw_framebPv_block_invoke;
            v105 = &__block_descriptor_tmp_29_85773;
            v106 = v107;
            v25 = v107[0];
            do
            {
              if (!v25)
                break;
              v26 = *(_QWORD *)(v25 + 32);
              v27 = ((uint64_t (*)(_QWORD *))v104)(v103);
              v25 = v26;
            }
            while ((v27 & 1) != 0);
            goto LABEL_48;
          }
LABEL_14:
          if ((_UNKNOWN *)*(a3 - 7) == &nw_protocol_ref_counted_handle)
          {
            v39 = *(a3 - 1);
            if (v39)
            {
              v40 = v39 - 1;
              *(a3 - 1) = v40;
              if (!v40)
              {
                v41 = (void (**)(_QWORD))*(a3 - 4);
                if (v41)
                {
                  *(a3 - 4) = 0;
                  v41[2](v41);
                  _Block_release(v41);
                }
                if ((*(_BYTE *)(a3 - 3) & 1) != 0)
                {
                  v42 = (const void *)*(a3 - 4);
                  if (v42)
                    _Block_release(v42);
                }
                free(a3 - 12);
              }
            }
          }
          goto LABEL_15;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v115 = "__nw_protocol_get_output_frames";
        v57 = (char *)_os_log_send_and_compose_impl();
        v113 = OS_LOG_TYPE_ERROR;
        v112 = 0;
        if (__nwlog_fault(v57, &v113, &v112))
        {
          if (v113 == OS_LOG_TYPE_FAULT)
          {
            v58 = __nwlog_obj();
            v59 = v113;
            if (!os_log_type_enabled(v58, v113))
              goto LABEL_154;
            *(_DWORD *)buf = 136446210;
            v115 = "__nw_protocol_get_output_frames";
            v60 = "%{public}s called with null protocol";
            goto LABEL_153;
          }
          if (!v112)
          {
            v58 = __nwlog_obj();
            v59 = v113;
            if (!os_log_type_enabled(v58, v113))
              goto LABEL_154;
            *(_DWORD *)buf = 136446210;
            v115 = "__nw_protocol_get_output_frames";
            v60 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_153;
          }
          v70 = (char *)__nw_create_backtrace_string();
          v58 = __nwlog_obj();
          v59 = v113;
          v71 = os_log_type_enabled(v58, v113);
          if (v70)
          {
            if (v71)
            {
              *(_DWORD *)buf = 136446466;
              v115 = "__nw_protocol_get_output_frames";
              v116 = 2082;
              v117 = v70;
              _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v70);
            goto LABEL_154;
          }
          if (v71)
          {
            *(_DWORD *)buf = 136446210;
            v115 = "__nw_protocol_get_output_frames";
            v60 = "%{public}s called with null protocol, no backtrace";
LABEL_153:
            _os_log_impl(&dword_182FBE000, v58, v59, v60, buf, 0xCu);
          }
        }
LABEL_154:
        if (v57)
          free(v57);
        goto LABEL_27;
      }
    }
  }
LABEL_49:
  buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0);
  if (buffer)
    free(buffer);
  v37 = *((_QWORD *)a1 + 2);
  v38 = (_QWORD *)*((_QWORD *)a1 + 3);
  if (v37)
  {
    *(_QWORD *)(v37 + 24) = v38;
    v38 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    a3[13] = v38;
  }
  *v38 = v37;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  os_release(a1);
}

uint64_t ___ZL39nw_protocol_ipv4_frame_output_finalizerP8nw_framebPv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL39nw_protocol_ipv4_frame_output_finalizerP8nw_framebPv_block_invoke_30(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v29;
  _BOOL4 v30;
  const char *v31;
  const char *v32;
  const char *v33;
  NSObject *v34;
  os_log_type_t v35;
  const char *v36;
  NSObject *v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  int v41;
  int v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  const char *v46;
  unint64_t v47;
  char *backtrace_string;
  _BOOL4 v49;
  char *v50;
  _BOOL4 v51;
  char *v52;
  unsigned int v53;
  char v54;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v57;
  __int16 v58;
  void *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_DWORD *)(a1 + 72)
    || (v53 = 0, v4 = nw_frame_unclaimed_bytes(a2, &v53), v5 = v53, v53 <= 0x13))
  {
    v6 = *(_QWORD *)(a2 + 32);
    v7 = *(_QWORD **)(a2 + 40);
    if (v6)
    {
      *(_QWORD *)(v6 + 40) = v7;
      v7 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) = v7;
    }
    *v7 = v6;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
    return 1;
  }
  v8 = (unsigned __int16 *)v4;
  v9 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    v10 = *(_DWORD *)(v9 + 116);
    if (v53 > v10)
    {
      v53 = *(_DWORD *)(v9 + 116);
      v5 = v10;
    }
    v11 = v5 - 20;
    v12 = (*(_DWORD *)(a1 + 72) - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    if ((v11 & 0xFFFFFFF8) >= v12)
      v13 = v12;
    else
      v13 = v11 & 0xFFFFFFF8;
    v14 = *(_QWORD *)(v9 + 48);
    if (v14)
      ++*(_QWORD *)(v14 + 232);
    *(_QWORD *)(v4 + 12) = *(_QWORD *)(v9 + 56);
    *(_BYTE *)(v4 + 9) = *(_BYTE *)(v9 + 134);
    *(_BYTE *)(v4 + 8) = *(_BYTE *)(v9 + 135);
    *(_BYTE *)v4 = 69;
    *(_WORD *)(v4 + 2) = bswap32(v13 + 20) >> 16;
    v15 = *(_QWORD *)(a1 + 56);
    if (v15)
    {
      v16 = *(_BYTE *)(v15 + 186) & 3;
      goto LABEL_17;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "__nw_frame_get_ecn_flag";
    v33 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    v52 = (char *)v33;
    if (__nwlog_fault(v33, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v34 = __nwlog_obj();
        v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "__nw_frame_get_ecn_flag";
          v36 = "%{public}s called with null frame";
LABEL_67:
          _os_log_impl(&dword_182FBE000, v34, v35, v36, buf, 0xCu);
        }
      }
      else
      {
        v47 = v12;
        if (v54)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v34 = __nwlog_obj();
          v35 = type;
          v49 = os_log_type_enabled(v34, type);
          if (backtrace_string)
          {
            if (v49)
            {
              *(_DWORD *)buf = 136446466;
              v57 = "__nw_frame_get_ecn_flag";
              v58 = 2082;
              v59 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            v12 = v47;
            goto LABEL_68;
          }
          v12 = v47;
          if (v49)
          {
            *(_DWORD *)buf = 136446210;
            v57 = "__nw_frame_get_ecn_flag";
            v36 = "%{public}s called with null frame, no backtrace";
            goto LABEL_67;
          }
        }
        else
        {
          v34 = __nwlog_obj();
          v35 = type;
          if (os_log_type_enabled(v34, type))
          {
            *(_DWORD *)buf = 136446210;
            v57 = "__nw_frame_get_ecn_flag";
            v36 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_67;
          }
        }
      }
    }
LABEL_68:
    if (v52)
      free(v52);
    v16 = 0;
LABEL_17:
    *((_BYTE *)v8 + 1) = v16;
    v17 = (bswap32(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >> 3) >> 16) | (32 * (v11 <= v12));
    v8[3] = v17;
    v18 = *(unsigned __int16 *)(a1 + 76);
    v8[2] = v18;
    v8[5] = 0;
    v19 = *(_QWORD *)(a1 + 48);
    if ((*(_BYTE *)(v19 + 136) & 0x10) == 0)
    {
      if ((v8 & 3) != 0)
      {
        v20 = vaddvq_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)(v8 + 6))) + v8[1] + *v8 + v18 + v8[4] + v17;
        LODWORD(v21) = HIWORD(v20) + (unsigned __int16)v20 + ((HIWORD(v20) + (unsigned __int16)v20) >> 16);
      }
      else
      {
        v23 = vaddlvq_u32(*(uint32x4_t *)v8);
        v24 = ((v23 + *((unsigned int *)v8 + 4)) >> 32) + (v23 + *((_DWORD *)v8 + 4));
        v21 = (((v24 >> 16) + (unsigned __int16)v24) >> 16) + (unsigned __int16)(WORD1(v24) + v24);
        LOWORD(v21) = WORD1(v21) + v21;
      }
      v8[5] = ~(_WORD)v21;
      v25 = *(_QWORD *)(v19 + 48);
      if (v25)
        *(int64x2_t *)(v25 + 312) = vaddq_s64(*(int64x2_t *)(v25 + 312), (int64x2_t)xmmword_183C6F230);
LABEL_26:
      ++*(_QWORD *)v19;
      if ((*(_BYTE *)(v19 + 136) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v37 = __nwlog_obj();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          {
            v38 = *(_QWORD *)(a1 + 48);
            v39 = (const char *)(v38 + 137);
            v40 = "";
            if (!v38)
              v39 = "";
            v41 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            if (v38)
              v40 = " ";
            v42 = *(unsigned __int16 *)(a1 + 76);
            *(_DWORD *)buf = 136447746;
            v57 = "nw_protocol_ipv4_frame_output_finalizer_block_invoke";
            v58 = 2082;
            v59 = (void *)v39;
            v60 = 2080;
            v61 = v40;
            v62 = 2048;
            v63 = v38;
            v64 = 1024;
            v65 = v13;
            v66 = 1024;
            v67 = v41;
            v68 = 1024;
            v69 = v42;
            _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Writing fragment of length %u at offset %u with ID %u", buf, 0x3Cu);
          }
        }
      }
      memcpy(v8 + 10, (const void *)(*(_QWORD *)(a1 + 64) + *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)), v13);
      nw_frame_claim(a2, v26, v13 + 20, 0);
      nw_frame_collapse(a2);
      nw_frame_unclaim(a2, v27, v13 + 20, 0);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v13;
      return 1;
    }
    v22 = *(_QWORD *)(a1 + 56);
    if (v22)
    {
      if ((*(_WORD *)(v22 + 204) & 0x100) != 0)
        *(_BYTE *)(v22 + 203) |= 4u;
      goto LABEL_26;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "__nw_frame_add_internet_csum_flags";
    v43 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v43, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v44 = __nwlog_obj();
        v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "__nw_frame_add_internet_csum_flags";
          v46 = "%{public}s called with null frame";
LABEL_75:
          _os_log_impl(&dword_182FBE000, v44, v45, v46, buf, 0xCu);
        }
      }
      else if (v54)
      {
        v50 = (char *)__nw_create_backtrace_string();
        v44 = __nwlog_obj();
        v45 = type;
        v51 = os_log_type_enabled(v44, type);
        if (v50)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            v57 = "__nw_frame_add_internet_csum_flags";
            v58 = 2082;
            v59 = v50;
            _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v50);
          goto LABEL_76;
        }
        if (v51)
        {
          *(_DWORD *)buf = 136446210;
          v57 = "__nw_frame_add_internet_csum_flags";
          v46 = "%{public}s called with null frame, no backtrace";
          goto LABEL_75;
        }
      }
      else
      {
        v44 = __nwlog_obj();
        v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "__nw_frame_add_internet_csum_flags";
          v46 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_75;
        }
      }
    }
LABEL_76:
    if (v43)
      free(v43);
    v19 = *(_QWORD *)(a1 + 48);
    goto LABEL_26;
  }
  if (!v9 || (*(_BYTE *)(v9 + 136) & 1) == 0)
  {
    v29 = __nwlog_obj();
    v30 = os_log_type_enabled(v29, OS_LOG_TYPE_INFO);
    v9 = *(_QWORD *)(a1 + 48);
    if (v30)
    {
      v31 = (const char *)(v9 + 137);
      if (!v9)
        v31 = "";
      *(_DWORD *)buf = 136446978;
      v57 = "nw_protocol_ipv4_frame_output_finalizer_block_invoke";
      v58 = 2082;
      v59 = (void *)v31;
      v32 = " ";
      if (!v9)
        v32 = "";
      v60 = 2080;
      v61 = v32;
      v62 = 2048;
      v63 = v9;
      _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Fragment frame is no longer valid", buf, 0x2Au);
      v9 = *(_QWORD *)(a1 + 48);
    }
  }
  *(_QWORD *)(v9 + 48) = 0;
  return 1;
}

uint64_t ___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_19(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;

  if (!nw_protocol_ipv4_process_input_frame(a1[7], a2, a1[8], a1[9], (_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24), (_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24)))
  {
    --*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v4 = *(_QWORD *)(a2 + 32);
    v5 = *(_QWORD **)(a2 + 40);
    if (v4)
    {
      *(_QWORD *)(v4 + 40) = v5;
      v5 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(a1[8] + 8) = v5;
    }
    *v5 = v4;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
    *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  }
  return 1;
}

uint64_t ___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 32);
  v4 = *(_QWORD **)(a2 + 40);
  if (v3)
  {
    *(_QWORD *)(v3 + 40) = v4;
    v4 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v4;
  }
  *v4 = v3;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5 || (*(_BYTE *)(v5 + 136) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v7 = *(_QWORD *)(a1 + 40);
      v8 = (const char *)(v7 + 137);
      if (!v7)
        v8 = "";
      v11 = 136446978;
      v12 = "nw_protocol_ipv4_get_input_frames_block_invoke_2";
      v13 = 2082;
      v14 = v8;
      if (v7)
        v9 = " ";
      else
        v9 = "";
      v15 = 2080;
      v16 = v9;
      v17 = 2048;
      v18 = v7;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Dropping unused IPv4 extra fragment", (uint8_t *)&v11, 0x2Au);
    }
  }
  return 1;
}

uint64_t ___ZL36nw_protocol_ipv4_process_input_frameP16nw_protocol_ipv4P8nw_frameP16nw_frame_array_sS4_PjS5__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  NSObject *v13;
  _BOOL4 v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  const char *v27;
  char *backtrace_string;
  _BOOL4 v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  const char *v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  char v39;
  os_log_type_t type;
  unsigned int v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  unsigned int v51;
  __int16 v52;
  char *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v41 = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &v41);
  if (v4)
  {
    if (v41 > 0x13)
    {
      v5 = v41 + ((bswap32(*(unsigned __int16 *)(v4 + 6)) >> 13) & 0xFFF8) - 20;
      result = 1;
      if (v5 != *(unsigned __int16 *)(a1 + 56))
        return result;
      v7 = *(_QWORD *)(a1 + 48);
      v8 = (_QWORD *)(*(_QWORD *)(a1 + 40) + 72);
      v10 = *(_QWORD *)(a2 + 32);
      v9 = (_QWORD *)(a2 + 32);
      *(_QWORD *)(v7 + 32) = v10;
      v11 = (_QWORD *)(v10 + 40);
      if (v10)
        v8 = v11;
      *v8 = v7 + 32;
      *v9 = v7;
      *(_QWORD *)(v7 + 40) = v9;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      return 0;
    }
    v17 = *(_QWORD *)(a1 + 40);
    if (v17 && (*(_BYTE *)(v17 + 136) & 1) != 0)
      return 0;
    __nwlog_obj();
    v18 = *(_QWORD *)(a1 + 40);
    v19 = (const char *)(v18 + 137);
    *(_DWORD *)buf = 136447234;
    v43 = "nw_protocol_ipv4_process_input_frame_block_invoke";
    v44 = 2082;
    if (v18)
    {
      v20 = " ";
    }
    else
    {
      v19 = "";
      v20 = "";
    }
    v45 = v19;
    v46 = 2080;
    v47 = v20;
    v48 = 2048;
    v49 = v18;
    v50 = 1024;
    v51 = v41;
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v21, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (!os_log_type_enabled(v22, type))
          goto LABEL_49;
        v24 = *(_QWORD *)(a1 + 40);
        v25 = (const char *)(v24 + 137);
        if (v24)
        {
          v26 = " ";
        }
        else
        {
          v25 = "";
          v26 = "";
        }
        *(_DWORD *)buf = 136447234;
        v43 = "nw_protocol_ipv4_process_input_frame_block_invoke";
        v44 = 2082;
        v45 = v25;
        v46 = 2080;
        v47 = v26;
        v48 = 2048;
        v49 = v24;
        v50 = 1024;
        v51 = v41;
        v27 = "%{public}s %{public}s%s%p Invalid IP reassembly frame for ordering (length %u)";
        goto LABEL_48;
      }
      if (!v39)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (!os_log_type_enabled(v22, type))
          goto LABEL_49;
        v33 = *(_QWORD *)(a1 + 40);
        v34 = (const char *)(v33 + 137);
        if (v33)
        {
          v35 = " ";
        }
        else
        {
          v34 = "";
          v35 = "";
        }
        *(_DWORD *)buf = 136447234;
        v43 = "nw_protocol_ipv4_process_input_frame_block_invoke";
        v44 = 2082;
        v45 = v34;
        v46 = 2080;
        v47 = v35;
        v48 = 2048;
        v49 = v33;
        v50 = 1024;
        v51 = v41;
        v27 = "%{public}s %{public}s%s%p Invalid IP reassembly frame for ordering (length %u), backtrace limit exceeded";
        goto LABEL_48;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v29 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v29)
        {
          v30 = *(_QWORD *)(a1 + 40);
          v31 = (const char *)(v30 + 137);
          v32 = "";
          if (v30)
            v32 = " ";
          else
            v31 = "";
          *(_DWORD *)buf = 136447490;
          v43 = "nw_protocol_ipv4_process_input_frame_block_invoke";
          v44 = 2082;
          v45 = v31;
          v46 = 2080;
          v47 = v32;
          v48 = 2048;
          v49 = v30;
          v50 = 1024;
          v51 = v41;
          v52 = 2082;
          v53 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s %{public}s%s%p Invalid IP reassembly frame for ordering (length %u), dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(backtrace_string);
        goto LABEL_49;
      }
      v36 = "";
      if (v29)
      {
        v37 = *(_QWORD *)(a1 + 40);
        v38 = (const char *)(v37 + 137);
        if (v37)
          v36 = " ";
        else
          v38 = "";
        *(_DWORD *)buf = 136447234;
        v43 = "nw_protocol_ipv4_process_input_frame_block_invoke";
        v44 = 2082;
        v45 = v38;
        v46 = 2080;
        v47 = v36;
        v48 = 2048;
        v49 = v37;
        v50 = 1024;
        v51 = v41;
        v27 = "%{public}s %{public}s%s%p Invalid IP reassembly frame for ordering (length %u), no backtrace";
LABEL_48:
        _os_log_impl(&dword_182FBE000, v22, v23, v27, buf, 0x30u);
      }
    }
LABEL_49:
    if (v21)
      free(v21);
    return 0;
  }
  v12 = *(_QWORD *)(a1 + 40);
  if (!v12 || (*(_BYTE *)(v12 + 136) & 1) == 0)
  {
    v13 = __nwlog_obj();
    v14 = os_log_type_enabled(v13, OS_LOG_TYPE_INFO);
    v12 = *(_QWORD *)(a1 + 40);
    if (v14)
    {
      v15 = (const char *)(v12 + 137);
      if (!v12)
        v15 = "";
      *(_DWORD *)buf = 136446978;
      v43 = "nw_protocol_ipv4_process_input_frame_block_invoke";
      v44 = 2082;
      v45 = v15;
      v16 = " ";
      if (!v12)
        v16 = "";
      v46 = 2080;
      v47 = v16;
      v48 = 2048;
      v49 = v12;
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
      v12 = *(_QWORD *)(a1 + 40);
    }
  }
  result = 0;
  *(_QWORD *)(v12 + 48) = 0;
  return result;
}

uint64_t ___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t result;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  _BOOL4 v19;
  const char *v20;
  const char *v21;
  NSObject *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  int v26;
  int v27;
  unsigned int v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  _BYTE v38[10];
  _BYTE v39[6];
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v28 = 0;
  v3 = nw_frame_unclaimed_bytes(a2, &v28);
  if (v3)
  {
    v4 = v3;
    v5 = (bswap32(*(unsigned __int16 *)(v3 + 6)) >> 13) & 0x7FFF8;
    v6 = bswap32(*(unsigned __int16 *)(v3 + 2)) >> 16;
    v7 = a1[6];
    if (!v7 || (*(_BYTE *)(v7 + 136) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v22 = __nwlog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          v23 = a1[6];
          v24 = (const char *)(v23 + 137);
          v25 = "";
          if (!v23)
            v24 = "";
          v26 = *(unsigned __int16 *)(v23 + 132);
          if (v23)
            v25 = " ";
          v27 = *(unsigned __int16 *)(*(_QWORD *)(a1[4] + 8) + 24);
          *(_DWORD *)buf = 136448258;
          v30 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v31 = 2082;
          v32 = v24;
          v33 = 2080;
          v34 = v25;
          v35 = 2048;
          v36 = v23;
          v37 = 1024;
          *(_DWORD *)v38 = v26;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = v28;
          *(_WORD *)v39 = 1024;
          *(_DWORD *)&v39[2] = v6;
          v40 = 1024;
          v41 = (unsigned __int16)v5;
          v42 = 1024;
          v43 = v27;
          _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Examining fragment for IP ID %u, length %u ip_len %u offset %u aggregate length %u", buf, 0x48u);
        }
      }
    }
    v8 = *(_QWORD *)(a1[4] + 8);
    if (*(unsigned __int16 *)(v8 + 24) == (unsigned __int16)v5)
    {
      v9 = v6 - 20 + (unsigned __int16)v5;
      *(_WORD *)(v8 + 24) = v9;
      if (!__CFADD__(v6 - 20, (unsigned __int16)v5) && v9 < 0x10000)
      {
        result = 1;
        if ((*(_WORD *)(v4 + 6) & 0x20) == 0)
        {
          *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
          return 0;
        }
        return result;
      }
      v11 = a1[6];
      if (!v11 || (*(_BYTE *)(v11 + 136) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v13 = a1[6];
          v14 = (const char *)(v13 + 137);
          v15 = "";
          if (v13)
            v15 = " ";
          else
            v14 = "";
          v16 = *(unsigned __int16 *)(*(_QWORD *)(a1[4] + 8) + 24);
          *(_DWORD *)buf = 136447490;
          v30 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v31 = 2082;
          v32 = v14;
          v33 = 2080;
          v34 = v15;
          v35 = 2048;
          v36 = v13;
          v37 = 2048;
          *(_QWORD *)v38 = v28 - 20;
          *(_WORD *)&v38[8] = 1024;
          *(_DWORD *)v39 = v16;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Cannot add %lu to existing offset %u", buf, 0x3Au);
        }
      }
    }
    result = 0;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
    return result;
  }
  v17 = a1[6];
  if (!v17 || (*(_BYTE *)(v17 + 136) & 1) == 0)
  {
    v18 = __nwlog_obj();
    v19 = os_log_type_enabled(v18, OS_LOG_TYPE_INFO);
    v17 = a1[6];
    if (v19)
    {
      v20 = (const char *)(v17 + 137);
      if (!v17)
        v20 = "";
      *(_DWORD *)buf = 136446978;
      v30 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
      v31 = 2082;
      v32 = v20;
      v21 = " ";
      if (!v17)
        v21 = "";
      v33 = 2080;
      v34 = v21;
      v35 = 2048;
      v36 = v17;
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
      v17 = a1[6];
    }
  }
  result = 0;
  *(_QWORD *)(v17 + 48) = 0;
  return result;
}

void nw_protocol_ipv4_frame_input_finalizer(nw_frame *a1, BOOL a2, _QWORD *a3)
{
  void *buffer;
  uint64_t v6;
  _QWORD *v7;

  buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0);
  if (buffer)
    free(buffer);
  v6 = *((_QWORD *)a1 + 2);
  v7 = (_QWORD *)*((_QWORD *)a1 + 3);
  if (v6)
  {
    *(_QWORD *)(v6 + 24) = v7;
    v7 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    a3[11] = v7;
  }
  *v7 = v6;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  os_release(a1);
}

uint64_t ___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke_24(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  int v13;
  const char *v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  int v20;
  const char *v21;
  uint64_t result;
  char *v23;
  _BOOL4 v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  int v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  int v32;
  uint64_t v33;
  const char *v34;
  const char *v35;
  int v36;
  char *v37;
  uint64_t v38;
  NSObject *v39;
  _BOOL4 v40;
  const char *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  const char *v46;
  const char *v47;
  NSObject *v48;
  os_log_type_t v49;
  uint64_t v50;
  const char *v51;
  const char *v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  const char *v57;
  NSObject *v58;
  os_log_type_t v59;
  uint64_t v60;
  const char *v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  int v66;
  const char *v67;
  int v68;
  uint64_t v69;
  const char *v70;
  const char *v71;
  unsigned int v72;
  int v73;
  char *backtrace_string;
  _BOOL4 v75;
  uint64_t v76;
  const char *v77;
  const char *v78;
  char *v79;
  _BOOL4 v80;
  uint64_t v81;
  const char *v82;
  const char *v83;
  char *v84;
  _BOOL4 v85;
  uint64_t v86;
  const char *v87;
  const char *v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  const char *v92;
  const char *v93;
  uint64_t v94;
  const char *v95;
  const char *v96;
  uint64_t v97;
  const char *v98;
  const char *v99;
  unsigned int v100;
  int v101;
  uint64_t v102;
  const char *v103;
  const char *v104;
  NSObject *v105;
  os_log_type_t v106;
  uint32_t v107;
  uint64_t v108;
  const char *v109;
  const char *v110;
  uint64_t v111;
  const char *v112;
  const char *v113;
  unsigned int v114;
  int v115;
  char v116;
  os_log_type_t type;
  unsigned int v118;
  uint8_t buf[4];
  const char *v120;
  __int16 v121;
  const char *v122;
  __int16 v123;
  const char *v124;
  __int16 v125;
  uint64_t v126;
  __int16 v127;
  unsigned int v128;
  __int16 v129;
  _WORD v130[15];

  *(_QWORD *)&v130[11] = *MEMORY[0x1E0C80C00];
  v118 = 0;
  v3 = nw_frame_unclaimed_bytes(a2, &v118);
  if (v3)
  {
    if (v118 <= 0x13)
    {
      v43 = *(_QWORD *)(a1 + 40);
      if (v43 && (*(_BYTE *)(v43 + 136) & 1) != 0)
        return 0;
      __nwlog_obj();
      v44 = *(_QWORD *)(a1 + 40);
      v45 = (const char *)(v44 + 137);
      *(_DWORD *)buf = 136447234;
      v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
      v121 = 2082;
      if (v44)
      {
        v46 = " ";
      }
      else
      {
        v45 = "";
        v46 = "";
      }
      v122 = v45;
      v123 = 2080;
      v124 = v46;
      v125 = 2048;
      v126 = v44;
      v127 = 1024;
      v128 = v118;
      v47 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v116 = 0;
      if (__nwlog_fault(v47, &type, &v116))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v48 = __nwlog_obj();
          v49 = type;
          if (!os_log_type_enabled(v48, type))
            goto LABEL_143;
          v50 = *(_QWORD *)(a1 + 40);
          v51 = (const char *)(v50 + 137);
          if (v50)
          {
            v52 = " ";
          }
          else
          {
            v51 = "";
            v52 = "";
          }
          *(_DWORD *)buf = 136447234;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v51;
          v123 = 2080;
          v124 = v52;
          v125 = 2048;
          v126 = v50;
          v127 = 1024;
          v128 = v118;
          v53 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u)";
        }
        else if (v116)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v48 = __nwlog_obj();
          v49 = type;
          v75 = os_log_type_enabled(v48, type);
          if (backtrace_string)
          {
            if (v75)
            {
              v76 = *(_QWORD *)(a1 + 40);
              v77 = (const char *)(v76 + 137);
              if (v76)
              {
                v78 = " ";
              }
              else
              {
                v77 = "";
                v78 = "";
              }
              *(_DWORD *)buf = 136447490;
              v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
              v121 = 2082;
              v122 = v77;
              v123 = 2080;
              v124 = v78;
              v125 = 2048;
              v126 = v76;
              v127 = 1024;
              v128 = v118;
              v129 = 2082;
              *(_QWORD *)v130 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u), dumping backtrace:%{public}s", buf, 0x3Au);
            }
            free(backtrace_string);
            goto LABEL_143;
          }
          if (!v75)
            goto LABEL_143;
          v102 = *(_QWORD *)(a1 + 40);
          v103 = (const char *)(v102 + 137);
          if (v102)
          {
            v104 = " ";
          }
          else
          {
            v103 = "";
            v104 = "";
          }
          *(_DWORD *)buf = 136447234;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v103;
          v123 = 2080;
          v124 = v104;
          v125 = 2048;
          v126 = v102;
          v127 = 1024;
          v128 = v118;
          v53 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u), no backtrace";
        }
        else
        {
          v48 = __nwlog_obj();
          v49 = type;
          if (!os_log_type_enabled(v48, type))
            goto LABEL_143;
          v91 = *(_QWORD *)(a1 + 40);
          v92 = (const char *)(v91 + 137);
          if (v91)
          {
            v93 = " ";
          }
          else
          {
            v92 = "";
            v93 = "";
          }
          *(_DWORD *)buf = 136447234;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v92;
          v123 = 2080;
          v124 = v93;
          v125 = 2048;
          v126 = v91;
          v127 = 1024;
          v128 = v118;
          v53 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u), backtrace limit exceeded";
        }
        v105 = v48;
        v106 = v49;
        v107 = 48;
LABEL_142:
        _os_log_impl(&dword_182FBE000, v105, v106, v53, buf, v107);
      }
    }
    else
    {
      v4 = bswap32(*(unsigned __int16 *)(v3 + 2)) >> 16;
      if (v118 >= v4)
      {
        v5 = v4 - 20;
        v6 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (v6 + v4 - 20 <= *(_DWORD *)(a1 + 56))
        {
          memcpy((void *)(*(_QWORD *)(a1 + 48) + v6), (const void *)(v3 + 20), v4 - 20);
          v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v8 = *(_DWORD *)(v7 + 24);
          *(_DWORD *)(v7 + 24) = v8 + v5;
          if (!__CFADD__(v8, v5))
            return 1;
          v9 = *(_QWORD *)(a1 + 40);
          if (v9 && (*(_BYTE *)(v9 + 136) & 1) != 0)
            return 0;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = *(_QWORD *)(a1 + 40);
          v11 = (const char *)(v10 + 137);
          if (v10)
          {
            v12 = " ";
          }
          else
          {
            v11 = "";
            v12 = "";
          }
          v13 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136447490;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v11;
          v123 = 2080;
          v124 = v12;
          v125 = 2048;
          v126 = v10;
          v127 = 1024;
          v128 = v4 - 20;
          v129 = 1024;
          *(_DWORD *)v130 = v13;
          v14 = (const char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v116 = 0;
          if (__nwlog_fault(v14, &type, &v116))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              v16 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type))
                goto LABEL_38;
              v17 = *(_QWORD *)(a1 + 40);
              v18 = (const char *)(v17 + 137);
              if (v17)
              {
                v19 = " ";
              }
              else
              {
                v18 = "";
                v19 = "";
              }
              v20 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136447490;
              v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
              v121 = 2082;
              v122 = v18;
              v123 = 2080;
              v124 = v19;
              v125 = 2048;
              v126 = v17;
              v127 = 1024;
              v128 = v4 - 20;
              v129 = 1024;
              *(_DWORD *)v130 = v20;
              v21 = "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u";
              goto LABEL_37;
            }
            if (!v116)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = gLogObj;
              v16 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type))
                goto LABEL_38;
              v29 = *(_QWORD *)(a1 + 40);
              v30 = (const char *)(v29 + 137);
              if (v29)
              {
                v31 = " ";
              }
              else
              {
                v30 = "";
                v31 = "";
              }
              v32 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136447490;
              v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
              v121 = 2082;
              v122 = v30;
              v123 = 2080;
              v124 = v31;
              v125 = 2048;
              v126 = v29;
              v127 = 1024;
              v128 = v4 - 20;
              v129 = 1024;
              *(_DWORD *)v130 = v32;
              v21 = "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u, backtrace limit exceeded";
              goto LABEL_37;
            }
            v23 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v15 = gLogObj;
            v16 = type;
            v24 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (!v23)
            {
              if (!v24)
                goto LABEL_38;
              v33 = *(_QWORD *)(a1 + 40);
              v34 = (const char *)(v33 + 137);
              if (v33)
              {
                v35 = " ";
              }
              else
              {
                v34 = "";
                v35 = "";
              }
              v36 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136447490;
              v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
              v121 = 2082;
              v122 = v34;
              v123 = 2080;
              v124 = v35;
              v125 = 2048;
              v126 = v33;
              v127 = 1024;
              v128 = v5;
              v129 = 1024;
              *(_DWORD *)v130 = v36;
              v21 = "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u, no backtrace";
              goto LABEL_37;
            }
            if (v24)
            {
              v25 = *(_QWORD *)(a1 + 40);
              v26 = (const char *)(v25 + 137);
              if (v25)
              {
                v27 = " ";
              }
              else
              {
                v26 = "";
                v27 = "";
              }
              v28 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136447746;
              v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
              v121 = 2082;
              v122 = v26;
              v123 = 2080;
              v124 = v27;
              v125 = 2048;
              v126 = v25;
              v127 = 1024;
              v128 = v5;
              v129 = 1024;
              *(_DWORD *)v130 = v28;
              v130[2] = 2082;
              *(_QWORD *)&v130[3] = v23;
              _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s %{public}s%s%p Cannot add %u to new frame offset %u, dumping backtrace:%{public}s", buf, 0x40u);
            }
            free(v23);
          }
LABEL_38:
          if (!v14)
            return 0;
          goto LABEL_39;
        }
        v63 = *(_QWORD *)(a1 + 40);
        if (v63 && (*(_BYTE *)(v63 + 136) & 1) != 0)
          return 0;
        __nwlog_obj();
        v64 = *(_QWORD *)(a1 + 40);
        v65 = (const char *)(v64 + 137);
        v66 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (v64)
        {
          v67 = " ";
        }
        else
        {
          v65 = "";
          v67 = "";
        }
        v68 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)buf = 136447490;
        v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
        v121 = 2082;
        v122 = v65;
        v123 = 2080;
        v124 = v67;
        v125 = 2048;
        v126 = v64;
        v127 = 1024;
        v128 = v66 + v5;
        v129 = 1024;
        *(_DWORD *)v130 = v68;
        v14 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v116 = 0;
        if (!__nwlog_fault(v14, &type, &v116))
          goto LABEL_38;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v15 = __nwlog_obj();
          v16 = type;
          if (!os_log_type_enabled(v15, type))
            goto LABEL_38;
          v69 = *(_QWORD *)(a1 + 40);
          v70 = (const char *)(v69 + 137);
          if (v69)
          {
            v71 = " ";
          }
          else
          {
            v70 = "";
            v71 = "";
          }
          v72 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + v5;
          v73 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136447490;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v70;
          v123 = 2080;
          v124 = v71;
          v125 = 2048;
          v126 = v69;
          v127 = 1024;
          v128 = v72;
          v129 = 1024;
          *(_DWORD *)v130 = v73;
          v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u)";
        }
        else if (v116)
        {
          v84 = (char *)__nw_create_backtrace_string();
          v15 = __nwlog_obj();
          v16 = type;
          v85 = os_log_type_enabled(v15, type);
          if (v84)
          {
            if (v85)
            {
              v86 = *(_QWORD *)(a1 + 40);
              v87 = (const char *)(v86 + 137);
              if (v86)
              {
                v88 = " ";
              }
              else
              {
                v87 = "";
                v88 = "";
              }
              v89 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + v5;
              v90 = *(_DWORD *)(a1 + 56);
              *(_DWORD *)buf = 136447746;
              v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
              v121 = 2082;
              v122 = v87;
              v123 = 2080;
              v124 = v88;
              v125 = 2048;
              v126 = v86;
              v127 = 1024;
              v128 = v89;
              v129 = 1024;
              *(_DWORD *)v130 = v90;
              v130[2] = 2082;
              *(_QWORD *)&v130[3] = v84;
              _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), dumping backtrace:%{public}s", buf, 0x40u);
            }
            free(v84);
            if (!v14)
              return 0;
LABEL_39:
            v37 = (char *)v14;
LABEL_40:
            free(v37);
            return 0;
          }
          if (!v85)
            goto LABEL_38;
          v111 = *(_QWORD *)(a1 + 40);
          v112 = (const char *)(v111 + 137);
          if (v111)
          {
            v113 = " ";
          }
          else
          {
            v112 = "";
            v113 = "";
          }
          v114 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + v5;
          v115 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136447490;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v112;
          v123 = 2080;
          v124 = v113;
          v125 = 2048;
          v126 = v111;
          v127 = 1024;
          v128 = v114;
          v129 = 1024;
          *(_DWORD *)v130 = v115;
          v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), no backtrace";
        }
        else
        {
          v15 = __nwlog_obj();
          v16 = type;
          if (!os_log_type_enabled(v15, type))
            goto LABEL_38;
          v97 = *(_QWORD *)(a1 + 40);
          v98 = (const char *)(v97 + 137);
          if (v97)
          {
            v99 = " ";
          }
          else
          {
            v98 = "";
            v99 = "";
          }
          v100 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + v5;
          v101 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)buf = 136447490;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v98;
          v123 = 2080;
          v124 = v99;
          v125 = 2048;
          v126 = v97;
          v127 = 1024;
          v128 = v100;
          v129 = 1024;
          *(_DWORD *)v130 = v101;
          v21 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (total length %u > %u), backtrace limit exceeded";
        }
LABEL_37:
        _os_log_impl(&dword_182FBE000, v15, v16, v21, buf, 0x36u);
        goto LABEL_38;
      }
      v54 = *(_QWORD *)(a1 + 40);
      if (v54 && (*(_BYTE *)(v54 + 136) & 1) != 0)
        return 0;
      __nwlog_obj();
      v55 = *(_QWORD *)(a1 + 40);
      v56 = (const char *)(v55 + 137);
      if (!v55)
        v56 = "";
      *(_DWORD *)buf = 136447490;
      v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
      v121 = 2082;
      if (v55)
        v57 = " ";
      else
        v57 = "";
      v122 = v56;
      v123 = 2080;
      v124 = v57;
      v125 = 2048;
      v126 = v55;
      v127 = 1024;
      v128 = v118;
      v129 = 1024;
      *(_DWORD *)v130 = v4;
      v47 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v116 = 0;
      if (!__nwlog_fault(v47, &type, &v116))
        goto LABEL_143;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v58 = __nwlog_obj();
        v59 = type;
        if (!os_log_type_enabled(v58, type))
          goto LABEL_143;
        v60 = *(_QWORD *)(a1 + 40);
        v61 = (const char *)(v60 + 137);
        if (v60)
        {
          v62 = " ";
        }
        else
        {
          v61 = "";
          v62 = "";
        }
        *(_DWORD *)buf = 136447490;
        v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
        v121 = 2082;
        v122 = v61;
        v123 = 2080;
        v124 = v62;
        v125 = 2048;
        v126 = v60;
        v127 = 1024;
        v128 = v118;
        v129 = 1024;
        *(_DWORD *)v130 = v4;
        v53 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u < ip_length %u)";
        goto LABEL_141;
      }
      if (!v116)
      {
        v58 = __nwlog_obj();
        v59 = type;
        if (!os_log_type_enabled(v58, type))
          goto LABEL_143;
        v94 = *(_QWORD *)(a1 + 40);
        v95 = (const char *)(v94 + 137);
        if (v94)
        {
          v96 = " ";
        }
        else
        {
          v95 = "";
          v96 = "";
        }
        *(_DWORD *)buf = 136447490;
        v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
        v121 = 2082;
        v122 = v95;
        v123 = 2080;
        v124 = v96;
        v125 = 2048;
        v126 = v94;
        v127 = 1024;
        v128 = v118;
        v129 = 1024;
        *(_DWORD *)v130 = v4;
        v53 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u < ip_length %u), backtrace limit exceeded";
        goto LABEL_141;
      }
      v79 = (char *)__nw_create_backtrace_string();
      v58 = __nwlog_obj();
      v59 = type;
      v80 = os_log_type_enabled(v58, type);
      if (v79)
      {
        if (v80)
        {
          v81 = *(_QWORD *)(a1 + 40);
          v82 = (const char *)(v81 + 137);
          if (v81)
          {
            v83 = " ";
          }
          else
          {
            v82 = "";
            v83 = "";
          }
          *(_DWORD *)buf = 136447746;
          v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
          v121 = 2082;
          v122 = v82;
          v123 = 2080;
          v124 = v83;
          v125 = 2048;
          v126 = v81;
          v127 = 1024;
          v128 = v118;
          v129 = 1024;
          *(_DWORD *)v130 = v4;
          v130[2] = 2082;
          *(_QWORD *)&v130[3] = v79;
          _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u < ip_length %u), dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(v79);
        if (!v47)
          return 0;
LABEL_144:
        v37 = (char *)v47;
        goto LABEL_40;
      }
      if (v80)
      {
        v108 = *(_QWORD *)(a1 + 40);
        v109 = (const char *)(v108 + 137);
        if (v108)
        {
          v110 = " ";
        }
        else
        {
          v109 = "";
          v110 = "";
        }
        *(_DWORD *)buf = 136447490;
        v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
        v121 = 2082;
        v122 = v109;
        v123 = 2080;
        v124 = v110;
        v125 = 2048;
        v126 = v108;
        v127 = 1024;
        v128 = v118;
        v129 = 1024;
        *(_DWORD *)v130 = v4;
        v53 = "%{public}s %{public}s%s%p Invalid IP reassembly frame (length %u < ip_length %u), no backtrace";
LABEL_141:
        v105 = v58;
        v106 = v59;
        v107 = 54;
        goto LABEL_142;
      }
    }
LABEL_143:
    if (!v47)
      return 0;
    goto LABEL_144;
  }
  v38 = *(_QWORD *)(a1 + 40);
  if (!v38 || (*(_BYTE *)(v38 + 136) & 1) == 0)
  {
    v39 = __nwlog_obj();
    v40 = os_log_type_enabled(v39, OS_LOG_TYPE_INFO);
    v38 = *(_QWORD *)(a1 + 40);
    if (v40)
    {
      v41 = (const char *)(v38 + 137);
      if (!v38)
        v41 = "";
      *(_DWORD *)buf = 136446978;
      v120 = "nw_protocol_ipv4_append_reassembled_packets_block_invoke";
      v121 = 2082;
      v122 = v41;
      v42 = " ";
      if (!v38)
        v42 = "";
      v123 = 2080;
      v124 = v42;
      v125 = 2048;
      v126 = v38;
      _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
      v38 = *(_QWORD *)(a1 + 40);
    }
  }
  result = 0;
  *(_QWORD *)(v38 + 48) = 0;
  return result;
}

uint64_t ___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke_26(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

void sub_183B65600(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

void sub_183B673A8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t nw_throughput_to_bucket(unint64_t a1)
{
  unsigned __int8 v1;
  unsigned __int8 v2;

  v1 = 49 - __clz(a1);
  if (a1 >= 0x10000)
    v2 = v1;
  else
    v2 = 1;
  if (!a1)
    return 0;
  return v2;
}

uint64_t nw_bucket_to_throughput(unsigned int a1)
{
  uint64_t v1;

  v1 = 0x8000 << a1;
  if (a1 > 0x30)
    v1 = -1;
  if (a1)
    return v1;
  else
    return 0;
}

uint64_t __nw_channel_purge_idle_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  nw_channel_check_defunct(a3);
  return 1;
}

void nw_channel_handle_defunct(uint64_t a1)
{
  __int16 *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  char *v18;
  void *v19;
  _BOOL8 globals_for_channel;
  uint64_t v21;
  __int16 v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  char *backtrace_string;
  _BOOL4 v34;
  char *v35;
  _BOOL4 v36;
  _QWORD v37[5];
  char v38;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  _DWORD *v42;
  __int16 v43;
  int v44;
  _DWORD out[14];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    out[0] = 136446210;
    *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
    v29 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    v38 = 0;
    if (!__nwlog_fault(v29, buf, &v38))
      goto LABEL_72;
    if (buf[0] == 17)
    {
      v30 = __nwlog_obj();
      v31 = buf[0];
      if (!os_log_type_enabled(v30, (os_log_type_t)buf[0]))
        goto LABEL_72;
      out[0] = 136446210;
      *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
      v32 = "%{public}s called with null channel";
    }
    else if (v38)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = buf[0];
      v34 = os_log_type_enabled(v30, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v34)
        {
          out[0] = 136446466;
          *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
          LOWORD(out[3]) = 2082;
          *(_QWORD *)((char *)&out[3] + 2) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null channel, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
        }
        free(backtrace_string);
LABEL_72:
        if (!v29)
          return;
LABEL_73:
        free(v29);
        return;
      }
      if (!v34)
        goto LABEL_72;
      out[0] = 136446210;
      *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
      v32 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      v30 = __nwlog_obj();
      v31 = buf[0];
      if (!os_log_type_enabled(v30, (os_log_type_t)buf[0]))
        goto LABEL_72;
      out[0] = 136446210;
      *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
      v32 = "%{public}s called with null channel, backtrace limit exceeded";
    }
LABEL_71:
    _os_log_impl(&dword_182FBE000, v30, v31, v32, (uint8_t *)out, 0xCu);
    goto LABEL_72;
  }
  if (((*(unsigned __int16 *)(a1 + 444) | (*(unsigned __int8 *)(a1 + 446) << 16)) & 0x80000) == 0)
  {
    if (_nw_signposts_once != -1)
      dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
    v2 = (__int16 *)(a1 + 444);
    if (_nw_signposts_enabled && kdebug_is_enabled())
      kdebug_trace();
    *(_BYTE *)(a1 + 446) = ((unsigned __int16)*v2 | (*(unsigned __int8 *)(a1 + 446) << 16) | 0x80000u) >> 16;
    memset(out, 0, 48);
    v3 = *(_DWORD *)(a1 + 428);
    uuid_unparse((const unsigned __int8 *)(a1 + 88), (char *)out);
    snprintf((char *)&out[9], 0xCuLL, "-%u", v3);
    v5 = *(_QWORD *)(a1 + 152);
    if (!v5 || *(_DWORD *)(v5 + 124) != 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v7 = *(_DWORD *)(a1 + 432);
        *(_DWORD *)buf = 136446722;
        v40 = "nw_channel_handle_defunct";
        v41 = 2082;
        v42 = out;
        v43 = 1024;
        v44 = v7;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s Defunct channel destroyed with key: %{public}s and fd: %d", buf, 0x1Cu);
      }
    }
    v8 = *(_QWORD *)(a1 + 192);
    if (v8)
    {
      nw_queue_cancel_source(v8, v4);
      *(_QWORD *)(a1 + 192) = 0;
    }
    v9 = *(_QWORD *)(a1 + 200);
    if (v9)
    {
      nw_queue_cancel_source(v9, v4);
      *(_QWORD *)(a1 + 200) = 0;
    }
    v10 = *(_QWORD *)(a1 + 184);
    if (v10)
    {
      nw_queue_cancel_source(v10, v4);
      *(_QWORD *)(a1 + 184) = 0;
    }
    v11 = *(_QWORD *)(a1 + 168);
    if (v11)
    {
      nw_queue_cancel_source(*(_QWORD *)(a1 + 168), v4);
      *(_QWORD *)(a1 + 168) = 0;
      if ((*v2 & 8) != 0)
      {
        nw_queue_resume_source(v11, v4);
        v12 = (unsigned __int16)*v2;
        v13 = v12 & 0xFFFFFFF7 | (*(unsigned __int8 *)(a1 + 446) << 16);
        *v2 = v12 & 0xFFF7;
        *(_BYTE *)(a1 + 446) = BYTE2(v13);
      }
    }
    v14 = *(_QWORD *)(a1 + 176);
    if (v14)
    {
      nw_queue_cancel_source(*(_QWORD *)(a1 + 176), v4);
      *(_QWORD *)(a1 + 176) = 0;
      if ((*v2 & 0x10) != 0)
      {
        nw_queue_resume_source(v14, v15);
        v16 = (unsigned __int16)*v2;
        v17 = v16 & 0xFFFFFFEF | (*(unsigned __int8 *)(a1 + 446) << 16);
        *v2 = v16 & 0xFFEF;
        *(_BYTE *)(a1 + 446) = BYTE2(v17);
      }
    }
    v18 = *(char **)(a1 + 280);
    if (v18)
    {
      v37[0] = MEMORY[0x1E0C809B0];
      v37[1] = 0x40000000;
      v37[2] = ___ZL25nw_channel_handle_defunctP10nw_channel_block_invoke;
      v37[3] = &__block_descriptor_tmp_63_86324;
      v37[4] = a1;
      nw_hash_table_apply(v18, (uint64_t)v37);
    }
    v19 = *(void **)(a1 + 152);
    if (v19)
    {
      globals_for_channel = nw_context_get_globals_for_channel(v19);
      v21 = globals_for_channel;
      v22 = *v2;
      if ((*v2 & 0x4000) == 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(globals_for_channel + 20));
        v23 = (unsigned __int16)*v2;
        v24 = v23 | (*(unsigned __int8 *)(a1 + 446) << 16);
        if ((v23 & 0x4000) == 0)
        {
          *(_BYTE *)(a1 + 446) = BYTE2(v24);
          *v2 = v24 | 0x4000;
          nw_array_append(*(_QWORD *)(v21 + 8), (void *)a1);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v21 + 20));
        v22 = *v2;
      }
      if ((v22 & 0x2000) != 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v21 + 16));
        v25 = (unsigned __int16)*v2;
        if ((v25 & 0x2000) != 0)
        {
          v26 = v25 & 0xFFFFDFFF | (*(unsigned __int8 *)(a1 + 446) << 16);
          *v2 = v25 & 0xDFFF;
          *(_BYTE *)(a1 + 446) = BYTE2(v26);
          nw_dictionary_set_value(*(_QWORD *)v21, (const char *)out, 0);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v21 + 16));
      }
    }
    if (*(_QWORD *)(a1 + 136))
    {
      if (*(_QWORD *)(a1 + 208))
        dispatch_group_leave(*(dispatch_group_t *)(a1 + 208));
      else
        os_channel_destroy();
      *(_QWORD *)(a1 + 136) = 0;
    }
    *(_QWORD *)(a1 + 216) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    if (*(_QWORD *)(a1 + 144))
    {
      os_channel_attr_destroy();
      *(_QWORD *)(a1 + 144) = 0;
    }
    v27 = (unsigned __int16)*v2;
    v28 = (v27 | (*(unsigned __int8 *)(a1 + 446) << 16)) & 0xFFF7FFFF;
    *v2 = v27;
    *(_BYTE *)(a1 + 446) = BYTE2(v28);
    return;
  }
  __nwlog_obj();
  out[0] = 136446210;
  *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
  v29 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  v38 = 0;
  if (!__nwlog_fault(v29, buf, &v38))
    goto LABEL_72;
  if (buf[0] == 17)
  {
    v30 = __nwlog_obj();
    v31 = buf[0];
    if (!os_log_type_enabled(v30, (os_log_type_t)buf[0]))
      goto LABEL_72;
    out[0] = 136446210;
    *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
    v32 = "%{public}s called with null !channel->processing_defunct";
    goto LABEL_71;
  }
  if (!v38)
  {
    v30 = __nwlog_obj();
    v31 = buf[0];
    if (!os_log_type_enabled(v30, (os_log_type_t)buf[0]))
      goto LABEL_72;
    out[0] = 136446210;
    *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
    v32 = "%{public}s called with null !channel->processing_defunct, backtrace limit exceeded";
    goto LABEL_71;
  }
  v35 = (char *)__nw_create_backtrace_string();
  v30 = __nwlog_obj();
  v31 = buf[0];
  v36 = os_log_type_enabled(v30, (os_log_type_t)buf[0]);
  if (!v35)
  {
    if (!v36)
      goto LABEL_72;
    out[0] = 136446210;
    *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
    v32 = "%{public}s called with null !channel->processing_defunct, no backtrace";
    goto LABEL_71;
  }
  if (v36)
  {
    out[0] = 136446466;
    *(_QWORD *)&out[1] = "nw_channel_handle_defunct";
    LOWORD(out[3]) = 2082;
    *(_QWORD *)((char *)&out[3] + 2) = v35;
    _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null !channel->processing_defunct, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
  }
  free(v35);
  if (v29)
    goto LABEL_73;
}

uint64_t ___ZL25nw_channel_handle_defunctP10nw_channel_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t extra;

  extra = nw_hash_node_get_extra(a2);
  nw_channel_disconnect_flow(*(_QWORD *)(a1 + 32), extra);
  return 1;
}

void nw_channel_disconnect_flow(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void (*v5)(void);
  uint64_t v6;
  void (*v7)(void);
  void *v8;
  char *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  char *v17;
  _BOOL4 v18;
  NSObject *v19;
  NSObject *v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_disconnect_flow";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v11, &type, &v21))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_channel_disconnect_flow";
      v14 = "%{public}s called with null channel";
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_channel_disconnect_flow";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_50:
        if (!v11)
          return;
LABEL_51:
        free(v11);
        return;
      }
      if (!v16)
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_channel_disconnect_flow";
      v14 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_channel_disconnect_flow";
      v14 = "%{public}s called with null channel, backtrace limit exceeded";
    }
LABEL_49:
    _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
    goto LABEL_50;
  }
  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 24);
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 24);
      if (v4)
      {
        v5 = *(void (**)(void))(v4 + 56);
        if (!v5 || (v5(), (v6 = *(_QWORD *)(a2 + 24)) != 0) && (v4 = *(_QWORD *)(v6 + 24)) != 0)
        {
          v7 = *(void (**)(void))(v4 + 48);
          if (v7)
            v7();
        }
      }
    }
    v8 = *(void **)(a2 + 16);
    if (v8)
    {
      v9 = v8;
      *(_OWORD *)(v9 + 88) = 0u;
      *(_OWORD *)(v9 + 104) = 0u;
      *(_OWORD *)(v9 + 120) = 0u;

      if ((*(_BYTE *)(a2 + 121) & 0x10) != 0)
      {
        if (gLogDatapath)
        {
          v20 = __nwlog_obj();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v24 = "nw_channel_disconnect_flow";
            v25 = 2080;
            v26 = (char *)(a2 + 84);
            _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Not closing flow registration %s", buf, 0x16u);
          }
        }
      }
      else
      {
        if (gLogDatapath)
        {
          v19 = __nwlog_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v24 = "nw_channel_disconnect_flow";
            v25 = 2080;
            v26 = (char *)(a2 + 84);
            _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s Closing flow registration %s", buf, 0x16u);
          }
        }
        nw_path_flow_registration_close(*(void **)(a2 + 16));
      }
      v10 = *(void **)(a2 + 16);
      if (v10)
      {
        os_release(v10);
        *(_QWORD *)(a2 + 16) = 0;
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_channel_disconnect_flow";
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v11, &type, &v21))
    goto LABEL_50;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_50;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_disconnect_flow";
    v14 = "%{public}s called with null input_flow";
    goto LABEL_49;
  }
  if (!v21)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_50;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_disconnect_flow";
    v14 = "%{public}s called with null input_flow, backtrace limit exceeded";
    goto LABEL_49;
  }
  v17 = (char *)__nw_create_backtrace_string();
  v12 = __nwlog_obj();
  v13 = type;
  v18 = os_log_type_enabled(v12, type);
  if (!v17)
  {
    if (!v18)
      goto LABEL_50;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_disconnect_flow";
    v14 = "%{public}s called with null input_flow, no backtrace";
    goto LABEL_49;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_channel_disconnect_flow";
    v25 = 2082;
    v26 = v17;
    _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null input_flow, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v17);
  if (v11)
    goto LABEL_51;
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_86338()
{
  _BOOL8 result;

  result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

BOOL ___ZL22nw_channel_get_globalsP10nw_context_block_invoke(uint64_t a1, _QWORD *a2)
{
  _BOOL8 result;

  *a2 = nw_dictionary_create();
  result = nw_array_create();
  a2[1] = result;
  a2[2] = 0;
  return result;
}

void nw_channel_set_no_close_delay(uint64_t a1)
{
  char *v1;
  NSObject *v2;
  os_log_type_t v3;
  const char *v4;
  char *backtrace_string;
  _BOOL4 v6;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_WORD *)(a1 + 444) |= 0x40u;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_channel_set_no_close_delay";
  v1 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v1, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v2 = __nwlog_obj();
      v3 = type;
      if (!os_log_type_enabled(v2, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_channel_set_no_close_delay";
      v4 = "%{public}s called with null channel";
      goto LABEL_17;
    }
    if (!v7)
    {
      v2 = __nwlog_obj();
      v3 = type;
      if (!os_log_type_enabled(v2, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_channel_set_no_close_delay";
      v4 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v2 = __nwlog_obj();
    v3 = type;
    v6 = os_log_type_enabled(v2, type);
    if (backtrace_string)
    {
      if (v6)
      {
        *(_DWORD *)buf = 136446466;
        v10 = "nw_channel_set_no_close_delay";
        v11 = 2082;
        v12 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v2, v3, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      v10 = "nw_channel_set_no_close_delay";
      v4 = "%{public}s called with null channel, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v2, v3, v4, buf, 0xCu);
    }
  }
LABEL_18:
  if (v1)
    free(v1);
}

uint64_t __nw_channel_create_event_source_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 40) + 136))
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0, 0, 0, 6);
  while (1)
  {
    result = os_channel_get_next_event_handle();
    if ((_DWORD)result)
      break;
    os_channel_packet_free();
  }
  if ((_DWORD)result != 96)
    return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0);
  return result;
}

void __nw_channel_create_event_source_block_invoke_8(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(*(_QWORD *)(a1 + 32) + 208));
}

uint64_t __nw_channel_create_interface_advisory_source_block_invoke(uint64_t a1)
{
  uint64_t (*v2)(void);
  uint64_t result;
  void *v4;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 40) + 136))
  {
    v2 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
    return v2();
  }
  if (malloc_type_calloc(1uLL, 0x60uLL, 0xEAFB8F1AuLL))
  {
LABEL_3:
    os_channel_get_interface_advisory();
    v2 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
    return v2();
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  v4 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v4);
  if (!(_DWORD)result)
  {
    free(v4);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void __nw_channel_create_interface_advisory_source_block_invoke_2(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(*(_QWORD *)(a1 + 32) + 208));
}

void nw_channel_set_keep_path_flow_registration_open(uint64_t a1, void *a2)
{
  unsigned __int8 *v3;
  uint64_t node;
  NSObject *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  _QWORD v18[2];
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_channel_set_keep_path_flow_registration_open";
    v6 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v19) = 16;
    v14 = 0;
    if (!__nwlog_fault(v6, &v19, &v14))
      goto LABEL_38;
    if (v19 == 17)
    {
      v7 = __nwlog_obj();
      v8 = v19;
      if (!os_log_type_enabled(v7, (os_log_type_t)v19))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_channel_set_keep_path_flow_registration_open";
      v9 = "%{public}s called with null channel";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = v19;
      v11 = os_log_type_enabled(v7, (os_log_type_t)v19);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_channel_set_keep_path_flow_registration_open";
          v17 = 2082;
          v18[0] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_38:
        if (!v6)
          return;
LABEL_39:
        free(v6);
        return;
      }
      if (!v11)
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_channel_set_keep_path_flow_registration_open";
      v9 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = v19;
      if (!os_log_type_enabled(v7, (os_log_type_t)v19))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_channel_set_keep_path_flow_registration_open";
      v9 = "%{public}s called with null channel, backtrace limit exceeded";
    }
LABEL_37:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_38;
  }
  if (a2)
  {
    v19 = 0uLL;
    v3 = a2;
    if (!uuid_is_null(v3 + 32))
      v19 = *((_OWORD *)v3 + 2);

    node = nw_hash_table_get_node(*(_QWORD *)(a1 + 280), (uint64_t)&v19, 16);
    if (node)
    {
      *(_BYTE *)(node + 153) |= 0x10u;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v16 = "nw_channel_set_keep_path_flow_registration_open";
        v17 = 1042;
        LODWORD(v18[0]) = 16;
        WORD2(v18[0]) = 2098;
        *(_QWORD *)((char *)v18 + 6) = &v19;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s Node not found for flow id %{public,uuid_t}.16P", buf, 0x1Cu);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_channel_set_keep_path_flow_registration_open";
  v6 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v19) = 16;
  v14 = 0;
  if (!__nwlog_fault(v6, &v19, &v14))
    goto LABEL_38;
  if (v19 == 17)
  {
    v7 = __nwlog_obj();
    v8 = v19;
    if (!os_log_type_enabled(v7, (os_log_type_t)v19))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_channel_set_keep_path_flow_registration_open";
    v9 = "%{public}s called with null flow_registration";
    goto LABEL_37;
  }
  if (!v14)
  {
    v7 = __nwlog_obj();
    v8 = v19;
    if (!os_log_type_enabled(v7, (os_log_type_t)v19))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_channel_set_keep_path_flow_registration_open";
    v9 = "%{public}s called with null flow_registration, backtrace limit exceeded";
    goto LABEL_37;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = v19;
  v13 = os_log_type_enabled(v7, (os_log_type_t)v19);
  if (!v12)
  {
    if (!v13)
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_channel_set_keep_path_flow_registration_open";
    v9 = "%{public}s called with null flow_registration, no backtrace";
    goto LABEL_37;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_channel_set_keep_path_flow_registration_open";
    v17 = 2082;
    v18[0] = v12;
    _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v6)
    goto LABEL_39;
}

void sub_183B68E3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_35(uint64_t a1)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  if (*(_BYTE *)(a1 + 40) && *(_QWORD *)(*(_QWORD *)(a1 + 32) + 136))
    os_channel_sync();
  *(_WORD *)(*(_QWORD *)(a1 + 32) + 444) |= 4u;
  nw_channel_update_input_source(*(_QWORD *)(a1 + 32), 0, 1);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(unsigned __int16 *)(v2 + 444);
  v4 = v3 & 0xFFFFFFFB | (*(unsigned __int8 *)(v2 + 446) << 16);
  *(_WORD *)(v2 + 444) = v3 & 0xFFFB;
  *(_BYTE *)(v2 + 446) = BYTE2(v4);
}

uint64_t __nw_channel_create_with_attributes_block_invoke(uint64_t a1, const char *a2)
{
  nw_append_format((const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), "%s,", a2);
  return 1;
}

uint64_t ___ZL30nw_channel_update_input_sourceP10nw_channelP11nw_protocolb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;

  nw_frame_finalize(a2);
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 344) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  return 1;
}

uint64_t nw_channel_add_input_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t next_slot;
  unsigned __int16 *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t packet;
  uint64_t v10;
  uint64_t v11;
  uint64_t node;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t *v20;
  uint64_t extra;
  uint64_t *v22;
  uint64_t next_buflet;
  uint64_t v24;
  unsigned int data_offset;
  uint64_t object_address;
  uint64_t v27;
  uint64_t v28;
  int data_length;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int segment_count;
  const char *v37;
  uint64_t v38;
  os_log_type_t v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  const char *v43;
  uint64_t v44;
  os_log_type_t v45;
  char *v46;
  uint64_t v47;
  _BOOL4 v48;
  NSObject *v49;
  os_log_type_t v50;
  const char *v51;
  uint64_t v52;
  _BOOL4 v53;
  uint64_t v54;
  os_log_type_t v55;
  uint64_t v56;
  os_log_type_t v57;
  _QWORD *v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  NSObject *v66;
  uint64_t v67;
  char v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  _QWORD *v75;
  int v76;
  int v77;
  char *v78;
  NSObject *v79;
  os_log_type_t v80;
  NSObject *v81;
  os_log_type_t v82;
  const char *v83;
  char *v84;
  NSObject *v85;
  os_log_type_t v86;
  _BOOL4 v87;
  NSObject *v88;
  os_log_type_t v89;
  char *v90;
  uint64_t v91;
  os_log_type_t v92;
  NSObject *v93;
  os_log_type_t v94;
  const char *v95;
  NSObject *v96;
  char *v97;
  uint64_t v98;
  os_log_type_t v99;
  NSObject *v100;
  os_log_type_t v101;
  const char *v102;
  char *v103;
  NSObject *v104;
  os_log_type_t v105;
  _BOOL4 v106;
  char *v107;
  NSObject *v108;
  os_log_type_t v109;
  _BOOL4 v110;
  uint64_t v111;
  os_log_type_t v112;
  uint64_t v113;
  os_log_type_t v114;
  _QWORD *v115;
  unint64_t v116;
  unint64_t v117;
  NSObject *v118;
  int v119;
  char *v120;
  NSObject *v121;
  os_log_type_t v122;
  NSObject *v123;
  os_log_type_t v124;
  const char *v125;
  char *v126;
  NSObject *v127;
  os_log_type_t v128;
  _BOOL4 v129;
  uint64_t v130;
  char *v131;
  NSObject *v132;
  os_log_type_t v133;
  NSObject *v134;
  os_log_type_t v135;
  const char *v136;
  uint64_t v137;
  char *v138;
  NSObject *v139;
  os_log_type_t v140;
  NSObject *v141;
  os_log_type_t v142;
  const char *v143;
  NSObject *v144;
  os_log_type_t v145;
  NSObject *v146;
  os_log_type_t v147;
  char *backtrace_string;
  NSObject *v149;
  os_log_type_t v150;
  _BOOL4 v151;
  char *v152;
  NSObject *v153;
  os_log_type_t v154;
  _BOOL4 v155;
  char *v156;
  NSObject *v157;
  os_log_type_t v158;
  _BOOL4 v159;
  NSObject *v160;
  os_log_type_t v161;
  NSObject *v162;
  os_log_type_t v163;
  NSObject *v164;
  os_log_type_t v165;
  char v166;
  _BOOL4 v168;
  int v169;
  int v170;
  uint64_t v171;
  int v172;
  void *v173;
  uint64_t *v174;
  unint64_t v175;
  unint64_t v176;
  char *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  void (*v181)(uint64_t, void *);
  void *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  void (**v187)(_QWORD);
  const void *v188;
  uint64_t v189;
  uint64_t v190;
  void (**v191)(_QWORD);
  const void *v192;
  const char *v193;
  NSObject *v194;
  os_log_type_t v195;
  NSObject *v196;
  os_log_type_t v197;
  const char *v198;
  char *v199;
  NSObject *v200;
  os_log_type_t v201;
  _BOOL4 v202;
  NSObject *v203;
  os_log_type_t v204;
  uint64_t *v205;
  uint64_t v206;
  uint64_t v207;
  void (*v208)(uint64_t, void *);
  void *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  void (**v214)(_QWORD);
  const void *v215;
  uint64_t v216;
  uint64_t v217;
  void (**v218)(_QWORD);
  const void *v219;
  unsigned int v220;
  uint64_t v221;
  int v222;
  char v223;
  int v224;
  char *v225;
  NSObject *v226;
  os_log_type_t v227;
  const char *v228;
  char *v229;
  _BOOL4 v230;
  os_log_type_t v231;
  os_log_type_t v232;
  uint64_t v233;
  unint64_t v234;
  uint64_t v236;
  uint64_t v237;
  unsigned __int16 *v238;
  char v239;
  char *v240;
  int buflet_count;
  _BOOL4 v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  char v246;
  os_log_type_t type[2];
  __int128 v248;
  __int128 v249;
  __int128 v250;
  __int128 v251;
  os_log_type_t v252;
  uint8_t buf[4];
  const char *v254;
  __int16 v255;
  _QWORD v256[2];
  os_log_type_t v257[8];
  uint64_t v258;
  _QWORD v259[36];

  v259[33] = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 136) || !*(_QWORD *)(a1 + 224) || !os_channel_available_slot_count())
  {
    v166 = 0;
    return v166 & 1;
  }
  memset(v259, 0, 256);
  v250 = 0u;
  v251 = 0u;
  v248 = 0u;
  v249 = 0u;
  v3 = *(_QWORD *)(a1 + 288);
  next_slot = os_channel_get_next_slot();
  v245 = a1;
  v5 = (unsigned __int16 *)(a1 + 444);
  if (!next_slot)
  {
    v168 = 0;
    v166 = 0;
    v169 = *v5 | (*(unsigned __int8 *)(a1 + 446) << 16) | 0x8000;
    v170 = 1;
    goto LABEL_357;
  }
  v239 = 0;
  v6 = 0;
  v7 = 0;
  v238 = (unsigned __int16 *)(a1 + 444);
  while (1)
  {
    v8 = next_slot;
    if (!v3)
    {
      nw_channel_allocate_frames((_QWORD *)v245);
      v3 = *(_QWORD *)(v245 + 288);
      if (!v3)
      {
        v8 = v7;
        goto LABEL_269;
      }
    }
    v237 = v7;
    packet = os_channel_slot_get_packet();
    v243 = v3;
    if (!packet)
    {
      v130 = v8;
      if ((nw_channel_check_defunct(v245) & 1) != 0)
        goto LABEL_381;
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v254 = "nw_channel_add_input_frames";
      v131 = (char *)_os_log_send_and_compose_impl();
      v257[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v131, v257, type))
        goto LABEL_262;
      if (v257[0] == OS_LOG_TYPE_FAULT)
      {
        v132 = __nwlog_obj();
        v133 = v257[0];
        if (os_log_type_enabled(v132, v257[0]))
        {
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v134 = v132;
          v135 = v133;
          v136 = "%{public}s failed to get packet from channel";
          goto LABEL_261;
        }
        goto LABEL_262;
      }
      if (type[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v149 = __nwlog_obj();
        v150 = v257[0];
        v151 = os_log_type_enabled(v149, v257[0]);
        if (backtrace_string)
        {
          if (v151)
          {
            *(_DWORD *)buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            v255 = 2082;
            v256[0] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v149, v150, "%{public}s failed to get packet from channel, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_262;
        }
        if (!v151)
          goto LABEL_262;
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v134 = v149;
        v135 = v150;
        v136 = "%{public}s failed to get packet from channel, no backtrace";
      }
      else
      {
        v160 = __nwlog_obj();
        v161 = v257[0];
        if (!os_log_type_enabled(v160, v257[0]))
          goto LABEL_262;
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v134 = v160;
        v135 = v161;
        v136 = "%{public}s failed to get packet from channel, backtrace limit exceeded";
      }
      goto LABEL_261;
    }
    v10 = packet;
    if (os_packet_get_trace_id())
      os_packet_trace_event();
    if ((*v5 & 0x1000) != 0 && os_channel_slot_detach_packet())
    {
      v130 = v8;
      if ((nw_channel_check_defunct(v245) & 1) != 0)
        goto LABEL_381;
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v254 = "nw_channel_add_input_frames";
      v131 = (char *)_os_log_send_and_compose_impl();
      v257[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v131, v257, type))
        goto LABEL_262;
      if (v257[0] == OS_LOG_TYPE_FAULT)
      {
        v146 = __nwlog_obj();
        v147 = v257[0];
        if (os_log_type_enabled(v146, v257[0]))
        {
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v134 = v146;
          v135 = v147;
          v136 = "%{public}s failed to detach packet";
          goto LABEL_261;
        }
LABEL_262:
        if (v131)
LABEL_263:
          free(v131);
LABEL_264:
        v8 = v130;
        v3 = v243;
        goto LABEL_187;
      }
      if (type[0])
      {
        v156 = (char *)__nw_create_backtrace_string();
        v157 = __nwlog_obj();
        v158 = v257[0];
        v159 = os_log_type_enabled(v157, v257[0]);
        if (v156)
        {
          if (v159)
          {
            *(_DWORD *)buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            v255 = 2082;
            v256[0] = v156;
            _os_log_impl(&dword_182FBE000, v157, v158, "%{public}s failed to detach packet, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v156);
          if (v131)
            goto LABEL_263;
          goto LABEL_264;
        }
        if (!v159)
          goto LABEL_262;
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v134 = v157;
        v135 = v158;
        v136 = "%{public}s failed to detach packet, no backtrace";
      }
      else
      {
        v164 = __nwlog_obj();
        v165 = v257[0];
        if (!os_log_type_enabled(v164, v257[0]))
          goto LABEL_262;
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v134 = v164;
        v135 = v165;
        v136 = "%{public}s failed to detach packet, backtrace limit exceeded";
      }
LABEL_261:
      _os_log_impl(&dword_182FBE000, v134, v135, v136, buf, 0xCu);
      goto LABEL_262;
    }
    if (!os_packet_get_data_length())
    {
      v137 = v8;
      if ((nw_channel_check_defunct(v245) & 1) != 0)
        goto LABEL_381;
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v254 = "nw_channel_add_input_frames";
      v138 = (char *)_os_log_send_and_compose_impl();
      v257[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v138, v257, type))
      {
        if (v257[0] == OS_LOG_TYPE_FAULT)
        {
          v139 = __nwlog_obj();
          v140 = v257[0];
          if (!os_log_type_enabled(v139, v257[0]))
            goto LABEL_250;
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v141 = v139;
          v142 = v140;
          v143 = "%{public}s zero length packet";
LABEL_249:
          _os_log_impl(&dword_182FBE000, v141, v142, v143, buf, 0xCu);
          goto LABEL_250;
        }
        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          v162 = __nwlog_obj();
          v163 = v257[0];
          if (!os_log_type_enabled(v162, v257[0]))
            goto LABEL_250;
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v141 = v162;
          v142 = v163;
          v143 = "%{public}s zero length packet, backtrace limit exceeded";
          goto LABEL_249;
        }
        v152 = (char *)__nw_create_backtrace_string();
        v153 = __nwlog_obj();
        v154 = v257[0];
        v155 = os_log_type_enabled(v153, v257[0]);
        if (!v152)
        {
          if (!v155)
            goto LABEL_250;
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v141 = v153;
          v142 = v154;
          v143 = "%{public}s zero length packet, no backtrace";
          goto LABEL_249;
        }
        if (v155)
        {
          *(_DWORD *)buf = 136446466;
          v254 = "nw_channel_add_input_frames";
          v255 = 2082;
          v256[0] = v152;
          _os_log_impl(&dword_182FBE000, v153, v154, "%{public}s zero length packet, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v152);
      }
LABEL_250:
      if (v138)
        free(v138);
      v3 = v243;
      if ((*v5 & 0x1000) == 0)
      {
        v8 = v137;
        goto LABEL_187;
      }
      v8 = v137;
      if (*(_QWORD *)(v245 + 136) && os_channel_packet_free())
      {
        nw_channel_check_defunct(v245);
        v8 = v237;
        goto LABEL_269;
      }
      goto LABEL_187;
    }
    *(_QWORD *)v257 = 0;
    v258 = 0;
    os_packet_get_flow_uuid();
    if (((*v5 & 0x100) == 0
       || (v11 = *(_QWORD *)(v245 + 280)) == 0
       || (node = nw_hash_table_get_node(v11, (uint64_t)v257, 16)) == 0)
      && ((v13 = *(_QWORD *)(v245 + 272)) == 0 || (node = *(_QWORD *)(v13 + 56)) == 0)
      || (v14 = *(_QWORD *)(node + 16)) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v254 = "nw_channel_add_input_frames";
        v255 = 1042;
        LODWORD(v256[0]) = 16;
        WORD2(v256[0]) = 2098;
        *(_QWORD *)((char *)v256 + 6) = v257;
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s Failed to find client for slot (%{public,uuid_t}.16P)", buf, 0x1Cu);
      }
      if ((*v5 & 0x1000) != 0)
      {
        v17 = v245;
        if (*(_QWORD *)(v245 + 136))
        {
          if (os_channel_packet_free())
            goto LABEL_380;
        }
      }
      goto LABEL_187;
    }
    v15 = *(_QWORD *)(v14 + 56);
    v236 = *(_QWORD *)(node + 16);
    v242 = v15 && (*(unsigned __int8 *)(v15 + 153) >> 2) & 1;
    v18 = *(_WORD *)(v3 + 204) & 0xFF7F | (*(unsigned __int8 *)(v3 + 206) << 16);
    *(_WORD *)(v3 + 204) &= ~0x80u;
    *(_BYTE *)(v3 + 206) = BYTE2(v18);
    buflet_count = os_packet_get_buflet_count();
    if (buflet_count)
      break;
    v61 = v236;
    if ((*(_WORD *)(v3 + 204) & 0x80) != 0)
    {
      v234 = v6;
      LOWORD(v6) = 0;
      v62 = v3;
      goto LABEL_91;
    }
LABEL_179:
    if (v61 != a2)
    {
      if (v6)
      {
        v115 = v259;
        v116 = v6;
        while (*v115 != v61)
        {
          ++v115;
          if (!--v116)
          {
            v117 = v6;
            goto LABEL_186;
          }
        }
      }
      else
      {
        v117 = 0;
LABEL_186:
        v259[v117] = v61;
        ++v6;
      }
    }
LABEL_187:
    next_slot = os_channel_get_next_slot();
    if (next_slot)
    {
      v7 = v8;
      if (v6 < 0x20)
        continue;
    }
    goto LABEL_269;
  }
  v233 = v8;
  v234 = v6;
  v19 = 0;
  LODWORD(v6) = 0;
  while (1)
  {
    next_buflet = os_packet_get_next_buflet();
    if (!next_buflet)
    {
      v118 = __nwlog_obj();
      if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        _os_log_impl(&dword_182FBE000, v118, OS_LOG_TYPE_ERROR, "%{public}s os_packet_get_next_buflet() returns NULL", buf, 0xCu);
      }
      v27 = v3;
      v5 = v238;
      v6 = v234;
      v65 = v243;
      goto LABEL_98;
    }
    v24 = next_buflet;
    data_offset = os_buflet_get_data_offset();
    object_address = os_buflet_get_object_address();
    v27 = v3;
    if (!v3)
    {
      nw_channel_allocate_frames((_QWORD *)v245);
      v27 = *(_QWORD *)(v245 + 288);
      if (!v27)
      {
        v63 = v245;
        v64 = *(_QWORD *)(v245 + 152);
        if (!v64 || *(_DWORD *)(v64 + 124) != 4)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v66 = gLogObj;
          v5 = v238;
          v6 = v234;
          v65 = v243;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446210;
            v254 = "nw_channel_add_input_frames";
            _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_INFO, "%{public}s nw_channel_allocate_frames() is out of frames", buf, 0xCu);
          }
          v27 = 0;
          goto LABEL_98;
        }
        v27 = 0;
        v5 = v238;
        v6 = v234;
        v65 = v243;
        goto LABEL_99;
      }
    }
    v28 = node;
    data_length = os_buflet_get_data_length();
    v30 = object_address + data_offset;
    v31 = v245;
    nw_frame_reset(v27, v30, data_length, (uint64_t)nw_channel_finalize_input_frame, v245);
    if (v242)
      nw_frame_set_metadata(v27, 0, 1, 1);
    if ((*(_WORD *)(v27 + 204) & 4) != 0)
    {
      *(_QWORD *)(v27 + 208) = v10;
      *(_QWORD *)(v27 + 216) = v24;
      *(_BYTE *)(v27 + 232) = *(_BYTE *)(v27 + 232) & 0xFE | ((*v238 & 0x400) != 0);
    }
    v32 = os_packet_increment_use_count();
    if (v32)
      break;
    v33 = *(unsigned __int16 *)(v27 + 204);
    v34 = *(unsigned __int8 *)(v27 + 206);
    *(_WORD *)(v27 + 204) = v33 | 0x2000;
    if (!v19)
    {
      if ((*v238 & 0x400) == 0 || os_packet_get_aggregation_type() != 2)
      {
LABEL_78:
        if (os_packet_get_wake_flag())
          *(_WORD *)(v243 + 204) |= 0x4000u;
        goto LABEL_80;
      }
      *(_WORD *)(v243 + 204) |= 0x80u;
      segment_count = os_packet_get_segment_count();
      if (segment_count)
      {
        if ((*(_WORD *)(v243 + 204) & 0x40) == 0)
        {
          *(_BYTE *)(v243 + 200) = segment_count;
          goto LABEL_78;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v254 = "__nw_frame_set_segment_count";
        v43 = (const char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v252 = OS_LOG_TYPE_DEFAULT;
        v240 = (char *)v43;
        if (!__nwlog_fault(v43, type, &v252))
          goto LABEL_75;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v44 = gLogObj;
          v45 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v254 = "__nw_frame_set_segment_count";
            v40 = v44;
            v41 = v45;
            v42 = "%{public}s Attempt to set segment-count on a chain-member";
            goto LABEL_74;
          }
LABEL_75:
          if (v240)
            free(v240);
          v31 = v245;
          goto LABEL_78;
        }
        if (v252)
        {
          v46 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v52 = gLogObj;
          v232 = type[0];
          v53 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v46)
          {
            if (v53)
            {
              *(_DWORD *)buf = 136446466;
              v254 = "__nw_frame_set_segment_count";
              v255 = 2082;
              v256[0] = v46;
              v49 = v52;
              v50 = v232;
              v51 = "%{public}s Attempt to set segment-count on a chain-member, dumping backtrace:%{public}s";
LABEL_64:
              _os_log_impl(&dword_182FBE000, v49, v50, v51, buf, 0x16u);
            }
            goto LABEL_65;
          }
          if (!v53)
            goto LABEL_75;
          *(_DWORD *)buf = 136446210;
          v254 = "__nw_frame_set_segment_count";
          v40 = v52;
          v41 = v232;
          v42 = "%{public}s Attempt to set segment-count on a chain-member, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = gLogObj;
          v57 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
            goto LABEL_75;
          *(_DWORD *)buf = 136446210;
          v254 = "__nw_frame_set_segment_count";
          v40 = v56;
          v41 = v57;
          v42 = "%{public}s Attempt to set segment-count on a chain-member, backtrace limit exceeded";
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v37 = (const char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v252 = OS_LOG_TYPE_DEFAULT;
        v240 = (char *)v37;
        if (!__nwlog_fault(v37, type, &v252))
          goto LABEL_75;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = gLogObj;
          v39 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v254 = "nw_channel_add_input_frames";
            v40 = v38;
            v41 = v39;
            v42 = "%{public}s No segment-count set on single-IP aggregate";
            goto LABEL_74;
          }
          goto LABEL_75;
        }
        if (v252)
        {
          v46 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v47 = gLogObj;
          v231 = type[0];
          v48 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v46)
          {
            if (v48)
            {
              *(_DWORD *)buf = 136446466;
              v254 = "nw_channel_add_input_frames";
              v255 = 2082;
              v256[0] = v46;
              v49 = v47;
              v50 = v231;
              v51 = "%{public}s No segment-count set on single-IP aggregate, dumping backtrace:%{public}s";
              goto LABEL_64;
            }
LABEL_65:
            free(v46);
            goto LABEL_75;
          }
          if (!v48)
            goto LABEL_75;
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v40 = v47;
          v41 = v231;
          v42 = "%{public}s No segment-count set on single-IP aggregate, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          v55 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
            goto LABEL_75;
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v40 = v54;
          v41 = v55;
          v42 = "%{public}s No segment-count set on single-IP aggregate, backtrace limit exceeded";
        }
      }
LABEL_74:
      _os_log_impl(&dword_182FBE000, v40, v41, v42, buf, 0xCu);
      goto LABEL_75;
    }
    v35 = v33 | (v34 << 16);
    *(_BYTE *)(v27 + 206) = BYTE2(v35);
    *(_WORD *)(v27 + 204) = v35 | 0x2040;
LABEL_80:
    v59 = *(_QWORD *)(v27 + 16);
    v60 = *(_QWORD **)(v27 + 24);
    v58 = (_QWORD *)(v27 + 16);
    if (*(_OWORD *)(v27 + 16) == 0)
    {
      v60 = 0;
      v3 = 0;
    }
    else
    {
      v3 = *(_QWORD *)(v27 + 16);
    }
    if (v59)
    {
      *(_QWORD *)(v59 + 24) = v60;
      v60 = *(_QWORD **)(v27 + 24);
    }
    else
    {
      *(_QWORD *)(v31 + 296) = v60;
    }
    LODWORD(v6) = data_length + v6;
    *v60 = v59;
    *v58 = 0;
    *(_QWORD *)(v27 + 24) = 0;
    v20 = *(uint64_t **)(v31 + 328);
    *(_QWORD *)(v27 + 24) = v20;
    *v20 = v27;
    *(_QWORD *)(v31 + 328) = v58;
    ++*(_DWORD *)(v31 + 416);
    node = v28;
    extra = nw_hash_node_get_extra(v28);
    *(_QWORD *)(v27 + 32) = 0;
    v22 = *(uint64_t **)(extra + 8);
    *(_QWORD *)(v27 + 40) = v22;
    *v22 = v27;
    *(_QWORD *)(extra + 8) = v27 + 32;
    ++v19;
    v239 = 1;
    if (buflet_count == v19)
    {
      if ((*(_WORD *)(v243 + 204) & 0x80) == 0)
      {
        v239 = 1;
        v5 = v238;
        v8 = v233;
        v6 = v234;
        goto LABEL_178;
      }
      if (!WORD1(v6))
      {
        v239 = 1;
        v5 = v238;
        v8 = v233;
        v62 = v243;
        v61 = v236;
LABEL_91:
        *(_WORD *)(v62 + 196) = v6;
        v6 = v234;
        goto LABEL_179;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = v6;
      v90 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v252 = OS_LOG_TYPE_DEFAULT;
      v5 = v238;
      if (__nwlog_fault(v90, type, &v252))
      {
        if (type[0] != OS_LOG_TYPE_FAULT)
        {
          if (v252)
          {
            v107 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v108 = gLogObj;
            v109 = type[0];
            v110 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
            if (v107)
            {
              if (v110)
              {
                *(_DWORD *)buf = 136446722;
                v254 = "nw_channel_add_input_frames";
                v255 = 1024;
                LODWORD(v256[0]) = v6;
                WORD2(v256[0]) = 2082;
                *(_QWORD *)((char *)v256 + 6) = v107;
                _os_log_impl(&dword_182FBE000, v108, v109, "%{public}s Chained packet-length is too big: %u, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(v107);
              goto LABEL_175;
            }
            if (!v110)
              goto LABEL_175;
            *(_DWORD *)buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            v255 = 1024;
            LODWORD(v256[0]) = v6;
            v93 = v108;
            v94 = v109;
            v95 = "%{public}s Chained packet-length is too big: %u, no backtrace";
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v113 = gLogObj;
            v114 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
              goto LABEL_175;
            *(_DWORD *)buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            v255 = 1024;
            LODWORD(v256[0]) = v6;
            v93 = v113;
            v94 = v114;
            v95 = "%{public}s Chained packet-length is too big: %u, backtrace limit exceeded";
          }
LABEL_174:
          _os_log_impl(&dword_182FBE000, v93, v94, v95, buf, 0x12u);
          goto LABEL_175;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v91 = gLogObj;
        v92 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v254 = "nw_channel_add_input_frames";
          v255 = 1024;
          LODWORD(v256[0]) = v6;
          v93 = v91;
          v94 = v92;
          v95 = "%{public}s Chained packet-length is too big: %u";
          goto LABEL_174;
        }
      }
LABEL_175:
      if (v90)
        free(v90);
      v239 = 1;
      v8 = v233;
      v6 = v234;
LABEL_178:
      v61 = v236;
      goto LABEL_179;
    }
  }
  v119 = v32;
  __nwlog_obj();
  *(_DWORD *)buf = 136446466;
  v254 = "nw_channel_add_input_frames";
  v255 = 1024;
  LODWORD(v256[0]) = v119;
  v120 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v252 = OS_LOG_TYPE_DEFAULT;
  v5 = v238;
  v6 = v234;
  if (!__nwlog_fault(v120, type, &v252))
    goto LABEL_217;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (v252)
    {
      v126 = (char *)__nw_create_backtrace_string();
      v127 = __nwlog_obj();
      v128 = type[0];
      v129 = os_log_type_enabled(v127, type[0]);
      if (v126)
      {
        if (v129)
        {
          *(_DWORD *)buf = 136446722;
          v254 = "nw_channel_add_input_frames";
          v255 = 1024;
          LODWORD(v256[0]) = v119;
          WORD2(v256[0]) = 2082;
          *(_QWORD *)((char *)v256 + 6) = v126;
          _os_log_impl(&dword_182FBE000, v127, v128, "%{public}s os_packet_increment_use_count() %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v126);
        goto LABEL_217;
      }
      if (!v129)
        goto LABEL_217;
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = v119;
      v123 = v127;
      v124 = v128;
      v125 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d, no backtrace";
    }
    else
    {
      v144 = __nwlog_obj();
      v145 = type[0];
      if (!os_log_type_enabled(v144, type[0]))
        goto LABEL_217;
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = v119;
      v123 = v144;
      v124 = v145;
      v125 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_216:
    _os_log_impl(&dword_182FBE000, v123, v124, v125, buf, 0x12u);
    goto LABEL_217;
  }
  v121 = __nwlog_obj();
  v122 = type[0];
  if (os_log_type_enabled(v121, type[0]))
  {
    *(_DWORD *)buf = 136446466;
    v254 = "nw_channel_add_input_frames";
    v255 = 1024;
    LODWORD(v256[0]) = v119;
    v123 = v121;
    v124 = v122;
    v125 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d";
    goto LABEL_216;
  }
LABEL_217:
  if (v120)
    free(v120);
  v65 = v243;
  node = v28;
LABEL_98:
  v63 = v245;
LABEL_99:
  if ((*(_WORD *)(v65 + 204) & 0x80) == 0)
    goto LABEL_143;
  *(_WORD *)type = 1;
  v67 = nw_hash_node_get_extra(node);
  v68 = 0;
  while (2)
  {
    v70 = (_QWORD *)v65;
    v71 = (_QWORD *)(v65 + 16);
    v65 = *(_QWORD *)(v65 + 16);
    if (!v65 && !v70[3])
      v65 = 0;
    --*(_DWORD *)(v63 + 416);
    v72 = v70[4];
    v73 = (_QWORD *)v70[5];
    if (v72)
    {
      *(_QWORD *)(v72 + 40) = v73;
      v73 = (_QWORD *)v70[5];
    }
    else
    {
      *(_QWORD *)(v67 + 8) = v73;
    }
    *v73 = v72;
    v70[4] = 0;
    v70[5] = 0;
    v74 = v70[2];
    v75 = (_QWORD *)v70[3];
    if (v74)
    {
      *(_QWORD *)(v74 + 24) = v75;
      v75 = (_QWORD *)v70[3];
    }
    else
    {
      *(_QWORD *)(v63 + 328) = v75;
    }
    *v75 = v74;
    *v71 = 0;
    v71[1] = 0;
    if ((v68 & 1) != 0)
      goto LABEL_101;
    v76 = os_packet_decrement_use_count();
    if (!v76)
    {
      v68 = 0;
      goto LABEL_102;
    }
    v77 = v76;
    if ((nw_channel_check_defunct(v63) & 1) != 0)
    {
LABEL_101:
      v68 = 1;
      goto LABEL_102;
    }
    v244 = v65;
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v254 = "nw_channel_add_input_frames";
    v255 = 1024;
    LODWORD(v256[0]) = v77;
    v78 = (char *)_os_log_send_and_compose_impl();
    v252 = OS_LOG_TYPE_ERROR;
    v246 = 0;
    if (!__nwlog_fault(v78, &v252, &v246))
      goto LABEL_130;
    if (v252 == OS_LOG_TYPE_FAULT)
    {
      v79 = __nwlog_obj();
      v80 = v252;
      if (os_log_type_enabled(v79, v252))
      {
        *(_DWORD *)buf = 136446466;
        v254 = "nw_channel_add_input_frames";
        v255 = 1024;
        LODWORD(v256[0]) = v77;
        v81 = v79;
        v82 = v80;
        v83 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d";
        goto LABEL_129;
      }
      goto LABEL_130;
    }
    if (!v246)
    {
      v88 = __nwlog_obj();
      v89 = v252;
      if (!os_log_type_enabled(v88, v252))
        goto LABEL_130;
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = v77;
      v81 = v88;
      v82 = v89;
      v83 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, backtrace limit exceeded";
LABEL_129:
      _os_log_impl(&dword_182FBE000, v81, v82, v83, buf, 0x12u);
      goto LABEL_130;
    }
    v84 = (char *)__nw_create_backtrace_string();
    v85 = __nwlog_obj();
    v86 = v252;
    v87 = os_log_type_enabled(v85, v252);
    if (v84)
    {
      if (v87)
      {
        *(_DWORD *)buf = 136446722;
        v254 = "nw_channel_add_input_frames";
        v255 = 1024;
        LODWORD(v256[0]) = v77;
        WORD2(v256[0]) = 2082;
        *(_QWORD *)((char *)v256 + 6) = v84;
        _os_log_impl(&dword_182FBE000, v85, v86, "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v84);
      goto LABEL_130;
    }
    if (v87)
    {
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = v77;
      v81 = v85;
      v82 = v86;
      v83 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, no backtrace";
      goto LABEL_129;
    }
LABEL_130:
    if (v78)
      free(v78);
    v68 = 0;
    v5 = v238;
    v65 = v244;
    v63 = v245;
LABEL_102:
    v70[2] = 0;
    v69 = *(_QWORD **)(v63 + 296);
    v70[3] = v69;
    *v69 = v70;
    *(_QWORD *)(v63 + 296) = v71;
    if (v65)
      continue;
    break;
  }
  if (!*(_WORD *)type)
    v68 = 1;
  if ((v68 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v96 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v254 = "nw_channel_add_input_frames";
      v255 = 1024;
      LODWORD(v256[0]) = *(unsigned __int16 *)type;
      _os_log_impl(&dword_182FBE000, v96, OS_LOG_TYPE_ERROR, "%{public}s use_count is not 0 at the end: %u", buf, 0x12u);
    }
  }
  v6 = v234;
  v63 = v245;
LABEL_143:
  if ((nw_channel_check_defunct(v63) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v254 = "nw_channel_add_input_frames";
    v97 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v252 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v97, type, &v252))
      goto LABEL_165;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v252)
      {
        v103 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v104 = gLogObj;
        v105 = type[0];
        v106 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v103)
        {
          if (v106)
          {
            *(_DWORD *)buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            v255 = 2082;
            v256[0] = v103;
            _os_log_impl(&dword_182FBE000, v104, v105, "%{public}s failed to get buflet from packet, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v103);
          goto LABEL_165;
        }
        if (!v106)
          goto LABEL_165;
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v100 = v104;
        v101 = v105;
        v102 = "%{public}s failed to get buflet from packet, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v111 = gLogObj;
        v112 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_165;
        *(_DWORD *)buf = 136446210;
        v254 = "nw_channel_add_input_frames";
        v100 = v111;
        v101 = v112;
        v102 = "%{public}s failed to get buflet from packet, backtrace limit exceeded";
      }
LABEL_164:
      _os_log_impl(&dword_182FBE000, v100, v101, v102, buf, 0xCu);
      goto LABEL_165;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v98 = gLogObj;
    v99 = type[0];
    if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      v254 = "nw_channel_add_input_frames";
      v100 = v98;
      v101 = v99;
      v102 = "%{public}s failed to get buflet from packet";
      goto LABEL_164;
    }
LABEL_165:
    if (v97)
      free(v97);
    v17 = v245;
    if ((*v5 & 0x1000) == 0)
    {
      v3 = v27;
      v8 = v233;
      goto LABEL_187;
    }
    v8 = v233;
    if (!*(_QWORD *)(v245 + 136) || !os_channel_packet_free())
    {
      v3 = v27;
      goto LABEL_187;
    }
LABEL_380:
    nw_channel_check_defunct(v17);
  }
LABEL_381:
  v8 = v237;
LABEL_269:
  v168 = v8 != 0;
  v171 = v245;
  if (v8)
    *(_QWORD *)(v245 + 400) = v8;
  v172 = *v5;
  v169 = v172 | (*((unsigned __int8 *)v5 + 2) << 16) | 0x8000;
  *v5 = v172 | 0x8000;
  if (!v6)
  {
    v170 = 1;
    v166 = v239;
    goto LABEL_357;
  }
  v173 = (void *)(v245 + 24);
  v174 = v259;
  v175 = v6;
  v176 = v6;
  while (2)
  {
    v178 = *v174;
    if (*v174)
    {
      v179 = *(_QWORD *)(v178 + 56);
      if (v179 && ((*(_BYTE *)(v179 + 153) & 8) != 0 || (*v238 & 0x80) == 0))
      {
        v180 = *(_QWORD *)(v178 + 24);
        if (v180)
        {
          v181 = *(void (**)(uint64_t, void *))(v180 + 64);
          if (v181)
          {
            v182 = *(void **)(v178 + 40);
            if (v182 == &nw_protocol_ref_counted_handle)
            {
              v183 = *(_QWORD *)(v178 + 88);
              if (v183)
                *(_QWORD *)(v178 + 88) = v183 + 1;
            }
            if (*(_UNKNOWN **)(v171 + 64) == &nw_protocol_ref_counted_handle)
            {
              v184 = *(_QWORD *)(v171 + 112);
              if (v184)
                *(_QWORD *)(v171 + 112) = v184 + 1;
              v181(v178, v173);
              if (*(_UNKNOWN **)(v171 + 64) == &nw_protocol_ref_counted_handle)
              {
                v189 = *(_QWORD *)(v171 + 112);
                if (v189)
                {
                  v190 = v189 - 1;
                  *(_QWORD *)(v171 + 112) = v190;
                  if (!v190)
                  {
                    v191 = *(void (***)(_QWORD))(v171 + 88);
                    if (v191)
                    {
                      *(_QWORD *)(v171 + 88) = 0;
                      v191[2](v191);
                      _Block_release(v191);
                    }
                    if ((*(_BYTE *)(v171 + 96) & 1) != 0)
                    {
                      v192 = *(const void **)(v171 + 88);
                      if (v192)
                        _Block_release(v192);
                    }
                    free(v173);
                  }
                }
              }
            }
            else
            {
              v181(v178, v173);
            }
            if (v182 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v178 + 40) == &nw_protocol_ref_counted_handle)
            {
              v185 = *(_QWORD *)(v178 + 88);
              if (v185)
              {
                v186 = v185 - 1;
                *(_QWORD *)(v178 + 88) = v186;
                if (!v186)
                {
                  v187 = *(void (***)(_QWORD))(v178 + 64);
                  if (v187)
                  {
                    *(_QWORD *)(v178 + 64) = 0;
                    v187[2](v187);
                    _Block_release(v187);
                  }
                  if ((*(_BYTE *)(v178 + 72) & 1) != 0)
                  {
                    v188 = *(const void **)(v178 + 64);
                    if (v188)
                      _Block_release(v188);
                  }
                  v177 = (char *)v178;
LABEL_274:
                  free(v177);
                  goto LABEL_275;
                }
              }
            }
          }
        }
      }
      goto LABEL_276;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v254 = "__nw_protocol_get_output_handler_context";
    v193 = (const char *)_os_log_send_and_compose_impl();
    v257[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v193, v257, type))
      goto LABEL_322;
    if (v257[0] == OS_LOG_TYPE_FAULT)
    {
      v194 = __nwlog_obj();
      v195 = v257[0];
      if (os_log_type_enabled(v194, v257[0]))
      {
        *(_DWORD *)buf = 136446210;
        v254 = "__nw_protocol_get_output_handler_context";
        v196 = v194;
        v197 = v195;
        v198 = "%{public}s called with null protocol";
        goto LABEL_321;
      }
      goto LABEL_322;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v203 = __nwlog_obj();
      v204 = v257[0];
      if (!os_log_type_enabled(v203, v257[0]))
        goto LABEL_322;
      *(_DWORD *)buf = 136446210;
      v254 = "__nw_protocol_get_output_handler_context";
      v196 = v203;
      v197 = v204;
      v198 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_321:
      _os_log_impl(&dword_182FBE000, v196, v197, v198, buf, 0xCu);
      goto LABEL_322;
    }
    v199 = (char *)__nw_create_backtrace_string();
    v200 = __nwlog_obj();
    v201 = v257[0];
    v202 = os_log_type_enabled(v200, v257[0]);
    if (v199)
    {
      if (v202)
      {
        *(_DWORD *)buf = 136446466;
        v254 = "__nw_protocol_get_output_handler_context";
        v255 = 2082;
        v256[0] = v199;
        _os_log_impl(&dword_182FBE000, v200, v201, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v199);
      goto LABEL_322;
    }
    if (v202)
    {
      *(_DWORD *)buf = 136446210;
      v254 = "__nw_protocol_get_output_handler_context";
      v196 = v200;
      v197 = v201;
      v198 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_321;
    }
LABEL_322:
    if (v193)
    {
      v177 = (char *)v193;
      goto LABEL_274;
    }
LABEL_275:
    v171 = v245;
LABEL_276:
    ++v174;
    if (--v176)
      continue;
    break;
  }
  v205 = v259;
  v166 = v239;
  do
  {
    v206 = *v205;
    if (*v205)
    {
      v207 = *(_QWORD *)(v206 + 24);
      if (v207)
      {
        v208 = *(void (**)(uint64_t, void *))(v207 + 264);
        if (v208)
        {
          v209 = *(void **)(v206 + 40);
          if (v209 == &nw_protocol_ref_counted_handle)
          {
            v210 = *(_QWORD *)(v206 + 88);
            if (v210)
              *(_QWORD *)(v206 + 88) = v210 + 1;
          }
          if (*(_UNKNOWN **)(v171 + 64) == &nw_protocol_ref_counted_handle)
          {
            v211 = *(_QWORD *)(v171 + 112);
            if (v211)
              *(_QWORD *)(v171 + 112) = v211 + 1;
            v208(v206, v173);
            if (*(_UNKNOWN **)(v171 + 64) == &nw_protocol_ref_counted_handle)
            {
              v216 = *(_QWORD *)(v171 + 112);
              if (v216)
              {
                v217 = v216 - 1;
                *(_QWORD *)(v171 + 112) = v217;
                if (!v217)
                {
                  v218 = *(void (***)(_QWORD))(v171 + 88);
                  if (v218)
                  {
                    *(_QWORD *)(v171 + 88) = 0;
                    v218[2](v218);
                    _Block_release(v218);
                  }
                  if ((*(_BYTE *)(v171 + 96) & 1) != 0)
                  {
                    v219 = *(const void **)(v171 + 88);
                    if (v219)
                      _Block_release(v219);
                  }
                  free(v173);
                }
              }
            }
          }
          else
          {
            v208(v206, v173);
          }
          if (v209 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v206 + 40) == &nw_protocol_ref_counted_handle)
          {
            v212 = *(_QWORD *)(v206 + 88);
            if (v212)
            {
              v213 = v212 - 1;
              *(_QWORD *)(v206 + 88) = v213;
              if (!v213)
              {
                v214 = *(void (***)(_QWORD))(v206 + 64);
                if (v214)
                {
                  *(_QWORD *)(v206 + 64) = 0;
                  v214[2](v214);
                  _Block_release(v214);
                }
                if ((*(_BYTE *)(v206 + 72) & 1) != 0)
                {
                  v215 = *(const void **)(v206 + 64);
                  if (v215)
                    _Block_release(v215);
                }
                free((void *)v206);
                v171 = v245;
              }
            }
          }
        }
      }
    }
    ++v205;
    --v175;
  }
  while (v175);
  v170 = 0;
  v5 = v238;
  v169 = *v238 | (*((unsigned __int8 *)v238 + 2) << 16);
LABEL_357:
  *v5 = v169 & 0x7FFF;
  *((_BYTE *)v5 + 2) = (v169 & 0xFFFF7FFF) >> 16;
  if ((v169 & 0x10000) != 0)
  {
    v220 = v169 & 0xFFFE7FFF;
    *v5 = v220;
    *((_BYTE *)v5 + 2) = BYTE2(v220);
    if (*(_QWORD *)(v245 + 136))
    {
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
      if (_nw_signposts_enabled && kdebug_is_enabled())
        kdebug_trace();
      if (os_channel_sync())
        nw_channel_check_defunct(v245);
    }
  }
  if ((v168 & v170) == 1)
  {
    v221 = v245;
    if (!*(_QWORD *)(v245 + 320))
    {
      if (*(_QWORD *)(v245 + 224))
      {
        *(_DWORD *)(v245 + 416) = 0;
        v222 = os_channel_advance_slot();
        if (v222)
        {
          v224 = v222;
          if ((nw_channel_check_defunct(v245) & 1) == 0)
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446466;
            v254 = "nw_channel_add_input_frames";
            v255 = 1024;
            LODWORD(v256[0]) = v224;
            v225 = (char *)_os_log_send_and_compose_impl();
            v257[0] = OS_LOG_TYPE_ERROR;
            type[0] = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v225, v257, type))
              goto LABEL_397;
            if (v257[0] != OS_LOG_TYPE_FAULT)
            {
              if (type[0])
              {
                v229 = (char *)__nw_create_backtrace_string();
                v226 = __nwlog_obj();
                v227 = v257[0];
                v230 = os_log_type_enabled(v226, v257[0]);
                if (v229)
                {
                  if (v230)
                  {
                    *(_DWORD *)buf = 136446722;
                    v254 = "nw_channel_add_input_frames";
                    v255 = 1024;
                    LODWORD(v256[0]) = v224;
                    WORD2(v256[0]) = 2082;
                    *(_QWORD *)((char *)v256 + 6) = v229;
                    _os_log_impl(&dword_182FBE000, v226, v227, "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                  }
                  free(v229);
                  goto LABEL_397;
                }
                if (!v230)
                  goto LABEL_397;
                *(_DWORD *)buf = 136446466;
                v254 = "nw_channel_add_input_frames";
                v255 = 1024;
                LODWORD(v256[0]) = v224;
                v228 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, no backtrace";
              }
              else
              {
                v226 = __nwlog_obj();
                v227 = v257[0];
                if (!os_log_type_enabled(v226, v257[0]))
                  goto LABEL_397;
                *(_DWORD *)buf = 136446466;
                v254 = "nw_channel_add_input_frames";
                v255 = 1024;
                LODWORD(v256[0]) = v224;
                v228 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, backtrace limit exceeded";
              }
LABEL_396:
              _os_log_impl(&dword_182FBE000, v226, v227, v228, buf, 0x12u);
              goto LABEL_397;
            }
            v226 = __nwlog_obj();
            v227 = v257[0];
            if (os_log_type_enabled(v226, v257[0]))
            {
              *(_DWORD *)buf = 136446466;
              v254 = "nw_channel_add_input_frames";
              v255 = 1024;
              LODWORD(v256[0]) = v224;
              v228 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d";
              goto LABEL_396;
            }
LABEL_397:
            if (v225)
              free(v225);
            v221 = v245;
          }
        }
        if (*(_QWORD *)(v221 + 136))
        {
          if (_nw_signposts_once != -1)
            dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
          if (_nw_signposts_enabled && kdebug_is_enabled())
            kdebug_trace();
          v221 = v245;
          v223 = 1;
          if (os_channel_sync())
          {
            nw_channel_check_defunct(v245);
            goto LABEL_378;
          }
        }
        else
        {
LABEL_378:
          v223 = v166;
        }
        *(_QWORD *)(v221 + 400) = 0;
        v166 = v223;
      }
    }
  }
  return v166 & 1;
}

void nw_channel_reclassify_input(nw_frame *a1, unsigned __int8 *uu, char *a3)
{
  uint64_t v6;
  uint64_t node;
  char v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  __int128 v12;
  unsigned int data_offset;
  uint64_t v14;
  int data_length;
  _OWORD *v16;
  __int128 v17;
  char v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, char *);
  void *v23;
  uint64_t v24;
  NSObject *v25;
  _QWORD *v26;
  void *v27;
  _BOOL8 source;
  NSObject *v29;
  uint64_t v30;
  dispatch_time_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, char *);
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void (**v44)(_QWORD);
  const void *v45;
  char *v46;
  const char *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  void (**v53)(_QWORD);
  const void *v54;
  uint64_t v55;
  uint64_t v56;
  void (**v57)(_QWORD);
  const void *v58;
  char *v59;
  _BOOL4 v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  void (**v64)(_QWORD);
  const void *v65;
  char *backtrace_string;
  _BOOL4 v67;
  _BOOL4 v68;
  _BOOL4 v69;
  _QWORD v70[5];
  _QWORD v71[2];
  uint64_t (*v72)(uint64_t, uint64_t);
  void *v73;
  char *v74;
  char v75;
  os_log_type_t type[3];
  _BYTE buf[192];
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
    v47 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v47, type, &v75))
      goto LABEL_109;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v75)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v48 = __nwlog_obj();
        v49 = type[0];
        v67 = os_log_type_enabled(v48, type[0]);
        if (backtrace_string)
        {
          if (v67)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v67)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
          v50 = "%{public}s called with null frame, no backtrace";
          goto LABEL_108;
        }
      }
      else
      {
        v48 = __nwlog_obj();
        v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
          v50 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_108;
        }
      }
      goto LABEL_109;
    }
    v48 = __nwlog_obj();
    v49 = type[0];
    if (!os_log_type_enabled(v48, type[0]))
      goto LABEL_109;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
    v50 = "%{public}s called with null frame";
LABEL_108:
    _os_log_impl(&dword_182FBE000, v48, v49, v50, buf, 0xCu);
    goto LABEL_109;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
    v47 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v47, type, &v75))
      goto LABEL_109;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v75)
      {
        v59 = (char *)__nw_create_backtrace_string();
        v48 = __nwlog_obj();
        v49 = type[0];
        v68 = os_log_type_enabled(v48, type[0]);
        if (v59)
        {
          if (v68)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v59;
            v61 = "%{public}s called with null context, dumping backtrace:%{public}s";
            goto LABEL_93;
          }
LABEL_94:
          free(v59);
          if (!v47)
            return;
LABEL_110:
          v46 = (char *)v47;
LABEL_111:
          free(v46);
          return;
        }
        if (v68)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
          v50 = "%{public}s called with null context, no backtrace";
          goto LABEL_108;
        }
      }
      else
      {
        v48 = __nwlog_obj();
        v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
          v50 = "%{public}s called with null context, backtrace limit exceeded";
          goto LABEL_108;
        }
      }
      goto LABEL_109;
    }
    v48 = __nwlog_obj();
    v49 = type[0];
    if (!os_log_type_enabled(v48, type[0]))
      goto LABEL_109;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
    v50 = "%{public}s called with null context";
    goto LABEL_108;
  }
  if (uuid_is_null(uu))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
    v47 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (__nwlog_fault(v47, type, &v75))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v48 = __nwlog_obj();
        v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
          v50 = "%{public}s called with null (!uuid_is_null(newflow))";
          goto LABEL_108;
        }
      }
      else if (v75)
      {
        v59 = (char *)__nw_create_backtrace_string();
        v48 = __nwlog_obj();
        v49 = type[0];
        v69 = os_log_type_enabled(v48, type[0]);
        if (v59)
        {
          if (v69)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v59;
            v61 = "%{public}s called with null (!uuid_is_null(newflow)), dumping backtrace:%{public}s";
            goto LABEL_93;
          }
          goto LABEL_94;
        }
        if (v69)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
          v50 = "%{public}s called with null (!uuid_is_null(newflow)), no backtrace";
          goto LABEL_108;
        }
      }
      else
      {
        v48 = __nwlog_obj();
        v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
          v50 = "%{public}s called with null (!uuid_is_null(newflow)), backtrace limit exceeded";
          goto LABEL_108;
        }
      }
    }
LABEL_109:
    if (!v47)
      return;
    goto LABEL_110;
  }
  v6 = *((_QWORD *)a3 + 35);
  if (v6 && (node = nw_hash_table_get_node(v6, (uint64_t)uu, 16)) != 0)
  {
    v8 = 0;
    v9 = *(_QWORD *)(node + 16);
    v10 = node + 32;
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v8 = 1;
  }
  if ((*((_WORD *)a1 + 102) & 4) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s reclassify failed to reset frame", buf, 0xCu);
    }
    nw_frame_finalize((uint64_t)a1);
    return;
  }
  v12 = *((_OWORD *)a1 + 14);
  *(_OWORD *)buf = *((_OWORD *)a1 + 13);
  *(_OWORD *)&buf[16] = v12;
  data_offset = os_buflet_get_data_offset();
  v14 = os_buflet_get_object_address() + data_offset;
  data_length = os_buflet_get_data_length();
  nw_frame_reset((uint64_t)a1, v14, data_length, (uint64_t)nw_channel_finalize_input_frame, (uint64_t)a3);
  if ((*((_WORD *)a1 + 102) & 4) != 0)
    v16 = (_OWORD *)((char *)a1 + 208);
  else
    v16 = 0;
  v17 = *(_OWORD *)&buf[16];
  *v16 = *(_OWORD *)buf;
  v16[1] = v17;
  if (v9)
    v18 = v8;
  else
    v18 = 1;
  if ((v18 & 1) != 0 || !v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
      *(_WORD *)&buf[12] = 1042;
      *(_DWORD *)&buf[14] = 16;
      *(_WORD *)&buf[18] = 2098;
      *(_QWORD *)&buf[20] = uu;
      _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s reclassify can't find client for slot %{public,uuid_t}.16P, pending", buf, 0x1Cu);
    }
    if (!uuid_is_null((const unsigned __int8 *)a3 + 352) && uuid_compare((const unsigned __int8 *)a3 + 352, uu))
    {
      v71[0] = MEMORY[0x1E0C809B0];
      v71[1] = 0x40000000;
      v72 = ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke;
      v73 = &__block_descriptor_tmp_45_87016;
      v74 = a3;
      v33 = *((_QWORD *)a3 + 42);
      do
      {
        if (!v33)
          break;
        v34 = *(_QWORD *)(v33 + 32);
        v35 = ((uint64_t (*)(_QWORD *))v72)(v71);
        v33 = v34;
      }
      while ((v35 & 1) != 0);
      v36 = *((_QWORD *)a3 + 24);
      if (v36)
      {
        nw_queue_cancel_source(v36, v33);
        *((_QWORD *)a3 + 24) = 0;
      }
    }
    *((_OWORD *)a3 + 22) = *(_OWORD *)uu;
    *((_QWORD *)a1 + 4) = 0;
    v26 = (_QWORD *)*((_QWORD *)a3 + 43);
    *((_QWORD *)a1 + 5) = v26;
    *v26 = a1;
    *((_QWORD *)a3 + 43) = (char *)a1 + 32;
    if (*((_QWORD *)a3 + 24))
      return;
    v27 = (void *)*((_QWORD *)a3 + 19);
    v70[0] = MEMORY[0x1E0C809B0];
    v70[1] = 0x40000000;
    v70[2] = ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke_2;
    v70[3] = &__block_descriptor_tmp_48_87017;
    v70[4] = a3;
    source = nw_queue_context_create_source(v27, 2, 3, 0, v70, 0);
    *((_QWORD *)a3 + 24) = source;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = gLogObj;
    if (source)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = 2000;
        _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s Setting timer to finalize pending reclassify frames in %llums", buf, 0x16u);
      }
      v30 = *((_QWORD *)a3 + 24);
      v31 = dispatch_time(0x8000000000000000, 2000000000);
      nw_queue_set_timer_values(v30, v31, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      nw_queue_activate_source(*((_QWORD *)a3 + 24), v32);
      return;
    }
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
    v47 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v47, type, &v75))
      goto LABEL_109;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = gLogObj;
      v49 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_109;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
      v50 = "%{public}s nw_queue_context_create_source(timer) failed";
      goto LABEL_108;
    }
    if (!v75)
    {
      v48 = __nwlog_obj();
      v49 = type[0];
      if (!os_log_type_enabled(v48, type[0]))
        goto LABEL_109;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
      v50 = "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded";
      goto LABEL_108;
    }
    v59 = (char *)__nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = type[0];
    v60 = os_log_type_enabled(v48, type[0]);
    if (!v59)
    {
      if (!v60)
        goto LABEL_109;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
      v50 = "%{public}s nw_queue_context_create_source(timer) failed, no backtrace";
      goto LABEL_108;
    }
    if (v60)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_channel_reclassify_input";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v59;
      v61 = "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s";
LABEL_93:
      _os_log_impl(&dword_182FBE000, v48, v49, v61, buf, 0x16u);
      goto LABEL_94;
    }
    goto LABEL_94;
  }
  *((_QWORD *)a1 + 4) = 0;
  v19 = *(_QWORD **)(v10 + 8);
  *((_QWORD *)a1 + 5) = v19;
  *v19 = a1;
  *(_QWORD *)(v10 + 8) = (char *)a1 + 32;
  v20 = *(_QWORD *)(v9 + 56);
  if (v20 && ((*(_BYTE *)(v20 + 153) & 8) != 0 || (*((_WORD *)a3 + 222) & 0x80) == 0))
  {
    v21 = *(_QWORD *)(v9 + 24);
    if (v21)
    {
      v22 = *(void (**)(uint64_t, char *))(v21 + 64);
      if (!v22)
        goto LABEL_152;
      v23 = *(void **)(v9 + 40);
      if (v23 == &nw_protocol_ref_counted_handle)
      {
        v24 = *(_QWORD *)(v9 + 88);
        if (v24)
          *(_QWORD *)(v9 + 88) = v24 + 1;
      }
      if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
      {
        v37 = *((_QWORD *)a3 + 14);
        if (v37)
          *((_QWORD *)a3 + 14) = v37 + 1;
        v22(v9, a3 + 24);
        if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
        {
          v51 = *((_QWORD *)a3 + 14);
          if (v51)
          {
            v52 = v51 - 1;
            *((_QWORD *)a3 + 14) = v52;
            if (!v52)
            {
              v53 = (void (**)(_QWORD))*((_QWORD *)a3 + 11);
              if (v53)
              {
                *((_QWORD *)a3 + 11) = 0;
                v53[2](v53);
                _Block_release(v53);
              }
              if ((a3[96] & 1) != 0)
              {
                v54 = (const void *)*((_QWORD *)a3 + 11);
                if (v54)
                  _Block_release(v54);
              }
              free(a3 + 24);
            }
          }
        }
      }
      else
      {
        v22(v9, a3 + 24);
      }
      if (v23 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v9 + 40) == &nw_protocol_ref_counted_handle)
      {
        v55 = *(_QWORD *)(v9 + 88);
        if (v55)
        {
          v56 = v55 - 1;
          *(_QWORD *)(v9 + 88) = v56;
          if (!v56)
          {
            v57 = *(void (***)(_QWORD))(v9 + 64);
            if (v57)
            {
              *(_QWORD *)(v9 + 64) = 0;
              v57[2](v57);
              _Block_release(v57);
            }
            if ((*(_BYTE *)(v9 + 72) & 1) != 0)
            {
              v58 = *(const void **)(v9 + 64);
              if (v58)
                _Block_release(v58);
            }
            free((void *)v9);
          }
        }
      }
      v21 = *(_QWORD *)(v9 + 24);
      if (v21)
      {
LABEL_152:
        v38 = *(void (**)(uint64_t, char *))(v21 + 264);
        if (v38)
        {
          v39 = *(void **)(v9 + 40);
          if (v39 == &nw_protocol_ref_counted_handle)
          {
            v40 = *(_QWORD *)(v9 + 88);
            if (v40)
              *(_QWORD *)(v9 + 88) = v40 + 1;
          }
          if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
          {
            v41 = *((_QWORD *)a3 + 14);
            if (v41)
              *((_QWORD *)a3 + 14) = v41 + 1;
            v38(v9, a3 + 24);
            if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
            {
              v62 = *((_QWORD *)a3 + 14);
              if (v62)
              {
                v63 = v62 - 1;
                *((_QWORD *)a3 + 14) = v63;
                if (!v63)
                {
                  v64 = (void (**)(_QWORD))*((_QWORD *)a3 + 11);
                  if (v64)
                  {
                    *((_QWORD *)a3 + 11) = 0;
                    v64[2](v64);
                    _Block_release(v64);
                  }
                  if ((a3[96] & 1) != 0)
                  {
                    v65 = (const void *)*((_QWORD *)a3 + 11);
                    if (v65)
                      _Block_release(v65);
                  }
                  free(a3 + 24);
                }
              }
            }
          }
          else
          {
            v38(v9, a3 + 24);
          }
          if (v39 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v9 + 40) == &nw_protocol_ref_counted_handle)
          {
            v42 = *(_QWORD *)(v9 + 88);
            if (v42)
            {
              v43 = v42 - 1;
              *(_QWORD *)(v9 + 88) = v43;
              if (!v43)
              {
                v44 = *(void (***)(_QWORD))(v9 + 64);
                if (v44)
                {
                  *(_QWORD *)(v9 + 64) = 0;
                  v44[2](v44);
                  _Block_release(v44);
                }
                if ((*(_BYTE *)(v9 + 72) & 1) != 0)
                {
                  v45 = *(const void **)(v9 + 64);
                  if (v45)
                    _Block_release(v45);
                }
                v46 = (char *)v9;
                goto LABEL_111;
              }
            }
          }
        }
      }
    }
  }
}

uint64_t nw_channel_set_flow_handler(nw_frame *a1, unsigned __int8 *a2)
{
  uint64_t result;

  result = nw_frame_get_metadata((uint64_t)a1);
  if (result)
    return os_packet_set_flow_uuid();
  return result;
}

double nw_channel_get_flow_handler(nw_frame *a1, unsigned __int8 *a2)
{
  double result;

  if (nw_frame_get_metadata((uint64_t)a1))
  {
    os_packet_get_flow_uuid();
    result = 0.0;
    *(_OWORD *)a2 = 0uLL;
  }
  return result;
}

BOOL nw_channel_replace_input_handler(nw_protocol *a1, nw_protocol *a2, nw_protocol *a3)
{
  _QWORD *handle;
  uint64_t node;
  uint64_t v8;
  _QWORD *v9;
  os_log_type_t *v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int flow_control_status;
  int v15;
  int v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *v21;
  _BOOL4 v22;
  const char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  char *v27;
  _BOOL8 v28;
  uint64_t v30;
  _QWORD *v31;
  char *backtrace_string;
  _BOOL4 v33;
  const char *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _BOOL8 v38;
  int v39;
  uint64_t extra;
  uint64_t v41;
  os_log_type_t *v42;
  char v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  const char *v47;
  nw_protocol_callbacks *callbacks;
  int v49;
  char v50;
  void *v51;
  char v52;
  uint64_t *v53;
  void *v54;
  uint64_t *v55;
  nw_protocol *output_handler;
  nw_protocol_callbacks *v57;
  char *v58;
  _BOOL4 v59;
  uint64_t v60;
  uint64_t v61;
  void (**v62)(_QWORD);
  const void *v63;
  nw_protocol_callbacks *v64;
  nw_protocol_callbacks *v65;
  void (**v66)(_QWORD);
  const void *v67;
  _BOOL4 v68;
  _BOOL4 v69;
  _BOOL4 v70;
  _BOOL4 v71;
  void *v72;
  int v73;
  char v74;
  os_log_type_t v75;
  os_log_type_t type[8];
  os_log_type_t *v77;
  os_log_type_t v78;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE v82[14];
  __int16 v83;
  _BYTE v84[14];
  __int16 v85;
  char *v86;
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_channel_replace_input_handler";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v78 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v23, type, &v78))
      goto LABEL_110;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null channel_protocol";
      goto LABEL_109;
    }
    if (v78 == OS_LOG_TYPE_DEFAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
      goto LABEL_109;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type[0];
    v68 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v68)
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null channel_protocol, no backtrace";
      goto LABEL_109;
    }
    if (!v68)
      goto LABEL_49;
    *(_DWORD *)buf = 136446466;
    v80 = "nw_channel_replace_input_handler";
    v81 = 2082;
    *(_QWORD *)v82 = backtrace_string;
    v34 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
    goto LABEL_48;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_channel_replace_input_handler";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v78 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v23, type, &v78))
      goto LABEL_110;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null channel";
      goto LABEL_109;
    }
    if (v78 == OS_LOG_TYPE_DEFAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_109;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type[0];
    v69 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v69)
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null channel, no backtrace";
      goto LABEL_109;
    }
    if (!v69)
      goto LABEL_49;
    *(_DWORD *)buf = 136446466;
    v80 = "nw_channel_replace_input_handler";
    v81 = 2082;
    *(_QWORD *)v82 = backtrace_string;
    v34 = "%{public}s called with null channel, dumping backtrace:%{public}s";
    goto LABEL_48;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_channel_replace_input_handler";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v78 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v23, type, &v78))
      goto LABEL_110;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null old_input_handler";
      goto LABEL_109;
    }
    if (v78 == OS_LOG_TYPE_DEFAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null old_input_handler, backtrace limit exceeded";
      goto LABEL_109;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type[0];
    v70 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v70)
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null old_input_handler, no backtrace";
      goto LABEL_109;
    }
    if (!v70)
      goto LABEL_49;
    *(_DWORD *)buf = 136446466;
    v80 = "nw_channel_replace_input_handler";
    v81 = 2082;
    *(_QWORD *)v82 = backtrace_string;
    v34 = "%{public}s called with null old_input_handler, dumping backtrace:%{public}s";
    goto LABEL_48;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_channel_replace_input_handler";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v78 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v23, type, &v78))
      goto LABEL_110;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null new_input_handler";
      goto LABEL_109;
    }
    if (v78 == OS_LOG_TYPE_DEFAULT)
    {
      v24 = __nwlog_obj();
      v25 = type[0];
      if (!os_log_type_enabled(v24, type[0]))
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null new_input_handler, backtrace limit exceeded";
      goto LABEL_109;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type[0];
    v71 = os_log_type_enabled(v24, type[0]);
    if (!backtrace_string)
    {
      if (!v71)
        goto LABEL_110;
      *(_DWORD *)buf = 136446210;
      v80 = "nw_channel_replace_input_handler";
      v26 = "%{public}s called with null new_input_handler, no backtrace";
      goto LABEL_109;
    }
    if (!v71)
      goto LABEL_49;
    *(_DWORD *)buf = 136446466;
    v80 = "nw_channel_replace_input_handler";
    v81 = 2082;
    *(_QWORD *)v82 = backtrace_string;
    v34 = "%{public}s called with null new_input_handler, dumping backtrace:%{public}s";
    goto LABEL_48;
  }
  if (*(_QWORD *)a2->flow_id != *(_QWORD *)a3->flow_id || *(_QWORD *)&a2->flow_id[8] != *(_QWORD *)&a3->flow_id[8])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136447234;
    v80 = "nw_channel_replace_input_handler";
    v81 = 1042;
    *(_DWORD *)v82 = 16;
    *(_WORD *)&v82[4] = 2098;
    *(_QWORD *)&v82[6] = a2;
    v83 = 1042;
    *(_DWORD *)v84 = 16;
    *(_WORD *)&v84[4] = 2098;
    *(_QWORD *)&v84[6] = a3;
    v17 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v78 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v17, type, &v78))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136447234;
          v80 = "nw_channel_replace_input_handler";
          v81 = 1042;
          *(_DWORD *)v82 = 16;
          *(_WORD *)&v82[4] = 2098;
          *(_QWORD *)&v82[6] = a2;
          v83 = 1042;
          *(_DWORD *)v84 = 16;
          *(_WORD *)&v84[4] = 2098;
          *(_QWORD *)&v84[6] = a3;
          v20 = "%{public}s New input handler does not have matching flow ID (%{public,uuid_t}.16Ps != %{public,uuid_t}.16P)";
LABEL_35:
          _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0x2Cu);
        }
      }
      else if (v78)
      {
        v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type[0];
        v22 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v21)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136447490;
            v80 = "nw_channel_replace_input_handler";
            v81 = 1042;
            *(_DWORD *)v82 = 16;
            *(_WORD *)&v82[4] = 2098;
            *(_QWORD *)&v82[6] = a2;
            v83 = 1042;
            *(_DWORD *)v84 = 16;
            *(_WORD *)&v84[4] = 2098;
            *(_QWORD *)&v84[6] = a3;
            v85 = 2082;
            v86 = v21;
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s New input handler does not have matching flow ID (%{public,uuid_t}.16Ps != %{public,uuid_t}.16P), dumping backtrace:%{public}s", buf, 0x36u);
          }
          free(v21);
          goto LABEL_36;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136447234;
          v80 = "nw_channel_replace_input_handler";
          v81 = 1042;
          *(_DWORD *)v82 = 16;
          *(_WORD *)&v82[4] = 2098;
          *(_QWORD *)&v82[6] = a2;
          v83 = 1042;
          *(_DWORD *)v84 = 16;
          *(_WORD *)&v84[4] = 2098;
          *(_QWORD *)&v84[6] = a3;
          v20 = "%{public}s New input handler does not have matching flow ID (%{public,uuid_t}.16Ps != %{public,uuid_t}.1"
                "6P), no backtrace";
          goto LABEL_35;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136447234;
          v80 = "nw_channel_replace_input_handler";
          v81 = 1042;
          *(_DWORD *)v82 = 16;
          *(_WORD *)&v82[4] = 2098;
          *(_QWORD *)&v82[6] = a2;
          v83 = 1042;
          *(_DWORD *)v84 = 16;
          *(_WORD *)&v84[4] = 2098;
          *(_QWORD *)&v84[6] = a3;
          v20 = "%{public}s New input handler does not have matching flow ID (%{public,uuid_t}.16Ps != %{public,uuid_t}.1"
                "6P), backtrace limit exceeded";
          goto LABEL_35;
        }
      }
    }
LABEL_36:
    if (!v17)
      return 0;
    v27 = (char *)v17;
LABEL_38:
    free(v27);
    return 0;
  }
  *(_QWORD *)type = 0;
  v77 = type;
  node = nw_hash_table_get_node(handle[35], (uint64_t)a2, 16);
  if (!node)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_channel_replace_input_handler";
    v23 = (const char *)_os_log_send_and_compose_impl();
    v78 = OS_LOG_TYPE_ERROR;
    v75 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v23, &v78, &v75))
      goto LABEL_110;
    if (v78 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = gLogObj;
      v25 = v78;
      if (os_log_type_enabled((os_log_t)gLogObj, v78))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_channel_replace_input_handler";
        v26 = "%{public}s nw_hash_table_get_node failed";
LABEL_109:
        _os_log_impl(&dword_182FBE000, v24, v25, v26, buf, 0xCu);
        goto LABEL_110;
      }
      goto LABEL_110;
    }
    if (v75 == OS_LOG_TYPE_DEFAULT)
    {
      v24 = __nwlog_obj();
      v25 = v78;
      if (os_log_type_enabled(v24, v78))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_channel_replace_input_handler";
        v26 = "%{public}s nw_hash_table_get_node failed, backtrace limit exceeded";
        goto LABEL_109;
      }
LABEL_110:
      if (!v23)
        return 0;
      v27 = (char *)v23;
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = gLogObj;
    v25 = v78;
    v33 = os_log_type_enabled((os_log_t)gLogObj, v78);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_channel_replace_input_handler";
        v26 = "%{public}s nw_hash_table_get_node failed, no backtrace";
        goto LABEL_109;
      }
      goto LABEL_110;
    }
    if (!v33)
    {
LABEL_49:
      free(backtrace_string);
      goto LABEL_110;
    }
    *(_DWORD *)buf = 136446466;
    v80 = "nw_channel_replace_input_handler";
    v81 = 2082;
    *(_QWORD *)v82 = backtrace_string;
    v34 = "%{public}s nw_hash_table_get_node failed, dumping backtrace:%{public}s";
LABEL_48:
    _os_log_impl(&dword_182FBE000, v24, v25, v34, buf, 0x16u);
    goto LABEL_49;
  }
  v8 = node;
  if ((nw_protocol *)handle[34] == a2)
    handle[34] = a3;
  v9 = (_QWORD *)(node + 32);
  if (*(_QWORD *)type)
  {
    **(_QWORD **)(node + 40) = *(_QWORD *)type;
    v10 = v77;
    *(_QWORD *)(*(_QWORD *)type + 40) = *(_QWORD *)(node + 40);
    *(_QWORD *)(node + 40) = v10;
    *(_QWORD *)type = 0;
    v77 = type;
  }
  if (*v9)
  {
    *(_QWORD *)v77 = *v9;
    *(_QWORD *)(*(_QWORD *)(node + 32) + 40) = v77;
    v77 = *(os_log_type_t **)(node + 40);
    *(_QWORD *)(node + 32) = 0;
    *(_QWORD *)(node + 40) = v9;
  }
  v11 = *(_QWORD *)(node + 48);
  *(_QWORD *)(node + 48) = 0;
  v12 = *(unsigned __int8 *)(node + 153);
  v13 = (v12 >> 1) & 1;
  flow_control_status = nw_link_get_flow_control_status(*(void **)(node + 104));
  v15 = flow_control_status;
  v16 = *(_DWORD *)(v8 + 112);
  if ((v12 & 1) == 0)
  {
    if (!v13)
      goto LABEL_16;
LABEL_51:
    v35 = *(_QWORD *)(v8 + 88);
    v36 = *(_QWORD **)(v8 + 96);
    if (v35)
    {
      *(_QWORD *)(v35 + 64) = v36;
      v36 = *(_QWORD **)(v8 + 96);
    }
    else
    {
      handle[49] = v36;
    }
    *v36 = v35;
    if ((*(_BYTE *)(v8 + 64) & 1) == 0)
      goto LABEL_57;
    goto LABEL_55;
  }
  v30 = *(_QWORD *)(v8 + 72);
  v31 = *(_QWORD **)(v8 + 80);
  if (v30)
  {
    *(_QWORD *)(v30 + 48) = v31;
    **(_QWORD **)(v8 + 80) = v30;
    if (v13)
      goto LABEL_51;
  }
  else
  {
    handle[47] = v31;
    *v31 = 0;
    if (v13)
      goto LABEL_51;
  }
LABEL_16:
  if ((*(_BYTE *)(v8 + 64) & 1) == 0)
    goto LABEL_57;
LABEL_55:
  v37 = *(_QWORD *)(v8 + 56);
  if (v37)
  {
    if (*(_UNKNOWN **)(v37 + 40) == &nw_protocol_ref_counted_handle)
    {
      v60 = *(_QWORD *)(v37 + 88);
      if (v60)
      {
        v61 = v60 - 1;
        *(_QWORD *)(v37 + 88) = v61;
        if (!v61)
        {
          v73 = flow_control_status;
          v62 = *(void (***)(_QWORD))(v37 + 64);
          if (v62)
          {
            *(_QWORD *)(v37 + 64) = 0;
            v62[2](v62);
            _Block_release(v62);
          }
          if ((*(_BYTE *)(v37 + 72) & 1) != 0)
          {
            v63 = *(const void **)(v37 + 64);
            if (v63)
              _Block_release(v63);
          }
          free((void *)v37);
          v15 = v73;
        }
      }
    }
  }
LABEL_57:
  *(_BYTE *)(v8 + 64) |= 1u;
  *(_QWORD *)(v8 + 56) = 0;
  nw_hash_table_remove_node(handle[35], v8);
  v78 = OS_LOG_TYPE_DEFAULT;
  v38 = nw_hash_table_add_object(handle[35], (uint64_t)a3, (char *)&v78);
  v28 = v78 != OS_LOG_TYPE_DEFAULT;
  if (v78)
  {
    v39 = v15;
    v72 = (void *)v38;
    extra = nw_hash_node_get_extra(v38);
    v41 = extra;
    *(_OWORD *)extra = 0u;
    *(_OWORD *)(extra + 16) = 0u;
    *(_OWORD *)(extra + 32) = 0u;
    *(_OWORD *)(extra + 48) = 0u;
    *(_OWORD *)(extra + 64) = 0u;
    *(_OWORD *)(extra + 80) = 0u;
    *(_OWORD *)(extra + 96) = 0u;
    *(_OWORD *)(extra + 112) = 0u;
    *(_QWORD *)(extra + 8) = extra;
    if (*(_QWORD *)type)
    {
      *(_QWORD *)extra = *(_QWORD *)type;
      v42 = v77;
      *(_QWORD *)(*(_QWORD *)type + 40) = extra;
      *(_QWORD *)(extra + 8) = v42;
      *(_QWORD *)type = 0;
      v77 = type;
    }
    *(_QWORD *)(extra + 16) = v11;
    if (a3->handle == &nw_protocol_ref_counted_handle)
    {
      callbacks = a3[1].callbacks;
      if (callbacks)
        a3[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    v49 = v12 & 1;
    v50 = *(_BYTE *)(extra + 32);
    if ((v50 & 1) != 0)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)(extra + 24));
      v50 = *(_BYTE *)(v41 + 32);
    }
    *(_QWORD *)(v41 + 24) = a3;
    *(_BYTE *)(v41 + 32) = v50 & 0xFE | v43;
    v51 = *(void **)(v41 + 72);
    if (v51)
    {
      os_release(v51);
      *(_QWORD *)(v41 + 72) = 0;
    }
    *(_QWORD *)(v41 + 72) = nw_link_info_create(v39);
    uuid_unparse(a3->flow_id, (char *)(v41 + 84));
    *(_DWORD *)(v41 + 80) = v16;
    v52 = *(_BYTE *)(v41 + 121) & 0xFE | v49;
    *(_BYTE *)(v41 + 121) = v52;
    if (v49)
    {
      *(_QWORD *)(v41 + 40) = 0;
      v53 = (uint64_t *)handle[47];
      *(_QWORD *)(v41 + 48) = v53;
      *v53 = v41;
      handle[47] = v41 + 40;
      v52 = *(_BYTE *)(v41 + 121);
    }
    *(_BYTE *)(v41 + 121) = v52 & 0xFD | (2 * v13);
    v54 = v72;
    if (v13)
    {
      *(_QWORD *)(v41 + 56) = 0;
      v55 = (uint64_t *)handle[49];
      *(_QWORD *)(v41 + 64) = v55;
      *v55 = v41;
      handle[49] = v41 + 56;
    }
    output_handler = a3->output_handler;
    if (output_handler != a1)
    {
      if (output_handler)
      {
        if (output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v64 = output_handler[1].callbacks;
          if (v64)
          {
            v65 = (nw_protocol_callbacks *)((char *)v64 - 1);
            output_handler[1].callbacks = v65;
            if (!v65)
            {
              v66 = *(void (***)(_QWORD))output_handler[1].flow_id;
              if (v66)
              {
                *(_QWORD *)output_handler[1].flow_id = 0;
                v66[2](v66);
                _Block_release(v66);
              }
              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                v67 = *(const void **)output_handler[1].flow_id;
                if (v67)
                  _Block_release(v67);
              }
              free(output_handler);
              v54 = v72;
            }
          }
        }
      }
      a3->output_handler = a1;
      if (a1->handle == &nw_protocol_ref_counted_handle)
      {
        v57 = a1[1].callbacks;
        if (v57)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v57->add_input_handler + 1);
      }
    }
    a3->output_handler_context = v54;
    return v28;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446722;
  v80 = "nw_channel_replace_input_handler";
  v81 = 1042;
  *(_DWORD *)v82 = 16;
  *(_WORD *)&v82[4] = 2098;
  *(_QWORD *)&v82[6] = a3;
  v44 = (char *)_os_log_send_and_compose_impl();
  v75 = OS_LOG_TYPE_ERROR;
  v74 = 0;
  if (__nwlog_fault(v44, &v75, &v74))
  {
    if (v75 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v45 = gLogObj;
      v46 = v75;
      if (!os_log_type_enabled((os_log_t)gLogObj, v75))
        goto LABEL_117;
      *(_DWORD *)buf = 136446722;
      v80 = "nw_channel_replace_input_handler";
      v81 = 1042;
      *(_DWORD *)v82 = 16;
      *(_WORD *)&v82[4] = 2098;
      *(_QWORD *)&v82[6] = a3;
      v47 = "%{public}s Channel failed to add new input handler for %{public,uuid_t}.16P";
      goto LABEL_116;
    }
    if (!v74)
    {
      v45 = __nwlog_obj();
      v46 = v75;
      if (!os_log_type_enabled(v45, v75))
        goto LABEL_117;
      *(_DWORD *)buf = 136446722;
      v80 = "nw_channel_replace_input_handler";
      v81 = 1042;
      *(_DWORD *)v82 = 16;
      *(_WORD *)&v82[4] = 2098;
      *(_QWORD *)&v82[6] = a3;
      v47 = "%{public}s Channel failed to add new input handler for %{public,uuid_t}.16P, backtrace limit exceeded";
      goto LABEL_116;
    }
    v58 = (char *)__nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = v75;
    v59 = os_log_type_enabled(v45, v75);
    if (v58)
    {
      if (v59)
      {
        *(_DWORD *)buf = 136446978;
        v80 = "nw_channel_replace_input_handler";
        v81 = 1042;
        *(_DWORD *)v82 = 16;
        *(_WORD *)&v82[4] = 2098;
        *(_QWORD *)&v82[6] = a3;
        v83 = 2082;
        *(_QWORD *)v84 = v58;
        _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s Channel failed to add new input handler for %{public,uuid_t}.16P, dumping backtrace:%{public}s", buf, 0x26u);
      }
      free(v58);
      goto LABEL_117;
    }
    if (v59)
    {
      *(_DWORD *)buf = 136446722;
      v80 = "nw_channel_replace_input_handler";
      v81 = 1042;
      *(_DWORD *)v82 = 16;
      *(_WORD *)&v82[4] = 2098;
      *(_QWORD *)&v82[6] = a3;
      v47 = "%{public}s Channel failed to add new input handler for %{public,uuid_t}.16P, no backtrace";
LABEL_116:
      _os_log_impl(&dword_182FBE000, v45, v46, v47, buf, 0x1Cu);
    }
  }
LABEL_117:
  if (v44)
    free(v44);
  return v28;
}

uint64_t nw_channel_updated_path(nw_protocol *a1, nw_protocol *a2, nw_path *a3)
{
  return 1;
}

void ___ZL31nw_channel_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    v5 = 136446210;
    v6 = "nw_channel_remove_input_handler_block_invoke";
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s Tearing down defunct channel", (uint8_t *)&v5, 0xCu);
  }
  nw_channel_close(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v3);
  v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v4)
  {
    os_release(v4);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void ___ZL31nw_channel_remove_input_handlerP11nw_protocolS0_b_block_invoke_52(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v4 = *(_QWORD *)(v3 + 200);
  if (v4)
  {
    if ((*(_WORD *)(v3 + 444) & 0x20) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        v7 = 136446210;
        v8 = "nw_channel_remove_input_handler_block_invoke";
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Tearing down channel after inactivity", (uint8_t *)&v7, 0xCu);
      }
      nw_channel_close(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v6);
    }
    else
    {
      nw_queue_cancel_source(v4, a2);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 200) = 0;
    }
  }
}

void ___ZL31nw_channel_remove_input_handlerP11nw_protocolS0_b_block_invoke_54(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

uint64_t ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;

  nw_frame_finalize(a2);
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 344) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  return 1;
}

void ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke_2(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  _QWORD v8[2];
  uint64_t (*v9)(uint64_t, uint64_t);
  void *v10;
  uint64_t v11;
  uint8_t buf[4];
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446210;
    v13 = "nw_channel_reclassify_input_block_invoke_2";
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s reclassify is finalizing pending frames that have timed out", buf, 0xCu);
  }
  v3 = *(_QWORD *)(a1 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v9 = ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke_46;
  v10 = &__block_descriptor_tmp_47_87025;
  v11 = v3;
  v4 = *(_QWORD *)(v3 + 336);
  do
  {
    if (!v4)
      break;
    v5 = *(_QWORD *)(v4 + 32);
    v6 = ((uint64_t (*)(_QWORD *))v9)(v8);
    v4 = v5;
  }
  while ((v6 & 1) != 0);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 192);
  if (v7)
  {
    nw_queue_cancel_source(v7, v4);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 192) = 0;
  }
}

uint64_t ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke_46(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;

  nw_frame_finalize(a2);
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 344) = v5;
  }
  *v5 = v4;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  return 1;
}

BOOL nw_channel_create_with_nexus(unsigned __int8 *a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  _QWORD v7[2];

  v7[0] = a3;
  v7[1] = a4;
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  return nw_channel_create_with_attributes((id)nw_context_copy_implicit_context::implicit_context, a1, a2, (uint64_t)v7);
}

void nw_channel_simulate_defunct_all(void *a1, uint64_t a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  _QWORD v8[6];
  char v9;
  os_log_type_t v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __nw_channel_simulate_defunct_all_block_invoke;
    v8[3] = &unk_1E14ACB00;
    v8[4] = a2;
    v8[5] = a1;
    nw_queue_context_async(a1, v8);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_channel_simulate_defunct_all";
  v2 = (char *)_os_log_send_and_compose_impl();
  v10 = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v2, &v10, &v9))
  {
    if (v10 == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = v10;
      if (!os_log_type_enabled(v3, v10))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_channel_simulate_defunct_all";
      v5 = "%{public}s called with null context";
      goto LABEL_17;
    }
    if (!v9)
    {
      v3 = __nwlog_obj();
      v4 = v10;
      if (!os_log_type_enabled(v3, v10))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_channel_simulate_defunct_all";
      v5 = "%{public}s called with null context, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v3 = __nwlog_obj();
    v4 = v10;
    v7 = os_log_type_enabled(v3, v10);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        v12 = "nw_channel_simulate_defunct_all";
        v13 = 2082;
        v14 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      v12 = "nw_channel_simulate_defunct_all";
      v5 = "%{public}s called with null context, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_18:
  if (v2)
    free(v2);
}

void __nw_channel_simulate_defunct_all_block_invoke(uint64_t a1)
{
  _BOOL8 globals_for_channel;
  os_unfair_lock_s *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  void *v10;
  uint64_t v11;
  _QWORD v12[6];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  globals_for_channel = nw_context_get_globals_for_channel(*(void **)(a1 + 40));
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  v3 = (os_unfair_lock_s *)(globals_for_channel + 16);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = __nw_channel_simulate_defunct_all_block_invoke_2;
  v12[3] = &unk_1E14ACA98;
  v12[4] = &v13;
  v12[5] = globals_for_channel;
  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_channel + 16));
  __nw_channel_simulate_defunct_all_block_invoke_2((uint64_t)v12);
  os_unfair_lock_unlock(v3);
  v9 = (unsigned __int8 *)v14[3];
  if (v9)
  {
    nw_array_apply(v9, (uint64_t)&__block_literal_global_19_87058);
    v10 = (void *)v14[3];
    if (v10)
    {
      os_release(v10);
      v14[3] = 0;
    }
  }
  v11 = *(_QWORD *)(a1 + 32);
  if (v11)
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11 + 16))(v11, v4, v5, v6, v7, v8);
  _Block_object_dispose(&v13, 8);
}

uint64_t __nw_channel_simulate_defunct_all_block_invoke_2(uint64_t a1)
{
  uint64_t result;
  _QWORD v3[5];

  result = **(_QWORD **)(a1 + 40);
  if (result)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = __nw_channel_simulate_defunct_all_block_invoke_3;
    v3[3] = &unk_1E14ACA70;
    v3[4] = *(_QWORD *)(a1 + 32);
    return nw_dictionary_apply(result, (uint64_t)v3);
  }
  return result;
}

uint64_t __nw_channel_simulate_defunct_all_block_invoke_17(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (((*(unsigned __int16 *)(a3 + 444) | (*(unsigned __int8 *)(a3 + 446) << 16)) & 0x80000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136446466;
      v7 = "nw_channel_simulate_defunct_all_block_invoke";
      v8 = 2048;
      v9 = a3;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s Simulating channel defunct for %p", (uint8_t *)&v6, 0x16u);
    }
    nw_channel_handle_defunct(a3);
  }
  return 1;
}

uint64_t __nw_channel_simulate_defunct_all_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v5;
  uint64_t v6;
  unsigned int v7;
  int v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a3 + 136))
  {
    *(_BYTE *)(a3 + 446) = (*(unsigned __int16 *)(a3 + 444) | (*(unsigned __int8 *)(a3 + 446) << 16) | 0x40000u) >> 16;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      v9 = 136446210;
      v10 = "nw_channel_simulate_defunct_all_block_invoke_3";
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Purging channel packet pool before defunct", (uint8_t *)&v9, 0xCu);
    }
    os_channel_packet_pool_purge();
    v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (!v6)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = nw_array_create();
      v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    }
    nw_array_append(v6, (void *)a3);
  }
  v7 = (*(unsigned __int16 *)(a3 + 444) | (*(unsigned __int8 *)(a3 + 446) << 16)) & 0xFFFDFFFF;
  *(_WORD *)(a3 + 444) = *(_WORD *)(a3 + 444);
  *(_BYTE *)(a3 + 446) = BYTE2(v7);
  return 1;
}

uint64_t nw_channel_get_nexus_instance(uint64_t a1, _OWORD *a2, _DWORD *a3)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  const char *v10;
  _BOOL4 v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_channel_get_nexus_instance";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
      goto LABEL_44;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_44;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_channel_get_nexus_instance";
      v7 = "%{public}s called with null channel";
LABEL_43:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      goto LABEL_44;
    }
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_channel_get_nexus_instance";
        v7 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_channel_get_nexus_instance";
        v7 = "%{public}s called with null channel, no backtrace";
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    if (!v9)
      goto LABEL_30;
    *(_DWORD *)buf = 136446466;
    v16 = "nw_channel_get_nexus_instance";
    v17 = 2082;
    v18 = backtrace_string;
    v10 = "%{public}s called with null channel, dumping backtrace:%{public}s";
LABEL_29:
    _os_log_impl(&dword_182FBE000, v5, v6, v10, buf, 0x16u);
    goto LABEL_30;
  }
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_channel_get_nexus_instance";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
      goto LABEL_44;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_44;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_channel_get_nexus_instance";
      v7 = "%{public}s called with null nexus_instance";
      goto LABEL_43;
    }
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_channel_get_nexus_instance";
        v7 = "%{public}s called with null nexus_instance, backtrace limit exceeded";
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_channel_get_nexus_instance";
        v7 = "%{public}s called with null nexus_instance, no backtrace";
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    if (!v11)
      goto LABEL_30;
    *(_DWORD *)buf = 136446466;
    v16 = "nw_channel_get_nexus_instance";
    v17 = 2082;
    v18 = backtrace_string;
    v10 = "%{public}s called with null nexus_instance, dumping backtrace:%{public}s";
    goto LABEL_29;
  }
  if (a3)
  {
    *a2 = *(_OWORD *)(a1 + 88);
    *a3 = *(_DWORD *)(a1 + 428);
    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_channel_get_nexus_instance";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v4, &type, &v13))
    goto LABEL_44;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_channel_get_nexus_instance";
        v7 = "%{public}s called with null port, backtrace limit exceeded";
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    v12 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_channel_get_nexus_instance";
        v7 = "%{public}s called with null port, no backtrace";
        goto LABEL_43;
      }
      goto LABEL_44;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "nw_channel_get_nexus_instance";
      v17 = 2082;
      v18 = backtrace_string;
      v10 = "%{public}s called with null port, dumping backtrace:%{public}s";
      goto LABEL_29;
    }
LABEL_30:
    free(backtrace_string);
    goto LABEL_44;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  v6 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    v16 = "nw_channel_get_nexus_instance";
    v7 = "%{public}s called with null port";
    goto LABEL_43;
  }
LABEL_44:
  if (v4)
    free(v4);
  return 0;
}

uint64_t nw_channel_get_key(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_channel_get_key";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v5, &type, &v11))
      goto LABEL_20;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_channel_get_key";
      v8 = "%{public}s called with null channel";
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      v10 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_channel_get_key";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v10)
      {
LABEL_20:
        if (v5)
          free(v5);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v14 = "nw_channel_get_key";
      v8 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_channel_get_key";
      v8 = "%{public}s called with null channel, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_20;
  }
  result = *(_QWORD *)(a1 + 16);
  if (!result)
    return result;
  v4 = *(_DWORD *)(a1 + 424);
  if (!v4)
    return 0;
  if (a2)
    *a2 = v4;
  return result;
}

uint64_t nw_channel_has_partial_checksum_offload(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(unsigned __int16 *)(a1 + 444) >> 11) & 1;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_channel_has_partial_checksum_offload";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_channel_has_partial_checksum_offload";
        v5 = "%{public}s called with null channel";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_channel_has_partial_checksum_offload";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_channel_has_partial_checksum_offload";
        v5 = "%{public}s called with null channel, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_channel_has_partial_checksum_offload";
        v5 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

id nw_masque_server_create(void *a1, void *a2, void *a3)
{
  id v5;
  NWConcrete_nw_masque_server *v6;
  id v7;
  id v8;
  id v9;
  _QWORD *v10;
  id v11;
  unint64_t v12;
  _BOOL8 v13;
  void *v14;
  NSObject *v15;
  dispatch_queue_t v16;
  void *v17;
  id v18;
  _BOOL8 v19;
  void *v20;
  id v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  id v30;
  os_log_type_t v31;
  const char *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  os_log_type_t v36;
  os_log_type_t v37;
  os_log_type_t v38;
  NSObject *v39;
  NSObject *v40;
  id v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  char *backtrace_string;
  NSObject *v46;
  os_log_type_t v47;
  _BOOL4 v48;
  os_log_type_t v49;
  void *v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  void *v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  _BOOL4 v62;
  char *v63;
  NSObject *v64;
  os_log_type_t v65;
  _BOOL4 v66;
  os_log_type_t v67;
  os_log_type_t v68;
  id v69;
  id v70;
  char v71;
  os_log_type_t type;
  objc_super v73;
  uint8_t buf[4];
  const char *v75;
  __int16 v76;
  char *v77;
  char label[40];
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v69 = a1;
  v70 = a2;
  v5 = a3;
  nw_allow_use_of_dispatch_internal();
  if (v5)
  {
    v6 = [NWConcrete_nw_masque_server alloc];
    v7 = v69;
    v8 = v70;
    v9 = v5;
    if (!v6)
    {
LABEL_109:
      v21 = 0;
LABEL_47:

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = (id)gLogObj;
      v40 = v39;
      if (v21)
      {
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)label = 136446466;
          *(_QWORD *)&label[4] = "nw_masque_server_create";
          *(_WORD *)&label[12] = 2114;
          *(_QWORD *)&label[14] = v21;
          _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ created", (uint8_t *)label, 0x16u);
        }

        v41 = v21;
        goto LABEL_70;
      }
      *(_DWORD *)label = 136446210;
      *(_QWORD *)&label[4] = "nw_masque_server_create";
      v42 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      LOBYTE(v73.receiver) = 0;
      if (__nwlog_fault(v42, buf, &v73))
      {
        if (buf[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v43 = (id)gLogObj;
          v44 = buf[0];
          if (os_log_type_enabled(v43, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)label = 136446210;
            *(_QWORD *)&label[4] = "nw_masque_server_create";
            _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s [nw_masque_server initWithParameters:clientQueue:] failed", (uint8_t *)label, 0xCu);
          }
LABEL_55:

          goto LABEL_68;
        }
        if (!LOBYTE(v73.receiver))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v43 = (id)gLogObj;
          v49 = buf[0];
          if (os_log_type_enabled(v43, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)label = 136446210;
            *(_QWORD *)&label[4] = "nw_masque_server_create";
            _os_log_impl(&dword_182FBE000, v43, v49, "%{public}s [nw_masque_server initWithParameters:clientQueue:] failed, backtrace limit exceeded", (uint8_t *)label, 0xCu);
          }
          goto LABEL_55;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v46 = (id)gLogObj;
        v47 = buf[0];
        v48 = os_log_type_enabled(v46, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v48)
          {
            *(_DWORD *)label = 136446466;
            *(_QWORD *)&label[4] = "nw_masque_server_create";
            *(_WORD *)&label[12] = 2082;
            *(_QWORD *)&label[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s [nw_masque_server initWithParameters:clientQueue:] failed, dumping backtrace:%{public}s", (uint8_t *)label, 0x16u);
          }

          free(backtrace_string);
          if (!v42)
            goto LABEL_70;
          goto LABEL_69;
        }
        if (v48)
        {
          *(_DWORD *)label = 136446210;
          *(_QWORD *)&label[4] = "nw_masque_server_create";
          _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s [nw_masque_server initWithParameters:clientQueue:] failed, no backtrace", (uint8_t *)label, 0xCu);
        }

      }
LABEL_68:
      if (!v42)
      {
LABEL_70:

        goto LABEL_71;
      }
LABEL_69:
      free(v42);
      goto LABEL_70;
    }
    v73.receiver = v6;
    v73.super_class = (Class)NWConcrete_nw_masque_server;
    v10 = objc_msgSendSuper2(&v73, sel_init);
    v11 = v10;
    if (v10)
    {
      do
        v12 = __ldaxr(&s_last_server_id);
      while (__stlxr(v12 + 1, &s_last_server_id));
      v10[1] = v12;
      v13 = nw_array_create();
      v14 = (void *)*((_QWORD *)v11 + 9);
      *((_QWORD *)v11 + 9) = v13;

      objc_storeStrong((id *)v11 + 5, a3);
      objc_storeStrong((id *)v11 + 15, a2);
      strcpy(label, "com.apple.networking.nw_masque_server");
      dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = dispatch_queue_create(label, v15);
      v17 = (void *)*((_QWORD *)v11 + 3);
      *((_QWORD *)v11 + 3) = v16;

      if (*((_QWORD *)v11 + 3))
      {
        if (!v7
          || (v18 = v7,
              v19 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v18, 0, 0), v18, v20 = (void *)*((_QWORD *)v11 + 4), *((_QWORD *)v11 + 4) = v19, v20, *((_QWORD *)v11 + 4)))
        {
          v21 = v11;
LABEL_46:

          goto LABEL_47;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v30 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
        v23 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v71 = 0;
        if (__nwlog_fault(v23, &type, &v71))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v31 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s nw_parameters_copy failed", buf, 0xCu);
            }
          }
          else if (v71)
          {
            v32 = __nw_create_backtrace_string();
            if (v32)
            {
              v33 = (char *)v32;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v34 = (id)gLogObj;
              v35 = type;
              if (os_log_type_enabled(v34, type))
              {
                *(_DWORD *)buf = 136446466;
                v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
                v76 = 2082;
                v77 = v33;
                _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v33);
              if (!v23)
                goto LABEL_45;
              goto LABEL_44;
            }
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            v38 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              _os_log_impl(&dword_182FBE000, v24, v38, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v37 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              _os_log_impl(&dword_182FBE000, v24, v37, "%{public}s nw_parameters_copy failed, backtrace limit exceeded", buf, 0xCu);
            }
          }
          goto LABEL_42;
        }
LABEL_43:
        if (!v23)
        {
LABEL_45:
          v21 = 0;
          goto LABEL_46;
        }
LABEL_44:
        free(v23);
        goto LABEL_45;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
      v23 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v71 = 0;
      if (!__nwlog_fault(v23, &type, &v71))
        goto LABEL_43;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
          _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s dispatch_queue_create failed", buf, 0xCu);
        }
      }
      else
      {
        if (v71)
        {
          v26 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = (id)gLogObj;
          v28 = type;
          v29 = os_log_type_enabled(v27, type);
          if (v26)
          {
            if (v29)
            {
              *(_DWORD *)buf = 136446466;
              v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              v76 = 2082;
              v77 = v26;
              _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s dispatch_queue_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v26);
            if (!v23)
              goto LABEL_45;
            goto LABEL_44;
          }
          if (v29)
          {
            *(_DWORD *)buf = 136446210;
            v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
            _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s dispatch_queue_create failed, no backtrace", buf, 0xCu);
          }

          goto LABEL_43;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v36 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
          _os_log_impl(&dword_182FBE000, v24, v36, "%{public}s dispatch_queue_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
LABEL_42:

      goto LABEL_43;
    }
    __nwlog_obj();
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)label = 136446210;
    *(_QWORD *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
    v56 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v56, buf, &type) & 1) != 0)
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v57 = objc_claimAutoreleasedReturnValue();
        v58 = buf[0];
        if (os_log_type_enabled(v57, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)label = 136446210;
          *(_QWORD *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
          _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s [super init] failed", (uint8_t *)label, 0xCu);
        }
      }
      else
      {
        if (type)
        {
          v63 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v64 = objc_claimAutoreleasedReturnValue();
          v65 = buf[0];
          v66 = os_log_type_enabled(v64, (os_log_type_t)buf[0]);
          if (v63)
          {
            if (v66)
            {
              *(_DWORD *)label = 136446466;
              *(_QWORD *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              *(_WORD *)&label[12] = 2082;
              *(_QWORD *)&label[14] = v63;
              _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s [super init] failed, dumping backtrace:%{public}s", (uint8_t *)label, 0x16u);
            }

            free(v63);
          }
          else
          {
            if (v66)
            {
              *(_DWORD *)label = 136446210;
              *(_QWORD *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
              _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s [super init] failed, no backtrace", (uint8_t *)label, 0xCu);
            }

          }
          goto LABEL_107;
        }
        __nwlog_obj();
        v57 = objc_claimAutoreleasedReturnValue();
        v68 = buf[0];
        if (os_log_type_enabled(v57, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)label = 136446210;
          *(_QWORD *)&label[4] = "-[NWConcrete_nw_masque_server initWithParameters:securityOptions:clientQueue:]";
          _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s [super init] failed, backtrace limit exceeded", (uint8_t *)label, 0xCu);
        }
      }

    }
LABEL_107:
    if (v56)
      free(v56);
    goto LABEL_109;
  }
  __nwlog_obj();
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)label = 136446210;
  *(_QWORD *)&label[4] = "nw_masque_server_create";
  v52 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  LOBYTE(v73.receiver) = 0;
  if (__nwlog_fault(v52, buf, &v73))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v54 = buf[0];
      if (os_log_type_enabled(v53, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)label = 136446210;
        *(_QWORD *)&label[4] = "nw_masque_server_create";
        _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null queue", (uint8_t *)label, 0xCu);
      }
    }
    else
    {
      if (LOBYTE(v73.receiver))
      {
        v59 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v61 = buf[0];
        v62 = os_log_type_enabled(v60, (os_log_type_t)buf[0]);
        if (v59)
        {
          if (v62)
          {
            *(_DWORD *)label = 136446466;
            *(_QWORD *)&label[4] = "nw_masque_server_create";
            *(_WORD *)&label[12] = 2082;
            *(_QWORD *)&label[14] = v59;
            _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s called with null queue, dumping backtrace:%{public}s", (uint8_t *)label, 0x16u);
          }

          free(v59);
        }
        else
        {
          if (v62)
          {
            *(_DWORD *)label = 136446210;
            *(_QWORD *)&label[4] = "nw_masque_server_create";
            _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s called with null queue, no backtrace", (uint8_t *)label, 0xCu);
          }

        }
        goto LABEL_101;
      }
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v67 = buf[0];
      if (os_log_type_enabled(v53, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)label = 136446210;
        *(_QWORD *)&label[4] = "nw_masque_server_create";
        _os_log_impl(&dword_182FBE000, v53, v67, "%{public}s called with null queue, backtrace limit exceeded", (uint8_t *)label, 0xCu);
      }
    }

  }
LABEL_101:
  if (v52)
    free(v52);
  v21 = 0;
LABEL_71:

  return v21;
}

void sub_183B6FA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void nw_masque_server_set_state_changed_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  void (**v6)(_QWORD);
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD aBlock[4];
  os_unfair_lock_s *v22;
  id v23;
  char v24;
  os_log_type_t v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_masque_server_set_state_changed_handler";
    v8 = (char *)_os_log_send_and_compose_impl();

    v25 = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24))
      goto LABEL_38;
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_masque_server_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = v25;
      v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_masque_server_set_state_changed_handler";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_masque_server_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_masque_server_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_masque_server_set_state_changed_handler_block_invoke;
    aBlock[3] = &unk_1E14ACE18;
    v22 = v3;
    v23 = v5;
    v6 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 4);
    v6[2](v6);
    os_unfair_lock_unlock(v3 + 4);

    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_masque_server_set_state_changed_handler";
  v8 = (char *)_os_log_send_and_compose_impl();

  v25 = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24))
    goto LABEL_38;
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_masque_server_set_state_changed_handler";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_masque_server_set_state_changed_handler";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = v25;
  v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_masque_server_set_state_changed_handler";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_masque_server_set_state_changed_handler";
    v28 = 2082;
    v29 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

void sub_183B70008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __nw_masque_server_set_state_changed_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 48);
  *(_QWORD *)(v3 + 48) = v2;

}

void nw_masque_server_set_error_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  void (**v6)(_QWORD);
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD aBlock[4];
  os_unfair_lock_s *v22;
  id v23;
  char v24;
  os_log_type_t v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_masque_server_set_error_handler";
    v8 = (char *)_os_log_send_and_compose_impl();

    v25 = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24))
      goto LABEL_38;
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_masque_server_set_error_handler";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = v25;
      v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_masque_server_set_error_handler";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_masque_server_set_error_handler";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_masque_server_set_error_handler";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_masque_server_set_error_handler_block_invoke;
    aBlock[3] = &unk_1E14ACE18;
    v22 = v3;
    v23 = v5;
    v6 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 4);
    v6[2](v6);
    os_unfair_lock_unlock(v3 + 4);

    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_masque_server_set_error_handler";
  v8 = (char *)_os_log_send_and_compose_impl();

  v25 = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24))
    goto LABEL_38;
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_masque_server_set_error_handler";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_masque_server_set_error_handler";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = v25;
  v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_masque_server_set_error_handler";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_masque_server_set_error_handler";
    v28 = 2082;
    v29 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

void sub_183B70594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __nw_masque_server_set_error_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 56);
  *(_QWORD *)(v3 + 56) = v2;

}

void nw_masque_server_set_outer_connection_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void (**v5)(_QWORD);
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  os_unfair_lock_s *v15;
  id v16;
  char v17;
  os_log_type_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_masque_server_set_outer_connection_handler_block_invoke;
    aBlock[3] = &unk_1E14ACE18;
    v15 = v3;
    v16 = v4;
    v5 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 4);
    v5[2](v5);
    os_unfair_lock_unlock(v3 + 4);

    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_masque_server_set_outer_connection_handler";
  v7 = (char *)_os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_outer_connection_handler";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_masque_server_set_outer_connection_handler";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_outer_connection_handler";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_outer_connection_handler";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_183B7090C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __nw_masque_server_set_outer_connection_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 96);
  *(_QWORD *)(v3 + 96) = v2;

}

void nw_masque_server_set_proxy_client_connection_event_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void (**v5)(_QWORD);
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  os_unfair_lock_s *v15;
  id v16;
  char v17;
  os_log_type_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_masque_server_set_proxy_client_connection_event_handler_block_invoke;
    aBlock[3] = &unk_1E14ACE18;
    v15 = v3;
    v16 = v4;
    v5 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 4);
    v5[2](v5);
    os_unfair_lock_unlock(v3 + 4);

    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_masque_server_set_proxy_client_connection_event_handler";
  v7 = (char *)_os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_proxy_client_connection_event_handler";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_masque_server_set_proxy_client_connection_event_handler";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_proxy_client_connection_event_handler";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_proxy_client_connection_event_handler";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_183B70C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __nw_masque_server_set_proxy_client_connection_event_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 88);
  *(_QWORD *)(v3 + 88) = v2;

}

id nw_masque_server_copy_parameters(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[4];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_masque_server_copy_parameters";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_masque_server_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_masque_server_copy_parameters";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_masque_server_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_masque_server_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_masque_server_get_port(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void (**v3)(_QWORD);
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  os_unfair_lock_s *v15;
  _BYTE *v16;
  char v17;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v20 = 0;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_masque_server_get_port_block_invoke;
    aBlock[3] = &unk_1E14ACE40;
    v16 = buf;
    v15 = v1;
    v3 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 4);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 4);

    v4 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_masque_server_get_port";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_server_get_port";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_masque_server_get_port";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_server_get_port";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_server_get_port";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_3:

  return v4;
}

void sub_183B712AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_masque_server_get_port_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = nw_listener_get_port(*(nw_listener_t *)(*(_QWORD *)(a1 + 32) + 64));
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void nw_masque_server_set_outbound_interface(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void (**v5)(_QWORD);
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  os_unfair_lock_s *v15;
  id v16;
  char v17;
  os_log_type_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_masque_server_set_outbound_interface_block_invoke;
    aBlock[3] = &unk_1E14ACE68;
    v15 = v3;
    v16 = v4;
    v5 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 4);
    v5[2](v5);
    os_unfair_lock_unlock(v3 + 4);

    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_masque_server_set_outbound_interface";
  v7 = (char *)_os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_outbound_interface";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_masque_server_set_outbound_interface";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_outbound_interface";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_masque_server_set_outbound_interface";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_183B71628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __nw_masque_server_set_outbound_interface_block_invoke(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 112), *(id *)(a1 + 40));
}

uint64_t __Block_byref_object_copy__87292(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__87293(uint64_t a1)
{

}

void __nw_masque_server_copy_client_queue_block_invoke(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(id *)(*(_QWORD *)(a1 + 32) + 40));
}

void nw_masque_server_start(void *a1)
{
  id v1;
  nw_parameters_t secure_udp;
  void *v3;
  _QWORD *v4;
  NSObject *v5;
  NSObject *v6;
  int required_interface_subtype;
  NSObject *v8;
  void *v9;
  NWConcrete_nw_protocol_options *options;
  NWConcrete_nw_protocol_options *v11;
  id v12;
  void *v13;
  void *v14;
  NSObject *v15;
  NWConcrete_nw_protocol_options *v16;
  nw_listener_t v17;
  void *v18;
  void *v19;
  NSObject *v20;
  uint64_t v21;
  id v22;
  NSObject *v23;
  dispatch_queue_t *v24;
  id v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  char *backtrace_string;
  _BOOL4 v30;
  os_log_type_t v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  char *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  os_log_type_t v39;
  os_log_type_t v40;
  _QWORD v41[4];
  dispatch_queue_t *v42;
  _QWORD handler[4];
  id v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  char *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    secure_udp = nw_parameters_create_secure_udp(&__block_literal_global_18950, &__block_literal_global_87299);
    nw_parameters_set_data_mode(secure_udp, 2u);
    nw_parameters_set_server_mode(secure_udp, 1);
    nw_parameters_set_attach_protocol_listener(secure_udp, 1);
    v3 = (void *)*((_QWORD *)v1 + 4);
    if (v3)
    {
      v4 = v3;
      v5 = *(id *)(v4[13] + 160);

      if (v5)
        nw_parameters_set_local_endpoint(secure_udp, v5);
      v6 = nw_parameters_copy_required_interface(*((nw_parameters_t *)v1 + 4));
      if (v6)
        nw_parameters_require_interface(secure_udp, v6);
      required_interface_subtype = nw_parameters_get_required_interface_subtype(*((void **)v1 + 4));
      if (required_interface_subtype)
        nw_parameters_set_required_interface_subtype(secure_udp, required_interface_subtype);
      if (nw_parameters_get_always_open_listener_socket(*((void **)v1 + 4)))
        nw_parameters_set_always_open_listener_socket(secure_udp, 1);
      if (nw_parameters_get_use_awdl(*((void **)v1 + 4)))
        nw_parameters_set_use_awdl(secure_udp, 1);

    }
    v8 = nw_parameters_copy_default_protocol_stack(secure_udp);
    if (nw_protocol_demux_copy_definition::onceToken != -1)
      dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25927);
    if (nw_protocol_demux_copy_definition::definition)
    {
      v9 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
      options = nw_protocol_create_options(v9);
      if (v9)
        os_release(v9);
    }
    else
    {
      options = nw_protocol_create_options(0);
    }
    nw_protocol_stack_prepend_application_protocol(v8, &options->super);

    if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
    v11 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
    v12 = nw_quic_stream_copy_shared_connection_options(v11);
    v13 = v12;
    v14 = (void *)*((_QWORD *)v1 + 15);
    if (v14)
      nw_quic_connection_set_sec_protocol_options(v12, v14);
    v15 = nw_quic_connection_copy_sec_protocol_options(v13);
    sec_protocol_options_append_tls_ciphersuite_group(v15, tls_ciphersuite_group_default);
    sec_protocol_options_add_tls_application_protocol(v15, "h3");
    nw_quic_connection_set_initial_max_streams_bidirectional(v13, 0xFFFFFFFFLL);
    nw_quic_connection_set_max_datagram_frame_size(v13, 1400);
    nw_quic_connection_set_datagram_variant_flow_id_enabled(v13, 1);
    nw_quic_connection_set_pmtud_for_non_transport(v13, 1);
    nw_quic_connection_set_datagram_quarter_stream_id(v13, 1);
    nw_quic_connection_set_datagram_context_id(v13, 1);
    nw_protocol_stack_prepend_application_protocol(v8, &v11->super);
    if (nw_protocol_copy_http3_definition_onceToken != -1)
      dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_10_72326);
    v16 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
    nw_protocol_stack_prepend_application_protocol(v8, &v16->super);
    v17 = nw_listener_create(secure_udp);
    v18 = (void *)*((_QWORD *)v1 + 8);
    *((_QWORD *)v1 + 8) = v17;

    v19 = (void *)*((_QWORD *)v1 + 8);
    if (v19)
    {
      nw_listener_allow_new_connection_inline(v19);
      v20 = *((_QWORD *)v1 + 8);
      v21 = MEMORY[0x1E0C809B0];
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3221225472;
      handler[2] = __nw_masque_server_start_block_invoke_6;
      handler[3] = &unk_1E14ACEF8;
      v22 = v1;
      v44 = v22;
      nw_listener_set_new_connection_group_handler(v20, handler);
      v23 = *((_QWORD *)v1 + 8);
      v41[0] = v21;
      v41[1] = 3221225472;
      v41[2] = __nw_masque_server_start_block_invoke_8;
      v41[3] = &unk_1E14ACF48;
      v24 = (dispatch_queue_t *)v22;
      v42 = v24;
      nw_listener_set_state_changed_handler(v23, v41);
      nw_listener_set_queue(*((nw_listener_t *)v1 + 8), v24[3]);
      nw_listener_start(*((nw_listener_t *)v1 + 8));

LABEL_47:
      goto LABEL_48;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v48 = "nw_masque_server_start";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v26, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = (id)gLogObj;
        v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_masque_server_start";
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s nw_listener_create failed", buf, 0xCu);
        }
      }
      else if (v45)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = (id)gLogObj;
        v40 = type;
        v30 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v48 = "nw_masque_server_start";
            v49 = 2082;
            v50 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v27, v40, "%{public}s nw_listener_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v26)
            goto LABEL_47;
          goto LABEL_46;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_masque_server_start";
          _os_log_impl(&dword_182FBE000, v27, v40, "%{public}s nw_listener_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = (id)gLogObj;
        v31 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_masque_server_start";
          _os_log_impl(&dword_182FBE000, v27, v31, "%{public}s nw_listener_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v26)
      goto LABEL_47;
LABEL_46:
    free(v26);
    goto LABEL_47;
  }
  __nwlog_obj();
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v48 = "nw_masque_server_start";
  v33 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if (__nwlog_fault(v33, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_masque_server_start";
        _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v45)
    {
      v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      v38 = os_log_type_enabled(v34, type);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_masque_server_start";
          v49 = 2082;
          v50 = v36;
          _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v36);
        goto LABEL_65;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_masque_server_start";
        _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_masque_server_start";
        _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_65:
  if (v33)
    free(v33);
LABEL_48:

}

void sub_183B71EF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void __nw_masque_server_start_block_invoke_6(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  dispatch_queue_t *v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  dispatch_queue_t *v9;
  NSObject *v10;
  os_unfair_lock_s *v11;
  NSObject *v12;
  NSObject *v13;
  void (**v14)(_QWORD);
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  void *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  os_log_type_t v28;
  _QWORD aBlock[4];
  os_unfair_lock_s *v30;
  NSObject *v31;
  _QWORD state_changed_handler[4];
  os_unfair_lock_s *v33;
  NSObject *v34;
  _BYTE buf[24];
  void *v36;
  dispatch_queue_t *v37;
  NSObject *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_masque_server_start_block_invoke";
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v3;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s new connection group %@", buf, 0x16u);
  }

  v5 = (dispatch_queue_t *)*(id *)(a1 + 32);
  v6 = v3;
  v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
    v16 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(state_changed_handler[0]) = 16;
    LOBYTE(aBlock[0]) = 0;
    if (!__nwlog_fault(v16, state_changed_handler, aBlock))
      goto LABEL_40;
    if (LOBYTE(state_changed_handler[0]) == 17)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v18 = state_changed_handler[0];
      if (os_log_type_enabled(v17, state_changed_handler[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (LOBYTE(aBlock[0]))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v22 = state_changed_handler[0];
      v23 = os_log_type_enabled(v17, state_changed_handler[0]);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v16)
          goto LABEL_6;
LABEL_41:
        free(v16);
        goto LABEL_6;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
        _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v27 = state_changed_handler[0];
      if (os_log_type_enabled(v17, state_changed_handler[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
        _os_log_impl(&dword_182FBE000, v17, v27, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (v6)
  {
    nw_connection_group_set_queue(v6, v5[3]);
    v8 = MEMORY[0x1E0C809B0];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke;
    v36 = &unk_1E14AD020;
    v9 = v5;
    v37 = v9;
    v10 = v7;
    v38 = v10;
    nw_connection_group_set_new_connection_handler(v10, buf);
    state_changed_handler[0] = v8;
    state_changed_handler[1] = 3221225472;
    state_changed_handler[2] = ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke_98;
    state_changed_handler[3] = &unk_1E14AD048;
    v11 = v9;
    v33 = v11;
    v12 = v10;
    v34 = v12;
    nw_connection_group_set_state_changed_handler(v12, state_changed_handler);
    aBlock[0] = v8;
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke_2;
    aBlock[3] = &unk_1E14ACE68;
    v30 = v11;
    v13 = v12;
    v31 = v13;
    v14 = (void (**)(_QWORD))_Block_copy(aBlock);
    v11 += 4;
    os_unfair_lock_lock(v11);
    v14[2](v14);
    os_unfair_lock_unlock(v11);

    nw_connection_group_start(v13);
    goto LABEL_6;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
  v16 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(state_changed_handler[0]) = 16;
  LOBYTE(aBlock[0]) = 0;
  if (!__nwlog_fault(v16, state_changed_handler, aBlock))
    goto LABEL_40;
  if (LOBYTE(state_changed_handler[0]) == 17)
  {
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    v20 = state_changed_handler[0];
    if (os_log_type_enabled(v17, state_changed_handler[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
      _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null connection_group", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!LOBYTE(aBlock[0]))
  {
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    v28 = state_changed_handler[0];
    if (os_log_type_enabled(v17, state_changed_handler[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
      _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s called with null connection_group, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v24 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v17 = objc_claimAutoreleasedReturnValue();
  v25 = state_changed_handler[0];
  v26 = os_log_type_enabled(v17, state_changed_handler[0]);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
      _os_log_impl(&dword_182FBE000, v17, v25, "%{public}s called with null connection_group, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v26)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_masque_connection_group_start";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v24;
    _os_log_impl(&dword_182FBE000, v17, v25, "%{public}s called with null connection_group, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v24);
  if (v16)
    goto LABEL_41;
LABEL_6:

}

void sub_183B72624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  void *v30;
  void *v31;

  _Unwind_Resume(a1);
}

void __nw_masque_server_start_block_invoke_8(uint64_t a1, int a2, void *a3)
{
  id v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  id v8;
  void (**v9)(_QWORD);
  _QWORD aBlock[4];
  os_unfair_lock_s *v11;
  id v12;
  int v13;

  v5 = a3;
  v6 = *(os_unfair_lock_s **)(a1 + 32);
  v7 = v6 + 4;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_masque_server_start_block_invoke_2;
  aBlock[3] = &unk_1E14ACF20;
  v11 = v6;
  v13 = a2;
  v8 = v5;
  v12 = v8;
  v9 = (void (**)(_QWORD))_Block_copy(aBlock);
  os_unfair_lock_lock(v7);
  v9[2](v9);
  os_unfair_lock_unlock(v7);

}

void sub_183B7276C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void __nw_masque_server_start_block_invoke_2(uint64_t a1)
{
  int v2;
  void *v3;
  _QWORD *v4;
  id v5;
  const void *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  id v10;
  uint64_t v11;
  NSObject *v12;
  _BOOL4 v13;
  const char *v14;
  __int128 v15;
  uint64_t (*v16)(uint64_t);
  void *v17;
  id v18;
  id v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(void **)(a1 + 40);
  v4 = *(id *)(a1 + 32);
  v5 = v3;
  v6 = (const void *)v4[6];
  if (v6)
  {
    v7 = _Block_copy(v6);
    if (v2 == 4)
    {
      v8 = (void *)v4[6];
      v4[6] = 0;

    }
    v9 = v4[5];
    *(_QWORD *)&v15 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v15 + 1) = 3221225472;
    v16 = ___ZL42nw_masque_server_call_state_handler_lockedP27NWConcrete_nw_masque_server19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke;
    v17 = &unk_1E14ACFF8;
    v19 = v7;
    v20 = v2;
    v18 = v5;
    v10 = v7;
    dispatch_async(v9, &v15);

  }
  if (*(_DWORD *)(a1 + 48) == 3)
  {
    v11 = *(_QWORD *)(a1 + 40);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (v11)
    {
      if (v13)
      {
        LODWORD(v15) = 136446210;
        *(_QWORD *)((char *)&v15 + 4) = "nw_masque_server_start_block_invoke";
        v14 = "%{public}s listener reported state of failed with error";
LABEL_11:
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v15, 0xCu);
      }
    }
    else if (v13)
    {
      LODWORD(v15) = 136446210;
      *(_QWORD *)((char *)&v15 + 4) = "nw_masque_server_start_block_invoke_2";
      v14 = "%{public}s listener reported state of failed with NULL error";
      goto LABEL_11;
    }

  }
}

uint64_t ___ZL42nw_masque_server_call_state_handler_lockedP27NWConcrete_nw_masque_server19nw_listener_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48), *(_QWORD *)(a1 + 32));
}

void ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke(uint64_t a1, void *a2)
{
  id v4;
  NSObject *v5;
  void *v6;
  void *v7;
  _QWORD *v8;
  id v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  NWConcrete_nw_masque_connection *v15;
  id v16;
  os_unfair_lock_s *v17;
  id v18;
  id v19;
  id v20;
  id v21;
  unint64_t v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  void *v28;
  NWConcrete_nw_masque_connection *v29;
  id v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  char *v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  NSObject *v38;
  NSObject *v39;
  id *v40;
  id v41;
  uint64_t v42;
  os_unfair_lock_s *v43;
  NWConcrete_nw_masque_connection *v44;
  void (**v45)(_QWORD);
  NWConcrete_nw_masque_connection *v46;
  os_log_type_t *v47;
  NSObject *v48;
  NWConcrete_nw_masque_connection *v49;
  os_log_type_t *v50;
  uint64_t id;
  os_unfair_lock_s *v52;
  os_unfair_lock_s *v53;
  void (**v54)(_QWORD);
  os_unfair_lock_s *v55;
  NSObject *v56;
  os_unfair_lock_s *v57;
  id *v58;
  NWConcrete_nw_masque_connection *v59;
  id v60;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  char *v64;
  os_log_type_t v65;
  _BOOL4 v66;
  os_log_type_t v67;
  void *v68;
  char *v69;
  NSObject *v70;
  os_log_type_t receiver;
  void *v72;
  os_log_type_t v73;
  void *v74;
  char *v75;
  NSObject *v76;
  os_log_type_t v77;
  void *v78;
  char *v79;
  NSObject *v80;
  os_log_type_t v81;
  char *backtrace_string;
  os_log_type_t v83;
  _BOOL4 v84;
  char *v85;
  os_log_type_t v86;
  _BOOL4 v87;
  char *v88;
  os_log_type_t v89;
  _BOOL4 v90;
  char *v91;
  os_log_type_t v92;
  _BOOL4 v93;
  os_log_type_t v94;
  os_log_type_t v95;
  os_log_type_t v96;
  os_log_type_t v97;
  id v98;
  id v99;
  void *v100;
  id v101;
  id v102;
  id v103;
  _QWORD *v104;
  void *v105;
  id v106;
  os_unfair_lock_s *v107;
  os_log_type_t type[8];
  uint64_t v109;
  void (*v110)(uint64_t);
  void *v111;
  os_unfair_lock_s *v112;
  NWConcrete_nw_masque_connection *v113;
  objc_super aBlock;
  void (*v115)(uint64_t);
  void *v116;
  os_unfair_lock_s *v117;
  NWConcrete_nw_masque_connection *v118;
  char v119;
  _BYTE buf[24];
  NWConcrete_nw_masque_connection *v121;
  __int128 v122;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_masque_connection_group_start_block_invoke";
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v4;
    _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s new inner connection %@", buf, 0x16u);
  }

  v6 = *(void **)(a1 + 32);
  v7 = *(void **)(a1 + 40);
  v8 = v6;
  v9 = v4;
  v99 = v7;
  v104 = v8;
  v105 = v9;
  if (!v8)
  {
    __nwlog_obj();
    v68 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
    v69 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock.receiver) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v69, &aBlock, type))
      goto LABEL_118;
    if (LOBYTE(aBlock.receiver) == 17)
    {
      __nwlog_obj();
      v70 = objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)aBlock.receiver;
      if (os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
        _os_log_impl(&dword_182FBE000, v70, receiver, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v70 = objc_claimAutoreleasedReturnValue();
      v83 = (os_log_type_t)aBlock.receiver;
      v84 = os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver);
      if (backtrace_string)
      {
        if (v84)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v70, v83, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_118:
        if (!v69)
          goto LABEL_58;
LABEL_119:
        free(v69);
        goto LABEL_58;
      }
      if (v84)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
        _os_log_impl(&dword_182FBE000, v70, v83, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v70 = objc_claimAutoreleasedReturnValue();
      v94 = (os_log_type_t)aBlock.receiver;
      if (os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
        _os_log_impl(&dword_182FBE000, v70, v94, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_117:

    goto LABEL_118;
  }
  if (v9)
  {
    v10 = (void *)v8[3];
    v11 = (void *)v8[16];
    v12 = (void *)v104[14];
    v13 = (void *)v104[12];
    v106 = v9;
    v14 = v10;
    v107 = v104;
    v101 = v11;
    v102 = v12;
    v103 = v13;
    v100 = v14;
    if (v14)
    {
      v15 = [NWConcrete_nw_masque_connection alloc];
      v98 = v106;
      v16 = v14;
      v17 = v107;
      v18 = v101;
      v19 = v102;
      v20 = v103;
      if (!v15)
        goto LABEL_10;
      aBlock.receiver = v15;
      aBlock.super_class = (Class)NWConcrete_nw_masque_connection;
      v21 = objc_msgSendSuper2(&aBlock, sel_init);
      v15 = (NWConcrete_nw_masque_connection *)v21;
      if (v21)
      {
        do
          v22 = __ldaxr(&s_last_connection_id);
        while (__stlxr(v22 + 1, &s_last_connection_id));
        *((_QWORD *)v21 + 1) = v22;
        objc_storeStrong((id *)v21 + 4, v10);
        objc_storeStrong((id *)v15 + 6, a2);
        v23 = nw_dictionary_create();
        v24 = (void *)*((_QWORD *)v15 + 7);
        *((_QWORD *)v15 + 7) = v23;

        v25 = nw_dictionary_create();
        v26 = (void *)*((_QWORD *)v15 + 8);
        *((_QWORD *)v15 + 8) = v25;

        *((_BYTE *)v15 + 112) = 1;
        objc_storeWeak((id *)v15 + 5, v17);
        objc_storeStrong((id *)v15 + 9, v11);
        objc_storeStrong((id *)v15 + 10, v12);
        v27 = _Block_copy(v20);
        v28 = (void *)*((_QWORD *)v15 + 11);
        *((_QWORD *)v15 + 11) = v27;

        goto LABEL_10;
      }
      __nwlog_obj();
      v78 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identity:outb"
                           "ound_interface:outer_connection_handler:]";
      v79 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v119 = 0;
      if ((__nwlog_fault(v79, type, &v119) & 1) != 0)
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v80 = objc_claimAutoreleasedReturnValue();
          v81 = type[0];
          if (os_log_type_enabled(v80, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identit"
                                 "y:outbound_interface:outer_connection_handler:]";
            _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v119)
        {
          v91 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v80 = objc_claimAutoreleasedReturnValue();
          v92 = type[0];
          v93 = os_log_type_enabled(v80, type[0]);
          if (v91)
          {
            if (v93)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_ident"
                                   "ity:outbound_interface:outer_connection_handler:]";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v91;
              _os_log_impl(&dword_182FBE000, v80, v92, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v91);
            goto LABEL_129;
          }
          if (v93)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identit"
                                 "y:outbound_interface:outer_connection_handler:]";
            _os_log_impl(&dword_182FBE000, v80, v92, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v80 = objc_claimAutoreleasedReturnValue();
          v97 = type[0];
          if (os_log_type_enabled(v80, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "-[NWConcrete_nw_masque_connection initWithConnection:queue:parent:reverse_proxy_identit"
                                 "y:outbound_interface:outer_connection_handler:]";
            _os_log_impl(&dword_182FBE000, v80, v97, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_129:
      if (v79)
        free(v79);
      v15 = 0;
LABEL_10:

      if (v15)
      {
        v29 = v15;
LABEL_31:

        goto LABEL_32;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_masque_connection_create";
      v31 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(aBlock.receiver) = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if ((__nwlog_fault(v31, &aBlock, type) & 1) != 0)
      {
        if (LOBYTE(aBlock.receiver) == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v32 = (id)gLogObj;
          v33 = (os_log_type_t)aBlock.receiver;
          if (os_log_type_enabled(v32, (os_log_type_t)aBlock.receiver))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_masque_connection_create";
            _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed", buf, 0xCu);
          }
        }
        else if (type[0])
        {
          v34 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v32 = (id)gLogObj;
          v35 = (os_log_type_t)aBlock.receiver;
          v36 = os_log_type_enabled(v32, (os_log_type_t)aBlock.receiver);
          if (v34)
          {
            if (v36)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_masque_connection_create";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v34;
              _os_log_impl(&dword_182FBE000, v32, v35, "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v34);
            if (!v31)
              goto LABEL_31;
            goto LABEL_30;
          }
          if (v36)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_masque_connection_create";
            _os_log_impl(&dword_182FBE000, v32, v35, "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v32 = (id)gLogObj;
          v37 = (os_log_type_t)aBlock.receiver;
          if (os_log_type_enabled(v32, (os_log_type_t)aBlock.receiver))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_masque_connection_create";
            _os_log_impl(&dword_182FBE000, v32, v37, "%{public}s [nw_masque_connection initWithConnection:queue:masque:] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v31)
        goto LABEL_31;
LABEL_30:
      free(v31);
      goto LABEL_31;
    }
    __nwlog_obj();
    v74 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_masque_connection_create";
    v75 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock.receiver) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v75, &aBlock, type))
    {
      if (LOBYTE(aBlock.receiver) == 17)
      {
        __nwlog_obj();
        v76 = objc_claimAutoreleasedReturnValue();
        v77 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v76, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_masque_connection_create";
          _os_log_impl(&dword_182FBE000, v76, v77, "%{public}s called with null queue", buf, 0xCu);
        }
      }
      else if (type[0])
      {
        v88 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v76 = objc_claimAutoreleasedReturnValue();
        v89 = (os_log_type_t)aBlock.receiver;
        v90 = os_log_type_enabled(v76, (os_log_type_t)aBlock.receiver);
        if (v88)
        {
          if (v90)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_masque_connection_create";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v88;
            _os_log_impl(&dword_182FBE000, v76, v89, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v88);
          goto LABEL_123;
        }
        if (v90)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_masque_connection_create";
          _os_log_impl(&dword_182FBE000, v76, v89, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v76 = objc_claimAutoreleasedReturnValue();
        v96 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v76, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_masque_connection_create";
          _os_log_impl(&dword_182FBE000, v76, v96, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_123:
    if (v75)
      free(v75);
    v15 = 0;
LABEL_32:

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = (id)gLogObj;
    v39 = v38;
    if (v15)
    {
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        v40 = (id *)v106;
        v41 = v40[1];

        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v107;
        *(_WORD *)&buf[22] = 2112;
        v121 = v15;
        LOWORD(v122) = 2112;
        *(_QWORD *)((char *)&v122 + 2) = v41;
        _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEFAULT, "%{public}s %@ received new connection %@ from %@", buf, 0x2Au);

      }
      v42 = MEMORY[0x1E0C809B0];
      aBlock.receiver = (id)MEMORY[0x1E0C809B0];
      aBlock.super_class = (Class)3221225472;
      v115 = ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke;
      v116 = &unk_1E14ACE68;
      v43 = v107;
      v117 = v43;
      v44 = v15;
      v118 = v44;
      v45 = (void (**)(_QWORD))_Block_copy(&aBlock);
      os_unfair_lock_lock(v107 + 4);
      v45[2](v45);
      os_unfair_lock_unlock(v107 + 4);

      *(_QWORD *)type = v42;
      v109 = 3221225472;
      v110 = ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke_2;
      v111 = &unk_1E14ACE68;
      v112 = v43;
      v113 = v44;
      v46 = v113;
      v47 = type;
      v48 = *((_QWORD *)v46 + 4);
      *(_QWORD *)buf = v42;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = __nw_masque_connection_set_cancel_handler_block_invoke;
      v121 = (NWConcrete_nw_masque_connection *)&unk_1E14ACE18;
      v49 = v46;
      *(_QWORD *)&v122 = v49;
      v50 = v47;
      *((_QWORD *)&v122 + 1) = v50;
      dispatch_async(v48, buf);

      id = nw_connection_group_get_id(v99);
      v52 = v49;
      *(_QWORD *)buf = v42;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = __nw_masque_connection_set_group_identifier_block_invoke;
      v121 = (NWConcrete_nw_masque_connection *)&unk_1E14AA348;
      v53 = v52;
      *(_QWORD *)&v122 = v53;
      *((_QWORD *)&v122 + 1) = id;
      v54 = (void (**)(_QWORD))_Block_copy(buf);
      v52 += 6;
      os_unfair_lock_lock(v52);
      v54[2](v54);
      os_unfair_lock_unlock(v52);

      v55 = v53;
      v56 = *((_QWORD *)v46 + 4);
      *(_QWORD *)buf = v42;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = __nw_masque_connection_start_block_invoke;
      v121 = (NWConcrete_nw_masque_connection *)&unk_1E14ACFD0;
      v57 = v55;
      *(_QWORD *)&v122 = v57;
      dispatch_async(v56, buf);

      goto LABEL_57;
    }
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      v58 = (id *)v106;
      v59 = (NWConcrete_nw_masque_connection *)v58[1];

      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v107;
      *(_WORD *)&buf[22] = 2112;
      v121 = v59;
      _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_ERROR, "%{public}s %@ failed to create new connection from %@", buf, 0x20u);

    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v60 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
    v61 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock.receiver) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v61, &aBlock, type))
    {
      if (LOBYTE(aBlock.receiver) == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v62 = (id)gLogObj;
        v63 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v62, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
          _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s nw_masque_connection_create failed", buf, 0xCu);
        }
      }
      else if (type[0])
      {
        v64 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v62 = (id)gLogObj;
        v65 = (os_log_type_t)aBlock.receiver;
        v66 = os_log_type_enabled(v62, (os_log_type_t)aBlock.receiver);
        if (v64)
        {
          if (v66)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v64;
            _os_log_impl(&dword_182FBE000, v62, v65, "%{public}s nw_masque_connection_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v64);
          if (!v61)
            goto LABEL_57;
          goto LABEL_56;
        }
        if (v66)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
          _os_log_impl(&dword_182FBE000, v62, v65, "%{public}s nw_masque_connection_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v62 = (id)gLogObj;
        v67 = (os_log_type_t)aBlock.receiver;
        if (os_log_type_enabled(v62, (os_log_type_t)aBlock.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
          _os_log_impl(&dword_182FBE000, v62, v67, "%{public}s nw_masque_connection_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v61)
    {
LABEL_57:

      goto LABEL_58;
    }
LABEL_56:
    free(v61);
    goto LABEL_57;
  }
  __nwlog_obj();
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
  v69 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(aBlock.receiver) = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v69, &aBlock, type))
    goto LABEL_118;
  if (LOBYTE(aBlock.receiver) == 17)
  {
    __nwlog_obj();
    v70 = objc_claimAutoreleasedReturnValue();
    v73 = (os_log_type_t)aBlock.receiver;
    if (os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
      _os_log_impl(&dword_182FBE000, v70, v73, "%{public}s called with null inner_connection", buf, 0xCu);
    }
    goto LABEL_117;
  }
  if (type[0] == OS_LOG_TYPE_DEFAULT)
  {
    __nwlog_obj();
    v70 = objc_claimAutoreleasedReturnValue();
    v95 = (os_log_type_t)aBlock.receiver;
    if (os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
      _os_log_impl(&dword_182FBE000, v70, v95, "%{public}s called with null inner_connection, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_117;
  }
  v85 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v70 = objc_claimAutoreleasedReturnValue();
  v86 = (os_log_type_t)aBlock.receiver;
  v87 = os_log_type_enabled(v70, (os_log_type_t)aBlock.receiver);
  if (!v85)
  {
    if (v87)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
      _os_log_impl(&dword_182FBE000, v70, v86, "%{public}s called with null inner_connection, no backtrace", buf, 0xCu);
    }
    goto LABEL_117;
  }
  if (v87)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_masque_inner_connection_start";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v85;
    _os_log_impl(&dword_182FBE000, v70, v86, "%{public}s called with null inner_connection, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v85);
  if (v69)
    goto LABEL_119;
LABEL_58:

}

void sub_183B73CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,void *a37)
{
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;

  _Unwind_Resume(a1);
}

void ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke_98(uint64_t a1, int a2, void *a3)
{
  id v5;
  NSObject *v6;
  os_unfair_lock_s *v7;
  void (**v8)(_QWORD);
  _QWORD v9[4];
  os_unfair_lock_s *v10;
  id v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  id v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446722;
    v13 = "nw_masque_connection_group_start_block_invoke";
    v14 = 1024;
    v15 = a2;
    v16 = 2112;
    v17 = v5;
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s group state %u, error %@", buf, 0x1Cu);
  }

  if ((a2 - 3) > 1)
  {
    if (a2 == 2)
      nw_masque_server_call_proxy_client_connection_event_handler(*(void **)(a1 + 32), *(void **)(a1 + 40), 1);
  }
  else
  {
    v7 = *(os_unfair_lock_s **)(a1 + 32);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke_99;
    v9[3] = &unk_1E14ACE68;
    v10 = v7;
    v11 = *(id *)(a1 + 40);
    v8 = (void (**)(_QWORD))_Block_copy(v9);
    v7 += 4;
    os_unfair_lock_lock(v7);
    v8[2](v8);
    os_unfair_lock_unlock(v7);

    nw_connection_group_cancel(*(nw_connection_group_t *)(a1 + 40));
    if (a2 == 4)
      nw_masque_server_call_proxy_client_connection_event_handler(*(void **)(a1 + 32), *(void **)(a1 + 40), 2);

  }
}

void sub_183B73F44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke_2(uint64_t a1)
{
  nw_array_append(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 72), *(void **)(a1 + 40));
}

BOOL ___ZL32nw_masque_connection_group_startP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject_block_invoke_99(_BOOL8 result)
{
  if (*(_QWORD *)(*(_QWORD *)(result + 32) + 72))
    return nw_array_remove_object(*(_QWORD *)(*(_QWORD *)(result + 32) + 72), *(_QWORD *)(result + 40));
  return result;
}

void nw_masque_server_call_proxy_client_connection_event_handler(void *a1, void *a2, int a3)
{
  os_unfair_lock_s *v5;
  id v6;
  void *v7;
  void (**v8)(_QWORD);
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  _QWORD aBlock[4];
  os_unfair_lock_s *v24;
  id v25;
  int v26;
  char v27;
  os_log_type_t v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
    v10 = (char *)_os_log_send_and_compose_impl();

    v28 = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v10, &v28, &v27))
      goto LABEL_38;
    if (v28 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = v28;
      if (os_log_type_enabled(v11, v28))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = v28;
      v17 = os_log_type_enabled(v11, v28);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v10)
          goto LABEL_4;
LABEL_39:
        free(v10);
        goto LABEL_4;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v21 = v28;
      if (os_log_type_enabled(v11, v28))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v6)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZL59nw_masque_server_call_proxy_client_connection_event_handlerP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject41nw_masque_proxy_client_connection_event_t_block_invoke;
    aBlock[3] = &unk_1E14ACF20;
    v24 = v5;
    v25 = v7;
    v26 = a3;
    v8 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v5 + 4);
    v8[2](v8);
    os_unfair_lock_unlock(v5 + 4);

    goto LABEL_4;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
  v10 = (char *)_os_log_send_and_compose_impl();

  v28 = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v10, &v28, &v27))
    goto LABEL_38;
  if (v28 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v14 = v28;
    if (os_log_type_enabled(v11, v28))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
      _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null connection_group", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v27)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v22 = v28;
    if (os_log_type_enabled(v11, v28))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
      _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null connection_group, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v18 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  v19 = v28;
  v20 = os_log_type_enabled(v11, v28);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
      _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null connection_group, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    v30 = "nw_masque_server_call_proxy_client_connection_event_handler";
    v31 = 2082;
    v32 = v18;
    _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null connection_group, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10)
    goto LABEL_39;
LABEL_4:

}

void sub_183B744EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void ___ZL59nw_masque_server_call_proxy_client_connection_event_handlerP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject41nw_masque_proxy_client_connection_event_t_block_invoke(uint64_t a1)
{
  const void *v2;
  void *v3;
  unsigned int id;
  NSObject *v5;
  id v6;
  _QWORD block[4];
  id v8;
  uint64_t v9;
  int v10;

  v2 = *(const void **)(*(_QWORD *)(a1 + 32) + 88);
  if (v2)
  {
    v3 = _Block_copy(v2);
    id = nw_connection_group_get_id(*(void **)(a1 + 40));
    v5 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 40);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZL59nw_masque_server_call_proxy_client_connection_event_handlerP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject41nw_masque_proxy_client_connection_event_t_block_invoke_2;
    block[3] = &unk_1E14AD070;
    v8 = v3;
    v9 = id;
    v10 = *(_DWORD *)(a1 + 48);
    v6 = v3;
    dispatch_async(v5, block);

  }
}

uint64_t ___ZL59nw_masque_server_call_proxy_client_connection_event_handlerP27NWConcrete_nw_masque_serverPU33objcproto22OS_nw_connection_group8NSObject41nw_masque_proxy_client_connection_event_t_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48));
}

void ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke(uint64_t a1)
{
  nw_array_append(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 104), *(void **)(a1 + 40));
}

void ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke_2(uint64_t a1)
{
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  void (**v4)(_QWORD);
  _QWORD v5[4];
  os_unfair_lock_s *v6;
  id v7;

  v2 = *(os_unfair_lock_s **)(a1 + 32);
  v3 = v2 + 4;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke_3;
  v5[3] = &unk_1E14ACE68;
  v6 = v2;
  v7 = *(id *)(a1 + 40);
  v4 = (void (**)(_QWORD))_Block_copy(v5);
  os_unfair_lock_lock(v3);
  v4[2](v4);
  os_unfair_lock_unlock(v3);

}

void sub_183B74690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void ___ZL32nw_masque_inner_connection_startP27NWConcrete_nw_masque_serverPU27objcproto16OS_nw_connection8NSObjectPU33objcproto22OS_nw_connection_groupS1__block_invoke_3(uint64_t a1)
{
  _BOOL8 v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = nw_array_duplicate_array_without_object(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 104), *(void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 104);
  *(_QWORD *)(v3 + 104) = v2;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 104);
  if (v5)
    v6 = (uint64_t)(*(_QWORD *)(v5 + 24) - *(_QWORD *)(v5 + 16)) >> 3;
  else
    v6 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 32);
    v9 = *(_QWORD *)(a1 + 40);
    v10 = 136446978;
    v11 = "nw_masque_inner_connection_start_block_invoke_3";
    v12 = 2112;
    v13 = v8;
    v14 = 2112;
    v15 = v9;
    v16 = 2048;
    v17 = v6;
    _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %@ cancelled connection %@, %zu remaining", (uint8_t *)&v10, 0x2Au);
  }

}

void __nw_masque_server_start_block_invoke(uint64_t a1, void *a2)
{
  nw_udp_options_set_use_quic_stats(a2, 1);
}

void nw_masque_server_cancel(void *a1)
{
  _QWORD *v1;
  void *v2;
  NSObject *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  void *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  char *v13;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  os_log_type_t v17;
  _QWORD block[4];
  _QWORD *v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_masque_server_cancel";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v5, &type, &v20))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_masque_server_cancel";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_masque_server_cancel";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5)
          goto LABEL_4;
LABEL_39:
        free(v5);
        goto LABEL_4;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_masque_server_cancel";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_masque_server_cancel";
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  v3 = v1[3];
  if (v3)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __nw_masque_server_cancel_block_invoke;
    block[3] = &unk_1E14ACFD0;
    v19 = v1;
    dispatch_async(v3, block);

    goto LABEL_4;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_masque_server_cancel";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v5, &type, &v20))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v9 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_masque_server_cancel";
      _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null server->ms_queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_masque_server_cancel";
      _os_log_impl(&dword_182FBE000, v6, v17, "%{public}s called with null server->ms_queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v13 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v6 = objc_claimAutoreleasedReturnValue();
  v14 = type;
  v15 = os_log_type_enabled(v6, type);
  if (!v13)
  {
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_masque_server_cancel";
      _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null server->ms_queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_masque_server_cancel";
    v24 = 2082;
    v25 = v13;
    _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null server->ms_queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v5)
    goto LABEL_39;
LABEL_4:

}

void __nw_masque_server_cancel_block_invoke(uint64_t a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void (**v3)(_QWORD);
  _QWORD aBlock[4];
  os_unfair_lock_s *v5;

  v1 = *(os_unfair_lock_s **)(a1 + 32);
  v2 = v1 + 4;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_masque_server_cancel_block_invoke_2;
  aBlock[3] = &unk_1E14ACFD0;
  v5 = v1;
  v3 = (void (**)(_QWORD))_Block_copy(aBlock);
  os_unfair_lock_lock(v2);
  v3[2](v3);
  os_unfair_lock_unlock(v2);

}

void sub_183B74D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

unsigned __int8 *__nw_masque_server_cancel_block_invoke_2(uint64_t a1)
{
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  unsigned __int8 *v6;
  unsigned __int8 *result;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = v2[8];
  if (v3)
  {
    nw_listener_cancel(v3);
    v4 = *(_QWORD *)(a1 + 32);
    v5 = *(void **)(v4 + 64);
    *(_QWORD *)(v4 + 64) = 0;

    v2 = *(_QWORD **)(a1 + 32);
  }
  v6 = (unsigned __int8 *)v2[13];
  if (v6)
  {
    nw_array_apply(v6, (uint64_t)&__block_literal_global_10_87362);
    v2 = *(_QWORD **)(a1 + 32);
  }
  result = (unsigned __int8 *)v2[9];
  if (result)
    return (unsigned __int8 *)nw_array_apply(result, (uint64_t)&__block_literal_global_11_87363);
  return result;
}

uint64_t __nw_masque_server_cancel_block_invoke_4(int a1, int a2, nw_connection_group_t group)
{
  nw_connection_group_cancel(group);
  return 1;
}

uint64_t __nw_masque_server_cancel_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD *v3;
  void *v4;
  NSObject *v5;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  _BYTE block[24];
  void *v18;
  _QWORD *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a3;
  v4 = v3;
  if (v3)
  {
    v5 = v3[4];
    *(_QWORD *)block = MEMORY[0x1E0C809B0];
    *(_QWORD *)&block[8] = 3221225472;
    *(_QWORD *)&block[16] = __nw_masque_connection_cancel_block_invoke;
    v18 = &unk_1E14ACFD0;
    v19 = v3;
    dispatch_async(v5, block);

    goto LABEL_3;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  *(_DWORD *)block = 136446210;
  *(_QWORD *)&block[4] = "nw_masque_connection_cancel";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_masque_connection_cancel";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null connection", block, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)block = 136446466;
          *(_QWORD *)&block[4] = "nw_masque_connection_cancel";
          *(_WORD *)&block[12] = 2082;
          *(_QWORD *)&block[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", block, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_masque_connection_cancel";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection, no backtrace", block, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_masque_connection_cancel";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection, backtrace limit exceeded", block, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

  return 1;
}

void sub_183B7545C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183B75570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)nw_interpose_flow;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_183B7584C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{

  _Unwind_Resume(a1);
}

void sub_183B75B48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183B75CEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183B75F58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183B761A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183B762A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_interface_create_static(unsigned __int8 *a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6, __int16 a7, int a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  NWConcrete_nw_interface *v19;
  NWConcrete_nw_interface *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  __int16 v45;
  __int16 v46;
  NWConcrete_nw_interface *v47;
  void *v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  char *backtrace_string;
  os_log_type_t v54;
  _BOOL4 v55;
  os_log_type_t v56;
  char v57;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v60;
  __int16 v61;
  char *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v19 = objc_alloc_init(NWConcrete_nw_interface);
    v20 = v19;
    if (v19)
    {
      v21 = *a1;
      v19->name[0] = v21;
      if (v21)
      {
        v22 = a1[1];
        v19->name[1] = v22;
        if (v22)
        {
          v23 = a1[2];
          v19->name[2] = v23;
          if (v23)
          {
            v24 = a1[3];
            v19->name[3] = v24;
            if (v24)
            {
              v25 = a1[4];
              v19->name[4] = v25;
              if (v25)
              {
                v26 = a1[5];
                v19->name[5] = v26;
                if (v26)
                {
                  v27 = a1[6];
                  v19->name[6] = v27;
                  if (v27)
                  {
                    v28 = a1[7];
                    v19->name[7] = v28;
                    if (v28)
                    {
                      v29 = a1[8];
                      v19->name[8] = v29;
                      if (v29)
                      {
                        v30 = a1[9];
                        v19->name[9] = v30;
                        if (v30)
                        {
                          v31 = a1[10];
                          v19->name[10] = v31;
                          if (v31)
                          {
                            v32 = a1[11];
                            v19->name[11] = v32;
                            if (v32)
                            {
                              v33 = a1[12];
                              v19->name[12] = v33;
                              if (v33)
                              {
                                v34 = a1[13];
                                v19->name[13] = v34;
                                if (v34)
                                {
                                  v35 = a1[14];
                                  v19->name[14] = v35;
                                  if (v35)
                                  {
                                    v36 = a1[15];
                                    v19->name[15] = v36;
                                    if (v36)
                                    {
                                      v37 = a1[16];
                                      v19->name[16] = v37;
                                      if (v37)
                                      {
                                        v38 = a1[17];
                                        v19->name[17] = v38;
                                        if (v38)
                                        {
                                          v39 = a1[18];
                                          v19->name[18] = v39;
                                          if (v39)
                                          {
                                            v40 = a1[19];
                                            v19->name[19] = v40;
                                            if (v40)
                                            {
                                              v41 = a1[20];
                                              v19->name[20] = v41;
                                              if (v41)
                                              {
                                                v42 = a1[21];
                                                v19->name[21] = v42;
                                                if (v42)
                                                {
                                                  v43 = a1[22];
                                                  v19->name[22] = v43;
                                                  if (v43)
                                                  {
                                                    v44 = a1[23];
                                                    v19->name[23] = v44;
                                                    if (v44)
                                                      v19->name[24] = 0;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v19->index = a2;
      v19->type = a3;
      v19->subtype = a4;
      v19->delegate_index = a6;
      v19->generation = a5;
      if (a8)
        v45 = 2;
      else
        v45 = 0;
      v46 = v45 | a7 | *(_WORD *)((char *)&v19->details + 73) & 0xFFFC;
      *(_WORD *)((char *)&v19->details + 73) = v46;
      v19->details.mtu = a9;
      if (a10)
      {
        v46 |= 0x80u;
        *(_WORD *)((char *)&v19->details + 73) = v46;
        v19->details.ipv4_netmask = a10;
      }
      if (a11)
      {
        *(_WORD *)((char *)&v19->details + 73) = v46 | 0x100;
        v19->details.ipv4_broadcast = a11;
      }
      v47 = v19;
    }

    return v20;
  }
  __nwlog_obj();
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v60 = "nw_interface_create_static";
  v50 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v57 = 0;
  if (__nwlog_fault(v50, &type, &v57))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v51 = objc_claimAutoreleasedReturnValue();
      v52 = type;
      if (os_log_type_enabled(v51, type))
      {
        *(_DWORD *)buf = 136446210;
        v60 = "nw_interface_create_static";
        _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s called with null name", buf, 0xCu);
      }
    }
    else if (v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v51 = objc_claimAutoreleasedReturnValue();
      v54 = type;
      v55 = os_log_type_enabled(v51, type);
      if (backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          v60 = "nw_interface_create_static";
          v61 = 2082;
          v62 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v51, v54, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_54;
      }
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        v60 = "nw_interface_create_static";
        _os_log_impl(&dword_182FBE000, v51, v54, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v51 = objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v51, type))
      {
        *(_DWORD *)buf = 136446210;
        v60 = "nw_interface_create_static";
        _os_log_impl(&dword_182FBE000, v51, v56, "%{public}s called with null name, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_54:
  if (v50)
    free(v50);
  return 0;
}

uint64_t nw_interface_get_generation(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[23];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_get_generation";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_generation";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_get_generation";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_generation";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_generation";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_get_mtu(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[15];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_get_mtu";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_mtu";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_get_mtu";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_mtu";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_mtu";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_get_ipv6_network_signature(void *a1, void *a2, _BYTE *a3)
{
  unsigned __int8 *v5;
  void *v6;
  id v7;
  int v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  int v12;
  size_t v13;
  uint64_t v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  int v18;
  os_log_type_t v19;
  int v20;
  int v21;
  void *v23;
  NSObject *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  void *v28;
  os_log_type_t v29;
  char *backtrace_string;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  os_log_type_t v38;
  os_log_type_t v39;
  char v40;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  _WORD v45[17];

  *(_QWORD *)&v45[13] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_interface_get_ipv6_network_signature";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null interface", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v40)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v37, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v31 = type;
    v32 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_interface_get_ipv6_network_signature";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (!a2)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_interface_get_ipv6_network_signature";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s called with null signature", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v40)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v38, "%{public}s called with null signature, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v33 = type;
    v34 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_interface_get_ipv6_network_signature";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null signature, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (!a3)
  {
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_interface_get_ipv6_network_signature";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s called with null signature_len", buf, 0xCu);
      }
LABEL_74:

      goto LABEL_23;
    }
    if (!v40)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v39, "%{public}s called with null signature_len, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v35 = type;
    v36 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv6_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_interface_get_ipv6_network_signature";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s called with null signature_len, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_56:

    free(backtrace_string);
    goto LABEL_23;
  }
  if (*a3 <= 0x13u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = *a3;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_interface_get_ipv6_network_signature";
    v44 = 1024;
    *(_DWORD *)v45 = v8;
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v9, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          v12 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv6_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v12;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s signature length %u is less than IFNET_SIGNATURELEN", buf, 0x12u);
        }
      }
      else if (v40)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v16 = type;
        v17 = os_log_type_enabled(v10, type);
        if (v15)
        {
          if (v17)
          {
            v18 = *a3;
            *(_DWORD *)buf = 136446722;
            v43 = "nw_interface_get_ipv6_network_signature";
            v44 = 1024;
            *(_DWORD *)v45 = v18;
            v45[2] = 2082;
            *(_QWORD *)&v45[3] = v15;
            _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v15);
          if (!v9)
            goto LABEL_25;
          goto LABEL_24;
        }
        if (v17)
        {
          v21 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv6_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v21;
          _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          v20 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv6_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v20;
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
LABEL_23:
    if (!v9)
    {
LABEL_25:
      v14 = 0;
      goto LABEL_26;
    }
LABEL_24:
    free(v9);
    goto LABEL_25;
  }
  v13 = v5[56];
  *a3 = v13;
  memcpy(a2, v5 + 36, v13);
  v14 = 1;
LABEL_26:

  return v14;
}

uint64_t nw_interface_get_ipv4_netmask(void *a1, BOOL *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_interface_get_ipv4_netmask";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_interface_get_ipv4_netmask";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null interface", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_interface_get_ipv4_netmask";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_interface_get_ipv4_netmask";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_interface_get_ipv4_netmask";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_24:
    if (v8)
      free(v8);
    goto LABEL_5;
  }
  if (a2)
    *a2 = (*(_WORD *)((_BYTE *)v3 + 85) & 0x80) != 0;
  if ((*(_WORD *)((_BYTE *)v3 + 85) & 0x80) != 0)
  {
    v5 = *((unsigned int *)v3 + 18);
    goto LABEL_7;
  }
LABEL_5:
  v5 = 0;
LABEL_7:

  return v5;
}

nw_endpoint_t nw_interface_copy_ipv4_netmask_endpoint(void *a1)
{
  id v1;
  void *v2;
  nw_endpoint_t v3;
  int v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  _BYTE address[22];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_netmask_endpoint";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_netmask_endpoint";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null interface", address, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)address = 136446466;
            *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_netmask_endpoint";
            *(_WORD *)&address[12] = 2082;
            *(_QWORD *)&address[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null interface, dumping backtrace:%{public}s", address, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v12)
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_netmask_endpoint";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null interface, no backtrace", address, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_netmask_endpoint";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null interface, backtrace limit exceeded", address, 0xCu);
        }
      }

    }
LABEL_22:
    if (v7)
      free(v7);
    goto LABEL_3;
  }
  if ((*(_WORD *)((_BYTE *)v1 + 85) & 0x80) != 0)
  {
    v4 = *((_DWORD *)v1 + 18);
    *(_DWORD *)address = 528;
    *(_DWORD *)&address[4] = v4;
    *(_QWORD *)&address[8] = 0;
    v3 = nw_endpoint_create_address((const sockaddr *)address);
    goto LABEL_5;
  }
LABEL_3:
  v3 = 0;
LABEL_5:

  return v3;
}

void sub_183B77AFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_interface_get_ipv4_broadcast(void *a1, _BYTE *a2)
{
  unsigned int *v3;
  void *v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_interface_get_ipv4_broadcast";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_interface_get_ipv4_broadcast";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null interface", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_interface_get_ipv4_broadcast";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_interface_get_ipv4_broadcast";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_interface_get_ipv4_broadcast";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_24:
    if (v8)
      free(v8);
    goto LABEL_5;
  }
  if (a2)
    *a2 = *((_BYTE *)v3 + 86) & 1;
  if ((*(_WORD *)((_BYTE *)v3 + 85) & 0x100) != 0)
  {
    v5 = v3[19];
    goto LABEL_7;
  }
LABEL_5:
  v5 = 0;
LABEL_7:

  return v5;
}

nw_endpoint_t nw_interface_copy_ipv4_broadcast_endpoint(void *a1)
{
  id v1;
  void *v2;
  nw_endpoint_t v3;
  int v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  _BYTE address[22];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_broadcast_endpoint";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_broadcast_endpoint";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null interface", address, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)address = 136446466;
            *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_broadcast_endpoint";
            *(_WORD *)&address[12] = 2082;
            *(_QWORD *)&address[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null interface, dumping backtrace:%{public}s", address, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v12)
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_broadcast_endpoint";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null interface, no backtrace", address, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_interface_copy_ipv4_broadcast_endpoint";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null interface, backtrace limit exceeded", address, 0xCu);
        }
      }

    }
LABEL_22:
    if (v7)
      free(v7);
    goto LABEL_3;
  }
  if ((*(_WORD *)((_BYTE *)v1 + 85) & 0x100) != 0)
  {
    v4 = *((_DWORD *)v1 + 19);
    *(_DWORD *)address = 528;
    *(_DWORD *)&address[4] = v4;
    *(_QWORD *)&address[8] = 0;
    v3 = nw_endpoint_create_address((const sockaddr *)address);
    goto LABEL_5;
  }
LABEL_3:
  v3 = 0;
LABEL_5:

  return v3;
}

void sub_183B7807C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_interface_copy_delegate_interface(void *a1)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  NWConcrete_nw_interface *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_interface_copy_delegate_interface";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_interface_copy_delegate_interface";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_interface_copy_delegate_interface";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_interface_copy_delegate_interface";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_interface_copy_delegate_interface";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = v1[22];
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = nw_interface_create_with_index(v3);
LABEL_23:

  return v4;
}

void sub_183B78330(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_interface_is_expensive(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(_WORD *)((_BYTE *)v1 + 85) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_is_expensive";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_expensive";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_is_expensive";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_expensive";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_expensive";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_is_constrained(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_is_constrained";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_constrained";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_is_constrained";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_constrained";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_constrained";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_is_ultra_constrained(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_is_ultra_constrained";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ultra_constrained";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_is_ultra_constrained";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ultra_constrained";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ultra_constrained";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_is_multilayer_packet_logging_enabled(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 6) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_is_multilayer_packet_logging_enabled";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_multilayer_packet_logging_enabled";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_is_multilayer_packet_logging_enabled";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_multilayer_packet_logging_enabled";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_multilayer_packet_logging_enabled";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_supports_multicast(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 9) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_supports_multicast";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_multicast";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_supports_multicast";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_multicast";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_multicast";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_has_dns(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 10) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_has_dns";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_has_dns";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_has_dns";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_has_dns";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_has_dns";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_has_nat64(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 11) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_has_nat64";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_has_nat64";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_has_nat64";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_has_nat64";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_has_nat64";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_is_ipv4_routable(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 12) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_is_ipv4_routable";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ipv4_routable";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_is_ipv4_routable";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ipv4_routable";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ipv4_routable";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_is_ipv6_routable(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 13) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_is_ipv6_routable";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ipv6_routable";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_is_ipv6_routable";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ipv6_routable";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_is_ipv6_routable";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_get_tso_max_segment_size_v4(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[16];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_get_tso_max_segment_size_v4";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_tso_max_segment_size_v4";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_get_tso_max_segment_size_v4";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_tso_max_segment_size_v4";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_tso_max_segment_size_v4";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_get_tso_max_segment_size_v6(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[17];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_get_tso_max_segment_size_v6";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_tso_max_segment_size_v6";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_get_tso_max_segment_size_v6";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_tso_max_segment_size_v6";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_tso_max_segment_size_v6";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_get_csum_flags(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[20];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_get_csum_flags";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_csum_flags";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_get_csum_flags";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_csum_flags";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_csum_flags";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

const char *nw_interface_type_get_description(unsigned int a1)
{
  if (a1 > 4)
    return "unknown";
  else
    return off_1E14AD0B0[a1];
}

const char *nw_interface_subtype_get_description(int a1)
{
  if (a1 <= 1001)
  {
    if (!a1)
      return "other";
    if (a1 == 1001)
      return "wifi_infrastructure";
  }
  else
  {
    switch(a1)
    {
      case 1002:
        return "wifi_awdl";
      case 4001:
        return "coprocessor";
      case 5001:
        return "companion";
    }
  }
  return "unknown";
}

nw_endpoint_t nw_interface_copy_local_address_for_remote_address(void *a1, void *a2)
{
  _DWORD *v3;
  id v4;
  void *v5;
  NSObject *v6;
  int v7;
  const sockaddr *address;
  size_t sa_len;
  id v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  nw_endpoint_t v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  void *v23;
  NSObject *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  void *v28;
  os_log_type_t v29;
  char *backtrace_string;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  os_log_type_t v38;
  os_log_type_t v39;
  char v40;
  os_log_type_t type;
  int v42;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  char *v48;
  sockaddr __dst[8];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
    v15 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (!__nwlog_fault(v15, buf, &v42))
      goto LABEL_32;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v25 = buf[0];
      if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null interface", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    if (!(_BYTE)v42)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v37 = buf[0];
      if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v37, "%{public}s called with null interface, backtrace limit exceeded", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v31 = buf[0];
    v32 = os_log_type_enabled(v24, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s called with null interface, no backtrace", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    if (v32)
    {
      *(_DWORD *)&__dst[0].sa_len = 136446466;
      *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
      *(_WORD *)&__dst[0].sa_data[10] = 2082;
      *(_QWORD *)&__dst[0].sa_data[12] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s called with null interface, dumping backtrace:%{public}s", &__dst[0].sa_len, 0x16u);
    }
    goto LABEL_65;
  }
  if (!v4)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
    v15 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (!__nwlog_fault(v15, buf, &v42))
      goto LABEL_32;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v27 = buf[0];
      if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s called with null remote_endpoint", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    if (!(_BYTE)v42)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v38 = buf[0];
      if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v38, "%{public}s called with null remote_endpoint, backtrace limit exceeded", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v33 = buf[0];
    v34 = os_log_type_enabled(v24, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null remote_endpoint, no backtrace", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    if (v34)
    {
      *(_DWORD *)&__dst[0].sa_len = 136446466;
      *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
      *(_WORD *)&__dst[0].sa_data[10] = 2082;
      *(_QWORD *)&__dst[0].sa_data[12] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s", &__dst[0].sa_len, 0x16u);
    }
    goto LABEL_65;
  }
  v6 = v4;
  v7 = -[NSObject type](v6, "type");

  if (v7 != 1)
  {
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
    v15 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (!__nwlog_fault(v15, buf, &v42))
      goto LABEL_32;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v29 = buf[0];
      if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address)", &__dst[0].sa_len, 0xCu);
      }
LABEL_83:

      goto LABEL_32;
    }
    if (!(_BYTE)v42)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v39 = buf[0];
      if (os_log_type_enabled(v24, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v39, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address), backtrace limit exceeded", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v35 = buf[0];
    v36 = os_log_type_enabled(v24, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)&__dst[0].sa_len = 136446210;
        *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
        _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address), no backtrace", &__dst[0].sa_len, 0xCu);
      }
      goto LABEL_83;
    }
    if (v36)
    {
      *(_DWORD *)&__dst[0].sa_len = 136446466;
      *(_QWORD *)&__dst[0].sa_data[2] = "nw_interface_copy_local_address_for_remote_address";
      *(_WORD *)&__dst[0].sa_data[10] = 2082;
      *(_QWORD *)&__dst[0].sa_data[12] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s called with null (nw_endpoint_get_type(remote_endpoint) == nw_endpoint_type_address), dumping backtrace:%{public}s", &__dst[0].sa_len, 0x16u);
    }
LABEL_65:

    free(backtrace_string);
    goto LABEL_32;
  }
  v42 = v3[2];
  memset(__dst, 0, sizeof(__dst));
  address = nw_endpoint_get_address(v6);
  if (address)
  {
    sa_len = address->sa_len;
    if ((((_DWORD)sa_len - 1) & 0x80) == 0)
      memcpy(__dst, address, sa_len);
  }
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  v10 = (id)nw_context_copy_implicit_context::implicit_context;
  nw_path_shared_necp_fd(v10);

  if (necp_client_action())
  {
    v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v13 = v12;
    if (v11 == 2)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_interface_copy_local_address_for_remote_address";
        v45 = 1024;
        v46 = 2;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446466;
    v44 = "nw_interface_copy_local_address_for_remote_address";
    v45 = 1024;
    v46 = v11;
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v15, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_interface_copy_local_address_for_remote_address";
          v45 = 1024;
          v46 = v11;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (v40)
      {
        v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        v19 = type;
        v20 = os_log_type_enabled(v16, type);
        if (v18)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446722;
            v44 = "nw_interface_copy_local_address_for_remote_address";
            v45 = 1024;
            v46 = v11;
            v47 = 2082;
            v48 = v18;
            _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v18);
          if (!v15)
            goto LABEL_34;
          goto LABEL_33;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_interface_copy_local_address_for_remote_address";
          v45 = 1024;
          v46 = v11;
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_interface_copy_local_address_for_remote_address";
          v45 = 1024;
          v46 = v11;
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
LABEL_32:
    if (!v15)
    {
LABEL_34:
      v14 = 0;
      goto LABEL_35;
    }
LABEL_33:
    free(v15);
    goto LABEL_34;
  }
  v14 = nw_endpoint_create_address(__dst);
LABEL_35:

  return v14;
}

void sub_183B7AD60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_interface_get_loopback_index()
{
  if (nw_interface_get_loopback_index::onceToken[0] != -1)
    dispatch_once(nw_interface_get_loopback_index::onceToken, &__block_literal_global_87884);
  return nw_interface_get_loopback_index::index;
}

const char *nw_interface_radio_type_to_string(int a1)
{
  int v1;
  const char *result;

  v1 = a1 - 1;
  result = "802.11b";
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = "802.11a";
      break;
    case 2:
      result = "802.11g";
      break;
    case 3:
      result = "802.11n";
      break;
    case 4:
      result = "802.11ac";
      break;
    case 5:
      result = "802.11ax";
      break;
    case 127:
      result = "lte";
      break;
    case 128:
      result = "endc_sub6";
      break;
    case 129:
      result = "endc_mmw";
      break;
    case 130:
      result = "nr_sa_sub6";
      break;
    case 131:
      result = "nr_sa_mmw";
      break;
    case 132:
      result = "wcdma";
      break;
    case 133:
      result = "gsm";
      break;
    case 134:
      result = "cdma";
      break;
    case 135:
      result = "evdo";
      break;
    default:
      result = "";
      break;
  }
  return result;
}

uint64_t nw_interface_radio_type_from_string(const char *a1)
{
  if (!strncasecmp(a1, "802.11b", 8uLL))
    return 1;
  if (!strncasecmp(a1, "802.11a", 8uLL))
    return 2;
  if (!strncasecmp(a1, "802.11g", 8uLL))
    return 3;
  if (!strncasecmp(a1, "802.11n", 8uLL))
    return 4;
  if (!strncasecmp(a1, "802.11ac", 9uLL))
    return 5;
  if (!strncasecmp(a1, "802.11ax", 9uLL))
    return 6;
  if (!strncasecmp(a1, "lte", 4uLL))
    return 128;
  if (!strncasecmp(a1, "endc_sub6", 0xAuLL))
    return 129;
  if (!strncasecmp(a1, "endc_mmw", 9uLL))
    return 130;
  if (!strncasecmp(a1, "nr_sa_sub6", 0xBuLL))
    return 131;
  if (!strncasecmp(a1, "nr_sa_mmw", 0xAuLL))
    return 132;
  if (!strncasecmp(a1, "wcdma", 6uLL))
    return 133;
  if (!strncasecmp(a1, "gsm", 4uLL))
    return 134;
  if (!strncasecmp(a1, "cdma", 5uLL))
    return 135;
  if (!strncasecmp(a1, "evdo", 5uLL))
    return 136;
  return 0;
}

void nw_interface_option_details_set_interface(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 1, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_set_interface";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_interface";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_set_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_interface";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_interface";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_interface_option_details_set_nexus_agent(void *a1, _OWORD *a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_interface_option_details_set_nexus_agent";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_interface_option_details_set_nexus_agent";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null details", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_interface_option_details_set_nexus_agent";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_interface_option_details_set_nexus_agent";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_interface_option_details_set_nexus_agent";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    *((_OWORD *)v3 + 2) = *a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_interface_option_details_set_nexus_agent";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_interface_option_details_set_nexus_agent";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nexus_agent", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_interface_option_details_set_nexus_agent";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null nexus_agent, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_interface_option_details_set_nexus_agent";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null nexus_agent, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_interface_option_details_set_nexus_agent";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null nexus_agent, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

uint64_t nw_interface_option_details_get_priority(void *a1)
{
  id v1;
  void *v2;
  char v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 48);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_get_priority";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_get_priority";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_get_priority";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_get_priority";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_get_priority";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_interface_option_details_copy_local_cid(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[7];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_copy_local_cid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_local_cid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_copy_local_cid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_local_cid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_local_cid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_interface_option_details_set_local_cid(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 7, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_set_local_cid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_local_cid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_set_local_cid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_local_cid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_local_cid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

id nw_interface_option_details_copy_remote_cid(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[8];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_copy_remote_cid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_remote_cid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_copy_remote_cid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_remote_cid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_remote_cid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_interface_option_details_set_remote_cid(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 8, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_set_remote_cid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_remote_cid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_set_remote_cid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_remote_cid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_remote_cid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

id nw_interface_option_details_copy_initial_data(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[9];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_copy_initial_data";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_initial_data";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_copy_initial_data";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_initial_data";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_initial_data";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_option_details_get_sockfd(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[20];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_get_sockfd";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_get_sockfd";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_get_sockfd";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_get_sockfd";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_get_sockfd";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0xFFFFFFFFLL;
LABEL_3:

  return v3;
}

id nw_interface_option_details_copy_evaluator(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_copy_evaluator";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_evaluator";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_copy_evaluator";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_evaluator";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_evaluator";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_interface_option_details_set_evaluator(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 2, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_set_evaluator";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_evaluator";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_set_evaluator";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_evaluator";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_set_evaluator";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_settings_setup_atfork()
{
  return pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
}

void nw_settings_child_has_forked(void)
{
  uint64_t v0;
  id v1;
  _BOOL8 globals_for_path;
  pthread_mutexattr_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  sNWIsBetweenForkAndExec = 1;
  gHasForked = 1;
  gLogLock = 0;
  v0 = MEMORY[0x1E0C81028];
  gLogObj = MEMORY[0x1E0C81028];
  gactivityLogObj = MEMORY[0x1E0C81028];
  gbrowserLogObj = MEMORY[0x1E0C81028];
  gcandidate_managerLogObj = MEMORY[0x1E0C81028];
  gconnectionLogObj = MEMORY[0x1E0C81028];
  gconnection_groupLogObj = MEMORY[0x1E0C81028];
  ghttpLogObj = MEMORY[0x1E0C81028];
  glistenerLogObj = MEMORY[0x1E0C81028];
  gmetricsLogObj = MEMORY[0x1E0C81028];
  gpathLogObj = MEMORY[0x1E0C81028];
  gtcpLogObj = MEMORY[0x1E0C81028];
  gprivacy_proxyLogObj = MEMORY[0x1E0C81028];
  gnetwork_testLogObj = MEMORY[0x1E0C81028];
  gmetricstreamLogObj = MEMORY[0x1E0C81028];
  gurlLogObj = MEMORY[0x1E0C81028];
  if (sNWDispatchAllowedNow == 1)
  {
    sNWDispatchAllowedNow = 0;
    sNWParentAllowedDispatch = 1;
  }
  pthread_mutexattr_init(&v3);
  pthread_mutexattr_settype(&v3, 2);
  pthread_mutex_init(&sSettingsMutex, &v3);
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  v1 = (id)nw_context_copy_implicit_context::implicit_context;
  globals_for_path = nw_context_get_globals_for_path(v1);

  nw_path_release_globals(globals_for_path, 1);
  cache_lock = 0;
  gMpklHasForked = 1;
  gMpklLogObj = v0;
  if (sCachedSettings)
  {
    xpc_release((xpc_object_t)sCachedSettings);
    sCachedSettings = 0;
  }
  sCachedHash = 0;
}

