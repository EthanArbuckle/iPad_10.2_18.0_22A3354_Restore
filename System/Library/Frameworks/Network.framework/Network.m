uint64_t __nwlog_is_datapath_logging_enabled()
{
  return gLogDatapath;
}

uint64_t nw_frame_array_first(uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *nw_frame_array_init(_QWORD *result)
{
  *result = 0;
  result[1] = result;
  return result;
}

BOOL nw_frame_array_is_empty(_QWORD *a1)
{
  return *a1 == 0;
}

void *__cdecl nw_retain(void *obj)
{
  if (obj)
    return os_retain(obj);
  return obj;
}

uint64_t nw_settings_get_signposts_enabled()
{
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_15_88146);
  return _nw_signposts_enabled;
}

uint64_t nw_context_2k_buffer_length()
{
  return dword_1EDCDF2B8;
}

uint64_t nw_frame_array_append(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;

  if (a2)
  {
    *(_QWORD *)(a3 + 32) = 0;
    v3 = a3 + 32;
  }
  else
  {
    *(_QWORD *)(a3 + 16) = 0;
    v3 = a3 + 16;
  }
  v4 = *(_QWORD **)(result + 8);
  *(_QWORD *)(v3 + 8) = v4;
  *v4 = a3;
  *(_QWORD *)(result + 8) = v3;
  return result;
}

void nw_endpoint_handler_start(void *a1)
{
  void **v1;
  void **v2;
  id v3;
  void **v4;
  void **v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  nw_endpoint_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  void **v16;
  os_unfair_lock_s *v17;
  const char *v18;
  os_unfair_lock_s *v19;
  id *v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  id v24;
  void **v25;
  void **v26;
  void *v27;
  _QWORD *v28;
  BOOL v29;
  NSObject *v30;
  void **v31;
  const char *v32;
  const char *v33;
  nw_endpoint_t v34;
  const char *v35;
  const char *v36;
  const char *v37;
  id v38;
  void *v39;
  void *v40;
  void *v41;
  id v42;
  void *v43;
  const char *v44;
  nw_endpoint_t v45;
  const char *v46;
  uint64_t v47;
  const char *v48;
  const char *v49;
  void **v50;
  os_unfair_lock_s *v51;
  int v52;
  const char *v53;
  os_unfair_lock_s *v54;
  void **v55;
  id *v56;
  id v57;
  void *v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  const char *id_string;
  const char *v63;
  nw_endpoint_t v64;
  void **v65;
  const char *logging_description;
  const char *v67;
  const char *v68;
  id v69;
  char *backtrace_string;
  os_log_type_t v71;
  _BOOL4 v72;
  os_log_type_t v73;
  const char *v74;
  const char *v75;
  void **v76;
  char v77;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE *v82;
  __int16 v83;
  const char *v84;
  __int16 v85;
  const char *v86;
  __int16 v87;
  const char *v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  id v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_endpoint_handler_start";
    v59 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (__nwlog_fault(v59, &type, &v77))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "nw_endpoint_handler_start";
          _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v77)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v71 = type;
        v72 = os_log_type_enabled(v60, type);
        if (backtrace_string)
        {
          if (v72)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "nw_endpoint_handler_start";
            v81 = 2082;
            v82 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v60, v71, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_86;
        }
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "nw_endpoint_handler_start";
          _os_log_impl(&dword_182FBE000, v60, v71, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v73 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "nw_endpoint_handler_start";
          _os_log_impl(&dword_182FBE000, v60, v73, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_86:
    if (v59)
      free(v59);
    goto LABEL_64;
  }
  v3 = nw_parameters_copy_context(v1[4]);
  nw_context_assert_queue(v3);

  v4 = v2;
  v5 = v4;
  v6 = v2[4];
  if (!v6)
  {

    if ((*((_BYTE *)v5 + 268) & 0x20) != 0)
      goto LABEL_25;
    goto LABEL_7;
  }
  v7 = v6;
  v8 = v7[12];

  if ((v8 & 0x4000000000) != 0)
  {
    if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
      goto LABEL_25;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(v5);
      v63 = nw_endpoint_handler_dry_run_string(v5);
      v64 = nw_endpoint_handler_copy_endpoint(v5);
      v65 = v2;
      logging_description = nw_endpoint_get_logging_description(v64);
      v67 = nw_endpoint_handler_state_string(v5);
      v68 = nw_endpoint_handler_mode_string(v5);
      v69 = nw_endpoint_handler_copy_current_path(v5);
      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      v81 = 2082;
      v82 = id_string;
      v83 = 2082;
      v84 = v63;
      v85 = 2082;
      v86 = logging_description;
      v87 = 2082;
      v88 = v67;
      v89 = 2082;
      v90 = v68;
      v91 = 2114;
      v92 = v69;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x48u);

      v2 = v65;
    }
LABEL_24:

    goto LABEL_25;
  }
  if ((*((_BYTE *)v5 + 268) & 0x20) == 0)
  {
LABEL_7:
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      if ((*((_BYTE *)v5 + 268) & 1) != 0)
        v10 = "dry-run ";
      else
        v10 = "";
      v11 = nw_endpoint_handler_copy_endpoint(v5);
      v12 = nw_endpoint_get_logging_description(v11);
      v13 = *((unsigned int *)v5 + 30);
      v14 = v12;
      if (v13 > 5)
        v15 = "unknown-state";
      else
        v15 = off_1E149FC48[v13];
      v74 = v15;
      v16 = v5;
      v17 = (os_unfair_lock_s *)v16;
      v76 = v2;
      v18 = "path";
      switch(*((_DWORD *)v16 + 29))
      {
        case 0:
          break;
        case 1:
          v18 = "resolver";
          break;
        case 2:
          v18 = nw_endpoint_flow_mode_string(v16[31]);
          break;
        case 3:
          v18 = "proxy";
          break;
        case 4:
          v18 = "fallback";
          break;
        case 5:
          v18 = "transform";
          break;
        default:
          v18 = "unknown-mode";
          break;
      }

      v19 = v17 + 28;
      v20 = v17;
      os_unfair_lock_lock(v17 + 28);
      v21 = v20[8];
      os_unfair_lock_unlock(v19);

      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      v81 = 2082;
      v82 = v5 + 21;
      v83 = 2082;
      v84 = v10;
      v85 = 2082;
      v86 = v14;
      v87 = 2082;
      v88 = v74;
      v89 = 2082;
      v90 = v18;
      v91 = 2114;
      v92 = v21;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x48u);

      v2 = v76;
    }
    goto LABEL_24;
  }
LABEL_25:
  if (*((_DWORD *)v5 + 29) == 2 && nw_endpoint_flow_should_not_use_path(v5[31]))
  {
    *((_DWORD *)v5 + 30) = 1;
    v22 = mach_continuous_time();
    if (v22 <= 1)
      v23 = 1;
    else
      v23 = v22;
    v5[16] = (void *)v23;
    v24 = v5[31];
    objc_msgSend(v24, "startWithHandler:", v5);

    goto LABEL_64;
  }
  *((_DWORD *)v5 + 20) = 65537;
  nw_endpoint_handler_report(v5, 0, (_WORD *)v5 + 40, 0);
  if (*((_DWORD *)v5 + 30))
  {
    v25 = v5;
    v26 = v25;
    v27 = v2[4];
    if (v27)
    {
      v28 = v27;
      v29 = (v28[12] & 0x4000000000) == 0;

      if (!v29)
      {
        if ((nw_endpoint_handler_get_logging_disabled(v26) & 1) != 0)
          goto LABEL_64;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v30 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v31 = v2;
          v32 = nw_endpoint_handler_get_id_string(v26);
          v33 = nw_endpoint_handler_dry_run_string(v26);
          v34 = nw_endpoint_handler_copy_endpoint(v26);
          v35 = nw_endpoint_get_logging_description(v34);
          v36 = nw_endpoint_handler_state_string(v26);
          v37 = nw_endpoint_handler_mode_string(v26);
          v38 = nw_endpoint_handler_copy_current_path(v26);
          *(_DWORD *)buf = 136447746;
          v80 = "nw_endpoint_handler_start";
          v81 = 2082;
          v82 = v32;
          v83 = 2082;
          v84 = v33;
          v85 = 2082;
          v86 = v35;
          v87 = 2082;
          v88 = v36;
          v89 = 2082;
          v90 = v37;
          v91 = 2114;
          v92 = v38;
          _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] state changed during initial report, not starting", buf, 0x48u);

          v2 = v31;
        }
LABEL_63:

        goto LABEL_64;
      }
    }
    else
    {

    }
    if ((*((_BYTE *)v26 + 268) & 0x20) != 0)
      goto LABEL_64;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v30 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      if ((*((_BYTE *)v26 + 268) & 1) != 0)
        v44 = "dry-run ";
      else
        v44 = "";
      v45 = nw_endpoint_handler_copy_endpoint(v26);
      v46 = nw_endpoint_get_logging_description(v45);
      v47 = *((unsigned int *)v5 + 30);
      v48 = v46;
      if (v47 > 5)
        v49 = "unknown-state";
      else
        v49 = off_1E149FC48[v47];
      v75 = v49;
      v50 = v26;
      v51 = (os_unfair_lock_s *)v50;
      v52 = *((_DWORD *)v5 + 29);
      v53 = "path";
      switch(v52)
      {
        case 0:
          break;
        case 1:
          v53 = "resolver";
          break;
        case 2:
          v53 = nw_endpoint_flow_mode_string(v50[31]);
          break;
        case 3:
          v53 = "proxy";
          break;
        case 4:
          v53 = "fallback";
          break;
        case 5:
          v53 = "transform";
          break;
        default:
          v53 = "unknown-mode";
          break;
      }

      v54 = v51 + 28;
      v55 = v2;
      v56 = v51;
      os_unfair_lock_lock(v51 + 28);
      v57 = v56[8];
      os_unfair_lock_unlock(v54);

      v2 = v55;
      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      v81 = 2082;
      v82 = v26 + 21;
      v83 = 2082;
      v84 = v44;
      v85 = 2082;
      v86 = v48;
      v87 = 2082;
      v88 = v75;
      v89 = 2082;
      v90 = v53;
      v91 = 2114;
      v92 = v57;
      _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] state changed during initial report, not starting", buf, 0x48u);

    }
    goto LABEL_63;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 28);
  v39 = v5[8];
  v5[8] = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 28);
  v40 = v5[7];
  if (v40 && (*((_BYTE *)v5 + 268) & 4) == 0)
  {
    nw_association_unregister(v40, v5);
    v41 = v5[7];
    v5[7] = 0;

  }
  *((_DWORD *)v5 + 30) = 1;
  nw_endpoint_handler_initialize_association(v5);
  v42 = nw_association_copy_current_path(v5[7], v2[4]);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 28);
  v43 = v5[8];
  v5[8] = v42;

  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 28);
  *((_BYTE *)v5 + 268) &= ~4u;
  nw_endpoint_handler_path_change((NWConcrete_nw_endpoint_handler *)v5);
LABEL_64:

}

void sub_182FC14A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_handler_copy_endpoint(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  NSObject *v3;
  NSObject *v4;
  nw_endpoint_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_endpoint_handler_copy_endpoint";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_endpoint_handler_copy_endpoint";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_endpoint_handler_copy_endpoint";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_endpoint_handler_copy_endpoint";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_endpoint_handler_copy_endpoint";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v8)
      free(v8);
    v5 = 0;
    goto LABEL_9;
  }
  os_unfair_lock_lock(v1 + 28);
  if (v2[29]._os_unfair_lock_opaque != 2)
  {
    os_unfair_lock_unlock(v2 + 28);
LABEL_8:
    v5 = (nw_endpoint_t)*(id *)&v2[6]._os_unfair_lock_opaque;
    goto LABEL_9;
  }
  v3 = nw_endpoint_flow_copy_connected_path(*(void **)&v2[62]._os_unfair_lock_opaque);
  v4 = v3;
  if (v3)
    v5 = nw_path_copy_effective_remote_endpoint(v3);
  else
    v5 = 0;

  os_unfair_lock_unlock(v2 + 28);
  if (!v5)
    goto LABEL_8;
LABEL_9:

  return v5;
}

void sub_182FC1828(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_connected_path(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void *v3;
  void *v4;
  id v5;
  void *v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 220);
    if ((v2[8]._os_unfair_lock_opaque & 2) != 0 || (v2[8]._os_unfair_lock_opaque & 0x100) != 0)
    {
      v5 = *(id *)&v2[2]._os_unfair_lock_opaque;
    }
    else
    {
      v3 = *(void **)&v2[234]._os_unfair_lock_opaque;
      if (v3)
      {
        v4 = (void *)nw_endpoint_handler_copy_connected_path(v3);
        v5 = v4;
        if (v4)
        {
          v6 = *(void **)&v2[2]._os_unfair_lock_opaque;
          if (v6)
            nw_path_apply_override_interface_types_from_path(v4, v6);
        }
      }
      else
      {
        v5 = 0;
      }
    }
    os_unfair_lock_unlock(v2 + 220);
    goto LABEL_10;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_endpoint_flow_copy_connected_path";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_endpoint_flow_copy_connected_path";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_endpoint_flow_copy_connected_path";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_endpoint_flow_copy_connected_path";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_endpoint_flow_copy_connected_path";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_28:
  if (v9)
    free(v9);
  v5 = 0;
LABEL_10:

  return v5;
}

void sub_182FC1B30(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

const char *nw_endpoint_get_logging_description(void *a1)
{
  id v1;
  void *v2;
  id v3;
  os_unfair_lock_s *v4;
  _DWORD *v5;
  int v6;
  int v7;
  const char *v8;
  os_unfair_lock_s *v9;
  os_unfair_lock_s *v10;
  char *v11;
  _DWORD *v13;
  _QWORD v14[4];
  os_unfair_lock_s *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    v4 = (os_unfair_lock_s *)v3;
    if ((*((_BYTE *)v3 + 231) & 0x20) == 0)
    {
      v5 = *((id *)v3 + 1);
      if (!v5 || (v6 = v5[31], (v6 - 2) < 2))
      {
        if (nwlog_get_sensitive_redacted::onceToken != -1)
        {
          v13 = v5;
          dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
          v5 = v13;
        }
        v7 = nwlog_get_sensitive_redacted::sensitiveRedacted;

        if (!v7)
          goto LABEL_13;
LABEL_15:
        v17 = 0;
        v18 = (uint64_t)&v17;
        v19 = 0x2020000000;
        v20 = 0;
        v14[0] = MEMORY[0x1E0C809B0];
        v14[1] = 3221225472;
        v14[2] = __nw_endpoint_get_logging_description_block_invoke;
        v14[3] = &unk_1E14ACE40;
        v15 = v4;
        v16 = &v17;
        os_unfair_lock_lock(v4 + 45);
        __nw_endpoint_get_logging_description_block_invoke((uint64_t)v14);
        os_unfair_lock_unlock(v4 + 45);
        v8 = *(const char **)(v18 + 24);

        _Block_object_dispose(&v17, 8);
        goto LABEL_16;
      }
      if (v6 != 1)
      {

        goto LABEL_15;
      }

    }
LABEL_13:
    v9 = v4;
    v23 = 0;
    v24 = &v23;
    v25 = 0x2020000000;
    v26 = 0;
    v10 = v9 + 45;
    v17 = MEMORY[0x1E0C809B0];
    v18 = 3221225472;
    v19 = (uint64_t)__nw_endpoint_get_description_block_invoke;
    v20 = &unk_1E14ACE40;
    v11 = v9;
    v21 = v11;
    v22 = &v23;
    os_unfair_lock_lock(v10);
    __nw_endpoint_get_description_block_invoke((uint64_t)&v17);
    os_unfair_lock_unlock(v10);
    v8 = (const char *)v24[3];

    _Block_object_dispose(&v23, 8);
    goto LABEL_16;
  }
  v8 = "<NULL>";
LABEL_16:

  return v8;
}

_QWORD *__nw_endpoint_get_logging_description_block_invoke(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = *(_QWORD **)(a1 + 32);
  v3 = result[10];
  if (!v3)
  {
    result = (_QWORD *)objc_msgSend(result, "createDescription:", 1);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) = result;
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v3;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 231) |= 0x10u;
  return result;
}

NWConcrete_nw_protocol_options *nw_protocol_options_copy(void *a1)
{
  id v1;
  NWConcrete_nw_protocol_options *v2;
  id v3;
  id v4;
  NWConcrete_nw_protocol_options *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  OS_nw_array *proxy_next_hops;
  uint64_t (*v10)(void);
  void *v11;
  OS_xpc_object *v12;
  OS_xpc_object *legacy_parameters;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t receiver;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  char *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  char v31;
  objc_super v32;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = [NWConcrete_nw_protocol_options alloc];
  v3 = v1;
  v4 = v3;
  if (!v2)
    goto LABEL_12;
  if (!v3)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
    v16 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v32.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v16, &v32, &type))
    {
      if (LOBYTE(v32.receiver) == 17)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        receiver = (os_log_type_t)v32.receiver;
        if (os_log_type_enabled(v17, (os_log_type_t)v32.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_182FBE000, v17, receiver, "%{public}s called with null _options", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v24 = (os_log_type_t)v32.receiver;
        v25 = os_log_type_enabled(v17, (os_log_type_t)v32.receiver);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
            v36 = 2082;
            v37 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null _options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null _options, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v29 = (os_log_type_t)v32.receiver;
        if (os_log_type_enabled(v17, (os_log_type_t)v32.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_182FBE000, v17, v29, "%{public}s called with null _options, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_42:
    if (v16)
      free(v16);

    goto LABEL_50;
  }
  v32.receiver = v2;
  v32.super_class = (Class)NWConcrete_nw_protocol_options;
  v5 = (NWConcrete_nw_protocol_options *)objc_msgSendSuper2(&v32, sel_init);
  v2 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if ((__nwlog_fault(v20, &type, &v31) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v31)
      {
        v26 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        v28 = os_log_type_enabled(v21, type);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
            v36 = 2082;
            v37 = v26;
            _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v26);
          goto LABEL_48;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_182FBE000, v21, v30, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_48:
    if (v20)
      free(v20);
LABEL_50:
    v2 = 0;
    goto LABEL_12;
  }
  objc_storeStrong((id *)&v5->definition, *((id *)v4 + 1));
  objc_storeStrong((id *)&v2->proxy_endpoint, *((id *)v4 + 3));
  v6 = *((_QWORD *)v4 + 4);
  if (v6)
  {
    v7 = nw_array_create();
    if (v7 != v6)
    {
      v8 = v7;
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v7 + 16, *(void ***)(v6 + 16), *(void ***)(v6 + 24), (uint64_t)(*(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 16)) >> 3);
      v6 = v8;
    }
    proxy_next_hops = v2->proxy_next_hops;
    v2->proxy_next_hops = (OS_nw_array *)v6;

  }
  v2->override_stack_endpoint = *((_BYTE *)v4 + 152);
  v2->prohibit_joining = *((_BYTE *)v4 + 153);
  v10 = *(uint64_t (**)(void))(*((_QWORD *)v4 + 1) + 96);
  if (v10)
    v2->handle = (void *)v10();
  v11 = (void *)*((_QWORD *)v4 + 5);
  if (v11)
  {
    v12 = (OS_xpc_object *)xpc_copy(v11);
    legacy_parameters = v2->legacy_parameters;
    v2->legacy_parameters = v12;

  }
LABEL_12:

  return v2;
}

void sub_182FC2310(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_assert_queue(void *a1)
{
  dispatch_queue_t *v1;
  uint64_t v2;
  dispatch_queue_t *v3;
  void *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  uint64_t v11;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v3 = v1;
  if (v1)
  {
    if (((_BYTE)v1[17] & 8) == 0)
      dispatch_assert_queue_V2(v1[1]);
    goto LABEL_4;
  }
  __nwlog_obj(0, v2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_context_assert_queue";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  v6 = __nwlog_fault(v5, &type, &v15);
  if ((_DWORD)v6)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v6, v7);
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_context_assert_queue";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj(backtrace_string, v11);
      v8 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_context_assert_queue";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_context_assert_queue";
        _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v6, v7);
      v8 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_context_assert_queue";
        _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v5)
    free(v5);
LABEL_4:

}

void sub_182FC25CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_path_copy_effective_remote_endpoint(nw_path_t path)
{
  nw_path_t v1;
  id *p_isa;
  uint64_t isa;
  _QWORD *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = path;
  p_isa = (id *)&v1->isa;
  if (v1)
  {
    isa = (uint64_t)v1[9].isa;
    if (isa && *(_QWORD *)(isa + 24) != *(_QWORD *)(isa + 16))
    {
      nw_array_get_object_at_index(isa, 0);
      v4 = (_QWORD *)objc_claimAutoreleasedReturnValue();
      v5 = v4;
      if (v4)
      {
        v6 = (void *)v4[5];
        if (v6)
        {
          v7 = v6;

          goto LABEL_9;
        }
      }

    }
    v7 = p_isa[3];
    goto LABEL_9;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_path_copy_effective_remote_endpoint";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_path_copy_effective_remote_endpoint";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_26:
  if (v10)
    free(v10);
  v7 = 0;
LABEL_9:

  return v7;
}

uint64_t nw_array_get_object_at_index(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  unint64_t v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v3 = *(_QWORD *)(result + 16);
  if (a2 < (*(_QWORD *)(result + 24) - v3) >> 3)
    return *(_QWORD *)(v3 + 8 * a2);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v13 = "nw_array_get_object_at_index";
  v14 = 2048;
  v15 = a2;
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v13 = "nw_array_get_object_at_index";
        v14 = 2048;
        v15 = a2;
        v7 = "%{public}s array index out of range: %lu";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0x16u);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          v13 = "nw_array_get_object_at_index";
          v14 = 2048;
          v15 = a2;
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s array index out of range: %lu, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v13 = "nw_array_get_object_at_index";
        v14 = 2048;
        v15 = a2;
        v7 = "%{public}s array index out of range: %lu, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v13 = "nw_array_get_object_at_index";
        v14 = 2048;
        v15 = a2;
        v7 = "%{public}s array index out of range: %lu, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v4)
    free(v4);
  return 0;
}

uint64_t nw_endpoint_handler_copy_connected_path(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;
  NSObject *v4;
  const char *v5;
  void *v6;
  const char *logging_description;
  uint64_t os_unfair_lock_opaque;
  const char *v9;
  const char *v10;
  void **v11;
  void **v12;
  const char *v13;
  id *v14;
  id v15;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  const char *v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  id v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_endpoint_handler_copy_connected_path";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        v23 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_endpoint_handler_copy_connected_path";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_182FBE000, v19, v24, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_41:
    if (v18)
      free(v18);
    goto LABEL_23;
  }
  os_unfair_lock_lock(v1 + 28);
  if (v2[29]._os_unfair_lock_opaque != 2)
  {
    os_unfair_lock_unlock(v2 + 28);
    if ((v2[67]._os_unfair_lock_opaque & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((v2[67]._os_unfair_lock_opaque & 1) != 0)
          v5 = "dry-run ";
        else
          v5 = "";
        v6 = (void *)nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        os_unfair_lock_opaque = v2[30]._os_unfair_lock_opaque;
        v9 = logging_description;
        if (os_unfair_lock_opaque > 5)
          v10 = "unknown-state";
        else
          v10 = off_1E149FC48[os_unfair_lock_opaque];
        v25 = v10;
        v11 = v2;
        v12 = v11;
        v13 = "path";
        switch(v2[29]._os_unfair_lock_opaque)
        {
          case 0u:
            break;
          case 1u:
            v13 = "resolver";
            break;
          case 2u:
            v13 = nw_endpoint_flow_mode_string(v11[31]);
            break;
          case 3u:
            v13 = "proxy";
            break;
          case 4u:
            v13 = "fallback";
            break;
          case 5u:
            v13 = "transform";
            break;
          default:
            v13 = "unknown-mode";
            break;
        }

        v14 = v12;
        os_unfair_lock_lock(v2 + 28);
        v15 = v14[8];
        os_unfair_lock_unlock(v2 + 28);

        *(_DWORD *)buf = 136447746;
        v29 = "nw_endpoint_handler_copy_connected_path";
        v30 = 2082;
        v31 = (char *)&v2[42];
        v32 = 2082;
        v33 = v5;
        v34 = 2082;
        v35 = v9;
        v36 = 2082;
        v37 = v25;
        v38 = 2082;
        v39 = v13;
        v40 = 2114;
        v41 = v15;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is not flow", buf, 0x48u);

      }
    }
LABEL_23:
    v3 = 0;
    goto LABEL_24;
  }
  v3 = nw_endpoint_flow_copy_connected_path(*(_QWORD *)&v2[62]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2 + 28);
LABEL_24:

  return v3;
}

void sub_182FC3020(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

const char *nw_endpoint_get_description(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  const char *v3;
  _QWORD v5[4];
  os_unfair_lock_s *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2020000000;
    v11 = 0;
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = __nw_endpoint_get_description_block_invoke;
    v5[3] = &unk_1E14ACE40;
    v6 = v1;
    v7 = &v8;
    os_unfair_lock_lock(v2 + 45);
    __nw_endpoint_get_description_block_invoke((uint64_t)v5);
    os_unfair_lock_unlock(v2 + 45);
    v3 = (const char *)v9[3];

    _Block_object_dispose(&v8, 8);
  }
  else
  {
    v3 = "<NULL>";
  }

  return v3;
}

_QWORD *__nw_endpoint_get_description_block_invoke(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = *(_QWORD **)(a1 + 32);
  v3 = result[8];
  if (!v3)
  {
    result = (_QWORD *)objc_msgSend(result, "createDescription:", 0);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) = result;
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v3;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 231) |= 8u;
  return result;
}

void sub_182FC32B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL __nwlog_salted_hash(const void *a1, uint64_t a2, char *a3)
{
  CC_LONG v4;
  unsigned __int8 v6;
  int v7;
  char v8;
  char v9;
  char v10;
  unsigned __int8 v11;
  int v12;
  char v13;
  char v14;
  char v15;
  unsigned __int8 v16;
  int v17;
  char v18;
  char v19;
  char v20;
  unsigned __int8 v21;
  int v22;
  char v23;
  char v24;
  char v25;
  _BOOL8 result;
  NSObject *v27;
  void *v28;
  unsigned __int8 md;
  unsigned __int8 v30;
  unsigned __int8 v31;
  unsigned __int8 v32;
  CC_SHA256_CTX c;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = a2;
    if (a2)
    {
      if (__nwlog_salted_hash::onceToken != -1)
        dispatch_once(&__nwlog_salted_hash::onceToken, &__block_literal_global_67_44247);
      memset(&c, 0, sizeof(c));
      CC_SHA256_Init(&c);
      CC_SHA256_Update(&c, &__nwlog_salted_hash::salt, 0x40u);
      CC_SHA256_Update(&c, a1, v4);
      CC_SHA256_Final(&md, &c);
      v6 = md;
      v7 = md >> 4;
      v8 = v7 + 87;
      v9 = v7 | 0x30;
      if (md > 0x9Fu)
        v9 = v8;
      *a3 = v9;
      if ((v6 & 0xFu) <= 9)
        v10 = v6 & 0xF | 0x30;
      else
        v10 = (v6 & 0xF) + 87;
      a3[1] = v10;
      v11 = v30;
      v12 = v30 >> 4;
      v13 = v12 + 87;
      v14 = v12 | 0x30;
      if (v30 > 0x9Fu)
        v14 = v13;
      a3[2] = v14;
      if ((v11 & 0xFu) <= 9)
        v15 = v11 & 0xF | 0x30;
      else
        v15 = (v11 & 0xF) + 87;
      a3[3] = v15;
      v16 = v31;
      v17 = v31 >> 4;
      v18 = v17 + 87;
      v19 = v17 | 0x30;
      if (v31 > 0x9Fu)
        v19 = v18;
      a3[4] = v19;
      if ((v16 & 0xFu) <= 9)
        v20 = v16 & 0xF | 0x30;
      else
        v20 = (v16 & 0xF) + 87;
      a3[5] = v20;
      v21 = v32;
      v22 = v32 >> 4;
      v23 = v22 + 87;
      v24 = v22 | 0x30;
      if (v32 > 0x9Fu)
        v24 = v23;
      a3[6] = v24;
      if ((v21 & 0xFu) <= 9)
        v25 = v21 & 0xF | 0x30;
      else
        v25 = (v21 & 0xF) + 87;
      a3[7] = v25;
      a3[8] = 0;
      return (BOOL)a3;
    }
  }
  if (a3)
  {
LABEL_27:
    strcpy(a3, "<null>");
    return (BOOL)a3;
  }
  v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  c.count[0] = 136446210;
  *(_QWORD *)&c.count[1] = "_strict_strlcpy";
  v28 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

const char *__nwlog_salted_hostname_hash(const char *a1, char *a2)
{
  size_t v4;
  uint64_t v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = strlen(a1);
    v5 = v4;
    if (v4 >= 2 && a1[v4 - 1] == 46)
      v5 = v4 - 1;
    __nwlog_salted_hash(a1, v5, a2);
    return a2;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "__nwlog_salted_hostname_hash";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "__nwlog_salted_hostname_hash";
        v10 = "%{public}s called with null hostname";
LABEL_20:
        _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "__nwlog_salted_hostname_hash";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null hostname, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "__nwlog_salted_hostname_hash";
        v10 = "%{public}s called with null hostname, no backtrace";
        goto LABEL_20;
      }
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "__nwlog_salted_hostname_hash";
        v10 = "%{public}s called with null hostname, backtrace limit exceeded";
        goto LABEL_20;
      }
    }
  }
LABEL_21:
  if (v7)
    free(v7);
  return "???";
}

uint64_t nw_frame_array_next(int a1, _QWORD *a2)
{
  uint64_t result;

  if (a1)
  {
    result = a2[4];
    if (!result && !a2[5])
      return 0;
  }
  else
  {
    result = a2[2];
    if (!result && !a2[3])
      return 0;
  }
  return result;
}

uint64_t nw_frame_array_remove(uint64_t result, int a2, _QWORD *a3)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  if (!a2)
  {
    v4 = a3[2];
    v5 = (_QWORD *)a3[3];
    v3 = a3 + 2;
    if (v4)
    {
      *(_QWORD *)(v4 + 24) = v5;
      v5 = (_QWORD *)a3[3];
      goto LABEL_7;
    }
LABEL_6:
    *(_QWORD *)(result + 8) = v5;
    goto LABEL_7;
  }
  v4 = a3[4];
  v5 = (_QWORD *)a3[5];
  v3 = a3 + 4;
  if (!v4)
    goto LABEL_6;
  *(_QWORD *)(v4 + 40) = v5;
  v5 = (_QWORD *)a3[5];
LABEL_7:
  *v5 = v4;
  *v3 = 0;
  v3[1] = 0;
  return result;
}

uint64_t in_addword(int a1, int a2)
{
  unsigned int v2;

  v2 = ((a2 + a1) >> 16) + (unsigned __int16)(a2 + a1);
  return (unsigned __int16)(HIWORD(v2) + v2 + ((HIWORD(v2) + (unsigned __int16)v2) >> 16));
}

uint64_t nw_context_8k_buffer_length()
{
  return dword_1EDCDF300;
}

uint64_t in_pseudo(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3;

  v3 = a2 + (unint64_t)a1 + a3;
  LODWORD(v3) = ((WORD1(v3) + (unsigned __int16)v3 + HIDWORD(v3)) >> 16)
              + (unsigned __int16)(WORD1(v3) + v3 + WORD2(v3));
  return (unsigned __int16)(((WORD1(v3) + (unsigned __int16)v3) >> 16)
                          + WORD1(v3)
                          + v3
                          + ((((WORD1(v3) + (unsigned __int16)v3) >> 16)
                            + (unsigned __int16)(WORD1(v3) + v3)) >> 16));
}

uint64_t nw_frame_array_foreach(uint64_t result, char a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = *(_QWORD *)result;
  if ((a2 & 1) != 0)
  {
    do
    {
      if (!v5)
        break;
      v6 = *(_QWORD *)(v5 + 32);
      result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      v5 = v6;
    }
    while ((result & 1) != 0);
  }
  else
  {
    do
    {
      if (!v5)
        break;
      v7 = *(_QWORD *)(v5 + 16);
      result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      v5 = v7;
    }
    while ((result & 1) != 0);
  }
  return result;
}

ValueMetadata *type metadata accessor for NWError()
{
  return &type metadata for NWError;
}

uint64_t block_destroy_helper()
{
  return swift_release();
}

uint64_t block_destroy_helper_0()
{
  return swift_release();
}

uint64_t block_destroy_helper_1()
{
  return swift_release();
}

uint64_t block_destroy_helper_2()
{
  return swift_release();
}

uint64_t block_destroy_helper_3()
{
  return swift_release();
}

uint64_t block_destroy_helper_4()
{
  return swift_release();
}

uint64_t block_destroy_helper_5()
{
  return swift_release();
}

uint64_t block_destroy_helper_6()
{
  return swift_release();
}

uint64_t block_destroy_helper_7()
{
  return swift_release();
}

uint64_t block_destroy_helper_8()
{
  return swift_release();
}

uint64_t block_destroy_helper_9()
{
  return swift_release();
}

uint64_t block_destroy_helper_10()
{
  return swift_release();
}

uint64_t block_destroy_helper_11()
{
  return swift_release();
}

uint64_t block_destroy_helper_12()
{
  return swift_release();
}

uint64_t block_destroy_helper_13()
{
  return swift_release();
}

uint64_t block_destroy_helper_14()
{
  return swift_release();
}

uint64_t block_destroy_helper_15()
{
  return swift_release();
}

uint64_t block_destroy_helper_16()
{
  return swift_release();
}

uint64_t block_destroy_helper_17()
{
  return swift_release();
}

uint64_t block_destroy_helper_18()
{
  return swift_release();
}

void ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke(uint64_t a1)
{
  nw_socket_update_input_source(*(char **)(a1 + 32));
}

uint64_t nw_context_16k_buffer_length()
{
  return dword_1EDCDF348;
}

id nw_parameters_copy_required_netagent_domains(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_required_netagent_domains";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_domains";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_required_netagent_domains";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_domains";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_domains";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 56);
LABEL_23:

  return v4;
}

id nw_parameters_copy_required_netagent_uuids(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_required_netagent_uuids";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_required_netagent_uuids";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 72);
LABEL_23:

  return v4;
}

id nw_parameters_copy_required_netagent_types(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_required_netagent_types";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_types";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_required_netagent_types";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_types";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_required_netagent_types";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 64);
LABEL_23:

  return v4;
}

uint64_t nw_parameters_get_ip_protocol(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  id v5;
  BOOL v6;
  uint64_t protocol;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_parameters_get_ip_protocol";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_get_ip_protocol";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_parameters_get_ip_protocol";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_get_ip_protocol";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_get_ip_protocol";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_29:
    if (v9)
      free(v9);
    goto LABEL_31;
  }
  v3 = v1[19];
  if (!v3)
    goto LABEL_31;
  v4 = *(void **)(v3 + 24);
  if (!v4)
    goto LABEL_31;
  v5 = v4;
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
  v6 = nw_protocol_options_matches_definition(v5, (void *)g_tcp_definition);

  if (!v6)
  {
    if (nw_protocol_options_is_udp(*(void **)(v2[19] + 24))
      || nw_protocol_options_is_quic(*(nw_protocol_options_t *)(v2[19] + 24)))
    {
      protocol = 17;
      goto LABEL_32;
    }
    if (nw_protocol_options_is_custom_ip(*(void **)(v2[19] + 24)))
    {
      protocol = nw_custom_ip_options_get_protocol(*(void **)(v2[19] + 24));
      goto LABEL_32;
    }
LABEL_31:
    protocol = 0;
    goto LABEL_32;
  }
  protocol = 6;
LABEL_32:

  return protocol;
}

void sub_182FC454C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_matches_definition(void *a1, void *a2)
{
  uint64_t *v3;
  id v4;
  void *v5;
  _BOOL8 is_equal_unsafe;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      is_equal_unsafe = nw_protocol_definition_is_equal_unsafe(v3[1], (uint64_t)v4);
      goto LABEL_4;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_options_matches_definition";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null definition", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_options_matches_definition";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_options_matches_definition";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null options", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_options_matches_definition";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9)
    free(v9);
  is_equal_unsafe = 0;
LABEL_4:

  return is_equal_unsafe;
}

void sub_182FC4A20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_definition_is_equal_unsafe(uint64_t a1, uint64_t a2)
{
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  void *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  _BOOL4 v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_is_equal_unsafe";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v10, &type, &v19))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_is_equal_unsafe";
        v13 = "%{public}s called with null definition1";
LABEL_52:
        _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
      }
LABEL_53:

LABEL_54:
      if (v10)
        free(v10);
      return 0;
    }
    if (!v19)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_is_equal_unsafe";
        v13 = "%{public}s called with null definition1, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    v16 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_is_equal_unsafe";
        v13 = "%{public}s called with null definition1, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_definition_is_equal_unsafe";
      v23 = 2082;
      v24 = backtrace_string;
      v17 = "%{public}s called with null definition1, dumping backtrace:%{public}s";
LABEL_42:
      _os_log_impl(&dword_182FBE000, v11, v12, v17, buf, 0x16u);
    }
LABEL_43:

    free(backtrace_string);
    goto LABEL_54;
  }
  if (!a2)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_is_equal_unsafe";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v10, &type, &v19))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_is_equal_unsafe";
        v13 = "%{public}s called with null definition2";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v19)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_is_equal_unsafe";
        v13 = "%{public}s called with null definition2, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    v18 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_is_equal_unsafe";
        v13 = "%{public}s called with null definition2, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_definition_is_equal_unsafe";
      v23 = 2082;
      v24 = backtrace_string;
      v17 = "%{public}s called with null definition2, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  if ((*(_BYTE *)(a1 + 184) & 0x40) != 0 || (*(_BYTE *)(a2 + 184) & 0x40) != 0)
  {
    return a1 == a2;
  }
  else
  {
    if (a1 == a2)
      return 1;
    if (uuid_compare((const unsigned __int8 *)(a1 + 48), (const unsigned __int8 *)(a2 + 48)))
      return 0;
    return *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8)
        && *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16)
        && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24)
        && *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)
        && *(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 40);
  }
}

uint64_t nw_parameters_get_allow_socket_access(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 100) >> 4) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_allow_socket_access";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_allow_socket_access";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_allow_socket_access";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_allow_socket_access";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_allow_socket_access";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_get_multipath(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(_DWORD *)(*((_QWORD *)v1 + 13) + 103) != 0;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_multipath";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_multipath";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_multipath";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_multipath";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_multipath";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_required_interface_index(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_get_required_interface_index";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_get_required_interface_index";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 168);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(unsigned int *)(v3 + 8);
LABEL_23:

  return v4;
}

nw_interface_t nw_parameters_copy_required_interface(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = *((id *)v1[13].isa + 21);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_copy_required_interface";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_required_interface";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_copy_required_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_required_interface";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_required_interface";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

nw_interface_type_t nw_parameters_get_required_interface_type(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  nw_interface_type_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = *((_DWORD *)v1[13].isa + 19);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_required_interface_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_required_interface_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_required_interface_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_required_interface_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_required_interface_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = nw_interface_type_other;
LABEL_3:

  return v3;
}

BOOL nw_parameters_get_prohibit_expensive(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  __int16 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = *((_WORD *)v1[13].isa + 50) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_prohibit_expensive";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_expensive";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_prohibit_expensive";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_expensive";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_expensive";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_get_prohibit_constrained(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  _BOOL4 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = (*((unsigned __int16 *)v1[13].isa + 50) >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_prohibit_constrained";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_constrained";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_prohibit_constrained";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_constrained";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_constrained";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

id nw_parameters_copy_prohibited_netagent_uuids(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_prohibited_netagent_uuids";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_prohibited_netagent_uuids";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 48);
LABEL_23:

  return v4;
}

id nw_parameters_copy_prohibited_netagent_types(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_prohibited_netagent_types";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_types";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_prohibited_netagent_types";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_types";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_types";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 40);
LABEL_23:

  return v4;
}

id nw_parameters_copy_prohibited_netagent_domains(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_prohibited_netagent_domains";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_domains";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_prohibited_netagent_domains";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_domains";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_netagent_domains";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 32);
LABEL_23:

  return v4;
}

uint64_t nw_parameters_get_required_interface_subtype(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(unsigned int *)(*((_QWORD *)v1 + 13) + 80);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_required_interface_subtype";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_required_interface_subtype";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_required_interface_subtype";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_required_interface_subtype";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_required_interface_subtype";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_has_prohibited_interface_subtypes(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  _BOOL8 v5;
  _BYTE *v6;
  uint64_t v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_parameters_has_prohibited_interface_subtypes";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_parameters_has_prohibited_interface_subtypes";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_28:
    if (v9)
      free(v9);
    goto LABEL_30;
  }
  v3 = *(_QWORD *)(v1[13] + 176);
  if (!v3)
  {
LABEL_30:
    v5 = 0;
    goto LABEL_31;
  }
  v4 = *(void **)(v3 + 8);
  if (v4 && xpc_array_get_count(v4))
  {
    v5 = 1;
  }
  else
  {
    v6 = v2;
    v7 = v2[13];
    v5 = (*(_WORD *)(v7 + 108) & 8) == 0 && !*(_DWORD *)(v7 + 80) && !*(_QWORD *)(v7 + 168) && (v6[97] & 0x80) == 0;

  }
LABEL_31:

  return v5;
}

void sub_182FC6E64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_prohibited_interface_types(void *a1)
{
  id v1;
  void *v2;
  xpc_object_t *v3;
  _BOOL8 v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_has_prohibited_interface_types";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_has_prohibited_interface_types";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_21:
    if (v6)
      free(v6);
    goto LABEL_23;
  }
  v3 = *(xpc_object_t **)(*((_QWORD *)v1 + 13) + 176);
  if (!v3 || !*v3)
  {
LABEL_23:
    v4 = 0;
    goto LABEL_24;
  }
  v4 = xpc_array_get_count(*v3) != 0;
LABEL_24:

  return v4;
}

void sub_182FC7124(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_prohibit_roaming(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 100) >> 3) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_prohibit_roaming";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_prohibit_roaming";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_has_prohibited_interfaces(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v4;
  _BOOL8 v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_parameters_has_prohibited_interfaces";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_parameters_has_prohibited_interfaces";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_21:
    if (v7)
      free(v7);
    goto LABEL_23;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3 || (v4 = *(void **)(v3 + 24)) == 0)
  {
LABEL_23:
    v5 = 0;
    goto LABEL_24;
  }
  v5 = xpc_array_get_count(v4) != 0;
LABEL_24:

  return v5;
}

void sub_182FC7680(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t block_copy_helper(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_6(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_7(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_9(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_10(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_11(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_12(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_13(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_14(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_15(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_16(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_17(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_18(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  return swift_retain();
}

ValueMetadata *type metadata accessor for NWActivity.CompletionReason()
{
  return &type metadata for NWActivity.CompletionReason;
}

ValueMetadata *type metadata accessor for NWConnection.State()
{
  return &type metadata for NWConnection.State;
}

nw_endpoint_t nw_endpoint_create_address_with_ethernet(const sockaddr *a1, int *a2)
{
  nw_endpoint_t address;
  nw_endpoint_t v4;
  NSObject *v5;
  int v6;
  int v7;
  id v8;
  NSObject *v9;
  nw_endpoint_type_t v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  nw_endpoint_type_t v15;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  NSObject *v20;
  nw_endpoint_type_t v21;
  os_log_type_t v22;
  NSObject *v23;
  nw_endpoint_type_t v24;
  nw_endpoint_type_t v25;
  uint64_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  nw_endpoint_type_t v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  address = nw_endpoint_create_address(a1);
  v4 = address;
  if (a2 && address)
  {
    v5 = address;
    v6 = -[NSObject type](v5, "type");

    if (v6 == 1)
    {
      v7 = *a2;
      WORD2(v5[45].isa) = *((_WORD *)a2 + 2);
      LODWORD(v5[45].isa) = v7;
LABEL_12:

      return v4;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    v9 = v5;
    v10 = -[NSObject type](v9, "type");

    *(_DWORD *)buf = 136446466;
    v30 = "nw_endpoint_set_ethernet_address";
    v31 = 1024;
    v32 = v10;
    LODWORD(v26) = 18;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v11, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          v14 = v9;
          v15 = -[NSObject type](v14, "type", buf, v26);

          *(_DWORD *)buf = 136446466;
          v30 = "nw_endpoint_set_ethernet_address";
          v31 = 1024;
          v32 = v15;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v18 = type;
        v19 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v19)
          {
            v20 = v9;
            v21 = -[NSObject type](v20, "type", buf, v26);

            *(_DWORD *)buf = 136446722;
            v30 = "nw_endpoint_set_ethernet_address";
            v31 = 1024;
            v32 = v21;
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          if (!v11)
            goto LABEL_12;
          goto LABEL_11;
        }
        if (v19)
        {
          v25 = nw_endpoint_get_type(v9);
          *(_DWORD *)buf = 136446466;
          v30 = "nw_endpoint_set_ethernet_address";
          v31 = 1024;
          v32 = v25;
          _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          v23 = v9;
          v24 = -[NSObject type](v23, "type", buf, v26);

          *(_DWORD *)buf = 136446466;
          v30 = "nw_endpoint_set_ethernet_address";
          v31 = 1024;
          v32 = v24;
          _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
    if (!v11)
      goto LABEL_12;
LABEL_11:
    free(v11);
    goto LABEL_12;
  }
  return v4;
}

void sub_182FC7C4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_array_copy(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = nw_array_create();
  v3 = v2;
  if (a1)
  {
    if (v2 == a1)
      return a1;
    else
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v2 + 16, *(void ***)(a1 + 16), *(void ***)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3);
  }
  return v3;
}

BOOL nw_endpoint_copy_original_endpoint(void *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  NSObject *v8;
  void *v9;
  _BOOL8 result;
  _QWORD *v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_endpoint_copy_original_endpoint";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v23 = "nw_endpoint_copy_original_endpoint";
            v24 = 2082;
            v25 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_29:
    if (v13)
      free(v13);
    v11 = 0;
    goto LABEL_12;
  }
  v5 = (void *)nw_endpoint_copy_proxy_original_endpoint(v3);
  v6 = v5;
  if (v5)
    goto LABEL_3;
  if (objc_msgSend(v4, "type") == (_DWORD)a2 || (v5 = (void *)v4[14]) == 0)
  {
    v7 = v4;
    goto LABEL_11;
  }
  if (v5 != v4)
  {
LABEL_3:
    v7 = (_QWORD *)nw_endpoint_copy_original_endpoint(v5, a2);
LABEL_11:
    v11 = v7;

LABEL_12:
    return (BOOL)v11;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v23 = "nw_endpoint_copy_original_endpoint";
  v9 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v9);
  if (!result)
  {
    free(v9);
    v5 = (void *)v4[14];
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_182FC8094(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_endpoint_copy_proxy_original_endpoint(void *a1)
{
  _QWORD *v1;
  uint64_t v2;
  id v3;
  id v4;
  id v5;
  NSObject *v6;
  void *v7;
  _BOOL8 result;
  id v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v3 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_endpoint_copy_proxy_original_endpoint";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v21 = "nw_endpoint_copy_proxy_original_endpoint";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v11)
      free(v11);
    goto LABEL_28;
  }
  v4 = (id)v1[14];
  if (!v4)
  {
LABEL_28:
    v9 = 0;
    goto LABEL_29;
  }
  if (v4 != v3)
  {
    if ((*((_BYTE *)v3 + 231) & 2) == 0)
    {
LABEL_5:
      v5 = (id)nw_endpoint_copy_proxy_original_endpoint(v4, v2);
LABEL_9:
      v9 = v5;
LABEL_29:

      return (BOOL)v9;
    }
LABEL_8:
    v5 = v4;
    goto LABEL_9;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v21 = "nw_endpoint_copy_proxy_original_endpoint";
  v7 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    v4 = (id)*((_QWORD *)v3 + 14);
    if ((*((_BYTE *)v3 + 231) & 2) == 0)
      goto LABEL_5;
    goto LABEL_8;
  }
  __break(1u);
  return result;
}

void sub_182FC8428(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_context_endpoint_get_connected_flow_count(void *a1, void *a2)
{
  dispatch_queue_t *v3;
  id v4;
  void *v5;
  _BOOL8 v6;
  id v7;
  int v8;
  uint64_t *v9;
  uint64_t node;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  dispatch_queue_t *v15;
  dispatch_queue_t *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  void *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  char *v31;
  os_log_type_t v32;
  _BOOL4 v33;
  char *v34;
  os_log_type_t v35;
  _BOOL4 v36;
  char *v37;
  os_log_type_t v38;
  _BOOL4 v39;
  void *v40;
  void *v41;
  NSObject *v42;
  os_log_type_t v43;
  void *v44;
  os_log_type_t v45;
  char *backtrace_string;
  os_log_type_t v47;
  _BOOL4 v48;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  os_log_type_t v52;
  os_log_type_t v53;
  os_log_type_t v54;
  os_log_type_t v55;
  os_log_type_t type[8];
  os_log_type_t *v58;
  uint64_t v59;
  int v60;
  char v61;
  _BYTE buf[24];
  void *v63;
  os_log_type_t *v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      if (((_BYTE)v3[17] & 8) == 0)
        dispatch_assert_queue_V2(v3[1]);
      v6 = nw_context_copy_cache_context(v3);

      v7 = v5;
      v8 = objc_msgSend(v7, "type");

      if (v8 == 2)
      {
        v9 = (uint64_t *)(*(_QWORD *)(v6 + 24) + 40);
      }
      else if (v8 == 1)
      {
        v9 = (uint64_t *)(*(_QWORD *)(v6 + 24) + 32);
      }
      else
      {
        v9 = (uint64_t *)(*(_QWORD *)(v6 + 24) + 48);
      }
      if (*v9)
      {
        node = nw_hash_table_get_node(*v9, (uint64_t)v7, 0);
        if (node)
        {
          v11 = nw_hash_table_get_node(*(_QWORD *)(node + 16), (uint64_t)v7, 0);
          if (v11)
          {
            v12 = *(id *)(v11 + 16);
            v13 = v12;
            if (v12)
            {
              v14 = (void *)v12[1];
              if (v14)
              {
                v15 = v14;
                v16 = v15;
                if (((_BYTE)v15[17] & 8) == 0)
                  dispatch_assert_queue_V2(v15[1]);

                v17 = v13[25];
                if (v17 && *(_DWORD *)(v17 + 40))
                {
                  *(_QWORD *)type = 0;
                  v58 = type;
                  v60 = 0;
                  v59 = 0x2020000000;
                  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                  *(_QWORD *)&buf[8] = 3221225472;
                  *(_QWORD *)&buf[16] = __nw_endpoint_get_connected_flow_count_block_invoke;
                  v63 = &unk_1E149BA50;
                  v64 = type;
                  nw_hash_table_apply((char *)v17, (uint64_t)buf);
                  v18 = *((unsigned int *)v58 + 6);
                  _Block_object_dispose(type, 8);
LABEL_112:

                  goto LABEL_113;
                }
LABEL_111:
                v18 = 0;
                goto LABEL_112;
              }
              __nwlog_obj();
              v44 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
              v41 = (void *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              v61 = 0;
              if (!__nwlog_fault((const char *)v41, type, &v61))
              {
LABEL_109:
                if (v41)
                  free(v41);
                goto LABEL_111;
              }
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v42 = objc_claimAutoreleasedReturnValue();
                v45 = type[0];
                if (os_log_type_enabled(v42, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl(&dword_182FBE000, v42, v45, "%{public}s called with null endpoint->context", buf, 0xCu);
                }
LABEL_108:

                goto LABEL_109;
              }
              if (!v61)
              {
                __nwlog_obj();
                v42 = objc_claimAutoreleasedReturnValue();
                v55 = type[0];
                if (os_log_type_enabled(v42, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl(&dword_182FBE000, v42, v55, "%{public}s called with null endpoint->context, backtrace limit exceeded", buf, 0xCu);
                }
                goto LABEL_108;
              }
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v42 = objc_claimAutoreleasedReturnValue();
              v49 = type[0];
              v50 = os_log_type_enabled(v42, type[0]);
              if (!backtrace_string)
              {
                if (v50)
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl(&dword_182FBE000, v42, v49, "%{public}s called with null endpoint->context, no backtrace", buf, 0xCu);
                }
                goto LABEL_108;
              }
              if (v50)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = backtrace_string;
                _os_log_impl(&dword_182FBE000, v42, v49, "%{public}s called with null endpoint->context, dumping backtrace:%{public}s", buf, 0x16u);
              }
            }
            else
            {
              __nwlog_obj();
              v40 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
              v41 = (void *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              v61 = 0;
              if (!__nwlog_fault((const char *)v41, type, &v61))
                goto LABEL_109;
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v42 = objc_claimAutoreleasedReturnValue();
                v43 = type[0];
                if (os_log_type_enabled(v42, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s called with null endpoint", buf, 0xCu);
                }
                goto LABEL_108;
              }
              if (!v61)
              {
                __nwlog_obj();
                v42 = objc_claimAutoreleasedReturnValue();
                v54 = type[0];
                if (os_log_type_enabled(v42, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl(&dword_182FBE000, v42, v54, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
                }
                goto LABEL_108;
              }
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v42 = objc_claimAutoreleasedReturnValue();
              v47 = type[0];
              v48 = os_log_type_enabled(v42, type[0]);
              if (!backtrace_string)
              {
                if (v48)
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                  _os_log_impl(&dword_182FBE000, v42, v47, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
                }
                goto LABEL_108;
              }
              if (v48)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_endpoint_get_connected_flow_count";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = backtrace_string;
                _os_log_impl(&dword_182FBE000, v42, v47, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
              }
            }

            free(backtrace_string);
            goto LABEL_109;
          }
        }
LABEL_96:
        v18 = 0;
LABEL_113:
        v3 = (dispatch_queue_t *)v6;
        goto LABEL_114;
      }
      __nwlog_obj();
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
      v28 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (__nwlog_fault(v28, type, &v61))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v30 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
            _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null hash_table", buf, 0xCu);
          }
        }
        else if (v61)
        {
          v37 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v38 = type[0];
          v39 = os_log_type_enabled(v29, type[0]);
          if (v37)
          {
            if (v39)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v37;
              _os_log_impl(&dword_182FBE000, v29, v38, "%{public}s called with null hash_table, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v37);
            goto LABEL_94;
          }
          if (v39)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
            _os_log_impl(&dword_182FBE000, v29, v38, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v53 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
            _os_log_impl(&dword_182FBE000, v29, v53, "%{public}s called with null hash_table, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_94:
      if (v28)
        free(v28);
      goto LABEL_96;
    }
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
    v24 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (!__nwlog_fault(v24, type, &v61))
      goto LABEL_88;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
        _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v61)
    {
      v34 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v35 = type[0];
      v36 = os_log_type_enabled(v25, type[0]);
      if (v34)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v34;
          _os_log_impl(&dword_182FBE000, v25, v35, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v34);
        goto LABEL_88;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
        _os_log_impl(&dword_182FBE000, v25, v35, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v52 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
        _os_log_impl(&dword_182FBE000, v25, v52, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_88:
    if (v24)
      free(v24);
    v18 = 0;
    goto LABEL_114;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
  v20 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v61 = 0;
  if (__nwlog_fault(v20, type, &v61))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v61)
    {
      v31 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v32 = type[0];
      v33 = os_log_type_enabled(v21, type[0]);
      if (v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v31;
          _os_log_impl(&dword_182FBE000, v21, v32, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v31);
        goto LABEL_82;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
        _os_log_impl(&dword_182FBE000, v21, v32, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v51 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_endpoint_get_connected_flow_count";
        _os_log_impl(&dword_182FBE000, v21, v51, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_82:
  if (v20)
    free(v20);
  v3 = 0;
  v18 = 0;
LABEL_114:

  return v18;
}

void sub_182FC9064(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_is_multicast(void *a1)
{
  id v1;
  void *v2;
  id v3;
  int v4;
  _DWORD *v5;
  int v6;
  BOOL v7;
  id v8;
  id v9;
  int v10;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  id v14;
  int v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  id v19;
  int v20;
  uint64_t v21;
  os_log_type_t v22;
  id v23;
  int v24;
  id v25;
  int v26;
  char *v27;
  void *v29;
  const char *v30;
  NSObject *v31;
  os_log_type_t v32;
  char *backtrace_string;
  os_log_type_t v34;
  _BOOL4 v35;
  os_log_type_t v36;
  uint64_t v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  _WORD v43[17];

  *(_QWORD *)&v43[13] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_endpoint_is_multicast";
    v30 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v30, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "nw_endpoint_is_multicast";
          _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v34 = type;
        v35 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            v41 = "nw_endpoint_is_multicast";
            v42 = 2082;
            *(_QWORD *)v43 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v31, v34, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          v41 = "nw_endpoint_is_multicast";
          _os_log_impl(&dword_182FBE000, v31, v34, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v36 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "nw_endpoint_is_multicast";
          _os_log_impl(&dword_182FBE000, v31, v36, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_50:
    if (!v30)
      goto LABEL_32;
    v27 = (char *)v30;
    goto LABEL_31;
  }
  v3 = v1;
  v4 = objc_msgSend(v3, "type");

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    v9 = v3;
    v10 = objc_msgSend(v9, "type");

    *(_DWORD *)buf = 136446466;
    v41 = "nw_endpoint_is_multicast";
    v42 = 1024;
    *(_DWORD *)v43 = v10;
    LODWORD(v37) = 18;
    v11 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v11, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          v14 = v9;
          v15 = objc_msgSend(v14, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          v41 = "nw_endpoint_is_multicast";
          v42 = 1024;
          *(_DWORD *)v43 = v15;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v38)
      {
        v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v12, type);
        if (v16)
        {
          if (v18)
          {
            v19 = v9;
            v20 = objc_msgSend(v19, "type", buf, v37);

            *(_DWORD *)buf = 136446722;
            v41 = "nw_endpoint_is_multicast";
            v42 = 1024;
            *(_DWORD *)v43 = v20;
            v43[2] = 2082;
            *(_QWORD *)&v43[3] = v16;
            _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v16);
          if (!v11)
            goto LABEL_32;
LABEL_30:
          v27 = (char *)v11;
LABEL_31:
          free(v27);
          goto LABEL_32;
        }
        if (v18)
        {
          v25 = v9;
          v26 = objc_msgSend(v25, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          v41 = "nw_endpoint_is_multicast";
          v42 = 1024;
          *(_DWORD *)v43 = v26;
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          v23 = v9;
          v24 = objc_msgSend(v23, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          v41 = "nw_endpoint_is_multicast";
          v42 = 1024;
          *(_DWORD *)v43 = v24;
          _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
    if (!v11)
    {
LABEL_32:
      v21 = 0;
      goto LABEL_33;
    }
    goto LABEL_30;
  }
  v5 = v3;
  v6 = *((unsigned __int8 *)v5 + 233);
  if (v6 == 30)
  {
    v7 = *((unsigned __int8 *)v5 + 240) == 255;
LABEL_18:
    v21 = v7;
    goto LABEL_22;
  }
  if (v6 == 2)
  {
    v7 = (v5[59] & 0xF0) == 224;
    goto LABEL_18;
  }
  v21 = 0;
LABEL_22:

LABEL_33:
  return v21;
}

void sub_182FC969C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_182FC9B2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  int v4;
  const sockaddr *v5;
  id v6;
  NSObject *v7;
  int v8;
  const char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  int v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  NSObject *v17;
  int v18;
  os_log_type_t v19;
  NSObject *v20;
  int v21;
  NSObject *v22;
  int v23;
  char *v24;
  void *v26;
  const char *v27;
  NSObject *v28;
  os_log_type_t v29;
  char *backtrace_string;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  uint64_t v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  _WORD v40[17];

  *(_QWORD *)&v40[13] = *MEMORY[0x1E0C80C00];
  v1 = endpoint;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_endpoint_get_address";
    v27 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v38 = "nw_endpoint_get_address";
            v39 = 2082;
            *(_QWORD *)v40 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_182FBE000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_42:
    if (!v27)
      goto LABEL_24;
    v24 = (char *)v27;
    goto LABEL_23;
  }
  v3 = v1;
  v4 = -[NSObject type](v3, "type");

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    v7 = v3;
    v8 = -[NSObject type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_address";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          v12 = v7;
          v13 = -[NSObject type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            v17 = v7;
            v18 = -[NSObject type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_address";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(_QWORD *)&v40[3] = v14;
            _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9)
            goto LABEL_24;
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          v22 = v7;
          v23 = -[NSObject type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          v20 = v7;
          v21 = -[NSObject type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_address";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
    if (!v9)
    {
LABEL_24:
      v5 = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  v5 = (const sockaddr *)&v3[29];
LABEL_25:

  return v5;
}

void sub_182FCA120(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

nw_endpoint_type_t nw_endpoint_get_type(nw_endpoint_t endpoint)
{
  NSObject *v1;
  NSObject *v2;
  nw_endpoint_type_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = endpoint;
  v2 = v1;
  if (v1)
  {
    v3 = -[NSObject type](v1, "type");
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_get_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_get_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = nw_endpoint_type_invalid;
LABEL_3:

  return v3;
}

void sub_182FCA418(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_txt_record_is_equal(nw_txt_record_t left, nw_txt_record_t right)
{
  nw_txt_record_t v3;
  NSObject *v4;
  NSObject *v5;
  BOOL v6;
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  size_t isa;
  os_unfair_lock_s *v11;
  void *v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  v3 = left;
  v4 = right;
  v5 = v4;
  if (v3 == v4)
    goto LABEL_16;
  v6 = 0;
  if (v3 && v4)
  {
    if (v3 <= v4)
      v7 = (os_unfair_lock_s *)v4;
    else
      v7 = (os_unfair_lock_s *)v3;
    if (v3 <= v4)
      v8 = (os_unfair_lock_s *)v3;
    else
      v8 = (os_unfair_lock_s *)v4;
    os_unfair_lock_lock(v7 + 8);
    os_unfair_lock_lock(v8 + 8);
    isa = (size_t)v3[2].isa;
    if ((Class)isa != v5[2].isa)
    {
LABEL_14:
      os_unfair_lock_unlock((os_unfair_lock_t)&v5[4]);
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
      v6 = 0;
      goto LABEL_17;
    }
    if (memcmp(v3[1].isa, v5[1].isa, isa))
    {
      if ((BYTE4(v3[4].isa) & 1) != 0 && (BYTE4(v5[4].isa) & 1) != 0)
      {
        v16 = 0;
        v17 = &v16;
        v18 = 0x2020000000;
        v19 = 1;
        v13[0] = MEMORY[0x1E0C809B0];
        v13[1] = 3221225472;
        v13[2] = __nw_txt_record_is_equal_block_invoke;
        v13[3] = &unk_1E14A5408;
        v11 = v5;
        v14 = v11;
        v15 = &v16;
        v12 = _Block_copy(v13);
        nw_txt_record_apply_internal_locked(v3, v12, 0);
        os_unfair_lock_unlock(v11 + 8);
        os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
        v6 = *((_BYTE *)v17 + 24) != 0;

        _Block_object_dispose(&v16, 8);
        goto LABEL_17;
      }
      goto LABEL_14;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&v5[4]);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
LABEL_16:
    v6 = 1;
  }
LABEL_17:

  return v6;
}

void sub_182FCA5BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_nsarray_is_equal(NSArray *a1, NSArray *a2)
{
  NSArray *v3;
  NSArray *v4;
  NSArray *v5;
  uint64_t v6;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  v6 = v3 == v4;
  if (v3 != v4 && v3 && v4)
    v6 = -[NSArray isEqual:](v3, "isEqual:", v4);

  return v6;
}

void sub_182FCA64C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_protocol_copy_quic_connection_definition()
{
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  return (id)nw_protocol_copy_quic_connection_definition::quic_definition;
}

uint32_t nw_interface_get_index(nw_interface_t interface)
{
  if (interface)
    LODWORD(interface) = interface[1].isa;
  return interface;
}

uint64_t __swift_memcpy5_4(uint64_t result, int *a2)
{
  int v2;

  v2 = *a2;
  *(_BYTE *)(result + 4) = *((_BYTE *)a2 + 4);
  *(_DWORD *)result = v2;
  return result;
}

id nw_path_copy_netagent_dictionary(uint64_t a1)
{
  void *v1;

  if (a1 && (v1 = *(void **)(a1 + 224)) != 0)
    return v1;
  else
    return 0;
}

void nw_connection_add_client_event(void *a1, int a2, void *a3)
{
  nw_connection_add_client_event_internal(a1, a2, a3, 0);
}

void nw_parameters_set_source_application_by_bundle_id(void *a1, const char *a2)
{
  nw_parameters_set_source_application_by_bundle_id_internal(a1, a2);
}

Swift::Void __swiftcall NWConnection.cancel()()
{
  uint64_t v0;

  nw_connection_cancel(*(nw_connection_t *)(v0 + 16));
}

uint64_t nw_log_ms_to_delta(unsigned int a1)
{
  unsigned int v1;
  int v2;

  v1 = 21 - __clz(a1);
  v2 = (a1 >> v1) | (v1 << 11);
  if (a1 < 0x800)
    LOWORD(v2) = a1;
  return (unsigned __int16)v2;
}

uint64_t sub_182FCA71C()
{
  uint64_t v0;
  id v1;
  uint64_t v2;

  v1 = objc_msgSend(*(id *)(*(_QWORD *)v0 + 16), sel_description);
  v2 = sub_183B916E0();

  return v2;
}

void sub_182FCA890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  void *v19;
  os_unfair_lock_s *v20;

  if (a19 < 0)
    operator delete(__p);
  os_unfair_lock_unlock(v20);

  _Unwind_Resume(a1);
}

void sub_182FCAE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  va_list va;

  va_start(va, a6);

  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t nw_activity_is_selected_for_reporting(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 17) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_is_selected_for_reporting";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_selected_for_reporting";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_is_selected_for_reporting";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_selected_for_reporting";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_selected_for_reporting";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_activity_is_global_parent(void *a1)
{
  id v1;
  void *v2;
  uint64_t is_equal;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    is_equal = nw_activity_is_equal(v1, (void *)global_parent);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_is_global_parent";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_global_parent";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_is_global_parent";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_global_parent";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_global_parent";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  is_equal = 0;
LABEL_3:

  return is_equal;
}

void sub_182FCB3E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_activity_is_equal(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  BOOL v6;
  uint64_t v7;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3 && v4 && !uuid_is_null((const unsigned __int8 *)v3 + 8) && !uuid_is_null((const unsigned __int8 *)v5 + 8))
  {
    if (*((_QWORD *)v3 + 1) != *((_QWORD *)v5 + 1))
    {
      v7 = 0;
      goto LABEL_9;
    }
    v6 = *((_QWORD *)v3 + 2) == *((_QWORD *)v5 + 2);
  }
  else
  {
    v6 = v3 == v5;
  }
  v7 = v6;
LABEL_9:

  return v7;
}

void sub_182FCB494(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *nw_frame_array_append_array(_QWORD *result, _QWORD *a2, int a3)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;

  v3 = *a2;
  if (a3)
  {
    if (!v3)
      return result;
    v4 = (_QWORD *)result[1];
    ++result;
    *v4 = v3;
    *(_QWORD *)(*a2 + 40) = *result;
  }
  else
  {
    if (!v3)
      return result;
    v5 = (_QWORD *)result[1];
    ++result;
    *v5 = v3;
    *(_QWORD *)(*a2 + 24) = *result;
  }
  *result = a2[1];
  *a2 = 0;
  a2[1] = a2;
  return result;
}

uint64_t sub_182FCB4F4(uint64_t a1)
{
  unsigned int v1;

  v1 = *(unsigned __int8 *)(a1 + 4) >> 6;
  if (v1 <= 1)
    return v1;
  else
    return (*(_DWORD *)a1 + 2);
}

uint64_t __nw_path_assert_required_agents_block_invoke(uint64_t a1, int a2, xpc_object_t xdict)
{
  _BYTE *data;
  size_t v6[3];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6[0] = 0;
  if (xdict)
  {
    data = xpc_dictionary_get_data(xdict, "data", v6);
    if (data)
    {
      if (v6[0] >= 0xD8 && v6[0] == *((unsigned int *)data + 53) + 216 && (data[209] & 2) != 0)
      {
        *(_OWORD *)v6 = *(_OWORD *)data;
        if (!uuid_is_null((const unsigned __int8 *)v6))
          nw_path_agent_action(*(NWConcrete_nw_path **)(a1 + 32), (const unsigned __int8 *)v6, 131);
      }
    }
  }
  return 1;
}

NSObject *nw_parameters_create_secure_tcp_or_quic_connection(void *a1, void *a2, void *a3)
{
  return nw_parameters_create_quic_connection_with_tls_fallback(a1, a2, 0, a3);
}

id *nw_path_copy_direct_interface(id *result)
{
  if (result)
    return (id *)result[12];
  return result;
}

uint64_t __nwlog_tcp_log()
{
  if (__nwlog_tcp_log::onceToken != -1)
    dispatch_once(&__nwlog_tcp_log::onceToken, &__block_literal_global_42_44208);
  return gtcpLogObj;
}

uint64_t nw_interface_functional_type_to_interface_type(int a1)
{
  if ((a1 - 1) > 5)
    return 0;
  else
    return dword_183C6F140[a1 - 1];
}

uint64_t nw_interface_functional_type_to_interface_subtype(int a1)
{
  if ((a1 - 3) > 4)
    return 0;
  else
    return dword_183C6F158[a1 - 3];
}

_BYTE *sub_182FCB738(_BYTE *result, char a2)
{
  *result = a2;
  return result;
}

void nw_channel_finalize_input_frame(nw_frame *a1, BOOL a2, _QWORD *a3)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *metadata;
  _QWORD *v9;
  int v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  _WORD *v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  int v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  int v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  char *backtrace_string;
  _BOOL4 v33;
  _QWORD *v34;
  char v35;
  os_log_type_t v36;
  os_log_type_t type[2];
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)a1 + 2);
  v6 = (_QWORD *)*((_QWORD *)a1 + 3);
  v7 = (_QWORD *)((char *)a1 + 16);
  if (v5)
  {
    *(_QWORD *)(v5 + 24) = v6;
    v6 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    a3[41] = v6;
  }
  *v6 = v5;
  *v7 = 0;
  *((_QWORD *)a1 + 3) = 0;
  metadata = (_QWORD *)nw_frame_get_metadata((uint64_t)a1);
  if (metadata)
  {
    v9 = metadata;
    if (*metadata)
    {
      v10 = *((unsigned __int16 *)a3 + 222);
      if ((v10 & 0x1000) == 0)
        goto LABEL_22;
      if (!a3[17])
      {
        if (_nw_signposts_once != -1)
          dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
        if (_nw_signposts_enabled && kdebug_is_enabled())
          kdebug_trace();
        goto LABEL_22;
      }
      if (((v10 | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
      {
LABEL_22:
        *v9 = 0;
        v9[1] = 0;
        goto LABEL_23;
      }
      if (os_channel_is_defunct())
      {
        nw_channel_handle_defunct((uint64_t)a3);
        goto LABEL_22;
      }
      *(_WORD *)type = 0;
      if ((*((_WORD *)a1 + 102) & 0x2000) == 0 || (v11 = os_packet_decrement_use_count()) == 0)
      {
LABEL_18:
        if (((*((_WORD *)a1 + 102) & 0x2000) == 0 || !*(_WORD *)type) && os_channel_packet_free())
          nw_channel_check_defunct((uint64_t)a3);
        goto LABEL_22;
      }
      v27 = v11;
      if ((nw_channel_check_defunct((uint64_t)a3) & 1) != 0)
        goto LABEL_22;
      v34 = v7;
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v39 = "nw_channel_finalize_input_frame";
      v40 = 1024;
      v41 = v27;
      v28 = (char *)_os_log_send_and_compose_impl();
      v36 = OS_LOG_TYPE_ERROR;
      v35 = 0;
      if (__nwlog_fault(v28, &v36, &v35))
      {
        if (v36 == OS_LOG_TYPE_FAULT)
        {
          v29 = __nwlog_obj();
          v30 = v36;
          if (os_log_type_enabled(v29, v36))
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_channel_finalize_input_frame";
            v40 = 1024;
            v41 = v27;
            v31 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d";
LABEL_78:
            _os_log_impl(&dword_182FBE000, v29, v30, v31, buf, 0x12u);
          }
        }
        else if (v35)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v29 = __nwlog_obj();
          v30 = v36;
          v33 = os_log_type_enabled(v29, v36);
          if (backtrace_string)
          {
            if (v33)
            {
              *(_DWORD *)buf = 136446722;
              v39 = "nw_channel_finalize_input_frame";
              v40 = 1024;
              v41 = v27;
              v42 = 2082;
              v43 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(backtrace_string);
            goto LABEL_79;
          }
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_channel_finalize_input_frame";
            v40 = 1024;
            v41 = v27;
            v31 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, no backtrace";
            goto LABEL_78;
          }
        }
        else
        {
          v29 = __nwlog_obj();
          v30 = v36;
          if (os_log_type_enabled(v29, v36))
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_channel_finalize_input_frame";
            v40 = 1024;
            v41 = v27;
            v31 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_78;
          }
        }
      }
LABEL_79:
      if (v28)
        free(v28);
      v7 = v34;
      goto LABEL_18;
    }
  }
LABEL_23:
  *((_QWORD *)a1 + 2) = 0;
  v12 = (_QWORD *)a3[37];
  *((_QWORD *)a1 + 3) = v12;
  *v12 = a1;
  a3[37] = v7;
  if (a3[40])
    return;
  *((_DWORD *)a3 + 104) = 0;
  v13 = a3[50];
  if (v13 && a3[28])
  {
    v14 = os_channel_advance_slot();
    if (!v14 || (v20 = v14, (nw_channel_check_defunct((uint64_t)a3) & 1) != 0))
    {
LABEL_28:
      a3[50] = 0;
      goto LABEL_29;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v39 = "nw_channel_finalize_input_frame";
    v40 = 1024;
    v41 = v20;
    v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v36 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v21, type, &v36))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v22 = __nwlog_obj();
        v23 = type[0];
        if (!os_log_type_enabled(v22, type[0]))
          goto LABEL_67;
        *(_DWORD *)buf = 136446466;
        v39 = "nw_channel_finalize_input_frame";
        v40 = 1024;
        v41 = v20;
        v24 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d";
        goto LABEL_66;
      }
      if (v36 == OS_LOG_TYPE_DEFAULT)
      {
        v22 = __nwlog_obj();
        v23 = type[0];
        if (!os_log_type_enabled(v22, type[0]))
          goto LABEL_67;
        *(_DWORD *)buf = 136446466;
        v39 = "nw_channel_finalize_input_frame";
        v40 = 1024;
        v41 = v20;
        v24 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_66;
      }
      v25 = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type[0];
      v26 = os_log_type_enabled(v22, type[0]);
      if (v25)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446722;
          v39 = "nw_channel_finalize_input_frame";
          v40 = 1024;
          v41 = v20;
          v42 = 2082;
          v43 = v25;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v25);
        goto LABEL_67;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v39 = "nw_channel_finalize_input_frame";
        v40 = 1024;
        v41 = v20;
        v24 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, no backtrace";
LABEL_66:
        _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0x12u);
      }
    }
LABEL_67:
    if (v21)
      free(v21);
    goto LABEL_28;
  }
LABEL_29:
  v15 = (_WORD *)a3 + 222;
  if ((*((_WORD *)a3 + 222) & 4) != 0)
  {
    v16 = (_QWORD *)a3[21];
    if (v16)
    {
      if (*v16 && _dispatch_source_will_reenable_kevent_4NW() && a3[21] && (*v15 & 8) != 0)
        goto LABEL_42;
    }
  }
  if (!a3[17])
    goto LABEL_42;
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  if (!os_channel_sync())
  {
LABEL_42:
    v17 = a3[21];
    if (!v17)
      return;
  }
  else
  {
    nw_channel_check_defunct((uint64_t)a3);
    v17 = a3[21];
    if (!v17)
      return;
  }
  v18 = (unsigned __int16)*v15;
  if ((v18 & 8) != 0)
  {
    v19 = v18 & 0xFFFFFFF7 | (*((unsigned __int8 *)a3 + 446) << 16);
    *v15 = v18 & 0xFFF7;
    *((_BYTE *)a3 + 446) = BYTE2(v19);
    nw_queue_resume_source(v17, v13);
  }
}

uint64_t nw_channel_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _WORD *handle;
  unsigned int v4;
  nw_frame *tqh_first;
  nw_frame **tqh_last;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  const char *v18;
  _BOOL4 v19;
  _QWORD v20[2];
  uint64_t (*v21)(uint64_t, uint64_t);
  void *v22;
  _BYTE *v23;
  os_log_type_t type[8];
  os_log_type_t *v25;
  char v26;
  _BYTE buf[24];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v4 = ((unsigned __int16)handle[222] | (*((unsigned __int8 *)handle + 446) << 16)) & 0xFFF9FFFF | 0x20000;
      handle[222] = handle[222];
      *((_BYTE *)handle + 446) = BYTE2(v4);
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
      if (_nw_signposts_enabled && kdebug_is_enabled())
        kdebug_trace();
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2000000000;
      v28 = 0;
      if (_nw_signposts_once == -1)
      {
        if (!_nw_signposts_enabled)
          goto LABEL_12;
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
        if (!_nw_signposts_enabled)
          goto LABEL_12;
      }
      if (kdebug_is_enabled())
      {
        *(_DWORD *)type = 0;
        nw_frame_array_get_frame_count((uint64_t *)a2, 1, type);
      }
LABEL_12:
      *(_QWORD *)type = 0;
      v25 = type;
      tqh_first = a2->tqh_first;
      if (a2->tqh_first)
      {
        *((_QWORD *)tqh_first + 5) = type;
        tqh_last = a2->tqh_last;
        *(_QWORD *)type = tqh_first;
        v25 = (os_log_type_t *)tqh_last;
        a2->tqh_first = 0;
        a2->tqh_last = &a2->tqh_first;
      }
      v20[0] = MEMORY[0x1E0C809B0];
      v20[1] = 0x40000000;
      v21 = ___ZL33nw_channel_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
      v22 = &unk_1E14ACD70;
      v23 = buf;
      do
      {
        v8 = *(_QWORD *)type;
        if (!*(_QWORD *)type)
          break;
        v10 = *(_QWORD *)(*(_QWORD *)type + 32);
        v7 = *(_QWORD **)(*(_QWORD *)type + 40);
        v9 = (_QWORD *)(*(_QWORD *)type + 32);
        if (v10)
        {
          *(_QWORD *)(v10 + 40) = v7;
          v7 = *(_QWORD **)(v8 + 40);
        }
        else
        {
          v25 = *(os_log_type_t **)(*(_QWORD *)type + 40);
        }
        *v7 = v10;
        *v9 = 0;
        *(_QWORD *)(v8 + 40) = 0;
      }
      while ((((uint64_t (*)(_QWORD *))v21)(v20) & 1) != 0);
      if (_nw_signposts_once == -1)
      {
        if (_nw_signposts_enabled)
          goto LABEL_22;
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
        if (_nw_signposts_enabled)
        {
LABEL_22:
          if (kdebug_is_enabled())
            kdebug_trace();
        }
      }
      _Block_object_dispose(buf, 8);
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v12, type, &v26))
      goto LABEL_56;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
        v15 = "%{public}s called with null channel";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (!v26)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
        v15 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type[0];
    v19 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
        v15 = "%{public}s called with null channel, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v18 = "%{public}s called with null channel, dumping backtrace:%{public}s";
      goto LABEL_45;
    }
    goto LABEL_46;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
  v12 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (!__nwlog_fault(v12, type, &v26))
    goto LABEL_56;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!v26)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
        v15 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type[0];
    v17 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
        v15 = "%{public}s called with null channel_protocol, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v18 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_45:
      _os_log_impl(&dword_182FBE000, v13, v14, v18, buf, 0x16u);
    }
LABEL_46:
    free(backtrace_string);
    goto LABEL_56;
  }
  v13 = __nwlog_obj();
  v14 = type[0];
  if (os_log_type_enabled(v13, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frames";
    v15 = "%{public}s called with null channel_protocol";
LABEL_55:
    _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
  }
LABEL_56:
  if (v12)
    free(v12);
  return 0;
}

uint64_t ___ZL33nw_channel_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  nw_frame_finalize(a2);
  return 1;
}

void nw_frame_finalize(uint64_t a1)
{
  void (*v1)(void);
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char *v8;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_finalize";
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v13 = "__nw_frame_finalize";
      v5 = "%{public}s called with null frame";
LABEL_31:
      _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      goto LABEL_32;
    }
    if (!v10)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v13 = "__nw_frame_finalize";
      v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_31;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v3 = __nwlog_obj();
    v4 = type;
    v7 = os_log_type_enabled(v3, type);
    if (!backtrace_string)
    {
      if (!v7)
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v13 = "__nw_frame_finalize";
      v5 = "%{public}s called with null frame, no backtrace";
      goto LABEL_31;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      v13 = "__nw_frame_finalize";
      v14 = 2082;
      v15 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_32:
    if (!v2)
      return;
    goto LABEL_33;
  }
  v1 = *(void (**)(void))(a1 + 80);
  if (v1)
  {
    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 88) = 0;
    v1();
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "__nw_frame_finalize";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10))
    goto LABEL_32;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_32;
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_finalize";
    v5 = "%{public}s called with null frame->finalizer";
    goto LABEL_31;
  }
  if (!v10)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_32;
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_finalize";
    v5 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_31;
  }
  v8 = (char *)__nw_create_backtrace_string();
  v3 = __nwlog_obj();
  v4 = type;
  v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9)
      goto LABEL_32;
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_finalize";
    v5 = "%{public}s called with null frame->finalizer, no backtrace";
    goto LABEL_31;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    v13 = "__nw_frame_finalize";
    v14 = 2082;
    v15 = v8;
    _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v8);
  if (v2)
LABEL_33:
    free(v2);
}

void nw_channel_finalize_output_frame(nw_frame *a1, int a2, unsigned __int16 *a3)
{
  _QWORD *metadata;
  _QWORD *v7;
  int v8;
  int v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  _WORD *v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  __int16 v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  int v35;
  uint64_t node;
  uint64_t v37;
  _QWORD *v38;
  NSObject *v39;
  int v40;
  int v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  int ce_count;
  BOOL v49;
  void *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  void (*v55)(uint64_t, unsigned __int16 *, uint64_t, unint64_t *, uint64_t);
  uint64_t v56;
  uint64_t v57;
  void (**v58)(_QWORD);
  const void *v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  void (**v63)(_QWORD);
  const void *v64;
  uint64_t v65;
  const char *v66;
  NSObject *v67;
  os_log_type_t v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  const char *v72;
  const char *v73;
  const char *v74;
  NSObject *v75;
  os_log_type_t v76;
  const char *v77;
  const char *v78;
  NSObject *v79;
  os_log_type_t v80;
  NSObject *v81;
  os_log_type_t v82;
  const char *v83;
  _BOOL4 v84;
  const char *v85;
  NSObject *v86;
  NSObject *v87;
  const char *v88;
  char *v89;
  _BOOL4 v90;
  const char *v91;
  char *v92;
  _BOOL4 v93;
  const char *v94;
  NSObject *v95;
  os_log_type_t v96;
  NSObject *v97;
  os_log_type_t v98;
  NSObject *v99;
  uint64_t v100;
  _QWORD *v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  int v106;
  NSObject *v107;
  uint64_t v108;
  void (*v109)(uint64_t, unsigned __int16 *);
  char v111;
  const char *v112;
  NSObject *v113;
  os_log_type_t v114;
  NSObject *v115;
  os_log_type_t v116;
  const char *v117;
  uint64_t v118;
  char v119;
  uint64_t v120;
  uint64_t *v121;
  char *v122;
  _BOOL4 v123;
  NSObject *v124;
  os_log_type_t v125;
  NSObject *v126;
  int v127;
  char *v128;
  NSObject *v129;
  os_log_type_t v130;
  const char *v131;
  NSObject *v132;
  char *v133;
  NSObject *v134;
  os_log_type_t v135;
  const char *v136;
  char *v137;
  NSObject *v138;
  os_log_type_t v139;
  const char *v140;
  char *v141;
  _BOOL4 v142;
  char *v143;
  _BOOL4 v144;
  char *v145;
  _BOOL4 v146;
  char *v147;
  NSObject *v148;
  os_log_type_t v149;
  const char *v150;
  char *v151;
  NSObject *v152;
  os_log_type_t v153;
  const char *v154;
  char *v155;
  _BOOL4 v156;
  char *v157;
  NSObject *v158;
  os_log_type_t v159;
  const char *v160;
  char *v161;
  _BOOL4 v162;
  char *v163;
  _BOOL4 v164;
  char *backtrace_string;
  _BOOL4 v166;
  char *v167;
  NSObject *v168;
  os_log_type_t v169;
  const char *v170;
  char *v171;
  _BOOL4 v172;
  char *v173;
  NSObject *v174;
  os_log_type_t v175;
  const char *v176;
  char *v177;
  _BOOL4 v178;
  os_log_type_t v179;
  os_log_type_t v180;
  NSObject *v181;
  os_log_type_t v182;
  NSObject *v183;
  os_log_type_t v184;
  NSObject *v185;
  char *v186;
  os_log_type_t v187;
  NSObject *v188;
  os_log_type_t v189;
  os_log_type_t v190[8];
  NSObject *v191;
  os_log_type_t v192[8];
  os_log_t log;
  os_log_t loga;
  NSObject *logb;
  os_log_t logc;
  char *v197;
  unsigned int v198;
  os_log_type_t type[4];
  char v200;
  os_log_type_t v201;
  _BYTE buf[12];
  __int16 v203;
  _BYTE v204[28];
  unint64_t v205;
  uint64_t v206;
  uint64_t v207;

  v207 = *MEMORY[0x1E0C80C00];
  metadata = (_QWORD *)nw_frame_get_metadata((uint64_t)a1);
  v7 = metadata;
  if (!metadata || !*metadata)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
    v11 = "%{public}s Frame has no packet";
LABEL_13:
    v12 = v10;
    v13 = OS_LOG_TYPE_ERROR;
    goto LABEL_14;
  }
  if (!metadata[1])
  {
    if ((a3[222] & 0x1000) == 0)
      goto LABEL_96;
    if (!*((_QWORD *)a3 + 17))
      goto LABEL_96;
    v23 = os_channel_packet_free();
    if (!v23)
      goto LABEL_96;
    v24 = v23;
    if (!*((_QWORD *)a3 + 17))
    {
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
      if (_nw_signposts_enabled && kdebug_is_enabled())
        kdebug_trace();
      goto LABEL_96;
    }
    if (((a3[222] | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
    {
LABEL_96:
      *v7 = 0;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
      v11 = "%{public}s Frame has no buflet";
      goto LABEL_13;
    }
    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_96;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
    v203 = 1024;
    *(_DWORD *)v204 = v24;
    v157 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v205) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v157, &v205, type))
    {
      if (v205 == 17)
      {
        v158 = __nwlog_obj();
        v159 = v205;
        if (!os_log_type_enabled(v158, (os_log_type_t)v205))
          goto LABEL_444;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v24;
        v160 = "%{public}s os_channel_packet_free failed %{darwin.errno}d";
        goto LABEL_443;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v158 = __nwlog_obj();
        v159 = v205;
        if (!os_log_type_enabled(v158, (os_log_type_t)v205))
          goto LABEL_444;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v24;
        v160 = "%{public}s os_channel_packet_free failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_443;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v158 = __nwlog_obj();
      v159 = v205;
      v166 = os_log_type_enabled(v158, (os_log_type_t)v205);
      if (backtrace_string)
      {
        if (v166)
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
          v203 = 1024;
          *(_DWORD *)v204 = v24;
          *(_WORD *)&v204[4] = 2082;
          *(_QWORD *)&v204[6] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v158, v159, "%{public}s os_channel_packet_free failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_444;
      }
      if (v166)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v24;
        v160 = "%{public}s os_channel_packet_free failed %{darwin.errno}d, no backtrace";
LABEL_443:
        _os_log_impl(&dword_182FBE000, v158, v159, v160, buf, 0x12u);
      }
    }
LABEL_444:
    if (v157)
      free(v157);
    goto LABEL_96;
  }
  if (!*((_QWORD *)a3 + 17))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      goto LABEL_15;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
    v11 = "%{public}s Channel is defunct, cannot write frame";
    v12 = v25;
    v13 = OS_LOG_TYPE_DEBUG;
LABEL_14:
    _os_log_impl(&dword_182FBE000, v12, v13, v11, buf, 0xCu);
    goto LABEL_15;
  }
  if (!a2)
  {
    v26 = os_buflet_set_data_length();
    if (!v26)
      goto LABEL_115;
    v27 = v26;
    if (!*((_QWORD *)a3 + 17))
    {
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
      if (_nw_signposts_enabled && kdebug_is_enabled())
        kdebug_trace();
      goto LABEL_115;
    }
    if (((a3[222] | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
      goto LABEL_115;
    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_115;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
    v203 = 1024;
    *(_DWORD *)v204 = v27;
    v151 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v205) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v151, &v205, type))
    {
      if (v205 == 17)
      {
        v152 = __nwlog_obj();
        v153 = v205;
        if (!os_log_type_enabled(v152, (os_log_type_t)v205))
          goto LABEL_437;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v27;
        v154 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d";
        goto LABEL_436;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v152 = __nwlog_obj();
        v153 = v205;
        if (!os_log_type_enabled(v152, (os_log_type_t)v205))
          goto LABEL_437;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v27;
        v154 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_436;
      }
      v163 = (char *)__nw_create_backtrace_string();
      v152 = __nwlog_obj();
      v153 = v205;
      v164 = os_log_type_enabled(v152, (os_log_type_t)v205);
      if (v163)
      {
        if (v164)
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
          v203 = 1024;
          *(_DWORD *)v204 = v27;
          *(_WORD *)&v204[4] = 2082;
          *(_QWORD *)&v204[6] = v163;
          _os_log_impl(&dword_182FBE000, v152, v153, "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v163);
        goto LABEL_437;
      }
      if (v164)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v27;
        v154 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, no backtrace";
LABEL_436:
        _os_log_impl(&dword_182FBE000, v152, v153, v154, buf, 0x12u);
      }
    }
LABEL_437:
    if (v151)
      free(v151);
    goto LABEL_115;
  }
  nw_frame_effective_length((uint64_t)a1);
  v8 = os_buflet_set_data_length();
  if (!v8)
    goto LABEL_66;
  v9 = v8;
  if (*((_QWORD *)a3 + 17))
  {
    if (((a3[222] | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
      goto LABEL_66;
    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_66;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
    v203 = 1024;
    *(_DWORD *)v204 = v9;
    v147 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v205) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v147, &v205, type))
      goto LABEL_432;
    if (v205 == 17)
    {
      v148 = __nwlog_obj();
      v149 = v205;
      if (!os_log_type_enabled(v148, (os_log_type_t)v205))
        goto LABEL_432;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
      v203 = 1024;
      *(_DWORD *)v204 = v9;
      v150 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d";
    }
    else if (type[0])
    {
      v161 = (char *)__nw_create_backtrace_string();
      v148 = __nwlog_obj();
      v149 = v205;
      v162 = os_log_type_enabled(v148, (os_log_type_t)v205);
      if (v161)
      {
        if (v162)
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
          v203 = 1024;
          *(_DWORD *)v204 = v9;
          *(_WORD *)&v204[4] = 2082;
          *(_QWORD *)&v204[6] = v161;
          _os_log_impl(&dword_182FBE000, v148, v149, "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v161);
        goto LABEL_432;
      }
      if (!v162)
      {
LABEL_432:
        if (v147)
          free(v147);
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
      v203 = 1024;
      *(_DWORD *)v204 = v9;
      v150 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v148 = __nwlog_obj();
      v149 = v205;
      if (!os_log_type_enabled(v148, (os_log_type_t)v205))
        goto LABEL_432;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
      v203 = 1024;
      *(_DWORD *)v204 = v9;
      v150 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v148, v149, v150, buf, 0x12u);
    goto LABEL_432;
  }
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
LABEL_66:
  if (!*((_QWORD *)a3 + 17))
  {
    v132 = __nwlog_obj();
    if (os_log_type_enabled(v132, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
      _os_log_impl(&dword_182FBE000, v132, OS_LOG_TYPE_DEBUG, "%{public}s Channel is newly defunct, cannot write frame", buf, 0xCu);
    }
    goto LABEL_115;
  }
  if (a1)
    goto LABEL_68;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "__nw_frame_get_service_class";
  v133 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v205) = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v133, &v205, type))
  {
    if (v205 == 17)
    {
      v134 = __nwlog_obj();
      v135 = v205;
      if (!os_log_type_enabled(v134, (os_log_type_t)v205))
        goto LABEL_356;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_get_service_class";
      v136 = "%{public}s called with null frame";
      goto LABEL_355;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v134 = __nwlog_obj();
      v135 = v205;
      if (!os_log_type_enabled(v134, (os_log_type_t)v205))
        goto LABEL_356;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_get_service_class";
      v136 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_355;
    }
    v141 = (char *)__nw_create_backtrace_string();
    v134 = __nwlog_obj();
    v135 = v205;
    v142 = os_log_type_enabled(v134, (os_log_type_t)v205);
    if (v141)
    {
      if (v142)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "__nw_frame_get_service_class";
        v203 = 2082;
        *(_QWORD *)v204 = v141;
        _os_log_impl(&dword_182FBE000, v134, v135, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v141);
      goto LABEL_356;
    }
    if (v142)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_get_service_class";
      v136 = "%{public}s called with null frame, no backtrace";
LABEL_355:
      _os_log_impl(&dword_182FBE000, v134, v135, v136, buf, 0xCu);
    }
  }
LABEL_356:
  if (v133)
    free(v133);
LABEL_68:
  os_packet_set_service_class();
  if ((a3[222] & 0x400) != 0)
  {
    if (a1)
    {
      if ((*((_BYTE *)a1 + 186) & 3) == 1)
      {
        os_packet_set_l4s_flag();
        if (*((_QWORD *)a1 + 20))
          os_packet_set_tx_timestamp();
      }
      if ((*((_BYTE *)a1 + 186) & 4) != 0)
      {
        os_packet_set_transport_retransmit();
        if ((*((_BYTE *)a1 + 186) & 8) == 0)
          goto LABEL_73;
      }
      else if ((*((_BYTE *)a1 + 186) & 8) == 0)
      {
        goto LABEL_73;
      }
      os_packet_set_transport_last_packet();
LABEL_73:
      if ((*((_BYTE *)a1 + 186) & 0x10) != 0)
      {
        os_packet_set_transport_traffic_background();
        if ((*((_BYTE *)a1 + 186) & 0x20) == 0)
          goto LABEL_75;
      }
      else if ((*((_BYTE *)a1 + 186) & 0x20) == 0)
      {
        goto LABEL_75;
      }
      os_packet_set_transport_traffic_realtime();
LABEL_75:
      LOBYTE(v28) = *((_WORD *)a1 + 102);
      if ((*((_WORD *)a1 + 102) & 0x20) != 0)
      {
        os_packet_set_packetid();
        LOBYTE(v28) = *((_WORD *)a1 + 102);
        if ((*((_WORD *)a1 + 102) & 0x10) == 0)
          goto LABEL_79;
      }
      else if ((*((_WORD *)a1 + 102) & 0x10) == 0)
      {
        goto LABEL_79;
      }
      if (*((_QWORD *)a1 + 19))
      {
        os_packet_set_expire_time();
        v28 = *((_WORD *)a1 + 102);
      }
LABEL_79:
      if ((v28 & 0x40) == 0)
      {
        if (*((_DWORD *)a1 + 48))
          os_packet_set_compression_generation_count();
        goto LABEL_110;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
      v29 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v205) = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v29, &v205, type))
      {
        if (v205 == 17)
        {
          v30 = __nwlog_obj();
          v31 = v205;
          if (!os_log_type_enabled(v30, (os_log_type_t)v205))
            goto LABEL_108;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
          v32 = "%{public}s Attempt to get generation-count on a chain-member";
          goto LABEL_107;
        }
        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          v30 = __nwlog_obj();
          v31 = v205;
          if (!os_log_type_enabled(v30, (os_log_type_t)v205))
            goto LABEL_108;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
          v32 = "%{public}s Attempt to get generation-count on a chain-member, backtrace limit exceeded";
          goto LABEL_107;
        }
        v33 = (char *)__nw_create_backtrace_string();
        v30 = __nwlog_obj();
        v31 = v205;
        v34 = os_log_type_enabled(v30, (os_log_type_t)v205);
        if (v33)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
            v203 = 2082;
            *(_QWORD *)v204 = v33;
            _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s Attempt to get generation-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v33);
          goto LABEL_108;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_get_compression_generation_count";
          v32 = "%{public}s Attempt to get generation-count on a chain-member, no backtrace";
LABEL_107:
          _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0xCu);
        }
      }
LABEL_108:
      if (v29)
        free(v29);
LABEL_110:
      v35 = *((unsigned __int16 *)a1 + 102);
      if ((v35 & 0x8000) != 0)
      {
        os_packet_set_keep_alive();
        if (((*((unsigned __int16 *)a1 + 102) | (*((unsigned __int8 *)a1 + 206) << 16)) & 0x10000) == 0)
        {
LABEL_112:
          if (!*((_WORD *)a1 + 99))
          {
LABEL_114:
            os_packet_add_inet_csum_flags();
            goto LABEL_115;
          }
LABEL_113:
          os_packet_set_tso_flags();
          os_packet_set_protocol_segment_size();
          goto LABEL_114;
        }
      }
      else if (((v35 | (*((unsigned __int8 *)a1 + 206) << 16)) & 0x10000) == 0)
      {
        goto LABEL_112;
      }
      os_packet_set_app_metadata();
      if (!*((_WORD *)a1 + 99))
        goto LABEL_114;
      goto LABEL_113;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_get_ecn_flag";
    v137 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v205) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v137, &v205, type))
    {
      if (v205 == 17)
      {
        v138 = __nwlog_obj();
        v139 = v205;
        if (!os_log_type_enabled(v138, (os_log_type_t)v205))
          goto LABEL_384;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_get_ecn_flag";
        v140 = "%{public}s called with null frame";
LABEL_383:
        _os_log_impl(&dword_182FBE000, v138, v139, v140, buf, 0xCu);
        goto LABEL_384;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v138 = __nwlog_obj();
        v139 = v205;
        if (!os_log_type_enabled(v138, (os_log_type_t)v205))
          goto LABEL_384;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_get_ecn_flag";
        v140 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_383;
      }
      v145 = (char *)__nw_create_backtrace_string();
      v138 = __nwlog_obj();
      v139 = v205;
      v146 = os_log_type_enabled(v138, (os_log_type_t)v205);
      if (!v145)
      {
        if (!v146)
          goto LABEL_384;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_get_ecn_flag";
        v140 = "%{public}s called with null frame, no backtrace";
        goto LABEL_383;
      }
      if (v146)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "__nw_frame_get_ecn_flag";
        v203 = 2082;
        *(_QWORD *)v204 = v145;
        _os_log_impl(&dword_182FBE000, v138, v139, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v145);
    }
LABEL_384:
    if (v137)
      free(v137);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_is_retransmit";
    v167 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v205) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v167, &v205, type))
    {
      if (v205 == 17)
      {
        v168 = __nwlog_obj();
        v169 = v205;
        if (!os_log_type_enabled(v168, (os_log_type_t)v205))
          goto LABEL_400;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_is_retransmit";
        v170 = "%{public}s called with null frame";
LABEL_399:
        _os_log_impl(&dword_182FBE000, v168, v169, v170, buf, 0xCu);
        goto LABEL_400;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v168 = __nwlog_obj();
        v169 = v205;
        if (!os_log_type_enabled(v168, (os_log_type_t)v205))
          goto LABEL_400;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_is_retransmit";
        v170 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_399;
      }
      v171 = (char *)__nw_create_backtrace_string();
      v168 = __nwlog_obj();
      v169 = v205;
      v172 = os_log_type_enabled(v168, (os_log_type_t)v205);
      if (!v171)
      {
        if (!v172)
          goto LABEL_400;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_is_retransmit";
        v170 = "%{public}s called with null frame, no backtrace";
        goto LABEL_399;
      }
      if (v172)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "__nw_frame_is_retransmit";
        v203 = 2082;
        *(_QWORD *)v204 = v171;
        _os_log_impl(&dword_182FBE000, v168, v169, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v171);
    }
LABEL_400:
    if (v167)
      free(v167);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_is_last_frame";
    v173 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v205) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v173, &v205, type))
      goto LABEL_416;
    if (v205 == 17)
    {
      v174 = __nwlog_obj();
      v175 = v205;
      if (!os_log_type_enabled(v174, (os_log_type_t)v205))
        goto LABEL_416;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_is_last_frame";
      v176 = "%{public}s called with null frame";
    }
    else if (type[0])
    {
      v177 = (char *)__nw_create_backtrace_string();
      v174 = __nwlog_obj();
      v175 = v205;
      v178 = os_log_type_enabled(v174, (os_log_type_t)v205);
      if (v177)
      {
        if (v178)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_frame_is_last_frame";
          v203 = 2082;
          *(_QWORD *)v204 = v177;
          _os_log_impl(&dword_182FBE000, v174, v175, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v177);
        goto LABEL_416;
      }
      if (!v178)
      {
LABEL_416:
        if (v173)
          free(v173);
        goto LABEL_73;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_is_last_frame";
      v176 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v174 = __nwlog_obj();
      v175 = v205;
      if (!os_log_type_enabled(v174, (os_log_type_t)v205))
        goto LABEL_416;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_is_last_frame";
      v176 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v174, v175, v176, buf, 0xCu);
    goto LABEL_416;
  }
LABEL_115:
  if (*((_QWORD *)a3 + 17))
  {
    v205 = 0;
    v206 = 0;
    os_packet_get_flow_uuid();
    node = nw_hash_table_get_node(*((_QWORD *)a3 + 35), (uint64_t)&v205, 16);
    if (node)
    {
      if ((a3[222] & 0x200) != 0 && (*(_BYTE *)(node + 153) & 3) == 0)
      {
        *(_QWORD *)(node + 72) = 0;
        v37 = node + 72;
        v38 = (_QWORD *)*((_QWORD *)a3 + 47);
        *(_QWORD *)(v37 + 8) = v38;
        *v38 = v37 - 40;
        *((_QWORD *)a3 + 47) = v37;
        *(_BYTE *)(v37 + 81) |= 1u;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1042;
        *(_DWORD *)v204 = 16;
        *(_WORD *)&v204[4] = 2098;
        *(_QWORD *)&v204[6] = &v205;
        _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_ERROR, "%{public}s Node not found for flow id %{public,uuid_t}.16P", buf, 0x1Cu);
      }
    }
    os_packet_finalize();
    if ((a3[222] & 0x1000) != 0)
    {
      if (*((_QWORD *)a3 + 27))
      {
        v40 = os_channel_slot_attach_packet();
        if (v40)
        {
          v41 = v40;
          if ((nw_channel_check_defunct((uint64_t)a3) & 1) == 0)
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
            v203 = 1024;
            *(_DWORD *)v204 = v41;
            v42 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v198) = 0;
            if (!__nwlog_fault(v42, type, &v198))
              goto LABEL_427;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v43 = __nwlog_obj();
              v44 = type[0];
              if (!os_log_type_enabled(v43, type[0]))
                goto LABEL_427;
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
              v203 = 1024;
              *(_DWORD *)v204 = v41;
              v45 = "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d";
            }
            else if ((_BYTE)v198)
            {
              v155 = (char *)__nw_create_backtrace_string();
              v43 = __nwlog_obj();
              v44 = type[0];
              v156 = os_log_type_enabled(v43, type[0]);
              if (v155)
              {
                if (v156)
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
                  v203 = 1024;
                  *(_DWORD *)v204 = v41;
                  *(_WORD *)&v204[4] = 2082;
                  *(_QWORD *)&v204[6] = v155;
                  _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }
                free(v155);
                goto LABEL_427;
              }
              if (!v156)
              {
LABEL_427:
                if (v42)
                  free(v42);
                goto LABEL_15;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
              v203 = 1024;
              *(_DWORD *)v204 = v41;
              v45 = "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d, no backtrace";
            }
            else
            {
              v43 = __nwlog_obj();
              v44 = type[0];
              if (!os_log_type_enabled(v43, type[0]))
                goto LABEL_427;
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
              v203 = 1024;
              *(_DWORD *)v204 = v41;
              v45 = "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d, backtrace limit exceeded";
            }
            _os_log_impl(&dword_182FBE000, v43, v44, v45, buf, 0x12u);
            goto LABEL_427;
          }
        }
      }
    }
  }
LABEL_15:
  v15 = *((_QWORD *)a1 + 2);
  v16 = (_QWORD *)*((_QWORD *)a1 + 3);
  v14 = (_QWORD *)((char *)a1 + 16);
  if (v15)
  {
    *(_QWORD *)(v15 + 24) = v16;
    v16 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    *((_QWORD *)a3 + 39) = v16;
  }
  *v16 = v15;
  *v14 = 0;
  *((_QWORD *)a1 + 3) = 0;
  --*((_DWORD *)a3 + 105);
  if (v7 && *v7)
  {
    *v7 = 0;
    v7[1] = 0;
  }
  *((_QWORD *)a1 + 2) = 0;
  v17 = (_QWORD *)*((_QWORD *)a3 + 37);
  *((_QWORD *)a1 + 3) = v17;
  *v17 = a1;
  *((_QWORD *)a3 + 37) = v14;
  if (*((_QWORD *)a3 + 38))
    return;
  if (*((_QWORD *)a3 + 51) && *((_QWORD *)a3 + 27))
  {
    v18 = os_channel_advance_slot();
    if (!v18 || (v127 = v18, (nw_channel_check_defunct((uint64_t)a3) & 1) != 0))
    {
LABEL_25:
      *((_QWORD *)a3 + 51) = 0;
      goto LABEL_26;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
    v203 = 1024;
    *(_DWORD *)v204 = v127;
    v128 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v205) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v128, &v205, type))
    {
      if (v205 == 17)
      {
        v129 = __nwlog_obj();
        v130 = v205;
        if (!os_log_type_enabled(v129, (os_log_type_t)v205))
          goto LABEL_362;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v127;
        v131 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d";
        goto LABEL_361;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v129 = __nwlog_obj();
        v130 = v205;
        if (!os_log_type_enabled(v129, (os_log_type_t)v205))
          goto LABEL_362;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v127;
        v131 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_361;
      }
      v143 = (char *)__nw_create_backtrace_string();
      v129 = __nwlog_obj();
      v130 = v205;
      v144 = os_log_type_enabled(v129, (os_log_type_t)v205);
      if (v143)
      {
        if (v144)
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
          v203 = 1024;
          *(_DWORD *)v204 = v127;
          *(_WORD *)&v204[4] = 2082;
          *(_QWORD *)&v204[6] = v143;
          _os_log_impl(&dword_182FBE000, v129, v130, "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v143);
        goto LABEL_362;
      }
      if (v144)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_finalize_output_frame";
        v203 = 1024;
        *(_DWORD *)v204 = v127;
        v131 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, no backtrace";
LABEL_361:
        _os_log_impl(&dword_182FBE000, v129, v130, v131, buf, 0x12u);
      }
    }
LABEL_362:
    if (v128)
      free(v128);
    goto LABEL_25;
  }
LABEL_26:
  v19 = a3 + 222;
  v20 = a3[222];
  if ((v20 & 0x8000) != 0)
  {
    if (_nw_signposts_once != -1)
      dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
    if (_nw_signposts_enabled && kdebug_is_enabled())
      kdebug_trace();
    *((_BYTE *)a3 + 446) = ((unsigned __int16)*v19 | (*((unsigned __int8 *)a3 + 446) << 16) | 0x10000u) >> 16;
  }
  else
  {
    v21 = (v20 | (*((unsigned __int8 *)a3 + 446) << 16)) & 0xFFFEFFFF;
    *v19 = v20;
    *((_BYTE *)a3 + 446) = BYTE2(v21);
    if (*((_QWORD *)a3 + 17))
    {
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
      if (_nw_signposts_enabled && kdebug_is_enabled())
        kdebug_trace();
      if (os_channel_sync())
        nw_channel_check_defunct((uint64_t)a3);
    }
  }
  if ((*v19 & 0x200) != 0)
  {
    if ((*((_BYTE *)a1 + 186) & 3) == 1)
    {
      if (*((_QWORD *)a3 + 17))
      {
        if (*((_QWORD *)a3 + 27))
        {
          v198 = 0;
          *(_DWORD *)type = 0;
          v22 = *((_QWORD *)a3 + 46);
          while (v22)
          {
            v46 = v22;
            v22 = *(_QWORD *)(v22 + 40);
            v47 = *(_QWORD *)(v46 + 24);
            ce_count = os_channel_flow_adv_get_ce_count();
            if (ce_count)
            {
              if (ce_count == 6)
              {
                if (!gLogDatapath)
                  continue;
                v99 = __nwlog_obj();
                if (!os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
                  continue;
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v203 = 2082;
                *(_QWORD *)v204 = v46 + 84;
                v87 = v99;
                v88 = "%{public}s Channel doesn't support flow-advisory %{public}s";
LABEL_234:
                _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_DEBUG, v88, buf, 0x16u);
                continue;
              }
              if (ce_count != 22)
              {
                if (ce_count != 2)
                  continue;
                if (!gLogDatapath)
                  continue;
                v86 = __nwlog_obj();
                if (!os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
                  continue;
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v203 = 2082;
                *(_QWORD *)v204 = v46 + 84;
                v87 = v86;
                v88 = "%{public}s Flow advisory is not not valid for flow id %{public}s";
                goto LABEL_234;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              v65 = v46 + 84;
              *(_QWORD *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
              v203 = 2082;
              *(_QWORD *)v204 = v65;
              *(_WORD *)&v204[8] = 1024;
              *(_DWORD *)&v204[10] = 22;
              v66 = (const char *)_os_log_send_and_compose_impl();
              LOBYTE(v205) = 16;
              v201 = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v66, &v205, &v201))
                goto LABEL_230;
              if (v205 == 17)
              {
                v67 = __nwlog_obj();
                v68 = v205;
                log = v67;
                if (os_log_type_enabled(v67, (os_log_type_t)v205))
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                  v203 = 2082;
                  *(_QWORD *)v204 = v65;
                  *(_WORD *)&v204[8] = 1024;
                  *(_DWORD *)&v204[10] = 22;
                  v69 = log;
                  v70 = v68;
                  v71 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d";
                  goto LABEL_229;
                }
                goto LABEL_230;
              }
              if (v201)
              {
                v92 = (char *)__nw_create_backtrace_string();
                v183 = __nwlog_obj();
                v189 = v205;
                v93 = os_log_type_enabled(v183, (os_log_type_t)v205);
                if (v92)
                {
                  if (v93)
                  {
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                    v203 = 2082;
                    *(_QWORD *)v204 = v65;
                    *(_WORD *)&v204[8] = 1024;
                    *(_DWORD *)&v204[10] = 22;
                    *(_WORD *)&v204[14] = 2082;
                    *(_QWORD *)&v204[16] = v92;
                    _os_log_impl(&dword_182FBE000, v183, v189, "%{public}s Ring is not TX %{public}s %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
                  }
                  free(v92);
                  goto LABEL_230;
                }
                if (!v93)
                {
LABEL_230:
                  if (!v66)
                    continue;
                  v60 = (char *)v66;
                  goto LABEL_159;
                }
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v203 = 2082;
                *(_QWORD *)v204 = v65;
                *(_WORD *)&v204[8] = 1024;
                *(_DWORD *)&v204[10] = 22;
                v69 = v183;
                v70 = v189;
                v71 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d, no backtrace";
              }
              else
              {
                v97 = __nwlog_obj();
                v98 = v205;
                logc = v97;
                if (!os_log_type_enabled(v97, (os_log_type_t)v205))
                  goto LABEL_230;
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_channel_flows_adv_get_ce_count";
                v203 = 2082;
                *(_QWORD *)v204 = v65;
                *(_WORD *)&v204[8] = 1024;
                *(_DWORD *)&v204[10] = 22;
                v69 = logc;
                v70 = v98;
                v71 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d, backtrace limit exceeded";
              }
LABEL_229:
              _os_log_impl(&dword_182FBE000, v69, v70, v71, buf, 0x1Cu);
              goto LABEL_230;
            }
            if (*(_DWORD *)type)
              v49 = v198 == 0;
            else
              v49 = 1;
            if (v49)
              continue;
            v205 = __PAIR64__(v198, *(unsigned int *)type);
            if (v47)
            {
              v50 = *(void **)(v47 + 40);
              if (v50 == &nw_protocol_ref_counted_handle)
              {
                v51 = *(_QWORD *)(v47 + 88);
                if (v51)
                  *(_QWORD *)(v47 + 88) = v51 + 1;
              }
              v52 = (void *)*((_QWORD *)a3 + 8);
              if (v52 == &nw_protocol_ref_counted_handle)
              {
                v53 = *((_QWORD *)a3 + 14);
                if (v53)
                  *((_QWORD *)a3 + 14) = v53 + 1;
              }
              v54 = *(_QWORD *)(v47 + 24);
              if (v54)
              {
                v55 = *(void (**)(uint64_t, unsigned __int16 *, uint64_t, unint64_t *, uint64_t))(v54 + 160);
                if (v55)
                {
                  v55(v47, a3 + 12, 20, &v205, 8);
LABEL_147:
                  if (v52 == &nw_protocol_ref_counted_handle
                    && *((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
                  {
                    v61 = *((_QWORD *)a3 + 14);
                    if (v61)
                    {
                      v62 = v61 - 1;
                      *((_QWORD *)a3 + 14) = v62;
                      if (!v62)
                      {
                        v63 = (void (**)(_QWORD))*((_QWORD *)a3 + 11);
                        if (v63)
                        {
                          *((_QWORD *)a3 + 11) = 0;
                          v63[2](v63);
                          _Block_release(v63);
                        }
                        if ((a3[48] & 1) != 0)
                        {
                          v64 = (const void *)*((_QWORD *)a3 + 11);
                          if (v64)
                            _Block_release(v64);
                        }
                        free(a3 + 12);
                      }
                    }
                  }
                  if (v50 != &nw_protocol_ref_counted_handle)
                    continue;
                  if (*(_UNKNOWN **)(v47 + 40) != &nw_protocol_ref_counted_handle)
                    continue;
                  v56 = *(_QWORD *)(v47 + 88);
                  if (!v56)
                    continue;
                  v57 = v56 - 1;
                  *(_QWORD *)(v47 + 88) = v57;
                  if (v57)
                    continue;
                  v58 = *(void (***)(_QWORD))(v47 + 64);
                  if (v58)
                  {
                    *(_QWORD *)(v47 + 64) = 0;
                    v58[2](v58);
                    _Block_release(v58);
                  }
                  if ((*(_BYTE *)(v47 + 72) & 1) != 0)
                  {
                    v59 = *(const void **)(v47 + 64);
                    if (v59)
                      _Block_release(v59);
                  }
                  v60 = (char *)v47;
                  goto LABEL_159;
                }
              }
              __nwlog_obj();
              v72 = *(const char **)(v47 + 16);
              if (!v72)
                v72 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_notify";
              v203 = 2082;
              *(_QWORD *)v204 = v72;
              *(_WORD *)&v204[8] = 2048;
              *(_QWORD *)&v204[10] = v47;
              v73 = (const char *)_os_log_send_and_compose_impl();
              v201 = OS_LOG_TYPE_ERROR;
              v200 = 0;
              loga = (os_log_t)v73;
              if (!__nwlog_fault(v73, &v201, &v200))
                goto LABEL_216;
              if (v201 == OS_LOG_TYPE_FAULT)
              {
                v185 = __nwlog_obj();
                v180 = v201;
                if (os_log_type_enabled(v185, v201))
                {
                  v74 = *(const char **)(v47 + 16);
                  if (!v74)
                    v74 = "invalid";
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                  v203 = 2082;
                  *(_QWORD *)v204 = v74;
                  *(_WORD *)&v204[8] = 2048;
                  *(_QWORD *)&v204[10] = v47;
                  v75 = v185;
                  v76 = v180;
                  v77 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
                  goto LABEL_215;
                }
                goto LABEL_216;
              }
              if (v200)
              {
                v186 = (char *)__nw_create_backtrace_string();
                v181 = __nwlog_obj();
                v179 = v201;
                v84 = os_log_type_enabled(v181, v201);
                if (v186)
                {
                  if (v84)
                  {
                    v85 = *(const char **)(v47 + 16);
                    if (!v85)
                      v85 = "invalid";
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                    v203 = 2082;
                    *(_QWORD *)v204 = v85;
                    *(_WORD *)&v204[8] = 2048;
                    *(_QWORD *)&v204[10] = v47;
                    *(_WORD *)&v204[18] = 2082;
                    *(_QWORD *)&v204[20] = v186;
                    _os_log_impl(&dword_182FBE000, v181, v179, "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }
                  free(v186);
                  goto LABEL_216;
                }
                if (!v84)
                {
LABEL_216:
                  if (loga)
                    free(loga);
                  goto LABEL_147;
                }
                v94 = *(const char **)(v47 + 16);
                if (!v94)
                  v94 = "invalid";
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                v203 = 2082;
                *(_QWORD *)v204 = v94;
                *(_WORD *)&v204[8] = 2048;
                *(_QWORD *)&v204[10] = v47;
                v75 = v181;
                v76 = v179;
                v77 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
              }
              else
              {
                v188 = __nwlog_obj();
                v182 = v201;
                if (!os_log_type_enabled(v188, v201))
                  goto LABEL_216;
                v91 = *(const char **)(v47 + 16);
                if (!v91)
                  v91 = "invalid";
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                v203 = 2082;
                *(_QWORD *)v204 = v91;
                *(_WORD *)&v204[8] = 2048;
                *(_QWORD *)&v204[10] = v47;
                v75 = v188;
                v76 = v182;
                v77 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
              }
LABEL_215:
              _os_log_impl(&dword_182FBE000, v75, v76, v77, buf, 0x20u);
              goto LABEL_216;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_notify";
            v78 = (const char *)_os_log_send_and_compose_impl();
            v201 = OS_LOG_TYPE_ERROR;
            v200 = 0;
            if (__nwlog_fault(v78, &v201, &v200))
            {
              if (v201 == OS_LOG_TYPE_FAULT)
              {
                v79 = __nwlog_obj();
                v80 = v201;
                if (os_log_type_enabled(v79, v201))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                  v81 = v79;
                  v82 = v80;
                  v83 = "%{public}s called with null protocol";
LABEL_222:
                  _os_log_impl(&dword_182FBE000, v81, v82, v83, buf, 0xCu);
                }
              }
              else if (v200)
              {
                v89 = (char *)__nw_create_backtrace_string();
                logb = __nwlog_obj();
                v187 = v201;
                v90 = os_log_type_enabled(logb, v201);
                if (v89)
                {
                  if (v90)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                    v203 = 2082;
                    *(_QWORD *)v204 = v89;
                    _os_log_impl(&dword_182FBE000, logb, v187, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }
                  free(v89);
                  goto LABEL_223;
                }
                if (v90)
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                  v81 = logb;
                  v82 = v187;
                  v83 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_222;
                }
              }
              else
              {
                v95 = __nwlog_obj();
                v96 = v201;
                if (os_log_type_enabled(v95, v201))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "__nw_protocol_notify";
                  v81 = v95;
                  v82 = v96;
                  v83 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_222;
                }
              }
            }
LABEL_223:
            if (!v78)
              continue;
            v60 = (char *)v78;
LABEL_159:
            free(v60);
          }
        }
      }
    }
    if (*((_QWORD *)a3 + 17))
    {
      if (*((_QWORD *)a3 + 27))
      {
        v100 = *((_QWORD *)a3 + 46);
        if (v100)
        {
          do
          {
            v102 = *(_QWORD *)(v100 + 40);
            v103 = *(_QWORD *)(v100 + 24);
            v104 = os_channel_flow_admissible();
            if (v104)
            {
              v106 = v104;
              if (v104 == 55)
              {
                if (nw_link_set_flow_control_status(*(void **)(v100 + 72), 1))
                {
                  v107 = __nwlog_obj();
                  if (os_log_type_enabled(v107, OS_LOG_TYPE_INFO))
                  {
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_channel_check_flows_controlled";
                    v203 = 2082;
                    *(_QWORD *)v204 = v100 + 84;
                    _os_log_impl(&dword_182FBE000, v107, OS_LOG_TYPE_INFO, "%{public}s Flow controlled for flow id %{public}s", buf, 0x16u);
                  }
                }
                if (v103)
                {
                  v108 = *(_QWORD *)(v103 + 24);
                  if (v108)
                  {
                    v109 = *(void (**)(uint64_t, unsigned __int16 *))(v108 + 104);
                    if (v109 && *(_QWORD *)(v100 + 72) != 0)
                    {
                      if (*(_UNKNOWN **)(v103 + 40) == &nw_protocol_ref_counted_handle)
                      {
                        v118 = *(_QWORD *)(v103 + 88);
                        if (v118)
                          *(_QWORD *)(v103 + 88) = v118 + 1;
                        *(_QWORD *)buf = v103;
                        v111 = buf[8] | 1;
                      }
                      else
                      {
                        *(_QWORD *)buf = v103;
                        v111 = buf[8] & 0xFE;
                      }
                      buf[8] = v111;
                      if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
                      {
                        v120 = *((_QWORD *)a3 + 14);
                        if (v120)
                          *((_QWORD *)a3 + 14) = v120 + 1;
                        v205 = (unint64_t)(a3 + 12);
                        v119 = v206 | 1;
                      }
                      else
                      {
                        v205 = (unint64_t)(a3 + 12);
                        v119 = v206 & 0xFE;
                      }
                      LOBYTE(v206) = v119;
                      v109(v103, a3 + 12);
                      nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)&v205);
                      nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)buf);
                    }
                  }
                }
                *(_QWORD *)(v100 + 56) = 0;
                v121 = (uint64_t *)*((_QWORD *)a3 + 49);
                *(_QWORD *)(v100 + 64) = v121;
                *v121 = v100;
                *((_QWORD *)a3 + 49) = v100 + 56;
                *(_BYTE *)(v100 + 121) |= 2u;
              }
              else if (v104 == 2)
              {
                if (gLogDatapath)
                {
                  v126 = __nwlog_obj();
                  if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_channel_check_flows_controlled";
                    v203 = 2082;
                    *(_QWORD *)v204 = v100 + 84;
                    _os_log_impl(&dword_182FBE000, v126, OS_LOG_TYPE_DEBUG, "%{public}s Flow(%{public}s) is no longer present, disconnecting", buf, 0x16u);
                  }
                }
                nw_channel_disconnect_flow((uint64_t)a3, v100);
              }
              else if ((nw_channel_check_defunct((uint64_t)a3) & 1) == 0)
              {
                __nwlog_obj();
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_channel_check_flows_controlled";
                v203 = 2082;
                *(_QWORD *)v204 = v100 + 84;
                *(_WORD *)&v204[8] = 1024;
                *(_DWORD *)&v204[10] = v106;
                v112 = (const char *)_os_log_send_and_compose_impl();
                LOBYTE(v205) = 16;
                type[0] = OS_LOG_TYPE_DEFAULT;
                v197 = (char *)v112;
                if (!__nwlog_fault(v112, &v205, type))
                  goto LABEL_286;
                if (v205 == 17)
                {
                  v113 = __nwlog_obj();
                  v114 = v205;
                  *(_QWORD *)v190 = v113;
                  if (os_log_type_enabled(v113, (os_log_type_t)v205))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "nw_channel_check_flows_controlled";
                    v203 = 2082;
                    v115 = *(NSObject **)v190;
                    *(_QWORD *)v204 = v100 + 84;
                    *(_WORD *)&v204[8] = 1024;
                    *(_DWORD *)&v204[10] = v106;
                    v116 = v114;
                    v117 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d";
                    goto LABEL_285;
                  }
                  goto LABEL_286;
                }
                if (type[0])
                {
                  v122 = (char *)__nw_create_backtrace_string();
                  v191 = __nwlog_obj();
                  v184 = v205;
                  v123 = os_log_type_enabled(v191, (os_log_type_t)v205);
                  if (v122)
                  {
                    if (v123)
                    {
                      *(_DWORD *)buf = 136446978;
                      *(_QWORD *)&buf[4] = "nw_channel_check_flows_controlled";
                      v203 = 2082;
                      *(_QWORD *)v204 = v100 + 84;
                      *(_WORD *)&v204[8] = 1024;
                      *(_DWORD *)&v204[10] = v106;
                      *(_WORD *)&v204[14] = 2082;
                      *(_QWORD *)&v204[16] = v122;
                      _os_log_impl(&dword_182FBE000, v191, v184, "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
                    }
                    free(v122);
                    goto LABEL_286;
                  }
                  if (!v123)
                  {
LABEL_286:
                    if (v197)
                      free(v197);
                    goto LABEL_243;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_channel_check_flows_controlled";
                  v203 = 2082;
                  v115 = v191;
                  *(_QWORD *)v204 = v100 + 84;
                  *(_WORD *)&v204[8] = 1024;
                  *(_DWORD *)&v204[10] = v106;
                  v116 = v184;
                  v117 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, no backtrace";
                }
                else
                {
                  v124 = __nwlog_obj();
                  v125 = v205;
                  *(_QWORD *)v192 = v124;
                  if (!os_log_type_enabled(v124, (os_log_type_t)v205))
                    goto LABEL_286;
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_channel_check_flows_controlled";
                  v203 = 2082;
                  v115 = *(NSObject **)v192;
                  *(_QWORD *)v204 = v100 + 84;
                  *(_WORD *)&v204[8] = 1024;
                  *(_DWORD *)&v204[10] = v106;
                  v116 = v125;
                  v117 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, backtrace limit exceeded";
                }
LABEL_285:
                _os_log_impl(&dword_182FBE000, v115, v116, v117, buf, 0x1Cu);
                goto LABEL_286;
              }
            }
LABEL_243:
            if ((*(_BYTE *)(v100 + 121) & 1) != 0)
            {
              v105 = *(_QWORD *)(v100 + 40);
              v101 = *(_QWORD **)(v100 + 48);
              if (v105)
              {
                *(_QWORD *)(v105 + 48) = v101;
                v101 = *(_QWORD **)(v100 + 48);
              }
              else
              {
                *((_QWORD *)a3 + 47) = v101;
              }
              *v101 = v105;
              *(_BYTE *)(v100 + 121) &= ~1u;
            }
            v100 = v102;
          }
          while (v102);
        }
      }
    }
  }
}

BOOL nw_hash_table_get_node(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t *v7;
  uint64_t *v8;
  _BOOL8 result;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  void *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  char *backtrace_string;
  uint64_t v27;
  _BOOL4 v28;
  const char *v29;
  uint64_t v30;
  _BOOL4 v31;
  char *v32;
  uint64_t v33;
  _BOOL4 v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj(0, a2);
    *(_DWORD *)buf = 136446210;
    v38 = "nw_hash_table_get_node";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    v11 = __nwlog_fault(v10, &type, &v35);
    if (!(_DWORD)v11)
      goto LABEL_56;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        v13 = __nwlog_obj(v11, v12);
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_56;
        *(_DWORD *)buf = 136446210;
        v38 = "nw_hash_table_get_node";
        v15 = "%{public}s called with null table, backtrace limit exceeded";
        goto LABEL_55;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj(backtrace_string, v27);
      v14 = type;
      v28 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v28)
          goto LABEL_56;
        *(_DWORD *)buf = 136446210;
        v38 = "nw_hash_table_get_node";
        v15 = "%{public}s called with null table, no backtrace";
        goto LABEL_55;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        v38 = "nw_hash_table_get_node";
        v39 = 2082;
        v40 = backtrace_string;
        v29 = "%{public}s called with null table, dumping backtrace:%{public}s";
LABEL_38:
        _os_log_impl(&dword_182FBE000, v13, v14, v29, buf, 0x16u);
      }
LABEL_39:
      free(backtrace_string);
      goto LABEL_56;
    }
    v13 = __nwlog_obj(v11, v12);
    v14 = type;
    if (!os_log_type_enabled(v13, type))
      goto LABEL_56;
    *(_DWORD *)buf = 136446210;
    v38 = "nw_hash_table_get_node";
    v15 = "%{public}s called with null table";
LABEL_55:
    _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
LABEL_56:
    if (v10)
      free(v10);
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj(a1, 0);
    *(_DWORD *)buf = 136446210;
    v38 = "nw_hash_table_get_node";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    v16 = __nwlog_fault(v10, &type, &v35);
    if (!(_DWORD)v16)
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj(v16, v17);
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v38 = "nw_hash_table_get_node";
      v15 = "%{public}s called with null key";
      goto LABEL_55;
    }
    if (!v35)
    {
      v13 = __nwlog_obj(v16, v17);
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v38 = "nw_hash_table_get_node";
      v15 = "%{public}s called with null key, backtrace limit exceeded";
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj(backtrace_string, v30);
    v14 = type;
    v31 = os_log_type_enabled(v13, type);
    if (backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        v38 = "nw_hash_table_get_node";
        v39 = 2082;
        v40 = backtrace_string;
        v29 = "%{public}s called with null key, dumping backtrace:%{public}s";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v31)
      goto LABEL_56;
    *(_DWORD *)buf = 136446210;
    v38 = "nw_hash_table_get_node";
    v15 = "%{public}s called with null key, no backtrace";
    goto LABEL_55;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v18 = __nwlog_obj(a1, a2);
  os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v38 = "nw_hash_table_lock";
  v19 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v19);
  if (!result)
  {
    free(v19);
    v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_6:
      if ((v6 & 1) != 0)
      {
        v7 = *(uint64_t **)(a1
                         + 16
                         * ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 8))(a2, a3) % *(_DWORD *)(a1 + 32))
                         + 56);
        if (v7)
        {
          do
          {
            v8 = (uint64_t *)*v7;
            if (*((_BYTE *)v7 + 30) == 1
              && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 16))(v7[2], a2, a3) & 1) != 0)
            {
              break;
            }
            v7 = v8;
          }
          while (v8);
        }
        if ((*(_BYTE *)(a1 + 48) & 2) != 0)
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        return (BOOL)v7;
      }
      __nwlog_obj(a1, a2);
      *(_DWORD *)buf = 136446210;
      v38 = "nw_hash_table_get_node";
      v20 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v35 = 0;
      v21 = __nwlog_fault(v20, &type, &v35);
      if ((_DWORD)v21)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v23 = __nwlog_obj(v21, v22);
          v24 = type;
          if (!os_log_type_enabled(v23, type))
            goto LABEL_61;
          *(_DWORD *)buf = 136446210;
          v38 = "nw_hash_table_get_node";
          v25 = "%{public}s called with invalid hash table";
LABEL_60:
          _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0xCu);
          goto LABEL_61;
        }
        if (!v35)
        {
          v23 = __nwlog_obj(v21, v22);
          v24 = type;
          if (!os_log_type_enabled(v23, type))
            goto LABEL_61;
          *(_DWORD *)buf = 136446210;
          v38 = "nw_hash_table_get_node";
          v25 = "%{public}s called with invalid hash table, backtrace limit exceeded";
          goto LABEL_60;
        }
        v32 = (char *)__nw_create_backtrace_string();
        v23 = __nwlog_obj(v32, v33);
        v24 = type;
        v34 = os_log_type_enabled(v23, type);
        if (!v32)
        {
          if (!v34)
            goto LABEL_61;
          *(_DWORD *)buf = 136446210;
          v38 = "nw_hash_table_get_node";
          v25 = "%{public}s called with invalid hash table, no backtrace";
          goto LABEL_60;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v38 = "nw_hash_table_get_node";
          v39 = 2082;
          v40 = v32;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v32);
      }
LABEL_61:
      if (v20)
        free(v20);
      if ((*(_BYTE *)(a1 + 48) & 2) != 0)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        return 0;
      }
      return 0;
    }
LABEL_5:
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
    v6 = *(_DWORD *)(a1 + 48);
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

uint64_t nw_channel_set_internet_checksum_handler(nw_frame *a1)
{
  uint64_t metadata;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  metadata = nw_frame_get_metadata((uint64_t)a1);
  if (metadata)
  {
    if ((*(_BYTE *)(metadata + 24) & 1) != 0)
      return os_packet_set_inet_checksum();
    else
      return 45;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_channel_set_internet_checksum_handler";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_channel_set_internet_checksum_handler";
        v6 = "%{public}s called with null frame_info";
LABEL_18:
        _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
      }
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v12 = "nw_channel_set_internet_checksum_handler";
          v13 = 2082;
          v14 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null frame_info, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_channel_set_internet_checksum_handler";
        v6 = "%{public}s called with null frame_info, no backtrace";
        goto LABEL_18;
      }
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_channel_set_internet_checksum_handler";
        v6 = "%{public}s called with null frame_info, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if (v3)
    free(v3);
  return 22;
}

uint64_t nw_channel_get_internet_checksum_handler(nw_frame *a1, BOOL *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t metadata;
  __int16 inet_checksum;
  uint64_t result;
  char *v11;
  int v12;
  unsigned int v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  char *backtrace_string;
  _BOOL4 v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  metadata = nw_frame_get_metadata((uint64_t)a1);
  if (a4 && a3 && a2 && metadata)
  {
    if ((*(_BYTE *)(metadata + 24) & 1) == 0)
      return 45;
    inet_checksum = os_packet_get_inet_checksum();
    result = 0;
    *a2 = inet_checksum & 1;
    v12 = *((unsigned __int16 *)a1 + 102);
    v11 = (char *)a1 + 204;
    v13 = v12 & 0xFFFFE1FF | (v11[2] << 16);
    *(_WORD *)v11 = v12 & 0xE1FF | (2 * inet_checksum) & 0x1E00;
    v11[2] = BYTE2(v13);
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_channel_get_internet_checksum_handler";
  v14 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v14, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_channel_get_internet_checksum_handler";
        v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL)";
LABEL_22:
        _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_channel_get_internet_checksum_handler";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && checksum_value != NULL), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_23;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_channel_get_internet_checksum_handler";
        v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL), no backtrace";
        goto LABEL_22;
      }
    }
    else
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_channel_get_internet_checksum_handler";
        v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL), backtrace limit exceeded";
        goto LABEL_22;
      }
    }
  }
LABEL_23:
  if (v14)
    free(v14);
  return 22;
}

uint64_t nw_frame_get_metadata(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 4) != 0)
      return a1 + 208;
    else
      return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_get_metadata";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_get_metadata";
        v5 = "%{public}s called with null frame";
LABEL_19:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "__nw_frame_get_metadata";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_get_metadata";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_19;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_get_metadata";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }
LABEL_20:
  if (v2)
    free(v2);
  return 0;
}

uint64_t nw_frame_effective_length(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(unsigned int *)(a1 + 52);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_effective_length";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_effective_length";
        v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "__nw_frame_effective_length";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_effective_length";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_effective_length";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

BOOL nw_flow_protocol_matches_key(char *a1, const void *a2, int a3)
{
  uint64_t v3;

  v3 = 240;
  if (!a3)
    v3 = 248;
  return *(_QWORD *)&a1[v3] == (_QWORD)a2;
}

BOOL stream_matches_key(_DWORD *a1, _DWORD *a2)
{
  return a1[8] == *a2;
}

uint64_t stream_key_hash(unsigned int *a1, int a2)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a2 == 4)
    return *a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v13 = "stream_key_hash";
  v14 = 1024;
  v15 = a2;
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v13 = "stream_key_hash";
        v14 = 1024;
        v15 = a2;
        v7 = "%{public}s stream_key_hash called with invalid key_length %u";
LABEL_16:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0x12u);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          v13 = "stream_key_hash";
          v14 = 1024;
          v15 = a2;
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s stream_key_hash called with invalid key_length %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_17;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v13 = "stream_key_hash";
        v14 = 1024;
        v15 = a2;
        v7 = "%{public}s stream_key_hash called with invalid key_length %u, no backtrace";
        goto LABEL_16;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v13 = "stream_key_hash";
        v14 = 1024;
        v15 = a2;
        v7 = "%{public}s stream_key_hash called with invalid key_length %u, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }
LABEL_17:
  if (v4)
    free(v4);
  return 0;
}

{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a2 == 4)
    return *a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v13 = "stream_key_hash";
  v14 = 1024;
  v15 = a2;
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v13 = "stream_key_hash";
        v14 = 1024;
        v15 = a2;
        v7 = "%{public}s stream_key_hash called with invalid key_length %u";
LABEL_16:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0x12u);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          v13 = "stream_key_hash";
          v14 = 1024;
          v15 = a2;
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s stream_key_hash called with invalid key_length %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_17;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v13 = "stream_key_hash";
        v14 = 1024;
        v15 = a2;
        v7 = "%{public}s stream_key_hash called with invalid key_length %u, no backtrace";
        goto LABEL_16;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v13 = "stream_key_hash";
        v14 = 1024;
        v15 = a2;
        v7 = "%{public}s stream_key_hash called with invalid key_length %u, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }
LABEL_17:
  if (v4)
    free(v4);
  return 0;
}

const char *__cdecl nw_interface_get_name(nw_interface_t interface)
{
  if (interface)
    return (const char *)&interface[13];
  else
    return 0;
}

BOOL nw_path_copy_description(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v4;
  size_t v5;
  char *v6;
  id v7;
  void *v8;
  NSObject *v9;
  os_log_type_t v10;
  id v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  _BOOL8 result;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  uint8_t *v27;
  uint64_t v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  size_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(v1, "description");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_path_copy_description";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v6, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_path_copy_description";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s [path description] failed", buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_path_copy_description";
            v33 = 2082;
            v34 = (size_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s [path description] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v6)
            goto LABEL_42;
          goto LABEL_41;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_path_copy_description";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s [path description] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_path_copy_description";
          _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s [path description] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v6)
    {
LABEL_42:
      v6 = 0;
      goto LABEL_43;
    }
LABEL_41:
    free(v6);
    goto LABEL_42;
  }
  v4 = objc_msgSend(v2, "lengthOfBytesUsingEncoding:", 4);
  v5 = v4 + 1;
  if (v4 == -1)
  {
    __nwlog_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v32 = "strict_malloc";
    LODWORD(v28) = 12;
    v27 = buf;
    v24 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v24);
    if (result)
      goto LABEL_51;
    free(v24);
  }
  v6 = (char *)malloc_type_malloc(v5, 0xF2B69DE5uLL);
  if (v6)
    goto LABEL_4;
  __nwlog_obj();
  v25 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v32 = "strict_malloc";
  v33 = 2048;
  v34 = v5;
  LODWORD(v28) = 22;
  v27 = buf;
  v26 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
LABEL_4:
    if ((objc_msgSend(v3, "getCString:maxLength:encoding:", v6, v5, 4, v27, v28) & 1) != 0)
    {
LABEL_43:

      return (BOOL)v6;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_path_copy_description";
    v8 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault((const char *)v8, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_path_copy_description";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s [desc getCString:maxLength:encoding:] failed", buf, 0xCu);
        }
      }
      else if (v29)
      {
        v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v18 = type;
        v19 = os_log_type_enabled(v9, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_path_copy_description";
            v33 = 2082;
            v34 = (size_t)v17;
            _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s [desc getCString:maxLength:encoding:] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v17);
          if (!v8)
          {
LABEL_12:
            if (!v6)
              goto LABEL_43;
            goto LABEL_41;
          }
LABEL_11:
          free(v8);
          goto LABEL_12;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_path_copy_description";
          _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s [desc getCString:maxLength:encoding:] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_path_copy_description";
          _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s [desc getCString:maxLength:encoding:] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v8)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_51:
  __break(1u);
  return result;
}

void sub_182FD0DB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_182FD1F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,id a60,char a61,uint64_t a62,uint64_t a63)
{
  char a65;
  void *v65;
  void *v66;
  uint64_t v67;

  _Block_object_dispose(&a61, 8);
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose((const void *)(v67 - 184), 8);
  _Block_object_dispose((const void *)(v67 - 152), 8);

  _Block_object_dispose(&a55, 8);
  _Unwind_Resume(a1);
}

BOOL nw_path_uses_interface_type(nw_path_t path, nw_interface_type_t interface_type)
{
  nw_path_t v3;
  nw_path_t v4;
  BOOL v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  int isa;
  char v11;
  int isa_high;
  Class v13;
  objc_class *v14;
  int v15;
  Class v16;
  objc_class *v17;
  int v18;
  Class v19;
  objc_class *v20;
  int v21;
  void *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = path;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_path_uses_interface_type";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v24, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v34 = "nw_path_uses_interface_type";
            v35 = 2082;
            v36 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_182FBE000, v25, v30, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_44:
    if (v24)
      free(v24);
    v5 = 0;
    goto LABEL_25;
  }
  if (interface_type != nw_interface_type_cellular)
  {
    if (interface_type == nw_interface_type_wifi && (BYTE3(v3[59].isa) & 0x40) != 0)
    {
      v5 = 1;
      goto LABEL_25;
    }
    v5 = 0;
LABEL_7:
    v6 = nw_path_copy_connected_interface(v3);
    v7 = v6;
    if (v6)
    {
      v8 = v6;
      v9 = *((_DWORD *)v8 + 24);

      if (v9 == interface_type)
        goto LABEL_23;
    }
    isa = (int)v4[47].isa;
    v11 = !v5;
    if (isa != 3)
      v11 = 1;
    if ((v11 & 1) == 0)
    {
      if (nw_path_has_unsatisfied_cellular_agent(v4, 0))
        goto LABEL_23;
      isa = (int)v4[47].isa;
    }
    if (isa != 1)
    {
      v5 = 0;
      isa_high = HIDWORD(v4[47].isa);
      if (isa_high == 4 || isa_high == 30)
        goto LABEL_24;
    }
    v13 = v4[12].isa;
    if (!v13 || (v14 = v13, v15 = *((_DWORD *)v14 + 24), v14, v15 != interface_type))
    {
      v16 = v4[13].isa;
      if (!v16 || (v17 = v16, v18 = *((_DWORD *)v17 + 24), v17, v18 != interface_type))
      {
        v19 = v4[14].isa;
        if (!v19 || (v20 = v19, v21 = *((_DWORD *)v20 + 24), v20, v21 != interface_type))
        {
          v5 = 0;
          goto LABEL_24;
        }
      }
    }
LABEL_23:
    v5 = 1;
LABEL_24:

    goto LABEL_25;
  }
  v5 = 1;
  if ((SBYTE3(v3[59].isa) & 0x80000000) == 0)
    goto LABEL_7;
LABEL_25:

  return v5;
}

void sub_182FD23CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_path_should_fallback(void *a1, char a2)
{
  void **v3;
  void **v4;
  _BOOL8 v5;
  void **v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_path_should_fallback";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_path_should_fallback";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_32:
    if (v9)
      free(v9);
    goto LABEL_6;
  }
  if ((a2 & 1) == 0
    && ((*((_BYTE *)v3 + 473) & 8) == 0 && (nw_parameters_get_no_fallback(v3[2]) & 1) != 0
     || (nw_parameters_get_fallback_applied(v4[2]) & 1) != 0))
  {
LABEL_6:
    v5 = 0;
    goto LABEL_15;
  }
  if (v4[14] || v4[21] && v4[22])
  {
    v5 = 1;
  }
  else
  {
    v6 = v4;
    if (nw_path_allows_multipath(v6))
      v5 = nw_parameters_multipath_fallback_allowed(v6[2]);
    else
      v5 = 0;

  }
LABEL_15:

  return v5;
}

void sub_182FD26E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_no_fallback(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 108) >> 5) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_no_fallback";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_no_fallback";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_fallback_applied(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 108) >> 11) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_fallback_applied";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_fallback_applied";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_stack_iterate_application_protocols(nw_protocol_stack_t stack, nw_protocol_stack_iterate_protocols_block_t iterate_block)
{
  nw_protocol_stack_t v3;
  nw_protocol_stack_iterate_protocols_block_t v4;
  void *v5;
  unsigned __int8 *isa;
  uint64_t v7;
  id v8;
  unsigned __int8 *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _QWORD v18[4];
  id v19;
  _QWORD v20[4];
  id v21;
  char v22;
  os_log_type_t v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = stack;
  v4 = iterate_block;
  v5 = v4;
  if (v3)
  {
    isa = (unsigned __int8 *)v3[1].isa;
    v7 = MEMORY[0x1E0C809B0];
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __nw_protocol_stack_iterate_application_protocols_block_invoke;
    v20[3] = &unk_1E14AC278;
    v8 = v4;
    v21 = v8;
    nw_array_apply(isa, (uint64_t)v20);
    v9 = (unsigned __int8 *)v3[2].isa;
    v18[0] = v7;
    v18[1] = 3221225472;
    v18[2] = __nw_protocol_stack_iterate_application_protocols_block_invoke_2;
    v18[3] = &unk_1E14AC278;
    v19 = v8;
    nw_array_apply(v9, (uint64_t)v18);

    goto LABEL_3;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_protocol_stack_iterate_application_protocols";
  v11 = (char *)_os_log_send_and_compose_impl();

  v23 = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (__nwlog_fault(v11, &v23, &v22))
  {
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = v23;
      if (os_log_type_enabled(v12, v23))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_stack_iterate_application_protocols";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = v23;
      v16 = os_log_type_enabled(v12, v23);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_stack_iterate_application_protocols";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_stack_iterate_application_protocols";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = v23;
      if (os_log_type_enabled(v12, v23))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_stack_iterate_application_protocols";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v11)
    free(v11);
LABEL_3:

}

unsigned __int8 *nw_path_copy_connected_interface(void *a1)
{
  unsigned __int8 **v1;
  unsigned __int8 **v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  _QWORD v15[5];
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v19)(uint64_t, uint64_t);
  void (*v20)(uint64_t);
  id v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[11];
    if (v3)
    {
      v4 = v3;
    }
    else
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v19 = __Block_byref_object_copy__67271;
      v20 = __Block_byref_object_dispose__67272;
      v21 = 0;
      v5 = v1[9];
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 3221225472;
      v15[2] = __nw_path_copy_connected_interface_block_invoke;
      v15[3] = &unk_1E14A8DC0;
      v15[4] = buf;
      nw_array_apply(v5, (uint64_t)v15);
      v4 = (unsigned __int8 *)*(id *)(*(_QWORD *)&buf[8] + 40);
      _Block_object_dispose(buf, 8);

    }
    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_path_copy_connected_interface";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_copy_connected_interface";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  v4 = 0;
LABEL_5:

  return v4;
}

BOOL nw_array_apply(unsigned __int8 *object, uint64_t a2)
{
  unsigned __int8 *v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  _BOOL8 result;
  NSObject *v11;
  void *v12;
  NSObject *v13;

  if (!object)
    return 1;
  v4 = object + 40;
  do
    v5 = __ldxr(v4);
  while (__stxr(v5 + 1, v4));
  if (v5 == 255)
  {
    v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    v12 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v12);
    if (!result)
    {
      v8 = 0;
LABEL_18:
      free(v12);
      return v8;
    }
  }
  else
  {
    os_retain(object);
    v6 = *((_QWORD *)object + 2);
    if (*((_QWORD *)object + 3) == v6)
    {
      v8 = 1;
    }
    else
    {
      v7 = 0;
      do
      {
        v8 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(a2 + 16))(a2, v7, *(_QWORD *)(v6 + 8 * v7));
        if ((v8 & 1) == 0)
          break;
        ++v7;
        v6 = *((_QWORD *)object + 2);
      }
      while (v7 < (*((_QWORD *)object + 3) - v6) >> 3);
    }
    do
      v9 = __ldxr(v4);
    while (__stlxr(v9 - 1, v4));
    os_release(object);
    if (v9)
      return v8;
    v13 = __nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    v12 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v12);
    if (!result)
      goto LABEL_18;
  }
  __break(1u);
  return result;
}

uint64_t __nw_path_copy_connected_interface_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  void *v6;
  uint64_t v7;

  v4 = a3;
  v5 = v4;
  v6 = (void *)*((_QWORD *)v4 + 2);
  if (v6 && (*((_BYTE *)v4 + 185) & 1) != 0)
  {
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v6);
    v7 = 0;
  }
  else
  {
    v7 = 1;
  }

  return v7;
}

uint64_t __nw_path_copy_for_flow_registration_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  unsigned __int8 *v7;
  _QWORD v9[4];
  _QWORD *v10;
  id v11;
  _QWORD *v12;

  v4 = a3;
  v5 = v4;
  v6 = *(_QWORD *)(a1 + 32);
  if (v4[18] == *(_QWORD *)(v6 + 32) && v4[19] == *(_QWORD *)(v6 + 40) && (*(_BYTE *)(v6 + 149) & 1) == 0)
  {
    nw_array_append(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 72), v4);
  }
  else
  {
    v7 = *(unsigned __int8 **)(v6 + 16);
    if (v7)
    {
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 3221225472;
      v9[2] = __nw_path_copy_for_flow_registration_block_invoke_3;
      v9[3] = &unk_1E14AA9F0;
      v10 = v4;
      v11 = *(id *)(a1 + 40);
      v12 = v10;
      nw_array_apply(v7, (uint64_t)v9);

    }
  }

  return 1;
}

uint64_t __nw_protocol_stack_copy_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3;
  NWConcrete_nw_protocol_options *v4;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  v4 = nw_protocol_options_copy(a3);
  nw_array_append(v3, v4);

  return 1;
}

void nw_array_append(uint64_t a1, void *object)
{
  uint64_t v4;
  void *v5;
  void **v6;
  _QWORD *v7;

  if (a1 && object)
  {
    if (atomic_load((unsigned __int8 *)(a1 + 40)))
    {
      v4 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v4);
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      v5 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v5))
        __break(1u);
      else
        free(v5);
    }
    else
    {
      v6 = *(void ***)(a1 + 24);
      if ((unint64_t)v6 >= *(_QWORD *)(a1 + 32))
      {
        v7 = std::vector<nw_object_wrapper_t>::__emplace_back_slow_path<nw_object *&>(a1 + 16, object);
      }
      else
      {
        *v6 = os_retain(object);
        v7 = v6 + 1;
      }
      *(_QWORD *)(a1 + 24) = v7;
    }
  }
}

uint64_t __nw_content_context_set_metadata_for_protocol_block_invoke(_QWORD *a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  nw_protocol_definition_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;

  v5 = a3;
  v6 = a1[4];
  if (v6 == v5)
  {
    v11 = 0;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
  }
  else
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40);
    if (!v7)
    {
      v8 = nw_protocol_metadata_copy_definition(v6);
      v9 = *(_QWORD *)(a1[6] + 8);
      v10 = *(void **)(v9 + 40);
      *(_QWORD *)(v9 + 40) = v8;

      v7 = *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40);
    }
    if (nw_protocol_metadata_matches_definition((uint64_t)v5, v7))
    {
      objc_storeStrong((id *)(*(_QWORD *)(a1[7] + 8) + 40), a3);
      v11 = 0;
    }
    else
    {
      v11 = 1;
    }
  }

  return v11;
}

void sub_182FD3820(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_flow_copy_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  nw_protocol_definition_t v6;

  v5 = a3;
  v6 = nw_protocol_metadata_copy_definition(v5);
  if (nw_protocol_definition_is_equal_unsafe(*(_QWORD *)(a1 + 32), (uint64_t)v6))
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);

  return 1;
}

void sub_182FD38A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

nw_protocol_definition_t nw_protocol_metadata_copy_definition(nw_protocol_metadata_t metadata)
{
  nw_protocol_metadata_t v1;
  nw_protocol_metadata_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = metadata;
  v2 = v1;
  if (v1)
  {
    v3 = v1[1].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_metadata_copy_definition";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_metadata_copy_definition";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

NWConcrete_nw_protocol_transform *nw_protocol_transform_copy(void *a1)
{
  unsigned __int8 *v1;
  NWConcrete_nw_protocol_transform *v2;
  NWConcrete_nw_protocol_transform *v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  void *v12;
  OS_xpc_object *v13;
  OS_xpc_object *disabled_protocols;
  void *v15;
  OS_xpc_object *v16;
  OS_xpc_object *match_url_schemes;
  void *v18;
  NWConcrete_nw_protocol_stack *v19;
  OS_nw_protocol_stack *transform_stack;
  NWConcrete_nw_protocol_transform *v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  void *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  char *v35;
  os_log_type_t v36;
  _BOOL4 v37;
  os_log_type_t v38;
  char v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  char *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = objc_alloc_init(NWConcrete_nw_protocol_transform);
    v3 = v2;
    if (v2)
    {
      v4 = *((_BYTE *)v2 + 8) & 0xFE | v1[8] & 1;
      *((_BYTE *)v2 + 8) = v4;
      v5 = v4 & 0xFFFFFFFD | (2 * ((v1[8] >> 1) & 1));
      *((_BYTE *)v2 + 8) = v5;
      v6 = v5 & 0xFFFFFFFB | (4 * ((v1[8] >> 2) & 1));
      *((_BYTE *)v2 + 8) = v6;
      v7 = v6 & 0xFFFFFFF7 | (8 * ((v1[8] >> 3) & 1));
      *((_BYTE *)v2 + 8) = v7;
      v8 = v7 & 0xFFFFFFEF | (16 * ((v1[8] >> 4) & 1));
      *((_BYTE *)v2 + 8) = v8;
      v9 = v8 & 0xFFFFFFDF | (32 * ((v1[8] >> 5) & 1));
      *((_BYTE *)v2 + 8) = v9;
      LOBYTE(v9) = v9 & 0xBF | (((v1[8] & 0x40) != 0) << 6);
      *((_BYTE *)v2 + 8) = v9;
      *((_BYTE *)v2 + 8) = v1[8] & 0x80 | v9 & 0x7F;
      v10 = *((_BYTE *)v2 + 9) & 0xFE | v1[9] & 1;
      *((_BYTE *)v2 + 9) = v10;
      v11 = v10 & 0xFFFFFFFD | (2 * ((v1[9] >> 1) & 1));
      *((_BYTE *)v2 + 9) = v11;
      *((_BYTE *)v2 + 9) = v11 & 0xFB | v1[9] & 4;
      *(_OWORD *)&v2->traffic_class = *(_OWORD *)(v1 + 12);
      objc_storeStrong((id *)&v2->replace_endpoint, *((id *)v1 + 4));
      v12 = (void *)*((_QWORD *)v1 + 5);
      if (v12)
      {
        v13 = (OS_xpc_object *)xpc_copy(v12);
        disabled_protocols = v3->disabled_protocols;
        v3->disabled_protocols = v13;

      }
      v15 = (void *)*((_QWORD *)v1 + 6);
      if (v15)
      {
        v16 = (OS_xpc_object *)xpc_copy(v15);
        match_url_schemes = v3->match_url_schemes;
        v3->match_url_schemes = v16;

      }
      v18 = (void *)*((_QWORD *)v1 + 7);
      if (v18)
      {
        v19 = nw_protocol_stack_copy(v18);
        transform_stack = v3->transform_stack;
        v3->transform_stack = (OS_nw_protocol_stack *)v19;

      }
      v21 = v3;
      goto LABEL_29;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_transform_copy";
    v23 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v23, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_transform_copy";
          _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s [[nw_protocol_stack alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v27 = type;
        v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_protocol_transform_copy";
            v43 = 2082;
            v44 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s [[nw_protocol_stack alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v23)
            goto LABEL_29;
          goto LABEL_28;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_transform_copy";
          _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s [[nw_protocol_stack alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_transform_copy";
          _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s [[nw_protocol_stack alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v23)
    {
LABEL_29:

      goto LABEL_30;
    }
LABEL_28:
    free(v23);
    goto LABEL_29;
  }
  __nwlog_obj();
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v42 = "nw_protocol_transform_copy";
  v32 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v32, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v39)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      v37 = os_log_type_enabled(v33, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v42 = "nw_protocol_transform_copy";
          v43 = 2082;
          v44 = v35;
          _os_log_impl(&dword_182FBE000, v33, v36, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v35);
        goto LABEL_47;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_182FBE000, v33, v36, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_182FBE000, v33, v38, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_47:
  if (v32)
    free(v32);
  v3 = 0;
LABEL_30:

  return v3;
}

void sub_182FD41B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_stack *nw_protocol_stack_copy(void *a1)
{
  _QWORD *v1;
  NWConcrete_nw_protocol_stack *v2;
  uint64_t v3;
  _BOOL8 v4;
  OS_nw_array *persistent_application_protocols;
  unsigned __int8 *v6;
  _BOOL8 v7;
  OS_nw_array *application_protocols;
  unsigned __int8 *v9;
  void *v10;
  NWConcrete_nw_protocol_options *v11;
  OS_nw_protocol_options *transport_protocol;
  void *v13;
  NWConcrete_nw_protocol_options *v14;
  OS_nw_protocol_options *secondary_transport_protocol;
  void *v16;
  NWConcrete_nw_protocol_options *v17;
  OS_nw_protocol_options *original_proxied_transport_protocol;
  void *v19;
  NWConcrete_nw_protocol_options *v20;
  OS_nw_protocol_options *internet_protocol;
  NWConcrete_nw_protocol_stack *v22;
  id v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  _QWORD v32[4];
  NWConcrete_nw_protocol_stack *v33;
  _QWORD v34[4];
  NWConcrete_nw_protocol_stack *v35;
  char v36;
  os_log_type_t v37;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = objc_alloc_init(NWConcrete_nw_protocol_stack);
  if (v2)
  {
    v3 = MEMORY[0x1E0C809B0];
    if (v1[1])
    {
      v4 = nw_array_create();
      persistent_application_protocols = v2->persistent_application_protocols;
      v2->persistent_application_protocols = (OS_nw_array *)v4;

      v6 = (unsigned __int8 *)v1[1];
      v34[0] = v3;
      v34[1] = 3221225472;
      v34[2] = __nw_protocol_stack_copy_block_invoke;
      v34[3] = &unk_1E14AC200;
      v35 = v2;
      nw_array_apply(v6, (uint64_t)v34);

    }
    if (v1[2])
    {
      v7 = nw_array_create();
      application_protocols = v2->application_protocols;
      v2->application_protocols = (OS_nw_array *)v7;

      v9 = (unsigned __int8 *)v1[2];
      v32[0] = v3;
      v32[1] = 3221225472;
      v32[2] = __nw_protocol_stack_copy_block_invoke_2;
      v32[3] = &unk_1E14AC200;
      v33 = v2;
      nw_array_apply(v9, (uint64_t)v32);

    }
    v10 = (void *)v1[3];
    if (v10)
    {
      v11 = nw_protocol_options_copy(v10);
      transport_protocol = v2->transport_protocol;
      v2->transport_protocol = (OS_nw_protocol_options *)v11;

    }
    v13 = (void *)v1[4];
    if (v13)
    {
      v14 = nw_protocol_options_copy(v13);
      secondary_transport_protocol = v2->secondary_transport_protocol;
      v2->secondary_transport_protocol = (OS_nw_protocol_options *)v14;

    }
    v16 = (void *)v1[5];
    if (v16)
    {
      v17 = nw_protocol_options_copy(v16);
      original_proxied_transport_protocol = v2->original_proxied_transport_protocol;
      v2->original_proxied_transport_protocol = (OS_nw_protocol_options *)v17;

    }
    v19 = (void *)v1[6];
    if (v19)
    {
      v20 = nw_protocol_options_copy(v19);
      internet_protocol = v2->internet_protocol;
      v2->internet_protocol = (OS_nw_protocol_options *)v20;

    }
    v22 = v2;
    goto LABEL_34;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v23 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v39 = "nw_protocol_stack_copy";
  v24 = (char *)_os_log_send_and_compose_impl();

  v37 = OS_LOG_TYPE_ERROR;
  v36 = 0;
  if (!__nwlog_fault(v24, &v37, &v36))
    goto LABEL_32;
  if (v37 == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = (id)gLogObj;
    v26 = v37;
    if (os_log_type_enabled(v25, v37))
    {
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_stack_copy";
      _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s [[nw_protocol_stack alloc] init] failed", buf, 0xCu);
    }
LABEL_31:

LABEL_32:
    if (!v24)
      goto LABEL_34;
LABEL_33:
    free(v24);
    goto LABEL_34;
  }
  if (!v36)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = (id)gLogObj;
    v30 = v37;
    if (os_log_type_enabled(v25, v37))
    {
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_stack_copy";
      _os_log_impl(&dword_182FBE000, v25, v30, "%{public}s [[nw_protocol_stack alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_31;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = (id)gLogObj;
  v28 = v37;
  v29 = os_log_type_enabled(v25, v37);
  if (!backtrace_string)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_stack_copy";
      _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s [[nw_protocol_stack alloc] init] failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_31;
  }
  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    v39 = "nw_protocol_stack_copy";
    v40 = 2082;
    v41 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s [[nw_protocol_stack alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v24)
    goto LABEL_33;
LABEL_34:

  return v2;
}

void sub_182FD45E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_stack_iterate_application_protocols_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return 1;
}

uint64_t __nw_path_is_viable_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  _BYTE *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  void *v8;
  _DWORD *data;
  _DWORD *v10;
  BOOL v11;
  size_t length;

  v4 = a3;
  v5 = v4;
  if ((v4[185] & 2) != 0)
  {
    if ((v4[185] & 1) != 0)
      goto LABEL_15;
    v7 = v4;
    v8 = (void *)v7[3];
    if (!v8
      || (length = 0, (data = xpc_dictionary_get_data(v8, "data", &length)) == 0)
      || length < 0xD8
      || (v10 = data, length != data[53] + 216)
      || ((data[52] & 0xE080) != 0 ? (v11 = (data[52] & 0x13) == 1) : (v11 = 1), v11))
    {

      v6 = 1;
      goto LABEL_16;
    }

    if ((v10[52] & 0x40) != 0)
    {
LABEL_15:
      v6 = 0;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      goto LABEL_16;
    }
  }
  v6 = 1;
LABEL_16:

  return v6;
}

uint64_t __nw_establishment_report_enumerate_protocols_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL __nw_content_context_copy_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  nw_protocol_definition_t v6;
  _BOOL4 is_equal_unsafe;

  v5 = a3;
  v6 = nw_protocol_metadata_copy_definition(v5);
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, *(_QWORD *)(a1 + 32));

  if (is_equal_unsafe)
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);

  return !is_equal_unsafe;
}

void sub_182FD4D5C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_copy_resolved_endpoints_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  nw_endpoint_t v4;

  v4 = nw_endpoint_handler_copy_endpoint(a3);
  nw_array_append(*(_QWORD *)(a1 + 32), v4);

  return 1;
}

uint64_t ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;

  v4 = a3;
  v5 = v4;
  if (*(id *)(a1 + 32) != v4)
    nw_endpoint_handler_cancel(v4, 0, 0);

  return 1;
}

void sub_182FD4DF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_enumerate_resolution_reports_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __nw_path_enumerate_resolver_configs_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t __nw_resolver_set_update_handler_block_invoke_78(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  int address_family;
  uint64_t v6;

  v4 = a3;
  if (nw_endpoint_get_type(v4) == nw_endpoint_type_address)
  {
    address_family = nw_endpoint_get_address_family(v4);
    if (address_family == 30)
    {
      v6 = a1 + 40;
      goto LABEL_6;
    }
    if (address_family == 2)
    {
      v6 = a1 + 32;
LABEL_6:
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v6 + 8) + 24) = 1;
    }
  }

  return 1;
}

void sub_182FD4EC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_content_context_foreach_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  uint64_t v5;
  nw_protocol_definition_t v6;

  v4 = a3;
  v5 = *(_QWORD *)(a1 + 32);
  v6 = nw_protocol_metadata_copy_definition(v4);
  (*(void (**)(uint64_t, nw_protocol_definition_t, NSObject *))(v5 + 16))(v5, v6, v4);

  return 1;
}

void sub_182FD4F38(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_register_context_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  nw_protocol_definition_t v6;

  v5 = a3;
  v6 = nw_protocol_metadata_copy_definition(v5);
  if (nw_protocol_definition_is_equal_unsafe(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 768), (uint64_t)v6))
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);

  return 1;
}

void sub_182FD4FC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void __nw_protocol_transform_modify_parameters_block_invoke_2(uint64_t a1, void *a2)
{
  nw_protocol_stack_append_application_protocol(*(void **)(a1 + 32), a2);
}

void __nw_protocol_transform_contains_protocol_block_invoke(uint64_t a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;

  v3 = a2;
  v4 = v3;
  if (!*(_BYTE *)(a1 + 48))
  {
    if (!nw_protocol_options_matches_definition(v3, *(void **)(a1 + 32)))
      goto LABEL_4;
    goto LABEL_3;
  }
  if (nw_protocol_options_is_quic(v3))
LABEL_3:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
LABEL_4:

}

void sub_182FD5044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_stack_replace_protocol_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  nw_protocol_definition_t v5;
  _BOOL8 v6;
  uint64_t v7;
  void *v8;
  unsigned __int8 *v9;
  id v10;
  uint64_t v11;
  __int128 v13;
  _QWORD v14[4];
  NSObject *v15;
  __int128 v16;

  v4 = a3;
  v5 = nw_protocol_options_copy_definition(v4);
  if (nw_protocol_definition_is_equal_unsafe(*(_QWORD *)(a1 + 32), (uint64_t)v5)
    || nw_protocol_definition_is_equal_unsafe(*(_QWORD *)(a1 + 40), (uint64_t)v5))
  {
    v6 = nw_array_create();
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
    v8 = *(void **)(v7 + 40);
    *(_QWORD *)(v7 + 40) = v6;

    v9 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 48) + 16);
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_protocol_stack_replace_protocol_block_invoke_4;
    v14[3] = &unk_1E14A51E8;
    v15 = v4;
    v13 = *(_OWORD *)(a1 + 56);
    v10 = (id)v13;
    v16 = v13;
    nw_array_apply(v9, (uint64_t)v14);

    v11 = 0;
  }
  else
  {
    v11 = 1;
  }

  return v11;
}

void sub_182FD515C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_content_context_copy_first_repliable_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  int v6;

  v5 = a3;
  v6 = nw_protocol_metadata_supports_replies(v5);
  if (v6)
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), a3);

  return v6 ^ 1u;
}

BOOL __nw_parameters_copy_protocol_options_for_definition_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v5;
  nw_protocol_definition_t v6;
  _BOOL4 is_equal_unsafe;

  v5 = a3;
  v6 = nw_protocol_options_copy_definition(v5);
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe(*(_QWORD *)(a1 + 32), (uint64_t)v6);
  if (is_equal_unsafe)
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);

  return !is_equal_unsafe;
}

void sub_182FD5258(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_copy_dictionary_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int *v4;
  xpc_object_t v5;
  char *identifier;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = a3;
  v5 = xpc_dictionary_create(0, 0, 0);
  identifier = nw_protocol_definition_get_identifier(*((void **)v4 + 4));
  if (identifier)
    xpc_dictionary_set_string(v5, "protocol", identifier);
  v7 = *((_QWORD *)v4 + 1);
  if (v7)
    xpc_dictionary_set_uint64(v5, "handshake_milliseconds", v7);
  v8 = *((_QWORD *)v4 + 2);
  if (v8)
    xpc_dictionary_set_uint64(v5, "handshake_rtt_milliseconds", v8);
  v9 = v4[6];
  if ((_DWORD)v9)
    xpc_dictionary_set_uint64(v5, "client_accurate_ecn_state", v9);
  v10 = v4[7];
  if ((_DWORD)v10)
    xpc_dictionary_set_uint64(v5, "server_accurate_ecn_state", v10);
  if ((v4[10] & 1) != 0)
    xpc_dictionary_set_BOOL(v5, "l4s_enabled", 1);
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), v5);

  return 1;
}

void sub_182FD5390(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_parameters_add_protocol_stack_member_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;

  v5 = a3;
  if (*(_DWORD *)(a1 + 48) == a2)
    nw_array_append(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40));
  nw_array_append(*(_QWORD *)(a1 + 32), v5);

  return 1;
}

uint64_t __nw_path_enumerate_gateways_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZL27nw_endpoint_resolver_updateP30NWConcrete_nw_endpoint_handlerPU25objcproto14OS_nw_resolver8NSObject20nw_resolver_status_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  nw_endpoint_t v4;
  uint64_t v5;
  char *v6;
  char **v7;
  char *v8;
  int v9;
  const char *logging_description;
  const char *v11;

  v4 = nw_endpoint_handler_copy_endpoint(a3);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v8 = *(char **)(v5 + 24);
  v7 = (char **)(v5 + 24);
  v6 = v8;
  v9 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  logging_description = nw_endpoint_get_logging_description(v4);
  v11 = "";
  if (!v9)
    v11 = ",";
  asprintf(v7, "%s%s%s", v6, v11, logging_description);
  if (v6)
    free(v6);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;

  return 1;
}

void sub_182FD54C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL44nw_endpoint_resolver_array_contains_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return nw_endpoint_is_equal(*(void **)(a1 + 32), a3, 1) ^ 1;
}

uint64_t ___ZL53nw_endpoint_resolver_duplicate_array_without_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  if ((nw_endpoint_is_equal(*(void **)(a1 + 32), v4, 1) & 1) == 0)
    nw_array_append(*(_QWORD *)(a1 + 40), v4);

  return 1;
}

void sub_182FD5548(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_get_accurate_ecn_state_block_invoke(uint64_t a1, void *a2, int a3, int a4)
{
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  id v12;
  BOOL is_equal_unsafe;

  v7 = a2;
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
  v8 = (id)g_tcp_definition;
  if (nw_protocol_definition_is_equal_unsafe((uint64_t)v7, (uint64_t)v8))
    goto LABEL_8;
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  v9 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  if (nw_protocol_definition_is_equal_unsafe((uint64_t)v7, (uint64_t)v9))
  {

LABEL_8:
    goto LABEL_9;
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  v12 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v7, (uint64_t)v12);

  if (!is_equal_unsafe)
  {
    v10 = 1;
    goto LABEL_10;
  }
LABEL_9:
  v10 = 0;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a4;
LABEL_10:

  return v10;
}

void sub_182FD56BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_enumerate_protocol_l4s_state_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t nw_array_get_count(uint64_t result)
{
  if (result)
    return (uint64_t)(*(_QWORD *)(result + 24) - *(_QWORD *)(result + 16)) >> 3;
  return result;
}

id nw_protocol_copy_quic_stream_definition()
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  return (id)nw_protocol_copy_quic_stream_definition::quic_definition;
}

uint64_t ___ZL28nw_flow_handle_send_completeP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP16nw_flow_protocol_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

ValueMetadata *type metadata accessor for NWConnection.SendCompletion()
{
  return &type metadata for NWConnection.SendCompletion;
}

BOOL nw_context_create(const char *a1)
{
  return -[NWConcrete_nw_context initWithIdentifier:]([NWConcrete_nw_context alloc], a1);
}

void nw_frame_set_buffer_used_manager(uint64_t a1, uint64_t a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)(a1 + 104) = a2;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_set_buffer_used_manager";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v11 = "__nw_frame_set_buffer_used_manager";
      v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }
    if (!v8)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v11 = "__nw_frame_set_buffer_used_manager";
      v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v3 = __nwlog_obj();
    v4 = type;
    v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        v11 = "__nw_frame_set_buffer_used_manager";
        v12 = 2082;
        v13 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      v11 = "__nw_frame_set_buffer_used_manager";
      v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_18:
  if (v2)
    free(v2);
}

uint64_t getEnumTagSinglePayload for NWError(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0xFE && *(_BYTE *)(a1 + 5))
    return (*(_DWORD *)a1 + 254);
  v3 = *(unsigned __int8 *)(a1 + 4);
  if (v3 <= 2)
    v4 = -1;
  else
    v4 = v3 ^ 0xFF;
  return (v4 + 1);
}

uint64_t ___ZL22nw_flow_input_finishedP11nw_protocolS0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_182FD5AA8(uint32_t a1, uint32_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  NSObject *v14;
  uint64_t v15;
  void *v16;
  _QWORD v17[6];

  v14 = *(NSObject **)(v7 + 16);
  v15 = swift_allocObject();
  *(_QWORD *)(v15 + 16) = a3;
  *(_QWORD *)(v15 + 24) = a4;
  v17[4] = a6;
  v17[5] = v15;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 1107296256;
  v17[2] = sub_183083F3C;
  v17[3] = a7;
  v16 = _Block_copy(v17);
  swift_unknownObjectRetain();
  swift_retain();
  swift_release();
  nw_connection_receive(v14, a1, a2, v16);
  swift_unknownObjectRelease();
  _Block_release(v16);
}

NWConcrete_nw_read_request *nw_read_request_create(unint64_t a1, unint64_t a2, void *a3, void *a4, void *a5)
{
  id v10;
  id v11;
  id v12;
  void *v13;
  BOOL v14;
  unint64_t v15;
  id v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  os_unfair_lock_s *v20;
  os_unfair_lock_s *v21;
  char v22;
  NSObject *v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  NWConcrete_nw_read_request *v27;
  void *v28;
  id data_completion;
  NWConcrete_nw_read_request *v30;
  id v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  os_log_type_t v35;
  const char *v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  os_log_type_t v40;
  os_log_type_t v41;
  void *v43;
  NSObject *v44;
  os_log_type_t v45;
  char *backtrace_string;
  os_log_type_t v47;
  _BOOL4 v48;
  os_log_type_t v49;
  char v50;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  char *v55;
  __int16 v56;
  unint64_t v57;
  __int16 v58;
  char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v10 = a3;
  v11 = a4;
  v12 = a5;
  v13 = v12;
  if (a2)
    v14 = a1 == 0;
  else
    v14 = 0;
  if (v14)
    v15 = 1;
  else
    v15 = a1;
  if (!v12)
  {
    __nwlog_obj();
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_read_request_create";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v17, &type, &v50))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_read_request_create";
        _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null completion", buf, 0xCu);
      }
    }
    else if (v50)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      v48 = os_log_type_enabled(v44, type);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          v53 = "nw_read_request_create";
          v54 = 2082;
          v55 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v44, v47, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_54;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_read_request_create";
        _os_log_impl(&dword_182FBE000, v44, v47, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v49 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_read_request_create";
        _os_log_impl(&dword_182FBE000, v44, v49, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_54;
  }
  if (v15 <= a2)
  {
    if (v10)
    {
      v20 = (os_unfair_lock_s *)v10;
      if (v20 == (os_unfair_lock_s *)&__block_literal_global_5_41741)
      {

      }
      else
      {
        v21 = v20;
        if (v20 == (os_unfair_lock_s *)&__block_literal_global_4
          || v20 == (os_unfair_lock_s *)&__block_literal_global_3_41726
          || v20 == (os_unfair_lock_s *)&__block_literal_global_41718)
        {

          goto LABEL_20;
        }
        os_unfair_lock_lock(v20 + 28);
        v22 = BYTE2(v21[29]._os_unfair_lock_opaque);
        os_unfair_lock_unlock(v21 + 28);

        if ((v22 & 0x40) == 0)
        {
LABEL_20:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v23 = (id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v53 = "nw_read_request_create";
            _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s Cannot receive a reply for a protocol that does not support replies", buf, 0xCu);
          }

          goto LABEL_56;
        }
      }
    }
    v27 = objc_alloc_init(NWConcrete_nw_read_request);
    if (v27)
    {
      v28 = _Block_copy(v13);
      data_completion = v27->data_completion;
      v27->data_completion = v28;

      objc_storeStrong((id *)&v27->connection, a4);
      v27->qos_class = qos_class_self();
      v27->min = v15;
      v27->max = a2;
      objc_storeStrong((id *)&v27->repliable_message, a3);
      v27->variant = 1;
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_51698);
      if (_nw_signposts_enabled && kdebug_is_enabled())
        kdebug_trace();
      v30 = v27;
      goto LABEL_65;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v31 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v53 = "nw_read_request_create";
    v32 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v32, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = (id)gLogObj;
        v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_read_request_create";
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v50)
      {
        v36 = __nw_create_backtrace_string();
        if (v36)
        {
          v37 = (char *)v36;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = (id)gLogObj;
          v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            *(_DWORD *)buf = 136446466;
            v53 = "nw_read_request_create";
            v54 = 2082;
            v55 = v37;
            _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v37);
          if (!v32)
            goto LABEL_65;
          goto LABEL_64;
        }
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v41 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_read_request_create";
          _os_log_impl(&dword_182FBE000, v33, v41, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = (id)gLogObj;
        v40 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_read_request_create";
          _os_log_impl(&dword_182FBE000, v33, v40, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v32)
    {
LABEL_65:

      goto LABEL_66;
    }
LABEL_64:
    free(v32);
    goto LABEL_65;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  v53 = "nw_read_request_create";
  v54 = 2048;
  v55 = (char *)v15;
  v56 = 2048;
  v57 = a2;
  v17 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v50 = 0;
  if (__nwlog_fault(v17, &type, &v50))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (id)gLogObj;
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446722;
        v53 = "nw_read_request_create";
        v54 = 2048;
        v55 = (char *)v15;
        v56 = 2048;
        v57 = a2;
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s minlength (%zu) > maxlength (%zu)", buf, 0x20u);
      }
    }
    else if (v50)
    {
      v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (id)gLogObj;
      v25 = type;
      v26 = os_log_type_enabled(v18, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446978;
          v53 = "nw_read_request_create";
          v54 = 2048;
          v55 = (char *)v15;
          v56 = 2048;
          v57 = a2;
          v58 = 2082;
          v59 = v24;
          _os_log_impl(&dword_182FBE000, v18, v25, "%{public}s minlength (%zu) > maxlength (%zu), dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v24);
        if (!v17)
          goto LABEL_56;
        goto LABEL_55;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446722;
        v53 = "nw_read_request_create";
        v54 = 2048;
        v55 = (char *)v15;
        v56 = 2048;
        v57 = a2;
        _os_log_impl(&dword_182FBE000, v18, v25, "%{public}s minlength (%zu) > maxlength (%zu), no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (id)gLogObj;
      v35 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446722;
        v53 = "nw_read_request_create";
        v54 = 2048;
        v55 = (char *)v15;
        v56 = 2048;
        v57 = a2;
        _os_log_impl(&dword_182FBE000, v18, v35, "%{public}s minlength (%zu) > maxlength (%zu), backtrace limit exceeded", buf, 0x20u);
      }
    }

  }
LABEL_54:
  if (v17)
LABEL_55:
    free(v17);
LABEL_56:
  v27 = 0;
LABEL_66:

  return v27;
}

void sub_182FD654C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void nw_connection_receive(nw_connection_t connection, uint32_t minimum_incomplete_length, uint32_t maximum_length, nw_connection_receive_completion_t completion)
{
  nw_connection_receive_internal(connection, 0, minimum_incomplete_length, maximum_length, completion);
}

nw_endpoint_t nw_flow_get_local(nw_protocol *a1)
{
  id v1;
  void *v2;
  NWConcrete_nw_endpoint_handler *v3;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v5;
  nw_endpoint_t v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  NSObject *v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  void *v25;
  __int16 v26;
  const char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = *((id *)a1->handle + 20);
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_flow_get_local";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_flow_get_local";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v23 = "nw_flow_get_local";
            v24 = 2082;
            v25 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_34;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_flow_get_local";
          _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_flow_get_local";
          _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_34:
    if (v13)
      free(v13);
    goto LABEL_13;
  }
  v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (mode > 5)
        v8 = "unknown-mode";
      else
        v8 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v23 = "nw_flow_get_local";
      v24 = 2082;
      v25 = (void *)v8;
      v26 = 2082;
      v27 = "flow";
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }

LABEL_13:
    v6 = 0;
    goto LABEL_17;
  }
  v5 = nw_endpoint_handler_copy_flow(v3);
  if (*((_QWORD *)v5 + 120))
  {
    v6 = 0;
  }
  else
  {
    v9 = nw_endpoint_flow_copy_path(v3);
    v10 = v9;
    if (v9)
      v6 = nw_path_copy_effective_local_endpoint(v9);
    else
      v6 = 0;

  }
LABEL_17:

  return v6;
}

void sub_182FD6BD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_add_read_request(void *a1, void *a2)
{
  id v3;
  id v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v7;
  NWConcrete_nw_endpoint_mode_handler *v8;
  id *v9;
  id *v10;
  NSObject *v11;
  uint64_t node;
  nw_flow_protocol *v13;
  _BOOL8 v14;
  id v15;
  const char *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t request;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  const char *v26;
  NWConcrete_nw_endpoint_handler *v27;
  char v28;
  NWConcrete_nw_endpoint_handler *v29;
  NWConcrete_nw_endpoint_handler *v30;
  char v31;
  const char *v32;
  nw_endpoint_t v33;
  const char *logging_description;
  unsigned int *v35;
  unsigned int *v36;
  uint64_t v37;
  const char *v38;
  os_log_type_t v39;
  const char *v40;
  NWConcrete_nw_endpoint_handler *v41;
  char v42;
  NWConcrete_nw_endpoint_handler *v43;
  NWConcrete_nw_endpoint_handler *v44;
  char v45;
  const char *v46;
  nw_endpoint_t v47;
  const char *v48;
  unsigned int *v49;
  unsigned int *v50;
  uint64_t v51;
  const char *v52;
  const char *v53;
  void **v54;
  void **v55;
  int v56;
  const char *v57;
  char *v58;
  id *v59;
  void **v60;
  void **v61;
  void **v62;
  int v63;
  const char *v64;
  id repliable_metadata;
  void *v66;
  _BOOL8 request_list_append;
  void *v68;
  void **v69;
  id v70;
  void **v71;
  id v72;
  void *v74;
  os_log_type_t v75;
  char *v76;
  os_log_type_t v77;
  _BOOL4 v78;
  os_log_type_t v79;
  void *v80;
  char *v81;
  NSObject *v82;
  os_log_type_t v83;
  char *backtrace_string;
  os_log_type_t v85;
  _BOOL4 v86;
  NSObject *v87;
  id v88;
  os_log_type_t v89;
  const char *v90;
  const char *v91;
  const char *v92;
  char *id_str;
  char *v94;
  const char *id_string;
  nw_endpoint_t v96;
  _QWORD v97[4];
  NWConcrete_nw_endpoint_handler *v98;
  id *v99;
  void **v100;
  _BYTE *v101;
  os_log_type_t *v102;
  os_log_type_t type[8];
  os_log_type_t *v104;
  uint64_t v105;
  char v106;
  char v107;
  _BYTE buf[24];
  const char *v109;
  __int16 v110;
  const char *v111;
  __int16 v112;
  const char *v113;
  __int16 v114;
  const char *v115;
  __int16 v116;
  id v117;
  __int16 v118;
  id *v119;
  __int16 v120;
  nw_flow_protocol *v121;
  __int16 v122;
  _BOOL4 v123;
  uint64_t v124;

  v124 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v5 = (NWConcrete_nw_endpoint_handler *)v3;
    mode = v5->mode;

    if ((_DWORD)mode == 2)
    {
      v7 = nw_endpoint_handler_copy_flow(v5);
      v8 = v7;
      if ((*((_BYTE *)v7 + 35) & 2) != 0)
      {
        v21 = *((_QWORD *)v7 + 117);
        if (!v21)
        {
          v27 = v5;
          v28 = *((_BYTE *)v27 + 268);

          if ((v28 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v11 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              v29 = v27;

              v30 = v29;
              v31 = *((_BYTE *)v27 + 268);

              if ((v31 & 1) != 0)
                v32 = "dry-run ";
              else
                v32 = "";
              v33 = nw_endpoint_handler_copy_endpoint(v30);
              logging_description = nw_endpoint_get_logging_description(v33);
              id_str = v29->id_str;
              v35 = v30;
              v36 = v35;
              v37 = v35[30];
              if (v37 > 5)
                v38 = "unknown-state";
              else
                v38 = off_1E149FC48[v37];
              v90 = v38;

              v54 = v36;
              v55 = v54;
              v56 = v5->mode;
              v57 = "path";
              switch(v56)
              {
                case 0:
                  break;
                case 1:
                  v57 = "resolver";
                  break;
                case 2:
                  v57 = nw_endpoint_flow_mode_string(v54[31]);
                  break;
                case 3:
                  v57 = "proxy";
                  break;
                case 4:
                  v57 = "fallback";
                  break;
                case 5:
                  v57 = "transform";
                  break;
                default:
                  v57 = "unknown-mode";
                  break;
              }

              v69 = v55;
              os_unfair_lock_lock((os_unfair_lock_t)v69 + 28);
              v70 = v69[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v69 + 28);

              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = id_str;
              *(_WORD *)&buf[22] = 2082;
              v109 = v32;
              v110 = 2082;
              v111 = logging_description;
              v112 = 2082;
              v113 = v90;
              v114 = 2082;
              v115 = v57;
              v116 = 2114;
              v117 = v70;
              _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot receive, no connected handler", buf, 0x48u);

            }
            goto LABEL_94;
          }
LABEL_112:
          v14 = 0;
          goto LABEL_96;
        }
        request = nw_endpoint_handler_add_read_request(v21, v4);
      }
      else
      {
        if (*((_QWORD *)v7 + 96))
        {
          if (*((_QWORD *)v7 + 108))
          {
            v9 = (id *)v4;
            v10 = v9;
            if (v9)
            {
              v11 = v9[18];

              if (v11)
              {
                if (v11 == &__block_literal_global_5_41741)
                {
                  *(_QWORD *)buf = 0;
                  *(_QWORD *)&buf[8] = buf;
                  *(_QWORD *)&buf[16] = 0x2020000000;
                  LOBYTE(v109) = 0;
                  *(_QWORD *)type = 0;
                  v104 = type;
                  v105 = 0x2020000000;
                  v106 = 0;
                  v58 = (char *)*((_QWORD *)v8 + 108);
                  v97[0] = MEMORY[0x1E0C809B0];
                  v97[1] = 3221225472;
                  v97[2] = __nw_endpoint_handler_add_read_request_block_invoke;
                  v97[3] = &unk_1E149C6E8;
                  v98 = v5;
                  v59 = v10;
                  v99 = v59;
                  v101 = buf;
                  v102 = type;
                  v60 = v8;
                  v100 = v60;
                  nw_hash_table_apply(v58, (uint64_t)v97);
                  if (*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
                  {
                    v14 = *((_BYTE *)v104 + 24) != 0;
                  }
                  else
                  {
                    request_list_append = nw_read_request_list_append(v60[89], v59);
                    v68 = v60[89];
                    v60[89] = (void *)request_list_append;

                    v14 = 1;
                  }

                  _Block_object_dispose(type, 8);
                  _Block_object_dispose(buf, 8);
                  v11 = &__block_literal_global_5_41741;
                  goto LABEL_95;
                }
                node = nw_hash_table_get_node(*((_QWORD *)v8 + 108), (uint64_t)v11, 0);
                if (node
                  || (repliable_metadata = nw_content_context_copy_first_repliable_metadata(v11)) != 0
                  && (v66 = repliable_metadata,
                      node = nw_hash_table_get_node(*((_QWORD *)v8 + 108), (uint64_t)repliable_metadata, 1),
                      v66,
                      node))
                {
                  v13 = *(nw_flow_protocol **)(node + 16);
                  v14 = nw_flow_add_read_request(v5, (uint64_t)v13, v10);
                  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v87 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v5);
                      v92 = nw_endpoint_handler_dry_run_string(v5);
                      v96 = nw_endpoint_handler_copy_endpoint(v5);
                      *(_DWORD *)buf = 136448514;
                      *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = id_string;
                      *(_WORD *)&buf[22] = 2082;
                      v109 = v92;
                      v110 = 2082;
                      v111 = nw_endpoint_get_logging_description(v96);
                      v112 = 2082;
                      v113 = nw_endpoint_handler_state_string(v5);
                      v114 = 2082;
                      v115 = nw_endpoint_handler_mode_string(v5);
                      v116 = 2114;
                      v88 = nw_endpoint_handler_copy_current_path(v5);
                      v117 = v88;
                      v118 = 2112;
                      v119 = v10;
                      v120 = 2048;
                      v121 = v13;
                      v122 = 1024;
                      v123 = v14;
                      _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added read request %@ to flow protocol %p: %u", buf, 0x62u);

                    }
                  }
                  nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v8, v13, 0);
                  goto LABEL_95;
                }
                nw_read_request_fail(v10, 2);
                goto LABEL_94;
              }
LABEL_140:
              v14 = nw_flow_add_read_request(v5, (uint64_t)v8 + 376, v10);
              v11 = 0;
              goto LABEL_95;
            }
            __nwlog_obj();
            v80 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_read_request_copy_repliable_context";
            v81 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v107 = 0;
            if (__nwlog_fault(v81, type, &v107))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v82 = objc_claimAutoreleasedReturnValue();
                v83 = type[0];
                if (os_log_type_enabled(v82, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl(&dword_182FBE000, v82, v83, "%{public}s called with null request", buf, 0xCu);
                }
              }
              else if (v107)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v82 = objc_claimAutoreleasedReturnValue();
                v85 = type[0];
                v86 = os_log_type_enabled(v82, type[0]);
                if (backtrace_string)
                {
                  if (v86)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_read_request_copy_repliable_context";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = backtrace_string;
                    _os_log_impl(&dword_182FBE000, v82, v85, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(backtrace_string);
                  goto LABEL_138;
                }
                if (v86)
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl(&dword_182FBE000, v82, v85, "%{public}s called with null request, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                __nwlog_obj();
                v82 = objc_claimAutoreleasedReturnValue();
                v89 = type[0];
                if (os_log_type_enabled(v82, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl(&dword_182FBE000, v82, v89, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
                }
              }

            }
LABEL_138:
            if (v81)
              free(v81);
            goto LABEL_140;
          }
          v41 = v5;
          v42 = *((_BYTE *)v41 + 268);

          if ((v42 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v11 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              v43 = v41;

              v44 = v43;
              v45 = *((_BYTE *)v41 + 268);

              if ((v45 & 1) != 0)
                v46 = "dry-run ";
              else
                v46 = "";
              v47 = nw_endpoint_handler_copy_endpoint(v44);
              v48 = nw_endpoint_get_logging_description(v47);
              v94 = v43->id_str;
              v49 = v44;
              v50 = v49;
              v51 = v49[30];
              if (v51 > 5)
                v52 = "unknown-state";
              else
                v52 = off_1E149FC48[v51];
              v91 = v52;

              v61 = v50;
              v62 = v61;
              v63 = v5->mode;
              v64 = "path";
              switch(v63)
              {
                case 0:
                  break;
                case 1:
                  v64 = "resolver";
                  break;
                case 2:
                  v64 = nw_endpoint_flow_mode_string(v61[31]);
                  break;
                case 3:
                  v64 = "proxy";
                  break;
                case 4:
                  v64 = "fallback";
                  break;
                case 5:
                  v64 = "transform";
                  break;
                default:
                  v64 = "unknown-mode";
                  break;
              }

              v71 = v62;
              os_unfair_lock_lock((os_unfair_lock_t)v71 + 28);
              v72 = v71[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v71 + 28);

              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v94;
              *(_WORD *)&buf[22] = 2082;
              v109 = v46;
              v110 = 2082;
              v111 = v48;
              v112 = 2082;
              v113 = v91;
              v114 = 2082;
              v115 = v64;
              v116 = 2114;
              v117 = v72;
              _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot receive after flow table is released", buf, 0x48u);

            }
LABEL_94:
            v14 = 0;
LABEL_95:

            goto LABEL_96;
          }
          goto LABEL_112;
        }
        request = nw_flow_add_read_request(v5, (uint64_t)v7 + 376, v4);
      }
      v14 = request;
LABEL_96:

      goto LABEL_97;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    if (mode > 5)
      v16 = "unknown-mode";
    else
      v16 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v16;
    *(_WORD *)&buf[22] = 2082;
    v109 = "flow";
    v17 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (__nwlog_fault(v17, type, &v107))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          if (mode > 5)
            v20 = "unknown-mode";
          else
            v20 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v20;
          *(_WORD *)&buf[22] = 2082;
          v109 = "flow";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v107)
      {
        v23 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v24 = type[0];
        v25 = os_log_type_enabled(v18, type[0]);
        if (v23)
        {
          if (v25)
          {
            if (mode > 5)
              v26 = "unknown-mode";
            else
              v26 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v26;
            *(_WORD *)&buf[22] = 2082;
            v109 = "flow";
            v110 = 2082;
            v111 = v23;
            _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v23);
          if (!v17)
            goto LABEL_73;
          goto LABEL_72;
        }
        if (v25)
        {
          if (mode > 5)
            v53 = "unknown-mode";
          else
            v53 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v53;
          *(_WORD *)&buf[22] = 2082;
          v109 = "flow";
          _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v39 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          if (mode > 5)
            v40 = "unknown-mode";
          else
            v40 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v40;
          *(_WORD *)&buf[22] = 2082;
          v109 = "flow";
          _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
LABEL_70:

    }
  }
  else
  {
    __nwlog_obj();
    v74 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
    v17 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (__nwlog_fault(v17, type, &v107))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v75 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_182FBE000, v18, v75, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v107)
      {
        v76 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v77 = type[0];
        v78 = os_log_type_enabled(v18, type[0]);
        if (v76)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v76;
            _os_log_impl(&dword_182FBE000, v18, v77, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v76);
          if (!v17)
            goto LABEL_73;
          goto LABEL_72;
        }
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_182FBE000, v18, v77, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v79 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_182FBE000, v18, v79, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_70;
    }
  }
  if (v17)
LABEL_72:
    free(v17);
LABEL_73:
  v14 = 0;
LABEL_97:

  return v14;
}

void sub_182FD7BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_flow_get_remote(nw_protocol *a1)
{
  id v1;
  void *v2;
  NWConcrete_nw_endpoint_handler *v3;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v5;
  NWConcrete_nw_endpoint_mode_handler *v6;
  void *v7;
  nw_endpoint_t v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  void *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v1 = *((id *)a1->handle + 20);
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_flow_get_remote";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v14, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v24 = "nw_flow_get_remote";
            v25 = 2082;
            v26 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_33:
    if (v14)
      free(v14);
    goto LABEL_13;
  }
  v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (mode > 5)
        v10 = "unknown-mode";
      else
        v10 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v24 = "nw_flow_get_remote";
      v25 = 2082;
      v26 = (void *)v10;
      v27 = 2082;
      v28 = "flow";
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }

LABEL_13:
    v8 = 0;
    goto LABEL_16;
  }
  v5 = nw_endpoint_handler_copy_flow(v3);
  v6 = v5;
  v7 = (void *)*((_QWORD *)v5 + 121);
  if (v7)
  {
    v8 = v7;
  }
  else
  {
    v8 = (nw_endpoint_t)*((_QWORD *)v5 + 120);
    if (v8)
    {
      nw_flow_copy_flow_divert_endpoint(*((NWConcrete_nw_endpoint_flow **)v5 + 120));
    }
    else
    {
      v11 = nw_endpoint_flow_copy_path(v3);
      v8 = nw_path_copy_effective_remote_endpoint(v11);

    }
  }

LABEL_16:
  return v8;
}

void sub_182FD8028(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_handler *nw_endpoint_handler_copy_connected_flow_handler(void *a1)
{
  id v1;
  void *v2;
  NWConcrete_nw_endpoint_handler *v3;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v5;
  NWConcrete_nw_endpoint_handler *v6;
  id v7;
  const char *v8;
  NWConcrete_nw_endpoint_handler *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  const char *v17;
  os_log_type_t v18;
  const char *v19;
  const char *v20;
  void *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_endpoint_handler_copy_connected_flow_handler";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_42:

    goto LABEL_43;
  }
  v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (mode > 5)
      v8 = "unknown-mode";
    else
      v8 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v31 = "nw_endpoint_handler_copy_connected_flow_handler";
    v32 = 2082;
    v33 = (void *)v8;
    v34 = 2082;
    v35 = "flow";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v10, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5)
            v13 = "unknown-mode";
          else
            v13 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          v32 = 2082;
          v33 = (void *)v13;
          v34 = 2082;
          v35 = "flow";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v28)
      {
        v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v11, type);
        if (v14)
        {
          if (v16)
          {
            if (mode > 5)
              v17 = "unknown-mode";
            else
              v17 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446978;
            v31 = "nw_endpoint_handler_copy_connected_flow_handler";
            v32 = 2082;
            v33 = (void *)v17;
            v34 = 2082;
            v35 = "flow";
            v36 = 2082;
            v37 = v14;
            _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v14);
          if (!v10)
            goto LABEL_45;
          goto LABEL_44;
        }
        if (v16)
        {
          if (mode > 5)
            v20 = "unknown-mode";
          else
            v20 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          v32 = 2082;
          v33 = (void *)v20;
          v34 = 2082;
          v35 = "flow";
          _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5)
            v19 = "unknown-mode";
          else
            v19 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          v32 = 2082;
          v33 = (void *)v19;
          v34 = 2082;
          v35 = "flow";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
      goto LABEL_42;
    }
LABEL_43:
    if (!v10)
    {
LABEL_45:
      v9 = 0;
      goto LABEL_46;
    }
LABEL_44:
    free(v10);
    goto LABEL_45;
  }
  v5 = nw_endpoint_handler_copy_flow(v3);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 220);
  if ((*((_BYTE *)v5 + 32) & 2) != 0 || (*((_BYTE *)v5 + 33) & 1) != 0)
  {
    v6 = v3;
  }
  else
  {
    if (!*((_QWORD *)v5 + 117))
    {
      v9 = 0;
      goto LABEL_11;
    }
    v6 = (NWConcrete_nw_endpoint_handler *)nw_endpoint_handler_copy_connected_flow_handler();
  }
  v9 = v6;
LABEL_11:
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 220);

LABEL_46:
  return v9;
}

void sub_182FD86A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_path(void *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_mode_handler *v2;
  NWConcrete_nw_endpoint_mode_handler *v3;
  void *v4;
  id *v5;
  id v6;
  void *v7;
  id v8;

  v1 = a1;
  v2 = nw_endpoint_handler_copy_flow(v1);
  v3 = v2;
  v5 = (id *)((char *)v2 + 16);
  v4 = (void *)*((_QWORD *)v2 + 2);
  if (!v4)
  {
    v7 = (void *)*((_QWORD *)v2 + 104);
    if (v7)
    {
      v8 = (id)nw_path_flow_registration_copy_path(v7);
      if (v8)
      {
LABEL_5:
        os_unfair_lock_lock((os_unfair_lock_t)v3 + 220);
        objc_storeStrong(v5, v8);
        os_unfair_lock_unlock((os_unfair_lock_t)v3 + 220);
        v6 = *((id *)v3 + 2);
LABEL_8:

        goto LABEL_9;
      }
    }
    else
    {
      v8 = nw_endpoint_handler_copy_current_path(v1);
      if (v8)
        goto LABEL_5;
    }
    v6 = 0;
    goto LABEL_8;
  }
  v6 = v4;
LABEL_9:

  return v6;
}

void sub_182FD877C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_mode_handler *nw_endpoint_handler_copy_flow(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  NWConcrete_nw_endpoint_mode_handler *v3;
  NSObject *v4;
  const char *v5;
  nw_endpoint_t v6;
  const char *logging_description;
  uint64_t state;
  const char *v9;
  const char *v10;
  NWConcrete_nw_endpoint_handler *v11;
  os_unfair_lock_s *v12;
  const char *v13;
  os_unfair_lock_s *v14;
  id *v15;
  id v16;
  id v17;
  id *v18;
  id *v19;
  const char *v20;
  void *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *id_str;
  __int16 v37;
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  id v46;
  __int16 v47;
  const char *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_endpoint_handler_copy_flow";
    v23 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v24 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v24 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v34 = "nw_endpoint_handler_copy_flow";
            v35 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v24 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_48:
    if (v23)
      free(v23);
    goto LABEL_30;
  }
  if (v1->mode != 2)
  {
    if ((*((_BYTE *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)v2 + 268) & 1) != 0)
          v5 = "dry-run ";
        else
          v5 = "";
        v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        state = v2->state;
        v9 = logging_description;
        if (state > 5)
          v10 = "unknown-state";
        else
          v10 = off_1E149FC48[state];
        v30 = v10;
        v11 = v2;
        v12 = (os_unfair_lock_s *)v11;
        v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            v13 = "resolver";
            break;
          case 2:
            v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            v13 = "proxy";
            break;
          case 4:
            v13 = "fallback";
            break;
          case 5:
            v13 = "transform";
            break;
          default:
            v13 = "unknown-mode";
            break;
        }

        v14 = v12 + 28;
        v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        v16 = v15[8];
        os_unfair_lock_unlock(v14);

        v17 = v16;
        v18 = v15;
        v19 = v18;
        v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            v20 = "resolver";
            break;
          case 2:
            v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            v20 = "proxy";
            break;
          case 4:
            v20 = "fallback";
            break;
          case 5:
            v20 = "transform";
            break;
          default:
            v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        v34 = "nw_endpoint_handler_copy_flow";
        v35 = 2082;
        id_str = v2->id_str;
        v37 = 2082;
        v38 = v5;
        v39 = 2082;
        v40 = v9;
        v41 = 2082;
        v42 = v30;
        v43 = 2082;
        v44 = v13;
        v45 = 2114;
        v46 = v17;
        v47 = 2082;
        v48 = v20;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public}s, not a flow", buf, 0x52u);

      }
    }
LABEL_30:
    v3 = 0;
    goto LABEL_31;
  }
  v3 = v1->mode_handler;
LABEL_31:

  return v3;
}

void sub_182FD8CAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_path_copy_effective_local_endpoint(nw_path_t path)
{
  nw_path_t v1;
  nw_parameters_t *v2;
  Class isa;
  nw_endpoint_t v4;
  uint64_t v5;
  _QWORD *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = path;
  v2 = (nw_parameters_t *)v1;
  if (v1)
  {
    isa = v1[10].isa;
    if (isa)
    {
      v4 = isa;
LABEL_11:
      v9 = v4;
      goto LABEL_12;
    }
    v5 = (uint64_t)v1[9].isa;
    if (v5 && *(_QWORD *)(v5 + 24) != *(_QWORD *)(v5 + 16))
    {
      nw_array_get_object_at_index(v5, 0);
      v6 = (_QWORD *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      if (v6)
      {
        v8 = (void *)v6[4];
        if (v8)
        {
          v9 = v8;

          goto LABEL_12;
        }
      }

    }
    v4 = nw_parameters_copy_local_endpoint(v2[2]);
    goto LABEL_11;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_path_copy_effective_local_endpoint";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_path_copy_effective_local_endpoint";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_path_copy_effective_local_endpoint";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_path_copy_effective_local_endpoint";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_path_copy_effective_local_endpoint";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_29:
  if (v12)
    free(v12);
  v9 = 0;
LABEL_12:

  return v9;
}

nw_endpoint_t nw_parameters_copy_local_endpoint(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = *((id *)v1[13].isa + 20);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_copy_local_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_local_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_copy_local_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_local_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_local_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_content_context_copy_first_repliable_metadata(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  unsigned __int8 *v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[5];
  char v15;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  id v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = 0;
    if (v1 != (os_unfair_lock_s *)&__block_literal_global_5_41741
      && v1 != (os_unfair_lock_s *)&__block_literal_global_4
      && v1 != (os_unfair_lock_s *)&__block_literal_global_3_41726
      && v1 != (os_unfair_lock_s *)&__block_literal_global_41718)
    {
      os_unfair_lock_lock(v1 + 28);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v18 = __Block_byref_object_copy__41932;
      v19 = __Block_byref_object_dispose__41933;
      v20 = 0;
      v4 = *(unsigned __int8 **)&v2[22]._os_unfair_lock_opaque;
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3221225472;
      v14[2] = __nw_content_context_copy_first_repliable_metadata_block_invoke;
      v14[3] = &unk_1E14A8DC0;
      v14[4] = buf;
      nw_array_apply(v4, (uint64_t)v14);
      os_unfair_lock_unlock(v2 + 28);
      v3 = *(id *)(*(_QWORD *)&buf[8] + 40);
      _Block_object_dispose(buf, 8);

    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_content_context_copy_first_repliable_metadata";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_copy_first_repliable_metadata";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_content_context_copy_first_repliable_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_copy_first_repliable_metadata";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_copy_first_repliable_metadata";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v7)
    free(v7);
  v3 = 0;
LABEL_7:

  return v3;
}

BOOL nw_context_get_logging_disabled(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 124) == 4;
  return result;
}

uint64_t NWActivity.__deallocating_deinit()
{
  swift_unknownObjectRelease();
  return swift_deallocClassInstance();
}

uint64_t nw_path_get_policy_id(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 340);
  return result;
}

uint64_t nw_frame_is_wake_packet(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(unsigned __int16 *)(a1 + 204) >> 14) & 1;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_is_wake_packet";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_is_wake_packet";
        v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "__nw_frame_is_wake_packet";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_is_wake_packet";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_is_wake_packet";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

void nw_context_add_cache_entry(void *a1, _QWORD *a2)
{
  id v3;
  void *v4;
  dispatch_queue_t *v5;
  dispatch_queue_t *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  _BOOL8 v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (v3)
  {
    v4 = v3;
    if (a2)
    {
      v5 = (dispatch_queue_t *)v3;
      v6 = v5;
      if (((_BYTE)v5[17] & 8) == 0)
        dispatch_assert_queue_V2(v5[1]);

      v27 = nw_context_copy_cache_context(v6);
      v7 = **(_QWORD **)(v27 + 24);
      *a2 = v7;
      v8 = *(_QWORD **)(v27 + 24);
      if (v7)
        v8 = (_QWORD *)*v8;
      v8[1] = a2;
      **(_QWORD **)(v27 + 24) = a2;
      a2[1] = *(_QWORD *)(v27 + 24);
      v9 = *(_QWORD *)(*(_QWORD *)(v27 + 24) + 16);
      a2[2] = v9;
      v10 = *(_QWORD **)(v27 + 24);
      if (v9)
        v10 = (_QWORD *)v10[2];
      v10[3] = a2 + 2;
      *(_QWORD *)(*(_QWORD *)(v27 + 24) + 16) = a2;
      a2[3] = *(_QWORD *)(v27 + 24) + 16;
      *(int32x2_t *)(*(_QWORD *)(v27 + 24) + 64) = vadd_s32(*(int32x2_t *)(*(_QWORD *)(v27 + 24) + 64), (int32x2_t)0x100000001);

      return;
    }
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_context_add_cache_entry";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v16, &type, &v28))
      goto LABEL_44;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null cache_entry", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_context_add_cache_entry";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v23, "%{public}s called with null cache_entry, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_44;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_182FBE000, v17, v23, "%{public}s called with null cache_entry, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_182FBE000, v17, v26, "%{public}s called with null cache_entry, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_44:
    if (v16)
      free(v16);

    return;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v31 = "nw_context_add_cache_entry";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (__nwlog_fault(v12, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v28)
    {
      v19 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v13, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_context_add_cache_entry";
          v32 = 2082;
          v33 = v19;
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v19);
        goto LABEL_39;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_39:
  if (v12)
    free(v12);
}

void sub_182FD9EA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_endpoint_handler_initialize_association(void *a1)
{
  void **v1;
  void **v2;
  id v3;
  void *v4;
  id *v5;
  void *v6;
  void *v7;
  void *v8;
  int v9;
  os_unfair_lock_s *v10;
  id v11;
  void *v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;

  v1 = a1;
  v2 = v1;
  if (!v1[7])
  {
    v3 = nw_context_copy_registered_endpoint(v1[5], v1[3]);
    v4 = v2[3];
    v2[3] = v3;

    v5 = nw_endpoint_copy_association_with_evaluator(v2[3], v2[4], v2[32]);
    v6 = v2[7];
    v2[7] = v5;

    v7 = v2[7];
    if (v7)
    {
      v8 = v2[4];
      v9 = *((_BYTE *)v2 + 268) & 1;
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 3221225472;
      v13[2] = __nw_endpoint_handler_initialize_association_block_invoke;
      v13[3] = &unk_1E149FB00;
      v10 = v2;
      v14 = v10;
      nw_association_register(v7, v8, v10, v9, v13);
      v11 = nw_association_copy_current_path(v2[7], v2[4]);
      os_unfair_lock_lock(v10 + 28);
      v12 = *(void **)&v10[16]._os_unfair_lock_opaque;
      *(_QWORD *)&v10[16]._os_unfair_lock_opaque = v11;

      os_unfair_lock_unlock(v10 + 28);
    }
    *((_BYTE *)v2 + 268) |= 4u;
  }

}

void sub_182FD9FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

id nw_context_copy_registered_endpoint(void *a1, void *a2)
{
  dispatch_queue_t *v3;
  id v4;
  void *v5;
  id v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      if (((_BYTE)v3[17] & 8) == 0)
        dispatch_assert_queue_V2(v3[1]);
      v6 = nw_context_copy_registered_endpoint_internal(v3, v5, 0);
      goto LABEL_6;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_context_copy_registered_endpoint";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null endpoint", buf, 0xCu);
        }
LABEL_38:

        goto LABEL_39;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_context_copy_registered_endpoint";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
  }
  else
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_context_copy_registered_endpoint";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null context", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_context_copy_registered_endpoint";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
    }
  }
LABEL_39:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_6:

  return v6;
}

void sub_182FDA4CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_context_copy_registered_endpoint_internal(void *a1, void *a2, int a3)
{
  _QWORD *v5;
  id v6;
  void *v7;
  NWConcrete_nw_context *v8;
  NWConcrete_nw_context *v9;
  _BOOL8 v10;
  id v11;
  int v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  int64_t v19;
  uint64_t v20;
  dispatch_time_t v21;
  uint64_t v22;
  id v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t node;
  uint64_t v28;
  uint64_t v29;
  id v30;
  _BOOL8 internal;
  id v32;
  void *v33;
  id v34;
  const char *logging_description;
  void *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  id v40;
  const char *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  id v46;
  void *v47;
  id v48;
  const char *v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  const char *v53;
  const char *v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  const char *v59;
  const char *v60;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  const char *v64;
  const char *v65;
  char *v66;
  NSObject *v67;
  os_log_type_t v68;
  char *v69;
  os_log_type_t v70;
  _BOOL4 v71;
  const char *v72;
  os_log_type_t v73;
  const char *v74;
  os_log_type_t v75;
  const char *v76;
  os_log_type_t v77;
  os_log_type_t v78;
  const char *v79;
  os_log_type_t v80;
  const char *v81;
  os_log_type_t v82;
  const char *v83;
  os_log_type_t v84;
  const char *v85;
  void *v86;
  char *v87;
  NSObject *v88;
  os_log_type_t v89;
  void *v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  void *v94;
  char *v95;
  NSObject *v96;
  os_log_type_t v97;
  char *backtrace_string;
  os_log_type_t v99;
  _BOOL4 v100;
  char *v101;
  os_log_type_t v102;
  _BOOL4 v103;
  void *v104;
  char *v105;
  NSObject *v106;
  os_log_type_t v107;
  char *v108;
  os_log_type_t v109;
  _BOOL4 v110;
  char *v111;
  os_log_type_t v112;
  _BOOL4 v113;
  os_log_type_t v114;
  os_log_type_t v115;
  os_log_type_t v116;
  os_log_type_t v117;
  char v118;
  os_log_type_t type;
  _BYTE v120[24];
  const char *v121;
  id v122[2];
  uint8_t buf[4];
  const char *v124;
  __int16 v125;
  char *v126;
  uint64_t v127;

  v127 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    v86 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v120 = 136446210;
    *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
    v87 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v87, buf, &type))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v88 = objc_claimAutoreleasedReturnValue();
        v89 = buf[0];
        if (os_log_type_enabled(v88, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v88, v89, "%{public}s called with null context", v120, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v88 = objc_claimAutoreleasedReturnValue();
        v99 = buf[0];
        v100 = os_log_type_enabled(v88, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v100)
          {
            *(_DWORD *)v120 = 136446466;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2082;
            *(_QWORD *)&v120[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v88, v99, "%{public}s called with null context, dumping backtrace:%{public}s", v120, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_158;
        }
        if (v100)
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v88, v99, "%{public}s called with null context, no backtrace", v120, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v88 = objc_claimAutoreleasedReturnValue();
        v114 = buf[0];
        if (os_log_type_enabled(v88, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v88, v114, "%{public}s called with null context, backtrace limit exceeded", v120, 0xCu);
        }
      }

    }
LABEL_158:
    if (v87)
      free(v87);
    goto LABEL_172;
  }
  if (!v6)
  {
    __nwlog_obj();
    v90 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v120 = 136446210;
    *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
    v91 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v91, buf, &type))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v92 = objc_claimAutoreleasedReturnValue();
        v93 = buf[0];
        if (os_log_type_enabled(v92, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s called with null endpoint", v120, 0xCu);
        }
      }
      else if (type)
      {
        v101 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v92 = objc_claimAutoreleasedReturnValue();
        v102 = buf[0];
        v103 = os_log_type_enabled(v92, (os_log_type_t)buf[0]);
        if (v101)
        {
          if (v103)
          {
            *(_DWORD *)v120 = 136446466;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2082;
            *(_QWORD *)&v120[14] = v101;
            _os_log_impl(&dword_182FBE000, v92, v102, "%{public}s called with null endpoint, dumping backtrace:%{public}s", v120, 0x16u);
          }

          free(v101);
          goto LABEL_163;
        }
        if (v103)
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v92, v102, "%{public}s called with null endpoint, no backtrace", v120, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v92 = objc_claimAutoreleasedReturnValue();
        v115 = buf[0];
        if (os_log_type_enabled(v92, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v92, v115, "%{public}s called with null endpoint, backtrace limit exceeded", v120, 0xCu);
        }
      }

    }
LABEL_163:
    if (v91)
      free(v91);
    goto LABEL_171;
  }
  v8 = v5;
  v9 = v8;
  if ((*((_BYTE *)v8 + 136) & 8) == 0)
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v8 + 1));

  if (a3)
    v10 = nw_context_copy_globals_context(v9);
  else
    v10 = nw_context_copy_cache_context(v9);
  v5 = (_QWORD *)v10;

  v11 = v7;
  v12 = objc_msgSend(v11, "type");

  if (v12 == 2)
  {
    v13 = (uint64_t *)(v5[3] + 40);
  }
  else if (v12 == 1)
  {
    v13 = (uint64_t *)(v5[3] + 32);
  }
  else
  {
    v13 = (uint64_t *)(v5[3] + 48);
  }
  v14 = *v13;
  if (!*v13)
  {
    __nwlog_obj();
    v94 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v120 = 136446210;
    *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
    v95 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v95, buf, &type))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v97 = buf[0];
        if (os_log_type_enabled(v96, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v96, v97, "%{public}s called with null hash_table", v120, 0xCu);
        }
      }
      else if (type)
      {
        v108 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v109 = buf[0];
        v110 = os_log_type_enabled(v96, (os_log_type_t)buf[0]);
        if (v108)
        {
          if (v110)
          {
            *(_DWORD *)v120 = 136446466;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2082;
            *(_QWORD *)&v120[14] = v108;
            _os_log_impl(&dword_182FBE000, v96, v109, "%{public}s called with null hash_table, dumping backtrace:%{public}s", v120, 0x16u);
          }

          free(v108);
          goto LABEL_169;
        }
        if (v110)
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v96, v109, "%{public}s called with null hash_table, no backtrace", v120, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v116 = buf[0];
        if (os_log_type_enabled(v96, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v120 = 136446210;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_182FBE000, v96, v116, "%{public}s called with null hash_table, backtrace limit exceeded", v120, 0xCu);
        }
      }

    }
LABEL_169:
    if (v95)
      free(v95);
LABEL_171:

LABEL_172:
    v30 = 0;
    goto LABEL_57;
  }
  v15 = v5;
  v16 = v15;
  if ((v15[17] & 7) != 0)
  {
    if (*(_QWORD *)(v15[3] + 56))
      goto LABEL_28;
    *(_QWORD *)v120 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v120[8] = 3221225472;
    *(_QWORD *)&v120[16] = ___ZL28nw_context_start_purge_timerP21NWConcrete_nw_context_block_invoke;
    v121 = (const char *)&unk_1E14ACFD0;
    v17 = v15;
    v122[0] = v17;
    *(_QWORD *)(v16[3] + 56) = nw_queue_context_create_source(v17, 2, 3, 0, v120, 0);
    v18 = *(_QWORD *)(v16[3] + 56);
    if (v18)
    {
      v19 = v17[13];
      if (!v19)
      {
        v19 = 1000 * networkd_settings_get_int64_with_default((const char *)nw_setting_context_purge_delay, 30);
        v18 = *(_QWORD *)(v16[3] + 56);
      }
      v20 = 1000000 * v19;
      v21 = dispatch_time(0x8000000000000000, 1000000 * v19);
      nw_queue_set_timer_values(v18, v21, v20, v20);
      nw_queue_activate_source(*(_QWORD *)(v16[3] + 56), v22);
      goto LABEL_27;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v124 = "nw_context_start_purge_timer";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v118 = 0;
    if (__nwlog_fault(v24, &type, &v118))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v124 = "nw_context_start_purge_timer";
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s nw_queue_context_create_source failed", buf, 0xCu);
        }
      }
      else if (v118)
      {
        v65 = __nw_create_backtrace_string();
        if (v65)
        {
          v66 = (char *)v65;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v67 = (id)gLogObj;
          v68 = type;
          if (os_log_type_enabled(v67, type))
          {
            *(_DWORD *)buf = 136446466;
            v124 = "nw_context_start_purge_timer";
            v125 = 2082;
            v126 = v66;
            _os_log_impl(&dword_182FBE000, v67, v68, "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v66);
          if (!v24)
            goto LABEL_27;
          goto LABEL_26;
        }
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v84 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v124 = "nw_context_start_purge_timer";
          _os_log_impl(&dword_182FBE000, v25, v84, "%{public}s nw_queue_context_create_source failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v77 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v124 = "nw_context_start_purge_timer";
          _os_log_impl(&dword_182FBE000, v25, v77, "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v24)
    {
LABEL_27:

      goto LABEL_28;
    }
LABEL_26:
    free(v24);
    goto LABEL_27;
  }
  __nwlog_obj();
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)v120 = 136446210;
  *(_QWORD *)&v120[4] = "nw_context_start_purge_timer";
  v105 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v105, buf, &type))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v106 = objc_claimAutoreleasedReturnValue();
      v107 = buf[0];
      if (os_log_type_enabled(v106, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v120 = 136446210;
        *(_QWORD *)&v120[4] = "nw_context_start_purge_timer";
        _os_log_impl(&dword_182FBE000, v106, v107, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context))", v120, 0xCu);
      }
    }
    else if (type)
    {
      v111 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v106 = objc_claimAutoreleasedReturnValue();
      v112 = buf[0];
      v113 = os_log_type_enabled(v106, (os_log_type_t)buf[0]);
      if (v111)
      {
        if (v113)
        {
          *(_DWORD *)v120 = 136446466;
          *(_QWORD *)&v120[4] = "nw_context_start_purge_timer";
          *(_WORD *)&v120[12] = 2082;
          *(_QWORD *)&v120[14] = v111;
          _os_log_impl(&dword_182FBE000, v106, v112, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), dumping backtrace:%{public}s", v120, 0x16u);
        }

        free(v111);
        goto LABEL_179;
      }
      if (v113)
      {
        *(_DWORD *)v120 = 136446210;
        *(_QWORD *)&v120[4] = "nw_context_start_purge_timer";
        _os_log_impl(&dword_182FBE000, v106, v112, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), no backtrace", v120, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v106 = objc_claimAutoreleasedReturnValue();
      v117 = buf[0];
      if (os_log_type_enabled(v106, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v120 = 136446210;
        *(_QWORD *)&v120[4] = "nw_context_start_purge_timer";
        _os_log_impl(&dword_182FBE000, v106, v117, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), backtrace limit exceeded", v120, 0xCu);
      }
    }

  }
LABEL_179:
  if (v105)
    free(v105);
LABEL_28:

  node = nw_hash_table_get_node(v14, (uint64_t)v11, 0);
  if (!node)
  {
    internal = nw_hash_table_create_internal(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_context_object_get_key, (unsigned int (*)(const void *, unsigned int))nw_context_endpoint_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_context_endpoint_matches_key, (void (*)(void *))nw_context_object_release);
    v32 = v11;
    v33 = (void *)objc_msgSend(v32, "copyEndpoint");
    nw_endpoint_copy_properties(v32, v33);

    nw_endpoint_set_context(v33, v16);
    nw_endpoint_set_is_registered(v33);
    buf[0] = 0;
    v30 = v33;
    nw_hash_table_add_object(internal, (uint64_t)v30, (char *)buf);
    if (buf[0])
      goto LABEL_39;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = (id)gLogObj;
    logging_description = nw_endpoint_get_logging_description(v30);
    *(_DWORD *)v120 = 136446722;
    *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
    *(_WORD *)&v120[12] = 2114;
    *(_QWORD *)&v120[14] = v16;
    *(_WORD *)&v120[22] = 2082;
    v121 = logging_description;
    v36 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v118 = 0;
    if (__nwlog_fault((const char *)v36, &type, &v118))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = (id)gLogObj;
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          v39 = nw_endpoint_get_logging_description(v30);
          *(_DWORD *)v120 = 136446722;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v120[12] = 2114;
          *(_QWORD *)&v120[14] = v16;
          *(_WORD *)&v120[22] = 2082;
          v121 = v39;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s %{public}@ failed to add endpoint %{public}s", v120, 0x20u);
        }
      }
      else if (v118)
      {
        v55 = __nw_create_backtrace_string();
        if (v55)
        {
          v56 = (char *)v55;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = (id)gLogObj;
          v58 = type;
          if (os_log_type_enabled(v57, type))
          {
            v59 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446978;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(_QWORD *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v59;
            LOWORD(v122[0]) = 2082;
            *(id *)((char *)v122 + 2) = v56;
            _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s %{public}@ failed to add endpoint %{public}s, dumping backtrace:%{public}s", v120, 0x2Au);
          }

          free(v56);
          if (!v36)
          {
LABEL_39:
            nw_hash_table_add_object(v14, internal, (char *)buf);
            if (buf[0])
              goto LABEL_56;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v40 = (id)gLogObj;
            v41 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446722;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(_QWORD *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v41;
            v42 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v118 = 0;
            if (__nwlog_fault(v42, &type, &v118))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v43 = (id)gLogObj;
                v44 = type;
                if (os_log_type_enabled(v43, type))
                {
                  v45 = nw_endpoint_get_logging_description(v30);
                  *(_DWORD *)v120 = 136446722;
                  *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
                  *(_WORD *)&v120[12] = 2114;
                  *(_QWORD *)&v120[14] = v16;
                  *(_WORD *)&v120[22] = 2082;
                  v121 = v45;
                  _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s", v120, 0x20u);
                }
              }
              else if (v118)
              {
                v60 = __nw_create_backtrace_string();
                if (v60)
                {
                  v61 = (char *)v60;
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v62 = (id)gLogObj;
                  v63 = type;
                  if (os_log_type_enabled(v62, type))
                  {
                    v64 = nw_endpoint_get_logging_description(v30);
                    *(_DWORD *)v120 = 136446978;
                    *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
                    *(_WORD *)&v120[12] = 2114;
                    *(_QWORD *)&v120[14] = v16;
                    *(_WORD *)&v120[22] = 2082;
                    v121 = v64;
                    LOWORD(v122[0]) = 2082;
                    *(id *)((char *)v122 + 2) = v61;
                    _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s, dumping backtrace:%{public}s", v120, 0x2Au);
                  }

                  free(v61);
                  if (!v42)
                    goto LABEL_56;
                  goto LABEL_46;
                }
                __nwlog_obj();
                v43 = objc_claimAutoreleasedReturnValue();
                v82 = type;
                if (os_log_type_enabled(v43, type))
                {
                  v83 = nw_endpoint_get_logging_description(v30);
                  *(_DWORD *)v120 = 136446722;
                  *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
                  *(_WORD *)&v120[12] = 2114;
                  *(_QWORD *)&v120[14] = v16;
                  *(_WORD *)&v120[22] = 2082;
                  v121 = v83;
                  _os_log_impl(&dword_182FBE000, v43, v82, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s, no backtrace", v120, 0x20u);
                }
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v43 = (id)gLogObj;
                v75 = type;
                if (os_log_type_enabled(v43, type))
                {
                  v76 = nw_endpoint_get_logging_description(v30);
                  *(_DWORD *)v120 = 136446722;
                  *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
                  *(_WORD *)&v120[12] = 2114;
                  *(_QWORD *)&v120[14] = v16;
                  *(_WORD *)&v120[22] = 2082;
                  v121 = v76;
                  _os_log_impl(&dword_182FBE000, v43, v75, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s, backtrace limit exceeded", v120, 0x20u);
                }
              }

            }
            if (!v42)
              goto LABEL_56;
LABEL_46:
            free(v42);
            goto LABEL_56;
          }
LABEL_38:
          free(v36);
          goto LABEL_39;
        }
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v37, type))
        {
          v79 = nw_endpoint_get_logging_description(v30);
          *(_DWORD *)v120 = 136446722;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v120[12] = 2114;
          *(_QWORD *)&v120[14] = v16;
          *(_WORD *)&v120[22] = 2082;
          v121 = v79;
          _os_log_impl(&dword_182FBE000, v37, v78, "%{public}s %{public}@ failed to add endpoint %{public}s, no backtrace", v120, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = (id)gLogObj;
        v73 = type;
        if (os_log_type_enabled(v37, type))
        {
          v74 = nw_endpoint_get_logging_description(v30);
          *(_DWORD *)v120 = 136446722;
          *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v120[12] = 2114;
          *(_QWORD *)&v120[14] = v16;
          *(_WORD *)&v120[22] = 2082;
          v121 = v74;
          _os_log_impl(&dword_182FBE000, v37, v73, "%{public}s %{public}@ failed to add endpoint %{public}s, backtrace limit exceeded", v120, 0x20u);
        }
      }

    }
    if (!v36)
      goto LABEL_39;
    goto LABEL_38;
  }
  v28 = *(_QWORD *)(node + 16);
  v29 = nw_hash_table_get_node(v28, (uint64_t)v11, 0);
  if (!v29)
  {
    buf[0] = 0;
    v46 = v11;
    v47 = (void *)objc_msgSend(v46, "copyEndpoint");
    nw_endpoint_copy_properties(v46, v47);

    nw_endpoint_set_context(v47, v16);
    nw_endpoint_set_is_registered(v47);
    v30 = v47;
    nw_hash_table_add_object(v28, (uint64_t)v30, (char *)buf);
    if (!buf[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = (id)gLogObj;
      v49 = nw_endpoint_get_logging_description(v30);
      *(_DWORD *)v120 = 136446722;
      *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
      *(_WORD *)&v120[12] = 2114;
      *(_QWORD *)&v120[14] = v16;
      *(_WORD *)&v120[22] = 2082;
      v121 = v49;
      v50 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v118 = 0;
      if (__nwlog_fault(v50, &type, &v118))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v51 = (id)gLogObj;
          v52 = type;
          if (os_log_type_enabled(v51, type))
          {
            v53 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446722;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(_QWORD *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v53;
            _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s %{public}@ failed to add endpoint %{public}s", v120, 0x20u);
          }
        }
        else if (v118)
        {
          v69 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v51 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          v71 = os_log_type_enabled(v51, type);
          if (v69)
          {
            if (v71)
            {
              v72 = nw_endpoint_get_logging_description(v30);
              *(_DWORD *)v120 = 136446978;
              *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
              *(_WORD *)&v120[12] = 2114;
              *(_QWORD *)&v120[14] = v16;
              *(_WORD *)&v120[22] = 2082;
              v121 = v72;
              LOWORD(v122[0]) = 2082;
              *(id *)((char *)v122 + 2) = v69;
              _os_log_impl(&dword_182FBE000, v51, v70, "%{public}s %{public}@ failed to add endpoint %{public}s, dumping backtrace:%{public}s", v120, 0x2Au);
            }

            free(v69);
            if (!v50)
              goto LABEL_56;
            goto LABEL_55;
          }
          if (v71)
          {
            v85 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446722;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(_QWORD *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v85;
            _os_log_impl(&dword_182FBE000, v51, v70, "%{public}s %{public}@ failed to add endpoint %{public}s, no backtrace", v120, 0x20u);
          }
        }
        else
        {
          __nwlog_obj();
          v51 = objc_claimAutoreleasedReturnValue();
          v80 = type;
          if (os_log_type_enabled(v51, type))
          {
            v81 = nw_endpoint_get_logging_description(v30);
            *(_DWORD *)v120 = 136446722;
            *(_QWORD *)&v120[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v120[12] = 2114;
            *(_QWORD *)&v120[14] = v16;
            *(_WORD *)&v120[22] = 2082;
            v121 = v81;
            _os_log_impl(&dword_182FBE000, v51, v80, "%{public}s %{public}@ failed to add endpoint %{public}s, backtrace limit exceeded", v120, 0x20u);
          }
        }

      }
      if (v50)
LABEL_55:
        free(v50);
    }
LABEL_56:

    goto LABEL_57;
  }
  v30 = *(id *)(v29 + 16);

LABEL_57:
  return v30;
}

void sub_182FDBC04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

BOOL nw_context_copy_cache_context(void *a1)
{
  _BYTE *v1;
  _BYTE *v2;
  _BYTE *v3;
  int v4;
  void *v5;
  _QWORD *v6;
  NSObject *v7;
  void *v8;
  _BOOL8 result;

  v1 = a1;
  v2 = v1;
  if ((v1[136] & 4) != 0 || (v3 = v1, v4 = v2[136] & 3, v3, v4))
  {
    v5 = (void *)*((_QWORD *)v2 + 5);
    if (!v5)
      v5 = v2;
  }
  else
  {
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    v5 = (void *)nw_context_copy_implicit_context::implicit_context;
  }
  v6 = v5;
  if (v6[3])
    goto LABEL_8;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  v8 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v8);
  if (!result)
  {
    free(v8);
LABEL_8:

    return (BOOL)v6;
  }
  __break(1u);
  return result;
}

id *nw_endpoint_copy_association_with_evaluator(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  _QWORD *v9;
  id v10;
  uint64_t internal;
  NSObject *v12;
  uint64_t node;
  id *v14;
  id *v15;
  id v16;
  id v17;
  os_unfair_lock_s *v18;
  os_unfair_lock_s *v19;
  id *v20;
  id v21;
  _QWORD *v22;
  id v23;
  void *v24;
  id v25;
  _QWORD *v26;
  id v27;
  NWConcrete_nw_association *v28;
  NWConcrete_nw_association *v29;
  void **p_evaluator;
  os_unfair_lock_s *v31;
  os_unfair_lock_s *v32;
  id *v33;
  id v34;
  OS_nw_path *v35;
  OS_nw_path *previous_path;
  OS_nw_path_evaluator *evaluator;
  uint64_t v38;
  id v39;
  id v41;
  void *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  void *v46;
  os_log_type_t v47;
  char *backtrace_string;
  os_log_type_t v49;
  _BOOL4 v50;
  char *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  os_log_type_t v54;
  os_log_type_t v55;
  void *v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  char *v60;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  void *v64;
  void *v65;
  id v66;
  void *v67;
  char v68;
  os_log_type_t type;
  _BYTE buf[24];
  void *v71;
  NWConcrete_nw_association *v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    v41 = v7;
    __nwlog_obj();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
    v43 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v43, &type, &v68))
      goto LABEL_69;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v68)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v49 = type;
      v50 = os_log_type_enabled(v44, type);
      if (backtrace_string)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v44, v49, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_69:
        if (!v43)
        {
LABEL_71:
          v15 = 0;
          v8 = v41;
          goto LABEL_30;
        }
LABEL_70:
        free(v43);
        goto LABEL_71;
      }
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_182FBE000, v44, v49, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v54 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_182FBE000, v44, v54, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_68:

    goto LABEL_69;
  }
  if (!v6)
  {
    v41 = v7;
    __nwlog_obj();
    v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
    v43 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v43, &type, &v68))
      goto LABEL_69;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_182FBE000, v44, v47, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v68)
    {
      v51 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v52 = type;
      v53 = os_log_type_enabled(v44, type);
      if (v51)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v51;
          _os_log_impl(&dword_182FBE000, v44, v52, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v51);
        if (!v43)
          goto LABEL_71;
        goto LABEL_70;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_182FBE000, v44, v52, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v55 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_182FBE000, v44, v55, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_68;
  }
  if (*((_QWORD *)v5 + 1))
  {
    v9 = v6;
    v10 = *(id *)(v9[13] + 136);

    v67 = v8;
    nw_context_assert_queue(v10);
    if ((nw_context_caches_are_shared(v10, *((void **)v5 + 1)) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        v24 = (void *)*((_QWORD *)v5 + 1);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_endpoint_copy_association_with_evaluator";
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v10;
        *(_WORD *)&buf[22] = 2112;
        v71 = v24;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_INFO, "%{public}s nw_context_caches_are_shared(context (%@), endpoint->context (%@)) is false", buf, 0x20u);
      }
      v15 = 0;
      goto LABEL_29;
    }
    if (!*((_QWORD *)v5 + 25))
    {
      internal = nw_hash_table_create_internal(5u, 0, (const void *(*)(const void *, unsigned int *))nw_endpoint_association_get_key, (unsigned int (*)(const void *, unsigned int))nw_endpoint_association_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_endpoint_association_matches_key, (void (*)(void *))nw_endpoint_association_release);
      if (internal)
        *(_DWORD *)(internal + 48) &= ~2u;
      *((_QWORD *)v5 + 25) = internal;
    }
    v12 = nw_parameters_copy_path_parameters(v9, 0);
    node = nw_hash_table_get_node(*((_QWORD *)v5 + 25), (uint64_t)v12, 0);
    if (!node)
    {
      type = OS_LOG_TYPE_DEFAULT;
      v25 = v5;
      v26 = v9;
      v27 = v8;
      v64 = v25;
      v65 = v26;
      v28 = nw_association_create(v25, v26);
      v29 = v28;
      if (v27)
      {
        p_evaluator = (void **)&v28->evaluator;
        objc_storeStrong((id *)&v28->evaluator, a3);
        *((_BYTE *)v29 + 76) &= ~1u;
        v31 = (os_unfair_lock_s *)*p_evaluator;
        if (*p_evaluator)
        {
          v32 = v31 + 24;
          v33 = v31;
          os_unfair_lock_lock(v32);
          v34 = v33[6];
          os_unfair_lock_unlock(v32);

        }
        else
        {
          v34 = 0;
        }
        v35 = (OS_nw_path *)nw_path_copy_without_parameters(v34);
        previous_path = v29->previous_path;
        v29->previous_path = v35;

        evaluator = v29->evaluator;
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __nw_association_create_with_evaluator_block_invoke;
        v71 = &unk_1E14AC2C8;
        v72 = v29;
        nw_path_evaluator_set_update_handler(evaluator, 0, buf);

      }
      v38 = *((_QWORD *)v5 + 25);
      v15 = v29;
      nw_hash_table_add_object(v38, (uint64_t)v15, (char *)&type);
      goto LABEL_29;
    }
    v14 = (id *)*(id *)(node + 16);
    v15 = v14;
    if (!v8)
    {
LABEL_29:

      v8 = v67;
      goto LABEL_30;
    }
    v15 = v14;
    v16 = v8;
    if (v15)
    {
      if ((*((_BYTE *)v15 + 76) & 1) != 0)
      {
        v17 = v16;
        objc_storeStrong(v15 + 3, a3);
        *((_BYTE *)v15 + 76) &= ~1u;
        v18 = (os_unfair_lock_s *)v15[3];
        if (v18)
        {
          v19 = v18 + 24;
          v20 = v18;
          os_unfair_lock_lock(v19);
          v21 = v20[6];
          os_unfair_lock_unlock(v19);

          if (v21)
          {
            v22 = nw_path_copy_without_parameters(v21);
            v23 = v15[4];
            v15[4] = v22;

          }
        }
        else
        {
          v21 = 0;
        }
        v39 = v15[3];
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __nw_association_update_with_evaluator_block_invoke;
        v71 = &unk_1E14AC2C8;
        v72 = v15;
        nw_path_evaluator_set_update_handler(v39, 0, buf);

        v16 = v17;
      }
LABEL_28:

      goto LABEL_29;
    }
    v66 = v16;
    __nwlog_obj();
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_association_update_with_evaluator";
    v57 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (__nwlog_fault(v57, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v68)
      {
        v60 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        v61 = type;
        v62 = os_log_type_enabled(v58, type);
        if (v60)
        {
          if (v62)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_association_update_with_evaluator";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v60;
            _os_log_impl(&dword_182FBE000, v58, v61, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v60);
          goto LABEL_83;
        }
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_182FBE000, v58, v61, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_182FBE000, v58, v63, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_83:
    if (v57)
      free(v57);
    v16 = v66;
    goto LABEL_28;
  }
  v15 = 0;
LABEL_30:

  return v15;
}

void sub_182FDCA4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

id nw_parameters_copy_path_parameters(void *a1, int a2)
{
  _QWORD *v3;
  id v4;
  uint64_t v5;
  void *v6;
  NWConcrete_nw_protocol_options *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  NWConcrete_nw_protocol_options *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  id v15;
  id v16;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = v3[19];
    if (v5)
    {
      v6 = *(void **)(v5 + 24);
      if (a2)
      {
        if (v6)
        {
          v7 = nw_protocol_options_copy(*(void **)(v5 + 24));
          v8 = *((_QWORD *)v4 + 13);
          v9 = *(void **)(v8 + 144);
          *(_QWORD *)(v8 + 144) = v7;

          v5 = *((_QWORD *)v4 + 19);
        }
        v10 = *(void **)(v5 + 48);
        if (!v10)
          goto LABEL_10;
        v11 = nw_protocol_options_copy(v10);
        v12 = *((_QWORD *)v4 + 13);
        v13 = *(void **)(v12 + 152);
        *(_QWORD *)(v12 + 152) = v11;
      }
      else
      {
        objc_storeStrong((id *)(v3[13] + 144), v6);
        v14 = *((_QWORD *)v4 + 13);
        v15 = *(id *)(*((_QWORD *)v4 + 19) + 48);
        v13 = *(void **)(v14 + 152);
        *(_QWORD *)(v14 + 152) = v15;
      }

    }
LABEL_10:
    v16 = *((id *)v4 + 13);
    goto LABEL_11;
  }
  __nwlog_obj();
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v29 = "nw_parameters_copy_path_parameters";
  v19 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v19, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_parameters_copy_path_parameters";
        _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_parameters_copy_path_parameters";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_parameters_copy_path_parameters";
        _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_parameters_copy_path_parameters";
        _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_28:
  if (v19)
    free(v19);
  v16 = 0;
LABEL_11:

  return v16;
}

void sub_182FDCDF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_182FDD178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_protocol_options;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

uint64_t nw_context_caches_are_shared(void *a1, void *a2)
{
  _BYTE *v3;
  _BYTE *v4;
  char v5;
  uint64_t v6;

  v3 = a1;
  v4 = a2;
  if (v3 == v4)
    goto LABEL_12;
  if (nw_context_get_isolate_protocol_cache(v3))
  {
    v5 = v3[136];
    if ((v5 & 4) == 0)
      goto LABEL_7;
  }
  if (!nw_context_get_isolate_protocol_cache(v4) || (v4[136] & 4) != 0)
  {
LABEL_12:
    v6 = 1;
    goto LABEL_13;
  }
  v5 = v3[136];
LABEL_7:
  if ((v5 & 0x20) != 0 && *((_BYTE **)v4 + 5) == v3 || (v4[136] & 0x20) != 0 && *((_BYTE **)v3 + 5) == v4)
    goto LABEL_12;
  v6 = 0;
LABEL_13:

  return v6;
}

void sub_182FDD2B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_protocol_metadata;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_182FDD3B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_url_endpoint;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_182FDD64C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, objc_super a11)
{
  void *v11;

  a11.super_class = (Class)NWConcrete_nw_endpoint;
  -[_Unwind_Exception dealloc](&a11, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_endpoint_clear_alternatives(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  _QWORD v11[4];
  id v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = __nw_endpoint_clear_alternatives_block_invoke;
    v11[3] = &unk_1E14ACFD0;
    v12 = v1;
    nw_endpoint_locked(v12, v11);

    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_clear_alternatives";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v4, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_clear_alternatives";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

void sub_182FDD968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

void nw_endpoint_locked(void *a1, void *a2)
{
  void (**v3)(_QWORD);
  os_unfair_lock_s *v4;

  v4 = a1;
  v3 = a2;
  os_unfair_lock_lock(v4 + 44);
  v3[2](v3);

  os_unfair_lock_unlock(v4 + 44);
}

void sub_182FDD9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void __nw_endpoint_clear_alternatives_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v3;
  void *v4;
  void *v5;
  _QWORD *v6;
  _QWORD *v7;

  v1 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 160);
  if (v1)
  {
    do
    {
      v3 = (_QWORD *)*v1;
      v4 = (void *)v1[2];
      v1[2] = 0;

      v5 = (void *)v1[3];
      v1[3] = 0;

      v6 = (_QWORD *)*v1;
      v7 = (_QWORD *)v1[1];
      if (*v1)
      {
        v6[1] = v7;
        v7 = (_QWORD *)v1[1];
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 168) = v7;
      }
      *v7 = v6;
      *v1 = 0;
      v1[1] = 0;
      if (v1 != (_QWORD *)(*(_QWORD *)(a1 + 32) + 128))
        free(v1);
      v1 = v3;
    }
    while (v3);
  }
}

uint64_t __nw_endpoint_enumerate_alternatives_block_invoke(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = result;
  v2 = (_QWORD *)(*(_QWORD *)(result + 32) + 160);
  do
  {
    v2 = (_QWORD *)*v2;
    if (!v2)
      break;
    result = (*(uint64_t (**)(void))(*(_QWORD *)(v1 + 40) + 16))();
  }
  while ((result & 1) != 0);
  return result;
}

void nw_endpoint_set_is_registered(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 231) |= 4u;
    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_endpoint_set_is_registered";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_endpoint_set_is_registered";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_endpoint_set_is_registered";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_endpoint_set_is_registered";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_endpoint_set_is_registered";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

void nw_endpoint_set_context(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_endpoint_set_context";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_endpoint_set_context";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_endpoint_set_context";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_endpoint_set_context";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_endpoint_set_context";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    objc_storeStrong(v3 + 1, a2);
    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_endpoint_set_context";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_endpoint_set_context";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_endpoint_set_context";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_endpoint_set_context";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_endpoint_set_context";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

void __nw_endpoint_add_alternative_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  void *v4;
  _QWORD *v5;
  uint64_t v6;
  void *v7;
  _QWORD *v8;
  id *v9;
  id **v10;
  uint64_t v11;
  _QWORD *v12;
  NSObject *v13;
  void *v14;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD **)(v2 + 160);
  if (!v3)
    goto LABEL_24;
  v4 = *(void **)(a1 + 40);
  if (v4 == &__block_literal_global_6232)
  {
    while (1)
    {
      v12 = (_QWORD *)*v3;
      if (v3[3] == *(_QWORD *)(a1 + 48) && (_UNKNOWN *)v3[2] == &__block_literal_global_6232)
        return;
      v3 = (_QWORD *)*v3;
      if (!v12)
        goto LABEL_22;
    }
  }
  while (1)
  {
    v5 = (_QWORD *)*v3;
    if (v4 == &__block_literal_global_6232)
    {
      if (v3[3] == *(_QWORD *)(a1 + 48) && (_UNKNOWN *)v3[2] == &__block_literal_global_6232)
        return;
    }
    else
    {
      v6 = *(_QWORD *)(a1 + 48);
      if (v6 && (_UNKNOWN *)v3[2] == &__block_literal_global_6232 && v3[3] == v6)
      {
        v8 = (_QWORD *)v3[1];
        if (v5)
        {
          v5[1] = v8;
          v8 = (_QWORD *)v3[1];
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 168) = v8;
        }
        *v8 = v5;
        *v3 = 0;
        v3[1] = 0;
        if (v3 != (_QWORD *)(*(_QWORD *)(a1 + 32) + 128))
          free(v3);
      }
      else if (v3[3] == v6)
      {
        v7 = (void *)v3[2];
        if (v7 != &__block_literal_global_6232 && (nw_endpoint_is_equal(v7, v4, 31) & 1) != 0)
          return;
      }
    }
    if (!v5)
      break;
    v4 = *(void **)(a1 + 40);
    v3 = v5;
  }
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(v2 + 160))
  {
LABEL_24:
    objc_storeStrong((id *)(v2 + 144), *(id *)(a1 + 40));
    objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 152), *(id *)(a1 + 48));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 128) = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 136) = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 168);
    **(_QWORD **)(*(_QWORD *)(a1 + 32) + 168) = *(_QWORD *)(a1 + 32) + 128;
    v11 = *(_QWORD *)(a1 + 32);
    v9 = (id *)(v11 + 128);
    goto LABEL_25;
  }
LABEL_22:
  v9 = (id *)malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (v9)
  {
LABEL_23:
    objc_storeStrong(v9 + 2, *(id *)(a1 + 40));
    objc_storeStrong(v9 + 3, *(id *)(a1 + 48));
    *v9 = 0;
    v10 = *(id ***)(*(_QWORD *)(a1 + 32) + 168);
    v9[1] = v10;
    *v10 = v9;
    v11 = *(_QWORD *)(a1 + 32);
LABEL_25:
    *(_QWORD *)(v11 + 168) = v9;
    return;
  }
  __nwlog_obj();
  v13 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  v14 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v14))
  {
    free(v14);
    goto LABEL_23;
  }
  __break(1u);
}

void __nw_endpoint_enumerate_edges_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 216);
  v3 = nw_array_create();
  v4 = v3;
  if (v2)
  {
    if (v3 == v2)
      v4 = v2;
    else
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v3 + 16, *(void ***)(v2 + 16), *(void ***)(v2 + 24), (uint64_t)(*(_QWORD *)(v2 + 24) - *(_QWORD *)(v2 + 16)) >> 3);
  }
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v6 = *(void **)(v5 + 40);
  *(_QWORD *)(v5 + 40) = v4;

}

uint64_t __nw_connection_create_with_id_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  char *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *logging_description;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  if (!v6)
  {
    if (v5 == &__block_literal_global_6232)
      goto LABEL_25;
    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
    if (!v13 || nw_path_parameters_get_logging_disabled(*(_QWORD *)(v13 + 104)))
      goto LABEL_25;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v8 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      goto LABEL_24;
    v14 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
    v17 = 136446722;
    v18 = "nw_connection_create_with_id_block_invoke";
    v19 = 1024;
    v20 = v14;
    v21 = 2082;
    logging_description = nw_endpoint_get_logging_description(v5);
    v10 = "%{public}s [C%u] has alternative %{public}s";
LABEL_22:
    v11 = v8;
    v12 = 28;
    goto LABEL_23;
  }
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  if (v5 == &__block_literal_global_6232)
  {
    if (!v7 || nw_path_parameters_get_logging_disabled(*(_QWORD *)(v7 + 104)))
      goto LABEL_25;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v8 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      goto LABEL_24;
    v15 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
    v17 = 136446722;
    v18 = "nw_connection_create_with_id_block_invoke";
    v19 = 1024;
    v20 = v15;
    v21 = 2114;
    logging_description = v6;
    v10 = "%{public}s [C%u] has alternative UNKNOWN for %{public}@";
    goto LABEL_22;
  }
  if (v7 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v7 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v8 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      goto LABEL_24;
    v9 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
    v17 = 136446978;
    v18 = "nw_connection_create_with_id_block_invoke";
    v19 = 1024;
    v20 = v9;
    v21 = 2082;
    logging_description = nw_endpoint_get_logging_description(v5);
    v23 = 2114;
    v24 = v6;
    v10 = "%{public}s [C%u] has alternative %{public}s for %{public}@";
    v11 = v8;
    v12 = 38;
LABEL_23:
    _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, v10, (uint8_t *)&v17, v12);
LABEL_24:

  }
LABEL_25:

  return 1;
}

void sub_182FDE9BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[5];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 216);
  if (v2)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke_2;
    v3[3] = &unk_1E149B2E0;
    v3[4] = *(_QWORD *)(a1 + 40);
    nw_array_remove_objects(v2, (uint64_t)v3);
  }
}

uint64_t ___ZL36nw_endpoint_transform_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  id *v10;
  id *v11;
  int minimize_logging;
  char logging_disabled;
  NSObject *v14;
  const char *v15;
  const char *v16;
  nw_endpoint_t v17;
  const char *v18;
  const char *v19;
  const char *v20;
  id v21;
  const char *id_string;
  const char *v24;
  nw_endpoint_t v25;
  const char *logging_description;
  const char *v27;
  const char *v28;
  id v29;
  NSObject *loga;
  NSObject *log;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  id v45;
  __int16 v46;
  void *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = v6;
  v8 = 1;
  if (v5)
  {
    if (v6)
    {
      if (v5 != &__block_literal_global_6232)
      {
        v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32);
        if (v9)
        {
          v11 = *(id **)(v9 + 16);
          v10 = *(id **)(v9 + 24);
          if (v11 != v10)
          {
            while (*v11 != v6)
            {
              if (++v11 == v10)
              {
                v11 = v10;
                break;
              }
            }
          }
          if (v11 == v10)
          {
            v8 = 1;
            goto LABEL_19;
          }
          minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40));
          logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40));
          if (minimize_logging)
          {
            if ((logging_disabled & 1) != 0)
              goto LABEL_17;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            log = (id)gconnectionLogObj;
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
            {
              id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
              v24 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
              v25 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
              logging_description = nw_endpoint_get_logging_description(v25);
              v27 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
              v28 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
              v29 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
              *(_DWORD *)buf = 136448002;
              v33 = "nw_endpoint_transform_receive_report_block_invoke";
              v34 = 2082;
              v35 = id_string;
              v36 = 2082;
              v37 = v24;
              v38 = 2082;
              v39 = logging_description;
              v40 = 2082;
              v41 = v27;
              v42 = 2082;
              v43 = v28;
              v44 = 2114;
              v45 = v29;
              v46 = 2114;
              v47 = v7;
              v14 = log;
              _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] updated endpoint alternatives allow %{public}@, restarting", buf, 0x52u);

            }
            else
            {
              v14 = log;
            }
          }
          else
          {
            if ((logging_disabled & 1) != 0)
            {
LABEL_17:
              v8 = 0;
              *(_BYTE *)(*(_QWORD *)(a1 + 32) + 96) = 1;
              *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
              goto LABEL_19;
            }
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v14 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
            {
              v15 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
              v16 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
              loga = v14;
              v17 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
              v18 = nw_endpoint_get_logging_description(v17);
              v19 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
              v20 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
              v21 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
              *(_DWORD *)buf = 136448002;
              v33 = "nw_endpoint_transform_receive_report_block_invoke";
              v34 = 2082;
              v35 = v15;
              v36 = 2082;
              v37 = v16;
              v38 = 2082;
              v39 = v18;
              v40 = 2082;
              v41 = v19;
              v42 = 2082;
              v43 = v20;
              v44 = 2114;
              v45 = v21;
              v46 = 2114;
              v47 = v7;
              v14 = loga;
              _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] updated endpoint alternatives allow %{public}@, restarting", buf, 0x52u);

            }
          }

          goto LABEL_17;
        }
      }
    }
  }
LABEL_19:

  return v8;
}

void sub_182FDEE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

nw_protocol_definition_t nw_protocol_copy_tcp_definition(void)
{
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
  return (nw_protocol_definition_t)(id)g_tcp_definition;
}

id nw_parameters_copy_context(void *a1)
{
  id v1;
  void *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(id *)(*((_QWORD *)v1 + 13) + 136);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_copy_context";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_copy_context";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_context_get_globals_for_path(void *a1)
{
  NWConcrete_nw_context *v1;
  void *v2;
  uint64_t v3;
  _BOOL8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  _BOOL8 result;
  void *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  uint64_t v18;
  os_log_type_t v19;
  _BOOL4 v20;
  NSObject *v21;
  void *v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = &__block_literal_global_389;
  if (!v1)
  {
    __nwlog_obj(v2, v3);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_context_get_globals_for_path";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    v13 = __nwlog_fault(v12, &type, &v24);
    if ((_DWORD)v13)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj(v13, v14);
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_context_get_globals_for_path";
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj(backtrace_string, v18);
        v15 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        v20 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_context_get_globals_for_path";
            v28 = 2082;
            v29 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v15, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_context_get_globals_for_path";
          _os_log_impl(&dword_182FBE000, v15, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj(v13, v14);
        v15 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_context_get_globals_for_path";
          _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_25:
    if (v12)
      free(v12);
    v6 = 0;
    goto LABEL_6;
  }
  v4 = nw_context_copy_globals_context(v1);

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(v4 + 32) + 44));
  v5 = *(_QWORD *)(v4 + 32);
  v6 = *(_QWORD *)(v5 + 68);
  if (v6)
  {
LABEL_5:
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 44));

LABEL_6:
    return v6;
  }
  v8 = malloc_type_calloc(1uLL, 0x98uLL, 0xEAFB8F1AuLL);
  if (v8)
  {
LABEL_4:
    *(_QWORD *)(*(_QWORD *)(v4 + 32) + 68) = v8;
    v9 = *(_QWORD *)(*(_QWORD *)(v4 + 32) + 68);
    *(_OWORD *)(v9 + 112) = 0u;
    *(_OWORD *)(v9 + 128) = 0u;
    *(_QWORD *)(v9 + 144) = 0;
    *(_OWORD *)(v9 + 80) = 0u;
    *(_OWORD *)(v9 + 96) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 16) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)v9 = 0u;
    *(_QWORD *)(v9 + 132) = -1;
    v5 = *(_QWORD *)(v4 + 32);
    v6 = *(_QWORD *)(v5 + 68);
    goto LABEL_5;
  }
  __nwlog_obj(0, v7);
  v21 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v27 = "strict_calloc";
  v28 = 2048;
  v29 = 1;
  v30 = 2048;
  v31 = 152;
  v22 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v22);
  if (!result)
  {
    free(v22);
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

void sub_182FDF500(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *nw_dictionary_copy_value(uint64_t a1, uint64_t a2)
{
  void *pointer;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char *v10;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_dictionary_copy_value";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_copy_value";
      v7 = "%{public}s called with null dictionary";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_dictionary_copy_value";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_47:
        if (!v4)
          return 0;
LABEL_48:
        free(v4);
        return 0;
      }
      if (!v9)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_copy_value";
      v7 = "%{public}s called with null dictionary, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_copy_value";
      v7 = "%{public}s called with null dictionary, backtrace limit exceeded";
    }
    goto LABEL_46;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_dictionary_copy_value";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14))
      goto LABEL_47;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v14)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_copy_value";
        v7 = "%{public}s called with null key, backtrace limit exceeded";
        goto LABEL_46;
      }
      v10 = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (!v10)
      {
        if (!v11)
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_copy_value";
        v7 = "%{public}s called with null key, no backtrace";
        goto LABEL_46;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v17 = "nw_dictionary_copy_value";
        v18 = 2082;
        v19 = v10;
        v12 = "%{public}s called with null key, dumping backtrace:%{public}s";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v5, v6, v12, buf, 0x16u);
      }
LABEL_32:
      free(v10);
      if (!v4)
        return 0;
      goto LABEL_48;
    }
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_dictionary_copy_value";
    v7 = "%{public}s called with null key";
LABEL_46:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_47;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_dictionary_copy_value";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_copy_value";
      v7 = "%{public}s called with null dictionary->xpc_object";
      goto LABEL_46;
    }
    if (!v14)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_copy_value";
      v7 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
      goto LABEL_46;
    }
    v10 = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v13 = os_log_type_enabled(v5, type);
    if (!v10)
    {
      if (!v13)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_copy_value";
      v7 = "%{public}s called with null dictionary->xpc_object, no backtrace";
      goto LABEL_46;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_dictionary_copy_value";
      v18 = 2082;
      v19 = v10;
      v12 = "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s";
      goto LABEL_31;
    }
    goto LABEL_32;
  }
  pointer = (void *)xpc_dictionary_get_pointer();
  if (pointer)
    return os_retain(pointer);
  return 0;
}

BOOL nw_path_endpoint_is_always_satisfied(void *a1)
{
  id v1;
  void *v2;
  NSObject *v3;
  int v4;
  const sockaddr *address;
  int sa_family;
  _BOOL8 v8;
  id v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *backtrace_string;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
    goto LABEL_29;
  v3 = v1;
  v4 = -[NSObject type](v3, "type");

  if (v4 != 1)
    goto LABEL_29;
  address = nw_endpoint_get_address(v3);
  if (!address)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_path_endpoint_is_always_satisfied";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v10, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_path_endpoint_is_always_satisfied";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s nw_endpoint_get_address failed", buf, 0xCu);
        }
      }
      else if (v20)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v14 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = (id)gLogObj;
          v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446466;
            v23 = "nw_path_endpoint_is_always_satisfied";
            v24 = 2082;
            v25 = v14;
            _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s nw_endpoint_get_address failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v14);
          if (!v10)
            goto LABEL_29;
          goto LABEL_28;
        }
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_path_endpoint_is_always_satisfied";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s nw_endpoint_get_address failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_path_endpoint_is_always_satisfied";
          _os_log_impl(&dword_182FBE000, v11, v17, "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v10)
    {
LABEL_29:
      v8 = 0;
      goto LABEL_30;
    }
LABEL_28:
    free(v10);
    goto LABEL_29;
  }
  sa_family = address->sa_family;
  v8 = sa_family != 2 && sa_family != 30;
LABEL_30:

  return v8;
}

void sub_182FDFDF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_path_set_reason(void *a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  void **v11;
  void **v12;
  int v13;
  void *v14;
  void **v15;
  void **v16;
  int v17;
  void *v18;
  id v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  void *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  char *backtrace_string;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  char v35;
  os_log_type_t v36[8];
  _QWORD v37[5];
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = v11;
  if (!v11)
  {
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_path_set_reason";
    v28 = (char *)_os_log_send_and_compose_impl();

    v36[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v28, v36, &type))
    {
      if (v36[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v30 = v36[0];
        if (os_log_type_enabled(v29, v36[0]))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_path_set_reason";
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v32 = v36[0];
        v33 = os_log_type_enabled(v29, v36[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_path_set_reason";
            v41 = 2082;
            v42 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_51;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_path_set_reason";
          _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v34 = v36[0];
        if (os_log_type_enabled(v29, v36[0]))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_path_set_reason";
          _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_51:
    if (v28)
      free(v28);
    goto LABEL_22;
  }
  if (!a2 || (v13 = *((_DWORD *)v11 + 95), (v13 - 27) >= 4) && (!v13 || (a2 - 27) <= 3))
  {
    v15 = v11 + 31;
    v14 = v11[31];
    *((_DWORD *)v12 + 95) = a2;
    if (v14)
    {
      free(v14);
      *v15 = 0;
    }
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 3221225472;
    v37[2] = __nw_path_set_reason_block_invoke;
    v37[3] = &unk_1E14ACFD0;
    v16 = v12;
    v37[4] = v16;
    os_unfair_lock_lock((os_unfair_lock_t)v12 + 3);
    __nw_path_set_reason_block_invoke((uint64_t)v37);
    os_unfair_lock_unlock((os_unfair_lock_t)v12 + 3);
    if (!a3)
      goto LABEL_21;
    *(_QWORD *)v36 = &a9;
    v17 = vasprintf((char **)v12 + 31, a3, &a9);
    v18 = *v15;
    if (v17 < 0)
    {
      if (v18)
      {
        free(v18);
        *v15 = 0;
      }
    }
    else if (v18)
    {
      goto LABEL_21;
    }
    *v15 = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    v40 = "nw_path_set_reason";
    v41 = 2082;
    v42 = (void *)a3;
    v43 = 1024;
    v44 = v17;
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v20, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_path_set_reason";
          v41 = 2082;
          v42 = (void *)a3;
          v43 = 1024;
          v44 = v17;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s vasprintf(\"%{public}s\") returned %d failed", buf, 0x1Cu);
        }
      }
      else if (v35)
      {
        v23 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (id)gLogObj;
        v24 = type;
        v25 = os_log_type_enabled(v21, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446978;
            v40 = "nw_path_set_reason";
            v41 = 2082;
            v42 = (void *)a3;
            v43 = 1024;
            v44 = v17;
            v45 = 2082;
            v46 = v23;
            _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s vasprintf(\"%{public}s\") returned %d failed, dumping backtrace:%{public}s", buf, 0x26u);
          }

          free(v23);
          if (!v20)
            goto LABEL_21;
          goto LABEL_20;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_path_set_reason";
          v41 = 2082;
          v42 = (void *)a3;
          v43 = 1024;
          v44 = v17;
          _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s vasprintf(\"%{public}s\") returned %d failed, no backtrace", buf, 0x1Cu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (id)gLogObj;
        v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_path_set_reason";
          v41 = 2082;
          v42 = (void *)a3;
          v43 = 1024;
          v44 = v17;
          _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s vasprintf(\"%{public}s\") returned %d failed, backtrace limit exceeded", buf, 0x1Cu);
        }
      }

    }
    if (v20)
LABEL_20:
      free(v20);
LABEL_21:

  }
LABEL_22:

}

void sub_182FE0458(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_parameters_are_valid(void *a1)
{
  id v1;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
    goto LABEL_2;
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_parameters_are_valid";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_parameters_are_valid";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v4)
    free(v4);
LABEL_2:

  return v1 != 0;
}

void __nw_path_set_reason_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void **)(v1 + 256);
  *(_QWORD *)(v1 + 256) = 0;

}

xpc_object_t nw_network_agent_copy_dictionary_from_necp()
{
  int v0;
  NSObject *v1;
  xpc_object_t v2;
  xpc_object_t v3;
  void *v4;
  uint64_t v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  const char *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint32_t v13;
  uint64_t v14;
  os_log_type_t v15;
  _BOOL4 v16;
  NSObject *v17;
  os_log_type_t v18;
  uint32_t v19;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  _QWORD v26[3];
  char bytes[212];
  unsigned int v28;
  uint64_t v29;

  MEMORY[0x1E0C80A78]();
  v29 = *MEMORY[0x1E0C80C00];
  if (necp_client_action())
  {
    v0 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    if (v0 == 2)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_network_agent_copy_dictionary_from_necp";
        v25 = 1024;
        LODWORD(v26[0]) = 2;
        _os_log_impl(&dword_182FBE000, v1, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_AGENT %{darwin.errno}d", buf, 0x12u);
      }
      return 0;
    }
    *(_DWORD *)buf = 136446466;
    v24 = "nw_network_agent_copy_dictionary_from_necp";
    v25 = 1024;
    LODWORD(v26[0]) = v0;
    v4 = (void *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v21))
    {
LABEL_36:
      if (v4)
        free(v4);
      return 0;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446466;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v25 = 1024;
      LODWORD(v26[0]) = v0;
      v7 = "%{public}s NECP_CLIENT_ACTION_COPY_AGENT %{darwin.errno}d";
LABEL_29:
      v17 = v5;
      v18 = v6;
      v19 = 18;
LABEL_35:
      _os_log_impl(&dword_182FBE000, v17, v18, v7, buf, v19);
      goto LABEL_36;
    }
    if (!v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446466;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v25 = 1024;
      LODWORD(v26[0]) = v0;
      v7 = "%{public}s NECP_CLIENT_ACTION_COPY_AGENT %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v9)
        goto LABEL_36;
      *(_DWORD *)buf = 136446466;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v25 = 1024;
      LODWORD(v26[0]) = v0;
      v7 = "%{public}s NECP_CLIENT_ACTION_COPY_AGENT %{darwin.errno}d, no backtrace";
      goto LABEL_29;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446722;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v25 = 1024;
      LODWORD(v26[0]) = v0;
      WORD2(v26[0]) = 2082;
      *(_QWORD *)((char *)v26 + 6) = backtrace_string;
      v10 = "%{public}s NECP_CLIENT_ACTION_COPY_AGENT %{darwin.errno}d, dumping backtrace:%{public}s";
      v11 = v5;
      v12 = v6;
      v13 = 28;
LABEL_23:
      _os_log_impl(&dword_182FBE000, v11, v12, v10, buf, v13);
      goto LABEL_24;
    }
    goto LABEL_24;
  }
  v2 = xpc_dictionary_create(0, 0, 0);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_network_agent_copy_dictionary_from_necp";
    v4 = (void *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v21))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v7 = "%{public}s xpc_dictionary_create failed";
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      v16 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_network_agent_copy_dictionary_from_necp";
          v25 = 2082;
          v26[0] = backtrace_string;
          v10 = "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s";
          v11 = v14;
          v12 = v15;
          v13 = 22;
          goto LABEL_23;
        }
LABEL_24:
        free(backtrace_string);
        goto LABEL_36;
      }
      if (!v16)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v7 = "%{public}s xpc_dictionary_create failed, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_network_agent_copy_dictionary_from_necp";
      v7 = "%{public}s xpc_dictionary_create failed, backtrace limit exceeded";
    }
    v17 = v14;
    v18 = v15;
    v19 = 12;
    goto LABEL_35;
  }
  v3 = v2;
  xpc_dictionary_set_data(v2, "data", bytes, v28 + 216);
  return v3;
}

uint64_t nw_path_flow_registration_ecn_enabled(NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;

  v2 = (unsigned __int8 *)nw_path_copy_flow_for_registration(a1, a2);
  if (v2)
    v3 = (v2[185] >> 2) & 1;
  else
    v3 = 0;

  return v3;
}

uint64_t NWPath.isExpensive.getter()
{
  uint64_t v0;

  return *(unsigned __int8 *)(v0 + 16);
}

id *nw_quic_create_stream_metadata()
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  return nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
}

void nw_protocol_connected(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(_QWORD *, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  void (**v16)(_QWORD);
  const void *v17;
  const char *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  char *backtrace_string;
  _BOOL4 v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  const char *v38;
  char v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  void *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  char *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = a2;
    v3 = (uint64_t)a1;
    v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      v5 = a1[11];
      if (v5)
        a1[11] = v5 + 1;
    }
    if (a2)
    {
      v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        v7 = *(_QWORD *)(a2 + 88);
        if (v7)
          *(_QWORD *)(a2 + 88) = v7 + 1;
      }
      v8 = a1[3];
      if (v8)
      {
        v9 = *(void (**)(_QWORD *, uint64_t))(v8 + 40);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }
      __nwlog_obj();
      v18 = *(const char **)(v3 + 16);
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_connected";
      if (!v18)
        v18 = "invalid";
      v43 = 2082;
      v44 = (void *)v18;
      v45 = 2048;
      v46 = v3;
      v19 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v20 = __nwlog_obj();
          v21 = type;
          if (!os_log_type_enabled(v20, type))
            goto LABEL_77;
          v22 = *(const char **)(v3 + 16);
          if (!v22)
            v22 = "invalid";
          *(_DWORD *)buf = 136446722;
          v42 = "__nw_protocol_connected";
          v43 = 2082;
          v44 = (void *)v22;
          v45 = 2048;
          v46 = v3;
          v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
          goto LABEL_76;
        }
        if (!v39)
        {
          v20 = __nwlog_obj();
          v21 = type;
          if (!os_log_type_enabled(v20, type))
            goto LABEL_77;
          v37 = *(const char **)(v3 + 16);
          if (!v37)
            v37 = "invalid";
          *(_DWORD *)buf = 136446722;
          v42 = "__nw_protocol_connected";
          v43 = 2082;
          v44 = (void *)v37;
          v45 = 2048;
          v46 = v3;
          v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
          goto LABEL_76;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v20 = __nwlog_obj();
        v21 = type;
        v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            v32 = *(const char **)(v3 + 16);
            if (!v32)
              v32 = "invalid";
            *(_DWORD *)buf = 136446978;
            v42 = "__nw_protocol_connected";
            v43 = 2082;
            v44 = (void *)v32;
            v45 = 2048;
            v46 = v3;
            v47 = 2082;
            v48 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
          goto LABEL_77;
        }
        if (v31)
        {
          v38 = *(const char **)(v3 + 16);
          if (!v38)
            v38 = "invalid";
          *(_DWORD *)buf = 136446722;
          v42 = "__nw_protocol_connected";
          v43 = 2082;
          v44 = (void *)v38;
          v45 = 2048;
          v46 = v3;
          v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_182FBE000, v20, v21, v23, buf, 0x20u);
        }
      }
LABEL_77:
      if (v19)
        free(v19);
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        v14 = *(_QWORD *)(v2 + 88);
        if (v14)
        {
          v15 = v14 - 1;
          *(_QWORD *)(v2 + 88) = v15;
          if (!v15)
          {
            v16 = *(void (***)(_QWORD))(v2 + 64);
            if (v16)
            {
              *(_QWORD *)(v2 + 64) = 0;
              v16[2](v16);
              _Block_release(v16);
            }
            if ((*(_BYTE *)(v2 + 72) & 1) != 0)
            {
              v17 = *(const void **)(v2 + 64);
              if (v17)
                _Block_release(v17);
            }
LABEL_32:
            free((void *)v2);
          }
        }
      }
LABEL_14:
      if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
      {
        v10 = *(_QWORD *)(v3 + 88);
        if (v10)
        {
          v11 = v10 - 1;
          *(_QWORD *)(v3 + 88) = v11;
          if (!v11)
          {
            v12 = *(void (***)(_QWORD))(v3 + 64);
            if (v12)
            {
              *(_QWORD *)(v3 + 64) = 0;
              v12[2](v12);
              _Block_release(v12);
            }
            if ((*(_BYTE *)(v3 + 72) & 1) != 0)
            {
              v13 = *(const void **)(v3 + 64);
              if (v13)
                _Block_release(v13);
            }
            goto LABEL_24;
          }
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v42 = "__nw_protocol_connected";
    v2 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault((const char *)v2, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v27 = __nwlog_obj();
        v28 = type;
        if (!os_log_type_enabled(v27, type))
          goto LABEL_91;
        *(_DWORD *)buf = 136446210;
        v42 = "__nw_protocol_connected";
        v29 = "%{public}s called with null other_protocol";
        goto LABEL_90;
      }
      if (!v39)
      {
        v27 = __nwlog_obj();
        v28 = type;
        if (!os_log_type_enabled(v27, type))
          goto LABEL_91;
        *(_DWORD *)buf = 136446210;
        v42 = "__nw_protocol_connected";
        v29 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_90;
      }
      v35 = (char *)__nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v28 = type;
      v36 = os_log_type_enabled(v27, type);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          v42 = "__nw_protocol_connected";
          v43 = 2082;
          v44 = v35;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v35);
        if (v2)
          goto LABEL_32;
        goto LABEL_14;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "__nw_protocol_connected";
        v29 = "%{public}s called with null other_protocol, no backtrace";
LABEL_90:
        _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
      }
    }
LABEL_91:
    if (!v2)
      goto LABEL_14;
    goto LABEL_32;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v42 = "__nw_protocol_connected";
  v3 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault((const char *)v3, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v42 = "__nw_protocol_connected";
      v26 = "%{public}s called with null protocol";
    }
    else if (v39)
    {
      v33 = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v34 = os_log_type_enabled(v24, type);
      if (v33)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v42 = "__nw_protocol_connected";
          v43 = 2082;
          v44 = v33;
          _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v33);
        if (v3)
          goto LABEL_24;
        return;
      }
      if (!v34)
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v42 = "__nw_protocol_connected";
      v26 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v42 = "__nw_protocol_connected";
      v26 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v24, v25, v26, buf, 0xCu);
  }
LABEL_86:
  if (v3)
LABEL_24:
    free((void *)v3);
}

void nw_flow_connected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *v3;
  id *handle;
  id v5;
  NWConcrete_nw_endpoint_handler *v6;
  uint64_t mode;
  __int16 v8;
  __int16 v9;
  void *v10;
  id v11;
  _BOOL8 v12;
  void *v13;
  NWConcrete_nw_endpoint_handler *v14;
  BOOL v15;
  NSObject *v16;
  NWConcrete_nw_endpoint_handler *v17;
  NWConcrete_nw_endpoint_handler *v18;
  _BOOL4 v19;
  const char *v20;
  nw_endpoint_t v21;
  const char *v22;
  unsigned int *v23;
  unsigned int *v24;
  uint64_t v25;
  const char *v26;
  NSObject *v27;
  const char *v28;
  NWConcrete_nw_endpoint_handler *v29;
  char v30;
  NWConcrete_nw_endpoint_mode_handler *v31;
  NSObject *v32;
  NWConcrete_nw_endpoint_handler *v33;
  NWConcrete_nw_endpoint_handler *v34;
  char v35;
  const char *v36;
  nw_endpoint_t v37;
  const char *logging_description;
  char *id_str;
  unsigned int *v40;
  unsigned int *v41;
  uint64_t v42;
  const char *v43;
  nw_protocol_callbacks *callbacks;
  unsigned int (*waiting_for_output)(nw_protocol *, nw_protocol *);
  int minimize_logging;
  char logging_disabled;
  NSObject *v48;
  const char *v49;
  const char *v50;
  nw_endpoint_t v51;
  NSObject *v52;
  const char *v53;
  const char *v54;
  const char *v55;
  id v56;
  void **v57;
  void **v58;
  int v59;
  const char *v60;
  nw_protocol_callbacks *v61;
  unsigned int (*v62)(nw_protocol *, nw_protocol *);
  int v63;
  char v64;
  NSObject *v65;
  const char *v66;
  const char *v67;
  nw_endpoint_t v68;
  NSObject *v69;
  const char *v70;
  const char *v71;
  const char *v72;
  const char *v73;
  id v74;
  const char *v75;
  void **v76;
  const char *v77;
  void **v78;
  id v79;
  int v80;
  char v81;
  NSObject *v82;
  const char *v83;
  const char *v84;
  nw_endpoint_t v85;
  const char *v86;
  const char *v87;
  const char *v88;
  id v89;
  nw_protocol_callbacks *v90;
  unsigned int (*v91)(nw_protocol *, nw_protocol *);
  int v92;
  char v93;
  const char *v94;
  const char *v95;
  nw_endpoint_t v96;
  const char *v97;
  const char *v98;
  const char *v99;
  id v100;
  int v101;
  char v102;
  NSObject *v103;
  const char *v104;
  const char *v105;
  nw_endpoint_t v106;
  const char *v107;
  const char *v108;
  const char *v109;
  const char *v110;
  id v111;
  NWConcrete_nw_endpoint_handler *v112;
  id v113;
  nw_endpoint_t v114;
  void **v115;
  id v116;
  nw_endpoint_t v117;
  nw_protocol *default_input_handler;
  void *v119;
  int v120;
  char v121;
  NSObject *v122;
  const char *v123;
  const char *v124;
  nw_endpoint_t v125;
  NSObject *v126;
  const char *v127;
  const char *v128;
  const char *v129;
  const char *v130;
  id v131;
  id v132;
  NSObject *v133;
  unsigned __int8 *v134;
  unsigned __int8 *v135;
  void *v136;
  void *v137;
  int v138;
  char v139;
  NSObject *v140;
  const char *v141;
  nw_endpoint_t v142;
  const char *v143;
  const char *v144;
  const char *v145;
  id v146;
  id v147;
  void *v148;
  char *v149;
  NSObject *v150;
  os_log_type_t v151;
  char *backtrace_string;
  os_log_type_t v153;
  _BOOL4 v154;
  os_log_type_t v155;
  nw_endpoint_t v156;
  const char *v157;
  const char *v158;
  const char *v159;
  id v160;
  NSObject *v161;
  const char *v162;
  const char *v163;
  nw_endpoint_t v164;
  const char *v165;
  const char *v166;
  const char *v167;
  id v168;
  const char *v169;
  nw_endpoint_t v170;
  const char *v171;
  const char *v172;
  const char *v173;
  id v174;
  const char *v175;
  nw_endpoint_t v176;
  const char *v177;
  const char *v178;
  const char *v179;
  id v180;
  const char *v181;
  nw_endpoint_t v182;
  const char *v183;
  const char *v184;
  const char *v185;
  id v186;
  const char *id_string;
  const char *v188;
  nw_endpoint_t v189;
  const char *v190;
  const char *v191;
  const char *v192;
  id v193;
  const char *v194;
  nw_endpoint_t v195;
  const char *v196;
  const char *v197;
  const char *v198;
  id v199;
  const char *v200;
  const char *v201;
  const char *v202;
  os_log_t log;
  NSObject *logb;
  NSObject *logc;
  NSObject *logd;
  const char *loge;
  const char *logf;
  os_log_t loga;
  const char *logg;
  const char *logh;
  const char *logi;
  const char *logj;
  nw_protocol *v214;
  nw_protocol *v215;
  nw_protocol *v216;
  NSObject *v217;
  nw_protocol *v218;
  void *v219;
  NWConcrete_nw_endpoint_mode_handler *v220;
  id v221;
  _QWORD v222[4];
  NWConcrete_nw_endpoint_handler *v223;
  _QWORD v224[4];
  id v225;
  uint64_t *v226;
  uint64_t v227;
  uint64_t *v228;
  uint64_t v229;
  char v230;
  uint8_t buf[4];
  const char *v232;
  __int16 v233;
  void *v234;
  __int16 v235;
  const char *v236;
  __int16 v237;
  void *v238;
  __int16 v239;
  const char *v240;
  __int16 v241;
  const char *v242;
  __int16 v243;
  id v244;
  __int16 v245;
  _BYTE *v246;
  __int16 v247;
  id *v248;
  _BYTE __str[35];
  uint64_t v250;

  v3 = a1;
  v250 = *MEMORY[0x1E0C80C00];
  handle = (id *)a1->handle;
  v5 = handle[20];
  if (v5)
  {
    v221 = v5;
    v6 = (NWConcrete_nw_endpoint_handler *)v5;
    mode = v6->mode;

    if ((_DWORD)mode != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5)
          v28 = "unknown-mode";
        else
          v28 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v232 = "nw_flow_connected";
        v233 = 2082;
        v234 = (void *)v28;
        v235 = 2082;
        v236 = "flow";
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }

      goto LABEL_118;
    }
    v220 = nw_endpoint_handler_copy_flow(v6);
    if ((*((_WORD *)handle + 166) & 0x200) != 0)
    {
      v29 = v6;
      v30 = *((_BYTE *)v29 + 268);

      v31 = v220;
      if ((v30 & 0x20) != 0)
      {
LABEL_117:

LABEL_118:
        v119 = v221;
        goto LABEL_119;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v32 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v33 = v29;

        v34 = v33;
        v35 = *((_BYTE *)v29 + 268);

        if ((v35 & 1) != 0)
          v36 = "dry-run ";
        else
          v36 = "";
        v37 = nw_endpoint_handler_copy_endpoint(v34);
        logging_description = nw_endpoint_get_logging_description(v37);
        id_str = v33->id_str;
        v40 = v34;
        v41 = v40;
        v42 = v40[30];
        if (v42 > 5)
          v43 = "unknown-state";
        else
          v43 = off_1E149FC48[v42];

        v57 = v41;
        v58 = v57;
        v59 = v6->mode;
        v60 = "path";
        switch(v59)
        {
          case 0:
            break;
          case 1:
            v60 = "resolver";
            break;
          case 2:
            v60 = nw_endpoint_flow_mode_string(v57[31]);
            break;
          case 3:
            v60 = "proxy";
            break;
          case 4:
            v60 = "fallback";
            break;
          case 5:
            v60 = "transform";
            break;
          default:
            v60 = "unknown-mode";
            break;
        }

        v78 = v58;
        os_unfair_lock_lock((os_unfair_lock_t)v78 + 28);
        v79 = v78[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v78 + 28);

        *(_DWORD *)buf = 136447746;
        v232 = "nw_flow_connected";
        v233 = 2082;
        v234 = id_str;
        v235 = 2082;
        v236 = v36;
        v237 = 2082;
        v238 = (void *)logging_description;
        v239 = 2082;
        v240 = v43;
        v241 = 2082;
        v242 = v60;
        v243 = 2114;
        v244 = v79;
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow was disconnected, skipping connected", buf, 0x48u);

      }
LABEL_116:
      v31 = v220;
      goto LABEL_117;
    }
    memset(__str, 0, sizeof(__str));
    if (a2 && a2->identifier)
      snprintf(__str, 0x23uLL, " (%s)", a2->identifier->name);
    v218 = a2;
    if ((id *)((char *)v220 + 376) != handle)
      goto LABEL_8;
    if (v3->output_handler != a2)
    {
      if (*((nw_protocol **)v220 + 90) == a2)
      {
        v75 = "Transport";
      }
      else
      {
        if (*((nw_protocol **)v220 + 92) != a2)
        {
          if (*((nw_protocol **)v220 + 93) != a2)
            goto LABEL_8;
          v215 = v3;
          if (a2)
          {
            callbacks = a2->callbacks;
            if (callbacks)
            {
              waiting_for_output = (unsigned int (*)(nw_protocol *, nw_protocol *))callbacks->waiting_for_output;
              if (waiting_for_output)
              {
                if (waiting_for_output(a2, v3))
                {
                  minimize_logging = nw_endpoint_handler_get_minimize_logging(v6);
                  logging_disabled = nw_endpoint_handler_get_logging_disabled(v6);
                  if (minimize_logging)
                  {
                    a2 = v218;
                    if ((logging_disabled & 1) != 0)
                      goto LABEL_8;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v52 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v6);
                      v188 = nw_endpoint_handler_dry_run_string(v6);
                      v189 = nw_endpoint_handler_copy_endpoint(v6);
                      v190 = nw_endpoint_get_logging_description(v189);
                      v191 = nw_endpoint_handler_state_string(v6);
                      v192 = nw_endpoint_handler_mode_string(v6);
                      v193 = nw_endpoint_handler_copy_current_path(v6);
                      *(_DWORD *)buf = 136448002;
                      v232 = "nw_flow_connected";
                      v233 = 2082;
                      v234 = (void *)id_string;
                      v235 = 2082;
                      v236 = v188;
                      v237 = 2082;
                      v238 = (void *)v190;
                      v239 = 2082;
                      v240 = v191;
                      v241 = 2082;
                      v242 = v192;
                      v243 = 2114;
                      v244 = v193;
                      v245 = 2082;
                      v246 = __str;
                      _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol%{public}s waiting for output, ignore", buf, 0x52u);

                    }
LABEL_48:
                    v48 = v52;
LABEL_96:

                    v3 = v215;
                    a2 = v218;
                    goto LABEL_8;
                  }
                  a2 = v218;
                  if ((logging_disabled & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v48 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
                      goto LABEL_96;
                    v49 = nw_endpoint_handler_get_id_string(v6);
                    v50 = nw_endpoint_handler_dry_run_string(v6);
                    v51 = nw_endpoint_handler_copy_endpoint(v6);
                    v52 = v48;
                    v53 = nw_endpoint_get_logging_description(v51);
                    v54 = nw_endpoint_handler_state_string(v6);
                    v55 = nw_endpoint_handler_mode_string(v6);
                    v56 = nw_endpoint_handler_copy_current_path(v6);
                    *(_DWORD *)buf = 136448002;
                    v232 = "nw_flow_connected";
                    v233 = 2082;
                    v234 = (void *)v49;
                    v235 = 2082;
                    v236 = v50;
                    v237 = 2082;
                    v238 = (void *)v53;
                    v239 = 2082;
                    v240 = v54;
                    v241 = 2082;
                    v242 = v55;
                    v243 = 2114;
                    v244 = v56;
                    v245 = 2082;
                    v246 = __str;
                    _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol%{public}s waiting for output, ignore", buf, 0x52u);

                    goto LABEL_48;
                  }
LABEL_8:
                  v8 = *((_WORD *)handle + 166);
                  if ((v8 & 0x400) != 0)
                  {
                    v9 = v8 & 0xFBFF;
                    *((_WORD *)handle + 166) = v8 & 0xFBFF;
                    v10 = (void *)*((_QWORD *)v220 + 89);
                    if (v10)
                    {
                      v214 = v3;
                      v11 = v10;
                      v12 = nw_read_request_list_remove_head(*((void **)v220 + 89));
                      v13 = (void *)*((_QWORD *)v220 + 89);
                      *((_QWORD *)v220 + 89) = v12;

                      v14 = v6;
                      v15 = (*((_BYTE *)v14 + 268) & 0x20) == 0;

                      if (v15)
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v16 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                        {
                          v17 = v14;

                          v18 = v17;
                          v19 = (*((_BYTE *)v14 + 268) & 1) == 0;

                          if (v19)
                            v20 = "";
                          else
                            v20 = "dry-run ";
                          v21 = nw_endpoint_handler_copy_endpoint(v18);
                          v22 = nw_endpoint_get_logging_description(v21);
                          v23 = v18;
                          v24 = v23;
                          v25 = v23[30];
                          log = (os_log_t)v22;
                          if (v25 > 5)
                            v26 = "unknown-state";
                          else
                            v26 = off_1E149FC48[v25];
                          v201 = v26;

                          v76 = v24;
                          v77 = "path";
                          switch(v6->mode)
                          {
                            case 0:
                              break;
                            case 1:
                              v77 = "resolver";
                              break;
                            case 2:
                              v77 = nw_endpoint_flow_mode_string(v76[31]);
                              break;
                            case 3:
                              v77 = "proxy";
                              break;
                            case 4:
                              v77 = "fallback";
                              break;
                            case 5:
                              v77 = "transform";
                              break;
                            default:
                              v77 = "unknown-mode";
                              break;
                          }
                          v200 = v77;

                          v112 = v17;
                          v113 = v11;
                          v114 = v21;
                          v115 = v76;
                          os_unfair_lock_lock((os_unfair_lock_t)v115 + 28);
                          v116 = v115[8];
                          os_unfair_lock_unlock((os_unfair_lock_t)v115 + 28);

                          v117 = v114;
                          v11 = v113;
                          *(_DWORD *)buf = 136448258;
                          v232 = "nw_flow_connected";
                          v233 = 2082;
                          v234 = v112->id_str;
                          v235 = 2082;
                          v236 = v20;
                          v237 = 2082;
                          v238 = log;
                          v239 = 2082;
                          v240 = v201;
                          v241 = 2082;
                          v242 = v200;
                          v243 = 2114;
                          v244 = v116;
                          v245 = 2112;
                          v246 = v113;
                          v247 = 2048;
                          v248 = handle;
                          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding new flow read request %@ to %p", buf, 0x5Cu);

                        }
                      }
                      nw_flow_add_read_request(v14, (uint64_t)handle, v11);

                      v3 = v214;
                      a2 = v218;
                    }
                    else
                    {
                      *((_WORD *)handle + 166) = v9 | 0x20;
                      a2 = v218;
                    }
                  }
                  default_input_handler = v3->default_input_handler;
                  if (default_input_handler)
                  {
                    nw_protocol_connected(default_input_handler, (uint64_t)a2);
                    if (v3->output_handler == a2)
                      nw_protocol_connected(v3->default_input_handler->flow_id, (uint64_t)v3);
                  }
                  goto LABEL_116;
                }
              }
            }
          }
          v120 = nw_endpoint_handler_get_minimize_logging(v6);
          v121 = nw_endpoint_handler_get_logging_disabled(v6);
          if (v120)
          {
            if ((v121 & 1) != 0)
              goto LABEL_127;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v122 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
            {
              v181 = nw_endpoint_handler_get_id_string(v6);
              logi = nw_endpoint_handler_dry_run_string(v6);
              v182 = nw_endpoint_handler_copy_endpoint(v6);
              v183 = nw_endpoint_get_logging_description(v182);
              v184 = nw_endpoint_handler_state_string(v6);
              v185 = nw_endpoint_handler_mode_string(v6);
              v186 = nw_endpoint_handler_copy_current_path(v6);
              *(_DWORD *)buf = 136448002;
              v232 = "nw_flow_connected";
              v233 = 2082;
              v234 = (void *)v181;
              v235 = 2082;
              v236 = logi;
              v237 = 2082;
              v238 = (void *)v183;
              v239 = 2082;
              v240 = v184;
              v241 = 2082;
              v242 = v185;
              v243 = 2114;
              v244 = v186;
              v245 = 2082;
              v246 = __str;
              _os_log_impl(&dword_182FBE000, v122, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol connected%{public}s", buf, 0x52u);

            }
          }
          else
          {
            if ((v121 & 1) != 0)
            {
LABEL_127:
              v6->event = (nw_endpoint_handler_event_s)917507;
              nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
              nw_flow_get_remote(v3);
              v48 = objc_claimAutoreleasedReturnValue();
              if (!v48)
                goto LABEL_96;
              v132 = handle[22];
              if (!v132 || !handle[23] || !nw_parameters_get_block_trackers(v132))
                goto LABEL_96;
              v133 = v48;
              v134 = (unsigned __int8 *)nw_endpoint_copy_cname_array(v48);
              v135 = v134;
              if (v134 && *((_QWORD *)v134 + 3) != *((_QWORD *)v134 + 2))
              {
                v227 = 0;
                v228 = &v227;
                v229 = 0x2020000000;
                v230 = 0;
                v136 = nw_context_copy_tracker_lookup_callback(handle[23]);
                if (v136)
                {
                  v224[0] = MEMORY[0x1E0C809B0];
                  v224[1] = 3221225472;
                  v224[2] = ___ZL17nw_flow_connectedP11nw_protocolS0__block_invoke;
                  v224[3] = &unk_1E149D1F0;
                  v137 = v136;
                  v225 = v136;
                  v226 = &v227;
                  nw_array_apply(v135, (uint64_t)v224);

                  v136 = v137;
                }
                if (*((_BYTE *)v228 + 24))
                {
                  v219 = v136;
                  v138 = nw_endpoint_handler_get_minimize_logging(v6);
                  v139 = nw_endpoint_handler_get_logging_disabled(v6);
                  if (v138)
                  {
                    if ((v139 & 1) != 0)
                      goto LABEL_144;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v217 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v217, OS_LOG_TYPE_DEBUG))
                    {
                      v194 = nw_endpoint_handler_get_id_string(v6);
                      logj = nw_endpoint_handler_dry_run_string(v6);
                      v195 = nw_endpoint_handler_copy_endpoint(v6);
                      v196 = nw_endpoint_get_logging_description(v195);
                      v197 = nw_endpoint_handler_state_string(v6);
                      v198 = nw_endpoint_handler_mode_string(v6);
                      v199 = nw_endpoint_handler_copy_current_path(v6);
                      *(_DWORD *)buf = 136447746;
                      v232 = "nw_flow_connected";
                      v233 = 2082;
                      v234 = (void *)v194;
                      v235 = 2082;
                      v236 = logj;
                      v237 = 2082;
                      v238 = (void *)v196;
                      v239 = 2082;
                      v240 = v197;
                      v241 = 2082;
                      v242 = v198;
                      v243 = 2114;
                      v244 = v199;
                      _os_log_impl(&dword_182FBE000, v217, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol detected tracker to block", buf, 0x48u);

                    }
                  }
                  else
                  {
                    if ((v139 & 1) != 0)
                    {
LABEL_144:
                      v147 = handle[23];
                      v222[0] = MEMORY[0x1E0C809B0];
                      v222[1] = 3221225472;
                      v222[2] = ___ZL17nw_flow_connectedP11nw_protocolS0__block_invoke_97;
                      v222[3] = &unk_1E14ACFD0;
                      v223 = v6;
                      nw_queue_context_async(v147, v222);

                      _Block_object_dispose(&v227, 8);
                      goto LABEL_116;
                    }
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v140 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
                    {
LABEL_143:

                      goto LABEL_144;
                    }
                    v217 = v140;
                    loge = nw_endpoint_handler_get_id_string(v6);
                    v141 = nw_endpoint_handler_dry_run_string(v6);
                    v142 = nw_endpoint_handler_copy_endpoint(v6);
                    v143 = nw_endpoint_get_logging_description(v142);
                    v144 = nw_endpoint_handler_state_string(v6);
                    v145 = nw_endpoint_handler_mode_string(v6);
                    v146 = nw_endpoint_handler_copy_current_path(v6);
                    *(_DWORD *)buf = 136447746;
                    v232 = "nw_flow_connected";
                    v233 = 2082;
                    v234 = (void *)loge;
                    v235 = 2082;
                    v236 = v141;
                    v237 = 2082;
                    v238 = (void *)v143;
                    v239 = 2082;
                    v240 = v144;
                    v241 = 2082;
                    v242 = v145;
                    v243 = 2114;
                    v244 = v146;
                    _os_log_impl(&dword_182FBE000, v217, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol detected tracker to block", buf, 0x48u);

                  }
                  v140 = v217;
                  goto LABEL_143;
                }

                _Block_object_dispose(&v227, 8);
              }

              goto LABEL_96;
            }
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v122 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
            {
              v123 = nw_endpoint_handler_get_id_string(v6);
              v124 = nw_endpoint_handler_dry_run_string(v6);
              v125 = nw_endpoint_handler_copy_endpoint(v6);
              v126 = v122;
              v127 = v124;
              v128 = nw_endpoint_get_logging_description(v125);
              v129 = nw_endpoint_handler_state_string(v6);
              v130 = nw_endpoint_handler_mode_string(v6);
              v131 = nw_endpoint_handler_copy_current_path(v6);
              *(_DWORD *)buf = 136448002;
              v232 = "nw_flow_connected";
              v233 = 2082;
              v234 = (void *)v123;
              v235 = 2082;
              v236 = v127;
              v237 = 2082;
              v238 = (void *)v128;
              v239 = 2082;
              v240 = v129;
              v241 = 2082;
              v242 = v130;
              v243 = 2114;
              v244 = v131;
              v245 = 2082;
              v246 = __str;
              _os_log_impl(&dword_182FBE000, v126, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol connected%{public}s", buf, 0x52u);

              v122 = v126;
            }
          }

          v3 = v215;
          goto LABEL_127;
        }
        v75 = "Joined";
      }
      v215 = v3;
      if (a2)
      {
        v90 = a2->callbacks;
        if (v90)
        {
          v91 = (unsigned int (*)(nw_protocol *, nw_protocol *))v90->waiting_for_output;
          if (v91)
          {
            if (v91(a2, v3))
            {
              v92 = nw_endpoint_handler_get_minimize_logging(v6);
              v93 = nw_endpoint_handler_get_logging_disabled(v6);
              if (v92)
              {
                a2 = v218;
                if ((v93 & 1) != 0)
                  goto LABEL_8;
                loga = (os_log_t)v75;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v161 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
                {
                  v162 = nw_endpoint_handler_get_id_string(v6);
                  v163 = nw_endpoint_handler_dry_run_string(v6);
                  v164 = nw_endpoint_handler_copy_endpoint(v6);
                  v165 = nw_endpoint_get_logging_description(v164);
                  v166 = nw_endpoint_handler_state_string(v6);
                  v167 = nw_endpoint_handler_mode_string(v6);
                  v168 = nw_endpoint_handler_copy_current_path(v6);
                  *(_DWORD *)buf = 136448258;
                  v232 = "nw_flow_connected";
                  v233 = 2082;
                  v234 = (void *)v162;
                  v235 = 2082;
                  v236 = v163;
                  v237 = 2082;
                  v238 = (void *)v165;
                  v239 = 2082;
                  v240 = v166;
                  v241 = 2082;
                  v242 = v167;
                  v243 = 2114;
                  v244 = v168;
                  v245 = 2082;
                  v246 = loga;
                  v247 = 2082;
                  v248 = (id *)__str;
                  _os_log_impl(&dword_182FBE000, v161, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol%{public}s waiting for output, ignore", buf, 0x5Cu);

                }
                v48 = v161;
                goto LABEL_96;
              }
              a2 = v218;
              if ((v93 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v48 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
                {
                  v94 = nw_endpoint_handler_get_id_string(v6);
                  v95 = nw_endpoint_handler_dry_run_string(v6);
                  logc = v48;
                  v96 = nw_endpoint_handler_copy_endpoint(v6);
                  v97 = nw_endpoint_get_logging_description(v96);
                  v98 = nw_endpoint_handler_state_string(v6);
                  v99 = nw_endpoint_handler_mode_string(v6);
                  v100 = nw_endpoint_handler_copy_current_path(v6);
                  *(_DWORD *)buf = 136448258;
                  v232 = "nw_flow_connected";
                  v233 = 2082;
                  v234 = (void *)v94;
                  v235 = 2082;
                  v236 = v95;
                  v237 = 2082;
                  v238 = (void *)v97;
                  v239 = 2082;
                  v240 = v98;
                  v241 = 2082;
                  v242 = v99;
                  v243 = 2114;
                  v244 = v100;
                  v245 = 2082;
                  v246 = v75;
                  v247 = 2082;
                  v248 = (id *)__str;
                  _os_log_impl(&dword_182FBE000, logc, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol%{public}s waiting for output, ignore", buf, 0x5Cu);

                  v48 = logc;
                }
                goto LABEL_96;
              }
              goto LABEL_8;
            }
          }
        }
      }
      v101 = nw_endpoint_handler_get_minimize_logging(v6);
      v102 = nw_endpoint_handler_get_logging_disabled(v6);
      if (v101)
      {
        if ((v102 & 1) != 0)
          goto LABEL_104;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v103 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          logf = nw_endpoint_handler_get_id_string(v6);
          v202 = nw_endpoint_handler_dry_run_string(v6);
          v156 = nw_endpoint_handler_copy_endpoint(v6);
          v157 = nw_endpoint_get_logging_description(v156);
          v158 = nw_endpoint_handler_state_string(v6);
          v159 = nw_endpoint_handler_mode_string(v6);
          v160 = nw_endpoint_handler_copy_current_path(v6);
          *(_DWORD *)buf = 136448258;
          v232 = "nw_flow_connected";
          v233 = 2082;
          v234 = (void *)logf;
          v235 = 2082;
          v236 = v202;
          v237 = 2082;
          v238 = (void *)v157;
          v239 = 2082;
          v240 = v158;
          v241 = 2082;
          v242 = v159;
          v243 = 2114;
          v244 = v160;
          v245 = 2082;
          v246 = v75;
          v247 = 2082;
          v248 = (id *)__str;
          _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol connected%{public}s", buf, 0x5Cu);

        }
      }
      else
      {
        if ((v102 & 1) != 0)
        {
LABEL_104:
          v6->event = (nw_endpoint_handler_event_s)327683;
          nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
          a2 = v218;
          goto LABEL_8;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v103 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
        {
          logd = v103;
          v104 = nw_endpoint_handler_get_id_string(v6);
          v105 = nw_endpoint_handler_dry_run_string(v6);
          v106 = nw_endpoint_handler_copy_endpoint(v6);
          v107 = v104;
          v108 = nw_endpoint_get_logging_description(v106);
          v109 = nw_endpoint_handler_state_string(v6);
          v110 = nw_endpoint_handler_mode_string(v6);
          v111 = nw_endpoint_handler_copy_current_path(v6);
          *(_DWORD *)buf = 136448258;
          v232 = "nw_flow_connected";
          v233 = 2082;
          v234 = (void *)v107;
          v235 = 2082;
          v236 = v105;
          v237 = 2082;
          v238 = (void *)v108;
          v239 = 2082;
          v240 = v109;
          v241 = 2082;
          v242 = v110;
          v243 = 2114;
          v244 = v111;
          v245 = 2082;
          v246 = v75;
          v247 = 2082;
          v248 = (id *)__str;
          _os_log_impl(&dword_182FBE000, logd, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol connected%{public}s", buf, 0x5Cu);

          v103 = logd;
        }
      }

      v3 = v215;
      goto LABEL_104;
    }
    if (a2)
    {
      v61 = a2->callbacks;
      if (v61)
      {
        v62 = (unsigned int (*)(nw_protocol *, nw_protocol *))v61->waiting_for_output;
        if (v62)
        {
          if (v62(a2, v3))
          {
            v63 = nw_endpoint_handler_get_minimize_logging(v6);
            v64 = nw_endpoint_handler_get_logging_disabled(v6);
            v216 = v3;
            if (v63)
            {
              if ((v64 & 1) != 0)
                goto LABEL_64;
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v65 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
              {
                v175 = nw_endpoint_handler_get_id_string(v6);
                logh = nw_endpoint_handler_dry_run_string(v6);
                v176 = nw_endpoint_handler_copy_endpoint(v6);
                v177 = nw_endpoint_get_logging_description(v176);
                v178 = nw_endpoint_handler_state_string(v6);
                v179 = nw_endpoint_handler_mode_string(v6);
                v180 = nw_endpoint_handler_copy_current_path(v6);
                *(_DWORD *)buf = 136447746;
                v232 = "nw_flow_connected";
                v233 = 2082;
                v234 = (void *)v175;
                v235 = 2082;
                v236 = logh;
                v237 = 2082;
                v238 = (void *)v177;
                v239 = 2082;
                v240 = v178;
                v241 = 2082;
                v242 = v179;
                v243 = 2114;
                v244 = v180;
                _os_log_impl(&dword_182FBE000, v65, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fast open started, need initial data", buf, 0x48u);

              }
            }
            else
            {
              if ((v64 & 1) != 0)
              {
LABEL_64:
                *((_WORD *)handle + 166) |= 0x800u;
                nw_endpoint_flow_add_initial_write_request(v6);
                a2 = v218;
                v6->event = (nw_endpoint_handler_event_s)589827;
                nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
LABEL_84:
                nw_endpoint_handler_service_writes(v6);
                nw_endpoint_handler_service_reads(v6);
                goto LABEL_8;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v65 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
              {
                v66 = nw_endpoint_handler_get_id_string(v6);
                v67 = nw_endpoint_handler_dry_run_string(v6);
                v68 = nw_endpoint_handler_copy_endpoint(v6);
                v69 = v65;
                v70 = v67;
                v71 = nw_endpoint_get_logging_description(v68);
                v72 = nw_endpoint_handler_state_string(v6);
                v73 = nw_endpoint_handler_mode_string(v6);
                v74 = nw_endpoint_handler_copy_current_path(v6);
                *(_DWORD *)buf = 136447746;
                v232 = "nw_flow_connected";
                v233 = 2082;
                v234 = (void *)v66;
                v235 = 2082;
                v236 = v70;
                v237 = 2082;
                v238 = (void *)v71;
                v239 = 2082;
                v240 = v72;
                v241 = 2082;
                v242 = v73;
                v243 = 2114;
                v244 = v74;
                _os_log_impl(&dword_182FBE000, v69, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fast open started, need initial data", buf, 0x48u);

                v65 = v69;
              }
            }

            v3 = v216;
            goto LABEL_64;
          }
        }
      }
    }
    v80 = nw_endpoint_handler_get_minimize_logging(v6);
    v81 = nw_endpoint_handler_get_logging_disabled(v6);
    if (v80)
    {
      if ((v81 & 1) != 0)
        goto LABEL_83;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v82 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
      {
        v169 = nw_endpoint_handler_get_id_string(v6);
        logg = nw_endpoint_handler_dry_run_string(v6);
        v170 = nw_endpoint_handler_copy_endpoint(v6);
        v171 = nw_endpoint_get_logging_description(v170);
        v172 = nw_endpoint_handler_state_string(v6);
        v173 = nw_endpoint_handler_mode_string(v6);
        v174 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v232 = "nw_flow_connected";
        v233 = 2082;
        v234 = (void *)v169;
        v235 = 2082;
        v236 = logg;
        v237 = 2082;
        v238 = (void *)v171;
        v239 = 2082;
        v240 = v172;
        v241 = 2082;
        v242 = v173;
        v243 = 2114;
        v244 = v174;
        v245 = 2082;
        v246 = __str;
        _os_log_impl(&dword_182FBE000, v82, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol connected%{public}s", buf, 0x52u);

      }
    }
    else
    {
      if ((v81 & 1) != 0)
      {
LABEL_83:
        *((_WORD *)handle + 166) &= ~0x800u;
        *((_DWORD *)v220 + 251) = 0;
        nw_endpoint_flow_add_initial_write_request(v6);
        a2 = v218;
        nw_endpoint_flow_connected(v6);
        goto LABEL_84;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v82 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        logb = v82;
        v83 = nw_endpoint_handler_get_id_string(v6);
        v84 = nw_endpoint_handler_dry_run_string(v6);
        v85 = nw_endpoint_handler_copy_endpoint(v6);
        v86 = nw_endpoint_get_logging_description(v85);
        v87 = nw_endpoint_handler_state_string(v6);
        v88 = nw_endpoint_handler_mode_string(v6);
        v89 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v232 = "nw_flow_connected";
        v233 = 2082;
        v234 = (void *)v83;
        v235 = 2082;
        v236 = v84;
        v237 = 2082;
        v238 = (void *)v86;
        v239 = 2082;
        v240 = v87;
        v241 = 2082;
        v242 = v88;
        v243 = 2114;
        v244 = v89;
        v245 = 2082;
        v246 = __str;
        _os_log_impl(&dword_182FBE000, logb, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol connected%{public}s", buf, 0x52u);

        v82 = logb;
      }
    }

    goto LABEL_83;
  }
  v119 = 0;
  __nwlog_obj();
  v148 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v232 = "nw_flow_connected";
  v149 = (char *)_os_log_send_and_compose_impl();

  __str[0] = 16;
  LOBYTE(v227) = 0;
  if (__nwlog_fault(v149, __str, &v227))
  {
    if (__str[0] == 17)
    {
      __nwlog_obj();
      v150 = objc_claimAutoreleasedReturnValue();
      v151 = __str[0];
      if (os_log_type_enabled(v150, (os_log_type_t)__str[0]))
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_182FBE000, v150, v151, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v227)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v150 = objc_claimAutoreleasedReturnValue();
      v153 = __str[0];
      v154 = os_log_type_enabled(v150, (os_log_type_t)__str[0]);
      if (backtrace_string)
      {
        if (v154)
        {
          *(_DWORD *)buf = 136446466;
          v232 = "nw_flow_connected";
          v233 = 2082;
          v234 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v150, v153, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_163;
      }
      if (v154)
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_182FBE000, v150, v153, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v150 = objc_claimAutoreleasedReturnValue();
      v155 = __str[0];
      if (os_log_type_enabled(v150, (os_log_type_t)__str[0]))
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_182FBE000, v150, v155, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_163:
  if (v149)
    free(v149);
LABEL_119:

}

void sub_182FE31E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  void *v31;
  void *v32;
  void *v33;
  void *v34;

  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_current_path(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    v3 = *(id *)&v2[16]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 28);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_copy_current_path";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_copy_current_path";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_copy_current_path";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_copy_current_path";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_copy_current_path";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_endpoint_handler_get_minimize_logging(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)*((_QWORD *)v1 + 4);
    if (v3)
    {
      v4 = v3;
      v5 = (v4[12] >> 38) & 1;

    }
    else
    {
      v5 = 0;
    }
    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_endpoint_handler_get_minimize_logging";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_handler_get_minimize_logging";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_endpoint_handler_get_minimize_logging";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_handler_get_minimize_logging";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_handler_get_minimize_logging";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  v5 = 1;
LABEL_5:

  return v5;
}

const char *nw_endpoint_handler_get_id_string(void *a1)
{
  const char *v1;
  char *v2;
  const char *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (char *)v1;
  if (v1)
  {
    v3 = v1 + 168;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_get_id_string";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_id_string";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_get_id_string";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_id_string";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_id_string";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = "";
LABEL_3:

  return v3;
}

const char *nw_endpoint_handler_mode_string(void *a1)
{
  void **v1;
  void **v2;
  const char *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = "path";
    switch(*((_DWORD *)v1 + 29))
    {
      case 0:
        goto LABEL_9;
      case 1:
        v3 = "resolver";
        break;
      case 2:
        v3 = nw_endpoint_flow_mode_string(v1[31]);
        break;
      case 3:
        v3 = "proxy";
        break;
      case 4:
        v3 = "fallback";
        break;
      case 5:
        v3 = "transform";
        break;
      default:
        v3 = "unknown-mode";
        break;
    }
    goto LABEL_9;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_mode_string";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_mode_string";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_mode_string";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_mode_string";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_mode_string";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_26:
  if (v6)
    free(v6);
  v3 = "null";
LABEL_9:

  return v3;
}

const char *nw_endpoint_handler_state_string(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  const char *v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[30];
    if (v3 > 5)
      v4 = "unknown-state";
    else
      v4 = off_1E149FC48[v3];
    goto LABEL_5;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_endpoint_handler_state_string";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_handler_state_string";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_endpoint_handler_state_string";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_handler_state_string";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_handler_state_string";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v7)
    free(v7);
  v4 = "null";
LABEL_5:

  return v4;
}

const char *nw_endpoint_handler_dry_run_string(void *a1)
{
  id v1;
  void *v2;
  const char *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((*((_BYTE *)v1 + 268) & 1) != 0)
      v3 = "dry-run ";
    else
      v3 = "";
    goto LABEL_5;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_dry_run_string";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_dry_run_string";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_dry_run_string";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_dry_run_string";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_dry_run_string";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v6)
    free(v6);
  v3 = "";
LABEL_5:

  return v3;
}

const char *nw_endpoint_flow_mode_string(void *a1)
{
  char *v1;
  void *v2;
  const char *v3;
  const char *v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[32] & 3) == 1)
    {
      v3 = "parent-flow";
    }
    else if ((v1[32] & 2) != 0)
    {
      if (v1[33] < 0)
        v4 = "multipath-socket-flow";
      else
        v4 = "socket-flow";
      if ((v1[33] & 0x40) != 0)
        v3 = "channel-flow";
      else
        v3 = v4;
    }
    else
    {
      v3 = "intermediate-flow";
    }
    goto LABEL_12;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_endpoint_flow_mode_string";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_flow_mode_string";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_endpoint_flow_mode_string";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_flow_mode_string";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_flow_mode_string";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_29:
  if (v7)
    free(v7);
  v3 = "null-flow";
LABEL_12:

  return v3;
}

uint64_t nw_parameters_get_sleep_keepalive_interval(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[22];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_sleep_keepalive_interval";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_sleep_keepalive_interval";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_socket_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
      return *(unsigned __int16 *)((char *)&a1[6].handle + 5) >> 15;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_socket_waiting_for_output";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_socket_waiting_for_output";
        v6 = "%{public}s called with null socket_handler";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_socket_waiting_for_output";
        v6 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_socket_waiting_for_output";
        v6 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_socket_waiting_for_output";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_socket_waiting_for_output";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_socket_waiting_for_output";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_socket_waiting_for_output";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_socket_waiting_for_output";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_socket_waiting_for_output";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_protocol_default_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  uint64_t (*waiting_for_output)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_default_waiting_for_output";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12))
      goto LABEL_20;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_waiting_for_output";
      v9 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_default_waiting_for_output";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v11)
      {
LABEL_20:
        if (v6)
          free(v6);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_waiting_for_output";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_waiting_for_output";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_20;
  }
  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      waiting_for_output = (uint64_t (*)(void))callbacks->waiting_for_output;
      if (waiting_for_output)
        return waiting_for_output();
    }
  }
  return 0;
}

uint64_t nw_path_flow_registration_get_id(void *a1, _OWORD *a2)
{
  _OWORD *v3;
  void *v4;
  _OWORD *v5;
  uint64_t v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_path_flow_registration_get_id";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_flow_registration_get_id";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null registration", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_path_flow_registration_get_id";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null registration, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_flow_registration_get_id";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null registration, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_flow_registration_get_id";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null registration, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_22:
    if (v9)
      free(v9);
    goto LABEL_3;
  }
  v5 = v3 + 2;
  if (!uuid_is_null((const unsigned __int8 *)v3 + 32))
  {
    *a2 = *v5;
    v6 = 1;
    goto LABEL_5;
  }
LABEL_3:
  v6 = 0;
LABEL_5:

  return v6;
}

void sub_182FE5254(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_purge_all_endpoints(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  _QWORD v11[4];
  id v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = __nw_context_purge_all_endpoints_block_invoke;
    v11[3] = &unk_1E14ACFD0;
    v12 = v1;
    nw_queue_context_async_if_needed(v12, v11);

    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_context_purge_all_endpoints";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v4, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_purge_all_endpoints";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_context_purge_all_endpoints";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_purge_all_endpoints";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_purge_all_endpoints";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

void sub_182FE5548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_server_mode(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[97] >> 7;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_server_mode";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_server_mode";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_server_mode";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_server_mode";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_server_mode";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_data_mode(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_parameters_get_data_mode";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_get_data_mode";
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v10 = type;
        v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_parameters_get_data_mode";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v5)
            goto LABEL_10;
          goto LABEL_9;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_get_data_mode";
          _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_get_data_mode";
          _os_log_impl(&dword_182FBE000, v6, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v5)
    {
LABEL_10:
      v3 = 0;
      goto LABEL_11;
    }
LABEL_9:
    free(v5);
    goto LABEL_10;
  }
  v3 = v1[92];
LABEL_11:

  return v3;
}

uint64_t nw_parameters_get_is_probe(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[97] >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_is_probe";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_is_probe";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_https_proxy_over_tls(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[98] >> 5) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_https_proxy_over_tls";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_https_proxy_over_tls";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void sub_182FE6750(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_pid(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(unsigned int *)(*((_QWORD *)v1 + 13) + 64);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_pid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_pid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_queue_context_async_if_needed(void *a1, void *a2)
{
  void (**v3)(_QWORD);
  _BOOL8 v4;
  id v5;

  v5 = a1;
  v3 = a2;
  if (nw_context_is_inline(v5))
  {
    v3[2](v3);
  }
  else
  {
    v4 = nw_context_copy_workloop(v5);
    if (dispatch_workloop_is_current())
      v3[2](v3);
    else
      dispatch_async((dispatch_queue_t)v4, v3);

  }
}

void sub_182FE6AE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void nw_release(void *obj)
{
  if (obj)
    os_release(obj);
}

BOOL nw_queue_context_create_source(void *a1, int a2, int a3, unsigned int a4, void *a5, void *a6)
{
  id v12;
  id v13;
  id v14;
  uint64_t v15;
  void *v16;
  const dispatch_source_type_s *v17;
  uint64_t v18;
  id *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  void *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  os_log_type_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  os_log_type_t v32;
  void *v33;
  _BOOL8 result;
  void *v35;
  dispatch_source_t v36;
  dispatch_source_t v37;
  NSObject *v38;
  uint64_t v39;
  id v40;
  char *v41;
  uint64_t v42;
  NSObject *v43;
  os_log_type_t v44;
  char *v45;
  uint64_t v46;
  os_log_type_t v47;
  _BOOL4 v48;
  uint64_t v49;
  os_log_type_t v50;
  void *v51;
  id v52;
  void *v53;
  id v54;
  char *backtrace_string;
  uint64_t v56;
  os_log_type_t v57;
  _BOOL4 v58;
  uint64_t v59;
  os_log_type_t v60;
  _BOOL4 v61;
  os_log_type_t v62;
  os_log_type_t v63;
  NSObject *v64;
  _QWORD handler[4];
  id v66;
  id *v67;
  char v68;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v71;
  __int16 v72;
  uint64_t v73;
  __int16 v74;
  uint64_t v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = a5;
  v14 = a6;
  v16 = v14;
  if (a2 == -1)
  {
    __nwlog_obj(v14, v15);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_queue_context_create_source";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    v25 = __nwlog_fault(v24, &type, &v68);
    if (!(_DWORD)v25)
      goto LABEL_79;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v25, v26);
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_queue_context_create_source";
        _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null (fd != -1)", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (!v68)
    {
      __nwlog_obj(v25, v26);
      v27 = objc_claimAutoreleasedReturnValue();
      v62 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_queue_context_create_source";
        _os_log_impl(&dword_182FBE000, v27, v62, "%{public}s called with null (fd != -1), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj(backtrace_string, v56);
    v27 = objc_claimAutoreleasedReturnValue();
    v57 = type;
    v58 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_queue_context_create_source";
        _os_log_impl(&dword_182FBE000, v27, v57, "%{public}s called with null (fd != -1), no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v58)
    {
      *(_DWORD *)buf = 136446466;
      v71 = "nw_queue_context_create_source";
      v72 = 2082;
      v73 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v27, v57, "%{public}s called with null (fd != -1), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_66;
  }
  if (!v13)
  {
    __nwlog_obj(v14, v15);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_queue_context_create_source";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    v30 = __nwlog_fault(v24, &type, &v68);
    if (!(_DWORD)v30)
      goto LABEL_79;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v30, v31);
      v27 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_queue_context_create_source";
        _os_log_impl(&dword_182FBE000, v27, v32, "%{public}s called with null block", buf, 0xCu);
      }
LABEL_78:

LABEL_79:
      if (v24)
        free(v24);
      goto LABEL_18;
    }
    if (!v68)
    {
      __nwlog_obj(v30, v31);
      v27 = objc_claimAutoreleasedReturnValue();
      v63 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_queue_context_create_source";
        _os_log_impl(&dword_182FBE000, v27, v63, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj(backtrace_string, v59);
    v27 = objc_claimAutoreleasedReturnValue();
    v60 = type;
    v61 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        v71 = "nw_queue_context_create_source";
        _os_log_impl(&dword_182FBE000, v27, v60, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v71 = "nw_queue_context_create_source";
      v72 = 2082;
      v73 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v27, v60, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_66:

    free(backtrace_string);
    goto LABEL_79;
  }
  if (a3 == 1)
  {
    v17 = (const dispatch_source_type_s *)MEMORY[0x1E0C80DB8];
    goto LABEL_11;
  }
  if (a3 == 2)
  {
    v17 = (const dispatch_source_type_s *)MEMORY[0x1E0C80DF0];
    goto LABEL_11;
  }
  if ((a3 & 0xFFFFFFFB) == 3)
  {
    v17 = (const dispatch_source_type_s *)MEMORY[0x1E0C80DD0];
    goto LABEL_11;
  }
  if ((a3 - 4) >= 3)
  {
    v21 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v21);
    v22 = (id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v71 = "nw_queue_context_create_source";
      v72 = 1024;
      LODWORD(v73) = a3;
      _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, "%{public}s Bad source type %d", buf, 0x12u);
    }

LABEL_18:
    v19 = 0;
LABEL_55:

    return (BOOL)v19;
  }
  v17 = (const dispatch_source_type_s *)qword_1E14A8678[a3 - 4];
LABEL_11:
  v19 = (id *)malloc_type_calloc(1uLL, 0x38uLL, 0xEAFB8F1AuLL);
  if (v19)
  {
    if (v12)
    {
LABEL_13:
      if (nw_context_is_inline(v12))
      {
        objc_storeStrong(v19 + 1, a1);
        v51 = _Block_copy(v13);
        v52 = v19[2];
        v19[2] = v51;

        v53 = _Block_copy(v16);
        v54 = v19[3];
        v19[3] = v53;

        *((_BYTE *)v19 + 48) = a3 == 3;
        v19[4] = (id)-1;
        v19[5] = (id)-1;
        goto LABEL_55;
      }
      v20 = nw_context_copy_workloop(v12);
LABEL_32:
      v35 = (void *)v20;
      v36 = dispatch_source_create(v17, a2, a4, (dispatch_queue_t)v20);
      v37 = (dispatch_source_t)*v19;
      *v19 = v36;

      if (*v19)
      {
        dispatch_source_set_event_handler((dispatch_source_t)*v19, v13);
        v38 = *v19;
        handler[0] = MEMORY[0x1E0C809B0];
        handler[1] = 3221225472;
        handler[2] = __nw_queue_context_create_source_block_invoke;
        handler[3] = &unk_1E14AB060;
        v66 = v16;
        v67 = v19;
        dispatch_source_set_cancel_handler(v38, handler);

LABEL_54:
        goto LABEL_55;
      }
      free(v19);
      v39 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v39);
      v40 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_queue_context_create_source";
      v41 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v68 = 0;
      if (__nwlog_fault(v41, &type, &v68))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v42 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v42);
          v43 = (id)gLogObj;
          v44 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)buf = 136446210;
            v71 = "nw_queue_context_create_source";
            _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s dispatch_source_create failed", buf, 0xCu);
          }
        }
        else if (v68)
        {
          v45 = (char *)__nw_create_backtrace_string();
          v46 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v46);
          v43 = (id)gLogObj;
          v47 = type;
          v48 = os_log_type_enabled(v43, type);
          if (v45)
          {
            if (v48)
            {
              *(_DWORD *)buf = 136446466;
              v71 = "nw_queue_context_create_source";
              v72 = 2082;
              v73 = (uint64_t)v45;
              _os_log_impl(&dword_182FBE000, v43, v47, "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v45);
            if (!v41)
              goto LABEL_53;
            goto LABEL_52;
          }
          if (v48)
          {
            *(_DWORD *)buf = 136446210;
            v71 = "nw_queue_context_create_source";
            _os_log_impl(&dword_182FBE000, v43, v47, "%{public}s dispatch_source_create failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          v49 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v49);
          v43 = (id)gLogObj;
          v50 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)buf = 136446210;
            v71 = "nw_queue_context_create_source";
            _os_log_impl(&dword_182FBE000, v43, v50, "%{public}s dispatch_source_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v41)
      {
LABEL_53:
        v19 = 0;
        goto LABEL_54;
      }
LABEL_52:
      free(v41);
      goto LABEL_53;
    }
LABEL_31:
    v20 = dispatch_workloop_copy_current();
    goto LABEL_32;
  }
  __nwlog_obj(0, v18);
  v64 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v71 = "strict_calloc";
  v72 = 2048;
  v73 = 1;
  v74 = 2048;
  v75 = 56;
  v33 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v33);
  if (!result)
  {
    free(v33);
    if (v12)
      goto LABEL_13;
    goto LABEL_31;
  }
  __break(1u);
  return result;
}

void sub_182FE74EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_queue_context_async(void *a1, void *a2)
{
  id v3;
  _BOOL8 v4;
  id v5;

  v5 = a1;
  v3 = a2;
  if (nw_context_is_inline(v5))
  {
    nw_context_queue_block(v5, v3);
  }
  else
  {
    v4 = nw_context_copy_workloop(v5);
    dispatch_async((dispatch_queue_t)v4, v3);

  }
}

void sub_182FE7580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

BOOL nw_context_is_inline(void *a1)
{
  unsigned __int8 *v1;
  uint64_t v2;
  unsigned __int8 *v3;
  unsigned int v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  _BOOL8 result;
  uint64_t v9;
  void *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  uint64_t v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v3 = v1;
  if (!v1)
  {
    __nwlog_obj(0, v2);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_context_is_inline";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    v12 = __nwlog_fault(v11, &type, &v21);
    if ((_DWORD)v12)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj(v12, v13);
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_is_inline";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj(backtrace_string, v17);
        v14 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        v19 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v24 = "nw_context_is_inline";
            v25 = 2082;
            v26 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v18, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_is_inline";
          _os_log_impl(&dword_182FBE000, v14, v18, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj(v12, v13);
        v14 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_context_is_inline";
          _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_23:
    if (v11)
      free(v11);
    v9 = 0;
    goto LABEL_6;
  }
  v4 = v1[136];
  if ((v4 & 0x40) != 0)
  {
LABEL_5:
    v9 = (v4 >> 3) & 1;
LABEL_6:

    return v9;
  }
  v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v5);
  v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v24 = "nw_context_is_inline";
  v7 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    v4 = v3[136];
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

BOOL nw_context_copy_workloop(void *a1)
{
  id *v1;
  uint64_t v2;
  id *v3;
  uint64_t v4;
  NSObject *v5;
  void *v6;
  _BOOL8 result;
  id v8;
  void *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  os_log_type_t v18;
  char *backtrace_string;
  uint64_t v20;
  os_log_type_t v21;
  _BOOL4 v22;
  uint64_t v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v3 = v1;
  if (!v1)
  {
    __nwlog_obj(0, v2);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_context_copy_workloop";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    v11 = __nwlog_fault(v10, &type, &v28);
    if ((_DWORD)v11)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj(v11, v12);
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_context_copy_workloop";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null context", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v28)
      {
        __nwlog_obj(v11, v12);
        v13 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_context_copy_workloop";
          _os_log_impl(&dword_182FBE000, v13, v26, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj(backtrace_string, v20);
      v13 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_context_copy_workloop";
          _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_context_copy_workloop";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
LABEL_40:
    if (v10)
      free(v10);
    v8 = 0;
    goto LABEL_7;
  }
  if (((_BYTE)v1[17] & 8) != 0)
  {
    __nwlog_obj(v1, v2);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_context_copy_workloop";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    v16 = __nwlog_fault(v10, &type, &v28);
    if ((_DWORD)v16)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj(v16, v17);
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_context_copy_workloop";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null !context->is_inline", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v28)
      {
        __nwlog_obj(v16, v17);
        v13 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_context_copy_workloop";
          _os_log_impl(&dword_182FBE000, v13, v27, "%{public}s called with null !context->is_inline, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj(backtrace_string, v23);
      v13 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_context_copy_workloop";
          _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null !context->is_inline, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_context_copy_workloop";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null !context->is_inline, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
    goto LABEL_40;
  }
  if (((_BYTE)v1[17] & 0x40) != 0)
  {
LABEL_6:
    v8 = v3[1];
LABEL_7:

    return (BOOL)v8;
  }
  v4 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v4);
  v5 = (id)gLogObj;
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v31 = "nw_context_copy_workloop";
  v6 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v6);
  if (!result)
  {
    free(v6);
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

uint64_t nw_path_struct_size_for_endpoint_and_metadata(void *a1, unint64_t *a2, char a3)
{
  NSObject *v5;
  nw_endpoint_type_t v6;
  nw_txt_record_t v7;
  _BOOL8 domain_for_policy;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *device_id;
  size_t v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  size_t custom_data_length;
  id v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const sockaddr *address;
  unint64_t sa_len;
  const char *bonjour_service_name;
  const char *bonjour_service_type;
  const char *bonjour_service_domain;
  size_t v29;
  size_t v30;
  size_t v31;
  Class isa;
  const char *application_service_alias;
  const char *application_service_name;
  const char *device_name;
  const char *device_model;
  const char *contact_id;
  size_t v38;
  size_t v39;
  size_t v40;
  size_t v41;
  size_t v42;
  Class v43;
  const char *url;
  char v45;
  unsigned __int8 v46;
  char *backtrace_string;
  os_log_type_t v48;
  _BOOL4 v49;
  os_log_type_t v50;
  _BYTE *v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  char v57;
  os_log_type_t type;
  unsigned __int8 v59[128];
  _BYTE uu[18];
  __int16 v61;
  char *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = nw_endpoint_get_type(v5);
  v7 = nw_endpoint_copy_txt_record(v5);
  switch(v6)
  {
    case nw_endpoint_type_address:
      address = nw_endpoint_get_address(v5);
      if (a2)
      {
        if (address)
          sa_len = address->sa_len;
        else
          sa_len = 0;
        *a2 = sa_len;
      }
      if (address)
      {
        v9 = address->sa_len;
        if (!v7)
          goto LABEL_77;
      }
      else
      {
        v9 = 0;
        if (!v7)
        {
LABEL_77:
          if (a2)
            goto LABEL_5;
          goto LABEL_6;
        }
      }
      v9 = (unint64_t)v7[2].isa + 28;
      goto LABEL_77;
    case nw_endpoint_type_host:
    case nw_endpoint_type_url|nw_endpoint_type_address:
      domain_for_policy = nw_endpoint_get_domain_for_policy(v5);
      if (domain_for_policy)
      {
        v9 = strlen((const char *)domain_for_policy) + 9;
        if (v7)
          goto LABEL_4;
      }
      else
      {
        v9 = 9;
        if (v7)
        {
LABEL_4:
          v9 += (unint64_t)v7[2].isa;
          if (!a2)
            goto LABEL_6;
          goto LABEL_5;
        }
      }
      if (a2)
        goto LABEL_5;
      goto LABEL_6;
    case nw_endpoint_type_bonjour_service:
      bonjour_service_name = nw_endpoint_get_bonjour_service_name(v5);
      bonjour_service_type = nw_endpoint_get_bonjour_service_type(v5);
      bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(v5);
      if (bonjour_service_name)
      {
        v29 = strlen(bonjour_service_name) + 9;
        if (bonjour_service_type)
          goto LABEL_40;
      }
      else
      {
        v29 = 9;
        if (bonjour_service_type)
        {
LABEL_40:
          v30 = strlen(bonjour_service_type) + 1;
          if (bonjour_service_domain)
            goto LABEL_41;
          goto LABEL_60;
        }
      }
      v30 = 1;
      if (bonjour_service_domain)
      {
LABEL_41:
        v31 = strlen(bonjour_service_domain) + 1;
        if (v7)
        {
LABEL_42:
          isa = v7[2].isa;
          goto LABEL_62;
        }
LABEL_61:
        isa = 0;
LABEL_62:
        v9 = (unint64_t)isa + v31 + v30 + v29;
        if (!a2)
          goto LABEL_6;
LABEL_5:
        *a2 = v9;
LABEL_6:
        if (v9 <= 0x1C)
          v10 = 28;
        else
          v10 = v9;
        goto LABEL_9;
      }
LABEL_60:
      v31 = 1;
      if (v7)
        goto LABEL_42;
      goto LABEL_61;
    case nw_endpoint_type_url:
      url = nw_endpoint_get_url(v5);
      if (url)
      {
        v9 = strlen(url) + 9;
        if (a2)
          goto LABEL_5;
      }
      else
      {
        v9 = 9;
        if (a2)
          goto LABEL_5;
      }
      goto LABEL_6;
    case nw_endpoint_type_url|nw_endpoint_type_host:
      application_service_alias = (const char *)nw_endpoint_get_application_service_alias(v5);
      application_service_name = (const char *)nw_endpoint_get_application_service_name(v5);
      nw_endpoint_get_service_identifier(v5, uu);
      device_name = (const char *)nw_endpoint_get_device_name(v5);
      device_model = (const char *)nw_endpoint_get_device_model(v5);
      contact_id = (const char *)nw_endpoint_get_contact_id(v5);
      if (application_service_alias)
      {
        v38 = strlen(application_service_alias) + 9;
        if (application_service_name)
          goto LABEL_45;
      }
      else
      {
        v38 = 9;
        if (application_service_name)
        {
LABEL_45:
          v39 = strlen(application_service_name) + 1;
          if (device_name)
            goto LABEL_46;
          goto LABEL_66;
        }
      }
      v39 = 1;
      if (device_name)
      {
LABEL_46:
        v40 = strlen(device_name) + 1;
        if (device_model)
          goto LABEL_47;
        goto LABEL_67;
      }
LABEL_66:
      v40 = 1;
      if (device_model)
      {
LABEL_47:
        v41 = strlen(device_model) + 1;
        if (contact_id)
          goto LABEL_48;
        goto LABEL_68;
      }
LABEL_67:
      v41 = 1;
      if (contact_id)
      {
LABEL_48:
        v42 = strlen(contact_id) + 1;
        if (v7)
        {
LABEL_49:
          v43 = v7[2].isa;
          goto LABEL_70;
        }
LABEL_69:
        v43 = 0;
LABEL_70:
        v9 = (unint64_t)v43 + v42 + v38 + v39 + v40 + v41 + 24;
        if (!a2)
          goto LABEL_6;
        goto LABEL_5;
      }
LABEL_68:
      v42 = 1;
      if (v7)
        goto LABEL_49;
      goto LABEL_69;
    default:
      if (!nw_endpoint_is_custom_type(v5))
        goto LABEL_101;
      custom_data_length = nw_endpoint_get_custom_data_length(v5);
      if (!custom_data_length)
        goto LABEL_101;
      if (custom_data_length <= 0x400)
      {
        v45 = -9;
        if (custom_data_length < 0xF7)
          v45 = custom_data_length;
        v46 = v45 + 8;
        if (a2)
          *a2 = v46;
        if (v46 <= 0x1Cu)
          v10 = 28;
        else
          v10 = v46;
        goto LABEL_9;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = (id)gLogObj;
      *(_DWORD *)uu = 136446466;
      *(_QWORD *)&uu[4] = "nw_path_struct_size_for_endpoint";
      *(_WORD *)&uu[12] = 1024;
      *(_DWORD *)&uu[14] = 1024;
      LODWORD(v52) = 18;
      v51 = uu;
      v21 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v57 = 0;
      if (!__nwlog_fault(v21, &type, &v57))
        goto LABEL_99;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)uu = 136446466;
          *(_QWORD *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s Custom data size must be no larger than %d", uu, 0x12u);
        }
LABEL_98:

        goto LABEL_99;
      }
      if (!v57)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v50 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)uu = 136446466;
          *(_QWORD *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl(&dword_182FBE000, v22, v50, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", uu, 0x12u);
        }
        goto LABEL_98;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v48 = type;
      v49 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)uu = 136446466;
          *(_QWORD *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl(&dword_182FBE000, v22, v48, "%{public}s Custom data size must be no larger than %d, no backtrace", uu, 0x12u);
        }
        goto LABEL_98;
      }
      if (v49)
      {
        *(_DWORD *)uu = 136446722;
        *(_QWORD *)&uu[4] = "nw_path_struct_size_for_endpoint";
        *(_WORD *)&uu[12] = 1024;
        *(_DWORD *)&uu[14] = 1024;
        v61 = 2082;
        v62 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v22, v48, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", uu, 0x1Cu);
      }

      free(backtrace_string);
LABEL_99:
      if (v21)
        free(v21);
LABEL_101:
      v10 = 28;
LABEL_9:

      v11 = v10 + 5;
      if ((a3 & 1) != 0)
      {
        *(_QWORD *)uu = 0;
        *(_QWORD *)&uu[8] = 0;
        nw_endpoint_get_agent_identifier(v5, uu);
        if (!uuid_is_null(uu))
          v11 = v10 + 26;
      }
      if ((a3 & 2) != 0)
      {
        device_id = (const char *)nw_endpoint_get_device_id(v5);
        if (device_id)
          v13 = strlen(device_id) + 5;
        else
          v13 = 0;
        v11 += v13;
      }
      if ((a3 & 4) != 0)
      {
        v55 = 0u;
        v56 = 0u;
        v53 = 0u;
        v54 = 0u;
        v14 = nw_endpoint_copy_public_keys(v5);
        v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v53, v59, 16);
        if (v15)
        {
          v16 = *(_QWORD *)v54;
          do
          {
            for (i = 0; i != v15; ++i)
            {
              if (*(_QWORD *)v54 != v16)
                objc_enumerationMutation(v14);
              v11 += objc_msgSend(*(id *)(*((_QWORD *)&v53 + 1) + 8 * i), "length", v51, v52) + 5;
            }
            v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v53, v59, 16);
          }
          while (v15);
        }

      }
      return v11;
  }
}

void sub_182FE84E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

nw_txt_record_t nw_endpoint_copy_txt_record(nw_endpoint_t endpoint)
{
  nw_endpoint_t v1;
  nw_endpoint_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = endpoint;
  v2 = v1;
  if (v1)
  {
    v3 = v1[23].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_copy_txt_record";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_copy_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_copy_txt_record";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_copy_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_copy_txt_record";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_endpoint_get_domain_for_policy(void *a1)
{
  id v1;
  void *v2;
  _QWORD *v3;
  uint64_t domain_for_policy;
  _QWORD *v5;
  NSObject *v6;
  void *v7;
  _BOOL8 result;

  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    domain_for_policy = 0;
LABEL_11:

    return domain_for_policy;
  }
  v3 = v1;
  domain_for_policy = objc_msgSend(v3, "domainForPolicy");
  if (domain_for_policy)
  {
LABEL_10:

    goto LABEL_11;
  }
  v5 = (_QWORD *)v3[14];
  if (!v5)
  {
    domain_for_policy = 0;
    goto LABEL_10;
  }
  if (v5 != v3)
  {
LABEL_7:
    domain_for_policy = nw_endpoint_get_domain_for_policy(v5);
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  v7 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    v5 = (_QWORD *)v3[14];
    goto LABEL_7;
  }
  __break(1u);
  return result;
}

void sub_182FE8954(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_endpoint_get_agent_identifier(void *a1, _OWORD *a2)
{
  char *v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(v3 + 28);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_get_agent_identifier";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_get_agent_identifier";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_endpoint_get_device_id(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 13);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_get_device_id";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_device_id";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_get_device_id";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_device_id";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_device_id";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_effective_bundle_id(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 14);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_effective_bundle_id";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_effective_bundle_id";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_endpoint_handler_get_next_top_id()
{
  unsigned int v0;
  uint64_t result;
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  do
    v0 = __ldaxr(nw_endpoint_handler_get_next_top_id::s_last_top_level_id);
  while (__stlxr(v0 + 1, nw_endpoint_handler_get_next_top_id::s_last_top_level_id));
  result = v0 + 1;
  if (v0 == -1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136446466;
      v4 = "nw_endpoint_handler_get_next_top_id";
      v5 = 1024;
      v6 = 0;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s reached %u endpoint top ids, wrapping", (uint8_t *)&v3, 0x12u);
    }

    return nw_endpoint_handler_get_next_top_id();
  }
  return result;
}

void __nw_context_purge_all_endpoints_block_invoke(uint64_t a1)
{
  nw_context_purge_endpoints(*(NWConcrete_nw_context **)(a1 + 32), 1);
}

void nw_endpoint_set_do_not_redact(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 231) |= 0x20u;
    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_endpoint_set_do_not_redact";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_endpoint_set_do_not_redact";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_endpoint_set_do_not_redact";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_endpoint_set_do_not_redact";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_endpoint_set_do_not_redact";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

void nw_parameters_set_no_cellular_fallback(void *a1, int a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  __int16 v9;
  unsigned int v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = *((_QWORD *)v3 + 13);
    v7 = *(unsigned __int16 *)(v5 + 108);
    v6 = v5 + 108;
    v8 = v7 | (*(unsigned __int8 *)(v6 + 2) << 16);
    if (a2)
      v9 = 64;
    else
      v9 = 0;
    v10 = v8 & 0xFFFFFFBF;
    *(_WORD *)v6 = v10 | v9;
    *(_BYTE *)(v6 + 2) = BYTE2(v10);
    goto LABEL_6;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_parameters_set_no_cellular_fallback";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_parameters_set_no_cellular_fallback";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_parameters_set_no_cellular_fallback";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_parameters_set_no_cellular_fallback";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_parameters_set_no_cellular_fallback";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v12)
    free(v12);
LABEL_6:

}

Swift::Void __swiftcall NWActivity.activate()()
{
  uint64_t v0;

  nw_activity_activate(*(void **)(v0 + 16));
}

uint64_t nw_protocol_request_outbound_data(void *a1, unint64_t a2, uint64_t a3, void *a4)
{
  NWConcrete_nw_protocol_instance *v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t tqh_first;
  _BOOL8 v13;
  nw_frame *v14;
  void *v15;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  void *v21;
  os_log_type_t v22;
  void *v23;
  os_log_type_t v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  char *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  os_log_type_t v34;
  os_log_type_t v35;
  _QWORD aBlock[4];
  id v37;
  unint64_t v38;
  uint64_t v39;
  char v40;
  os_log_type_t v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  v9 = v8;
  if (!v7)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_request_outbound_data";
    v18 = (char *)_os_log_send_and_compose_impl();

    v41 = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v18, &v41, &v40))
      goto LABEL_61;
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v26 = v41;
      v27 = os_log_type_enabled(v19, v41);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          v43 = "nw_protocol_request_outbound_data";
          v44 = 2082;
          v45 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v19, v26, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v18)
        {
LABEL_10:
          v10 = 0;
          goto LABEL_11;
        }
LABEL_62:
        free(v18);
        goto LABEL_10;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v26, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v33 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v33, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_60:

    goto LABEL_61;
  }
  if (!a3)
  {
    __nwlog_obj();
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_request_outbound_data";
    v18 = (char *)_os_log_send_and_compose_impl();

    v41 = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v18, &v41, &v40))
      goto LABEL_61;
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v22 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null data_size", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (!v40)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v34 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v34, "%{public}s called with null data_size, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_60;
    }
    v28 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v29 = v41;
    v30 = os_log_type_enabled(v19, v41);
    if (!v28)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v29, "%{public}s called with null data_size, no backtrace", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_request_outbound_data";
      v44 = 2082;
      v45 = v28;
      _os_log_impl(&dword_182FBE000, v19, v29, "%{public}s called with null data_size, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_41;
  }
  if (!v8)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_request_outbound_data";
    v18 = (char *)_os_log_send_and_compose_impl();

    v41 = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v18, &v41, &v40))
      goto LABEL_61;
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v24 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v24, "%{public}s called with null available_outbound_data", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (!v40)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v35 = v41;
      if (os_log_type_enabled(v19, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v35, "%{public}s called with null available_outbound_data, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_60;
    }
    v28 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v31 = v41;
    v32 = os_log_type_enabled(v19, v41);
    if (!v28)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_request_outbound_data";
        _os_log_impl(&dword_182FBE000, v19, v31, "%{public}s called with null available_outbound_data, no backtrace", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_request_outbound_data";
      v44 = 2082;
      v45 = v28;
      _os_log_impl(&dword_182FBE000, v19, v31, "%{public}s called with null available_outbound_data, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_41:

    free(v28);
    if (!v18)
      goto LABEL_10;
    goto LABEL_62;
  }
  if (!nw_protocol_service_outbound_requests(v7)
    || (nw_protocol_service_requested_outbound_data(v7, a2, a3, v9) & 1) == 0)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_request_outbound_data_block_invoke;
    aBlock[3] = &unk_1E149B9B8;
    v37 = v9;
    v38 = a2;
    v39 = a3;
    v11 = _Block_copy(aBlock);
    tqh_first = (uint64_t)v7->pending_outbound_frames.tqh_first;
    if (!tqh_first)
    {
      v13 = nw_array_create();
      v14 = v7->pending_outbound_frames.tqh_first;
      v7->pending_outbound_frames.tqh_first = (nw_frame *)v13;

      tqh_first = (uint64_t)v7->pending_outbound_frames.tqh_first;
    }
    v15 = _Block_copy(v11);
    nw_array_append(tqh_first, v15);

    goto LABEL_10;
  }
  v10 = 1;
LABEL_11:

  return v10;
}

void sub_182FE9FA8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_udp_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, uint64_t a5, nw_frame_array_s *a6)
{
  __int16 output_handler_context_high;
  uint64_t v9;
  uint64_t v10;
  nw_protocol *output_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v14;
  nw_protocol_callbacks *v15;
  uint64_t (*get_output_frames)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *);
  uint64_t v17;
  nw_frame *tqh_first;
  nw_frame *v19;
  char v20;
  nw_protocol_callbacks *v22;
  nw_protocol_callbacks *v23;
  void (**v24)(_QWORD);
  const void *v25;
  nw_protocol_callbacks *v26;
  nw_protocol_callbacks *v27;
  void (**v28)(_QWORD);
  const void *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  const char *name;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  const char *v38;
  const char *v39;
  char *v40;
  _BOOL4 v41;
  const char *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  const char *v46;
  _BOOL4 v47;
  NSObject *v48;
  os_log_type_t v49;
  char *backtrace_string;
  _BOOL4 v51;
  const char *v52;
  char *v53;
  _BOOL4 v54;
  char *v55;
  _BOOL4 v56;
  const char *v57;
  const char *v58;
  NSObject *v59;
  os_log_type_t v60;
  uint32_t v61;
  _QWORD v62[2];
  uint64_t (*v63)(uint64_t, uint64_t);
  void *v64;
  nw_protocol *v65;
  char v66;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  void *v71;
  __int16 v72;
  nw_protocol *v73;
  __int16 v74;
  char *v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      output_handler_context_high = HIWORD(a1[2].output_handler_context);
      if ((output_handler_context_high & 1) != 0)
      {
        v17 = 0;
        HIWORD(a1[2].output_handler_context) = output_handler_context_high | 2;
        return v17;
      }
      if (a3 >= 0xFFFFFFF8)
        v9 = 0xFFFFFFFFLL;
      else
        v9 = a3 + 8;
      if (a4 >= 0xFFFFFFF8)
        v10 = 0xFFFFFFFFLL;
      else
        v10 = a4 + 8;
      output_handler = a1->output_handler;
      if (output_handler)
      {
        handle = output_handler->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
        v14 = a1[1].callbacks;
        if (v14)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v14->add_input_handler + 1);
        if (a6)
        {
          v15 = output_handler->callbacks;
          if (v15)
          {
            get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))v15->get_output_frames;
            if (get_output_frames)
            {
              v17 = get_output_frames(output_handler, a1, v9, v10, a5, a6);
              goto LABEL_20;
            }
          }
          __nwlog_obj();
          name = output_handler->identifier->name;
          *(_DWORD *)buf = 136446722;
          v69 = "__nw_protocol_get_output_frames";
          if (!name)
            name = "invalid";
          v70 = 2082;
          v71 = (void *)name;
          v72 = 2048;
          v73 = output_handler;
          v35 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v66 = 0;
          if (__nwlog_fault(v35, &type, &v66))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v36 = __nwlog_obj();
              v37 = type;
              if (!os_log_type_enabled(v36, type))
                goto LABEL_137;
              v38 = output_handler->identifier->name;
              if (!v38)
                v38 = "invalid";
              *(_DWORD *)buf = 136446722;
              v69 = "__nw_protocol_get_output_frames";
              v70 = 2082;
              v71 = (void *)v38;
              v72 = 2048;
              v73 = output_handler;
              v39 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_122:
              v59 = v36;
              v60 = v37;
              v61 = 32;
LABEL_136:
              _os_log_impl(&dword_182FBE000, v59, v60, v39, buf, v61);
              goto LABEL_137;
            }
            if (!v66)
            {
              v36 = __nwlog_obj();
              v37 = type;
              if (!os_log_type_enabled(v36, type))
                goto LABEL_137;
              v57 = output_handler->identifier->name;
              if (!v57)
                v57 = "invalid";
              *(_DWORD *)buf = 136446722;
              v69 = "__nw_protocol_get_output_frames";
              v70 = 2082;
              v71 = (void *)v57;
              v72 = 2048;
              v73 = output_handler;
              v39 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
              goto LABEL_122;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            v36 = __nwlog_obj();
            v37 = type;
            v51 = os_log_type_enabled(v36, type);
            if (!backtrace_string)
            {
              if (!v51)
                goto LABEL_137;
              v58 = output_handler->identifier->name;
              if (!v58)
                v58 = "invalid";
              *(_DWORD *)buf = 136446722;
              v69 = "__nw_protocol_get_output_frames";
              v70 = 2082;
              v71 = (void *)v58;
              v72 = 2048;
              v73 = output_handler;
              v39 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
              goto LABEL_122;
            }
            if (v51)
            {
              if (output_handler->identifier)
                v52 = output_handler->identifier->name;
              else
                v52 = "invalid";
              *(_DWORD *)buf = 136446978;
              v69 = "__nw_protocol_get_output_frames";
              v70 = 2082;
              v71 = (void *)v52;
              v72 = 2048;
              v73 = output_handler;
              v74 = 2082;
              v75 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(backtrace_string);
          }
LABEL_137:
          if (!v35)
          {
LABEL_139:
            v17 = 0;
LABEL_20:
            if (a1->handle == &nw_protocol_ref_counted_handle)
            {
              v22 = a1[1].callbacks;
              if (v22)
              {
                v23 = (nw_protocol_callbacks *)((char *)v22 - 1);
                a1[1].callbacks = v23;
                if (!v23)
                {
                  v24 = *(void (***)(_QWORD))a1[1].flow_id;
                  if (v24)
                  {
                    *(_QWORD *)a1[1].flow_id = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }
                  if ((a1[1].flow_id[8] & 1) != 0)
                  {
                    v25 = *(const void **)a1[1].flow_id;
                    if (v25)
                      _Block_release(v25);
                  }
                  free(a1);
                }
              }
            }
            if (handle == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
            {
              v26 = output_handler[1].callbacks;
              if (v26)
              {
                v27 = (nw_protocol_callbacks *)((char *)v26 - 1);
                output_handler[1].callbacks = v27;
                if (!v27)
                {
                  v28 = *(void (***)(_QWORD))output_handler[1].flow_id;
                  if (v28)
                  {
                    *(_QWORD *)output_handler[1].flow_id = 0;
                    v28[2](v28);
                    _Block_release(v28);
                  }
                  if ((output_handler[1].flow_id[8] & 1) != 0)
                  {
                    v29 = *(const void **)output_handler[1].flow_id;
                    if (v29)
                      _Block_release(v29);
                  }
                  free(output_handler);
                }
              }
            }
LABEL_23:
            v62[0] = MEMORY[0x1E0C809B0];
            v62[1] = 0x40000000;
            v63 = ___ZL33nw_protocol_udp_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v64 = &__block_descriptor_tmp_17;
            v65 = a1;
            tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first)
                break;
              v19 = (nw_frame *)*((_QWORD *)tqh_first + 4);
              v20 = ((uint64_t (*)(_QWORD *))v63)(v62);
              tqh_first = v19;
            }
            while ((v20 & 1) != 0);
            if (_nw_signposts_once != -1)
              dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
            if (_nw_signposts_enabled && kdebug_is_enabled())
              kdebug_trace();
            return v17;
          }
LABEL_138:
          free(v35);
          goto LABEL_139;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v69 = "__nw_protocol_get_output_frames";
        v35 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v66 = 0;
        if (!__nwlog_fault(v35, &type, &v66))
          goto LABEL_137;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v48 = __nwlog_obj();
          v49 = type;
          if (!os_log_type_enabled(v48, type))
            goto LABEL_137;
          *(_DWORD *)buf = 136446210;
          v69 = "__nw_protocol_get_output_frames";
          v39 = "%{public}s called with null return_array";
        }
        else if (v66)
        {
          v55 = (char *)__nw_create_backtrace_string();
          v48 = __nwlog_obj();
          v49 = type;
          v56 = os_log_type_enabled(v48, type);
          if (v55)
          {
            if (v56)
            {
              *(_DWORD *)buf = 136446466;
              v69 = "__nw_protocol_get_output_frames";
              v70 = 2082;
              v71 = v55;
              _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null return_array, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v55);
            if (!v35)
              goto LABEL_139;
            goto LABEL_138;
          }
          if (!v56)
            goto LABEL_137;
          *(_DWORD *)buf = 136446210;
          v69 = "__nw_protocol_get_output_frames";
          v39 = "%{public}s called with null return_array, no backtrace";
        }
        else
        {
          v48 = __nwlog_obj();
          v49 = type;
          if (!os_log_type_enabled(v48, type))
            goto LABEL_137;
          *(_DWORD *)buf = 136446210;
          v69 = "__nw_protocol_get_output_frames";
          v39 = "%{public}s called with null return_array, backtrace limit exceeded";
        }
        v59 = v48;
        v60 = v49;
        v61 = 12;
        goto LABEL_136;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v69 = "__nw_protocol_get_output_frames";
      v43 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v66 = 0;
      if (__nwlog_fault(v43, &type, &v66))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v44 = __nwlog_obj();
          v45 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            v69 = "__nw_protocol_get_output_frames";
            v46 = "%{public}s called with null protocol";
LABEL_129:
            _os_log_impl(&dword_182FBE000, v44, v45, v46, buf, 0xCu);
          }
        }
        else if (v66)
        {
          v53 = (char *)__nw_create_backtrace_string();
          v44 = __nwlog_obj();
          v45 = type;
          v54 = os_log_type_enabled(v44, type);
          if (v53)
          {
            if (v54)
            {
              *(_DWORD *)buf = 136446466;
              v69 = "__nw_protocol_get_output_frames";
              v70 = 2082;
              v71 = v53;
              _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v53);
            goto LABEL_130;
          }
          if (v54)
          {
            *(_DWORD *)buf = 136446210;
            v69 = "__nw_protocol_get_output_frames";
            v46 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_129;
          }
        }
        else
        {
          v44 = __nwlog_obj();
          v45 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            v69 = "__nw_protocol_get_output_frames";
            v46 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_129;
          }
        }
      }
LABEL_130:
      if (v43)
        free(v43);
      v17 = 0;
      goto LABEL_23;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_protocol_udp_get_output_frames";
    v30 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (!__nwlog_fault(v30, &type, &v66))
      goto LABEL_115;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null udp";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    if (!v66)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    v40 = (char *)__nw_create_backtrace_string();
    v31 = __nwlog_obj();
    v32 = type;
    v47 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null udp, no backtrace";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      v69 = "nw_protocol_udp_get_output_frames";
      v70 = 2082;
      v71 = v40;
      v42 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
    goto LABEL_78;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v69 = "nw_protocol_udp_get_output_frames";
  v30 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v66 = 0;
  if (!__nwlog_fault(v30, &type, &v66))
    goto LABEL_115;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v66)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    v40 = (char *)__nw_create_backtrace_string();
    v31 = __nwlog_obj();
    v32 = type;
    v41 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_protocol_udp_get_output_frames";
        v33 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      v69 = "nw_protocol_udp_get_output_frames";
      v70 = 2082;
      v71 = v40;
      v42 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_77:
      _os_log_impl(&dword_182FBE000, v31, v32, v42, buf, 0x16u);
    }
LABEL_78:
    free(v40);
    goto LABEL_115;
  }
  v31 = __nwlog_obj();
  v32 = type;
  if (os_log_type_enabled(v31, type))
  {
    *(_DWORD *)buf = 136446210;
    v69 = "nw_protocol_udp_get_output_frames";
    v33 = "%{public}s called with null protocol";
LABEL_114:
    _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0xCu);
  }
LABEL_115:
  if (v30)
    free(v30);
  return 0;
}

uint64_t ___ZL33nw_protocol_udp_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_frame_claim(a2, a2, 8, 0);
  return 1;
}

void nw_channel_allocate_frames(_QWORD *a1)
{
  unint64_t v1;
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *backtrace_string;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = a1[15];
  v1 = a1[16];
  v3 = v1 > v2;
  v4 = v1 - v2;
  if (v3)
  {
    v5 = v4 >= 0x20 ? 32 : v4;
    if (v5)
    {
      while (1)
      {
        v7 = nw_frame_create(32, 0, 0, 0, 0);
        if (!v7)
          break;
        *(_WORD *)(v7 + 204) |= 0x100u;
        *(_QWORD *)(v7 + 16) = 0;
        v8 = (uint64_t *)a1[37];
        *(_QWORD *)(v7 + 24) = v8;
        *v8 = v7;
        a1[37] = v7 + 16;
        ++a1[15];
        if (!--v5)
          return;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v18 = "nw_channel_create_frame";
      v9 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v15 = 0;
      if (!__nwlog_fault(v9, &type, &v15))
        goto LABEL_24;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v18 = "nw_channel_create_frame";
        v12 = "%{public}s nw_frame_create failed";
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        v14 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_channel_create_frame";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_24;
        }
        if (!v14)
        {
LABEL_24:
          if (v9)
            free(v9);
          return;
        }
        *(_DWORD *)buf = 136446210;
        v18 = "nw_channel_create_frame";
        v12 = "%{public}s nw_frame_create failed, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v18 = "nw_channel_create_frame";
        v12 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
      goto LABEL_24;
    }
  }
}

uint64_t nw_protocol_ipv4_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, int a5, nw_frame_array_s *a6)
{
  _BOOL8 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  nw_protocol *output_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v18;
  nw_protocol_callbacks *v19;
  uint64_t (*get_output_frames)(nw_protocol *, nw_protocol *, uint64_t, uint64_t);
  uint64_t v21;
  nw_frame *tqh_first;
  nw_frame *v23;
  char v24;
  nw_protocol_callbacks *v25;
  nw_protocol_callbacks *v26;
  void (**v27)(_QWORD);
  const void *v28;
  nw_protocol_callbacks *v29;
  nw_protocol_callbacks *v30;
  void (**v31)(_QWORD);
  const void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  const char *v36;
  char *backtrace_string;
  _BOOL4 v38;
  nw_frame **tqh_last;
  const char *name;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  const char *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  NSObject *v55;
  os_log_type_t v56;
  char *v57;
  _BOOL4 v58;
  const char *v59;
  char *v60;
  _BOOL4 v61;
  const char *v62;
  _BOOL4 v63;
  char *v64;
  _BOOL4 v65;
  char *v66;
  _BOOL4 v67;
  const char *v68;
  const char *v69;
  NSObject *v70;
  os_log_type_t v71;
  uint32_t v72;
  _QWORD v73[2];
  uint64_t (*v74)(uint64_t, uint64_t);
  void *v75;
  nw_protocol *v76;
  char v77;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE v82[18];
  __int16 v83;
  char *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      if (a5 && LODWORD(a1[3].identifier) < a3 && ((uint64_t)a1[3].handle & 4) == 0)
      {
        v9 = nw_calloc_type<unsigned char>(a3);
        v10 = nw_frame_create(0, v9, a3, (uint64_t)nw_protocol_ipv4_frame_output_finalizer, (uint64_t)&a1[1].output_handler);
        v11 = v10;
        if (v10)
        {
          *(_WORD *)(v10 + 204) |= 1u;
          *(_QWORD *)(v10 + 16) = 0;
          v12 = *(uint64_t **)&a1[3].flow_id[8];
          *(_QWORD *)(v10 + 24) = v12;
          *v12 = v10;
          *(_QWORD *)&a1[3].flow_id[8] = v10 + 16;
LABEL_65:
          *(_QWORD *)(v11 + 32) = 0;
          tqh_last = a6->tqh_last;
          *(_QWORD *)(v11 + 40) = tqh_last;
          *tqh_last = (nw_frame *)v11;
          a6->tqh_last = (nw_frame **)(v11 + 32);
          return 1;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        v80 = "nw_protocol_ipv4_create_output_frame";
        v81 = 1024;
        *(_DWORD *)v82 = a3;
        v33 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v77 = 0;
        if (__nwlog_fault(v33, &type, &v77))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v34 = gLogObj;
            v35 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)buf = 136446466;
              v80 = "nw_protocol_ipv4_create_output_frame";
              v81 = 1024;
              *(_DWORD *)v82 = a3;
              v36 = "%{public}s nw_frame_create(%u) failed";
LABEL_60:
              _os_log_impl(&dword_182FBE000, v34, v35, v36, buf, 0x12u);
            }
          }
          else if (v77)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v34 = gLogObj;
            v35 = type;
            v38 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (backtrace_string)
            {
              if (v38)
              {
                *(_DWORD *)buf = 136446722;
                v80 = "nw_protocol_ipv4_create_output_frame";
                v81 = 1024;
                *(_DWORD *)v82 = a3;
                *(_WORD *)&v82[4] = 2082;
                *(_QWORD *)&v82[6] = backtrace_string;
                _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s nw_frame_create(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(backtrace_string);
              goto LABEL_61;
            }
            if (v38)
            {
              *(_DWORD *)buf = 136446466;
              v80 = "nw_protocol_ipv4_create_output_frame";
              v81 = 1024;
              *(_DWORD *)v82 = a3;
              v36 = "%{public}s nw_frame_create(%u) failed, no backtrace";
              goto LABEL_60;
            }
          }
          else
          {
            v34 = __nwlog_obj();
            v35 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446466;
              v80 = "nw_protocol_ipv4_create_output_frame";
              v81 = 1024;
              *(_DWORD *)v82 = a3;
              v36 = "%{public}s nw_frame_create(%u) failed, backtrace limit exceeded";
              goto LABEL_60;
            }
          }
        }
LABEL_61:
        if (v33)
          free(v33);
        if (v9)
          free((void *)v9);
        goto LABEL_65;
      }
      if (a3 >= 0xFFFFFFEC)
        v13 = 0xFFFFFFFFLL;
      else
        v13 = a3 + 20;
      if (a4 >= 0xFFFFFFEC)
        v14 = 0xFFFFFFFFLL;
      else
        v14 = a4 + 20;
      output_handler = a1->output_handler;
      if (output_handler)
      {
        handle = output_handler->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
        v18 = a1[1].callbacks;
        if (v18)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
        if (a6)
        {
          v19 = output_handler->callbacks;
          if (v19)
          {
            get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t))v19->get_output_frames;
            if (get_output_frames)
            {
              v21 = get_output_frames(output_handler, a1, v13, v14);
              goto LABEL_24;
            }
          }
          __nwlog_obj();
          name = output_handler->identifier->name;
          *(_DWORD *)buf = 136446722;
          v80 = "__nw_protocol_get_output_frames";
          if (!name)
            name = "invalid";
          v81 = 2082;
          *(_QWORD *)v82 = name;
          *(_WORD *)&v82[8] = 2048;
          *(_QWORD *)&v82[10] = output_handler;
          v42 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v77 = 0;
          if (__nwlog_fault(v42, &type, &v77))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v43 = __nwlog_obj();
              v44 = type;
              if (!os_log_type_enabled(v43, type))
                goto LABEL_154;
              v45 = output_handler->identifier->name;
              if (!v45)
                v45 = "invalid";
              *(_DWORD *)buf = 136446722;
              v80 = "__nw_protocol_get_output_frames";
              v81 = 2082;
              *(_QWORD *)v82 = v45;
              *(_WORD *)&v82[8] = 2048;
              *(_QWORD *)&v82[10] = output_handler;
              v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_131:
              v70 = v43;
              v71 = v44;
              v72 = 32;
LABEL_153:
              _os_log_impl(&dword_182FBE000, v70, v71, v46, buf, v72);
              goto LABEL_154;
            }
            if (!v77)
            {
              v43 = __nwlog_obj();
              v44 = type;
              if (!os_log_type_enabled(v43, type))
                goto LABEL_154;
              v68 = output_handler->identifier->name;
              if (!v68)
                v68 = "invalid";
              *(_DWORD *)buf = 136446722;
              v80 = "__nw_protocol_get_output_frames";
              v81 = 2082;
              *(_QWORD *)v82 = v68;
              *(_WORD *)&v82[8] = 2048;
              *(_QWORD *)&v82[10] = output_handler;
              v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
              goto LABEL_131;
            }
            v57 = (char *)__nw_create_backtrace_string();
            v43 = __nwlog_obj();
            v44 = type;
            v58 = os_log_type_enabled(v43, type);
            if (!v57)
            {
              if (!v58)
                goto LABEL_154;
              v69 = output_handler->identifier->name;
              if (!v69)
                v69 = "invalid";
              *(_DWORD *)buf = 136446722;
              v80 = "__nw_protocol_get_output_frames";
              v81 = 2082;
              *(_QWORD *)v82 = v69;
              *(_WORD *)&v82[8] = 2048;
              *(_QWORD *)&v82[10] = output_handler;
              v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
              goto LABEL_131;
            }
            if (v58)
            {
              v59 = output_handler->identifier->name;
              if (!v59)
                v59 = "invalid";
              *(_DWORD *)buf = 136446978;
              v80 = "__nw_protocol_get_output_frames";
              v81 = 2082;
              *(_QWORD *)v82 = v59;
              *(_WORD *)&v82[8] = 2048;
              *(_QWORD *)&v82[10] = output_handler;
              v83 = 2082;
              v84 = v57;
              _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v57);
          }
LABEL_154:
          if (!v42)
          {
LABEL_156:
            v21 = 0;
LABEL_24:
            if (a1->handle == &nw_protocol_ref_counted_handle)
            {
              v25 = a1[1].callbacks;
              if (v25)
              {
                v26 = (nw_protocol_callbacks *)((char *)v25 - 1);
                a1[1].callbacks = v26;
                if (!v26)
                {
                  v27 = *(void (***)(_QWORD))a1[1].flow_id;
                  if (v27)
                  {
                    *(_QWORD *)a1[1].flow_id = 0;
                    v27[2](v27);
                    _Block_release(v27);
                  }
                  if ((a1[1].flow_id[8] & 1) != 0)
                  {
                    v28 = *(const void **)a1[1].flow_id;
                    if (v28)
                      _Block_release(v28);
                  }
                  free(a1);
                }
              }
            }
            if (handle == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
            {
              v29 = output_handler[1].callbacks;
              if (v29)
              {
                v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
                output_handler[1].callbacks = v30;
                if (!v30)
                {
                  v31 = *(void (***)(_QWORD))output_handler[1].flow_id;
                  if (v31)
                  {
                    *(_QWORD *)output_handler[1].flow_id = 0;
                    v31[2](v31);
                    _Block_release(v31);
                  }
                  if ((output_handler[1].flow_id[8] & 1) != 0)
                  {
                    v32 = *(const void **)output_handler[1].flow_id;
                    if (v32)
                      _Block_release(v32);
                  }
                  free(output_handler);
                }
              }
            }
LABEL_27:
            v73[0] = MEMORY[0x1E0C809B0];
            v73[1] = 0x40000000;
            v74 = ___ZL34nw_protocol_ipv4_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v75 = &__block_descriptor_tmp_28_85771;
            v76 = a1;
            tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first)
                break;
              v23 = (nw_frame *)*((_QWORD *)tqh_first + 4);
              v24 = ((uint64_t (*)(_QWORD *))v74)(v73);
              tqh_first = v23;
            }
            while ((v24 & 1) != 0);
            return v21;
          }
LABEL_155:
          free(v42);
          goto LABEL_156;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v80 = "__nw_protocol_get_output_frames";
        v42 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v77 = 0;
        if (!__nwlog_fault(v42, &type, &v77))
          goto LABEL_154;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v55 = __nwlog_obj();
          v56 = type;
          if (!os_log_type_enabled(v55, type))
            goto LABEL_154;
          *(_DWORD *)buf = 136446210;
          v80 = "__nw_protocol_get_output_frames";
          v46 = "%{public}s called with null return_array";
        }
        else if (v77)
        {
          v66 = (char *)__nw_create_backtrace_string();
          v55 = __nwlog_obj();
          v56 = type;
          v67 = os_log_type_enabled(v55, type);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446466;
              v80 = "__nw_protocol_get_output_frames";
              v81 = 2082;
              *(_QWORD *)v82 = v66;
              _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null return_array, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v66);
            if (!v42)
              goto LABEL_156;
            goto LABEL_155;
          }
          if (!v67)
            goto LABEL_154;
          *(_DWORD *)buf = 136446210;
          v80 = "__nw_protocol_get_output_frames";
          v46 = "%{public}s called with null return_array, no backtrace";
        }
        else
        {
          v55 = __nwlog_obj();
          v56 = type;
          if (!os_log_type_enabled(v55, type))
            goto LABEL_154;
          *(_DWORD *)buf = 136446210;
          v80 = "__nw_protocol_get_output_frames";
          v46 = "%{public}s called with null return_array, backtrace limit exceeded";
        }
        v70 = v55;
        v71 = v56;
        v72 = 12;
        goto LABEL_153;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v80 = "__nw_protocol_get_output_frames";
      v51 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v51, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v52 = __nwlog_obj();
          v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            v80 = "__nw_protocol_get_output_frames";
            v54 = "%{public}s called with null protocol";
LABEL_146:
            _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0xCu);
          }
        }
        else if (v77)
        {
          v64 = (char *)__nw_create_backtrace_string();
          v52 = __nwlog_obj();
          v53 = type;
          v65 = os_log_type_enabled(v52, type);
          if (v64)
          {
            if (v65)
            {
              *(_DWORD *)buf = 136446466;
              v80 = "__nw_protocol_get_output_frames";
              v81 = 2082;
              *(_QWORD *)v82 = v64;
              _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v64);
            goto LABEL_147;
          }
          if (v65)
          {
            *(_DWORD *)buf = 136446210;
            v80 = "__nw_protocol_get_output_frames";
            v54 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_146;
          }
        }
        else
        {
          v52 = __nwlog_obj();
          v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            v80 = "__nw_protocol_get_output_frames";
            v54 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_146;
          }
        }
      }
LABEL_147:
      if (v51)
        free(v51);
      v21 = 0;
      goto LABEL_27;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_protocol_ipv4_get_output_frames";
    v47 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v47, &type, &v77))
      goto LABEL_141;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null ipv4";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (!v77)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    v60 = (char *)__nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = type;
    v63 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "nw_protocol_ipv4_get_output_frames";
      v81 = 2082;
      *(_QWORD *)v82 = v60;
      v62 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_106;
    }
    goto LABEL_107;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v80 = "nw_protocol_ipv4_get_output_frames";
  v47 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v77 = 0;
  if (!__nwlog_fault(v47, &type, &v77))
    goto LABEL_141;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v77)
    {
      v48 = __nwlog_obj();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    v60 = (char *)__nw_create_backtrace_string();
    v48 = __nwlog_obj();
    v49 = type;
    v61 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "nw_protocol_ipv4_get_output_frames";
        v50 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "nw_protocol_ipv4_get_output_frames";
      v81 = 2082;
      *(_QWORD *)v82 = v60;
      v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_106:
      _os_log_impl(&dword_182FBE000, v48, v49, v62, buf, 0x16u);
    }
LABEL_107:
    free(v60);
    goto LABEL_141;
  }
  v48 = __nwlog_obj();
  v49 = type;
  if (os_log_type_enabled(v48, type))
  {
    *(_DWORD *)buf = 136446210;
    v80 = "nw_protocol_ipv4_get_output_frames";
    v50 = "%{public}s called with null protocol";
LABEL_140:
    _os_log_impl(&dword_182FBE000, v48, v49, v50, buf, 0xCu);
  }
LABEL_141:
  if (v47)
    free(v47);
  return 0;
}

uint64_t nw_channel_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  char *handle;
  int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t next_slot;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v47;
  uint64_t next_buflet;
  uint64_t v49;
  uint64_t v50;
  unsigned int data_offset;
  uint64_t object_address;
  int data_limit;
  _QWORD *v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t *v58;
  nw_frame **tqh_last;
  char *v60;
  _BOOL4 v61;
  NSObject *v62;
  NSObject *v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  const char *v67;
  NSObject *v68;
  os_log_type_t v69;
  uint32_t v70;
  char *v72;
  _BOOL4 v73;
  int v74;
  int v75;
  unsigned int v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  unsigned int v82;
  NSObject *v83;
  os_log_type_t v84;
  char *v85;
  NSObject *v86;
  os_log_type_t v87;
  const char *v88;
  char *backtrace_string;
  _BOOL4 v90;
  const char *v91;
  _BOOL4 v92;
  char *v93;
  _BOOL4 v94;
  char *v95;
  NSObject *v96;
  _BOOL4 v97;
  NSObject *v98;
  unint64_t StatusReg;
  char v100;
  unsigned int v101;
  _WORD *v102;
  char v103;
  os_log_type_t v104;
  uint64_t packet;
  os_log_type_t type[4];
  const char *v107;
  __int16 v108;
  _QWORD v109[2];
  uint8_t buf[32];
  __int128 v111;
  __int128 v112;
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(packet) = 0;
    if (!__nwlog_fault(v24, type, &packet))
      goto LABEL_113;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_113;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
      v27 = "%{public}s called with null channel_protocol";
      goto LABEL_189;
    }
    if ((_BYTE)packet)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v83 = __nwlog_obj();
      v84 = type[0];
      v90 = os_log_type_enabled(v83, type[0]);
      if (backtrace_string)
      {
        if (v90)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          v91 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_168:
          _os_log_impl(&dword_182FBE000, v83, v84, v91, buf, 0x16u);
        }
LABEL_169:
        free(backtrace_string);
        goto LABEL_113;
      }
      if (!v90)
        goto LABEL_113;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
      v27 = "%{public}s called with null channel_protocol, no backtrace";
    }
    else
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_113;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
      v27 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
    }
LABEL_189:
    v68 = v83;
    v69 = v84;
    v70 = 12;
    goto LABEL_112;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(packet) = 0;
    if (!__nwlog_fault(v24, type, &packet))
      goto LABEL_113;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_113;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
      v27 = "%{public}s called with null channel";
      goto LABEL_189;
    }
    if ((_BYTE)packet)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v83 = __nwlog_obj();
      v84 = type[0];
      v92 = os_log_type_enabled(v83, type[0]);
      if (backtrace_string)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          v91 = "%{public}s called with null channel, dumping backtrace:%{public}s";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v92)
        goto LABEL_113;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
      v27 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      v83 = __nwlog_obj();
      v84 = type[0];
      if (!os_log_type_enabled(v83, type[0]))
        goto LABEL_113;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
      v27 = "%{public}s called with null channel, backtrace limit exceeded";
    }
    goto LABEL_189;
  }
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  if (!*((_QWORD *)handle + 17) || !*((_QWORD *)handle + 27))
    return 0;
  v102 = handle + 444;
  v11 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
  *((_WORD *)handle + 222) = *((_WORD *)handle + 222);
  handle[446] = (v11 & 0xFFF9FFFF | 0x20000) >> 16;
  if ((v11 & 2) == 0 && *((_QWORD *)handle + 22))
  {
    v12 = v11 & 0xFFF9FFFD | 0x20002;
    *v102 = v12;
    handle[446] = BYTE2(v12);
    v13 = os_channel_available_slot_count();
    if (*((_DWORD *)handle + 105) - 1 >= v13)
      v15 = 0;
    else
      v15 = *((_DWORD *)handle + 105);
    v16 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
    if (v13 == v15)
    {
      if ((*((_WORD *)handle + 222) & 0x10) != 0)
      {
        v17 = *((_WORD *)handle + 222) & 0xFFEF | (handle[446] << 16);
        *v102 = *((_WORD *)handle + 222) & 0xFFEF;
        handle[446] = BYTE2(v17);
        nw_queue_resume_source(*((_QWORD *)handle + 22), v14);
      }
    }
    else if ((*((_WORD *)handle + 222) & 0x10) == 0)
    {
      handle[446] = BYTE2(v16);
      *v102 = v16 | 0x10;
      nw_queue_suspend_source(*((_QWORD *)handle + 22));
    }
    v18 = (unsigned __int16)*v102;
    v19 = v18 & 0xFFFFFFFD | (handle[446] << 16);
    *v102 = v18 & 0xFFFD;
    handle[446] = BYTE2(v19);
  }
  v20 = *((_DWORD *)handle + 109);
  v21 = *((_DWORD *)handle + 110);
  if (!v21)
    goto LABEL_28;
  v22 = 0xFFFFFFFF / v20;
  if (0xFFFFFFFF / v20 >= a5)
    v22 = a5;
  if (v22 * v20 < a3)
  {
    if (0xFFFFFFFF / v21 >= a5)
      v23 = a5;
    else
      v23 = 0xFFFFFFFF / v21;
    if (v23 * v21 < a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v21;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v23;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v23 * v21;
      *(_WORD *)&buf[30] = 1024;
      LODWORD(v111) = a3;
      v24 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(packet) = 0;
      if (!__nwlog_fault(v24, type, &packet))
        goto LABEL_113;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = gLogObj;
        v26 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_113;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v21;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v23;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v23 * v21;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v111) = a3;
        v27 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u)";
        goto LABEL_111;
      }
      if (!(_BYTE)packet)
      {
        v25 = __nwlog_obj();
        v26 = type[0];
        if (!os_log_type_enabled(v25, type[0]))
          goto LABEL_113;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v21;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v23;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v23 * v21;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v111) = a3;
        v27 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), backtrace limit exceeded";
        goto LABEL_111;
      }
      v60 = (char *)__nw_create_backtrace_string();
      v25 = __nwlog_obj();
      v26 = type[0];
      v61 = os_log_type_enabled(v25, type[0]);
      if (v60)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v21;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v23;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v23 * v21;
          *(_WORD *)&buf[30] = 1024;
          LODWORD(v111) = a3;
          WORD2(v111) = 2082;
          *(_QWORD *)((char *)&v111 + 6) = v60;
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), dumping backtrace:%{public}s", buf, 0x2Eu);
        }
        free(v60);
        goto LABEL_113;
      }
      if (v61)
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v21;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v23;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v23 * v21;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v111) = a3;
        v27 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), no backtrace";
LABEL_111:
        v68 = v25;
        v69 = v26;
        v70 = 36;
LABEL_112:
        _os_log_impl(&dword_182FBE000, v68, v69, v27, buf, v70);
      }
LABEL_113:
      if (v24)
        free(v24);
      return 0;
    }
    v100 = 1;
    v20 = *((_DWORD *)handle + 110);
  }
  else
  {
LABEL_28:
    v100 = 0;
  }
  v28 = os_channel_available_slot_count();
  v29 = *((_DWORD *)handle + 105);
  if (v29 - 1 >= v28)
    v29 = 0;
  v30 = v28 - v29;
  if (v30 >= a5)
    v30 = a5;
  if (0xFFFFFFFF / v20 < v30)
    v30 = 0xFFFFFFFF / v20;
  v31 = v30 * v20;
  v32 = a4 / v20;
  if (a4 % v20)
    v33 = v32 + 1;
  else
    v33 = a4 / v20;
  if (v31 > a4)
  {
    v31 = v33 * v20;
    v30 = v33;
  }
  v101 = v30;
  if (v31 < a3)
  {
    v34 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
    if ((v34 & 0x10000) == 0 || !*((_QWORD *)handle + 17))
      return 0;
    v35 = v34 & 0xFFFEFFFF;
    *v102 = v35;
    handle[446] = BYTE2(v35);
    if (_nw_signposts_once != -1)
      dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
    if (_nw_signposts_enabled && kdebug_is_enabled())
      kdebug_trace();
    if (os_channel_sync() && (nw_channel_check_defunct((uint64_t)handle) & 1) != 0)
      return 0;
    v36 = os_channel_available_slot_count();
    v37 = *((_DWORD *)handle + 105);
    if (v37 - 1 >= v36)
      v37 = 0;
    v38 = v36 - v37;
    if (v38 >= a5)
      v38 = a5;
    if (0xFFFFFFFF / v20 < v38)
      v38 = 0xFFFFFFFF / v20;
    v39 = v38 * v20;
    if (v32 * v20 == a4)
      v40 = a4 / v20;
    else
      v40 = v32 + 1;
    if (v39 > a4)
    {
      v39 = v40 * v20;
      v38 = v40;
    }
    v101 = v38;
    if (v39 < a3)
      return 0;
  }
  v111 = 0u;
  v112 = 0u;
  memset(buf, 0, sizeof(buf));
  if (!*((_QWORD *)handle + 17))
    return 0;
  v41 = *((_QWORD *)handle + 36);
  next_slot = os_channel_get_next_slot();
  v43 = 0;
  if (!next_slot || !v101)
    goto LABEL_131;
  v44 = 0;
  v43 = 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    v45 = next_slot;
    packet = 0;
    if (!v41)
    {
      nw_channel_allocate_frames(handle);
      v41 = *((_QWORD *)handle + 36);
      if (!v41)
        goto LABEL_129;
    }
    if ((*v102 & 0x1000) != 0)
    {
      if (!*((_QWORD *)handle + 17))
        goto LABEL_77;
      if (!((v100 & 1) != 0 ? os_channel_large_packet_alloc() : os_channel_packet_alloc()))
        goto LABEL_77;
      v47 = **(_DWORD **)(StatusReg + 8);
      if ((nw_channel_check_defunct((uint64_t)handle) & 1) != 0)
        goto LABEL_129;
LABEL_100:
      v62 = __nwlog_obj();
      v63 = v62;
      if (v47 == 35)
      {
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)type = 136446466;
          v107 = "nw_channel_get_output_frames";
          v108 = 1024;
          LODWORD(v109[0]) = 35;
          _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_ERROR, "%{public}s failed to get packet from channel %{darwin.errno}d", (uint8_t *)type, 0x12u);
        }
        goto LABEL_129;
      }
      *(_DWORD *)type = 136446466;
      v107 = "nw_channel_get_output_frames";
      v108 = 1024;
      LODWORD(v109[0]) = v47;
      v64 = (char *)_os_log_send_and_compose_impl();
      v104 = OS_LOG_TYPE_ERROR;
      v103 = 0;
      if (__nwlog_fault(v64, &v104, &v103))
      {
        if (v104 == OS_LOG_TYPE_FAULT)
        {
          v65 = __nwlog_obj();
          v66 = v104;
          if (!os_log_type_enabled(v65, v104))
            goto LABEL_127;
          *(_DWORD *)type = 136446466;
          v107 = "nw_channel_get_output_frames";
          v108 = 1024;
          LODWORD(v109[0]) = v47;
          v67 = "%{public}s failed to get packet from channel %{darwin.errno}d";
          goto LABEL_126;
        }
        if (!v103)
        {
          v65 = __nwlog_obj();
          v66 = v104;
          if (!os_log_type_enabled(v65, v104))
            goto LABEL_127;
          *(_DWORD *)type = 136446466;
          v107 = "nw_channel_get_output_frames";
          v108 = 1024;
          LODWORD(v109[0]) = v47;
          v67 = "%{public}s failed to get packet from channel %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_126;
        }
        v72 = (char *)__nw_create_backtrace_string();
        v65 = __nwlog_obj();
        v66 = v104;
        v73 = os_log_type_enabled(v65, v104);
        if (v72)
        {
          if (v73)
          {
            *(_DWORD *)type = 136446722;
            v107 = "nw_channel_get_output_frames";
            v108 = 1024;
            LODWORD(v109[0]) = v47;
            WORD2(v109[0]) = 2082;
            *(_QWORD *)((char *)v109 + 6) = v72;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s failed to get packet from channel %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)type, 0x1Cu);
          }
          free(v72);
          goto LABEL_127;
        }
        if (v73)
        {
          *(_DWORD *)type = 136446466;
          v107 = "nw_channel_get_output_frames";
          v108 = 1024;
          LODWORD(v109[0]) = v47;
          v67 = "%{public}s failed to get packet from channel %{darwin.errno}d, no backtrace";
LABEL_126:
          _os_log_impl(&dword_182FBE000, v65, v66, v67, (uint8_t *)type, 0x12u);
        }
      }
LABEL_127:
      if (v64)
        free(v64);
      goto LABEL_129;
    }
    if (!*((_QWORD *)handle + 27))
      goto LABEL_77;
    packet = os_channel_slot_get_packet();
    if (!packet)
    {
      if ((nw_channel_check_defunct((uint64_t)handle) & 1) != 0)
        goto LABEL_129;
LABEL_77:
      v47 = 0;
      goto LABEL_100;
    }
    next_buflet = os_packet_get_next_buflet();
    if (!next_buflet)
      break;
    v49 = next_buflet;
    v50 = v44;
    data_offset = os_buflet_get_data_offset();
    object_address = os_buflet_get_object_address();
    data_limit = os_buflet_get_data_limit();
    if (!data_limit)
    {
      v44 = v50;
      if ((nw_channel_check_defunct((uint64_t)handle) & 1) != 0)
        goto LABEL_129;
      __nwlog_obj();
      *(_DWORD *)type = 136446210;
      v107 = "nw_channel_get_output_frames";
      v85 = (char *)_os_log_send_and_compose_impl();
      v104 = OS_LOG_TYPE_ERROR;
      v103 = 0;
      if (!__nwlog_fault(v85, &v104, &v103))
        goto LABEL_198;
      if (v104 == OS_LOG_TYPE_FAULT)
      {
        v86 = __nwlog_obj();
        v87 = v104;
        if (!os_log_type_enabled(v86, v104))
          goto LABEL_198;
        *(_DWORD *)type = 136446210;
        v107 = "nw_channel_get_output_frames";
        v88 = "%{public}s invalid buflet size";
      }
      else
      {
        if (v103)
        {
          v95 = (char *)__nw_create_backtrace_string();
          v96 = __nwlog_obj();
          v87 = v104;
          v97 = os_log_type_enabled(v96, v104);
          if (v95)
          {
            if (v97)
            {
              *(_DWORD *)type = 136446466;
              v107 = "nw_channel_get_output_frames";
              v108 = 2082;
              v109[0] = v95;
              _os_log_impl(&dword_182FBE000, v96, v87, "%{public}s invalid buflet size, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
            }
            free(v95);
            v44 = v50;
            if (v85)
              goto LABEL_199;
            goto LABEL_200;
          }
          v44 = v50;
          if (!v97)
            goto LABEL_198;
          *(_DWORD *)type = 136446210;
          v107 = "nw_channel_get_output_frames";
          v88 = "%{public}s invalid buflet size, no backtrace";
          v98 = v96;
LABEL_197:
          _os_log_impl(&dword_182FBE000, v98, v87, v88, (uint8_t *)type, 0xCu);
          goto LABEL_198;
        }
        v86 = __nwlog_obj();
        v87 = v104;
        if (!os_log_type_enabled(v86, v104))
          goto LABEL_198;
        *(_DWORD *)type = 136446210;
        v107 = "nw_channel_get_output_frames";
        v88 = "%{public}s invalid buflet size, backtrace limit exceeded";
      }
LABEL_196:
      v98 = v86;
      goto LABEL_197;
    }
    nw_frame_reset(v41, object_address + data_offset, data_limit, (uint64_t)nw_channel_finalize_output_frame, (uint64_t)handle);
    os_packet_set_flow_uuid();
    if ((*(_WORD *)(v41 + 204) & 4) != 0)
    {
      *(_QWORD *)(v41 + 208) = packet;
      *(_QWORD *)(v41 + 216) = v49;
      *(_QWORD *)(v41 + 224) = v45;
      *(_BYTE *)(v41 + 232) = *(_BYTE *)(v41 + 232) & 0xFE | ((*v102 & 0x400) != 0);
    }
    v55 = *(_QWORD *)(v41 + 16);
    v56 = *(_QWORD **)(v41 + 24);
    v54 = (_QWORD *)(v41 + 16);
    if (*(_OWORD *)(v41 + 16) == 0)
    {
      v56 = 0;
      v57 = 0;
    }
    else
    {
      v57 = *(_QWORD *)(v41 + 16);
    }
    if (v55)
    {
      *(_QWORD *)(v55 + 24) = v56;
      v56 = *(_QWORD **)(v41 + 24);
    }
    else
    {
      *((_QWORD *)handle + 37) = v56;
    }
    *v56 = v55;
    *v54 = 0;
    *(_QWORD *)(v41 + 24) = 0;
    v58 = (uint64_t *)*((_QWORD *)handle + 39);
    *(_QWORD *)(v41 + 24) = v58;
    *v58 = v41;
    *((_QWORD *)handle + 39) = v54;
    ++*((_DWORD *)handle + 105);
    *(_QWORD *)(v41 + 32) = 0;
    tqh_last = a6->tqh_last;
    *(_QWORD *)(v41 + 40) = tqh_last;
    *tqh_last = (nw_frame *)v41;
    a6->tqh_last = (nw_frame **)(v41 + 32);
    v43 = (v43 + 1);
    next_slot = os_channel_get_next_slot();
    if (next_slot)
    {
      v41 = v57;
      v44 = v45;
      if (v43 < v101)
        continue;
    }
    goto LABEL_130;
  }
  if ((nw_channel_check_defunct((uint64_t)handle) & 1) != 0)
    goto LABEL_129;
  __nwlog_obj();
  *(_DWORD *)type = 136446210;
  v107 = "nw_channel_get_output_frames";
  v85 = (char *)_os_log_send_and_compose_impl();
  v104 = OS_LOG_TYPE_ERROR;
  v103 = 0;
  if (!__nwlog_fault(v85, &v104, &v103))
    goto LABEL_198;
  if (v104 != OS_LOG_TYPE_FAULT)
  {
    if (v103)
    {
      v93 = (char *)__nw_create_backtrace_string();
      v86 = __nwlog_obj();
      v87 = v104;
      v94 = os_log_type_enabled(v86, v104);
      if (v93)
      {
        if (v94)
        {
          *(_DWORD *)type = 136446466;
          v107 = "nw_channel_get_output_frames";
          v108 = 2082;
          v109[0] = v93;
          _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s failed to get buflet from packet, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
        }
        free(v93);
        goto LABEL_198;
      }
      if (!v94)
        goto LABEL_198;
      *(_DWORD *)type = 136446210;
      v107 = "nw_channel_get_output_frames";
      v88 = "%{public}s failed to get buflet from packet, no backtrace";
    }
    else
    {
      v86 = __nwlog_obj();
      v87 = v104;
      if (!os_log_type_enabled(v86, v104))
        goto LABEL_198;
      *(_DWORD *)type = 136446210;
      v107 = "nw_channel_get_output_frames";
      v88 = "%{public}s failed to get buflet from packet, backtrace limit exceeded";
    }
    goto LABEL_196;
  }
  v86 = __nwlog_obj();
  v87 = v104;
  if (os_log_type_enabled(v86, v104))
  {
    *(_DWORD *)type = 136446210;
    v107 = "nw_channel_get_output_frames";
    v88 = "%{public}s failed to get buflet from packet";
    goto LABEL_196;
  }
LABEL_198:
  if (v85)
LABEL_199:
    free(v85);
LABEL_200:
  if ((*v102 & 0x1000) != 0 && *((_QWORD *)handle + 17) && os_channel_packet_free())
    nw_channel_check_defunct((uint64_t)handle);
LABEL_129:
  v45 = v44;
  if (!v44)
    goto LABEL_131;
LABEL_130:
  *((_QWORD *)handle + 51) = v45;
LABEL_131:
  v74 = (unsigned __int16)*v102;
  v75 = v74 | (handle[446] << 16);
  if ((v74 & 2) == 0 && *((_QWORD *)handle + 22))
  {
    handle[446] = BYTE2(v75);
    *v102 = v75 | 2;
    v76 = os_channel_available_slot_count();
    if (*((_DWORD *)handle + 105) - 1 >= v76)
      v78 = 0;
    else
      v78 = *((_DWORD *)handle + 105);
    v79 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
    if (v76 == v78)
    {
      if ((*((_WORD *)handle + 222) & 0x10) != 0)
      {
        v80 = *((_WORD *)handle + 222) & 0xFFEF | (handle[446] << 16);
        *v102 = *((_WORD *)handle + 222) & 0xFFEF;
        handle[446] = BYTE2(v80);
        nw_queue_resume_source(*((_QWORD *)handle + 22), v77);
      }
    }
    else if ((*((_WORD *)handle + 222) & 0x10) == 0)
    {
      handle[446] = BYTE2(v79);
      *v102 = v79 | 0x10;
      nw_queue_suspend_source(*((_QWORD *)handle + 22));
    }
    v81 = (unsigned __int16)*v102;
    v82 = v81 & 0xFFFFFFFD | (handle[446] << 16);
    *v102 = v81 & 0xFFFD;
    handle[446] = BYTE2(v82);
  }
  return v43;
}

uint64_t nw_frame_create(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  objc_opt_class();
  v10 = _os_object_alloc();
  v11 = v10;
  if (v10)
  {
    if (a1)
      *(_WORD *)(v10 + 204) |= 4u;
    nw_frame_reset(v10, a2, a3, a4, a5);
    return v11;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_frame_create";
  v12 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_frame_create";
      v15 = "%{public}s nw_frame_obj_alloc failed";
      goto LABEL_18;
    }
    if (!v19)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_frame_create";
      v15 = "%{public}s nw_frame_obj_alloc failed, backtrace limit exceeded";
      goto LABEL_18;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    v14 = type;
    v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_frame_create";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s nw_frame_obj_alloc failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_19;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_frame_create";
      v15 = "%{public}s nw_frame_obj_alloc failed, no backtrace";
LABEL_18:
      _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
    }
  }
LABEL_19:
  if (v12)
    free(v12);
  return v11;
}

void nw_frame_reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  int v6;
  unsigned int v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  _WORD *v16;
  __int16 v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *backtrace_string;
  _BOOL4 v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v6 = *(unsigned __int16 *)(a1 + 204);
    *(_QWORD *)(a1 + 80) = a4;
    *(_QWORD *)(a1 + 88) = a5;
    *(_QWORD *)(a1 + 112) = a2;
    *(_QWORD *)(a1 + 104) = 0;
    *(_WORD *)(a1 + 196) = 0;
    *(_DWORD *)(a1 + 48) = a3;
    *(_DWORD *)(a1 + 52) = a3;
    *(_QWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 192) = 0;
    *(_BYTE *)(a1 + 200) = 0;
    v7 = v6 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
    *(_WORD *)(a1 + 204) = v7;
    *(_BYTE *)(a1 + 206) = BYTE2(v7);
    v9 = a1 + 64;
    v8 = *(_QWORD **)(a1 + 64);
    if (v8)
    {
      v10 = (_QWORD *)(a1 + 120);
      do
      {
        v11 = (_QWORD *)*v8;
        v12 = (void *)v8[6];
        v13 = (_QWORD *)*v8;
        if (v12)
        {
          os_release(v12);
          v8[6] = 0;
          v13 = (_QWORD *)*v8;
        }
        v14 = (_QWORD *)v8[1];
        if (v13)
        {
          v13[1] = v14;
          v14 = (_QWORD *)v8[1];
        }
        else
        {
          *(_QWORD *)(a1 + 72) = v14;
        }
        *v14 = v13;
        if (v8 != v10)
          free(v8);
        v8 = v11;
      }
      while (v11);
    }
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = v9;
    v15 = *(void **)(a1 + 168);
    if (v15)
      os_release(v15);
    v17 = *(_WORD *)(a1 + 204);
    v16 = (_WORD *)(a1 + 204);
    *(_QWORD *)(v16 - 10) = 0;
    *(_OWORD *)(v16 - 18) = 0u;
    *(_OWORD *)(v16 - 26) = 0u;
    *(_OWORD *)(v16 - 34) = 0u;
    *(_OWORD *)(v16 - 42) = 0u;
    *v16 = v17 & 0x213F;
    *((_BYTE *)v16 - 1) = 0;
    *(v16 - 3) = 0;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v27 = "__nw_frame_reset";
  v18 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v18, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_30;
      *(_DWORD *)buf = 136446210;
      v27 = "__nw_frame_reset";
      v21 = "%{public}s called with null frame";
      goto LABEL_29;
    }
    if (!v24)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_30;
      *(_DWORD *)buf = 136446210;
      v27 = "__nw_frame_reset";
      v21 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v23 = os_log_type_enabled(v19, type);
    if (backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v27 = "__nw_frame_reset";
        v28 = 2082;
        v29 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_30;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "__nw_frame_reset";
      v21 = "%{public}s called with null frame, no backtrace";
LABEL_29:
      _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
    }
  }
LABEL_30:
  if (v18)
    free(v18);
}

uint64_t ___ZL34nw_protocol_ipv4_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_frame_claim(a2, a2, 20, 0);
  return 1;
}

BOOL nw_frame_claim(uint64_t a1, uint64_t a2, int a3, int a4)
{
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  unsigned int v13;
  int v14;
  NSObject *v15;
  _BOOL8 result;
  int v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  _BOOL4 v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x80) == 0)
      goto LABEL_21;
    if (!a4)
    {
LABEL_20:
      *(_WORD *)(a1 + 196) -= a3;
LABEL_21:
      v13 = *(_DWORD *)(a1 + 56) + a3;
      v14 = *(_DWORD *)(a1 + 60) + a4;
      if (v13 <= *(_DWORD *)(a1 + 52) - v14)
      {
        *(_DWORD *)(a1 + 56) = v13;
        *(_DWORD *)(a1 + 60) = v14;
        return 1;
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          v17 = *(_DWORD *)(a1 + 52);
          *(_DWORD *)buf = 136446978;
          v27 = "__nw_frame_claim_internal";
          v28 = 1024;
          LODWORD(v29) = v13;
          WORD2(v29) = 1024;
          *(_DWORD *)((char *)&v29 + 6) = v17;
          WORD5(v29) = 1024;
          HIDWORD(v29) = v14;
          _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
          return 0;
        }
      }
      return result;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v27 = "__nw_frame_claim_internal";
    v28 = 1024;
    LODWORD(v29) = a4;
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v7, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_18;
        *(_DWORD *)buf = 136446466;
        v27 = "__nw_frame_claim_internal";
        v28 = 1024;
        LODWORD(v29) = a4;
        v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate";
        goto LABEL_17;
      }
      if (!v24)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_18;
        *(_DWORD *)buf = 136446466;
        v27 = "__nw_frame_claim_internal";
        v28 = 1024;
        LODWORD(v29) = a4;
        v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          v27 = "__nw_frame_claim_internal";
          v28 = 1024;
          LODWORD(v29) = a4;
          WORD2(v29) = 2082;
          *(_QWORD *)((char *)&v29 + 6) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v27 = "__nw_frame_claim_internal";
        v28 = 1024;
        LODWORD(v29) = a4;
        v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, no backtrace";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0x12u);
      }
    }
LABEL_18:
    if (v7)
      free(v7);
    goto LABEL_20;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v27 = "__nw_frame_claim_internal";
  v18 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v18, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "__nw_frame_claim_internal";
        v21 = "%{public}s called with null frame";
LABEL_39:
        _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
      }
    }
    else if (v24)
    {
      v22 = (char *)__nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v23 = os_log_type_enabled(v19, type);
      if (v22)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "__nw_frame_claim_internal";
          v28 = 2082;
          *(_QWORD *)&v29 = v22;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v22);
        goto LABEL_40;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "__nw_frame_claim_internal";
        v21 = "%{public}s called with null frame, no backtrace";
        goto LABEL_39;
      }
    }
    else
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "__nw_frame_claim_internal";
        v21 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_39;
      }
    }
  }
LABEL_40:
  if (v18)
    free(v18);
  return 0;
}

BOOL nw_path_get_vpn_config_id(NWConcrete_nw_path *a1, unsigned __int8 (*a2)[16])
{
  return nw_path_get_vpn_config_uuid(a1, a2, 0, 1, 0);
}

void NWPath.status.getter(_BYTE *a1@<X8>)
{
  _BYTE *v1;

  *a1 = *v1;
}

uint64_t sub_182FED9C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (*v5)(uint64_t, uint64_t);

  v5 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
  swift_retain();
  swift_unknownObjectRetain();
  v5(a2, a3);
  swift_release();
  return swift_unknownObjectRelease();
}

void sub_182FEDA1C(uint64_t a1, NSObject *a2)
{
  uint64_t v2;

  sub_182FEDA28(a1, a2, *(_QWORD *)(v2 + 16), *(void (**)(int *))(v2 + 24));
}

void sub_182FEDA28(uint64_t a1, NSObject *a2, uint64_t a3, void (*a4)(int *))
{
  os_unfair_lock_s *v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  int v10;

  v7 = *(os_unfair_lock_s **)(a3 + 24);
  v8 = (uint64_t)&v7[4];
  v9 = v7 + 24;
  os_unfair_lock_lock(v7 + 24);
  sub_182FEDAE0(v8, a1, a2, (uint64_t)&v10);
  os_unfair_lock_unlock(v9);
  if (a4)
    a4(&v10);
}

uint64_t sub_182FEDAC0()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_182FEDAE0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, NSObject *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;
  unsigned int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned __int8 v12;

  swift_unknownObjectRetain();
  result = sub_182FEDBA8(a3, a2, (uint64_t)&v11);
  v9 = v11;
  v10 = v11 | ((unint64_t)v12 << 32);
  *(_BYTE *)(a1 + 76) = v12;
  *(_DWORD *)(a1 + 72) = v9;
  if (v10 >= 0x8000000003)
  {
    result = nw_utilities_minos_atleast();
    if ((_DWORD)result)
    {
      sub_1830630AC(*(_QWORD *)a1);
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      sub_1830630AC(*(_QWORD *)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      sub_1830630AC(*(_QWORD *)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      result = sub_1830630AC(*(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
  *(_DWORD *)a4 = v10;
  *(_BYTE *)(a4 + 4) = BYTE4(v10);
  return result;
}

uint64_t sub_182FEDBA8@<X0>(nw_error_t error@<X1>, uint64_t result@<X0>, uint64_t a3@<X8>)
{
  unint64_t v5;
  nw_error_domain_t error_domain;
  uint64_t v7;
  unsigned int error_code;
  unsigned int v9;
  unsigned int v10;
  unsigned __int8 v11;

  switch((int)result)
  {
    case 0:
      result = swift_unknownObjectRelease();
      v5 = 0x8000000000;
      break;
    case 1:
      if (error)
      {
        error_domain = nw_error_get_error_domain(error);
        switch(error_domain)
        {
          case nw_error_domain_tls:
            error_code = nw_error_get_error_code(error);
            result = swift_unknownObjectRelease();
            v5 = error_code | 0x200000000;
            break;
          case nw_error_domain_dns:
            v9 = nw_error_get_error_code(error);
            result = swift_unknownObjectRelease();
            v5 = v9 | 0x100000000;
            break;
          case nw_error_domain_posix:
            nw_error_get_error_code(error);
            v7 = sub_183B915E4();
            result = swift_unknownObjectRelease();
            v5 = 22;
            if ((v7 & 0x100000000) == 0)
              v5 = v7;
            break;
          default:
            result = swift_unknownObjectRelease();
            v5 = 22;
            break;
        }
      }
      else
      {
        v5 = 50;
      }
      break;
    case 2:
      result = swift_unknownObjectRelease();
      v5 = 0x8000000001;
      break;
    case 3:
      result = swift_unknownObjectRelease();
      v5 = 0x8000000002;
      break;
    case 4:
      result = (uint64_t)sub_1830840B4(error, (uint64_t)&v10);
      v5 = 0x4000000016;
      if (v11 != 255)
        v5 = v10 | ((unint64_t)v11 << 32) | 0x4000000000;
      break;
    default:
      result = swift_unknownObjectRelease();
      v5 = 0x8000000003;
      break;
  }
  *(_DWORD *)a3 = v5;
  *(_BYTE *)(a3 + 4) = BYTE4(v5);
  return result;
}

uint64_t nw_utilities_minos_atleast()
{
  return dyld_program_minos_at_least();
}

_QWORD *destroy for NWConnection.SendCompletion(_QWORD *result)
{
  if (*result >= 0xFFFFFFFFuLL)
    return (_QWORD *)swift_release();
  return result;
}

id *nw_endpoint_handler_create_inner(void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int a6, int a7)
{
  id v13;
  id v14;
  id v15;
  int v16;
  NSObject *v17;
  id v18;
  NSObject *v19;
  int v20;
  int address_family;
  int v22;
  const sockaddr *v23;
  NSObject *v24;
  NSObject *v25;
  id v26;
  id v27;
  id v28;
  void *v29;
  id *v30;
  NSObject *v31;
  id *v32;
  id *v33;
  _QWORD *v34;
  BOOL v35;
  NWConcrete_nw_endpoint_flow *v36;
  id v37;
  id v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  id v42;
  NWConcrete_nw_endpoint_flow *v43;
  id v44;
  id v45;
  id *v46;
  _QWORD *v47;
  _QWORD *v48;
  nw_endpoint_t v49;
  void *v50;
  id *v51;
  char *v52;
  os_log_type_t v53;
  _BOOL4 v54;
  os_log_type_t v55;
  void *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  void *v61;
  os_log_type_t v62;
  void *v63;
  os_log_type_t v64;
  char *backtrace_string;
  os_log_type_t v66;
  _BOOL4 v67;
  os_log_type_t v68;
  _BOOL4 v69;
  char *v70;
  os_log_type_t v71;
  _BOOL4 v72;
  void *v73;
  char *v74;
  NSObject *v75;
  os_log_type_t v76;
  os_log_type_t v77;
  os_log_type_t v78;
  os_log_type_t v79;
  char *v80;
  _BOOL4 v81;
  os_log_type_t v82;
  os_log_type_t v83;
  id v84;
  void *v85;
  id v86;
  _QWORD iterate_block[4];
  id v88;
  id *v89;
  char v90;
  os_log_type_t type;
  _BYTE address[24];
  int v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v14 = a2;
  v84 = a4;
  v85 = v13;
  v86 = a5;
  if (!v13)
  {
    __nwlog_obj();
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
    v58 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90))
      goto LABEL_113;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s called with null endpoint", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (!v90)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v77 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v77, "%{public}s called with null endpoint, backtrace limit exceeded", address, 0xCu);
      }
      goto LABEL_112;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v59 = objc_claimAutoreleasedReturnValue();
    v66 = type;
    v67 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v67)
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v66, "%{public}s called with null endpoint, no backtrace", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (v67)
    {
      *(_DWORD *)address = 136446466;
      *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
      *(_WORD *)&address[12] = 2082;
      *(_QWORD *)&address[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v59, v66, "%{public}s called with null endpoint, dumping backtrace:%{public}s", address, 0x16u);
    }
    goto LABEL_78;
  }
  if (!v14)
  {
    __nwlog_obj();
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
    v58 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90))
      goto LABEL_113;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v62 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v62, "%{public}s called with null parameters", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (!v90)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v78 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v78, "%{public}s called with null parameters, backtrace limit exceeded", address, 0xCu);
      }
      goto LABEL_112;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v59 = objc_claimAutoreleasedReturnValue();
    v68 = type;
    v69 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v69)
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v68, "%{public}s called with null parameters, no backtrace", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (v69)
    {
      *(_DWORD *)address = 136446466;
      *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
      *(_WORD *)&address[12] = 2082;
      *(_QWORD *)&address[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v59, v68, "%{public}s called with null parameters, dumping backtrace:%{public}s", address, 0x16u);
    }
LABEL_78:

    free(backtrace_string);
    if (!v58)
      goto LABEL_115;
    goto LABEL_114;
  }
  if (!a3)
  {
    __nwlog_obj();
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
    v58 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90))
      goto LABEL_113;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v64 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v64, "%{public}s called with null report_callback", address, 0xCu);
      }
    }
    else if (v90)
    {
      v70 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v71 = type;
      v72 = os_log_type_enabled(v59, type);
      if (v70)
      {
        if (v72)
        {
          *(_DWORD *)address = 136446466;
          *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
          *(_WORD *)&address[12] = 2082;
          *(_QWORD *)&address[14] = v70;
          _os_log_impl(&dword_182FBE000, v59, v71, "%{public}s called with null report_callback, dumping backtrace:%{public}s", address, 0x16u);
        }

        free(v70);
LABEL_113:
        if (!v58)
        {
LABEL_115:
          v33 = 0;
          goto LABEL_53;
        }
LABEL_114:
        free(v58);
        goto LABEL_115;
      }
      if (v72)
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v71, "%{public}s called with null report_callback, no backtrace", address, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v79 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_182FBE000, v59, v79, "%{public}s called with null report_callback, backtrace limit exceeded", address, 0xCu);
      }
    }
LABEL_112:

    goto LABEL_113;
  }
  v15 = v13;
  v16 = objc_msgSend(v15, "type");

  if (v16 == 1)
  {
    v17 = v14;
    v18 = *((id *)v17[13].isa + 20);

    if (v18)
    {
      v19 = v18;
      v20 = -[NSObject type](v19, "type");

      if (v20 == 1)
      {
        address_family = nw_endpoint_get_address_family(v15);
        v22 = nw_endpoint_get_address_family(v19);
        v23 = nw_endpoint_get_address(v19);
        if (address_family != v22)
        {
          if (v23)
          {
            if (v22 == 30)
            {
              if (!*(_DWORD *)&v23->sa_data[6]
                && !*(_DWORD *)&v23->sa_data[10]
                && !*(_DWORD *)&v23[1].sa_len
                && !*(_DWORD *)&v23[1].sa_data[2])
              {
                *(_QWORD *)&address[8] = 0;
                *(_QWORD *)address = 528;
                *(_WORD *)&address[2] = *(_WORD *)v23->sa_data;
                *(_QWORD *)&address[4] = 0;
                v25 = nw_endpoint_create_address((const sockaddr *)address);
                nw_parameters_set_local_endpoint(v17, v25);

              }
            }
            else if (v22 == 2 && !*(_DWORD *)&v23->sa_data[2])
            {
              v93 = 0;
              *(_QWORD *)&address[8] = 0;
              *(_QWORD *)&address[16] = 0;
              *(_QWORD *)address = 7708;
              *(_WORD *)&address[2] = *(_WORD *)v23->sa_data;
              v24 = nw_endpoint_create_address((const sockaddr *)address);
              nw_parameters_set_local_endpoint(v17, v24);

            }
          }
        }
      }
    }

  }
  v26 = v15;
  v27 = nw_endpoint_copy_public_keys(v26);
  if (v27)
  {
    v28 = v26;
    v29 = (void *)objc_msgSend(v28, "copyEndpoint");
    nw_endpoint_copy_properties(v28, v29);

    nw_endpoint_set_public_keys(v29, 0);
    v30 = (id *)v14;
    v31 = v30[19];

    iterate_block[0] = MEMORY[0x1E0C809B0];
    iterate_block[1] = 3221225472;
    iterate_block[2] = ___ZL32nw_endpoint_handler_create_innerPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS_PFbP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS_ESD_S5_jb_block_invoke;
    iterate_block[3] = &unk_1E14A98F8;
    v88 = v27;
    v89 = v30;
    nw_protocol_stack_iterate_application_protocols(v31, iterate_block);

    v26 = v29;
  }
  v32 = -[NWConcrete_nw_endpoint_handler initWithEndpoint:parameters:reportCallback:context:parent:identifier:]((id *)[NWConcrete_nw_endpoint_handler alloc], v26, v14, a3, v84, v86, a6);
  v33 = v32;
  if (!v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = (id)gLogObj;
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
    v39 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (__nwlog_fault(v39, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = (id)gLogObj;
        v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed", address, 0xCu);
        }
      }
      else if (v90)
      {
        v52 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = (id)gLogObj;
        v53 = type;
        v54 = os_log_type_enabled(v40, type);
        if (v52)
        {
          if (v54)
          {
            *(_DWORD *)address = 136446466;
            *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
            *(_WORD *)&address[12] = 2082;
            *(_QWORD *)&address[14] = v52;
            _os_log_impl(&dword_182FBE000, v40, v53, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", address, 0x16u);
          }

          free(v52);
          if (!v39)
            goto LABEL_52;
          goto LABEL_51;
        }
        if (v54)
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl(&dword_182FBE000, v40, v53, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, no backtrace", address, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = (id)gLogObj;
        v55 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl(&dword_182FBE000, v40, v55, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, backtrace limit exceeded", address, 0xCu);
        }
      }

    }
    if (!v39)
      goto LABEL_52;
LABEL_51:
    free(v39);
    goto LABEL_52;
  }
  if (a7)
    *((_BYTE *)v32 + 268) |= 1u;
  v34 = v14;
  v35 = (v34[12] & 0x800) == 0;

  if (v35)
  {
    if (v86 || (*((_BYTE *)v33 + 268) & 1) != 0)
    {
      *((_DWORD *)v33 + 29) = 0;
    }
    else
    {
      *((_DWORD *)v33 + 29) = 2;
      v36 = objc_alloc_init(NWConcrete_nw_endpoint_flow);
      *((_BYTE *)v36 + 32) = *((_BYTE *)v36 + 32) & 0xFC | 1;
      v37 = v33[31];
      v33[31] = v36;

    }
    goto LABEL_37;
  }
  *((_DWORD *)v33 + 29) = 2;
  v42 = v33[9];
  v43 = objc_alloc_init(NWConcrete_nw_endpoint_flow);
  *((_BYTE *)v43 + 32) = *((_BYTE *)v43 + 32) & 0xFC | (v42 == 0) | 2;
  v44 = v33[31];
  v33[31] = v43;

  v45 = v33[31];
  v46 = v33;
  v47 = v45;
  v48 = v47;
  if (!v47)
  {
    __nwlog_obj();
    v73 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
    v74 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (__nwlog_fault(v74, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v75 = objc_claimAutoreleasedReturnValue();
        v76 = type;
        if (os_log_type_enabled(v75, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s called with null endpoint_flow", address, 0xCu);
        }
      }
      else if (v90)
      {
        v80 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v75 = objc_claimAutoreleasedReturnValue();
        v83 = type;
        v81 = os_log_type_enabled(v75, type);
        if (v80)
        {
          if (v81)
          {
            *(_DWORD *)address = 136446466;
            *(_QWORD *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
            *(_WORD *)&address[12] = 2082;
            *(_QWORD *)&address[14] = v80;
            _os_log_impl(&dword_182FBE000, v75, v83, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", address, 0x16u);
          }

          free(v80);
          goto LABEL_122;
        }
        if (v81)
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl(&dword_182FBE000, v75, v83, "%{public}s called with null endpoint_flow, no backtrace", address, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v75 = objc_claimAutoreleasedReturnValue();
        v82 = type;
        if (os_log_type_enabled(v75, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl(&dword_182FBE000, v75, v82, "%{public}s called with null endpoint_flow, backtrace limit exceeded", address, 0xCu);
        }
      }

    }
LABEL_122:
    if (v74)
      free(v74);
    goto LABEL_35;
  }
  *((_BYTE *)v47 + 34) |= 2u;
  v49 = nw_endpoint_handler_copy_endpoint(v46);
  v50 = (void *)v48[121];
  v48[121] = v49;

LABEL_35:
LABEL_37:
  v51 = v33;
LABEL_52:

LABEL_53:
  return v33;
}

void sub_182FEEBD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_182FEF348(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_182FF0B14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

BOOL nw_array_create()
{
  uint64_t v0;
  uint64_t v1;
  _BOOL8 result;
  NSObject *v3;
  void *v4;

  objc_opt_class();
  v0 = _os_object_alloc();
  v1 = v0;
  if (v0)
  {
    *(_QWORD *)(v0 + 16) = 0;
    *(_QWORD *)(v0 + 24) = 0;
    *(_QWORD *)(v0 + 32) = 0;
    atomic_store(0, (unsigned __int8 *)(v0 + 40));
    return v1;
  }
  v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  v4 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return v1;
  }
  __break(1u);
  return result;
}

void nw_endpoint_copy_properties(void *a1, void *a2)
{
  char *v3;
  id *v4;
  id *v5;
  char v6;
  char *v7;
  char *v8;
  int v9;
  id v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  NSObject *v15;
  void *v16;
  NSObject *v17;
  void *v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _QWORD v23[4];
  char *v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v4)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_endpoint_copy_properties";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v12, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null copy", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        v21 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            v28 = "nw_endpoint_copy_properties";
            v29 = 2082;
            v30 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null copy, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null copy, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s called with null copy, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_28:
    if (v12)
      free(v12);
    goto LABEL_7;
  }
  *((_WORD *)v4 + 114) = *((_WORD *)v3 + 114);
  objc_storeStrong(v4 + 2, *((id *)v3 + 2));
  *((_DWORD *)v5 + 6) = *((_DWORD *)v3 + 6);
  objc_storeStrong(v5 + 23, *((id *)v3 + 23));
  objc_storeStrong(v5 + 24, *((id *)v3 + 24));
  *(_OWORD *)((char *)v5 + 28) = *(_OWORD *)(v3 + 28);
  objc_storeStrong(v5 + 1, *((id *)v3 + 1));
  v6 = v3[231] & 1 | *((_BYTE *)v5 + 231);
  *((_BYTE *)v5 + 231) = v6;
  *((_BYTE *)v5 + 231) = v3[231] & 2 | v6 & 0xFD;
  objc_storeStrong(v5 + 14, *((id *)v3 + 14));
  *((_BYTE *)v5 + 231) = *((_BYTE *)v5 + 231) & 0xDF | v3[231] & 0x20;
  objc_storeStrong(v5 + 15, *((id *)v3 + 15));
  *((_DWORD *)v5 + 56) = *((_DWORD *)v3 + 56);
  v7 = (char *)*((_QWORD *)v3 + 11);
  if (v7)
  {
    v7 = strdup(v7);
    if (!v7)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v28 = "strict_strdup";
      v16 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v16))
        goto LABEL_30;
      free(v16);
      v7 = 0;
    }
  }
  v5[11] = v7;
  v8 = (char *)*((_QWORD *)v3 + 12);
  if (!v8)
    goto LABEL_6;
  v8 = strdup(v8);
  if (v8)
    goto LABEL_6;
  __nwlog_obj();
  v17 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v28 = "strict_strdup";
  v18 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v18))
  {
    free(v18);
    v8 = 0;
LABEL_6:
    v5[12] = v8;
    v9 = *((_BYTE *)v5 + 231) & 0xBF | (((v3[231] >> 6) & 1) << 6);
    *((_BYTE *)v5 + 231) = *((_BYTE *)v5 + 231) & 0xBF | (((v3[231] & 0x40) != 0) << 6);
    *((_BYTE *)v5 + 231) = v3[231] & 0x80 | v9 & 0x7F;
    *(_OWORD *)((char *)v5 + 28) = *(_OWORD *)(v3 + 28);
    nw_endpoint_set_device_id(v5, *((const char **)v3 + 13));
    v10 = nw_endpoint_copy_public_keys(v3);
    nw_endpoint_set_public_keys(v5, v10);

    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = __nw_endpoint_copy_properties_block_invoke;
    v23[3] = &unk_1E149B268;
    v24 = v5;
    nw_endpoint_enumerate_alternatives(v3, v23);

LABEL_7:
    return;
  }
LABEL_30:
  __break(1u);
}

void sub_182FF146C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

id nw_endpoint_copy_public_keys(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  uint64_t *v15;
  char v16;
  os_log_type_t type;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  id v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  v18 = 0;
  v19 = &v18;
  v20 = 0x3032000000;
  v21 = __Block_byref_object_copy__6403;
  v22 = __Block_byref_object_dispose__6404;
  v23 = 0;
  if (v1)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_endpoint_copy_public_keys_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v15 = &v18;
    v14 = v1;
    os_unfair_lock_lock(v2 + 44);
    __nw_endpoint_copy_public_keys_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 44);
    v3 = (id)v19[5];

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_endpoint_copy_public_keys";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_endpoint_copy_public_keys";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:
  _Block_object_dispose(&v18, 8);

  return v3;
}

void __nw_endpoint_copy_public_keys_block_invoke(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(id *)(*(_QWORD *)(a1 + 32) + 48));
}

void nw_endpoint_enumerate_alternatives(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  _QWORD v20[4];
  _QWORD *v21;
  id v22;
  char v23;
  os_log_type_t v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_endpoint_enumerate_alternatives";
    v7 = (char *)_os_log_send_and_compose_impl();

    v24 = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &v24, &v23))
      goto LABEL_39;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v24;
      v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_endpoint_enumerate_alternatives";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7)
          goto LABEL_5;
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v4)
  {
    if (v3[20])
    {
      v20[0] = MEMORY[0x1E0C809B0];
      v20[1] = 3221225472;
      v20[2] = __nw_endpoint_enumerate_alternatives_block_invoke;
      v20[3] = &unk_1E14ACE18;
      v21 = v3;
      v22 = v5;
      nw_endpoint_locked(v21, v20);

    }
    goto LABEL_5;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_endpoint_enumerate_alternatives";
  v7 = (char *)_os_log_send_and_compose_impl();

  v24 = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v7, &v24, &v23))
    goto LABEL_39;
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v23)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = v24;
  v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_endpoint_enumerate_alternatives";
    v27 = 2082;
    v28 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_40;
LABEL_5:

}

void sub_182FF1D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void nw_endpoint_set_device_id(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  NSObject *v11;
  void *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_endpoint_set_device_id";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_endpoint_set_device_id";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v8)
      free(v8);
    goto LABEL_7;
  }
  v5 = (void *)v3[13];
  if (v5)
  {
    free(v5);
    v4[13] = 0;
  }
  if (!a2)
    goto LABEL_7;
  v6 = strdup(a2);
  if (v6)
  {
LABEL_6:
    v4[13] = v6;
LABEL_7:

    return;
  }
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    goto LABEL_6;
  }
  __break(1u);
}

void nw_endpoint_set_public_keys(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  unint64_t accumulated_size;
  NSObject *v11;
  id v12;
  os_log_type_t v13;
  os_unfair_lock_s *v14;
  id v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  void *v23;
  os_log_type_t v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  _QWORD v29[6];
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  unint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if ((unint64_t)objc_msgSend(v4, "count") > 0x10)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v33 = "nw_endpoint_set_public_keys";
      v7 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v30 = 0;
      if (!__nwlog_fault(v7, &type, &v30))
        goto LABEL_40;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s Setting too many keys", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v30)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v21, "%{public}s Setting too many keys, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v17 = type;
      v18 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s Setting too many keys, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v33 = "nw_endpoint_set_public_keys";
        v34 = 2082;
        v35 = (unint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s Setting too many keys, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
      if (!v7)
        goto LABEL_42;
      goto LABEL_41;
    }
    accumulated_size = nw_endpoint_get_accumulated_size(v5);
    if (accumulated_size < 0x1389)
    {
      v29[0] = MEMORY[0x1E0C809B0];
      v29[1] = 3221225472;
      v29[2] = __nw_endpoint_set_public_keys_block_invoke;
      v29[3] = &unk_1E14ACE68;
      v14 = v3;
      v29[4] = v14;
      v15 = v5;
      v29[5] = v15;
      os_unfair_lock_lock(v3 + 44);
      __nw_endpoint_set_public_keys_block_invoke((uint64_t)v29);
      os_unfair_lock_unlock(v3 + 44);

      goto LABEL_42;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_endpoint_set_public_keys";
      v34 = 2048;
      v35 = accumulated_size;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s Accumulated key-size %zu", buf, 0x16u);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v33 = "nw_endpoint_set_public_keys";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v7, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s Accumulated key-size too large", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v30)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v22, "%{public}s Accumulated key-size too large, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v19 = type;
      v20 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s Accumulated key-size too large, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v33 = "nw_endpoint_set_public_keys";
        v34 = 2082;
        v35 = (unint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s Accumulated key-size too large, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
  }
  else
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_endpoint_set_public_keys";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v7, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v24, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v30)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v28, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      v27 = os_log_type_enabled(v8, type);
      if (!v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_182FBE000, v8, v26, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        v33 = "nw_endpoint_set_public_keys";
        v34 = 2082;
        v35 = (unint64_t)v25;
        _os_log_impl(&dword_182FBE000, v8, v26, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v25);
    }
  }
LABEL_40:
  if (v7)
LABEL_41:
    free(v7);
LABEL_42:

}

void sub_182FF28C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void __nw_endpoint_set_public_keys_block_invoke(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 48), *(id *)(a1 + 40));
}

void nw_resolver_config_set_provider_description(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  os_unfair_lock_s *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[6];
  char v15;
  os_log_type_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_provider_description_block_invoke;
    v14[3] = &unk_1E14AA348;
    v5 = (os_unfair_lock_s *)v3;
    v14[4] = v5;
    v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_provider_description_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_resolver_config_set_provider_description";
  v7 = (char *)_os_log_send_and_compose_impl();

  v16 = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v16;
      v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_resolver_config_set_provider_description";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_182FF2BC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_provider_description_block_invoke(uint64_t a1)
{
  xpc_dictionary_set_string(*(xpc_object_t *)(*(_QWORD *)(a1 + 32) + 8), "ProviderDescription", *(const char **)(a1 + 40));
}

uint64_t sub_182FF2BF8(unsigned __int8 *a1)
{
  return *a1;
}

uint64_t __nw_path_enumerate_resolve_options_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  _DWORD *data;
  uint64_t v7;
  int v8;
  size_t length;

  v4 = a3;
  v5 = v4;
  length = 0;
  if (v4)
  {
    data = xpc_dictionary_get_data(v4, "data", &length);
    if (data)
    {
      if (length >= 0xD8)
      {
        v7 = data[53];
        if (length == v7 + 216 && (data[52] & 0x10000) != 0 && v7 >= 0xCC)
        {
          v8 = *(_DWORD *)(a1 + 40);
          if ((data[72] == v8
             || data[74] == v8
             || data[76] == v8
             || data[78] == v8
             || data[80] == v8
             || data[82] == v8
             || data[84] == v8
             || data[86] == v8)
            && (data[52] & 0x13) != 1)
          {
            (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
          }
        }
      }
    }
  }

  return 1;
}

void sub_182FF2EF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_ipv4_process_input_frame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint32x4_t *v15;
  unsigned int v16;
  __int32 v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  int v26;
  uint64_t v27;
  __int8 v28;
  int v29;
  _QWORD *v30;
  char v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  const char *v38;
  const char *v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  char *v43;
  _BOOL4 v44;
  int v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  uint64_t *v54;
  uint64_t v55;
  _BOOL8 result;
  __int32 v57;
  int v58;
  int v59;
  int v60;
  const char *v61;
  NSObject *v62;
  uint32_t v63;
  uint64_t v64;
  int v65;
  char *v66;
  _BOOL4 v67;
  char *v68;
  NSObject *v69;
  __int16 v70;
  unsigned int v71;
  unsigned __int16 *v72;
  unsigned int v73;
  NSObject *v74;
  unint64_t v75;
  unint64_t v76;
  int v77;
  uint64_t v78;
  int v79;
  uint16x8_t *v80;
  int32x4_t v81;
  uint64_t v82;
  int32x4_t v83;
  int32x4_t v84;
  int32x4_t v85;
  uint16x8_t v86;
  int v87;
  uint64_t v88;
  const char *v89;
  NSObject *v90;
  os_log_type_t v91;
  const char *v92;
  NSObject *v93;
  NSObject *v94;
  uint64_t v95;
  NSObject *v96;
  int v97;
  uint64_t v98;
  NSObject *v99;
  const char *v100;
  NSObject *v101;
  uint32_t v102;
  NSObject *v103;
  NSObject *v104;
  __int32 v105;
  int v106;
  NSObject *v107;
  uint64_t v108;
  _BOOL4 v109;
  uint64_t v110;
  char *backtrace_string;
  _BOOL4 v112;
  const char *v113;
  _BOOL4 v114;
  _BOOL4 v115;
  _BOOL4 v116;
  NSObject *v117;
  unsigned int v118;
  int v119;
  uint64_t v120;
  NSObject *v121;
  unsigned int v122;
  unsigned int v123;
  uint64_t v124;
  __int32 *v125;
  unsigned int v126;
  uint64_t v127;
  int v128;
  uint32x4_t *v129;
  int64x2_t v130;
  uint64_t v131;
  int64x2_t v132;
  int64x2_t v133;
  int64x2_t v134;
  uint32x4_t v135;
  unsigned int v136;
  NSObject *log;
  NSObject *loga;
  os_log_type_t type[2];
  _QWORD v140[2];
  uint64_t (*v141)(uint64_t, uint64_t);
  void *v142;
  _BYTE *v143;
  uint64_t v144;
  uint64_t v145;
  __int16 v146;
  char v147;
  _BYTE buf[24];
  const char *v149;
  __int16 v150;
  uint64_t v151;
  __int16 v152;
  unsigned int v153;
  __int16 v154;
  _BYTE v155[10];
  __int16 v156;
  int v157;
  uint64_t v158;

  v158 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v147 = 0;
    if (!__nwlog_fault(v89, type, &v147))
      goto LABEL_252;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v147)
      {
        v90 = __nwlog_obj();
        v91 = type[0];
        if (os_log_type_enabled(v90, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
          v92 = "%{public}s called with null ipv4, backtrace limit exceeded";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v90 = __nwlog_obj();
      v91 = type[0];
      v112 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (v112)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
          v92 = "%{public}s called with null ipv4, no backtrace";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      if (!v112)
        goto LABEL_215;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v113 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_214;
    }
    v90 = __nwlog_obj();
    v91 = type[0];
    if (!os_log_type_enabled(v90, type[0]))
      goto LABEL_252;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    v92 = "%{public}s called with null ipv4";
LABEL_251:
    _os_log_impl(&dword_182FBE000, v90, v91, v92, buf, 0xCu);
    goto LABEL_252;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v147 = 0;
    if (!__nwlog_fault(v89, type, &v147))
      goto LABEL_252;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v147)
      {
        v90 = __nwlog_obj();
        v91 = type[0];
        if (os_log_type_enabled(v90, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
          v92 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v90 = __nwlog_obj();
      v91 = type[0];
      v114 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (v114)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
          v92 = "%{public}s called with null frame, no backtrace";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      if (!v114)
        goto LABEL_215;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v113 = "%{public}s called with null frame, dumping backtrace:%{public}s";
      goto LABEL_214;
    }
    v90 = __nwlog_obj();
    v91 = type[0];
    if (!os_log_type_enabled(v90, type[0]))
      goto LABEL_252;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    v92 = "%{public}s called with null frame";
    goto LABEL_251;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v147 = 0;
    if (!__nwlog_fault(v89, type, &v147))
      goto LABEL_252;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v90 = __nwlog_obj();
      v91 = type[0];
      if (!os_log_type_enabled(v90, type[0]))
        goto LABEL_252;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
      v92 = "%{public}s called with null count";
      goto LABEL_251;
    }
    if (!v147)
    {
      v90 = __nwlog_obj();
      v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        v92 = "%{public}s called with null count, backtrace limit exceeded";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v90 = __nwlog_obj();
    v91 = type[0];
    v115 = os_log_type_enabled(v90, type[0]);
    if (!backtrace_string)
    {
      if (v115)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        v92 = "%{public}s called with null count, no backtrace";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    if (!v115)
      goto LABEL_215;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v113 = "%{public}s called with null count, dumping backtrace:%{public}s";
LABEL_214:
    _os_log_impl(&dword_182FBE000, v90, v91, v113, buf, 0x16u);
    goto LABEL_215;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v147 = 0;
    if (!__nwlog_fault(v89, type, &v147))
      goto LABEL_252;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v90 = __nwlog_obj();
      v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        v92 = "%{public}s called with null reassembly_count";
        goto LABEL_251;
      }
LABEL_252:
      if (!v89)
        return 0;
      v68 = (char *)v89;
      goto LABEL_107;
    }
    if (!v147)
    {
      v90 = __nwlog_obj();
      v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        v92 = "%{public}s called with null reassembly_count, backtrace limit exceeded";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v90 = __nwlog_obj();
    v91 = type[0];
    v116 = os_log_type_enabled(v90, type[0]);
    if (!backtrace_string)
    {
      if (v116)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        v92 = "%{public}s called with null reassembly_count, no backtrace";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    if (v116)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v113 = "%{public}s called with null reassembly_count, dumping backtrace:%{public}s";
      goto LABEL_214;
    }
LABEL_215:
    free(backtrace_string);
    goto LABEL_252;
  }
  if (!*(_QWORD *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
  {
    v14 = 0;
    v15 = 0;
  }
  else
  {
    v13 = *(_DWORD *)(a2 + 52);
    v12 = *(unsigned int *)(a2 + 56);
    if (v13)
      v14 = v13 - (v12 + *(_DWORD *)(a2 + 60));
    else
      v14 = 0;
    v15 = (uint32x4_t *)(*(_QWORD *)(a2 + 112) + v12);
  }
  if ((*(_WORD *)(a2 + 204) & 0x80) != 0)
    v14 = *(unsigned __int16 *)(a2 + 196);
  if (!v15)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) != 0)
      goto LABEL_227;
    v93 = __nwlog_obj();
    if (!os_log_type_enabled(v93, OS_LOG_TYPE_INFO))
      goto LABEL_227;
    goto LABEL_226;
  }
  if (v14 <= 0x13)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      v94 = __nwlog_obj();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        v149 = " ";
        v150 = 2048;
        v151 = a1;
        v152 = 1024;
        v153 = v14;
        _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Received IPv4 packet with incorrect length %u", buf, 0x30u);
      }
    }
    v95 = *(_QWORD *)(a1 + 48);
    if (v95)
    {
      result = 0;
      ++*(_QWORD *)(v95 + 40);
      return result;
    }
    return 0;
  }
  if ((v15->i8[0] & 0xF0) != 0x40)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      v96 = __nwlog_obj();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      {
        v97 = v15->u8[0] >> 4;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        v149 = " ";
        v150 = 2048;
        v151 = a1;
        v152 = 1024;
        v153 = v97;
        _os_log_impl(&dword_182FBE000, v96, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Invalid IPv4 version: %u", buf, 0x30u);
      }
    }
    v98 = *(_QWORD *)(a1 + 48);
    if (v98)
    {
      result = 0;
      ++*(_QWORD *)(v98 + 96);
      return result;
    }
    return 0;
  }
  v16 = 4 * (v15->i8[0] & 0xF);
  if (v16 <= 0x13)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      v99 = __nwlog_obj();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        v149 = " ";
        v150 = 2048;
        v151 = a1;
        v152 = 1024;
        v153 = v16;
        v100 = "%{public}s %{public}s%s%p Invalid header length: %u";
        v101 = v99;
        v102 = 48;
LABEL_195:
        _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_ERROR, v100, buf, v102);
        goto LABEL_196;
      }
    }
    goto LABEL_196;
  }
  if (v14 < v16)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      v103 = __nwlog_obj();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        v149 = " ";
        v150 = 2048;
        v151 = a1;
        v152 = 1024;
        v153 = v16;
        v154 = 1024;
        *(_DWORD *)v155 = v14;
        v100 = "%{public}s %{public}s%s%p Invalid header length: %u > %u";
LABEL_194:
        v101 = v103;
        v102 = 54;
        goto LABEL_195;
      }
    }
LABEL_196:
    v110 = *(_QWORD *)(a1 + 48);
    if (v110)
    {
      result = 0;
      ++*(_QWORD *)(v110 + 72);
      return result;
    }
    return 0;
  }
  if (v15->i32[3] == *(_DWORD *)(a1 + 60))
  {
    v17 = v15[1].i32[0];
    if (v17 == *(_DWORD *)(a1 + 56)
      || v17 == -1
      || (v15[1].i32[0] & 0xF0) == 0xE0
      || (v18 = *(_DWORD *)(a1 + 128)) != 0 && v17 == v18
      || v18 && (v19 = *(_DWORD *)(a1 + 124)) != 0 && v17 == (v19 & v18))
    {
      v20 = bswap32(v15->u16[1]) >> 16;
      v21 = v14 - v20;
      if (v14 < v20)
      {
        if ((*(_BYTE *)(a1 + 136) & 1) == 0)
        {
          v107 = __nwlog_obj();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            v149 = " ";
            v150 = 2048;
            v151 = a1;
            v152 = 1024;
            v153 = v20;
            v154 = 1024;
            *(_DWORD *)v155 = v14;
            _os_log_impl(&dword_182FBE000, v107, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Received IPv4 packet with incorrect length, expected %u received %u", buf, 0x36u);
          }
        }
        v108 = *(_QWORD *)(a1 + 48);
        if (v108)
        {
          result = 0;
          ++*(_QWORD *)(v108 + 64);
          return result;
        }
        return 0;
      }
      if (v14 != v20 && (*(_BYTE *)(a1 + 136) & 1) == 0)
      {
        if (gLogDatapath)
        {
          loga = __nwlog_obj();
          v109 = os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG);
          v21 = v14 - v20;
          if (v109)
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            v149 = " ";
            v150 = 2048;
            v151 = a1;
            v152 = 1024;
            v153 = v20;
            v154 = 1024;
            *(_DWORD *)v155 = v14;
            _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Received length mismatch with IP total length %u != %u", buf, 0x36u);
            v21 = v14 - v20;
          }
        }
      }
      if (v16 <= v20)
      {
        if ((v15->i16[3] & 0xFF3F) != 0)
        {
          if ((*(_WORD *)(a2 + 204) & 0x80) == 0)
          {
            *a6 += nw_protocol_ipv4_process_reassembly(a1, v15->u16[2], a4, 0, 0);
            if ((*(_WORD *)(a2 + 204) & 0x100) == 0
              || !g_channel_check_validity
              || (g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)) & 1) != 0)
            {
              v22 = (bswap32(v15->u16[3]) >> 13) & 0x7FFF8;
              if ((*(_BYTE *)(a1 + 136) & 1) == 0)
              {
                if (gLogDatapath)
                {
                  v121 = __nwlog_obj();
                  if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
                  {
                    v122 = v15->u16[2];
                    *(_DWORD *)buf = 136447490;
                    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = a1 + 137;
                    *(_WORD *)&buf[22] = 2080;
                    v149 = " ";
                    v150 = 2048;
                    v151 = a1;
                    v152 = 1024;
                    v153 = v122;
                    v154 = 1024;
                    *(_DWORD *)v155 = (unsigned __int16)v22;
                    _os_log_impl(&dword_182FBE000, v121, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Got fragment for IP ID %u at offset %u", buf, 0x36u);
                  }
                }
              }
              v23 = *(_QWORD *)(a2 + 32);
              v24 = *(_QWORD **)(a2 + 40);
              v25 = (_QWORD *)(a2 + 32);
              if (v23)
              {
                *(_QWORD *)(v23 + 40) = v24;
                v24 = *(_QWORD **)(a2 + 40);
              }
              else
              {
                *(_QWORD *)(a3 + 8) = v24;
              }
              *v24 = v23;
              *v25 = 0;
              *(_QWORD *)(a2 + 40) = 0;
              v45 = v15->u16[3];
              if ((v45 & 0xFFFFFF1F) != 0)
              {
                if ((v45 & 0x20) != 0)
                {
                  *(_QWORD *)buf = 0;
                  *(_QWORD *)&buf[8] = buf;
                  *(_QWORD *)&buf[16] = 0x2000000000;
                  LOBYTE(v149) = 0;
                  v140[0] = MEMORY[0x1E0C809B0];
                  v140[1] = 0x40000000;
                  v141 = ___ZL36nw_protocol_ipv4_process_input_frameP16nw_protocol_ipv4P8nw_frameP16nw_frame_array_sS4_PjS5__block_invoke;
                  v142 = &unk_1E14AC570;
                  v146 = v22;
                  v144 = a1;
                  v145 = a2;
                  v143 = buf;
                  v51 = *(_QWORD *)(a1 + 64);
                  do
                  {
                    if (!v51)
                      break;
                    v52 = *(_QWORD *)(v51 + 32);
                    v53 = ((uint64_t (*)(_QWORD *))v141)(v140);
                    v51 = v52;
                  }
                  while ((v53 & 1) != 0);
                  if (!*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
                  {
                    *(_QWORD *)(a2 + 32) = 0;
                    v54 = *(uint64_t **)(a1 + 72);
                    *(_QWORD *)(a2 + 40) = v54;
                    *v54 = a2;
                    *(_QWORD *)(a1 + 72) = v25;
                  }
                  _Block_object_dispose(buf, 8);
                }
                else
                {
                  v46 = *(uint64_t **)(a1 + 72);
                  *(_QWORD *)(a2 + 40) = v46;
                  *v46 = a2;
                  *(_QWORD *)(a1 + 72) = v25;
                }
              }
              else
              {
                v48 = *(_QWORD *)(a1 + 64);
                v47 = (uint64_t *)(a1 + 64);
                *(_QWORD *)(a2 + 32) = v48;
                v49 = (_QWORD *)(v48 + 40);
                if (v48)
                  v50 = v49;
                else
                  v50 = v47 + 1;
                *v50 = v25;
                *v47 = a2;
                *(_QWORD *)(a2 + 40) = v47;
              }
              --*a5;
              return 1;
            }
            if ((*(_BYTE *)(a1 + 136) & 1) != 0
              || (v93 = __nwlog_obj(), !os_log_type_enabled(v93, OS_LOG_TYPE_INFO)))
            {
LABEL_227:
              result = 0;
              *(_QWORD *)(a1 + 48) = 0;
              return result;
            }
LABEL_226:
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            v149 = " ";
            v150 = 2048;
            v151 = a1;
            _os_log_impl(&dword_182FBE000, v93, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
            goto LABEL_227;
          }
          if ((*(_BYTE *)(a1 + 136) & 1) != 0)
            return 0;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 137;
          *(_WORD *)&buf[22] = 2080;
          v149 = " ";
          v150 = 2048;
          v151 = a1;
          v152 = 1024;
          v153 = v14;
          v39 = (const char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v147 = 0;
          if (__nwlog_fault(v39, type, &v147))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v40 = gLogObj;
              v41 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                goto LABEL_105;
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              v150 = 2048;
              v151 = a1;
              v152 = 1024;
              v153 = v14;
              v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u";
LABEL_104:
              _os_log_impl(&dword_182FBE000, v40, v41, v42, buf, 0x30u);
              goto LABEL_105;
            }
            if (!v147)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v40 = gLogObj;
              v41 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                goto LABEL_105;
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              v150 = 2048;
              v151 = a1;
              v152 = 1024;
              v153 = v14;
              v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, backtrace limit exceeded";
              goto LABEL_104;
            }
            v43 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v40 = gLogObj;
            v41 = type[0];
            v44 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
            if (!v43)
            {
              if (!v44)
                goto LABEL_105;
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              v150 = 2048;
              v151 = a1;
              v152 = 1024;
              v153 = v14;
              v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, no backtrace";
              goto LABEL_104;
            }
            if (v44)
            {
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              v150 = 2048;
              v151 = a1;
              v152 = 1024;
              v153 = v14;
              v154 = 2082;
              *(_QWORD *)v155 = v43;
              _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, dumping backtrace:%{public}s", buf, 0x3Au);
            }
            free(v43);
          }
LABEL_105:
          if (v39)
          {
            v68 = (char *)v39;
LABEL_107:
            free(v68);
          }
          return 0;
        }
        v26 = v21;
        *a6 += nw_protocol_ipv4_process_reassembly(a1, 0, a4, 0, 0);
        if ((*(_WORD *)(a2 + 204) & 0x100) != 0
          && g_channel_check_validity
          && (g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)) & 1) == 0)
        {
          if ((*(_BYTE *)(a1 + 136) & 1) != 0)
            goto LABEL_227;
          v93 = __nwlog_obj();
          if (!os_log_type_enabled(v93, OS_LOG_TYPE_INFO))
            goto LABEL_227;
          goto LABEL_226;
        }
        v28 = v15->i8[1];
        v29 = v28 & 3;
        *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xFC | v28 & 3;
        switch(v29)
        {
          case 3:
            v30 = (_QWORD *)(a1 + 32);
            break;
          case 2:
            v30 = (_QWORD *)(a1 + 24);
            break;
          case 1:
            v30 = (_QWORD *)(a1 + 16);
            break;
          default:
            v31 = *(_BYTE *)(a1 + 136);
            if ((v31 & 2) != 0)
              goto LABEL_92;
            goto LABEL_50;
        }
        ++*v30;
        v31 = *(_BYTE *)(a1 + 136);
        if ((v31 & 2) != 0)
        {
LABEL_92:
          v64 = mach_continuous_time();
          v65 = *(_WORD *)(a2 + 204) & 0xFFEF | (*(unsigned __int8 *)(a2 + 206) << 16);
          *(_WORD *)(a2 + 204) &= ~0x10u;
          *(_BYTE *)(a2 + 206) = BYTE2(v65);
          *(_QWORD *)(a2 + 152) = v64;
          if ((*(_BYTE *)(a1 + 136) & 0x80) == 0)
            goto LABEL_51;
          goto LABEL_93;
        }
LABEL_50:
        if ((v31 & 0x80) == 0)
          goto LABEL_51;
LABEL_93:
        *(_BYTE *)(a2 + 185) = v15->i8[8];
LABEL_51:
        if ((*(_WORD *)(a2 + 204) & 8) != 0)
          goto LABEL_115;
        v32 = a2 + 120;
        v33 = *(void **)(a2 + 168);
        if (v33)
        {
          os_release(v33);
          *(_QWORD *)(a2 + 168) = 0;
        }
        v34 = *(_QWORD *)(a2 + 64);
        *(_BYTE *)(a2 + 186) |= 0x40u;
        if (!v34)
        {
          *(_QWORD *)(a2 + 64) = v32;
          *(_QWORD *)(a2 + 72) = v32;
          *(_QWORD *)(a2 + 120) = 0;
          *(_QWORD *)(a2 + 128) = a2 + 64;
          goto LABEL_115;
        }
        if (v34 == v32)
          goto LABEL_115;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v34;
        *(_WORD *)&buf[22] = 2048;
        v149 = (const char *)(a2 + 120);
        v35 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v147 = 0;
        if (__nwlog_fault(v35, type, &v147))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v36 = gLogObj;
            v37 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
              goto LABEL_113;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v34;
            *(_WORD *)&buf[22] = 2048;
            v149 = (const char *)(a2 + 120);
            v38 = "%{public}s Existing metadata %p doesn't match expected %p";
LABEL_111:
            v69 = v36;
LABEL_112:
            _os_log_impl(&dword_182FBE000, v69, v37, v38, buf, 0x20u);
            goto LABEL_113;
          }
          if (!v147)
          {
            v36 = __nwlog_obj();
            v37 = type[0];
            if (!os_log_type_enabled(v36, type[0]))
              goto LABEL_113;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v34;
            *(_WORD *)&buf[22] = 2048;
            v149 = (const char *)(a2 + 120);
            v38 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
            goto LABEL_111;
          }
          v66 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v37 = type[0];
          log = gLogObj;
          v67 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v34;
              *(_WORD *)&buf[22] = 2048;
              v149 = (const char *)(a2 + 120);
              v150 = 2082;
              v151 = (uint64_t)v66;
              _os_log_impl(&dword_182FBE000, log, v37, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v66);
            goto LABEL_113;
          }
          if (v67)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v34;
            *(_WORD *)&buf[22] = 2048;
            v149 = (const char *)(a2 + 120);
            v38 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
            v69 = log;
            goto LABEL_112;
          }
        }
LABEL_113:
        if (v35)
          free(v35);
LABEL_115:
        if (v15->u8[9] != *(unsigned __int8 *)(a1 + 134))
        {
          if ((*(_BYTE *)(a1 + 136) & 1) == 0)
          {
            v117 = __nwlog_obj();
            if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
            {
              v118 = v15->u8[9];
              v119 = *(unsigned __int8 *)(a1 + 134);
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              v150 = 2048;
              v151 = a1;
              v152 = 1024;
              v153 = v118;
              v154 = 1024;
              *(_DWORD *)v155 = v119;
              _os_log_impl(&dword_182FBE000, v117, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Invalid IPv4 protocol %u (expected %u)", buf, 0x36u);
            }
          }
          v120 = *(_QWORD *)(a1 + 48);
          if (v120)
          {
            result = 0;
            ++*(_QWORD *)(v120 + 144);
            return result;
          }
          return 0;
        }
        v70 = *(_WORD *)(a2 + 204);
        if ((v70 & 0x100) != 0)
        {
          v147 = 0;
          *(_WORD *)buf = 0;
          *(_WORD *)type = 0;
          if (g_channel_get_internet_checksum_handler)
          {
            g_channel_get_internet_checksum_handler(a2, &v147, buf, type);
            v70 = *(_WORD *)(a2 + 204);
          }
        }
        if ((v70 & 0x200) != 0)
        {
          if ((v70 & 0x400) != 0)
          {
LABEL_137:
            v88 = *(_QWORD *)(a1 + 48);
            if (v88)
              ++*(_QWORD *)(v88 + 136);
            nw_frame_claim(a2, v27, v16, v26);
            ++*(_QWORD *)(a1 + 8);
            return 1;
          }
          if ((*(_BYTE *)(a1 + 136) & 1) == 0)
          {
            v74 = __nwlog_obj();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
              goto LABEL_240;
          }
          goto LABEL_241;
        }
        if ((v15 & 3) != 0)
        {
          if (v16 - 2 > 0x1D)
          {
            v78 = ((v16 - 2) >> 1) + 1;
            v79 = 2 * (v78 & 0xFFFFFFF0);
            v80 = (uint16x8_t *)&v15[1];
            v81 = 0uLL;
            v82 = v78 & 0xFFFFFFF0;
            v83 = 0uLL;
            v84 = 0uLL;
            v85 = 0uLL;
            do
            {
              v86 = v80[-1];
              v83 = (int32x4_t)vaddw_high_u16((uint32x4_t)v83, v86);
              v81 = (int32x4_t)vaddw_u16((uint32x4_t)v81, *(uint16x4_t *)v86.i8);
              v85 = (int32x4_t)vaddw_high_u16((uint32x4_t)v85, *v80);
              v84 = (int32x4_t)vaddw_u16((uint32x4_t)v84, *(uint16x4_t *)v80->i8);
              v80 += 2;
              v82 -= 16;
            }
            while (v82);
            v71 = vaddvq_s32(vaddq_s32(vaddq_s32(v84, v81), vaddq_s32(v85, v83)));
            if ((v78 & 0xFFFFFFF0) == v78)
              goto LABEL_135;
            v72 = (unsigned __int16 *)v15 + (v78 & 0xFFFFFFF0);
            v73 = v16 - v79;
          }
          else
          {
            v71 = 0;
            v72 = (unsigned __int16 *)v15;
            v73 = v16;
          }
          do
          {
            v87 = *v72++;
            v71 += v87;
            v73 -= 2;
          }
          while (v73);
LABEL_135:
          v77 = HIWORD(v71) + (unsigned __int16)v71;
LABEL_136:
          if ((unsigned __int16)(v77 + HIWORD(v77)) == 0xFFFF)
            goto LABEL_137;
          if ((*(_BYTE *)(a1 + 136) & 1) == 0)
          {
            v74 = __nwlog_obj();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
            {
LABEL_240:
              v123 = bswap32(v15->u16[5]) >> 16;
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 137;
              *(_WORD *)&buf[22] = 2080;
              v149 = " ";
              v150 = 2048;
              v151 = a1;
              v152 = 1024;
              v153 = v123;
              _os_log_impl(&dword_182FBE000, v74, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Invalid checksum 0x%x", buf, 0x30u);
            }
          }
LABEL_241:
          v124 = *(_QWORD *)(a1 + 48);
          if (v124)
          {
            result = 0;
            ++*(_QWORD *)(v124 + 8);
            return result;
          }
          return 0;
        }
        if (v16 == 20)
        {
          v75 = vaddlvq_u32(*v15) + v15[1].u32[0];
        }
        else
        {
          if (v16 - 4 > 0x1B)
          {
            v127 = ((v16 - 4) >> 2) + 1;
            v128 = 4 * (v127 & 0x7FFFFFF8);
            v129 = v15 + 1;
            v130 = 0uLL;
            v131 = v127 & 0x7FFFFFF8;
            v132 = 0uLL;
            v133 = 0uLL;
            v134 = 0uLL;
            do
            {
              v135 = v129[-1];
              v132 = (int64x2_t)vaddw_high_u32((uint64x2_t)v132, v135);
              v130 = (int64x2_t)vaddw_u32((uint64x2_t)v130, *(uint32x2_t *)v135.i8);
              v134 = (int64x2_t)vaddw_high_u32((uint64x2_t)v134, *v129);
              v133 = (int64x2_t)vaddw_u32((uint64x2_t)v133, *(uint32x2_t *)v129->i8);
              v129 += 2;
              v131 -= 8;
            }
            while (v131);
            v75 = vaddvq_s64(vaddq_s64(vaddq_s64(v133, v130), vaddq_s64(v134, v132)));
            if ((v127 & 0x7FFFFFF8) == v127)
              goto LABEL_129;
            v125 = &v15->i32[v127 & 0x7FFFFFF8];
            v126 = v16 - v128;
          }
          else
          {
            v75 = 0;
            v125 = (__int32 *)v15;
            v126 = v16;
          }
          do
          {
            v136 = *v125++;
            v75 += v136;
            v126 -= 4;
          }
          while (v126);
        }
LABEL_129:
        v76 = ((HIDWORD(v75) + v75) >> 16) + (unsigned __int16)(WORD2(v75) + v75);
        v77 = (v76 >> 16) + (unsigned __int16)v76;
        goto LABEL_136;
      }
      if ((*(_BYTE *)(a1 + 136) & 1) == 0)
      {
        v103 = __nwlog_obj();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 137;
          *(_WORD *)&buf[22] = 2080;
          v149 = " ";
          v150 = 2048;
          v151 = a1;
          v152 = 1024;
          v153 = v16;
          v154 = 1024;
          *(_DWORD *)v155 = v20;
          v100 = "%{public}s %{public}s%s%p Invalid header length (greater than IP length): %u > %u";
          goto LABEL_194;
        }
      }
      goto LABEL_196;
    }
    if ((*(_BYTE *)(a1 + 136) & 1) != 0)
      return 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v55 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v57 = v15[1].i32[0];
    v58 = *(_DWORD *)(a1 + 56);
    v60 = *(_DWORD *)(a1 + 124);
    v59 = *(_DWORD *)(a1 + 128);
    *(_DWORD *)buf = 136448002;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 137;
    *(_WORD *)&buf[22] = 2080;
    v149 = " ";
    v150 = 2048;
    v151 = a1;
    v152 = 1024;
    v153 = v57;
    v154 = 1024;
    *(_DWORD *)v155 = v58;
    *(_WORD *)&v155[4] = 1024;
    *(_DWORD *)&v155[6] = v59;
    v156 = 1024;
    v157 = v60;
    v61 = "%{public}s %{public}s%s%p Received local address 0x%x != 0x%x (broadcast %x, netmask %x)";
    v62 = v55;
    v63 = 66;
LABEL_88:
    _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_ERROR, v61, buf, v63);
    return 0;
  }
  if ((*(_BYTE *)(a1 + 136) & 1) != 0)
    return 0;
  v104 = __nwlog_obj();
  result = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v105 = v15->i32[3];
    v106 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 137;
    *(_WORD *)&buf[22] = 2080;
    v149 = " ";
    v150 = 2048;
    v151 = a1;
    v152 = 1024;
    v153 = v105;
    v154 = 1024;
    *(_DWORD *)v155 = v106;
    v61 = "%{public}s %{public}s%s%p Received remote address 0x%x != 0x%x";
    v62 = v104;
    v63 = 54;
    goto LABEL_88;
  }
  return result;
}

uint64_t nw_channel_frame_check_validity(nw_frame *a1, _QWORD *a2)
{
  uint64_t result;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_channel_frame_check_validity";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v4, &type, &v10))
      goto LABEL_26;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_frame_check_validity";
      v7 = "%{public}s called with null context";
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_channel_frame_check_validity";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_26;
      }
      if (!v9)
      {
LABEL_26:
        if (v4)
          free(v4);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_frame_check_validity";
      v7 = "%{public}s called with null context, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_frame_check_validity";
      v7 = "%{public}s called with null context, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_26;
  }
  if (a2[17])
  {
    if (((*((unsigned __int16 *)a2 + 222) | (*((unsigned __int8 *)a2 + 446) << 16)) & 0x80000) == 0)
    {
      if (!os_channel_is_defunct())
        return 1;
      nw_channel_handle_defunct((uint64_t)a2);
    }
  }
  else
  {
    if (_nw_signposts_once != -1)
      dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
    if (_nw_signposts_enabled)
    {
      result = kdebug_is_enabled();
      if (!(_DWORD)result)
        return result;
      kdebug_trace();
    }
  }
  return 0;
}

uint64_t nw_protocol_ipv4_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  void *handle;
  nw_protocol **v8;
  int v9;
  int v10;
  nw_protocol *output_handler;
  nw_frame_array_s *v12;
  void *v13;
  nw_protocol_callbacks *callbacks;
  void *v15;
  nw_protocol_callbacks *v16;
  nw_protocol_callbacks *v17;
  uint64_t (*get_input_frames)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  int v19;
  nw_frame *tqh_first;
  nw_frame *v21;
  char v22;
  int v23;
  BOOL v24;
  int v25;
  nw_protocol *v26;
  void *v27;
  nw_protocol_callbacks *v28;
  void *v29;
  nw_protocol_callbacks *v30;
  nw_protocol_callbacks *v31;
  uint64_t (*v32)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, _QWORD *);
  int v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  nw_protocol_callbacks *v40;
  nw_protocol_callbacks *v41;
  void (**v42)(_QWORD);
  const void *v43;
  nw_protocol_callbacks *v44;
  nw_protocol_callbacks *v45;
  void (**v46)(_QWORD);
  const void *v47;
  const char *v48;
  const char *v49;
  os_log_type_t v50;
  const char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  char *v55;
  uint64_t v56;
  os_log_type_t v57;
  NSObject *v58;
  os_log_type_t v59;
  const char *v60;
  char *v61;
  _BOOL4 v62;
  const char *v63;
  NSObject *v64;
  int v65;
  const char *v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  _BOOL4 v70;
  os_log_type_t v71;
  const char *v72;
  const char *v73;
  uint64_t v74;
  os_log_type_t v75;
  nw_frame **v76;
  int v77;
  int v78;
  NSObject *v79;
  nw_protocol_callbacks *v80;
  nw_protocol_callbacks *v81;
  void (**v82)(_QWORD);
  const void *v83;
  nw_protocol_callbacks *v84;
  nw_protocol_callbacks *v85;
  void (**v86)(_QWORD);
  const void *v87;
  const char *name;
  const char *v89;
  NSObject *v90;
  os_log_type_t v91;
  const char *v92;
  NSObject *v93;
  os_log_type_t v94;
  const char *v95;
  const char *v96;
  NSObject *v97;
  os_log_type_t v98;
  uint32_t v99;
  char *v100;
  _BOOL4 v101;
  const char *v102;
  NSObject *v103;
  os_log_type_t v104;
  const char *v105;
  uint32_t v106;
  _BOOL4 v107;
  NSObject *v108;
  os_log_type_t v109;
  const char *v110;
  const char *v111;
  NSObject *v112;
  os_log_type_t v113;
  char *v114;
  NSObject *v115;
  os_log_type_t v116;
  const char *v117;
  char *v118;
  _BOOL4 v119;
  uint64_t v120;
  NSObject *v122;
  os_log_type_t v123;
  const char *v124;
  char *v125;
  NSObject *v127;
  char *backtrace_string;
  _BOOL4 v129;
  const char *v130;
  _BOOL4 v131;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  os_log_type_t type[8];
  os_log_type_t typea;
  os_log_type_t typeb[8];
  os_log_type_t typec[8];
  os_log_type_t typed[8];
  os_log_type_t typee;
  os_log_type_t typef;
  os_log_type_t typeg[8];
  os_log_type_t typeh[8];
  char *v144;
  char *v145;
  char *v146;
  nw_protocol **p_output_handler;
  unsigned int v149;
  unsigned int v150;
  _QWORD v152[2];
  uint64_t (*v153)(uint64_t, uint64_t);
  void *v154;
  _QWORD *v155;
  nw_protocol **v156;
  _QWORD v157[2];
  uint64_t (*v158)(_QWORD *);
  void *v159;
  uint64_t *v160;
  os_log_type_t *v161;
  _BYTE *v162;
  nw_protocol **v163;
  _QWORD *v164;
  uint64_t *v165;
  uint64_t v166;
  uint64_t *v167;
  uint64_t v168;
  int v169;
  _QWORD v170[2];
  char v171;
  _QWORD v172[2];
  uint64_t (*v173)(_QWORD *);
  void *v174;
  _QWORD *v175;
  _QWORD *v176;
  uint64_t *v177;
  os_log_type_t *v178;
  nw_frame_array_s *v179;
  nw_protocol **v180;
  uint64_t *v181;
  _QWORD v182[3];
  char v183;
  uint64_t v184;
  nw_frame **v185;
  _QWORD v186[3];
  char v187;
  os_log_type_t v188[8];
  os_log_type_t *v189;
  uint64_t v190;
  int v191;
  uint64_t v192;
  uint64_t *v193;
  uint64_t v194;
  int v195;
  char v196;
  os_log_type_t v197;
  _BYTE buf[24];
  const char *v199;
  __int16 v200;
  char *v201;
  __int16 v202;
  int v203;
  __int16 v204;
  const char *v205;
  uint64_t v206;

  v206 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
    v125 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v125, &v192, v188))
      goto LABEL_245;
    if (v192 == 17)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
        v124 = "%{public}s called with null protocol";
LABEL_244:
        _os_log_impl(&dword_182FBE000, v122, v123, v124, buf, 0xCu);
      }
LABEL_245:
      if (v125)
        free(v125);
      return 0;
    }
    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
        v124 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v122 = __nwlog_obj();
    v123 = v192;
    v129 = os_log_type_enabled(v122, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v129)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
        v124 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v129)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v130 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_234:
      _os_log_impl(&dword_182FBE000, v122, v123, v130, buf, 0x16u);
    }
LABEL_235:
    free(backtrace_string);
    goto LABEL_245;
  }
  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle)
    v8 = &a1[1].output_handler;
  else
    v8 = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
    v125 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v125, &v192, v188))
      goto LABEL_245;
    if (v192 == 17)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
        v124 = "%{public}s called with null ipv4";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      v122 = __nwlog_obj();
      v123 = v192;
      if (os_log_type_enabled(v122, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
        v124 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v122 = __nwlog_obj();
    v123 = v192;
    v131 = os_log_type_enabled(v122, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v131)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
        v124 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v131)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v130 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_234;
    }
    goto LABEL_235;
  }
  if (a3 >= 0xFFFFFFEC)
    v9 = -1;
  else
    v9 = a3 + 20;
  v10 = a4 + 20;
  if (a4 >= 0xFFFFFFEC)
    v10 = -1;
  v149 = v10;
  v150 = v9;
  v192 = 0;
  v193 = &v192;
  v195 = 0;
  v194 = 0x2000000000;
  v146 = (char *)&a1[3].handle + 1;
  output_handler = a1->output_handler;
  if (!output_handler)
  {
LABEL_195:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
    v114 = (char *)_os_log_send_and_compose_impl();
    v188[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v186[0]) = 0;
    if (!__nwlog_fault(v114, v188, v186))
      goto LABEL_209;
    if (v188[0] == OS_LOG_TYPE_FAULT)
    {
      v115 = __nwlog_obj();
      v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0]))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v117 = "%{public}s called with null protocol";
    }
    else if (LOBYTE(v186[0]))
    {
      v118 = (char *)__nw_create_backtrace_string();
      v115 = __nwlog_obj();
      v116 = v188[0];
      v119 = os_log_type_enabled(v115, v188[0]);
      if (v118)
      {
        if (v119)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v118;
          _os_log_impl(&dword_182FBE000, v115, v116, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v118);
LABEL_209:
        if (v114)
          free(v114);
        *((_DWORD *)v193 + 6) = 0;
LABEL_212:
        if (((uint64_t)a1[3].handle & 1) == 0)
        {
          if (gLogDatapath)
          {
            v127 = __nwlog_obj();
            if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v146;
              *(_WORD *)&buf[22] = 2080;
              v199 = " ";
              v200 = 2048;
              v201 = (char *)p_output_handler;
              _os_log_impl(&dword_182FBE000, v127, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p No IPv4 input frame", buf, 0x2Au);
            }
          }
        }
        goto LABEL_214;
      }
      if (!v119)
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v117 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v115 = __nwlog_obj();
      v116 = v188[0];
      if (!os_log_type_enabled(v115, v188[0]))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v117 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v115, v116, v117, buf, 0xCu);
    goto LABEL_209;
  }
  v12 = a6;
  while (2)
  {
    v13 = output_handler->handle;
    if (v13 == &nw_protocol_ref_counted_handle)
    {
      callbacks = output_handler[1].callbacks;
      if (callbacks)
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
    v15 = a1->handle;
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      v16 = a1[1].callbacks;
      if (v16)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v16->add_input_handler + 1);
    }
    if (!v12)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      v96 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      v145 = (char *)v96;
      if (!__nwlog_fault(v96, v188, v186))
        goto LABEL_186;
      if (v188[0] == OS_LOG_TYPE_FAULT)
      {
        v97 = __nwlog_obj();
        v98 = v188[0];
        *(_QWORD *)typed = v97;
        if (!os_log_type_enabled(v97, v188[0]))
          goto LABEL_186;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        v93 = *(NSObject **)typed;
        v94 = v98;
        v95 = "%{public}s called with null return_array";
        v99 = 12;
        goto LABEL_185;
      }
      if (LOBYTE(v186[0]))
      {
        v100 = (char *)__nw_create_backtrace_string();
        logb = __nwlog_obj();
        typef = v188[0];
        v107 = os_log_type_enabled(logb, v188[0]);
        if (v100)
        {
          if (v107)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v100;
            v103 = logb;
            v104 = typef;
            v105 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
            v106 = 22;
LABEL_174:
            _os_log_impl(&dword_182FBE000, v103, v104, v105, buf, v106);
          }
LABEL_175:
          free(v100);
          goto LABEL_186;
        }
        if (v107)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v93 = logb;
          v94 = typef;
          v95 = "%{public}s called with null return_array, no backtrace";
          v99 = 12;
          goto LABEL_185;
        }
      }
      else
      {
        v112 = __nwlog_obj();
        v113 = v188[0];
        *(_QWORD *)typeh = v112;
        if (os_log_type_enabled(v112, v188[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v93 = *(NSObject **)typeh;
          v94 = v113;
          v95 = "%{public}s called with null return_array, backtrace limit exceeded";
          v99 = 12;
          goto LABEL_185;
        }
      }
LABEL_186:
      if (v145)
        free(v145);
      v19 = 0;
      if (v15 != &nw_protocol_ref_counted_handle)
        goto LABEL_26;
      goto LABEL_25;
    }
    v17 = output_handler->callbacks;
    if (!v17
      || (get_input_frames = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v17->get_input_frames) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      name = output_handler->identifier->name;
      if (!name)
        name = "invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = name;
      *(_WORD *)&buf[22] = 2048;
      v199 = (const char *)output_handler;
      v89 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      v145 = (char *)v89;
      if (__nwlog_fault(v89, v188, v186))
      {
        if (v188[0] == OS_LOG_TYPE_FAULT)
        {
          v90 = __nwlog_obj();
          v91 = v188[0];
          *(_QWORD *)typec = v90;
          if (!os_log_type_enabled(v90, v188[0]))
            goto LABEL_186;
          v92 = output_handler->identifier->name;
          if (!v92)
            v92 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v92;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v93 = *(NSObject **)typec;
          v94 = v91;
          v95 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_184:
          v99 = 32;
LABEL_185:
          _os_log_impl(&dword_182FBE000, v93, v94, v95, buf, v99);
          goto LABEL_186;
        }
        if (!LOBYTE(v186[0]))
        {
          v108 = __nwlog_obj();
          v109 = v188[0];
          *(_QWORD *)typeg = v108;
          if (!os_log_type_enabled(v108, v188[0]))
            goto LABEL_186;
          v110 = output_handler->identifier->name;
          if (!v110)
            v110 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v110;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v93 = *(NSObject **)typeg;
          v94 = v109;
          v95 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
          goto LABEL_184;
        }
        v100 = (char *)__nw_create_backtrace_string();
        loga = __nwlog_obj();
        typee = v188[0];
        v101 = os_log_type_enabled(loga, v188[0]);
        if (!v100)
        {
          if (!v101)
            goto LABEL_186;
          v111 = output_handler->identifier->name;
          if (!v111)
            v111 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v111;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v93 = loga;
          v94 = typee;
          v95 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
          goto LABEL_184;
        }
        if (v101)
        {
          v102 = output_handler->identifier->name;
          if (!v102)
            v102 = "invalid";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v102;
          *(_WORD *)&buf[22] = 2048;
          v199 = (const char *)output_handler;
          v200 = 2082;
          v201 = v100;
          v103 = loga;
          v104 = typee;
          v105 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s";
          v106 = 42;
          goto LABEL_174;
        }
        goto LABEL_175;
      }
      goto LABEL_186;
    }
    v19 = get_input_frames(output_handler, a1, v150, v149, a5, v12);
    if (v15 == &nw_protocol_ref_counted_handle)
    {
LABEL_25:
      if (a1->handle == &nw_protocol_ref_counted_handle)
      {
        v84 = a1[1].callbacks;
        if (v84)
        {
          v85 = (nw_protocol_callbacks *)((char *)v84 - 1);
          a1[1].callbacks = v85;
          if (!v85)
          {
            v86 = *(void (***)(_QWORD))a1[1].flow_id;
            if (v86)
            {
              *(_QWORD *)a1[1].flow_id = 0;
              v86[2](v86);
              _Block_release(v86);
            }
            if ((a1[1].flow_id[8] & 1) != 0)
            {
              v87 = *(const void **)a1[1].flow_id;
              if (v87)
                _Block_release(v87);
            }
            free(a1);
          }
        }
      }
    }
LABEL_26:
    if (v13 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v80 = output_handler[1].callbacks;
      if (v80)
      {
        v81 = (nw_protocol_callbacks *)((char *)v80 - 1);
        output_handler[1].callbacks = v81;
        if (!v81)
        {
          v82 = *(void (***)(_QWORD))output_handler[1].flow_id;
          if (v82)
          {
            *(_QWORD *)output_handler[1].flow_id = 0;
            v82[2](v82);
            _Block_release(v82);
          }
          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            v83 = *(const void **)output_handler[1].flow_id;
            if (v83)
              _Block_release(v83);
          }
          free(output_handler);
        }
      }
    }
    *((_DWORD *)v193 + 6) = v19;
    if (!v19)
      goto LABEL_212;
    *(_QWORD *)v188 = 0;
    v189 = v188;
    v191 = 0;
    v190 = 0x2000000000;
    v186[0] = 0;
    v186[1] = v186;
    v186[2] = 0x2000000000;
    v187 = 0;
    v182[0] = 0;
    v182[1] = v182;
    v182[2] = 0x2000000000;
    v183 = 0;
    v184 = 0;
    v185 = (nw_frame **)&v184;
    v172[0] = MEMORY[0x1E0C809B0];
    v172[1] = 0x40000000;
    v173 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    v174 = &unk_1E14AC500;
    v175 = v186;
    v176 = v182;
    v179 = v12;
    v180 = v8;
    v181 = &v184;
    v177 = &v192;
    v178 = v188;
    tqh_first = v12->tqh_first;
    do
    {
      if (!tqh_first)
        break;
      v21 = (nw_frame *)*((_QWORD *)tqh_first + 4);
      v22 = v173(v172);
      tqh_first = v21;
    }
    while ((v22 & 1) != 0);
    v171 = 0;
    do
    {
      v25 = nw_protocol_ipv4_process_reassembly((uint64_t)v8, 0, (uint64_t)&v184, 0, &v171);
      *((_DWORD *)v193 + 6) += v25;
      if (!v171)
        break;
      v170[0] = 0;
      v170[1] = v170;
      v166 = 0;
      v167 = &v166;
      v169 = 0;
      v168 = 0x2000000000;
      v26 = a1->output_handler;
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        v55 = (char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        if (!__nwlog_fault(v55, &v197, &v196))
          goto LABEL_127;
        if (v197 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = gLogObj;
          v57 = v197;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            v58 = v56;
            v59 = v57;
            v60 = "%{public}s called with null protocol";
            goto LABEL_126;
          }
          goto LABEL_127;
        }
        if (v196)
        {
          v67 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v68 = gLogObj;
          v69 = v197;
          v70 = os_log_type_enabled((os_log_t)gLogObj, v197);
          if (v67)
          {
            if (v70)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v67;
              _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v67);
            goto LABEL_127;
          }
          if (!v70)
          {
LABEL_127:
            if (v55)
              free(v55);
            v33 = 0;
            goto LABEL_52;
          }
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = v68;
          v59 = v69;
          v60 = "%{public}s called with null protocol, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v74 = gLogObj;
          v75 = v197;
          if (!os_log_type_enabled((os_log_t)gLogObj, v197))
            goto LABEL_127;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
          v58 = v74;
          v59 = v75;
          v60 = "%{public}s called with null protocol, backtrace limit exceeded";
        }
LABEL_126:
        _os_log_impl(&dword_182FBE000, v58, v59, v60, buf, 0xCu);
        goto LABEL_127;
      }
      v27 = v26->handle;
      if (v27 == &nw_protocol_ref_counted_handle)
      {
        v28 = v26[1].callbacks;
        if (v28)
          v26[1].callbacks = (nw_protocol_callbacks *)((char *)&v28->add_input_handler + 1);
      }
      v29 = a1->handle;
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        v30 = a1[1].callbacks;
        if (v30)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v30->add_input_handler + 1);
      }
      v31 = v26->callbacks;
      if (!v31
        || (v32 = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, _QWORD *))v31->get_input_frames) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v48 = v26->identifier->name;
        if (!v48)
          v48 = "invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v48;
        *(_WORD *)&buf[22] = 2048;
        v199 = (const char *)v26;
        v49 = (const char *)_os_log_send_and_compose_impl();
        v197 = OS_LOG_TYPE_ERROR;
        v196 = 0;
        v144 = (char *)v49;
        if (__nwlog_fault(v49, &v197, &v196))
        {
          if (v197 != OS_LOG_TYPE_FAULT)
          {
            if (v196)
            {
              v61 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              log = gLogObj;
              typea = v197;
              v62 = os_log_type_enabled((os_log_t)gLogObj, v197);
              if (v61)
              {
                if (v62)
                {
                  v63 = v26->identifier->name;
                  if (!v63)
                    v63 = "invalid";
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v63;
                  *(_WORD *)&buf[22] = 2048;
                  v199 = (const char *)v26;
                  v200 = 2082;
                  v201 = v61;
                  _os_log_impl(&dword_182FBE000, log, typea, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }
                free(v61);
                goto LABEL_118;
              }
              if (!v62)
                goto LABEL_118;
              v73 = v26->identifier->name;
              if (!v73)
                v73 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v73;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              v52 = log;
              v53 = typea;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v71 = v197;
              *(_QWORD *)typeb = gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, v197))
                goto LABEL_118;
              v72 = v26->identifier->name;
              if (!v72)
                v72 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v72;
              *(_WORD *)&buf[22] = 2048;
              v199 = (const char *)v26;
              v52 = *(NSObject **)typeb;
              v53 = v71;
              v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            }
LABEL_117:
            _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0x20u);
            goto LABEL_118;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v50 = v197;
          *(_QWORD *)type = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            v51 = v26->identifier->name;
            if (!v51)
              v51 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v51;
            *(_WORD *)&buf[22] = 2048;
            v199 = (const char *)v26;
            v52 = *(NSObject **)type;
            v53 = v50;
            v54 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
            goto LABEL_117;
          }
        }
LABEL_118:
        if (v144)
          free(v144);
        v33 = 0;
        if (v29 != &nw_protocol_ref_counted_handle)
          goto LABEL_50;
LABEL_49:
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v40 = a1[1].callbacks;
          if (v40)
          {
            v41 = (nw_protocol_callbacks *)((char *)v40 - 1);
            a1[1].callbacks = v41;
            if (!v41)
            {
              v42 = *(void (***)(_QWORD))a1[1].flow_id;
              if (v42)
              {
                *(_QWORD *)a1[1].flow_id = 0;
                v42[2](v42);
                _Block_release(v42);
              }
              if ((a1[1].flow_id[8] & 1) != 0)
              {
                v43 = *(const void **)a1[1].flow_id;
                if (v43)
                  _Block_release(v43);
              }
              free(a1);
            }
          }
        }
        goto LABEL_50;
      }
      v33 = v32(v26, a1, 1, 0xFFFFFFFFLL, 1, v170);
      if (v29 == &nw_protocol_ref_counted_handle)
        goto LABEL_49;
LABEL_50:
      if (v27 == &nw_protocol_ref_counted_handle && v26->handle == &nw_protocol_ref_counted_handle)
      {
        v44 = v26[1].callbacks;
        if (v44)
        {
          v45 = (nw_protocol_callbacks *)((char *)v44 - 1);
          v26[1].callbacks = v45;
          if (!v45)
          {
            v46 = *(void (***)(_QWORD))v26[1].flow_id;
            if (v46)
            {
              *(_QWORD *)v26[1].flow_id = 0;
              v46[2](v46);
              _Block_release(v46);
            }
            if ((v26[1].flow_id[8] & 1) != 0)
            {
              v47 = *(const void **)v26[1].flow_id;
              if (v47)
                _Block_release(v47);
            }
            free(v26);
          }
        }
      }
LABEL_52:
      v169 = v33;
      if (*((_DWORD *)v167 + 6))
      {
        if (((uint64_t)a1[3].handle & 1) == 0)
        {
          if (gLogDatapath)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v64 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              v65 = *((_DWORD *)v167 + 6);
              v66 = "s";
              if (v65 == 1)
                v66 = "";
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v146;
              *(_WORD *)&buf[22] = 2080;
              v199 = " ";
              v200 = 2048;
              v201 = (char *)p_output_handler;
              v202 = 1024;
              v203 = v65;
              v204 = 2080;
              v205 = v66;
              _os_log_impl(&dword_182FBE000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Found %u IPv4 extra fragment%s", buf, 0x3Au);
            }
          }
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2000000000;
        LOBYTE(v199) = 0;
        v157[0] = MEMORY[0x1E0C809B0];
        v157[1] = 0x40000000;
        v158 = (uint64_t (*)(_QWORD *))___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_19;
        v159 = &unk_1E14AC528;
        v164 = v170;
        v165 = &v184;
        v160 = &v166;
        v161 = v188;
        v162 = buf;
        v163 = v8;
        v34 = v170[0];
        do
        {
          if (!v34)
            break;
          v35 = *(_QWORD *)(v34 + 32);
          v36 = v158(v157);
          v34 = v35;
        }
        while ((v36 & 1) != 0);
        v152[0] = MEMORY[0x1E0C809B0];
        v152[1] = 0x40000000;
        v153 = ___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2;
        v154 = &__block_descriptor_tmp_21_85792;
        v155 = v170;
        v156 = v8;
        v37 = v170[0];
        do
        {
          if (!v37)
            break;
          v38 = *(_QWORD *)(v37 + 32);
          v39 = ((uint64_t (*)(_QWORD *))v153)(v152);
          v37 = v38;
        }
        while ((v39 & 1) != 0);
        if (*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
          v23 = 34;
        else
          v23 = 0;
        _Block_object_dispose(buf, 8);
      }
      else
      {
        v23 = 34;
      }
      _Block_object_dispose(&v166, 8);
      if (v23)
        v24 = 1;
      else
        v24 = v171 == 0;
    }
    while (!v24);
    v12 = a6;
    if (v184)
    {
      *a6->tqh_last = (nw_frame *)v184;
      v76 = v185;
      *(_QWORD *)(v184 + 40) = a6->tqh_last;
      a6->tqh_last = v76;
      v184 = 0;
      v185 = (nw_frame **)&v184;
    }
    *((_DWORD *)v193 + 6) += *((_DWORD *)v189 + 6);
    v77 = nw_protocol_ipv4_process_reassembly((uint64_t)v8, 0, (uint64_t)a6, 1, 0);
    v78 = *((_DWORD *)v193 + 6) + v77;
    *((_DWORD *)v193 + 6) = v78;
    if (!v78)
    {
      if (((uint64_t)a1[3].handle & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v79 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v146;
          *(_WORD *)&buf[22] = 2080;
          v199 = " ";
          v200 = 2048;
          v201 = (char *)p_output_handler;
          _os_log_impl(&dword_182FBE000, v79, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Dropped inbound packets, checking for more", buf, 0x2Au);
        }
      }
      _Block_object_dispose(v182, 8);
      _Block_object_dispose(v186, 8);
      _Block_object_dispose(v188, 8);
      output_handler = a1->output_handler;
      if (!output_handler)
        goto LABEL_195;
      continue;
    }
    break;
  }
  _Block_object_dispose(v182, 8);
  _Block_object_dispose(v186, 8);
  _Block_object_dispose(v188, 8);
LABEL_214:
  v120 = *((unsigned int *)v193 + 6);
  _Block_object_dispose(&v192, 8);
  return v120;
}

uint64_t nw_protocol_ipv4_process_reassembly(uint64_t a1, int a2, uint64_t a3, int a4, _BYTE *a5)
{
  uint64_t v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  const char *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  char *v34;
  _BOOL4 v35;
  char *backtrace_string;
  _BOOL4 v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  int i;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  NSObject *v51;
  int v52;
  NSObject *v54;
  int v55;
  NSObject *v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  const char *v60;
  NSObject *v61;
  int v62;
  char *v63;
  _BOOL4 v64;
  NSObject *log;
  os_log_type_t v66;
  uint64_t v67;
  char *v68;
  os_log_type_t type[8];
  uint64_t v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  void *v72;
  uint64_t v73;
  _QWORD v74[3];
  int v75;
  unsigned int v76;
  _QWORD v77[2];
  uint64_t (*v78)(_QWORD *);
  void *v79;
  uint64_t *v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  __int16 v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  char v90;
  _BYTE buf[32];
  __int128 v92;
  _BYTE v93[12];
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 64);
  if (!v8)
  {
    v12 = 0;
    goto LABEL_85;
  }
  if (!a5 && *(unsigned __int16 *)(a1 + 132) == a2 && a4 == 0)
  {
    v12 = 0;
LABEL_86:
    *(_WORD *)(a1 + 132) = a2;
    return v12;
  }
  if (!a3)
  {
    v12 = 0;
    if (!a4)
      goto LABEL_85;
    goto LABEL_75;
  }
  v87 = 0;
  v88 = &v87;
  v89 = 0x2000000000;
  v90 = 0;
  v83 = 0;
  v84 = &v83;
  v85 = 0x2000000000;
  v86 = 0;
  v13 = MEMORY[0x1E0C809B0];
  v77[0] = MEMORY[0x1E0C809B0];
  v77[1] = 0x40000000;
  v78 = (uint64_t (*)(_QWORD *))___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke;
  v79 = &unk_1E14AC598;
  v81 = &v87;
  v82 = a1;
  v80 = &v83;
  do
  {
    if (!v8)
      break;
    v14 = *(_QWORD *)(v8 + 32);
    v15 = v78(v77);
    v8 = v14;
  }
  while ((v15 & 1) != 0);
  if (*((_BYTE *)v88 + 24))
  {
    v16 = *((unsigned __int16 *)v84 + 12) + 20;
    v17 = nw_calloc_type<unsigned char>(*((unsigned __int16 *)v84 + 12) + 20);
    v18 = nw_frame_create(0, v17, v16, (uint64_t)nw_protocol_ipv4_frame_input_finalizer, a1);
    if (v18)
    {
      v19 = v18;
      if ((*(_BYTE *)(a1 + 136) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v54 = __nwlog_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          {
            v55 = *(unsigned __int16 *)(a1 + 132);
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            *(_QWORD *)&buf[24] = " ";
            LOWORD(v92) = 2048;
            *(_QWORD *)((char *)&v92 + 2) = a1;
            WORD5(v92) = 1024;
            HIDWORD(v92) = v55;
            *(_WORD *)v93 = 1024;
            *(_DWORD *)&v93[2] = v16;
            _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Fragments for IP ID %u are complete, aggregate length %u", buf, 0x36u);
          }
        }
      }
      v20 = *(_QWORD *)(a1 + 64);
      v76 = 0;
      v21 = nw_frame_unclaimed_bytes(v20, &v76);
      if (!v21)
      {
        if ((*(_BYTE *)(a1 + 136) & 1) == 0)
        {
          v56 = __nwlog_obj();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            *(_QWORD *)&buf[24] = " ";
            LOWORD(v92) = 2048;
            *(_QWORD *)((char *)&v92 + 2) = a1;
            _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
          }
        }
        *(_QWORD *)(a1 + 48) = 0;
        goto LABEL_115;
      }
      if (v76 > 0x13)
      {
        v23 = *(_DWORD *)(v21 + 16);
        *(_OWORD *)v17 = *(_OWORD *)v21;
        *(_DWORD *)(v17 + 16) = v23;
        *(_WORD *)(v17 + 2) = bswap32(v16) >> 16;
        *(_WORD *)(v17 + 6) = 0;
        if ((*(_WORD *)(v19 + 204) & 8) == 0)
        {
          v24 = v19 + 120;
          v25 = *(void **)(v19 + 168);
          if (v25)
          {
            os_release(v25);
            v24 = v19 + 120;
            *(_QWORD *)(v19 + 168) = 0;
          }
          v26 = *(_QWORD *)(v19 + 64);
          *(_BYTE *)(v19 + 186) |= 0x40u;
          if (v26)
          {
            if (v26 != v24)
            {
              v27 = v24;
              __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v26;
              *(_WORD *)&buf[22] = 2048;
              v67 = v27;
              *(_QWORD *)&buf[24] = v27;
              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v74[0]) = 0;
              v68 = (char *)_os_log_send_and_compose_impl();
              if (__nwlog_fault(v68, type, v74))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  v28 = __nwlog_obj();
                  v66 = type[0];
                  if (os_log_type_enabled(v28, type[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v26;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)&buf[24] = v67;
                    v29 = "%{public}s Existing metadata %p doesn't match expected %p";
LABEL_62:
                    v38 = v28;
LABEL_63:
                    _os_log_impl(&dword_182FBE000, v38, v66, v29, buf, 0x20u);
                  }
                }
                else if (LOBYTE(v74[0]))
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  log = __nwlog_obj();
                  v66 = type[0];
                  v37 = os_log_type_enabled(log, type[0]);
                  if (backtrace_string)
                  {
                    if (v37)
                    {
                      *(_DWORD *)buf = 136446978;
                      *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                      *(_WORD *)&buf[12] = 2048;
                      *(_QWORD *)&buf[14] = v26;
                      *(_WORD *)&buf[22] = 2048;
                      *(_QWORD *)&buf[24] = v67;
                      LOWORD(v92) = 2082;
                      *(_QWORD *)((char *)&v92 + 2) = backtrace_string;
                      _os_log_impl(&dword_182FBE000, log, v66, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
                    }
                    free(backtrace_string);
                    goto LABEL_64;
                  }
                  if (v37)
                  {
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v26;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)&buf[24] = v67;
                    v29 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
                    v38 = log;
                    goto LABEL_63;
                  }
                }
                else
                {
                  v28 = __nwlog_obj();
                  v66 = type[0];
                  if (os_log_type_enabled(v28, type[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "__nw_frame_set_metadata";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v26;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)&buf[24] = v67;
                    v29 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
                    goto LABEL_62;
                  }
                }
              }
LABEL_64:
              if (v68)
                free(v68);
              v13 = MEMORY[0x1E0C809B0];
            }
          }
          else
          {
            *(_QWORD *)(v19 + 64) = v24;
            *(_QWORD *)(v19 + 72) = v24;
            *(_QWORD *)(v19 + 120) = 0;
            *(_QWORD *)(v19 + 128) = v19 + 64;
          }
        }
        nw_frame_claim(v19, v22, 20, 0);
        v74[0] = 0;
        v74[1] = v74;
        v75 = 20;
        v74[2] = 0x2000000000;
        *(_QWORD *)buf = v13;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke_24;
        *(_QWORD *)&buf[24] = &unk_1E14AC5C0;
        *(_QWORD *)&v92 = v74;
        *((_QWORD *)&v92 + 1) = a1;
        *(_DWORD *)&v93[8] = v16;
        *(_QWORD *)v93 = v17;
        v39 = *(_QWORD *)(a1 + 64);
        do
        {
          if (!v39)
            break;
          v40 = *(_QWORD *)(v39 + 32);
          v41 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          v39 = v40;
        }
        while ((v41 & 1) != 0);
        *(_QWORD *)(v19 + 16) = 0;
        v42 = *(uint64_t **)(a1 + 88);
        *(_QWORD *)(v19 + 24) = v42;
        *v42 = v19;
        *(_QWORD *)(a1 + 88) = v19 + 16;
        *(_QWORD *)(v19 + 32) = 0;
        v43 = *(uint64_t **)(a3 + 8);
        *(_QWORD *)(v19 + 40) = v43;
        *v43 = v19;
        *(_QWORD *)(a3 + 8) = v19 + 32;
        *(_QWORD *)type = v13;
        v70 = 0x40000000;
        v71 = ___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke_26;
        v72 = &__block_descriptor_tmp_27_85857;
        v73 = a1;
        v44 = *(_QWORD *)(a1 + 64);
        do
        {
          if (!v44)
            break;
          v45 = *(_QWORD *)(v44 + 32);
          v46 = ((uint64_t (*)(os_log_type_t *))v71)(type);
          v44 = v45;
        }
        while ((v46 & 1) != 0);
        _Block_object_dispose(v74, 8);
        v12 = 1;
        goto LABEL_74;
      }
      if ((*(_BYTE *)(a1 + 136) & 1) != 0)
      {
LABEL_115:
        os_release((void *)v19);
        v12 = 0;
        goto LABEL_74;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 137;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = " ";
      LOWORD(v92) = 2048;
      *(_QWORD *)((char *)&v92 + 2) = a1;
      WORD5(v92) = 1024;
      HIDWORD(v92) = v76;
      v57 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v74[0]) = 0;
      if (__nwlog_fault(v57, type, v74))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v58 = __nwlog_obj();
          v59 = type[0];
          if (!os_log_type_enabled(v58, type[0]))
            goto LABEL_113;
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 137;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = " ";
          LOWORD(v92) = 2048;
          *(_QWORD *)((char *)&v92 + 2) = a1;
          WORD5(v92) = 1024;
          HIDWORD(v92) = v76;
          v60 = "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u)";
          goto LABEL_112;
        }
        if (!LOBYTE(v74[0]))
        {
          v58 = __nwlog_obj();
          v59 = type[0];
          if (!os_log_type_enabled(v58, type[0]))
            goto LABEL_113;
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 137;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = " ";
          LOWORD(v92) = 2048;
          *(_QWORD *)((char *)&v92 + 2) = a1;
          WORD5(v92) = 1024;
          HIDWORD(v92) = v76;
          v60 = "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u), backtrace limit exceeded";
          goto LABEL_112;
        }
        v63 = (char *)__nw_create_backtrace_string();
        v58 = __nwlog_obj();
        v59 = type[0];
        v64 = os_log_type_enabled(v58, type[0]);
        if (v63)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 137;
            *(_WORD *)&buf[22] = 2080;
            *(_QWORD *)&buf[24] = " ";
            LOWORD(v92) = 2048;
            *(_QWORD *)((char *)&v92 + 2) = a1;
            WORD5(v92) = 1024;
            HIDWORD(v92) = v76;
            *(_WORD *)v93 = 2082;
            *(_QWORD *)&v93[2] = v63;
            _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u), dumping backtrace:%{public}s", buf, 0x3Au);
          }
          free(v63);
          goto LABEL_113;
        }
        if (v64)
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 137;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = " ";
          LOWORD(v92) = 2048;
          *(_QWORD *)((char *)&v92 + 2) = a1;
          WORD5(v92) = 1024;
          HIDWORD(v92) = v76;
          v60 = "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u), no backtrace";
LABEL_112:
          _os_log_impl(&dword_182FBE000, v58, v59, v60, buf, 0x30u);
        }
      }
LABEL_113:
      if (v57)
        free(v57);
      goto LABEL_115;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    v30 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v74[0]) = 0;
    if (!__nwlog_fault(v30, type, v74))
      goto LABEL_55;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v31 = __nwlog_obj();
      v32 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        v33 = "%{public}s nw_frame_create(%u) failed";
LABEL_54:
        _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0x12u);
      }
    }
    else if (LOBYTE(v74[0]))
    {
      v34 = (char *)__nw_create_backtrace_string();
      v31 = __nwlog_obj();
      v32 = type[0];
      v35 = os_log_type_enabled(v31, type[0]);
      if (v34)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v16;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v34;
          _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s nw_frame_create(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v34);
        goto LABEL_55;
      }
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        v33 = "%{public}s nw_frame_create(%u) failed, no backtrace";
        goto LABEL_54;
      }
    }
    else
    {
      v31 = __nwlog_obj();
      v32 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        v33 = "%{public}s nw_frame_create(%u) failed, backtrace limit exceeded";
        goto LABEL_54;
      }
    }
LABEL_55:
    if (v30)
      free(v30);
    if (v17)
      free((void *)v17);
    v12 = 0;
    goto LABEL_74;
  }
  if ((*(_BYTE *)(a1 + 136) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v61 = __nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
      {
        v62 = *(unsigned __int16 *)(a1 + 132);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v92) = 2048;
        *(_QWORD *)((char *)&v92 + 2) = a1;
        WORD5(v92) = 1024;
        HIDWORD(v92) = v62;
        _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Fragments for IP ID %u incomplete", buf, 0x30u);
      }
    }
  }
  v12 = 0;
  if (a5)
    *a5 = 1;
LABEL_74:
  _Block_object_dispose(&v83, 8);
  _Block_object_dispose(&v87, 8);
  if (!a4)
    goto LABEL_85;
LABEL_75:
  for (i = 0; ; ++i)
  {
    v48 = *(_QWORD *)(a1 + 64);
    if (!v48)
      break;
    v49 = *(_QWORD *)(v48 + 32);
    v50 = *(_QWORD **)(v48 + 40);
    if (v49)
    {
      *(_QWORD *)(v49 + 40) = v50;
      v50 = *(_QWORD **)(v48 + 40);
    }
    else
    {
      *(_QWORD *)(a1 + 72) = v50;
    }
    *v50 = v49;
    *(_QWORD *)(v48 + 32) = 0;
    *(_QWORD *)(v48 + 40) = 0;
    nw_frame_finalize(v48);
  }
  if (i)
  {
    if ((*(_BYTE *)(a1 + 136) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v52 = *(unsigned __int16 *)(a1 + 132);
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_process_reassembly";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 137;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = " ";
        LOWORD(v92) = 2048;
        *(_QWORD *)((char *)&v92 + 2) = a1;
        WORD5(v92) = 1024;
        HIDWORD(v92) = v52;
        *(_WORD *)v93 = 1024;
        *(_DWORD *)&v93[2] = i;
        _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Failed to reassemble IP ID %u, dropping %u frames", buf, 0x36u);
      }
    }
  }
LABEL_85:
  if (!a5)
    goto LABEL_86;
  return v12;
}

uint64_t ___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  const char *v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  char *v19;
  _BOOL4 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  char *backtrace_string;
  _BOOL4 v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  char *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1[4] + 8);
  if (!*(_BYTE *)(v4 + 24))
  {
    if (a2)
    {
      v6 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
      goto LABEL_12;
    }
LABEL_49:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "__nw_frame_is_single_ip_aggregate";
    v30 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v30, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "__nw_frame_is_single_ip_aggregate";
          v33 = "%{public}s called with null frame";
LABEL_62:
          _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0xCu);
        }
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v31 = __nwlog_obj();
        v32 = type;
        v35 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            v39 = "__nw_frame_is_single_ip_aggregate";
            v40 = 2082;
            v41 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_63;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          v39 = "__nw_frame_is_single_ip_aggregate";
          v33 = "%{public}s called with null frame, no backtrace";
          goto LABEL_62;
        }
      }
      else
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "__nw_frame_is_single_ip_aggregate";
          v33 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_62;
        }
      }
    }
LABEL_63:
    if (v30)
      free(v30);
    LOBYTE(v15) = 0;
    v4 = *(_QWORD *)(a1[4] + 8);
    goto LABEL_13;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "__nw_frame_is_packet_chain_member";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v24, &type, &v36))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v39 = "__nw_frame_is_packet_chain_member";
      v27 = "%{public}s called with null frame";
    }
    else if (v36)
    {
      v28 = (char *)__nw_create_backtrace_string();
      v25 = __nwlog_obj();
      v26 = type;
      v29 = os_log_type_enabled(v25, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "__nw_frame_is_packet_chain_member";
          v40 = 2082;
          v41 = v28;
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v28);
        goto LABEL_47;
      }
      if (!v29)
      {
LABEL_47:
        if (v24)
          free(v24);
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      v39 = "__nw_frame_is_packet_chain_member";
      v27 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v39 = "__nw_frame_is_packet_chain_member";
      v27 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
    goto LABEL_47;
  }
  v5 = *(unsigned __int16 *)(a2 + 204);
  v6 = v5 | (*(unsigned __int8 *)(a2 + 206) << 16);
  if ((v5 & 0x40) == 0)
  {
LABEL_12:
    v15 = (v6 >> 7) & 1;
LABEL_13:
    *(_BYTE *)(v4 + 24) = v15;
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = nw_protocol_ipv4_process_input_frame(a1[9], a2, a1[8], a1[10], (_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24), (_DWORD *)(*(_QWORD *)(a1[7] + 8) + 24));
    if (*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
      return 1;
    --*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24);
    goto LABEL_15;
  }
  if (*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
    return 1;
  v7 = *(_QWORD *)(a1[6] + 8);
  v8 = *(_DWORD *)(v7 + 24);
  *(_DWORD *)(v7 + 24) = v8 - 1;
  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
    *(_DWORD *)buf = 136446978;
    v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
    v40 = 2082;
    v41 = "count";
    v42 = 2048;
    v43 = 1;
    v44 = 2048;
    v45 = v9;
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v10, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v13 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          v40 = 2082;
          v41 = "count";
          v42 = 2048;
          v43 = 1;
          v44 = 2048;
          v45 = v13;
          v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_29:
          _os_log_impl(&dword_182FBE000, v11, v12, v14, buf, 0x2Au);
        }
      }
      else if (v36)
      {
        v19 = (char *)__nw_create_backtrace_string();
        v11 = __nwlog_obj();
        v12 = type;
        v20 = os_log_type_enabled(v11, type);
        if (v19)
        {
          if (v20)
          {
            v21 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
            v40 = 2082;
            v41 = "count";
            v42 = 2048;
            v43 = 1;
            v44 = 2048;
            v45 = v21;
            v46 = 2082;
            v47 = v19;
            _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v19);
          goto LABEL_30;
        }
        if (v20)
        {
          v23 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          v40 = 2082;
          v41 = "count";
          v42 = 2048;
          v43 = 1;
          v44 = 2048;
          v45 = v23;
          v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_29;
        }
      }
      else
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          v22 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          v40 = 2082;
          v41 = "count";
          v42 = 2048;
          v43 = 1;
          v44 = 2048;
          v45 = v22;
          v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }
LABEL_30:
    if (v10)
      free(v10);
    *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = 0;
  }
LABEL_15:
  v16 = *(_QWORD *)(a2 + 32);
  v17 = *(_QWORD **)(a2 + 40);
  if (v16)
  {
    *(_QWORD *)(v16 + 40) = v17;
    v17 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(a1[8] + 8) = v17;
  }
  *v17 = v16;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

id nw_proxy_copy_http_connect_definition()
{
  if (nw_proxy_copy_http_connect_definition::onceToken != -1)
    dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_92);
  return (id)nw_proxy_copy_http_connect_definition::proxy_definition;
}

void tcp_connection_set_persistent(void *a1, int a2)
{
  void **v3;
  void **v4;
  xpc_object_t v5;
  xpc_object_t v6;
  xpc_object_t v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  BOOL v13;
  xpc_object_t v14;
  xpc_object_t v15;
  id v16;
  id v17;
  id v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  NSObject *v30;
  os_log_type_t v31;
  NSObject *v32;
  os_log_type_t v33;
  _QWORD applier[4];
  id v35;
  id v36;
  id v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = nw_parameters_copy_preferred_netagent_domains(v3[6]);
    v6 = nw_parameters_copy_preferred_netagent_types(v4[6]);
    v7 = v6;
    if (!a2)
    {
      if (v5)
        v13 = v6 == 0;
      else
        v13 = 1;
      if (!v13 && xpc_array_get_count(v5))
      {
        v14 = xpc_array_create(0, 0);
        v15 = xpc_array_create(0, 0);
        applier[0] = MEMORY[0x1E0C809B0];
        applier[1] = 3221225472;
        applier[2] = __tcp_connection_set_persistent_block_invoke;
        applier[3] = &unk_1E14A92E0;
        v35 = v7;
        v16 = v14;
        v36 = v16;
        v17 = v15;
        v37 = v17;
        xpc_array_apply(v5, applier);
        v18 = v16;

        v7 = v17;
        v5 = v18;
      }
      goto LABEL_52;
    }
    if (v5)
    {
      if (v6)
        goto LABEL_5;
    }
    else
    {
      v5 = xpc_array_create(0, 0);
      if (v7)
      {
LABEL_5:
        if (!v5)
          goto LABEL_28;
        goto LABEL_26;
      }
    }
    v7 = xpc_array_create(0, 0);
    if (!v5)
      goto LABEL_28;
LABEL_26:
    if (v7)
    {
      xpc_array_set_string(v5, 0xFFFFFFFFFFFFFFFFLL, "Persistent");
      xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "Persistent");
LABEL_52:
      nw_parameters_set_preferred_netagent_classes(v4[6], v5, v7);

      goto LABEL_53;
    }
LABEL_28:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v41 = "tcp_connection_set_persistent";
    v23 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v23, &type, &v38))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (id)gLogObj;
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "tcp_connection_set_persistent";
        v26 = "%{public}s xpc_array_create failed";
LABEL_47:
        v32 = v24;
        v33 = v25;
LABEL_48:
        _os_log_impl(&dword_182FBE000, v32, v33, v26, buf, 0xCu);
      }
    }
    else
    {
      if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v28 = type;
        v29 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v41 = "tcp_connection_set_persistent";
            v42 = 2082;
            v43 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v24, v28, "%{public}s xpc_array_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }
        if (!v29)
          goto LABEL_49;
        *(_DWORD *)buf = 136446210;
        v41 = "tcp_connection_set_persistent";
        v26 = "%{public}s xpc_array_create failed, no backtrace";
        v32 = v24;
        v33 = v28;
        goto LABEL_48;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (id)gLogObj;
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "tcp_connection_set_persistent";
        v26 = "%{public}s xpc_array_create failed, backtrace limit exceeded";
        goto LABEL_47;
      }
    }
LABEL_49:

LABEL_50:
    if (v23)
      free(v23);
    goto LABEL_52;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v41 = "tcp_connection_set_persistent";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v38 = 0;
  if (!__nwlog_fault(v9, &type, &v38))
    goto LABEL_22;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v41 = "tcp_connection_set_persistent";
    v12 = "%{public}s called with null connection";
LABEL_39:
    v30 = v10;
    v31 = v11;
LABEL_40:
    _os_log_impl(&dword_182FBE000, v30, v31, v12, buf, 0xCu);
    goto LABEL_41;
  }
  if (!v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v41 = "tcp_connection_set_persistent";
    v12 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_39;
  }
  v19 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (id)gLogObj;
  v20 = type;
  v21 = os_log_type_enabled(v10, type);
  if (v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "tcp_connection_set_persistent";
      v42 = 2082;
      v43 = v19;
      _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v19);
LABEL_22:
    if (!v9)
      goto LABEL_53;
    goto LABEL_42;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446210;
    v41 = "tcp_connection_set_persistent";
    v12 = "%{public}s called with null connection, no backtrace";
    v30 = v10;
    v31 = v20;
    goto LABEL_40;
  }
LABEL_41:

  if (v9)
LABEL_42:
    free(v9);
LABEL_53:

}

BOOL __nw_path_evaluator_trigger_agents_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  unsigned int *data;
  unsigned int *v7;
  _BOOL4 is_required;
  uint64_t v9;
  unsigned int v10;
  unsigned int *v11;
  _BOOL4 v12;
  _BOOL8 v13;
  NWConcrete_nw_path *v15;
  int v16;
  const char *v17;
  const char *v18;
  const char *v19;
  NSObject *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  _BYTE v24[12];
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  unsigned int *v32;
  __int16 v33;
  unsigned int *v34;
  __int16 v35;
  unsigned int v36;
  unsigned __int8 uu[24];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v5 = v4;
  *(_QWORD *)v24 = 0;
  if (!v4)
    goto LABEL_14;
  data = (unsigned int *)xpc_dictionary_get_data(v4, "data", (size_t *)v24);
  if (!data)
    goto LABEL_14;
  if (*(_QWORD *)v24 < 0xD8uLL)
    goto LABEL_14;
  v7 = data;
  if (*(_QWORD *)v24 != data[53] + 216)
    goto LABEL_14;
  is_required = nw_path_netagent_is_required(*(void **)(a1 + 32), v5);
  v9 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v9 + 376) == 3 && !*(_DWORD *)(v9 + 320))
  {
    v11 = v7 + 52;
    v10 = v7[52];
    if (((is_required | ((v10 & 0x40) >> 6)) & 1) != 0)
      goto LABEL_8;
LABEL_10:
    v12 = *(_BYTE *)(a1 + 72) != 0;
    goto LABEL_11;
  }
  v11 = v7 + 52;
  v10 = v7[52];
  if (!is_required)
    goto LABEL_10;
LABEL_8:
  v12 = 1;
LABEL_11:
  if ((v10 & 3) != 1 || (v10 & 0x40) == 0 && *(_BYTE *)(a1 + 73))
  {
LABEL_14:
    v13 = 1;
    goto LABEL_15;
  }
  v13 = 1;
  if ((!v12 & (v10 >> 4) & 1) == 0)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
    if ((v10 & 1) != 0 && (v10 & 0xC) != 0)
    {
      *(_OWORD *)uu = *(_OWORD *)v7;
      if (!uuid_is_null(uu))
      {
        v15 = *(NWConcrete_nw_path **)(a1 + 32);
        if ((*((_BYTE *)v11 + 1) & 2) != 0)
        {
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = nw_path_agent_action(v15, uu, 131);
          v16 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
          v17 = "assert";
          v18 = "assert failed";
        }
        else
        {
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = nw_path_agent_action(v15, uu, 130);
          v16 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
          v17 = "triggered";
          v18 = "trigger failed";
        }
        if (v16)
          v19 = v17;
        else
          v19 = v18;
        if (__nwlog_path_log::onceToken[0] != -1)
          dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44205);
        v20 = (id)gpathLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          v21 = *(_QWORD *)(a1 + 40) + 80;
          v22 = v7[52];
          *(_DWORD *)v24 = 136447746;
          *(_QWORD *)&v24[4] = "nw_path_evaluator_trigger_agents_block_invoke";
          v25 = 1042;
          v26 = 16;
          v27 = 2098;
          v28 = v21;
          v29 = 2082;
          v30 = v19;
          v31 = 2082;
          v32 = v7 + 4;
          v33 = 2082;
          v34 = v7 + 12;
          v35 = 1024;
          v36 = v22;
          _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public,uuid_t}.16P] agent %{public}s %{public}s:%{public}s flags: 0x%x", v24, 0x40u);
        }

        v23 = *(void **)(a1 + 48);
        if (v23 && object_getClass(v23) == (Class)MEMORY[0x1E0C812C8])
          xpc_array_set_uuid(*(xpc_object_t *)(a1 + 48), 0xFFFFFFFFFFFFFFFFLL, uu);
      }
      v13 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) != 0;
    }
  }
LABEL_15:

  return v13;
}

void sub_182FF8658(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

xpc_object_t nw_parameters_copy_preferred_netagent_types(void *a1)
{
  NWConcrete_nw_parameters *v1;
  const char *v2;
  const char *v3;
  NWConcrete_nw_parameters *v4;
  NWConcrete_nw_path_parameters *path_parameters;
  OS_nw_interface *required_interface;
  xpc_object_t v7;
  int agent_preference;
  NSObject *v9;
  xpc_object_t v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v4 = v1;
  if (v1)
  {
    path_parameters = v1->path_parameters;
    required_interface = path_parameters->required_interface;
    if (required_interface)
    {
      v7 = *((id *)required_interface + 11);
      path_parameters = v4->path_parameters;
    }
    else
    {
      v7 = 0;
    }
    if (path_parameters->path_value.companion_preference == 1)
    {
      agent_preference = nw_parameters_get_agent_preference(v4, v2, v3);
      if (agent_preference)
      {
        if (agent_preference == 2)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v23 = "nw_parameters_copy_preferred_netagent_types";
            _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Parameters companion_preferece is prefer but companion is in avoided array", buf, 0xCu);
          }

        }
      }
      else
      {
        if (v7)
        {
          v10 = xpc_copy(*((xpc_object_t *)v4->path_parameters->required_interface + 11));

          v7 = v10;
        }
        else
        {
          v7 = xpc_array_create(0, 0);
        }
        xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "CompanionProxy");
      }
    }
    goto LABEL_15;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_parameters_copy_preferred_netagent_types";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_preferred_netagent_types";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_parameters_copy_preferred_netagent_types";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_preferred_netagent_types";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_preferred_netagent_types";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_32:
  if (v13)
    free(v13);
  v7 = 0;
LABEL_15:

  return v7;
}

void sub_182FF8A08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

xpc_object_t nw_parameters_copy_preferred_netagent_domains(void *a1)
{
  NWConcrete_nw_parameters *v1;
  const char *v2;
  const char *v3;
  NWConcrete_nw_parameters *v4;
  NWConcrete_nw_path_parameters *path_parameters;
  OS_nw_interface *required_interface;
  xpc_object_t v7;
  int agent_preference;
  NSObject *v9;
  xpc_object_t v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v4 = v1;
  if (v1)
  {
    path_parameters = v1->path_parameters;
    required_interface = path_parameters->required_interface;
    if (required_interface)
    {
      v7 = *((id *)required_interface + 10);
      path_parameters = v4->path_parameters;
    }
    else
    {
      v7 = 0;
    }
    if (path_parameters->path_value.companion_preference == 1)
    {
      agent_preference = nw_parameters_get_agent_preference(v4, v2, v3);
      if (agent_preference)
      {
        if (agent_preference == 2)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v23 = "nw_parameters_copy_preferred_netagent_domains";
            _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Parameters companion_preferece is prefer but companion is in avoided array", buf, 0xCu);
          }

        }
      }
      else
      {
        if (v7)
        {
          v10 = xpc_copy(*((xpc_object_t *)v4->path_parameters->required_interface + 10));

          v7 = v10;
        }
        else
        {
          v7 = xpc_array_create(0, 0);
        }
        xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "com.apple.networkrelay");
      }
    }
    goto LABEL_15;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_parameters_copy_preferred_netagent_domains";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_preferred_netagent_domains";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_parameters_copy_preferred_netagent_domains";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_preferred_netagent_domains";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_preferred_netagent_domains";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_32:
  if (v13)
    free(v13);
  v7 = 0;
LABEL_15:

  return v7;
}

void sub_182FF8DB0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_parameters_set_preferred_netagent_classes(void *a1, void *a2, void *a3)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  Class Class;
  objc_class *v15;
  size_t count;
  xpc_object_t v17;
  uint64_t v18;
  void *v19;
  xpc_object_t v20;
  uint64_t v21;
  void *v22;
  void *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  NSObject *v30;
  void *v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  _BYTE applier[24];
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = (void *)v7;
  if (!v5)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "nw_parameters_set_preferred_netagent_classes";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v24, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "nw_parameters_set_preferred_netagent_classes";
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null parameters", applier, 0xCu);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)applier = 136446466;
            *(_QWORD *)&applier[4] = "nw_parameters_set_preferred_netagent_classes";
            *(_WORD *)&applier[12] = 2082;
            *(_QWORD *)&applier[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s called with null parameters, dumping backtrace:%{public}s", applier, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }
        if (v29)
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "nw_parameters_set_preferred_netagent_classes";
          _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s called with null parameters, no backtrace", applier, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "nw_parameters_set_preferred_netagent_classes";
          _os_log_impl(&dword_182FBE000, v25, v32, "%{public}s called with null parameters, backtrace limit exceeded", applier, 0xCu);
        }
      }

    }
LABEL_39:
    if (v24)
      free(v24);
    goto LABEL_20;
  }
  v9 = *(_QWORD *)(v5[13] + 176);
  if (v9)
  {
LABEL_6:
    v11 = *(void **)(v9 + 80);
    *(_QWORD *)(v9 + 80) = 0;

    v12 = *(_QWORD *)(v5[13] + 176);
    v13 = *(void **)(v12 + 88);
    *(_QWORD *)(v12 + 88) = 0;

    if (v6)
    {
      Class = object_getClass((id)v6);
      if (v8)
      {
        v15 = (objc_class *)MEMORY[0x1E0C812C8];
        if (Class == (Class)MEMORY[0x1E0C812C8] && object_getClass(v8) == v15)
        {
          count = xpc_array_get_count((xpc_object_t)v6);
          if (count == xpc_array_get_count(v8))
          {
            if (object_getClass((id)v6) == v15
              && (*(_QWORD *)applier = MEMORY[0x1E0C809B0],
                  *(_QWORD *)&applier[8] = 0x40000000,
                  *(_QWORD *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke,
                  v36 = (uint64_t)&__block_descriptor_tmp_86211,
                  v37 = MEMORY[0x1E0C81390],
                  xpc_array_apply((xpc_object_t)v6, applier)))
            {
              v17 = xpc_retain((xpc_object_t)v6);
            }
            else
            {
              v17 = 0;
            }
            v18 = *(_QWORD *)(v5[13] + 176);
            v19 = *(void **)(v18 + 80);
            *(_QWORD *)(v18 + 80) = v17;

            if (object_getClass(v8) == v15
              && (*(_QWORD *)applier = MEMORY[0x1E0C809B0],
                  *(_QWORD *)&applier[8] = 0x40000000,
                  *(_QWORD *)&applier[16] = __nw_xpc_retain_array_with_validated_types_block_invoke,
                  v36 = (uint64_t)&__block_descriptor_tmp_86211,
                  v37 = MEMORY[0x1E0C81390],
                  xpc_array_apply(v8, applier)))
            {
              v20 = xpc_retain(v8);
            }
            else
            {
              v20 = 0;
            }
            v21 = *(_QWORD *)(v5[13] + 176);
            v22 = *(void **)(v21 + 88);
            *(_QWORD *)(v21 + 88) = v20;

          }
        }
      }
    }
    goto LABEL_20;
  }
  if (!(v6 | v7))
  {
LABEL_20:

    return;
  }
  v10 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
  if (v10)
  {
LABEL_5:
    *(_QWORD *)(v5[13] + 176) = v10;
    v9 = *(_QWORD *)(v5[13] + 176);
    goto LABEL_6;
  }
  __nwlog_obj();
  v30 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446722;
  *(_QWORD *)&applier[4] = "strict_calloc";
  *(_WORD *)&applier[12] = 2048;
  *(_QWORD *)&applier[14] = 1;
  *(_WORD *)&applier[22] = 2048;
  v36 = 144;
  v31 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v31))
  {
    free(v31);
    goto LABEL_5;
  }
  __break(1u);
}

void sub_182FF92C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_2(uint64_t a1)
{
  nw_mem_buffer_free(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

_QWORD *sub_182FF92F4(_QWORD *result, int a2)
{
  uint64_t v2;

  if (a2 < 0)
  {
    v2 = a2 ^ 0x80000000;
    result[1] = 0;
  }
  else
  {
    if (!a2)
      return result;
    v2 = (a2 - 1);
  }
  *result = v2;
  return result;
}

BOOL nw_settings_get_quic_enabled()
{
  const char *v0;
  void *v1;
  Class Class;
  _BOOL8 v3;
  xpc_object_t value;
  void *v5;

  v0 = (const char *)nw_setting_enable_quic;
  networkd_settings_init();
  if (!sCachedSettings)
    return 0;
  pthread_mutex_lock(&sSettingsMutex);
  v1 = (void *)sCachedSettings;
  if (!sCachedSettings)
    goto LABEL_7;
  Class = object_getClass((id)sCachedSettings);
  v3 = 0;
  if (!v0 || Class != (Class)MEMORY[0x1E0C812F8])
    goto LABEL_8;
  value = xpc_dictionary_get_value(v1, v0);
  if (value && (v5 = value, object_getClass(value) == (Class)MEMORY[0x1E0C812D0]))
    v3 = xpc_BOOL_get_value(v5);
  else
LABEL_7:
    v3 = 0;
LABEL_8:
  pthread_mutex_unlock(&sSettingsMutex);
  return v3;
}

BOOL network_config_get_tcp_accurate_ecn_enabled()
{
  void *v0;
  void *v1;
  BOOL value;

  v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_accurate_ecn, 0);
  v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1E0C812D0])
  {
    value = xpc_BOOL_get_value(v1);

    if (value)
      return 1;
  }
  else
  {

  }
  if (nw_settings_get_l4s_enabled_internal::onceToken != -1)
    dispatch_once(&nw_settings_get_l4s_enabled_internal::onceToken, &__block_literal_global_63599);
  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_182FF94BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL network_config_setting_exists(const char *a1)
{
  void *v1;
  _BOOL8 v2;

  v1 = networkd_settings_copy_value_of_type(a1, 0);
  v2 = v1 != 0;

  return v2;
}

void *networkd_settings_copy_value_of_type(const char *a1, objc_class *a2)
{
  void *v4;
  Class Class;
  void *v6;
  xpc_object_t value;

  networkd_settings_init();
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    v4 = (void *)sCachedSettings;
    if (sCachedSettings)
    {
      Class = object_getClass((id)sCachedSettings);
      v6 = 0;
      if (!a1 || Class != (Class)MEMORY[0x1E0C812F8])
        goto LABEL_12;
      value = xpc_dictionary_get_value(v4, a1);
      v6 = value;
      if (a2 && value)
      {
        if (object_getClass(value) != a2)
          goto LABEL_8;
      }
      else if (!value)
      {
        goto LABEL_12;
      }
      xpc_retain(v6);
      goto LABEL_12;
    }
LABEL_8:
    v6 = 0;
LABEL_12:
    pthread_mutex_unlock(&sSettingsMutex);
    return v6;
  }
  return 0;
}

uint64_t nw_endpoint_handler_get_child_timeout_nanos(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  NSObject *v3;
  const sockaddr *address;
  id *v5;
  id v6;
  uint64_t v7;
  unint64_t v8;
  const char *v9;
  int64_t int64;
  const char *v11;
  int64_t v12;
  const char *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[32];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_endpoint_handler_copy_endpoint(v1);
    if (nw_endpoint_get_type(v3) == nw_endpoint_type_address)
      address = nw_endpoint_get_address(v3);
    else
      address = 0;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v30 = 0u;
    memset(buf, 0, sizeof(buf));
    v5 = v2;
    os_unfair_lock_lock(v2 + 28);
    v6 = v5[8];
    os_unfair_lock_unlock(v2 + 28);

    if (v6 && nw_path_fillout_route_stats(v6, (uint64_t)buf, 0))
    {
      if (DWORD2(v34))
      {
        LODWORD(v7) = 8 * HIDWORD(v34) + (DWORD2(v34) >> 2);
        if (v7 <= DWORD2(v34))
          v7 = DWORD2(v34);
        else
          v7 = v7;
        v8 = 31250 * (v7 + DWORD2(v34));
        goto LABEL_23;
      }
    }
    else
    {
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v30 = 0u;
      memset(buf, 0, sizeof(buf));
    }
    if (address && address->sa_family == 2)
    {
      v8 = 250000000;
      v9 = (const char *)nw_setting_tcpconn_ipv4_delay;
    }
    else
    {
      v8 = 250000000;
      v9 = (const char *)nw_setting_tcpconn_ipv6_delay;
    }
    networkd_settings_init();
    if (sCachedSettings)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (sCachedSettings)
      {
        int64 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v9);
        pthread_mutex_unlock(&sSettingsMutex);
        if (int64)
          v8 = 1000000 * int64;
      }
      else
      {
        pthread_mutex_unlock(&sSettingsMutex);
      }
    }
LABEL_23:
    v11 = (const char *)nw_setting_tcpconn_min_delay;
    networkd_settings_init();
    if (sCachedSettings)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (sCachedSettings)
        v12 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v11);
      else
        v12 = 0;
      pthread_mutex_unlock(&sSettingsMutex);
    }
    else
    {
      v12 = 0;
    }
    v13 = (const char *)nw_setting_tcpconn_max_delay;
    networkd_settings_init();
    if (sCachedSettings)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (sCachedSettings)
        v14 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v13);
      else
        v14 = 0;
      pthread_mutex_unlock(&sSettingsMutex);
      v15 = 100000000;
      if (v12)
        v15 = v12;
      if (v14)
        goto LABEL_40;
    }
    else
    {
      v15 = 100000000;
      if (v12)
        v15 = v12;
    }
    v14 = 2000000000;
LABEL_40:
    if (v8 >= v14)
      v16 = v14;
    else
      v16 = v8;
    if (v8 >= v15)
      v17 = v16;
    else
      v17 = v15;

    goto LABEL_47;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
  v20 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v20, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null child_handler", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null child_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_64;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
        _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null child_handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_child_timeout_nanos";
        _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null child_handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_64:
  if (v20)
    free(v20);
  v17 = 100000000;
LABEL_47:

  return v17;
}

void sub_182FF9A7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t sa_dst_compare_internal(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  unint64_t v6;
  int v10;
  int v11;
  int v12;
  _BOOL4 v13;
  int v14;
  char v15;
  NSObject *v16;
  const char *v17;
  int v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  const char *v23;
  NSObject *v24;
  const char *v25;
  unsigned int v26;
  BOOL v27;
  char v28;
  char v29;
  unsigned int v30;
  int64_t int64_with_default;
  unsigned int v32;
  uint64_t v33;
  int64_t v34;
  int v35;
  int v36;
  unsigned int v37;
  NSObject *v38;
  NSObject *v39;
  uint32_t v40;
  unsigned int v41;
  unsigned int v42;
  BOOL v43;
  unsigned int v44;
  unsigned int v45;
  BOOL v46;
  unsigned int v47;
  unsigned int v48;
  BOOL v49;
  unsigned int v50;
  unsigned int v51;
  BOOL v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned int v56;
  unsigned int v57;
  BOOL v58;
  int v59;
  int v60;
  _BOOL4 v61;
  unsigned int v62;
  unsigned int v63;
  BOOL v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  NSObject *v68;
  unsigned int v69;
  unsigned int v70;
  NSObject *v71;
  NSObject *v72;
  uint32_t v73;
  unsigned int v74;
  unsigned int v75;
  NSObject *v76;
  unsigned int v77;
  unsigned int v78;
  NSObject *v79;
  int64_t v80;
  uint64_t v81;
  int64_t v82;
  int v83;
  int v84;
  unsigned int v85;
  NSObject *v86;
  _BOOL4 v87;
  _BOOL4 v88;
  NSObject *v89;
  const char *v91;
  NSObject *v92;
  uint32_t v93;
  _BOOL4 v94;
  unsigned int v95;
  unsigned int v96;
  _BOOL4 v97;
  _BOOL4 v98;
  char *v99;
  NSObject *v100;
  os_log_type_t v101;
  const char *v102;
  unsigned int v103;
  NSObject *v104;
  int v105;
  int v106;
  int v107;
  char *backtrace_string;
  _BOOL4 v110;
  const char *v111;
  _BOOL4 v112;
  uint64_t v113;
  int v114;
  int v115;
  NSObject *log;
  unsigned int v117;
  NSObject *v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  int64_t v123;
  unsigned int v124;
  _BYTE type[64];
  __int128 v126;
  __int128 v127;
  _BYTE v128[64];
  __int128 v129;
  __int128 v130;
  uint8_t buf[4];
  const char *v132;
  __int16 v133;
  _BYTE v134[10];
  double v135;
  __int16 v136;
  unsigned int v137;
  __int16 v138;
  unsigned int v139;
  uint64_t v140;

  v140 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a3)
    {
      LODWORD(v6) = a5;
      pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
      pthread_once(&cache_init, (void (*)(void))sa_dst_compare_init_once);
      v10 = a1[1];
      if (v10 != 2 && v10 != 30)
      {
        v18 = a3[1];
        v19 = v18 == 2 || v18 == 30;
        v20 = v19;
        v21 = (v20 << 31 >> 31);
        goto LABEL_387;
      }
      v11 = a3[1];
      if (v11 != 2 && v11 != 30)
      {
        v21 = 1;
        goto LABEL_387;
      }
      v129 = 0u;
      v130 = 0u;
      memset(v128, 0, sizeof(v128));
      v126 = 0u;
      v127 = 0u;
      memset(type, 0, sizeof(type));
      v12 = sa_dst_lookup(a1, a2, v128);
      v13 = sa_dst_lookup(a3, a4, type);
      if (v12)
      {
        v14 = v13;
        if (v13)
        {
          if ((_DWORD)v6)
          {
            if (networkd_settings_get_BOOL((const char *)nw_setting_compare_bypass_stats))
            {
LABEL_11:
              LODWORD(v6) = 0;
              goto LABEL_12;
            }
            v28 = BYTE12(v130);
            v29 = BYTE12(v127);
            if ((BYTE12(v130) & 1) != 0)
            {
              if ((BYTE12(v127) & 1) == 0)
              {
                v16 = __nwlog_obj();
                if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446210;
                  v132 = "sa_dst_compare_statistics";
                  v17 = "%{public}s prefer 1, dst 2 has no route";
                  goto LABEL_384;
                }
LABEL_386:
                v21 = 1;
                goto LABEL_387;
              }
              v59 = (BYTE12(v130) >> 2) & 1;
              v60 = (BYTE12(v127) >> 2) & 1;
              if (v59 != v60)
              {
                if (v60)
                {
                  v16 = __nwlog_obj();
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_statistics";
                    v17 = "%{public}s prefer dst 1, dst 2 is p2p, dst 1 is not";
                    goto LABEL_384;
                  }
                  goto LABEL_386;
                }
                if (v59)
                {
                  v24 = __nwlog_obj();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_statistics";
                    v25 = "%{public}s prefer dst 2, dst 1 is p2p, dst 2 is not";
                    goto LABEL_352;
                  }
                  goto LABEL_354;
                }
              }
              if (nw_interface_get_loopback_index::onceToken[0] != -1)
                dispatch_once(nw_interface_get_loopback_index::onceToken, &__block_literal_global_87884);
              if (HIDWORD(v129) == nw_interface_get_loopback_index::index)
              {
                v61 = 1;
              }
              else
              {
                v61 = 0;
                if (v128[1] == 30 && v128[8] == 254)
                  v61 = (v128[9] & 0xC0) == 0x80 && *(_DWORD *)&v128[24] == nw_interface_get_loopback_index::index;
              }
              if (HIDWORD(v126) == nw_interface_get_loopback_index::index)
              {
                v97 = 1;
              }
              else
              {
                v97 = 0;
                if (type[1] == 30 && type[8] == 254)
                  v97 = (type[9] & 0xC0) == 0x80 && *(_DWORD *)&type[24] == nw_interface_get_loopback_index::index;
                if (v61 && !v97)
                {
                  v16 = __nwlog_obj();
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_statistics";
                    v17 = "%{public}s prefer 1, dst 1 is loopback, dst 2 is not";
                    goto LABEL_384;
                  }
                  goto LABEL_386;
                }
              }
              if (v97 && !v61)
              {
                v24 = __nwlog_obj();
                if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446210;
                  v132 = "sa_dst_compare_statistics";
                  v25 = "%{public}s prefer 2, dst 2 is loopback, dst 1 is not";
                  goto LABEL_352;
                }
                goto LABEL_354;
              }
              if ((v28 & 2) != 0)
              {
                if ((v29 & 2) == 0)
                {
                  v16 = __nwlog_obj();
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_statistics";
                    v17 = "%{public}s prefer 1, dst 1 is local, dst 2 is not";
                    goto LABEL_384;
                  }
                  goto LABEL_386;
                }
                if (DWORD2(v129) == DWORD2(v126))
                  goto LABEL_11;
              }
              else if ((v29 & 2) != 0)
              {
                v24 = __nwlog_obj();
                if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446210;
                  v132 = "sa_dst_compare_statistics";
                  v25 = "%{public}s prefer 2, dst 2 is local, dst 1 is not";
                  goto LABEL_352;
                }
                goto LABEL_354;
              }
            }
            else if ((BYTE12(v127) & 1) != 0)
            {
              v24 = __nwlog_obj();
              if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                goto LABEL_354;
              *(_DWORD *)buf = 136446210;
              v132 = "sa_dst_compare_statistics";
              v25 = "%{public}s prefer 2, dst 1 has no route";
              goto LABEL_352;
            }
            LODWORD(v6) = v130;
            v30 = v127;
            if ((_DWORD)v130)
            {
              if (!(_DWORD)v127)
              {
                if (DWORD2(v127))
                  goto LABEL_11;
                v6 = DWORD1(v127);
                if (!DWORD1(v127))
                  goto LABEL_12;
                if (networkd_settings_get_int64_with_default((const char *)nw_setting_compare_failure_threshold, 10) >= v6)
                  goto LABEL_11;
                v79 = __nwlog_obj();
                if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
                  goto LABEL_386;
                *(_DWORD *)buf = 136446466;
                v132 = "sa_dst_compare_statistics";
                v133 = 1024;
                *(_DWORD *)v134 = v6;
                v17 = "%{public}s prefer 1, dst 2 has no successful connections and %u attempts";
                v39 = v79;
                v40 = 18;
LABEL_385:
                _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, v17, buf, v40);
                goto LABEL_386;
              }
              if (v130 < v127)
              {
                int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_rtt_leeway, 3200);
                if (int64_with_default <= 31999)
                  v32 = int64_with_default;
                else
                  v32 = 32000;
                v122 = v30;
                if (int64_with_default >= 0)
                  v33 = v32;
                else
                  v33 = 3200;
                v34 = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_rtt_leeway_small, 320);
                if (v34 >= v33)
                  v35 = v33;
                else
                  v35 = v34;
                if (v34 >= 0)
                  v36 = v35;
                else
                  v36 = 320;
                if ((int)v33 + (int)v6 < v122)
                {
                  v37 = v36;
                  v38 = __nwlog_obj();
                  if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
                    goto LABEL_386;
                  *(_DWORD *)buf = 136447234;
                  v132 = "sa_dst_compare_statistics";
                  v133 = 2048;
                  *(double *)v134 = (double)v6 * 0.03125;
                  *(_WORD *)&v134[8] = 2048;
                  v135 = (double)v122 * 0.03125;
                  v136 = 1024;
                  v137 = v33 >> 5;
                  v138 = 1024;
                  v139 = v37 >> 5;
                  v17 = "%{public}s prefering 1, dst1 min rtt %f < dst2 min rtt %f, leeway %u small leeway %u";
                  v39 = v38;
                  v40 = 44;
                  goto LABEL_385;
                }
                v117 = v36;
                v119 = v36 + v6;
                log = __nwlog_obj();
                v88 = os_log_type_enabled(log, OS_LOG_TYPE_DEBUG);
                if (v119 < v122)
                {
                  if (v88)
                  {
                    *(_DWORD *)buf = 136447234;
                    v132 = "sa_dst_compare_statistics";
                    v133 = 2048;
                    *(double *)v134 = (double)v6 * 0.03125;
                    *(_WORD *)&v134[8] = 2048;
                    v135 = (double)v122 * 0.03125;
                    v136 = 1024;
                    v137 = v33 >> 5;
                    v138 = 1024;
                    v139 = v117 >> 5;
                    _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s prefering 1 slightly, dst1 min rtt %f < dst2 min rtt %f, leeway %u small leeway %u", buf, 0x2Cu);
                  }
                  v15 = 0;
                  LODWORD(v6) = 1;
                  goto LABEL_13;
                }
                if (!v88)
                  goto LABEL_11;
                *(_DWORD *)buf = 136447234;
                v132 = "sa_dst_compare_statistics";
                v133 = 2048;
                *(double *)v134 = (double)v6 * 0.03125;
                *(_WORD *)&v134[8] = 2048;
                v135 = (double)v122 * 0.03125;
                v136 = 1024;
                v137 = v33 >> 5;
                v138 = 1024;
                v139 = v117 >> 5;
                v91 = "%{public}s not prefering 1, dst1 min rtt %f < dst2 min rtt %f, leeway %u small leeway %u";
                v92 = log;
                goto LABEL_376;
              }
              if (v130 <= v127)
              {
                v89 = __nwlog_obj();
                if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
                  goto LABEL_11;
                *(_DWORD *)buf = 136446466;
                v132 = "sa_dst_compare_statistics";
                v133 = 2048;
                *(double *)v134 = (double)v6 * 0.03125;
                v91 = "%{public}s no preference, equal min rtt %f";
                v92 = v89;
                v93 = 22;
                goto LABEL_377;
              }
              v80 = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_rtt_leeway, 3200);
              if (v80 <= 31999)
                LODWORD(v81) = v80;
              else
                LODWORD(v81) = 32000;
              if (v80 >= 0)
                v81 = v81;
              else
                v81 = 3200;
              v123 = v81;
              v82 = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_rtt_leeway_small, 320);
              if (v82 >= v123)
                v83 = v123;
              else
                v83 = v82;
              if (v82 >= 0)
                v84 = v83;
              else
                v84 = 320;
              if (v6 <= v123 + v30)
              {
                v120 = v84;
                v121 = v84 + v30;
                v118 = __nwlog_obj();
                v98 = os_log_type_enabled(v118, OS_LOG_TYPE_DEBUG);
                if (v6 > v121)
                {
                  if (v98)
                  {
                    *(_DWORD *)buf = 136447234;
                    v132 = "sa_dst_compare_statistics";
                    v133 = 2048;
                    *(double *)v134 = (double)v6 * 0.03125;
                    *(_WORD *)&v134[8] = 2048;
                    v135 = (double)v30 * 0.03125;
                    v136 = 1024;
                    v137 = v123 >> 5;
                    v138 = 1024;
                    v139 = v120 >> 5;
                    _os_log_impl(&dword_182FBE000, v118, OS_LOG_TYPE_DEBUG, "%{public}s prefering 2 slightly, dst1 min rtt %f > dst2 min rtt %f, leeway %u small leeway %u", buf, 0x2Cu);
                  }
                  LODWORD(v6) = 0;
                  v15 = 1;
                  goto LABEL_13;
                }
                if (!v98)
                  goto LABEL_11;
                *(_DWORD *)buf = 136447234;
                v132 = "sa_dst_compare_statistics";
                v133 = 2048;
                *(double *)v134 = (double)v6 * 0.03125;
                *(_WORD *)&v134[8] = 2048;
                v135 = (double)v30 * 0.03125;
                v136 = 1024;
                v137 = v123 >> 5;
                v138 = 1024;
                v139 = v120 >> 5;
                v91 = "%{public}s not prefering 2, dst1 min rtt %f > dst2 min rtt %f, leeway %u small leeway %u";
                v92 = v118;
LABEL_376:
                v93 = 44;
LABEL_377:
                _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_DEBUG, v91, buf, v93);
                goto LABEL_11;
              }
              v85 = v84;
              v86 = __nwlog_obj();
              if (!os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
                goto LABEL_354;
              *(_DWORD *)buf = 136447234;
              v132 = "sa_dst_compare_statistics";
              v133 = 2048;
              *(double *)v134 = (double)v6 * 0.03125;
              *(_WORD *)&v134[8] = 2048;
              v135 = (double)v30 * 0.03125;
              v136 = 1024;
              v137 = v123 >> 5;
              v138 = 1024;
              v139 = v85 >> 5;
              v25 = "%{public}s prefering 2, dst1 min rtt %f > dst2 min rtt %f, leeway %u small leeway %u";
              v72 = v86;
              v73 = 44;
LABEL_353:
              _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_DEBUG, v25, buf, v73);
              goto LABEL_354;
            }
            if (!(_DWORD)v127)
            {
              v15 = v130;
              goto LABEL_13;
            }
            v15 = v130;
            if (DWORD2(v130))
            {
LABEL_13:
              if (v128[37])
              {
                if (!type[37])
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v16 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_rfc6724";
                    v17 = "%{public}s Rule 1, prefer d1, d2 is not routable";
LABEL_384:
                    v39 = v16;
                    v40 = 12;
                    goto LABEL_385;
                  }
                  goto LABEL_386;
                }
LABEL_34:
                if (v128[1] == 2)
                {
                  v41 = bswap32(*(unsigned int *)&v128[4]);
                  v27 = (v41 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v41) == 127;
                  v26 = 14;
                }
                else
                {
                  if (v128[1] != 30)
                  {
                    v26 = 0;
                    goto LABEL_70;
                  }
                  if (v128[8] == 255)
                  {
                    v66 = (v128[9] & 0xF) - 1;
                    if (v66 >= 5)
                      v26 = 14;
                    else
                      v26 = dword_183C6E2E4[v66];
                    goto LABEL_70;
                  }
                  if (v128[8] == 254)
                  {
                    if (v128[9] <= 0xBFu)
                      v26 = 14;
                    else
                      v26 = 5;
                    v27 = (v128[9] & 0xC0) == 128;
                  }
                  else
                  {
                    v26 = 14;
                    if (*(_QWORD *)&v128[8] | *(_QWORD *)&v128[15])
                      goto LABEL_70;
                    v27 = v128[23] == 1;
                  }
                }
                if (v27)
                  v26 = 2;
LABEL_70:
                if (v128[37] == 2)
                {
                  v44 = bswap32(*(unsigned int *)&v128[40]);
                  v43 = (v44 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v44) == 127;
                  v42 = 14;
                }
                else
                {
                  if (v128[37] != 30)
                  {
                    v42 = 0;
                    goto LABEL_86;
                  }
                  if (v128[44] == 255)
                  {
                    v67 = (v128[45] & 0xF) - 1;
                    if (v67 >= 5)
                      v42 = 14;
                    else
                      v42 = dword_183C6E2E4[v67];
                    goto LABEL_86;
                  }
                  if (v128[44] == 254)
                  {
                    if (v128[45] <= 0xBFu)
                      v42 = 14;
                    else
                      v42 = 5;
                    v43 = (v128[45] & 0xC0) == 128;
                  }
                  else
                  {
                    v42 = 14;
                    if (*(_QWORD *)&v128[44] | *(_QWORD *)&v128[51])
                      goto LABEL_86;
                    v43 = v128[59] == 1;
                  }
                }
                if (v43)
                  v42 = 2;
LABEL_86:
                if (v26 != v42)
                  goto LABEL_123;
                if (type[1] == 2)
                {
                  v47 = bswap32(*(unsigned int *)&type[4]);
                  v46 = (v47 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v47) == 127;
                  v45 = 14;
                }
                else
                {
                  if (type[1] != 30)
                  {
                    v45 = 0;
                    goto LABEL_106;
                  }
                  if (type[8] == 255)
                  {
                    v74 = (type[9] & 0xF) - 1;
                    if (v74 >= 5)
                      v45 = 14;
                    else
                      v45 = dword_183C6E2E4[v74];
                    goto LABEL_106;
                  }
                  if (type[8] == 254)
                  {
                    if (type[9] <= 0xBFu)
                      v45 = 14;
                    else
                      v45 = 5;
                    v46 = (type[9] & 0xC0) == 128;
                  }
                  else
                  {
                    v45 = 14;
                    if (*(_QWORD *)&type[8] | *(_QWORD *)&type[15])
                      goto LABEL_106;
                    v46 = type[23] == 1;
                  }
                }
                if (v46)
                  v45 = 2;
LABEL_106:
                if (type[37] == 2)
                {
                  v50 = bswap32(*(unsigned int *)&type[40]);
                  v49 = (v50 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v50) == 127;
                  v48 = 14;
                }
                else
                {
                  if (type[37] != 30)
                  {
                    v48 = 0;
                    goto LABEL_122;
                  }
                  if (type[44] == 255)
                  {
                    v75 = (type[45] & 0xF) - 1;
                    if (v75 >= 5)
                      v48 = 14;
                    else
                      v48 = dword_183C6E2E4[v75];
                    goto LABEL_122;
                  }
                  if (type[44] == 254)
                  {
                    if (type[45] <= 0xBFu)
                      v48 = 14;
                    else
                      v48 = 5;
                    v49 = (type[45] & 0xC0) == 128;
                  }
                  else
                  {
                    v48 = 14;
                    if (*(_QWORD *)&type[44] | *(_QWORD *)&type[51])
                      goto LABEL_122;
                    v49 = type[59] == 1;
                  }
                }
                if (v49)
                  v48 = 2;
LABEL_122:
                if (v45 == v48)
                  goto LABEL_200;
LABEL_123:
                if (v128[1] == 2)
                {
                  v53 = bswap32(*(unsigned int *)&v128[4]);
                  v52 = (v53 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v53) == 127;
                  v51 = 14;
                }
                else
                {
                  if (v128[1] != 30)
                  {
                    v51 = 0;
                    goto LABEL_139;
                  }
                  if (v128[8] == 255)
                  {
                    v69 = (v128[9] & 0xF) - 1;
                    if (v69 >= 5)
                      v51 = 14;
                    else
                      v51 = dword_183C6E2E4[v69];
                    goto LABEL_139;
                  }
                  if (v128[8] == 254)
                  {
                    if (v128[9] <= 0xBFu)
                      v51 = 14;
                    else
                      v51 = 5;
                    v52 = (v128[9] & 0xC0) == 128;
                  }
                  else
                  {
                    v51 = 14;
                    if (*(_QWORD *)&v128[8] | *(_QWORD *)&v128[15])
                      goto LABEL_139;
                    v52 = v128[23] == 1;
                  }
                }
                if (v52)
                  v51 = 2;
LABEL_139:
                if (v128[37] == 2)
                {
                  v56 = bswap32(*(unsigned int *)&v128[40]);
                  v55 = (v56 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v56) == 127;
                  v54 = 14;
                }
                else
                {
                  if (v128[37] != 30)
                  {
                    v54 = 0;
                    goto LABEL_155;
                  }
                  if (v128[44] == 255)
                  {
                    v70 = (v128[45] & 0xF) - 1;
                    if (v70 >= 5)
                      v54 = 14;
                    else
                      v54 = dword_183C6E2E4[v70];
                    goto LABEL_155;
                  }
                  if (v128[44] == 254)
                  {
                    if (v128[45] <= 0xBFu)
                      v54 = 14;
                    else
                      v54 = 5;
                    v55 = (v128[45] & 0xC0) == 128;
                  }
                  else
                  {
                    v54 = 14;
                    if (*(_QWORD *)&v128[44] | *(_QWORD *)&v128[51])
                      goto LABEL_155;
                    v55 = v128[59] == 1;
                  }
                }
                if (v55)
                  v54 = 2;
LABEL_155:
                if (v51 == v54)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v16 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_rfc6724";
                    v17 = "%{public}s Rule 2, prefer d1, d2 dst scope does not match src scope";
                    goto LABEL_384;
                  }
                  goto LABEL_386;
                }
                if (type[1] == 2)
                {
                  v62 = bswap32(*(unsigned int *)&type[4]);
                  v58 = (v62 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v62) == 127;
                  v57 = 14;
                }
                else
                {
                  if (type[1] != 30)
                  {
                    v57 = 0;
                    goto LABEL_181;
                  }
                  if (type[8] == 255)
                  {
                    v77 = (type[9] & 0xF) - 1;
                    if (v77 >= 5)
                      v57 = 14;
                    else
                      v57 = dword_183C6E2E4[v77];
                    goto LABEL_181;
                  }
                  if (type[8] == 254)
                  {
                    if (type[9] <= 0xBFu)
                      v57 = 14;
                    else
                      v57 = 5;
                    v58 = (type[9] & 0xC0) == 128;
                  }
                  else
                  {
                    v57 = 14;
                    if (*(_QWORD *)&type[8] | *(_QWORD *)&type[15])
                      goto LABEL_181;
                    v58 = type[23] == 1;
                  }
                }
                if (v58)
                  v57 = 2;
LABEL_181:
                if (type[37] == 2)
                {
                  v65 = bswap32(*(unsigned int *)&type[40]);
                  v64 = (v65 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v65) == 127;
                  v63 = 14;
                }
                else
                {
                  if (type[37] != 30)
                  {
                    v63 = 0;
                    goto LABEL_197;
                  }
                  if (type[44] == 255)
                  {
                    v78 = (type[45] & 0xF) - 1;
                    if (v78 >= 5)
                      v63 = 14;
                    else
                      v63 = dword_183C6E2E4[v78];
                    goto LABEL_197;
                  }
                  if (type[44] == 254)
                  {
                    if (type[45] <= 0xBFu)
                      v63 = 14;
                    else
                      v63 = 5;
                    v64 = (type[45] & 0xC0) == 128;
                  }
                  else
                  {
                    v63 = 14;
                    if (*(_QWORD *)&type[44] | *(_QWORD *)&type[51])
                      goto LABEL_197;
                    v64 = type[59] == 1;
                  }
                }
                if (v64)
                  v63 = 2;
LABEL_197:
                if (v57 == v63)
                {
                  v24 = __nwlog_obj();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_rfc6724";
                    v25 = "%{public}s Rule 2, prefer d2, d1 dst scope does not match src scope";
                    goto LABEL_352;
                  }
LABEL_354:
                  v21 = 0xFFFFFFFFLL;
                  goto LABEL_387;
                }
LABEL_200:
                if ((v129 & 4) != (v126 & 4))
                {
                  if ((v129 & 4) != 0)
                  {
                    v16 = __nwlog_obj();
                    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446210;
                      v132 = "sa_dst_compare_rfc6724";
                      v17 = "%{public}s Rule 3, prefer d2, d1 source is deprecated";
                      goto LABEL_384;
                    }
                    goto LABEL_386;
                  }
                  if ((v126 & 4) != 0)
                  {
                    v24 = __nwlog_obj();
                    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446210;
                      v132 = "sa_dst_compare_rfc6724";
                      v25 = "%{public}s Rule 3, prefer d1, d2 source is deprecated";
                      goto LABEL_352;
                    }
                    goto LABEL_354;
                  }
                }
                if ((v129 & 8) != (v126 & 8))
                {
                  if ((v129 & 8) != 0)
                  {
                    v16 = __nwlog_obj();
                    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446210;
                      v132 = "sa_dst_compare_rfc6724";
                      v17 = "%{public}s Rule 3a, prefer d2, d1 source is optimistic";
                      goto LABEL_384;
                    }
                    goto LABEL_386;
                  }
                  if ((v126 & 8) != 0)
                  {
                    v24 = __nwlog_obj();
                    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446210;
                      v132 = "sa_dst_compare_rfc6724";
                      v25 = "%{public}s Rule 3a, prefer d1, d2 source is optimistic";
                      goto LABEL_352;
                    }
                    goto LABEL_354;
                  }
                }
                if (*(unsigned __int16 *)&v128[32] == WORD2(v129))
                {
                  if (*(unsigned __int16 *)&type[32] != WORD2(v126))
                  {
                    v16 = __nwlog_obj();
                    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446210;
                      v132 = "sa_dst_compare_rfc6724";
                      v17 = "%{public}s Rule 5, prefer d1, d2 dst label does not match src label";
                      goto LABEL_384;
                    }
                    goto LABEL_386;
                  }
                }
                else if (*(unsigned __int16 *)&type[32] == WORD2(v126))
                {
                  v24 = __nwlog_obj();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_rfc6724";
                    v25 = "%{public}s Rule 5, prefer d2, d1 dst label does not match src label";
                    goto LABEL_352;
                  }
                  goto LABEL_354;
                }
                if (*(unsigned __int16 *)&v128[34] > *(unsigned __int16 *)&type[34])
                {
                  v68 = __nwlog_obj();
                  if (!os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
                    goto LABEL_386;
                  *(_DWORD *)buf = 136446722;
                  v132 = "sa_dst_compare_rfc6724";
                  v133 = 1024;
                  *(_DWORD *)v134 = *(unsigned __int16 *)&v128[34];
                  *(_WORD *)&v134[4] = 1024;
                  *(_DWORD *)&v134[6] = *(unsigned __int16 *)&type[34];
                  v17 = "%{public}s Rule 6, prefer d1, d1 precedence %d > d2 precedence %d";
                  goto LABEL_228;
                }
                if (*(unsigned __int16 *)&type[34] > *(unsigned __int16 *)&v128[34])
                {
                  v76 = __nwlog_obj();
                  if (!os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
                    goto LABEL_354;
                  *(_DWORD *)buf = 136446722;
                  v132 = "sa_dst_compare_rfc6724";
                  v133 = 1024;
                  *(_DWORD *)v134 = *(unsigned __int16 *)&type[34];
                  *(_WORD *)&v134[4] = 1024;
                  *(_DWORD *)&v134[6] = *(unsigned __int16 *)&v128[34];
                  v25 = "%{public}s Rule 6, prefer d2, d2 precedence %d > d1 precedence %d";
                  goto LABEL_268;
                }
                if (v128[37] == 30)
                {
                  if (*(unsigned __int16 *)&v128[44] == 544)
                  {
                    v87 = 0;
LABEL_319:
                    if (type[37] == 30)
                    {
                      if (*(unsigned __int16 *)&type[44] == 544)
                      {
                        v94 = 0;
                        goto LABEL_380;
                      }
                      if (*(unsigned __int16 *)&type[44] == 288)
                      {
                        v94 = *(_WORD *)&type[46] != 0;
LABEL_380:
                        if (v87 && !v94)
                        {
                          v16 = __nwlog_obj();
                          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                          {
                            *(_DWORD *)buf = 136446210;
                            v132 = "sa_dst_compare_rfc6724";
                            v17 = "%{public}s Rule 7, prefer d1, d2 src is not native";
                            goto LABEL_384;
                          }
                          goto LABEL_386;
                        }
                        goto LABEL_324;
                      }
                    }
                    v94 = 1;
LABEL_324:
                    if (v94 && !v87)
                    {
                      v24 = __nwlog_obj();
                      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136446210;
                        v132 = "sa_dst_compare_rfc6724";
                        v25 = "%{public}s Rule 7, prefer d2, d1 src is not native";
                        goto LABEL_352;
                      }
                      goto LABEL_354;
                    }
                    v124 = rfc6724_scope((uint64_t)v128);
                    v95 = rfc6724_scope((uint64_t)type);
                    if (v124 < v95)
                    {
                      v96 = v95;
                      v68 = __nwlog_obj();
                      if (!os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
                        goto LABEL_386;
                      *(_DWORD *)buf = 136446722;
                      v132 = "sa_dst_compare_rfc6724";
                      v133 = 1024;
                      *(_DWORD *)v134 = v124;
                      *(_WORD *)&v134[4] = 1024;
                      *(_DWORD *)&v134[6] = v96;
                      v17 = "%{public}s Rule 8, prefer d1, d1 scope %d < d2 scope %d";
LABEL_228:
                      v39 = v68;
                      v40 = 24;
                      goto LABEL_385;
                    }
                    if (v95 < v124)
                    {
                      v103 = v95;
                      v76 = __nwlog_obj();
                      if (!os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
                        goto LABEL_354;
                      *(_DWORD *)buf = 136446722;
                      v132 = "sa_dst_compare_rfc6724";
                      v133 = 1024;
                      *(_DWORD *)v134 = v103;
                      *(_WORD *)&v134[4] = 1024;
                      *(_DWORD *)&v134[6] = v124;
                      v25 = "%{public}s Rule 8, prefer d2, d2 scope %d < d1 scope %d";
LABEL_268:
                      v72 = v76;
                      v73 = 24;
                      goto LABEL_353;
                    }
                    if ((_DWORD)v6)
                      v113 = 1;
                    else
                      v113 = 0xFFFFFFFFLL;
                    if (((v6 | v15) & 1) != 0)
                      goto LABEL_409;
                    v114 = common_prefix_length((const sockaddr_in_4_6 *)v128, (const sockaddr_in_4_6 *)&v128[36]);
                    v115 = common_prefix_length((const sockaddr_in_4_6 *)type, (const sockaddr_in_4_6 *)&type[36]);
                    if (v114 && v115)
                    {
                      if (v114 > v115)
                      {
                        v16 = __nwlog_obj();
                        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                          goto LABEL_386;
                        *(_DWORD *)buf = 136446210;
                        v132 = "sa_dst_compare_rfc6724";
                        v17 = "%{public}s Rule 9, prefer d1, d1 shares more common prefix";
                        goto LABEL_384;
                      }
                      if (v115 > v114)
                      {
                        v24 = __nwlog_obj();
                        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                          goto LABEL_354;
                        *(_DWORD *)buf = 136446210;
                        v132 = "sa_dst_compare_rfc6724";
                        v25 = "%{public}s Rule 9, prefer d2, d2 shares more common prefix";
                        goto LABEL_352;
                      }
                    }
                    if (v12 == 1 && v14 == 2)
                    {
                      v16 = __nwlog_obj();
                      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                        goto LABEL_386;
                      *(_DWORD *)buf = 136446210;
                      v132 = "sa_dst_compare_internal_wrapper";
                      v17 = "%{public}s prefer d1, known while d2 not known";
                      goto LABEL_384;
                    }
                    v113 = 0;
                    if (v14 != 1)
                    {
LABEL_409:
                      v21 = v113;
                    }
                    else
                    {
                      v19 = v12 == 2;
                      v21 = 0;
                      if (v19)
                      {
                        v24 = __nwlog_obj();
                        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                          goto LABEL_354;
                        *(_DWORD *)buf = 136446210;
                        v132 = "sa_dst_compare_internal_wrapper";
                        v25 = "%{public}s prefer d2, known while d1 not known";
                        goto LABEL_352;
                      }
                    }
LABEL_387:
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v104 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      v105 = *a1;
                      v106 = *a3;
                      if ((int)v21 >= 0)
                        v107 = 62;
                      else
                        v107 = 60;
                      if (!(_DWORD)v21)
                        v107 = 61;
                      *(_DWORD *)v128 = 136448003;
                      *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
                      *(_WORD *)&v128[12] = 1040;
                      *(_DWORD *)&v128[14] = v105;
                      *(_WORD *)&v128[18] = 2101;
                      *(_QWORD *)&v128[20] = a1;
                      *(_WORD *)&v128[28] = 1024;
                      *(_DWORD *)&v128[30] = a2;
                      *(_WORD *)&v128[34] = 1024;
                      *(_DWORD *)&v128[36] = v107;
                      *(_WORD *)&v128[40] = 1040;
                      *(_DWORD *)&v128[42] = v106;
                      *(_WORD *)&v128[46] = 2101;
                      *(_QWORD *)&v128[48] = a3;
                      *(_WORD *)&v128[56] = 1024;
                      *(_DWORD *)&v128[58] = a4;
                      _os_log_impl(&dword_182FBE000, v104, OS_LOG_TYPE_DEBUG, "%{public}s %{sensitive,network:sockaddr}.*P@%u %c %{sensitive,network:sockaddr}.*P@%u", v128, 0x3Eu);
                    }
                    return v21;
                  }
                  if (*(unsigned __int16 *)&v128[44] == 288)
                  {
                    v87 = *(_WORD *)&v128[46] != 0;
                    goto LABEL_319;
                  }
                }
                v87 = 1;
                goto LABEL_319;
              }
              if (!type[37])
                goto LABEL_34;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v24 = gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                goto LABEL_354;
              *(_DWORD *)buf = 136446210;
              v132 = "sa_dst_compare_rfc6724";
              v25 = "%{public}s Rule 1, prefer d2, d1 is not routable";
LABEL_352:
              v72 = v24;
              v73 = 12;
              goto LABEL_353;
            }
            v6 = DWORD1(v130);
            if (DWORD1(v130))
            {
              if (networkd_settings_get_int64_with_default((const char *)nw_setting_compare_failure_threshold, 10) >= v6)
                goto LABEL_11;
              v71 = __nwlog_obj();
              if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
                goto LABEL_354;
              *(_DWORD *)buf = 136446466;
              v132 = "sa_dst_compare_statistics";
              v133 = 1024;
              *(_DWORD *)v134 = v6;
              v25 = "%{public}s prefer 2, dst 1 has no successful connections and %u attempts";
              v72 = v71;
              v73 = 18;
              goto LABEL_353;
            }
          }
LABEL_12:
          v15 = 0;
          goto LABEL_13;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          v132 = "sa_dst_compare_internal_wrapper";
          v23 = "%{public}s sa_dst_lookup for dst2 failed";
          goto LABEL_29;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          v132 = "sa_dst_compare_internal_wrapper";
          v23 = "%{public}s sa_dst_lookup for dst1 failed";
LABEL_29:
          _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, v23, buf, 0xCu);
        }
      }
      v21 = 0;
      goto LABEL_387;
    }
    __nwlog_obj();
    *(_DWORD *)v128 = 136446210;
    *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
    v99 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    buf[0] = 0;
    if (!__nwlog_fault(v99, type, buf))
      goto LABEL_424;
    if (type[0] == 17)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (os_log_type_enabled(v100, (os_log_type_t)type[0]))
      {
        *(_DWORD *)v128 = 136446210;
        *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
        v102 = "%{public}s called with null dst2";
        goto LABEL_423;
      }
      goto LABEL_424;
    }
    if (!buf[0])
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (os_log_type_enabled(v100, (os_log_type_t)type[0]))
      {
        *(_DWORD *)v128 = 136446210;
        *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
        v102 = "%{public}s called with null dst2, backtrace limit exceeded";
        goto LABEL_423;
      }
      goto LABEL_424;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v100 = __nwlog_obj();
    v101 = type[0];
    v112 = os_log_type_enabled(v100, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (v112)
      {
        *(_DWORD *)v128 = 136446210;
        *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
        v102 = "%{public}s called with null dst2, no backtrace";
        goto LABEL_423;
      }
      goto LABEL_424;
    }
    if (v112)
    {
      *(_DWORD *)v128 = 136446466;
      *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
      *(_WORD *)&v128[12] = 2082;
      *(_QWORD *)&v128[14] = backtrace_string;
      v111 = "%{public}s called with null dst2, dumping backtrace:%{public}s";
      goto LABEL_403;
    }
    goto LABEL_404;
  }
  __nwlog_obj();
  *(_DWORD *)v128 = 136446210;
  *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
  v99 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  buf[0] = 0;
  if (!__nwlog_fault(v99, type, buf))
    goto LABEL_424;
  if (type[0] != 17)
  {
    if (!buf[0])
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (os_log_type_enabled(v100, (os_log_type_t)type[0]))
      {
        *(_DWORD *)v128 = 136446210;
        *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
        v102 = "%{public}s called with null dst1, backtrace limit exceeded";
        goto LABEL_423;
      }
      goto LABEL_424;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v100 = __nwlog_obj();
    v101 = type[0];
    v110 = os_log_type_enabled(v100, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (v110)
      {
        *(_DWORD *)v128 = 136446210;
        *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
        v102 = "%{public}s called with null dst1, no backtrace";
        goto LABEL_423;
      }
      goto LABEL_424;
    }
    if (v110)
    {
      *(_DWORD *)v128 = 136446466;
      *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
      *(_WORD *)&v128[12] = 2082;
      *(_QWORD *)&v128[14] = backtrace_string;
      v111 = "%{public}s called with null dst1, dumping backtrace:%{public}s";
LABEL_403:
      _os_log_impl(&dword_182FBE000, v100, v101, v111, v128, 0x16u);
    }
LABEL_404:
    free(backtrace_string);
    goto LABEL_424;
  }
  v100 = __nwlog_obj();
  v101 = type[0];
  if (os_log_type_enabled(v100, (os_log_type_t)type[0]))
  {
    *(_DWORD *)v128 = 136446210;
    *(_QWORD *)&v128[4] = "sa_dst_compare_internal";
    v102 = "%{public}s called with null dst1";
LABEL_423:
    _os_log_impl(&dword_182FBE000, v100, v101, v102, v128, 0xCu);
  }
LABEL_424:
  if (v99)
    free(v99);
  return 0;
}

BOOL sa_dst_lookup(unsigned __int8 *a1, int a2, _OWORD *a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  char v9;
  unint64_t v10;
  uint64_t *v11;
  int v12;
  unsigned __int8 *v13;
  BOOL v14;
  size_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  char *v23;
  uint64_t v24;
  unsigned __int8 *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  _BOOL8 result;
  NSObject *v33;
  void *v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  const char *v38;
  char *backtrace_string;
  _BOOL4 v40;
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  pthread_once(&cache_init, (void (*)(void))sa_dst_compare_init_once);
  os_unfair_lock_lock((os_unfair_lock_t)&cache_lock);
  v6 = mach_absolute_time();
  v7 = (_QWORD *)cache;
  if (!cache)
    goto LABEL_28;
  v8 = v6;
  v9 = 0;
  v10 = cache_timeout;
  v11 = &cache;
  do
  {
    while (v8 - *v7 >= v10)
    {
      *v11 = v7[1];
      free(v7);
      v10 = cache_timeout;
      v7 = (_QWORD *)*v11;
      if (!*v11)
        goto LABEL_26;
    }
    if ((v9 & 1) != 0)
      goto LABEL_6;
    if (*((_DWORD *)v7 + 22) == a2)
    {
      v12 = a1[1];
      if (v12 == *((unsigned __int8 *)v7 + 17))
      {
        v13 = (unsigned __int8 *)(v7 + 2);
        if (v12 == 30)
        {
          v14 = *((_QWORD *)a1 + 1) == v7[3] && *((_QWORD *)a1 + 2) == v7[4];
          if (v14 && *((_DWORD *)a1 + 6) == *((_DWORD *)v7 + 10))
          {
LABEL_25:
            v16 = *((_OWORD *)v7 + 2);
            *a3 = *(_OWORD *)v13;
            a3[1] = v16;
            v17 = *((_OWORD *)v7 + 3);
            v18 = *((_OWORD *)v7 + 4);
            v19 = *((_OWORD *)v7 + 6);
            a3[4] = *((_OWORD *)v7 + 5);
            a3[5] = v19;
            a3[2] = v17;
            a3[3] = v18;
            v7 = (_QWORD *)*v11;
LABEL_6:
            v9 = 1;
            goto LABEL_23;
          }
        }
        else if (v12 == 2)
        {
          if (*((_DWORD *)a1 + 1) == *((_DWORD *)v7 + 5))
            goto LABEL_25;
        }
        else
        {
          v15 = *a1;
          if ((_DWORD)v15 == *v13 && !memcmp(a1, v7 + 2, v15))
            goto LABEL_25;
        }
      }
    }
    v9 = 0;
LABEL_23:
    v11 = v7 + 1;
    v7 = (_QWORD *)v7[1];
  }
  while (v7);
LABEL_26:
  if ((v9 & 1) != 0)
  {
    v20 = 1;
    goto LABEL_34;
  }
LABEL_28:
  if (*a1 >= 0x1Du)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v22 = *a1;
      *(_DWORD *)buf = 136446466;
      v44 = "sa_dst_cache_create";
      v45 = 1024;
      LODWORD(v46) = v22;
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s (dst_sa->sa_len %u > sizeof(cache_entry->dce_entry.d_dst.addr))", buf, 0x12u);
    }
    goto LABEL_31;
  }
  v23 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0xEAFB8F1AuLL);
  if (v23)
  {
    v24 = (uint64_t)v23;
    v25 = (unsigned __int8 *)(v23 + 16);
    memcpy(v23 + 16, a1, *a1);
    *(_DWORD *)(v24 + 88) = a2;
    sa_dst_fill_netsrc(v25);
    v26 = *(_OWORD *)(v24 + 32);
    *a3 = *(_OWORD *)(v24 + 16);
    a3[1] = v26;
    v27 = *(_OWORD *)(v24 + 48);
    v28 = *(_OWORD *)(v24 + 64);
    v29 = *(_OWORD *)(v24 + 96);
    a3[4] = *(_OWORD *)(v24 + 80);
    a3[5] = v29;
    a3[2] = v27;
    a3[3] = v28;
    v30 = mach_absolute_time();
    v31 = cache;
    *(_QWORD *)v24 = v30;
    *(_QWORD *)(v24 + 8) = v31;
    cache = v24;
    v20 = 2;
    goto LABEL_34;
  }
  v33 = __nwlog_obj();
  os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v44 = "strict_calloc";
  v45 = 2048;
  v46 = 1;
  v47 = 2048;
  v48 = 112;
  v34 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v34);
  if (result)
  {
    __break(1u);
  }
  else
  {
    free(v34);
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v44 = "sa_dst_cache_create";
    v45 = 2048;
    v46 = 112;
    v35 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v35, &type, &v41))
      goto LABEL_50;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v41)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v36 = __nwlog_obj();
        v37 = type;
        v40 = os_log_type_enabled(v36, type);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446722;
            v44 = "sa_dst_cache_create";
            v45 = 2048;
            v46 = 112;
            v47 = 2082;
            v48 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s malloc(%zu) failed, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_50;
        }
        if (!v40)
          goto LABEL_50;
        *(_DWORD *)buf = 136446466;
        v44 = "sa_dst_cache_create";
        v45 = 2048;
        v46 = 112;
        v38 = "%{public}s malloc(%zu) failed, no backtrace";
      }
      else
      {
        v36 = __nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type))
          goto LABEL_50;
        *(_DWORD *)buf = 136446466;
        v44 = "sa_dst_cache_create";
        v45 = 2048;
        v46 = 112;
        v38 = "%{public}s malloc(%zu) failed, backtrace limit exceeded";
      }
LABEL_49:
      _os_log_impl(&dword_182FBE000, v36, v37, v38, buf, 0x16u);
      goto LABEL_50;
    }
    v36 = __nwlog_obj();
    v37 = type;
    if (os_log_type_enabled(v36, type))
    {
      *(_DWORD *)buf = 136446466;
      v44 = "sa_dst_cache_create";
      v45 = 2048;
      v46 = 112;
      v38 = "%{public}s malloc(%zu) failed";
      goto LABEL_49;
    }
LABEL_50:
    if (v35)
      free(v35);
LABEL_31:
    v20 = 0;
LABEL_34:
    os_unfair_lock_unlock((os_unfair_lock_t)&cache_lock);
    return v20;
  }
  return result;
}

uint64_t rfc6724_scope(uint64_t a1)
{
  int v2;
  int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;
  uint64_t result;
  unsigned int v10;
  uint64_t v11;

  v2 = *(unsigned __int8 *)(a1 + 1);
  if (v2 == 2)
  {
    v8 = bswap32(*(_DWORD *)(a1 + 4));
    v7 = HIWORD(v8) == 43518 || HIBYTE(v8) == 127;
    v6 = 14;
    goto LABEL_13;
  }
  if (v2 != 30)
    return 0;
  v3 = *(unsigned __int8 *)(a1 + 8);
  if (v3 == 255)
  {
    v10 = (*(_BYTE *)(a1 + 9) & 0xF) - 1;
    if (v10 >= 5)
      return 14;
    else
      return dword_183C6E2E4[v10];
  }
  else
  {
    if (v3 == 254)
    {
      v4 = *(unsigned __int8 *)(a1 + 9);
      v5 = v4 & 0xC0;
      if (v4 <= 0xBF)
        v6 = 14;
      else
        v6 = 5;
      v7 = v5 == 128;
LABEL_13:
      if (v7)
        return 2;
      else
        return v6;
    }
    v11 = *(_QWORD *)(a1 + 15);
    result = 14;
    if (!(*(_QWORD *)(a1 + 8) | v11))
    {
      if (*(_BYTE *)(a1 + 23) == 1)
        return 2;
      else
        return 14;
    }
  }
  return result;
}

uint64_t __nwlog_obj()
{
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  return gLogObj;
}

void sub_182FFC4AC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void nw_allow_use_of_dispatch_internal()
{
  void *v0;

  if (sNWIsBetweenForkAndExec != 1
    || (sNWParentAllowedDispatch & 1) == 0 && !_dispatch_is_fork_of_multithreaded_parent())
  {
    goto LABEL_6;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  v0 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v0))
  {
    free(v0);
LABEL_6:
    pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
    sNWDispatchAllowedNow = 1;
    networkd_settings_init();
    networkd_settings_setup_notify_watch();
    return;
  }
  __break(1u);
}

void networkd_settings_setup_notify_watch(void)
{
  uint64_t v0;
  char *v1;
  uint64_t v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  const char *v6;
  NSObject *v7;
  NSObject *v8;
  uint32_t v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  char *backtrace_string;
  uint64_t v15;
  _BOOL4 v16;
  const char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  const char *v31;
  char v32;
  os_log_type_t type;
  int out_token;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  _BYTE v39[14];
  __int16 v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if ((sNWDispatchAllowedNow & 1) == 0)
    {
      if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
        || (getpid(), sandbox_check() == 1))
      {
        sNWDispatchAllowedNow = 1;
      }
      else if (!sNWDispatchAllowedNow)
      {
        return;
      }
    }
    if (!networkd_settings_setup_notify_watch(void)::queue)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (networkd_settings_setup_notify_watch(void)::queue)
        goto LABEL_11;
      v6 = (const char *)nw_notification_name_settings;
      v7 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      v8 = dispatch_queue_create(v6, v7);
      networkd_settings_setup_notify_watch(void)::queue = (uint64_t)v8;
      if (!v8)
        goto LABEL_11;
      out_token = 0;
      v9 = notify_register_dispatch((const char *)nw_notification_name_settings, &out_token, v8, &__block_literal_global_88104);
      pthread_mutex_unlock(&sSettingsMutex);
      if (!v9)
      {
LABEL_12:
        if (networkd_settings_setup_notify_watch(void)::queue)
          return;
        v0 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v0);
        out_token = 136446466;
        v35 = "networkd_settings_setup_notify_watch";
        v36 = 2082;
        v37 = nw_notification_name_settings;
        v1 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v32 = 0;
        if (!__nwlog_fault(v1, &type, &v32))
          goto LABEL_48;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v2 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v2);
          v3 = gLogObj;
          v4 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_48;
          out_token = 136446466;
          v35 = "networkd_settings_setup_notify_watch";
          v36 = 2082;
          v37 = nw_notification_name_settings;
          v5 = "%{public}s dispatch_queue_create(%{public}s) failed";
        }
        else if (v32)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v15 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v15);
          v3 = gLogObj;
          v4 = type;
          v16 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v16)
            {
              out_token = 136446722;
              v35 = "networkd_settings_setup_notify_watch";
              v36 = 2082;
              v37 = nw_notification_name_settings;
              v38 = 2082;
              *(_QWORD *)v39 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s dispatch_queue_create(%{public}s) failed, dumping backtrace:%{public}s", (uint8_t *)&out_token, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_48;
          }
          if (!v16)
          {
LABEL_48:
            if (v1)
              free(v1);
            return;
          }
          out_token = 136446466;
          v35 = "networkd_settings_setup_notify_watch";
          v36 = 2082;
          v37 = nw_notification_name_settings;
          v5 = "%{public}s dispatch_queue_create(%{public}s) failed, no backtrace";
        }
        else
        {
          v25 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v25);
          v3 = gLogObj;
          v4 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_48;
          out_token = 136446466;
          v35 = "networkd_settings_setup_notify_watch";
          v36 = 2082;
          v37 = nw_notification_name_settings;
          v5 = "%{public}s dispatch_queue_create(%{public}s) failed, backtrace limit exceeded";
        }
        _os_log_impl(&dword_182FBE000, v3, v4, v5, (uint8_t *)&out_token, 0x16u);
        goto LABEL_48;
      }
      if (nw_settings_should_be_able_to_use_notify_apis(void)::onceToken[0] != -1)
        dispatch_once(nw_settings_should_be_able_to_use_notify_apis(void)::onceToken, &__block_literal_global_8_88048);
      v10 = nw_settings_should_be_able_to_use_notify_apis(void)::has_notify_apis;
      v11 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v11);
      v12 = gLogObj;
      if (v10 == 1 && v9 == 1000000)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        {
          if (sNWIsBetweenForkAndExec)
            v13 = " (forked)";
          else
            v13 = "";
          out_token = 136446978;
          v35 = "networkd_settings_setup_notify_watch";
          v36 = 2082;
          v37 = nw_notification_name_settings;
          v38 = 1024;
          *(_DWORD *)v39 = 1000000;
          *(_WORD *)&v39[4] = 2082;
          *(_QWORD *)&v39[6] = v13;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEFAULT, "%{public}s [sandboxed: ok] notify_register_dispatch(%{public}s) [status %u]%{public}s failed", (uint8_t *)&out_token, 0x26u);
        }
LABEL_72:
        pthread_mutex_lock(&sSettingsMutex);
        networkd_settings_read_from_file();
LABEL_11:
        pthread_mutex_unlock(&sSettingsMutex);
        goto LABEL_12;
      }
      if (sNWIsBetweenForkAndExec)
        v17 = " (forked)";
      else
        v17 = "";
      out_token = 136446978;
      v35 = "networkd_settings_setup_notify_watch";
      v36 = 2082;
      v37 = nw_notification_name_settings;
      v38 = 1024;
      *(_DWORD *)v39 = v9;
      *(_WORD *)&v39[4] = 2082;
      *(_QWORD *)&v39[6] = v17;
      v18 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v32 = 0;
      v19 = __nwlog_fault(v18, &type, &v32);
      if ((_DWORD)v19)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v21 = __nwlog_obj(v19, v20);
          v22 = type;
          if (!os_log_type_enabled(v21, type))
            goto LABEL_70;
          if (sNWIsBetweenForkAndExec)
            v23 = " (forked)";
          else
            v23 = "";
          out_token = 136446978;
          v35 = "networkd_settings_setup_notify_watch";
          v36 = 2082;
          v37 = nw_notification_name_settings;
          v38 = 1024;
          *(_DWORD *)v39 = v9;
          *(_WORD *)&v39[4] = 2082;
          *(_QWORD *)&v39[6] = v23;
          v24 = "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed";
          goto LABEL_69;
        }
        if (!v32)
        {
          v21 = __nwlog_obj(v19, v20);
          v22 = type;
          if (!os_log_type_enabled(v21, type))
            goto LABEL_70;
          if (sNWIsBetweenForkAndExec)
            v30 = " (forked)";
          else
            v30 = "";
          out_token = 136446978;
          v35 = "networkd_settings_setup_notify_watch";
          v36 = 2082;
          v37 = nw_notification_name_settings;
          v38 = 1024;
          *(_DWORD *)v39 = v9;
          *(_WORD *)&v39[4] = 2082;
          *(_QWORD *)&v39[6] = v30;
          v24 = "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed, backtrace limit exceeded";
          goto LABEL_69;
        }
        v26 = (char *)__nw_create_backtrace_string();
        v21 = __nwlog_obj(v26, v27);
        v22 = type;
        v28 = os_log_type_enabled(v21, type);
        if (v26)
        {
          if (v28)
          {
            if (sNWIsBetweenForkAndExec)
              v29 = " (forked)";
            else
              v29 = "";
            out_token = 136447234;
            v35 = "networkd_settings_setup_notify_watch";
            v36 = 2082;
            v37 = nw_notification_name_settings;
            v38 = 1024;
            *(_DWORD *)v39 = v9;
            *(_WORD *)&v39[4] = 2082;
            *(_QWORD *)&v39[6] = v29;
            v40 = 2082;
            v41 = v26;
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed, dumping backtrace:%{public}s", (uint8_t *)&out_token, 0x30u);
          }
          free(v26);
          goto LABEL_70;
        }
        if (v28)
        {
          if (sNWIsBetweenForkAndExec)
            v31 = " (forked)";
          else
            v31 = "";
          out_token = 136446978;
          v35 = "networkd_settings_setup_notify_watch";
          v36 = 2082;
          v37 = nw_notification_name_settings;
          v38 = 1024;
          *(_DWORD *)v39 = v9;
          *(_WORD *)&v39[4] = 2082;
          *(_QWORD *)&v39[6] = v31;
          v24 = "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed, no backtrace";
LABEL_69:
          _os_log_impl(&dword_182FBE000, v21, v22, v24, (uint8_t *)&out_token, 0x26u);
        }
      }
LABEL_70:
      if (v18)
        free(v18);
      goto LABEL_72;
    }
  }
}

BOOL networkd_settings_get_BOOL(const char *a1)
{
  void *v2;
  Class Class;
  _BOOL8 v4;
  xpc_object_t value;
  void *v6;

  networkd_settings_init(a1);
  if (!sCachedSettings)
    return 0;
  pthread_mutex_lock(&sSettingsMutex);
  v2 = (void *)sCachedSettings;
  if (!sCachedSettings)
    goto LABEL_7;
  Class = object_getClass((id)sCachedSettings);
  v4 = 0;
  if (!a1 || Class != (Class)MEMORY[0x1E0C812F8])
    goto LABEL_8;
  value = xpc_dictionary_get_value(v2, a1);
  if (value && (v6 = value, object_getClass(value) == (Class)MEMORY[0x1E0C812D0]))
    v4 = xpc_BOOL_get_value(v6);
  else
LABEL_7:
    v4 = 0;
LABEL_8:
  pthread_mutex_unlock(&sSettingsMutex);
  return v4;
}

int64_t networkd_settings_get_int64_with_default(const char *a1, int64_t a2)
{
  void *v4;
  Class Class;
  xpc_object_t value;
  void *v7;

  networkd_settings_init();
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    v4 = (void *)sCachedSettings;
    if (sCachedSettings)
    {
      Class = object_getClass((id)sCachedSettings);
      if (a1)
      {
        if (Class == (Class)MEMORY[0x1E0C812F8])
        {
          value = xpc_dictionary_get_value(v4, a1);
          if (value)
          {
            v7 = value;
            if (object_getClass(value) == (Class)MEMORY[0x1E0C81328])
              a2 = xpc_int64_get_value(v7);
          }
        }
      }
    }
    pthread_mutex_unlock(&sSettingsMutex);
  }
  return a2;
}

uint64_t networkd_settings_init()
{
  uint64_t result;
  uint32_t v1;
  char v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  int out_token;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  result = pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sSettingsInitState != 2)
  {
    pthread_mutex_lock(&sSettingsMutex);
    if (sSettingsInitState)
      return pthread_mutex_unlock(&sSettingsMutex);
    sSettingsInitState = 1;
    networkd_settings_setup_notify_watch();
    networkd_settings_read_from_file();
    out_token = -1;
    v1 = notify_register_check((const char *)nw_notification_name_settings, &out_token);
    if (!v1 && out_token != -1)
    {
      networkd_settings_update_from_token(out_token);
LABEL_19:
      if (out_token != -1)
        notify_cancel(out_token);
      sSettingsInitState = 2;
      return pthread_mutex_unlock(&sSettingsMutex);
    }
    if (nw_settings_should_be_able_to_use_notify_apis(void)::onceToken[0] != -1)
      dispatch_once(nw_settings_should_be_able_to_use_notify_apis(void)::onceToken, &__block_literal_global_8_88048);
    v2 = nw_settings_should_be_able_to_use_notify_apis(void)::has_notify_apis;
    v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v3);
    v4 = gLogObj;
    if (v1 == 1000000 && (v2 & 1) != 0)
    {
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        goto LABEL_19;
      v5 = "";
      *(_DWORD *)buf = 136447234;
      if (sNWIsBetweenForkAndExec)
        v5 = " (forked)";
      v12 = "networkd_settings_init";
      v13 = 2082;
      v14 = nw_notification_name_settings;
      v15 = 1024;
      v16 = 1000000;
      v17 = 1024;
      v18 = out_token;
      v19 = 2082;
      v20 = v5;
      v6 = "%{public}s [sandboxed: ok] notify_register_check(%{public}s) status %u token %d%{public}s failed";
      v7 = v4;
      v8 = OS_LOG_TYPE_DEFAULT;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_19;
      v9 = "";
      *(_DWORD *)buf = 136447234;
      if (sNWIsBetweenForkAndExec)
        v9 = " (forked)";
      v12 = "networkd_settings_init";
      v13 = 2082;
      v14 = nw_notification_name_settings;
      v15 = 1024;
      v16 = v1;
      v17 = 1024;
      v18 = out_token;
      v19 = 2082;
      v20 = v9;
      v6 = "%{public}s notify_register_check(%{public}s) status %u token %d%{public}s";
      v7 = v4;
      v8 = OS_LOG_TYPE_ERROR;
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v6, buf, 0x2Cu);
    goto LABEL_19;
  }
  return result;
}

uint64_t common_prefix_length(const sockaddr_in_4_6 *a1, const sockaddr_in_4_6 *a2)
{
  int v2;
  uint64_t result;

  if (a1->var0.sa_family != 30 || a2->var0.sa_family != 30)
    return 0;
  v2 = a1->var3.sin6_addr.__u6_addr8[0] ^ a2->var3.sin6_addr.__u6_addr8[0];
  if (v2)
  {
    result = 0;
  }
  else
  {
    v2 = a1->var3.sin6_addr.__u6_addr8[1] ^ a2->var3.sin6_addr.__u6_addr8[1];
    if (v2)
    {
      result = 8;
    }
    else
    {
      v2 = a1->var3.sin6_addr.__u6_addr8[2] ^ a2->var3.sin6_addr.__u6_addr8[2];
      if (v2)
      {
        result = 16;
      }
      else
      {
        v2 = a1->var3.sin6_addr.__u6_addr8[3] ^ a2->var3.sin6_addr.__u6_addr8[3];
        if (v2)
        {
          result = 24;
        }
        else
        {
          v2 = a1->var3.sin6_addr.__u6_addr8[4] ^ a2->var3.sin6_addr.__u6_addr8[4];
          if (v2)
          {
            result = 32;
          }
          else
          {
            v2 = a1->var3.sin6_addr.__u6_addr8[5] ^ a2->var3.sin6_addr.__u6_addr8[5];
            if (v2)
            {
              result = 40;
            }
            else
            {
              v2 = a1->var3.sin6_addr.__u6_addr8[6] ^ a2->var3.sin6_addr.__u6_addr8[6];
              if (v2)
              {
                result = 48;
              }
              else
              {
                v2 = a1->var3.sin6_addr.__u6_addr8[7] ^ a2->var3.sin6_addr.__u6_addr8[7];
                if (!v2)
                  return 64;
                result = 56;
              }
            }
          }
        }
      }
    }
  }
  for (; (v2 & 0x80) == 0; v2 *= 2)
    result = (result + 1);
  return result;
}

void sa_dst_fill_netsrc(unsigned __int8 *a1)
{
  int control_socket;
  int v3;
  int v4;
  size_t v5;
  NSObject *v6;
  int v7;
  unint64_t StatusReg;
  int v9;
  NSObject *v10;
  const char *v11;
  uint8_t *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  int v17;
  uint8_t v18;
  int v19;
  uint64_t v20;
  char *backtrace_string;
  _BOOL4 v22;
  int v23;
  os_log_type_t type[4];
  int v25;
  _QWORD v26[3];
  int v27;
  uint8_t buf[48];
  uint64_t v29;
  uint8_t v30[4];
  const char *v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  control_socket = sa_dst_fill_netsrc(Destination *)::netsrc_sockfd;
  if (sa_dst_fill_netsrc(Destination *)::netsrc_sockfd < 0)
  {
    control_socket = nw_create_control_socket((uint64_t)"com.apple.netsrc");
    sa_dst_fill_netsrc(Destination *)::netsrc_sockfd = control_socket;
    if (control_socket < 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "sa_dst_fill_netsrc";
      v13 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v30[0] = 0;
      if (!__nwlog_fault(v13, type, v30))
        goto LABEL_41;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_41;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "sa_dst_fill_netsrc";
        v16 = "%{public}s nw_create_control_socket failed";
      }
      else if (v30[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type[0];
        v22 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "sa_dst_fill_netsrc";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s nw_create_control_socket failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_41;
        }
        if (!v22)
        {
LABEL_41:
          if (v13)
            free(v13);
          return;
        }
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "sa_dst_fill_netsrc";
        v16 = "%{public}s nw_create_control_socket failed, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_41;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "sa_dst_fill_netsrc";
        v16 = "%{public}s nw_create_control_socket failed, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
      goto LABEL_41;
    }
  }
  memset(v26, 0, sizeof(v26));
  v27 = 0;
  if (sa_dst_fill_netsrc(Destination *)::version)
    v3 = 1;
  else
    v3 = 2;
  v4 = *((_DWORD *)a1 + 18);
  *(_DWORD *)type = v3;
  v25 = v4;
  v5 = *a1;
  if (v5 >= 0x1D)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "sa_dst_fill_netsrc";
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s sockaddr is too big", buf, 0xCu);
    }
    return;
  }
  memcpy(v26, a1, v5);
  if (send(control_socket, type, 0x24uLL, 0) == 36)
  {
    if (sa_dst_fill_netsrc(Destination *)::version == 1)
    {
      memset(buf, 0, 40);
      if (recv(sa_dst_fill_netsrc(Destination *)::netsrc_sockfd, buf, 0x28uLL, 0) == 40)
      {
        *((_DWORD *)a1 + 8) = *(_DWORD *)&buf[34];
        if (buf[0] <= 0x1CuLL)
          memcpy(a1 + 36, buf, buf[0]);
        v7 = *(_DWORD *)&buf[30];
        *((_DWORD *)a1 + 16) = *(unsigned __int16 *)&buf[28];
        *((_DWORD *)a1 + 17) = v7;
        return;
      }
      v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        return;
      goto LABEL_34;
    }
    v29 = 0;
    memset(buf, 0, sizeof(buf));
    if (recv(sa_dst_fill_netsrc(Destination *)::netsrc_sockfd, buf, 0x38uLL, 0) == 56)
    {
      v17 = *(_DWORD *)&buf[44];
      *((_DWORD *)a1 + 8) = v29;
      *(_OWORD *)(a1 + 36) = *(_OWORD *)buf;
      *((_OWORD *)a1 + 3) = *(_OWORD *)&buf[12];
      v19 = *(_DWORD *)&buf[36];
      v18 = buf[40];
      *((_DWORD *)a1 + 16) = *(_DWORD *)&buf[40];
      *((_DWORD *)a1 + 17) = v17;
      *((_DWORD *)a1 + 19) = WORD2(v29);
      v20 = *(_QWORD *)&buf[28];
      *((_DWORD *)a1 + 22) = v19;
      *((_QWORD *)a1 + 10) = v20;
      a1[92] = a1[92] & 0xF8 | (v18 >> 5);
      return;
    }
    v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
LABEL_34:
      *(_DWORD *)v30 = 136446466;
      v31 = "sa_dst_fill_netsrc";
      v32 = 1024;
      v33 = v23;
      v11 = "%{public}s recv failed %{darwin.errno}d";
      v12 = v30;
      goto LABEL_35;
    }
  }
  else
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v9 = **(_DWORD **)(StatusReg + 8);
    if (v9 == 22 && (sa_dst_fill_netsrc(Destination *)::version & 1) == 0)
    {
      sa_dst_fill_netsrc(Destination *)::version = 1;
      sa_dst_fill_netsrc(a1);
      v9 = **(_DWORD **)(StatusReg + 8);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "sa_dst_fill_netsrc";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      v11 = "%{public}s send failed %{darwin.errno}d";
      v12 = buf;
LABEL_35:
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, v11, v12, 0x12u);
    }
  }
}

uint64_t nw_create_control_socket(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  char *v5;
  uint64_t v6;
  os_log_type_t v7;
  const char *v8;
  uint64_t v9;
  int v10;
  int v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  const char *v18;
  uint8_t *v19;
  NSObject *v20;
  os_log_type_t v21;
  uint32_t v22;
  uint8_t *v23;
  NSObject *v24;
  os_log_type_t v25;
  uint32_t v26;
  uint64_t result;
  char *v28;
  _BOOL4 v29;
  int v30;
  int v31;
  int v32;
  NSObject *v33;
  os_log_type_t v34;
  int v35;
  NSObject *v36;
  os_log_type_t v37;
  char *v38;
  _BOOL4 v39;
  _BOOL4 v40;
  NSObject *v41;
  void *v42;
  int v43;
  uint64_t v44;
  char v45;
  os_log_type_t v46;
  int v47;
  _BYTE v48[20];
  uint64_t v49;
  int v50;
  int v51;
  os_log_type_t type[4];
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  _QWORD v59[2];
  uint8_t buf[32];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  int v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v2 = socket(32, 2, 2);
  v3 = v2;
  if ((v2 & 0x80000000) != 0)
  {
    v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_create_control_socket";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v4;
    v5 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v48[0] = 0;
    if (!__nwlog_fault(v5, type, v48))
      goto LABEL_33;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_33;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_create_control_socket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v4;
      v8 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d";
    }
    else if (v48[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      v17 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (backtrace_string)
      {
        if (!v17)
          goto LABEL_25;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_create_control_socket";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v4;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = backtrace_string;
        v18 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, dumping backtrace:%{public}s";
        v19 = buf;
        v20 = v6;
        v21 = v7;
        v22 = 28;
        goto LABEL_24;
      }
      if (!v17)
        goto LABEL_33;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_create_control_socket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v4;
      v8 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_33;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_create_control_socket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v4;
      v8 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, backtrace limit exceeded";
    }
    v23 = buf;
    v24 = v6;
    v25 = v7;
    v26 = 18;
LABEL_32:
    _os_log_impl(&dword_182FBE000, v24, v25, v8, v23, v26);
    goto LABEL_33;
  }
  v51 = 1;
  if (setsockopt(v2, 0xFFFF, 4130, &v51, 4u))
  {
LABEL_3:
    close(v3);
    return 0xFFFFFFFFLL;
  }
  v65 = 0;
  v63 = 0u;
  v64 = 0u;
  v62 = 0u;
  v61 = 0u;
  memset(buf, 0, sizeof(buf));
  if (a1)
  {
LABEL_9:
    v9 = 0;
    while (1)
    {
      v10 = *(unsigned __int8 *)(a1 + v9);
      buf[v9 + 4] = v10;
      if (!v10)
        break;
      if (++v9 == 95)
      {
        HIBYTE(v65) = 0;
        break;
      }
    }
    if (ioctl(v3, 0xC0644E03uLL, buf, v43) < 0)
      goto LABEL_3;
    *(_DWORD *)v48 = 139296;
    *(_DWORD *)&v48[4] = *(_DWORD *)buf;
    *(_DWORD *)&v48[8] = 0;
    *(_QWORD *)&v48[12] = 0;
    v49 = 0;
    v50 = 0;
    if (connect(v3, (const sockaddr *)v48, 0x20u))
      goto LABEL_3;
    v47 = 0x20000;
    if (!setsockopt(v3, 0xFFFF, 4098, &v47, 4u))
      goto LABEL_48;
    v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)type = 136446978;
    v53 = "nw_create_control_socket";
    v54 = 1024;
    v55 = v3;
    v56 = 1024;
    v57 = v47;
    v58 = 1024;
    LODWORD(v59[0]) = v11;
    LODWORD(v44) = 30;
    v12 = (char *)_os_log_send_and_compose_impl();
    v46 = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v12, &v46, &v45))
    {
      if (v46 == OS_LOG_TYPE_FAULT)
      {
        v13 = __nwlog_obj();
        v14 = v46;
        if (!os_log_type_enabled(v13, v46))
          goto LABEL_46;
        *(_DWORD *)type = 136446978;
        v53 = "nw_create_control_socket";
        v54 = 1024;
        v55 = v3;
        v56 = 1024;
        v57 = v47;
        v58 = 1024;
        LODWORD(v59[0]) = v11;
        v15 = "%{public}s setsockopt(%d, SOL_SOCKET, SO_RCVBUF, %d) %{darwin.errno}d";
        goto LABEL_45;
      }
      if (!v45)
      {
        v13 = __nwlog_obj();
        v14 = v46;
        if (!os_log_type_enabled(v13, v46))
          goto LABEL_46;
        *(_DWORD *)type = 136446978;
        v53 = "nw_create_control_socket";
        v54 = 1024;
        v55 = v3;
        v56 = 1024;
        v57 = v47;
        v58 = 1024;
        LODWORD(v59[0]) = v11;
        v15 = "%{public}s setsockopt(%d, SOL_SOCKET, SO_RCVBUF, %d) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_45;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = v46;
      v29 = os_log_type_enabled(v13, v46);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)type = 136447234;
          v53 = "nw_create_control_socket";
          v54 = 1024;
          v55 = v3;
          v56 = 1024;
          v57 = v47;
          v58 = 1024;
          LODWORD(v59[0]) = v11;
          WORD2(v59[0]) = 2082;
          *(_QWORD *)((char *)v59 + 6) = v28;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s setsockopt(%d, SOL_SOCKET, SO_RCVBUF, %d) %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)type, 0x28u);
        }
        free(v28);
        goto LABEL_46;
      }
      if (v29)
      {
        *(_DWORD *)type = 136446978;
        v53 = "nw_create_control_socket";
        v54 = 1024;
        v55 = v3;
        v56 = 1024;
        v57 = v47;
        v58 = 1024;
        LODWORD(v59[0]) = v11;
        v15 = "%{public}s setsockopt(%d, SOL_SOCKET, SO_RCVBUF, %d) %{darwin.errno}d, no backtrace";
LABEL_45:
        _os_log_impl(&dword_182FBE000, v13, v14, v15, (uint8_t *)type, 0x1Eu);
      }
    }
LABEL_46:
    if (v12)
      free(v12);
LABEL_48:
    v30 = fcntl(v3, 3, 0, v44);
    if (v30 != -1)
    {
      v31 = v30 | 4;
      if (fcntl(v3, 4, v30 | 4u) != -1)
        return v3;
      v32 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      __nwlog_obj();
      *(_DWORD *)type = 136446978;
      v53 = "nw_create_control_socket";
      v54 = 1024;
      v55 = v3;
      v56 = 1024;
      v57 = v31;
      v58 = 1024;
      LODWORD(v59[0]) = v32;
      v5 = (char *)_os_log_send_and_compose_impl();
      v46 = OS_LOG_TYPE_ERROR;
      v45 = 0;
      if (!__nwlog_fault(v5, &v46, &v45))
        goto LABEL_33;
      if (v46 == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = v46;
        if (os_log_type_enabled(v33, v46))
        {
          *(_DWORD *)type = 136446978;
          v53 = "nw_create_control_socket";
          v54 = 1024;
          v55 = v3;
          v56 = 1024;
          v57 = v31;
          v58 = 1024;
          LODWORD(v59[0]) = v32;
          v8 = "%{public}s fcntl(%d, F_SETFL, %d) %{darwin.errno}d";
LABEL_76:
          v23 = (uint8_t *)type;
          v24 = v33;
          v25 = v34;
          v26 = 30;
          goto LABEL_32;
        }
        goto LABEL_33;
      }
      if (!v45)
      {
        v33 = __nwlog_obj();
        v34 = v46;
        if (os_log_type_enabled(v33, v46))
        {
          *(_DWORD *)type = 136446978;
          v53 = "nw_create_control_socket";
          v54 = 1024;
          v55 = v3;
          v56 = 1024;
          v57 = v31;
          v58 = 1024;
          LODWORD(v59[0]) = v32;
          v8 = "%{public}s fcntl(%d, F_SETFL, %d) %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_76;
        }
LABEL_33:
        if (!v5)
          return v3;
LABEL_34:
        free(v5);
        return v3;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = v46;
      v40 = os_log_type_enabled(v33, v46);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)type = 136446978;
          v53 = "nw_create_control_socket";
          v54 = 1024;
          v55 = v3;
          v56 = 1024;
          v57 = v31;
          v58 = 1024;
          LODWORD(v59[0]) = v32;
          v8 = "%{public}s fcntl(%d, F_SETFL, %d) %{darwin.errno}d, no backtrace";
          goto LABEL_76;
        }
        goto LABEL_33;
      }
      if (!v40)
      {
LABEL_25:
        free(backtrace_string);
        if (!v5)
          return v3;
        goto LABEL_34;
      }
      *(_DWORD *)type = 136447234;
      v53 = "nw_create_control_socket";
      v54 = 1024;
      v55 = v3;
      v56 = 1024;
      v57 = v31;
      v58 = 1024;
      LODWORD(v59[0]) = v32;
      WORD2(v59[0]) = 2082;
      *(_QWORD *)((char *)v59 + 6) = backtrace_string;
      v18 = "%{public}s fcntl(%d, F_SETFL, %d) %{darwin.errno}d, dumping backtrace:%{public}s";
      v19 = (uint8_t *)type;
      v20 = v33;
      v21 = v34;
      v22 = 40;
LABEL_24:
      _os_log_impl(&dword_182FBE000, v20, v21, v18, v19, v22);
      goto LABEL_25;
    }
    v35 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)type = 136446722;
    v53 = "nw_create_control_socket";
    v54 = 1024;
    v55 = v3;
    v56 = 1024;
    v57 = v35;
    v5 = (char *)_os_log_send_and_compose_impl();
    v46 = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v5, &v46, &v45))
      goto LABEL_33;
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      v36 = __nwlog_obj();
      v37 = v46;
      if (!os_log_type_enabled(v36, v46))
        goto LABEL_33;
      *(_DWORD *)type = 136446722;
      v53 = "nw_create_control_socket";
      v54 = 1024;
      v55 = v3;
      v56 = 1024;
      v57 = v35;
      v8 = "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d";
    }
    else if (v45)
    {
      v38 = (char *)__nw_create_backtrace_string();
      v36 = __nwlog_obj();
      v37 = v46;
      v39 = os_log_type_enabled(v36, v46);
      if (v38)
      {
        if (v39)
        {
          *(_DWORD *)type = 136446978;
          v53 = "nw_create_control_socket";
          v54 = 1024;
          v55 = v3;
          v56 = 1024;
          v57 = v35;
          v58 = 2082;
          v59[0] = v38;
          _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)type, 0x22u);
        }
        free(v38);
        goto LABEL_33;
      }
      if (!v39)
        goto LABEL_33;
      *(_DWORD *)type = 136446722;
      v53 = "nw_create_control_socket";
      v54 = 1024;
      v55 = v3;
      v56 = 1024;
      v57 = v35;
      v8 = "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d, no backtrace";
    }
    else
    {
      v36 = __nwlog_obj();
      v37 = v46;
      if (!os_log_type_enabled(v36, v46))
        goto LABEL_33;
      *(_DWORD *)type = 136446722;
      v53 = "nw_create_control_socket";
      v54 = 1024;
      v55 = v3;
      v56 = 1024;
      v57 = v35;
      v8 = "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d, backtrace limit exceeded";
    }
    v23 = (uint8_t *)type;
    v24 = v36;
    v25 = v37;
    v26 = 24;
    goto LABEL_32;
  }
  v41 = __nwlog_obj();
  os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  *(_DWORD *)type = 136446210;
  v53 = "_strict_strlcpy";
  v43 = 12;
  v42 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v42);
  if (!(_DWORD)result)
  {
    free(v42);
    goto LABEL_9;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_metadata_is_ip(nw_protocol_metadata_t metadata)
{
  id v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (metadata)
  {
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_52132);
    return nw_protocol_metadata_matches_definition((uint64_t)metadata, g_ip_definition);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_metadata_is_ip_unsafe";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_protocol_metadata_is_ip_unsafe";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v4)
    free(v4);
  return 0;
}

void nw_association_mark_flow_connected(void *a1, void *a2)
{
  id v3;
  char *v4;
  char *v5;
  id v6;
  uint64_t v7;
  _BOOL8 node;
  _BOOL8 v9;
  uint64_t internal;
  NSObject *v11;
  const char *v12;
  id v13;
  const char *logging_description;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  id v19;
  const char *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  char *v24;
  os_log_type_t v25;
  const char *v26;
  uint64_t v27;
  char *v28;
  id v29;
  const char *v30;
  const char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  const char *v35;
  os_log_type_t v36;
  const char *v37;
  os_log_type_t v38;
  const char *v39;
  os_log_type_t v40;
  const char *v41;
  os_log_type_t v42;
  const char *v43;
  const char *v44;
  char *v45;
  NSObject *v46;
  os_log_type_t v47;
  const char *v48;
  os_log_type_t v49;
  const char *v50;
  char *v51;
  os_log_type_t v52;
  const char *v53;
  os_log_type_t v54;
  const char *v55;
  void *v56;
  os_log_type_t v57;
  void *v58;
  os_log_type_t v59;
  char *backtrace_string;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  _BOOL4 v64;
  os_log_type_t v65;
  os_log_type_t v66;
  char v67;
  os_log_type_t v68;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v71;
  __int16 v72;
  void *v73;
  __int16 v74;
  char *v75;
  __int16 v76;
  char *v77;
  __int16 v78;
  char *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_association_mark_flow_connected";
    v15 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v57 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_182FBE000, v16, v57, "%{public}s called with null association", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v68 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v65 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_182FBE000, v16, v65, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_89;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_182FBE000, v16, v61, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v16, v61, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    goto LABEL_90;
  }
  if (!v4)
  {
    __nwlog_obj();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_association_mark_flow_connected";
    v15 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_182FBE000, v16, v59, "%{public}s called with null handle", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v68 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v66 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_182FBE000, v16, v66, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_89;
      }
      v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v63 = type;
      v64 = os_log_type_enabled(v16, type);
      if (!v24)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_182FBE000, v16, v63, "%{public}s called with null handle, no backtrace", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v64)
      {
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = v24;
        _os_log_impl(&dword_182FBE000, v16, v63, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_60;
    }
LABEL_90:
    if (!v15)
      goto LABEL_93;
    goto LABEL_91;
  }
  v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);

  v7 = *((_QWORD *)v3 + 5);
  if (!v7)
  {
    if (nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
      goto LABEL_93;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v13 = (id)gconnectionLogObj;
    logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446466;
    v71 = "nw_association_mark_flow_connected";
    v72 = 2082;
    v73 = (void *)logging_description;
    v15 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &type, &v68))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        v18 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = (void *)v18;
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s <nw_association %{public}s> does not have a handle hash table", buf, 0x16u);
      }
      goto LABEL_89;
    }
    if (v68 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v38 = type;
      if (os_log_type_enabled(v16, type))
      {
        v39 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = (void *)v39;
        _os_log_impl(&dword_182FBE000, v16, v38, "%{public}s <nw_association %{public}s> does not have a handle hash table, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_89;
    }
    v23 = __nw_create_backtrace_string();
    if (!v23)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v40 = type;
      if (os_log_type_enabled(v16, type))
      {
        v41 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = (void *)v41;
        _os_log_impl(&dword_182FBE000, v16, v40, "%{public}s <nw_association %{public}s> does not have a handle hash table, no backtrace", buf, 0x16u);
      }
      goto LABEL_89;
    }
    v24 = (char *)v23;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v16 = (id)gconnectionLogObj;
    v25 = type;
    if (os_log_type_enabled(v16, type))
    {
      v26 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446722;
      v71 = "nw_association_mark_flow_connected";
      v72 = 2082;
      v73 = (void *)v26;
      v74 = 2082;
      v75 = v24;
      _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s <nw_association %{public}s> does not have a handle hash table, dumping backtrace:%{public}s", buf, 0x20u);
    }
    goto LABEL_60;
  }
  node = nw_hash_table_get_node(v7, (uint64_t)v5, 0);
  if (!node)
  {
    if (nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
      goto LABEL_93;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v19 = (id)gconnectionLogObj;
    v20 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446722;
    v71 = "nw_association_mark_flow_connected";
    v72 = 2082;
    v73 = (void *)v20;
    v74 = 2048;
    v75 = v5;
    v15 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v68 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &type, &v68))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        v22 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = (void *)v22;
        v74 = 2048;
        v75 = v5;
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s <nw_association %{public}s> does not have handle %p registered", buf, 0x20u);
      }
LABEL_89:

      goto LABEL_90;
    }
    if (v68 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v42 = type;
      if (os_log_type_enabled(v16, type))
      {
        v43 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = (void *)v43;
        v74 = 2048;
        v75 = v5;
        _os_log_impl(&dword_182FBE000, v16, v42, "%{public}s <nw_association %{public}s> does not have handle %p registered, backtrace limit exceeded", buf, 0x20u);
      }
      goto LABEL_89;
    }
    v35 = __nw_create_backtrace_string();
    if (!v35)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v49 = type;
      if (os_log_type_enabled(v16, type))
      {
        v50 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = (void *)v50;
        v74 = 2048;
        v75 = v5;
        _os_log_impl(&dword_182FBE000, v16, v49, "%{public}s <nw_association %{public}s> does not have handle %p registered, no backtrace", buf, 0x20u);
      }
      goto LABEL_89;
    }
    v24 = (char *)v35;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v16 = (id)gconnectionLogObj;
    v36 = type;
    if (os_log_type_enabled(v16, type))
    {
      v37 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      v71 = "nw_association_mark_flow_connected";
      v72 = 2082;
      v73 = (void *)v37;
      v74 = 2048;
      v75 = v5;
      v76 = 2082;
      v77 = v24;
      _os_log_impl(&dword_182FBE000, v16, v36, "%{public}s <nw_association %{public}s> does not have handle %p registered, dumping backtrace:%{public}s", buf, 0x2Au);
    }
LABEL_60:

    free(v24);
    if (!v15)
      goto LABEL_93;
LABEL_91:
    v51 = (char *)v15;
LABEL_92:
    free(v51);
    goto LABEL_93;
  }
  v9 = node;
  internal = *((_QWORD *)v3 + 6);
  if (!internal)
  {
    internal = nw_hash_table_create_internal(7u, 16, (const void *(*)(const void *, unsigned int *))nw_association_get_key, (unsigned int (*)(const void *, unsigned int))nw_association_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_association_matches_key, (void (*)(void *))nw_association_release);
    if (internal)
      *(_DWORD *)(internal + 48) &= ~2u;
    *((_QWORD *)v3 + 6) = internal;
  }
  if (nw_hash_table_get_node(internal, (uint64_t)v5, 0))
  {
    if (!nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        v12 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_connected";
        v72 = 2082;
        v73 = (void *)v12;
        v74 = 2048;
        v75 = v5;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s <nw_association %{public}s> already has connected flow %p registered", buf, 0x20u);
      }

    }
    goto LABEL_93;
  }
  type = OS_LOG_TYPE_DEFAULT;
  v27 = *((_QWORD *)v3 + 6);
  v28 = v5;
  nw_hash_table_add_object(v27, (uint64_t)v28, (char *)&type);
  if (type || nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
    goto LABEL_93;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v29 = (id)gconnectionLogObj;
  v30 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
  *(_DWORD *)buf = 136446978;
  v71 = "nw_association_mark_flow_connected";
  v72 = 2082;
  v73 = (void *)v30;
  v74 = 2048;
  v75 = v28;
  v76 = 2048;
  v77 = (char *)v9;
  v31 = (const char *)_os_log_send_and_compose_impl();

  v68 = OS_LOG_TYPE_ERROR;
  v67 = 0;
  if (!__nwlog_fault(v31, &v68, &v67))
    goto LABEL_104;
  if (v68 == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v32 = (id)gconnectionLogObj;
    v33 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      v34 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      v71 = "nw_association_mark_flow_connected";
      v72 = 2082;
      v73 = (void *)v34;
      v74 = 2048;
      v75 = v28;
      v76 = 2048;
      v77 = (char *)v9;
      _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p)", buf, 0x2Au);
    }
LABEL_103:

LABEL_104:
    if (!v31)
      goto LABEL_93;
    goto LABEL_105;
  }
  if (!v67)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v32 = (id)gconnectionLogObj;
    v52 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      v53 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      v71 = "nw_association_mark_flow_connected";
      v72 = 2082;
      v73 = (void *)v53;
      v74 = 2048;
      v75 = v28;
      v76 = 2048;
      v77 = (char *)v9;
      _os_log_impl(&dword_182FBE000, v32, v52, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), backtrace limit exceeded", buf, 0x2Au);
    }
    goto LABEL_103;
  }
  v44 = __nw_create_backtrace_string();
  if (!v44)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v32 = (id)gconnectionLogObj;
    v54 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      v55 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      v71 = "nw_association_mark_flow_connected";
      v72 = 2082;
      v73 = (void *)v55;
      v74 = 2048;
      v75 = v28;
      v76 = 2048;
      v77 = (char *)v9;
      _os_log_impl(&dword_182FBE000, v32, v54, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), no backtrace", buf, 0x2Au);
    }
    goto LABEL_103;
  }
  v45 = (char *)v44;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v46 = (id)gconnectionLogObj;
  v47 = v68;
  if (os_log_type_enabled(v46, v68))
  {
    v48 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136447234;
    v71 = "nw_association_mark_flow_connected";
    v72 = 2082;
    v73 = (void *)v48;
    v74 = 2048;
    v75 = v28;
    v76 = 2048;
    v77 = (char *)v9;
    v78 = 2082;
    v79 = v45;
    _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), dumping backtrace:%{public}s", buf, 0x34u);
  }

  free(v45);
  if (v31)
  {
LABEL_105:
    v51 = (char *)v31;
    goto LABEL_92;
  }
LABEL_93:

}

void sub_182FFF7A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_association_set_cached_content_for_protocol(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7;
  id v8;
  void *v9;
  id v10;
  uint64_t internal;
  _BOOL8 node;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  id v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  const char *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  os_log_type_t v27;
  const char *v28;
  os_log_type_t v29;
  const char *v30;
  uint64_t v31;
  id v32;
  _BOOL8 v33;
  char *v34;
  id v35;
  const char *logging_description;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  id v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  char *v45;
  os_log_type_t v46;
  _BOOL4 v47;
  const char *v48;
  char *v49;
  NSObject *v50;
  os_log_type_t v51;
  const char *v52;
  os_log_type_t v53;
  os_log_type_t v54;
  const char *v55;
  os_log_type_t v56;
  const char *v57;
  void *v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  void *v62;
  os_log_type_t v63;
  char *backtrace_string;
  os_log_type_t v65;
  _BOOL4 v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  os_log_type_t v71;
  uint64_t v72;
  uint64_t v73;
  char v74;
  os_log_type_t v75;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v78;
  __int16 v79;
  void *v80;
  __int16 v81;
  uint64_t v82;
  __int16 v83;
  char *v84;
  __int16 v85;
  char *v86;
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v9 = v8;
  if (!v7)
  {
    __nwlog_obj();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_association_set_cached_content_for_protocol";
    v59 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v75 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v59, &type, &v75))
      goto LABEL_133;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_association_set_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v75)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v65 = type;
      v66 = os_log_type_enabled(v60, type);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          v78 = "nw_association_set_cached_content_for_protocol";
          v79 = 2082;
          v80 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v60, v65, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_133:
        if (!v59)
          goto LABEL_99;
LABEL_134:
        free(v59);
        goto LABEL_99;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_association_set_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v60, v65, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v70 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_association_set_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v60, v70, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_132:

    goto LABEL_133;
  }
  if (v8)
  {
    v10 = nw_path_parameters_copy_context(*((void **)v7 + 2));
    nw_context_assert_queue(v10);
    internal = *((_QWORD *)v7 + 7);
    if (!internal)
    {
      internal = nw_hash_table_create_internal(5u, 48, (const void *(*)(const void *, unsigned int *))nw_association_get_key, (unsigned int (*)(const void *, unsigned int))nw_association_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_association_matches_key, (void (*)(void *))nw_association_release);
      if (!internal)
      {
        *((_QWORD *)v7 + 7) = 0;
        goto LABEL_98;
      }
      *(_DWORD *)(internal + 48) &= ~2u;
      *((_QWORD *)v7 + 7) = internal;
    }
    node = nw_hash_table_get_node(internal, (uint64_t)v9, 0);
    if (!node)
      goto LABEL_44;
    v13 = node;
    v14 = (uint64_t *)(node + 32);
    v15 = *(_QWORD *)(node + 72);
    if (v15)
    {
      if (v15 == a3)
      {
        *(_QWORD *)(node + 64) = a4;
        nw_context_remove_cache_entry(v10, v14);
        nw_context_add_cache_entry(v10, v14);
        goto LABEL_98;
      }
      nw_protocol_definition_deallocate_cache_entry(v9, v15);
    }
    nw_context_remove_cache_entry(v10, v14);
    if (nw_hash_table_remove_node(*((_QWORD *)v7 + 7), v13)
      || nw_path_parameters_get_logging_disabled(*((_QWORD *)v7 + 2)))
    {
LABEL_44:
      if (a3)
      {
        type = OS_LOG_TYPE_DEFAULT;
        v31 = *((_QWORD *)v7 + 7);
        v32 = v9;
        v33 = nw_hash_table_add_object(v31, (uint64_t)v32, (char *)&type);
        if (v33)
        {
          v34 = (char *)v33;
          if (type || nw_path_parameters_get_logging_disabled(*((_QWORD *)v7 + 2)))
            goto LABEL_97;
          v73 = a4;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v35 = (id)gconnectionLogObj;
          logging_description = nw_endpoint_get_logging_description(*((void **)v7 + 1));
          *(_DWORD *)buf = 136446978;
          v78 = "nw_association_set_cached_content_for_protocol";
          v79 = 2082;
          v80 = (void *)logging_description;
          v81 = 2048;
          v82 = (uint64_t)v32;
          v83 = 2048;
          v84 = v34;
          v37 = (char *)_os_log_send_and_compose_impl();

          v75 = OS_LOG_TYPE_ERROR;
          v74 = 0;
          if (__nwlog_fault(v37, &v75, &v74))
          {
            if (v75 == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v38 = (id)gconnectionLogObj;
              v39 = v75;
              if (os_log_type_enabled(v38, v75))
              {
                v40 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
                *(_DWORD *)buf = 136446978;
                v78 = "nw_association_set_cached_content_for_protocol";
                v79 = 2082;
                v80 = (void *)v40;
                v81 = 2048;
                v82 = (uint64_t)v32;
                v83 = 2048;
                v84 = v34;
                _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s <nw_association %{public}s> failed to add cached content for protocol %p (node %p)", buf, 0x2Au);
              }
            }
            else if (v74)
            {
              v48 = __nw_create_backtrace_string();
              if (v48)
              {
                v49 = (char *)v48;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v50 = (id)gconnectionLogObj;
                v51 = v75;
                if (os_log_type_enabled(v50, v75))
                {
                  v52 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
                  *(_DWORD *)buf = 136447234;
                  v78 = "nw_association_set_cached_content_for_protocol";
                  v79 = 2082;
                  v80 = (void *)v52;
                  v81 = 2048;
                  v82 = (uint64_t)v32;
                  v83 = 2048;
                  v84 = v34;
                  v85 = 2082;
                  v86 = v49;
                  _os_log_impl(&dword_182FBE000, v50, v51, "%{public}s <nw_association %{public}s> failed to add cached content for protocol %p (node %p), dumping backtrace:%{public}s", buf, 0x34u);
                }

                free(v49);
                if (!v37)
                  goto LABEL_96;
                goto LABEL_95;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v38 = (id)gconnectionLogObj;
              v56 = v75;
              if (os_log_type_enabled(v38, v75))
              {
                v57 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
                *(_DWORD *)buf = 136446978;
                v78 = "nw_association_set_cached_content_for_protocol";
                v79 = 2082;
                v80 = (void *)v57;
                v81 = 2048;
                v82 = (uint64_t)v32;
                v83 = 2048;
                v84 = v34;
                _os_log_impl(&dword_182FBE000, v38, v56, "%{public}s <nw_association %{public}s> failed to add cached content for protocol %p (node %p), no backtrace", buf, 0x2Au);
              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v38 = (id)gconnectionLogObj;
              v54 = v75;
              if (os_log_type_enabled(v38, v75))
              {
                v55 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
                *(_DWORD *)buf = 136446978;
                v78 = "nw_association_set_cached_content_for_protocol";
                v79 = 2082;
                v80 = (void *)v55;
                v81 = 2048;
                v82 = (uint64_t)v32;
                v83 = 2048;
                v84 = v34;
                _os_log_impl(&dword_182FBE000, v38, v54, "%{public}s <nw_association %{public}s> failed to add cached content for protocol %p (node %p), backtrace limit exceeded", buf, 0x2Au);
              }
            }

          }
          if (!v37)
          {
LABEL_96:
            a4 = v73;
LABEL_97:
            *((_QWORD *)v34 + 8) = a4;
            *((_QWORD *)v34 + 9) = a3;
            nw_context_add_cache_entry(v10, (_QWORD *)v34 + 4);
            goto LABEL_98;
          }
LABEL_95:
          free(v37);
          goto LABEL_96;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v78 = "nw_association_set_cached_content_for_protocol";
        v42 = (char *)_os_log_send_and_compose_impl();

        v75 = OS_LOG_TYPE_ERROR;
        v74 = 0;
        if (__nwlog_fault(v42, &v75, &v74))
        {
          if (v75 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = (id)gLogObj;
            v44 = v75;
            if (os_log_type_enabled(v43, v75))
            {
              *(_DWORD *)buf = 136446210;
              v78 = "nw_association_set_cached_content_for_protocol";
              _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s nw_hash_table_add_object failed", buf, 0xCu);
            }
          }
          else if (v74)
          {
            v45 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = (id)gLogObj;
            v46 = v75;
            v47 = os_log_type_enabled(v43, v75);
            if (v45)
            {
              if (v47)
              {
                *(_DWORD *)buf = 136446466;
                v78 = "nw_association_set_cached_content_for_protocol";
                v79 = 2082;
                v80 = v45;
                _os_log_impl(&dword_182FBE000, v43, v46, "%{public}s nw_hash_table_add_object failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v45);
              if (!v42)
                goto LABEL_98;
              goto LABEL_83;
            }
            if (v47)
            {
              *(_DWORD *)buf = 136446210;
              v78 = "nw_association_set_cached_content_for_protocol";
              _os_log_impl(&dword_182FBE000, v43, v46, "%{public}s nw_hash_table_add_object failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = (id)gLogObj;
            v53 = v75;
            if (os_log_type_enabled(v43, v75))
            {
              *(_DWORD *)buf = 136446210;
              v78 = "nw_association_set_cached_content_for_protocol";
              _os_log_impl(&dword_182FBE000, v43, v53, "%{public}s nw_hash_table_add_object failed, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
        if (v42)
LABEL_83:
          free(v42);
      }
LABEL_98:

      goto LABEL_99;
    }
    v72 = a4;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v16 = (id)gconnectionLogObj;
    v17 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
    *(_DWORD *)buf = 136446722;
    v78 = "nw_association_set_cached_content_for_protocol";
    v79 = 2082;
    v80 = (void *)v17;
    v81 = 2048;
    v82 = v13;
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v75 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v18, &type, &v75))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = (id)gconnectionLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          v21 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
          *(_DWORD *)buf = 136446722;
          v78 = "nw_association_set_cached_content_for_protocol";
          v79 = 2082;
          v80 = (void *)v21;
          v81 = 2048;
          v82 = v13;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p", buf, 0x20u);
        }
      }
      else if (v75)
      {
        v22 = __nw_create_backtrace_string();
        if (v22)
        {
          v23 = (char *)v22;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v24 = (id)gconnectionLogObj;
          v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            v26 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
            *(_DWORD *)buf = 136446978;
            v78 = "nw_association_set_cached_content_for_protocol";
            v79 = 2082;
            v80 = (void *)v26;
            v81 = 2048;
            v82 = v13;
            v83 = 2082;
            v84 = v23;
            _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v23);
          if (!v18)
            goto LABEL_43;
          goto LABEL_42;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = (id)gconnectionLogObj;
        v29 = type;
        if (os_log_type_enabled(v19, type))
        {
          v30 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
          *(_DWORD *)buf = 136446722;
          v78 = "nw_association_set_cached_content_for_protocol";
          v79 = 2082;
          v80 = (void *)v30;
          v81 = 2048;
          v82 = v13;
          _os_log_impl(&dword_182FBE000, v19, v29, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = (id)gconnectionLogObj;
        v27 = type;
        if (os_log_type_enabled(v19, type))
        {
          v28 = nw_endpoint_get_logging_description(*((void **)v7 + 1));
          *(_DWORD *)buf = 136446722;
          v78 = "nw_association_set_cached_content_for_protocol";
          v79 = 2082;
          v80 = (void *)v28;
          v81 = 2048;
          v82 = v13;
          _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
    if (!v18)
    {
LABEL_43:
      a4 = v72;
      goto LABEL_44;
    }
LABEL_42:
    free(v18);
    goto LABEL_43;
  }
  __nwlog_obj();
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v78 = "nw_association_set_cached_content_for_protocol";
  v59 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v75 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v59, &type, &v75))
    goto LABEL_133;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v60 = objc_claimAutoreleasedReturnValue();
    v63 = type;
    if (os_log_type_enabled(v60, type))
    {
      *(_DWORD *)buf = 136446210;
      v78 = "nw_association_set_cached_content_for_protocol";
      _os_log_impl(&dword_182FBE000, v60, v63, "%{public}s called with null protocol", buf, 0xCu);
    }
    goto LABEL_132;
  }
  if (v75 == OS_LOG_TYPE_DEFAULT)
  {
    __nwlog_obj();
    v60 = objc_claimAutoreleasedReturnValue();
    v71 = type;
    if (os_log_type_enabled(v60, type))
    {
      *(_DWORD *)buf = 136446210;
      v78 = "nw_association_set_cached_content_for_protocol";
      _os_log_impl(&dword_182FBE000, v60, v71, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_132;
  }
  v67 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v60 = objc_claimAutoreleasedReturnValue();
  v68 = type;
  v69 = os_log_type_enabled(v60, type);
  if (!v67)
  {
    if (v69)
    {
      *(_DWORD *)buf = 136446210;
      v78 = "nw_association_set_cached_content_for_protocol";
      _os_log_impl(&dword_182FBE000, v60, v68, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
    }
    goto LABEL_132;
  }
  if (v69)
  {
    *(_DWORD *)buf = 136446466;
    v78 = "nw_association_set_cached_content_for_protocol";
    v79 = 2082;
    v80 = v67;
    _os_log_impl(&dword_182FBE000, v60, v68, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v67);
  if (v59)
    goto LABEL_134;
LABEL_99:

}

void sub_1830007D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void nw_association_register(void *a1, void *a2, void *a3, int a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  uint64_t internal;
  _BOOL8 node;
  uint64_t v15;
  _QWORD *v16;
  id v17;
  const char *logging_description;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  os_log_type_t v28;
  const char *v29;
  os_log_type_t v30;
  const char *v31;
  id v32;
  const char *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  const char *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  os_log_type_t v43;
  const char *v44;
  os_log_type_t v45;
  const char *v46;
  uint64_t v47;
  id v48;
  _BOOL8 v49;
  id v50;
  const char *v51;
  void *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  const char *v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  const char *v60;
  os_log_type_t v61;
  const char *v62;
  os_log_type_t v63;
  const char *v64;
  uint64_t extra;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  void *v73;
  os_log_type_t v74;
  void *v75;
  char *v76;
  NSObject *v77;
  os_log_type_t v78;
  char *backtrace_string;
  NSObject *v80;
  os_log_type_t v81;
  _BOOL4 v82;
  char *v83;
  os_log_type_t v84;
  _BOOL4 v85;
  char *v86;
  NSObject *v87;
  os_log_type_t v88;
  _BOOL4 v89;
  os_log_type_t v90;
  os_log_type_t v91;
  os_log_type_t v92;
  int v93;
  const void *aBlock;
  id v95;
  char v96;
  os_log_type_t v97;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v100;
  __int16 v101;
  void *v102;
  __int16 v103;
  uint64_t v104;
  __int16 v105;
  char *v106;
  __int16 v107;
  char *v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v95 = a2;
  v10 = a3;
  v11 = a5;
  if (!v9)
  {
    v68 = v11;
    __nwlog_obj();
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v100 = "nw_association_register";
    v70 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v97 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v70, &type, &v97))
      goto LABEL_151;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v71 = objc_claimAutoreleasedReturnValue();
      v72 = type;
      if (os_log_type_enabled(v71, type))
      {
        *(_DWORD *)buf = 136446210;
        v100 = "nw_association_register";
        _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s called with null association", buf, 0xCu);
      }
      goto LABEL_141;
    }
    if (v97 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v71 = objc_claimAutoreleasedReturnValue();
      v90 = type;
      if (os_log_type_enabled(v71, type))
      {
        *(_DWORD *)buf = 136446210;
        v100 = "nw_association_register";
        _os_log_impl(&dword_182FBE000, v71, v90, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_141;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v80 = objc_claimAutoreleasedReturnValue();
    v81 = type;
    v82 = os_log_type_enabled(v80, type);
    if (backtrace_string)
    {
      if (v82)
      {
        *(_DWORD *)buf = 136446466;
        v100 = "nw_association_register";
        v101 = 2082;
        v102 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
LABEL_151:
      if (!v70)
        goto LABEL_104;
LABEL_152:
      free(v70);
      goto LABEL_104;
    }
    if (v82)
    {
      *(_DWORD *)buf = 136446210;
      v100 = "nw_association_register";
      _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s called with null association, no backtrace", buf, 0xCu);
    }
LABEL_150:

    goto LABEL_151;
  }
  if (v10)
  {
    aBlock = v11;
    if (v11)
    {
      v12 = nw_path_parameters_copy_context(*((void **)v9 + 2));
      nw_context_assert_queue(v12);

      if (!*((_QWORD *)v9 + 5))
      {
        internal = nw_hash_table_create_internal(7u, 16, (const void *(*)(const void *, unsigned int *))nw_association_get_key, (unsigned int (*)(const void *, unsigned int))nw_association_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_association_matches_key, (void (*)(void *))nw_association_release);
        if (internal)
          *(_DWORD *)(internal + 48) &= ~2u;
        *((_QWORD *)v9 + 5) = internal;
      }
      nw_association_activate(v9, v95, 1, 0);
      node = nw_hash_table_get_node(*((_QWORD *)v9 + 5), (uint64_t)v10, 0);
      if (!node)
        goto LABEL_70;
      v15 = node;
      v16 = &unk_183BA7000;
      if (nw_path_parameters_get_logging_disabled(*((_QWORD *)v9 + 2)))
        goto LABEL_39;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = (id)gconnectionLogObj;
      logging_description = nw_endpoint_get_logging_description(*((void **)v9 + 1));
      *(_DWORD *)buf = 136446722;
      v100 = "nw_association_register";
      v101 = 2082;
      v102 = (void *)logging_description;
      v103 = 2048;
      v104 = (uint64_t)v10;
      v19 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v97 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v19, &type, &v97))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v20 = (id)gconnectionLogObj;
          v21 = type;
          if (os_log_type_enabled(v20, type))
          {
            v22 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = 136446722;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v22;
            v103 = 2048;
            v104 = (uint64_t)v10;
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s <nw_association %{public}s> already has handle %p registered", buf, 0x20u);
          }
        }
        else if (v97)
        {
          v23 = __nw_create_backtrace_string();
          if (v23)
          {
            v24 = (char *)v23;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v25 = (id)gconnectionLogObj;
            v26 = type;
            if (os_log_type_enabled(v25, type))
            {
              v27 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
              *(_DWORD *)buf = 136446978;
              v100 = "nw_association_register";
              v101 = 2082;
              v102 = (void *)v27;
              v103 = 2048;
              v104 = (uint64_t)v10;
              v105 = 2082;
              v106 = v24;
              _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s <nw_association %{public}s> already has handle %p registered, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v24);
            v16 = (_QWORD *)&unk_183BA7000;
            if (v19)
              goto LABEL_38;
            goto LABEL_39;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v20 = (id)gconnectionLogObj;
          v30 = type;
          if (os_log_type_enabled(v20, type))
          {
            v31 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = 136446722;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v31;
            v103 = 2048;
            v104 = (uint64_t)v10;
            _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s <nw_association %{public}s> already has handle %p registered, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v20 = (id)gconnectionLogObj;
          v28 = type;
          if (os_log_type_enabled(v20, type))
          {
            v29 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = 136446722;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v29;
            v103 = 2048;
            v104 = (uint64_t)v10;
            _os_log_impl(&dword_182FBE000, v20, v28, "%{public}s <nw_association %{public}s> already has handle %p registered, backtrace limit exceeded", buf, 0x20u);
          }
        }

      }
      v16 = &unk_183BA7000;
      if (v19)
LABEL_38:
        free(v19);
LABEL_39:
      if (nw_hash_table_remove_node(*((_QWORD *)v9 + 5), v15)
        || nw_path_parameters_get_logging_disabled(*((_QWORD *)v9 + 2)))
      {
        goto LABEL_70;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v32 = (id)gconnectionLogObj;
      v33 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
      v93 = v16[191];
      *(_DWORD *)buf = v93;
      v100 = "nw_association_register";
      v101 = 2082;
      v102 = (void *)v33;
      v103 = 2048;
      v104 = v15;
      v34 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v97 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v34, &type, &v97))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v35 = (id)gconnectionLogObj;
          v36 = type;
          if (os_log_type_enabled(v35, type))
          {
            v37 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = v93;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v37;
            v103 = 2048;
            v104 = v15;
            _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s <nw_association %{public}s> failed to remove handle for node %p", buf, 0x20u);
          }
        }
        else if (v97)
        {
          v38 = __nw_create_backtrace_string();
          if (v38)
          {
            v39 = (char *)v38;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v40 = (id)gconnectionLogObj;
            v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              v42 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
              *(_DWORD *)buf = 136446978;
              v100 = "nw_association_register";
              v101 = 2082;
              v102 = (void *)v42;
              v103 = 2048;
              v104 = v15;
              v105 = 2082;
              v106 = v39;
              _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s <nw_association %{public}s> failed to remove handle for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v39);
            if (v34)
              goto LABEL_69;
            goto LABEL_70;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v35 = (id)gconnectionLogObj;
          v45 = type;
          if (os_log_type_enabled(v35, type))
          {
            v46 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = v93;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v46;
            v103 = 2048;
            v104 = v15;
            _os_log_impl(&dword_182FBE000, v35, v45, "%{public}s <nw_association %{public}s> failed to remove handle for node %p, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v35 = (id)gconnectionLogObj;
          v43 = type;
          if (os_log_type_enabled(v35, type))
          {
            v44 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = v93;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v44;
            v103 = 2048;
            v104 = v15;
            _os_log_impl(&dword_182FBE000, v35, v43, "%{public}s <nw_association %{public}s> failed to remove handle for node %p, backtrace limit exceeded", buf, 0x20u);
          }
        }

      }
      if (v34)
LABEL_69:
        free(v34);
LABEL_70:
      type = OS_LOG_TYPE_DEFAULT;
      v47 = *((_QWORD *)v9 + 5);
      v48 = v10;
      v49 = nw_hash_table_add_object(v47, (uint64_t)v48, (char *)&type);
      if (type || nw_path_parameters_get_logging_disabled(*((_QWORD *)v9 + 2)))
      {
LABEL_101:
        extra = nw_hash_node_get_extra(v49);
        v66 = _Block_copy(aBlock);
        v67 = *(void **)extra;
        *(_QWORD *)extra = v66;

        *(_BYTE *)(extra + 8) = *(_BYTE *)(extra + 8) & 0xFE | a4;
        if (a4)
          ++*((_DWORD *)v9 + 18);
LABEL_103:
        v68 = (void *)aBlock;
        goto LABEL_104;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v50 = (id)gconnectionLogObj;
      v51 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
      *(_DWORD *)buf = 136446978;
      v100 = "nw_association_register";
      v101 = 2082;
      v102 = (void *)v51;
      v103 = 2048;
      v104 = (uint64_t)v48;
      v105 = 2048;
      v106 = (char *)v49;
      v52 = (void *)_os_log_send_and_compose_impl();

      v97 = OS_LOG_TYPE_ERROR;
      v96 = 0;
      if (__nwlog_fault((const char *)v52, &v97, &v96))
      {
        if (v97 == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v53 = (id)gconnectionLogObj;
          v54 = v97;
          if (os_log_type_enabled(v53, v97))
          {
            v55 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = 136446978;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v55;
            v103 = 2048;
            v104 = (uint64_t)v48;
            v105 = 2048;
            v106 = (char *)v49;
            _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p)", buf, 0x2Au);
          }
        }
        else if (v96)
        {
          v56 = __nw_create_backtrace_string();
          if (v56)
          {
            v57 = (char *)v56;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v58 = (id)gconnectionLogObj;
            v59 = v97;
            if (os_log_type_enabled(v58, v97))
            {
              v60 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
              *(_DWORD *)buf = 136447234;
              v100 = "nw_association_register";
              v101 = 2082;
              v102 = (void *)v60;
              v103 = 2048;
              v104 = (uint64_t)v48;
              v105 = 2048;
              v106 = (char *)v49;
              v107 = 2082;
              v108 = v57;
              _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), dumping backtrace:%{public}s", buf, 0x34u);
            }

            free(v57);
            if (!v52)
              goto LABEL_101;
LABEL_100:
            free(v52);
            goto LABEL_101;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v53 = (id)gconnectionLogObj;
          v63 = v97;
          if (os_log_type_enabled(v53, v97))
          {
            v64 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = 136446978;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v64;
            v103 = 2048;
            v104 = (uint64_t)v48;
            v105 = 2048;
            v106 = (char *)v49;
            _os_log_impl(&dword_182FBE000, v53, v63, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), no backtrace", buf, 0x2Au);
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v53 = (id)gconnectionLogObj;
          v61 = v97;
          if (os_log_type_enabled(v53, v97))
          {
            v62 = nw_endpoint_get_logging_description(*((void **)v9 + 1));
            *(_DWORD *)buf = 136446978;
            v100 = "nw_association_register";
            v101 = 2082;
            v102 = (void *)v62;
            v103 = 2048;
            v104 = (uint64_t)v48;
            v105 = 2048;
            v106 = (char *)v49;
            _os_log_impl(&dword_182FBE000, v53, v61, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), backtrace limit exceeded", buf, 0x2Au);
          }
        }

      }
      if (!v52)
        goto LABEL_101;
      goto LABEL_100;
    }
    __nwlog_obj();
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v100 = "nw_association_register";
    v76 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v97 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v76, &type, &v97))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v77 = objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          v100 = "nw_association_register";
          _os_log_impl(&dword_182FBE000, v77, v78, "%{public}s called with null update_handler", buf, 0xCu);
        }
      }
      else
      {
        if (v97)
        {
          v86 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v87 = objc_claimAutoreleasedReturnValue();
          v88 = type;
          v89 = os_log_type_enabled(v87, type);
          if (v86)
          {
            if (v89)
            {
              *(_DWORD *)buf = 136446466;
              v100 = "nw_association_register";
              v101 = 2082;
              v102 = v86;
              _os_log_impl(&dword_182FBE000, v87, v88, "%{public}s called with null update_handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v86);
          }
          else
          {
            if (v89)
            {
              *(_DWORD *)buf = 136446210;
              v100 = "nw_association_register";
              _os_log_impl(&dword_182FBE000, v87, v88, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
            }

          }
          goto LABEL_156;
        }
        __nwlog_obj();
        v77 = objc_claimAutoreleasedReturnValue();
        v92 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          v100 = "nw_association_register";
          _os_log_impl(&dword_182FBE000, v77, v92, "%{public}s called with null update_handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_156:
    if (v76)
      free(v76);
    goto LABEL_103;
  }
  v68 = v11;
  __nwlog_obj();
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v100 = "nw_association_register";
  v70 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v97 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v70, &type, &v97))
    goto LABEL_151;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v71 = objc_claimAutoreleasedReturnValue();
    v74 = type;
    if (os_log_type_enabled(v71, type))
    {
      *(_DWORD *)buf = 136446210;
      v100 = "nw_association_register";
      _os_log_impl(&dword_182FBE000, v71, v74, "%{public}s called with null handle", buf, 0xCu);
    }
LABEL_141:

    goto LABEL_151;
  }
  if (v97 == OS_LOG_TYPE_DEFAULT)
  {
    __nwlog_obj();
    v71 = objc_claimAutoreleasedReturnValue();
    v91 = type;
    if (os_log_type_enabled(v71, type))
    {
      *(_DWORD *)buf = 136446210;
      v100 = "nw_association_register";
      _os_log_impl(&dword_182FBE000, v71, v91, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_141;
  }
  v83 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v80 = objc_claimAutoreleasedReturnValue();
  v84 = type;
  v85 = os_log_type_enabled(v80, type);
  if (!v83)
  {
    if (v85)
    {
      *(_DWORD *)buf = 136446210;
      v100 = "nw_association_register";
      _os_log_impl(&dword_182FBE000, v80, v84, "%{public}s called with null handle, no backtrace", buf, 0xCu);
    }
    goto LABEL_150;
  }
  if (v85)
  {
    *(_DWORD *)buf = 136446466;
    v100 = "nw_association_register";
    v101 = 2082;
    v102 = v83;
    _os_log_impl(&dword_182FBE000, v80, v84, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v83);
  if (v70)
    goto LABEL_152;
LABEL_104:

}

void sub_183001B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

BOOL nw_hash_table_add_object(uint64_t a1, uint64_t a2, char *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  char v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _BOOL8 result;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  void *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  NSObject *v33;
  void *v34;
  char *backtrace_string;
  uint64_t v36;
  _BOOL4 v37;
  const char *v38;
  uint64_t v39;
  _BOOL4 v40;
  char *v41;
  uint64_t v42;
  _BOOL4 v43;
  char v44;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  size_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj(0, a2);
    *(_DWORD *)buf = 136446210;
    v47 = "nw_hash_table_add_object";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    v18 = __nwlog_fault(v17, &type, &v44);
    if (!(_DWORD)v18)
      goto LABEL_66;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v44)
      {
        v20 = __nwlog_obj(v18, v19);
        v21 = type;
        if (!os_log_type_enabled(v20, type))
          goto LABEL_66;
        *(_DWORD *)buf = 136446210;
        v47 = "nw_hash_table_add_object";
        v22 = "%{public}s called with null table, backtrace limit exceeded";
        goto LABEL_65;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v20 = __nwlog_obj(backtrace_string, v36);
      v21 = type;
      v37 = os_log_type_enabled(v20, type);
      if (!backtrace_string)
      {
        if (!v37)
          goto LABEL_66;
        *(_DWORD *)buf = 136446210;
        v47 = "nw_hash_table_add_object";
        v22 = "%{public}s called with null table, no backtrace";
        goto LABEL_65;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "nw_hash_table_add_object";
        v48 = 2082;
        v49 = (uint64_t)backtrace_string;
        v38 = "%{public}s called with null table, dumping backtrace:%{public}s";
LABEL_48:
        _os_log_impl(&dword_182FBE000, v20, v21, v38, buf, 0x16u);
      }
LABEL_49:
      free(backtrace_string);
      goto LABEL_66;
    }
    v20 = __nwlog_obj(v18, v19);
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    v47 = "nw_hash_table_add_object";
    v22 = "%{public}s called with null table";
LABEL_65:
    _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
LABEL_66:
    if (v17)
      free(v17);
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj(a1, 0);
    *(_DWORD *)buf = 136446210;
    v47 = "nw_hash_table_add_object";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    v23 = __nwlog_fault(v17, &type, &v44);
    if (!(_DWORD)v23)
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj(v23, v24);
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      v47 = "nw_hash_table_add_object";
      v22 = "%{public}s called with null object";
      goto LABEL_65;
    }
    if (!v44)
    {
      v20 = __nwlog_obj(v23, v24);
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      v47 = "nw_hash_table_add_object";
      v22 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_65;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj(backtrace_string, v39);
    v21 = type;
    v40 = os_log_type_enabled(v20, type);
    if (backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "nw_hash_table_add_object";
        v48 = 2082;
        v49 = (uint64_t)backtrace_string;
        v38 = "%{public}s called with null object, dumping backtrace:%{public}s";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (!v40)
      goto LABEL_66;
    *(_DWORD *)buf = 136446210;
    v47 = "nw_hash_table_add_object";
    v22 = "%{public}s called with null object, no backtrace";
    goto LABEL_65;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v25 = __nwlog_obj(a1, a2);
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v47 = "nw_hash_table_lock";
  v26 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_6:
      if ((v6 & 1) != 0)
      {
        *(_DWORD *)buf = 0;
        v7 = (*(uint64_t (**)(uint64_t, uint8_t *))a1)(a2, buf);
        v8 = (*(unsigned int (**)(uint64_t, _QWORD))(a1 + 8))(v7, *(unsigned int *)buf) % *(_DWORD *)(a1 + 32);
        v9 = a1 + 56;
        if (_nw_signposts_once != -1)
          dispatch_once(&_nw_signposts_once, &__block_literal_global_62353);
        v10 = (_BYTE *)(v9 + 16 * v8);
        if (_nw_signposts_enabled && kdebug_is_enabled())
          kdebug_trace();
        while (1)
        {
          v10 = *(_BYTE **)v10;
          if (!v10)
            break;
          if (v10[30] == 1 && *((_QWORD *)v10 + 2) == a2)
          {
            v11 = 0;
            if (!a3)
              goto LABEL_20;
            goto LABEL_19;
          }
        }
        v12 = *(unsigned int *)(a1 + 36) + 32;
        v11 = 1;
        v10 = malloc_type_calloc(1uLL, v12, 0xEAFB8F1AuLL);
        if (!v10)
        {
          v33 = __nwlog_obj(0, v13);
          os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          v47 = "strict_calloc";
          v48 = 2048;
          v49 = 1;
          v50 = 2048;
          v51 = v12;
          v34 = (void *)_os_log_send_and_compose_impl();
          result = __nwlog_abort((uint64_t)v34);
          if (result)
            goto LABEL_76;
          free(v34);
        }
        *((_DWORD *)v10 + 6) = v8;
        *((_QWORD *)v10 + 2) = a2;
        *(_QWORD *)v10 = 0;
        v14 = v9 + 16 * v8;
        v15 = *(_QWORD **)(v14 + 8);
        *((_QWORD *)v10 + 1) = v15;
        *v15 = v10;
        *(_QWORD *)(v14 + 8) = v10;
        v10[30] = 1;
        ++*(_DWORD *)(a1 + 40);
        if (a3)
LABEL_19:
          *a3 = v11;
LABEL_20:
        if ((*(_BYTE *)(a1 + 48) & 2) != 0)
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        return (BOOL)v10;
      }
      __nwlog_obj(a1, a2);
      *(_DWORD *)buf = 136446210;
      v47 = "nw_hash_table_add_object";
      v27 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v44 = 0;
      v28 = __nwlog_fault(v27, &type, &v44);
      if ((_DWORD)v28)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v30 = __nwlog_obj(v28, v29);
          v31 = type;
          if (!os_log_type_enabled(v30, type))
            goto LABEL_71;
          *(_DWORD *)buf = 136446210;
          v47 = "nw_hash_table_add_object";
          v32 = "%{public}s called with invalid hash table";
LABEL_70:
          _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0xCu);
          goto LABEL_71;
        }
        if (!v44)
        {
          v30 = __nwlog_obj(v28, v29);
          v31 = type;
          if (!os_log_type_enabled(v30, type))
            goto LABEL_71;
          *(_DWORD *)buf = 136446210;
          v47 = "nw_hash_table_add_object";
          v32 = "%{public}s called with invalid hash table, backtrace limit exceeded";
          goto LABEL_70;
        }
        v41 = (char *)__nw_create_backtrace_string();
        v30 = __nwlog_obj(v41, v42);
        v31 = type;
        v43 = os_log_type_enabled(v30, type);
        if (!v41)
        {
          if (!v43)
            goto LABEL_71;
          *(_DWORD *)buf = 136446210;
          v47 = "nw_hash_table_add_object";
          v32 = "%{public}s called with invalid hash table, no backtrace";
          goto LABEL_70;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          v47 = "nw_hash_table_add_object";
          v48 = 2082;
          v49 = (uint64_t)v41;
          _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v41);
      }
LABEL_71:
      if (v27)
        free(v27);
      if ((*(_BYTE *)(a1 + 48) & 2) != 0)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        return 0;
      }
      return 0;
    }
LABEL_5:
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
    v6 = *(_DWORD *)(a1 + 48);
    goto LABEL_6;
  }
LABEL_76:
  __break(1u);
  return result;
}

uint64_t nw_endpoint_association_key_hash(void *a1)
{
  return nw_path_parameters_get_hash(a1);
}

uint64_t nw_path_parameters_get_hash(void *a1)
{
  char *v1;
  const void *v2;
  CC_LONG v3;
  const void *v4;
  CC_LONG v5;
  const void *v6;
  CC_LONG v7;
  uint64_t v8;
  uint64_t shallow_hash;
  uint64_t hash;
  uint64_t v11;
  int8x16_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  int8x16_t v32;
  int8x16_t v33;
  CC_SHA256_CTX c;
  unsigned __int8 md[16];
  int8x16_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    memset(&c, 0, sizeof(c));
    CC_SHA256_Init(&c);
    CC_SHA256_Update(&c, v1 + 8, 0x40u);
    CC_SHA256_Update(&c, v1 + 72, 0x1Eu);
    CC_SHA256_Update(&c, v1 + 102, 9u);
    if (*((_QWORD *)v1 + 17))
      CC_SHA256_Update(&c, v1 + 136, 8u);
    v2 = (const void *)*((_QWORD *)v1 + 14);
    if (v2)
    {
      v3 = strlen(*((const char **)v1 + 14));
      CC_SHA256_Update(&c, v2, v3);
    }
    v4 = (const void *)*((_QWORD *)v1 + 15);
    if (v4)
    {
      v5 = strlen(*((const char **)v1 + 15));
      CC_SHA256_Update(&c, v4, v5);
    }
    v6 = (const void *)*((_QWORD *)v1 + 16);
    if (v6)
    {
      v7 = strlen(*((const char **)v1 + 16));
      CC_SHA256_Update(&c, v6, v7);
    }
    CC_SHA256_Final(md, &c);
    v32 = *(int8x16_t *)md;
    v33 = v36;
    v8 = objc_msgSend(*((id *)v1 + 20), "getHash");
    shallow_hash = nw_interface_get_shallow_hash(*((void **)v1 + 21));
    hash = nw_protocol_options_get_hash(*((void **)v1 + 18));
    v11 = nw_protocol_options_get_hash(*((void **)v1 + 19));
    v12 = veorq_s8(v32, v33);
    v13 = v8 ^ *(_QWORD *)&veor_s8(*(int8x8_t *)v12.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)) ^ shallow_hash ^ hash ^ v11;
    v14 = *((_QWORD *)v1 + 22);
    if (v14)
    {
      if (*(_QWORD *)v14)
      {
        v13 ^= xpc_hash(*(xpc_object_t *)v14);
        v14 = *((_QWORD *)v1 + 22);
      }
      v15 = *(void **)(v14 + 8);
      if (v15)
      {
        v13 ^= xpc_hash(v15);
        v14 = *((_QWORD *)v1 + 22);
      }
      v16 = *(void **)(v14 + 16);
      if (v16)
      {
        v13 ^= xpc_hash(v16);
        v14 = *((_QWORD *)v1 + 22);
      }
      v17 = *(void **)(v14 + 24);
      if (v17)
      {
        v13 ^= xpc_hash(v17);
        v14 = *((_QWORD *)v1 + 22);
      }
      v18 = *(void **)(v14 + 32);
      if (v18)
      {
        v13 ^= xpc_hash(v18);
        v14 = *((_QWORD *)v1 + 22);
      }
      v19 = *(void **)(v14 + 40);
      if (v19)
      {
        v13 ^= xpc_hash(v19);
        v14 = *((_QWORD *)v1 + 22);
      }
      v20 = *(void **)(v14 + 48);
      if (v20)
      {
        v13 ^= xpc_hash(v20);
        v14 = *((_QWORD *)v1 + 22);
      }
      v21 = *(void **)(v14 + 56);
      if (v21)
      {
        v13 ^= xpc_hash(v21);
        v14 = *((_QWORD *)v1 + 22);
      }
      v22 = *(void **)(v14 + 64);
      if (v22)
      {
        v13 ^= xpc_hash(v22);
        v14 = *((_QWORD *)v1 + 22);
      }
      v23 = *(void **)(v14 + 72);
      if (v23)
      {
        v13 ^= xpc_hash(v23);
        v14 = *((_QWORD *)v1 + 22);
      }
      v24 = *(void **)(v14 + 80);
      if (v24)
      {
        v13 ^= xpc_hash(v24);
        v14 = *((_QWORD *)v1 + 22);
      }
      v25 = *(void **)(v14 + 88);
      if (v25)
      {
        v13 ^= xpc_hash(v25);
        v14 = *((_QWORD *)v1 + 22);
      }
      v26 = *(void **)(v14 + 96);
      if (v26)
      {
        v13 ^= xpc_hash(v26);
        v14 = *((_QWORD *)v1 + 22);
      }
      v27 = *(void **)(v14 + 104);
      if (v27)
      {
        v13 ^= xpc_hash(v27);
        v14 = *((_QWORD *)v1 + 22);
      }
      v28 = *(void **)(v14 + 112);
      if (v28)
      {
        v13 ^= xpc_hash(v28);
        v14 = *((_QWORD *)v1 + 22);
      }
      v29 = *(void **)(v14 + 120);
      if (v29)
      {
        v13 ^= xpc_hash(v29);
        v14 = *((_QWORD *)v1 + 22);
      }
      v30 = *(void **)(v14 + 136);
      if (v30)
      {
        v13 ^= xpc_hash(v30);
        v14 = *((_QWORD *)v1 + 22);
      }
      v13 ^= nw_protocol_options_get_hash(*(void **)(v14 + 128));
    }
  }
  else
  {
    v13 = 0;
  }

  return v13;
}

void sub_1830026DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_options_get_hash(void *a1)
{
  _QWORD *v1;
  uint64_t v2;
  int8x16_t v3;
  int8x8_t v4;
  void *v5;
  CC_SHA256_CTX v7;
  unsigned __int8 md[16];
  int8x16_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    memset(&v7, 0, sizeof(v7));
    CC_SHA256_Init(&v7);
    v2 = v1[1];
    if (v2)
      CC_SHA256_Update(&v7, (const void *)(v2 + 8), 0x28u);
    CC_SHA256_Final(md, &v7);
    v3 = veorq_s8(*(int8x16_t *)md, v9);
    v4 = veor_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
    v5 = (void *)v1[5];
    if (v5)
      *(_QWORD *)&v4 ^= xpc_hash(v5);
  }
  else
  {
    v4 = 0;
  }

  return (uint64_t)v4;
}

void sub_1830027C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_interface_get_shallow_hash(void *a1)
{
  char *v1;
  CC_LONG v2;
  int8x16_t v3;
  int8x8_t v4;
  CC_SHA256_CTX v6;
  unsigned __int8 md[16];
  int8x16_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    memset(&v6, 0, sizeof(v6));
    CC_SHA256_Init(&v6);
    CC_SHA256_Update(&v6, v1 + 96, 4u);
    CC_SHA256_Update(&v6, v1 + 100, 4u);
    CC_SHA256_Update(&v6, v1 + 8, 4u);
    v2 = strlen(v1 + 104);
    CC_SHA256_Update(&v6, v1 + 104, v2);
    CC_SHA256_Final(md, &v6);
    v3 = veorq_s8(*(int8x16_t *)md, v8);
    v4 = veor_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
  }
  else
  {
    v4 = 0;
  }

  return (uint64_t)v4;
}

void sub_1830028D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_association_copy_current_path(void *a1, void *a2)
{
  void **v3;
  id v4;
  id v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  id *v8;
  id v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_association_copy_current_path";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null association", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v24)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v27 = "nw_association_copy_current_path";
      v28 = 2082;
      v29 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  v5 = nw_path_parameters_copy_context(v3[2]);
  nw_context_assert_queue(v5);

  nw_association_activate(v3, v4, 0, 1);
  if ((*((_BYTE *)v3 + 76) & 1) != 0)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_association_copy_current_path";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null !association->dormant", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v11)
        free(v11);
      goto LABEL_39;
    }
    if (!v24)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null !association->dormant, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null !association->dormant, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v27 = "nw_association_copy_current_path";
      v28 = 2082;
      v29 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null !association->dormant, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  v6 = (os_unfair_lock_s *)v3[3];
  if (!v6)
  {
LABEL_39:
    v9 = 0;
    goto LABEL_40;
  }
  v7 = v6 + 24;
  v8 = v6;
  os_unfair_lock_lock(v7);
  v9 = v8[6];
  os_unfair_lock_unlock(v7);

LABEL_40:
  return v9;
}

void sub_183002DF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_path_parameters_copy_context(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[17];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_parameters_copy_context";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_parameters_copy_context";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_endpoint_association_get_key(void *a1, unsigned int *a2)
{
  id v2;

  v2 = nw_association_copy_path_parameters(a1);

  return v2;
}

uint64_t nw_path_evaluator_set_update_handler(void *a1, void *a2, void *a3)
{
  os_unfair_lock_s *v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  os_unfair_lock_s *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  void *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (v5)
  {
    if (v7)
    {
      nw_allow_use_of_dispatch_internal();
      if (v6)
        nw_path_evaluator_set_queue(v5, v6);
      v9 = v8;
      v10 = v5;
      os_unfair_lock_lock(v5 + 24);
      v11 = _Block_copy(v9);

      v12 = *(void **)&v10[16]._os_unfair_lock_opaque;
      *(_QWORD *)&v10[16]._os_unfair_lock_opaque = v11;

      os_unfair_lock_unlock(v5 + 24);
      nw_path_evaluator_start(v10);
      v13 = 1;
      goto LABEL_6;
    }
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_evaluator_set_update_handler";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v16, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null handler", buf, 0xCu);
        }
LABEL_38:

        goto LABEL_39;
      }
      if (!v28)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_182FBE000, v17, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_path_evaluator_set_update_handler";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
  }
  else
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_evaluator_set_update_handler";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v16, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null evaluator", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (!v28)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_182FBE000, v17, v26, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      v23 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_evaluator_set_update_handler";
          _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_path_evaluator_set_update_handler";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
    }
  }
LABEL_39:
  if (v16)
    free(v16);
  v13 = 0;
LABEL_6:

  return v13;
}

void sub_183003604(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_path_evaluator_set_logging(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 24);
    HIBYTE(v2[26]._os_unfair_lock_opaque) &= ~0x40u;
    os_unfair_lock_unlock(v2 + 24);
    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_path_evaluator_set_logging";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_path_evaluator_set_logging";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

uint64_t nw_flow_protocol_get_key(_QWORD *a1, _BOOL4 *a2)
{
  uint64_t v2;
  BOOL v3;
  _BOOL4 v4;
  uint64_t v5;

  v2 = a1[30];
  v3 = v2 == 0;
  v4 = v2 != 0;
  v5 = 31;
  if (!v3)
    v5 = 30;
  *a2 = v4;
  return a1[v5];
}

void nw_protocol_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 8;
}

void nw_protocol_instance_add_outbound(void *a1, void *a2, void *a3, uint64_t a4, int a5, int a6)
{
  char **v11;
  char *v12;
  NSObject *v13;
  char *v14;
  dispatch_queue_t *v15;
  dispatch_queue_t *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t node;
  uint64_t v22;
  _QWORD *extra;
  char *v24;
  const char *v25;
  void *v26;
  char v27;
  NSObject *v28;
  char **v29;
  uint64_t v30;
  char v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(uint64_t, _QWORD *);
  uint64_t v36;
  uint64_t v37;
  void (*v38)(const char *, char **);
  void *v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  void *v43;
  os_log_type_t v44;
  char *backtrace_string;
  os_log_type_t v46;
  _BOOL4 v47;
  char *v48;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  os_log_type_t v52;
  void *v53;
  const char *v54;
  char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  void *v59;
  const char *v60;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  const char *v64;
  void *v65;
  os_log_type_t v66;
  NSObject *v67;
  char *v68;
  os_log_type_t v69;
  _BOOL4 v70;
  const char *v71;
  void *v72;
  os_log_type_t v73;
  NSObject *v74;
  char *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  const char *v78;
  os_log_type_t v79;
  _BOOL4 v80;
  os_log_type_t v81;
  _BOOL4 v82;
  os_log_type_t v83;
  const char *v84;
  os_log_type_t v85;
  const char *v86;
  const char *v87;
  const char *v88;
  os_log_type_t v89;
  os_log_type_t v90;
  char v91;
  void *v92;
  char v93;
  os_log_type_t type[8];
  os_log_type_t *v95;
  uint64_t v96;
  uint64_t v97;
  _BYTE buf[12];
  __int16 v99;
  char *v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  uint64_t v104;
  _BYTE v105[24];
  const char *v106;
  __int128 v107;
  uint64_t v108;

  v108 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = a2;
  v13 = a3;
  if (!v11)
  {
    __nwlog_obj();
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v105 = 136446210;
    *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
    v40 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v40, buf, type))
      goto LABEL_190;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v42 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s called with null instance", v105, 0xCu);
      }
    }
    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v46 = buf[0];
      v47 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)v105 = 136446466;
          *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
          *(_WORD *)&v105[12] = 2082;
          *(_QWORD *)&v105[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v41, v46, "%{public}s called with null instance, dumping backtrace:%{public}s", v105, 0x16u);
        }

        free(backtrace_string);
LABEL_190:
        if (!v40)
          goto LABEL_58;
LABEL_191:
        free(v40);
        goto LABEL_58;
      }
      if (v47)
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_182FBE000, v41, v46, "%{public}s called with null instance, no backtrace", v105, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v51 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_182FBE000, v41, v51, "%{public}s called with null instance, backtrace limit exceeded", v105, 0xCu);
      }
    }
LABEL_189:

    goto LABEL_190;
  }
  if (!v12)
  {
    __nwlog_obj();
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v105 = 136446210;
    *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
    v40 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v40, buf, type))
      goto LABEL_190;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v44 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_182FBE000, v41, v44, "%{public}s called with null data", v105, 0xCu);
      }
      goto LABEL_189;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v52 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_182FBE000, v41, v52, "%{public}s called with null data, backtrace limit exceeded", v105, 0xCu);
      }
      goto LABEL_189;
    }
    v48 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v41 = objc_claimAutoreleasedReturnValue();
    v49 = buf[0];
    v50 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
    if (!v48)
    {
      if (v50)
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_182FBE000, v41, v49, "%{public}s called with null data, no backtrace", v105, 0xCu);
      }
      goto LABEL_189;
    }
    if (v50)
    {
      *(_DWORD *)v105 = 136446466;
      *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
      *(_WORD *)&v105[12] = 2082;
      *(_QWORD *)&v105[14] = v48;
      _os_log_impl(&dword_182FBE000, v41, v49, "%{public}s called with null data, dumping backtrace:%{public}s", v105, 0x16u);
    }
    goto LABEL_78;
  }
  v14 = v11[15];
  if (v14)
  {
    v15 = v14;
    v16 = v15;
    if (((_BYTE)v15[17] & 8) == 0)
      dispatch_assert_queue_V2(v15[1]);

  }
  if (*((char ***)v12 + 11) == v11)
  {
    nw_frame_finalize((uint64_t)v12);
    goto LABEL_58;
  }
  if (v13)
    nw_frame_set_metadata((uint64_t)v12, v13, 1, a5);
  if (a4)
    *((_QWORD *)v12 + 20) = a4;
  if (!v11[37])
  {
    *((_QWORD *)v12 + 4) = 0;
    v24 = v11[27];
    *((_QWORD *)v12 + 5) = v24;
    *(_QWORD *)v24 = v12;
    v11[27] = v12 + 32;
    if ((*((_BYTE *)v11 + 403) & 0x20) != 0 || !a6 || !v11[26])
      goto LABEL_58;
    if ((*((char *)v11 + 405) & 0x80000000) == 0 && gLogDatapath)
    {
      __nwlog_obj();
      v74 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v105 = 136446722;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        *(_WORD *)&v105[12] = 2082;
        *(_QWORD *)&v105[14] = (char *)v11 + 407;
        *(_WORD *)&v105[22] = 2080;
        v106 = " ";
        _os_log_impl(&dword_182FBE000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sFinalizing outbound frames (one-off)", v105, 0x20u);
      }

    }
    v25 = *(v11 - 8);
    if (!v25)
    {
      __nwlog_obj();
      v72 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)v105 = 136446210;
      *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
      v40 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v40, buf, type))
        goto LABEL_190;
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v41 = objc_claimAutoreleasedReturnValue();
        v73 = buf[0];
        if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v105 = 136446210;
          *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_182FBE000, v41, v73, "%{public}s called with null protocol", v105, 0xCu);
        }
        goto LABEL_189;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v41 = objc_claimAutoreleasedReturnValue();
        v90 = buf[0];
        if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v105 = 136446210;
          *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_182FBE000, v41, v90, "%{public}s called with null protocol, backtrace limit exceeded", v105, 0xCu);
        }
        goto LABEL_189;
      }
      v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v81 = buf[0];
      v82 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
      if (!v48)
      {
        if (v82)
        {
          *(_DWORD *)v105 = 136446210;
          *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_182FBE000, v41, v81, "%{public}s called with null protocol, no backtrace", v105, 0xCu);
        }
        goto LABEL_189;
      }
      if (v82)
      {
        *(_DWORD *)v105 = 136446466;
        *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(_QWORD *)&v105[14] = v48;
        _os_log_impl(&dword_182FBE000, v41, v81, "%{public}s called with null protocol, dumping backtrace:%{public}s", v105, 0x16u);
      }
      goto LABEL_78;
    }
    v26 = (void *)*((_QWORD *)v25 + 5);
    if (v26 == &nw_protocol_ref_counted_handle)
    {
      v36 = *((_QWORD *)v25 + 11);
      if (v36)
        *((_QWORD *)v25 + 11) = v36 + 1;
      v27 = -1;
    }
    else
    {
      v27 = 0;
    }
    *(_QWORD *)buf = v25;
    buf[8] = v27;
    v37 = *((_QWORD *)v25 + 3);
    if (v37)
    {
      v38 = *(void (**)(const char *, char **))(v37 + 96);
      if (v38)
      {
        v38(v25, v11 + 26);
        if (v26 != &nw_protocol_ref_counted_handle)
          goto LABEL_58;
        goto LABEL_57;
      }
    }
    v92 = v26;
    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    v60 = (const char *)*((_QWORD *)v25 + 2);
    *(_DWORD *)v105 = 136446722;
    *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
    if (!v60)
      v60 = "invalid";
    *(_WORD *)&v105[12] = 2082;
    *(_QWORD *)&v105[14] = v60;
    *(_WORD *)&v105[22] = 2048;
    v106 = v25;
    v61 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v61, type, &v93))
      goto LABEL_174;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v62 = objc_claimAutoreleasedReturnValue();
      v63 = type[0];
      if (os_log_type_enabled(v62, type[0]))
      {
        v64 = (const char *)*((_QWORD *)v25 + 2);
        if (!v64)
          v64 = "invalid";
        *(_DWORD *)v105 = 136446722;
        *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(_QWORD *)&v105[14] = v64;
        *(_WORD *)&v105[22] = 2048;
        v106 = v25;
        _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback", v105, 0x20u);
      }
    }
    else if (v93)
    {
      v75 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v62 = objc_claimAutoreleasedReturnValue();
      v76 = type[0];
      v77 = os_log_type_enabled(v62, type[0]);
      if (v75)
      {
        if (v77)
        {
          v78 = (const char *)*((_QWORD *)v25 + 2);
          if (!v78)
            v78 = "invalid";
          *(_DWORD *)v105 = 136446978;
          *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
          *(_WORD *)&v105[12] = 2082;
          *(_QWORD *)&v105[14] = v78;
          *(_WORD *)&v105[22] = 2048;
          v106 = v25;
          LOWORD(v107) = 2082;
          *(_QWORD *)((char *)&v107 + 2) = v75;
          _os_log_impl(&dword_182FBE000, v62, v76, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", v105, 0x2Au);
        }

        free(v75);
LABEL_174:
        if (v61)
          free(v61);
        if (v92 == &nw_protocol_ref_counted_handle)
          goto LABEL_57;
        goto LABEL_58;
      }
      if (v77)
      {
        v88 = (const char *)*((_QWORD *)v25 + 2);
        if (!v88)
          v88 = "invalid";
        *(_DWORD *)v105 = 136446722;
        *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(_QWORD *)&v105[14] = v88;
        *(_WORD *)&v105[22] = 2048;
        v106 = v25;
        _os_log_impl(&dword_182FBE000, v62, v76, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace", v105, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v62 = objc_claimAutoreleasedReturnValue();
      v85 = type[0];
      if (os_log_type_enabled(v62, type[0]))
      {
        v86 = (const char *)*((_QWORD *)v25 + 2);
        if (!v86)
          v86 = "invalid";
        *(_DWORD *)v105 = 136446722;
        *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(_QWORD *)&v105[14] = v86;
        *(_WORD *)&v105[22] = 2048;
        v106 = v25;
        _os_log_impl(&dword_182FBE000, v62, v85, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded", v105, 0x20u);
      }
    }

    goto LABEL_174;
  }
  v17 = v11;
  v18 = v12;
  *(_QWORD *)type = 0;
  v95 = type;
  v96 = 0x2020000000;
  v97 = 0;
  v19 = *((_QWORD *)v12 + 11);
  v20 = v11[37];
  if (!v19)
  {
    node = nw_hash_table_get_node((uint64_t)v20, *((_QWORD *)v17 + 38), 8);
    *((_QWORD *)v95 + 3) = node;
    if (node)
      goto LABEL_15;
LABEL_26:
    if ((v17[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = (id)gLogObj;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_implementation_lookup_path_by_frame";
        v99 = 2082;
        v100 = v17 + 407;
        v101 = 2080;
        v102 = " ";
        v103 = 2048;
        v104 = v19;
        _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo path found for context %p", buf, 0x2Au);
      }

    }
    v22 = 0;
    extra = 0;
    goto LABEL_31;
  }
  *(_QWORD *)v105 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v105[8] = 3221225472;
  *(_QWORD *)&v105[16] = ___ZL47nw_protocol_implementation_lookup_path_by_frameP31NWConcrete_nw_protocol_instancePU22objcproto11OS_nw_frame8NSObjectPm_block_invoke;
  v106 = (const char *)&unk_1E149C970;
  *(_QWORD *)&v107 = type;
  *((_QWORD *)&v107 + 1) = v19;
  nw_hash_table_apply(v20, (uint64_t)v105);
  node = *((_QWORD *)v95 + 3);
  if (!node)
    goto LABEL_26;
LABEL_15:
  v22 = *(_QWORD *)(node + 16);
  extra = (_QWORD *)nw_hash_node_get_extra(node);
LABEL_31:
  _Block_object_dispose(type, 8);

  if (extra)
  {
    *((_QWORD *)v18 + 4) = 0;
    v29 = (char **)extra[14];
    *((_QWORD *)v18 + 5) = v29;
    *v29 = v18;
    extra[14] = v18 + 32;
    if ((v17[403] & 0x20) != 0 || !a6 || !extra[13])
      goto LABEL_58;
    if ((v17[405] & 0x80000000) == 0 && gLogDatapath)
    {
      __nwlog_obj();
      v67 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v105 = 136446978;
        *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
        *(_WORD *)&v105[12] = 2082;
        *(_QWORD *)&v105[14] = v17 + 407;
        *(_WORD *)&v105[22] = 2080;
        v106 = " ";
        LOWORD(v107) = 2048;
        *(_QWORD *)((char *)&v107 + 2) = v22;
        _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sFinalizing outbound frames for %lx (one-off)", v105, 0x2Au);
      }

    }
    v30 = extra[4];
    if (v30)
    {
      if (*(_UNKNOWN **)(v30 + 40) == &nw_protocol_ref_counted_handle)
      {
        v33 = *(_QWORD *)(v30 + 88);
        if (v33)
          *(_QWORD *)(v30 + 88) = v33 + 1;
        v31 = -1;
      }
      else
      {
        v31 = 0;
      }
      *(_QWORD *)buf = v30;
      buf[8] = v31;
      v34 = *(_QWORD *)(v30 + 24);
      if (v34)
      {
        v35 = *(void (**)(uint64_t, _QWORD *))(v34 + 96);
        if (v35)
        {
          v35(v30, extra + 13);
          if ((buf[8] & 1) == 0)
            goto LABEL_58;
          goto LABEL_57;
        }
      }
      v91 = v31;
      __nwlog_obj();
      v53 = (void *)objc_claimAutoreleasedReturnValue();
      v54 = *(const char **)(v30 + 16);
      *(_DWORD *)v105 = 136446722;
      *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
      if (!v54)
        v54 = "invalid";
      *(_WORD *)&v105[12] = 2082;
      *(_QWORD *)&v105[14] = v54;
      *(_WORD *)&v105[22] = 2048;
      v106 = (const char *)v30;
      v55 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v93 = 0;
      if (__nwlog_fault(v55, type, &v93))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v56 = objc_claimAutoreleasedReturnValue();
          v57 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            v58 = *(const char **)(v30 + 16);
            if (!v58)
              v58 = "invalid";
            *(_DWORD *)v105 = 136446722;
            *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v105[12] = 2082;
            *(_QWORD *)&v105[14] = v58;
            *(_WORD *)&v105[22] = 2048;
            v106 = (const char *)v30;
            _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback", v105, 0x20u);
          }
LABEL_164:

          goto LABEL_165;
        }
        if (!v93)
        {
          __nwlog_obj();
          v56 = objc_claimAutoreleasedReturnValue();
          v83 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            v84 = *(const char **)(v30 + 16);
            if (!v84)
              v84 = "invalid";
            *(_DWORD *)v105 = 136446722;
            *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v105[12] = 2082;
            *(_QWORD *)&v105[14] = v84;
            *(_WORD *)&v105[22] = 2048;
            v106 = (const char *)v30;
            _os_log_impl(&dword_182FBE000, v56, v83, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded", v105, 0x20u);
          }
          goto LABEL_164;
        }
        v68 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v56 = objc_claimAutoreleasedReturnValue();
        v69 = type[0];
        v70 = os_log_type_enabled(v56, type[0]);
        if (!v68)
        {
          if (v70)
          {
            v87 = *(const char **)(v30 + 16);
            if (!v87)
              v87 = "invalid";
            *(_DWORD *)v105 = 136446722;
            *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v105[12] = 2082;
            *(_QWORD *)&v105[14] = v87;
            *(_WORD *)&v105[22] = 2048;
            v106 = (const char *)v30;
            _os_log_impl(&dword_182FBE000, v56, v69, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace", v105, 0x20u);
          }
          goto LABEL_164;
        }
        if (v70)
        {
          v71 = *(const char **)(v30 + 16);
          if (!v71)
            v71 = "invalid";
          *(_DWORD *)v105 = 136446978;
          *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
          *(_WORD *)&v105[12] = 2082;
          *(_QWORD *)&v105[14] = v71;
          *(_WORD *)&v105[22] = 2048;
          v106 = (const char *)v30;
          LOWORD(v107) = 2082;
          *(_QWORD *)((char *)&v107 + 2) = v68;
          _os_log_impl(&dword_182FBE000, v56, v69, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", v105, 0x2Au);
        }

        free(v68);
      }
LABEL_165:
      if (v55)
        free(v55);
      if ((v91 & 1) == 0)
        goto LABEL_58;
LABEL_57:
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      goto LABEL_58;
    }
    __nwlog_obj();
    v65 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v105 = 136446210;
    *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
    v40 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v40, buf, type))
      goto LABEL_190;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v66 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
        _os_log_impl(&dword_182FBE000, v41, v66, "%{public}s called with null protocol", v105, 0xCu);
      }
      goto LABEL_189;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v89 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
        _os_log_impl(&dword_182FBE000, v41, v89, "%{public}s called with null protocol, backtrace limit exceeded", v105, 0xCu);
      }
      goto LABEL_189;
    }
    v48 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v41 = objc_claimAutoreleasedReturnValue();
    v79 = buf[0];
    v80 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
    if (!v48)
    {
      if (v80)
      {
        *(_DWORD *)v105 = 136446210;
        *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
        _os_log_impl(&dword_182FBE000, v41, v79, "%{public}s called with null protocol, no backtrace", v105, 0xCu);
      }
      goto LABEL_189;
    }
    if (v80)
    {
      *(_DWORD *)v105 = 136446466;
      *(_QWORD *)&v105[4] = "__nw_protocol_finalize_output_frames";
      *(_WORD *)&v105[12] = 2082;
      *(_QWORD *)&v105[14] = v48;
      _os_log_impl(&dword_182FBE000, v41, v79, "%{public}s called with null protocol, dumping backtrace:%{public}s", v105, 0x16u);
    }
LABEL_78:

    free(v48);
    if (!v40)
      goto LABEL_58;
    goto LABEL_191;
  }
  if ((v17[405] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v32 = (id)gLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v105 = 136446978;
      *(_QWORD *)&v105[4] = "nw_protocol_instance_add_outbound";
      *(_WORD *)&v105[12] = 2082;
      *(_QWORD *)&v105[14] = v17 + 407;
      *(_WORD *)&v105[22] = 2080;
      v106 = " ";
      LOWORD(v107) = 2048;
      *(_QWORD *)((char *)&v107 + 2) = v18;
      _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo path found for frame %p", v105, 0x2Au);
    }

  }
LABEL_58:

}

uint64_t nw_protocol_udp_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  nw_frame *tqh_first;
  nw_frame *v5;
  char v6;
  nw_protocol *output_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v10;
  uint64_t (*finalize_output_frames)(nw_protocol *, nw_frame_array_s *);
  uint64_t v12;
  nw_protocol_callbacks *v14;
  nw_protocol_callbacks *v15;
  void (**v16)(_QWORD);
  const void *v17;
  const char *name;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *backtrace_string;
  _BOOL4 v29;
  const char *v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  _BOOL4 v38;
  char *v39;
  _BOOL4 v40;
  const char *v41;
  const char *v42;
  _QWORD v43[2];
  uint64_t (*v44)(uint64_t, uint64_t);
  void *v45;
  os_log_type_t *v46;
  nw_protocol *v47;
  nw_protocol **p_output_handler;
  os_log_type_t v49[8];
  os_log_type_t *v50;
  uint64_t v51;
  int v52;
  char v53;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v56;
  __int16 v57;
  void *v58;
  __int16 v59;
  nw_protocol *v60;
  __int16 v61;
  char *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      *(_QWORD *)v49 = 0;
      v50 = v49;
      v52 = 0;
      v51 = 0x2000000000;
      v43[0] = MEMORY[0x1E0C809B0];
      v43[1] = 0x40000000;
      v44 = ___ZL38nw_protocol_udp_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
      v45 = &unk_1E1499C88;
      v47 = a1;
      p_output_handler = &a1[1].output_handler;
      v46 = v49;
      tqh_first = a2->tqh_first;
      do
      {
        if (!tqh_first)
          break;
        v5 = (nw_frame *)*((_QWORD *)tqh_first + 4);
        v6 = ((uint64_t (*)(_QWORD *))v44)(v43);
        tqh_first = v5;
      }
      while ((v6 & 1) != 0);
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
      if (_nw_signposts_enabled && kdebug_is_enabled())
      {
        kdebug_trace();
        output_handler = a1->output_handler;
        if (output_handler)
          goto LABEL_11;
      }
      else
      {
        output_handler = a1->output_handler;
        if (output_handler)
        {
LABEL_11:
          handle = output_handler->handle;
          if (handle == &nw_protocol_ref_counted_handle)
          {
            callbacks = output_handler[1].callbacks;
            if (callbacks)
              output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          v10 = output_handler->callbacks;
          if (v10)
          {
            finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v10->finalize_output_frames;
            if (finalize_output_frames)
            {
              v12 = finalize_output_frames(output_handler, a2);
              if (handle != &nw_protocol_ref_counted_handle)
              {
LABEL_18:
                _Block_object_dispose(v49, 8);
                return v12;
              }
LABEL_17:
              if (output_handler->handle == &nw_protocol_ref_counted_handle)
              {
                v14 = output_handler[1].callbacks;
                if (v14)
                {
                  v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
                  output_handler[1].callbacks = v15;
                  if (!v15)
                  {
                    v16 = *(void (***)(_QWORD))output_handler[1].flow_id;
                    if (v16)
                    {
                      *(_QWORD *)output_handler[1].flow_id = 0;
                      v16[2](v16);
                      _Block_release(v16);
                    }
                    if ((output_handler[1].flow_id[8] & 1) != 0)
                    {
                      v17 = *(const void **)output_handler[1].flow_id;
                      if (v17)
                        _Block_release(v17);
                    }
                    free(output_handler);
                  }
                }
              }
              goto LABEL_18;
            }
          }
          __nwlog_obj();
          name = output_handler->identifier->name;
          *(_DWORD *)buf = 136446722;
          v56 = "__nw_protocol_finalize_output_frames";
          if (!name)
            name = "invalid";
          v57 = 2082;
          v58 = (void *)name;
          v59 = 2048;
          v60 = output_handler;
          v19 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v53 = 0;
          if (__nwlog_fault(v19, &type, &v53))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v20 = __nwlog_obj();
              v21 = type;
              if (!os_log_type_enabled(v20, type))
                goto LABEL_80;
              v22 = output_handler->identifier->name;
              if (!v22)
                v22 = "invalid";
              *(_DWORD *)buf = 136446722;
              v56 = "__nw_protocol_finalize_output_frames";
              v57 = 2082;
              v58 = (void *)v22;
              v59 = 2048;
              v60 = output_handler;
              v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_79:
              _os_log_impl(&dword_182FBE000, v20, v21, v23, buf, 0x20u);
              goto LABEL_80;
            }
            if (!v53)
            {
              v20 = __nwlog_obj();
              v21 = type;
              if (!os_log_type_enabled(v20, type))
                goto LABEL_80;
              v41 = output_handler->identifier->name;
              if (!v41)
                v41 = "invalid";
              *(_DWORD *)buf = 136446722;
              v56 = "__nw_protocol_finalize_output_frames";
              v57 = 2082;
              v58 = (void *)v41;
              v59 = 2048;
              v60 = output_handler;
              v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
              goto LABEL_79;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            v20 = __nwlog_obj();
            v21 = type;
            v29 = os_log_type_enabled(v20, type);
            if (!backtrace_string)
            {
              if (!v29)
                goto LABEL_80;
              v42 = output_handler->identifier->name;
              if (!v42)
                v42 = "invalid";
              *(_DWORD *)buf = 136446722;
              v56 = "__nw_protocol_finalize_output_frames";
              v57 = 2082;
              v58 = (void *)v42;
              v59 = 2048;
              v60 = output_handler;
              v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
              goto LABEL_79;
            }
            if (v29)
            {
              v30 = output_handler->identifier->name;
              if (!v30)
                v30 = "invalid";
              *(_DWORD *)buf = 136446978;
              v56 = "__nw_protocol_finalize_output_frames";
              v57 = 2082;
              v58 = (void *)v30;
              v59 = 2048;
              v60 = output_handler;
              v61 = 2082;
              v62 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(backtrace_string);
          }
LABEL_80:
          if (v19)
            free(v19);
          v12 = 0;
          if (handle != &nw_protocol_ref_counted_handle)
            goto LABEL_18;
          goto LABEL_17;
        }
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v56 = "__nw_protocol_finalize_output_frames";
      v31 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v53 = 0;
      if (__nwlog_fault(v31, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v32 = __nwlog_obj();
          v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)buf = 136446210;
            v56 = "__nw_protocol_finalize_output_frames";
            v34 = "%{public}s called with null protocol";
LABEL_100:
            _os_log_impl(&dword_182FBE000, v32, v33, v34, buf, 0xCu);
          }
        }
        else if (v53)
        {
          v39 = (char *)__nw_create_backtrace_string();
          v32 = __nwlog_obj();
          v33 = type;
          v40 = os_log_type_enabled(v32, type);
          if (v39)
          {
            if (v40)
            {
              *(_DWORD *)buf = 136446466;
              v56 = "__nw_protocol_finalize_output_frames";
              v57 = 2082;
              v58 = v39;
              _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v39);
            goto LABEL_101;
          }
          if (v40)
          {
            *(_DWORD *)buf = 136446210;
            v56 = "__nw_protocol_finalize_output_frames";
            v34 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_100;
          }
        }
        else
        {
          v32 = __nwlog_obj();
          v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)buf = 136446210;
            v56 = "__nw_protocol_finalize_output_frames";
            v34 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_100;
          }
        }
      }
LABEL_101:
      if (v31)
        free(v31);
      v12 = 0;
      goto LABEL_18;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v56 = "nw_protocol_udp_finalize_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    v49[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v24, v49, &type))
      goto LABEL_95;
    if (v49[0] == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = v49[0];
      if (os_log_type_enabled(v25, v49[0]))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_protocol_udp_finalize_output_frames";
        v27 = "%{public}s called with null udp";
        goto LABEL_94;
      }
      goto LABEL_95;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v25 = __nwlog_obj();
      v26 = v49[0];
      if (os_log_type_enabled(v25, v49[0]))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_protocol_udp_finalize_output_frames";
        v27 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_94;
      }
      goto LABEL_95;
    }
    v35 = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = v49[0];
    v38 = os_log_type_enabled(v25, v49[0]);
    if (!v35)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_protocol_udp_finalize_output_frames";
        v27 = "%{public}s called with null udp, no backtrace";
        goto LABEL_94;
      }
      goto LABEL_95;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      v56 = "nw_protocol_udp_finalize_output_frames";
      v57 = 2082;
      v58 = v35;
      v37 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_64;
    }
    goto LABEL_65;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v56 = "nw_protocol_udp_finalize_output_frames";
  v24 = (char *)_os_log_send_and_compose_impl();
  v49[0] = OS_LOG_TYPE_ERROR;
  type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v24, v49, &type))
    goto LABEL_95;
  if (v49[0] != OS_LOG_TYPE_FAULT)
  {
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v25 = __nwlog_obj();
      v26 = v49[0];
      if (os_log_type_enabled(v25, v49[0]))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_protocol_udp_finalize_output_frames";
        v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_94;
      }
      goto LABEL_95;
    }
    v35 = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = v49[0];
    v36 = os_log_type_enabled(v25, v49[0]);
    if (!v35)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_protocol_udp_finalize_output_frames";
        v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_94;
      }
      goto LABEL_95;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v56 = "nw_protocol_udp_finalize_output_frames";
      v57 = 2082;
      v58 = v35;
      v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_64:
      _os_log_impl(&dword_182FBE000, v25, v26, v37, buf, 0x16u);
    }
LABEL_65:
    free(v35);
    goto LABEL_95;
  }
  v25 = __nwlog_obj();
  v26 = v49[0];
  if (os_log_type_enabled(v25, v49[0]))
  {
    *(_DWORD *)buf = 136446210;
    v56 = "nw_protocol_udp_finalize_output_frames";
    v27 = "%{public}s called with null protocol";
LABEL_94:
    _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
  }
LABEL_95:
  if (v24)
    free(v24);
  return 0;
}

uint64_t ___ZL38nw_protocol_udp_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  __int16 v14;
  char v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t (*v26)(uint64_t, uint64_t, uint64_t, uint64_t);
  int v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  const char *v31;
  int v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  char *backtrace_string;
  _BOOL4 v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  const char *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  const char *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  const char *v65;
  char *v66;
  _BOOL4 v67;
  char *v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  char *v72;
  _BOOL4 v73;
  char *v74;
  _BOOL4 v75;
  char *v76;
  _BOOL4 v77;
  char *v78;
  _BOOL4 v79;
  char *v80;
  _BOOL4 v81;
  NSObject *v82;
  uint64_t v83;
  const char *v84;
  uint64_t v85;
  char *v86;
  NSObject *v87;
  os_log_type_t v88;
  const char *v89;
  char *v90;
  _BOOL4 v91;
  char v92;
  unsigned int v93;
  char v94;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v97;
  __int16 v98;
  void *v99;
  __int16 v100;
  int v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  nw_frame_unclaim(a2, a2, 8u, 0);
  v93 = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &v93);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)(a1 + 48);
    v7 = *(_QWORD *)(v6 + 64);
    if (v7)
      ++*(_QWORD *)(v7 + 120);
    *(_DWORD *)v4 = *(_DWORD *)(v6 + 88);
    *(_WORD *)(v4 + 4) = bswap32((unsigned __int16)v93) >> 16;
    if (a2)
    {
      if (*(_DWORD *)(a2 + 176))
        goto LABEL_30;
      v8 = *(_DWORD *)(v6 + 80);
      if (v8 > 499)
      {
        if (v8 <= 699)
        {
          if (v8 == 500)
          {
            v8 = 2621728;
            goto LABEL_29;
          }
          if (v8 == 600)
          {
            v8 = 3146000;
            goto LABEL_29;
          }
        }
        else
        {
          switch(v8)
          {
            case 700:
              v8 = 3670272;
              goto LABEL_29;
            case 800:
              v8 = 4194688;
              goto LABEL_29;
            case 900:
              v8 = 4718992;
              goto LABEL_29;
          }
        }
      }
      else if (v8 <= 199)
      {
        if (!v8)
          goto LABEL_29;
        if (v8 == 100)
        {
          v8 = 524432;
          goto LABEL_29;
        }
      }
      else
      {
        switch(v8)
        {
          case 200:
            v8 = 1048704;
            goto LABEL_29;
          case 300:
            v8 = 1572880;
            goto LABEL_29;
          case 400:
            v8 = 2097184;
LABEL_29:
            *(_DWORD *)(a2 + 176) = v8;
            goto LABEL_30;
        }
      }
      v8 = 0;
      goto LABEL_29;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v97 = "__nw_frame_get_service_class";
    v40 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault(v40, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v41 = __nwlog_obj();
        v42 = type;
        if (!os_log_type_enabled(v41, type))
          goto LABEL_136;
        *(_DWORD *)buf = 136446210;
        v97 = "__nw_frame_get_service_class";
        v43 = "%{public}s called with null frame";
LABEL_135:
        _os_log_impl(&dword_182FBE000, v41, v42, v43, buf, 0xCu);
        goto LABEL_136;
      }
      if (!v94)
      {
        v41 = __nwlog_obj();
        v42 = type;
        if (!os_log_type_enabled(v41, type))
          goto LABEL_136;
        *(_DWORD *)buf = 136446210;
        v97 = "__nw_frame_get_service_class";
        v43 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_135;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v41 = __nwlog_obj();
      v42 = type;
      v45 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v45)
          goto LABEL_136;
        *(_DWORD *)buf = 136446210;
        v97 = "__nw_frame_get_service_class";
        v43 = "%{public}s called with null frame, no backtrace";
        goto LABEL_135;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v97 = "__nw_frame_get_service_class";
        v98 = 2082;
        v99 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
    }
LABEL_136:
    if (v40)
      free(v40);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v97 = "__nw_frame_set_traffic_class";
    v68 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (!__nwlog_fault(v68, &type, &v94))
      goto LABEL_152;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v69 = __nwlog_obj();
      v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "__nw_frame_set_traffic_class";
        v71 = "%{public}s called with null frame";
LABEL_151:
        _os_log_impl(&dword_182FBE000, v69, v70, v71, buf, 0xCu);
      }
    }
    else if (v94)
    {
      v72 = (char *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = type;
      v73 = os_log_type_enabled(v69, type);
      if (v72)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446466;
          v97 = "__nw_frame_set_traffic_class";
          v98 = 2082;
          v99 = v72;
          _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v72);
        goto LABEL_152;
      }
      if (v73)
      {
        *(_DWORD *)buf = 136446210;
        v97 = "__nw_frame_set_traffic_class";
        v71 = "%{public}s called with null frame, no backtrace";
        goto LABEL_151;
      }
    }
    else
    {
      v69 = __nwlog_obj();
      v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "__nw_frame_set_traffic_class";
        v71 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_151;
      }
    }
LABEL_152:
    if (v68)
      free(v68);
    v6 = *(_QWORD *)(a1 + 48);
LABEL_30:
    v9 = *(unsigned __int16 *)(v6 + 94);
    if ((~v9 & 0x14) == 0)
      goto LABEL_31;
    if ((v9 & 4) != 0)
    {
      v12 = *(unsigned int *)(v6 + 48) + (unint64_t)*(unsigned int *)(v6 + 32) + bswap32(v93 + 17);
      LODWORD(v12) = ((WORD1(v12) + (unsigned __int16)v12 + HIDWORD(v12)) >> 16)
                   + (unsigned __int16)(WORD1(v12) + v12 + WORD2(v12));
      LODWORD(v12) = ((WORD1(v12) + (unsigned __int16)v12) >> 16) + (unsigned __int16)(WORD1(v12) + v12);
      v11 = v12 + WORD1(v12);
    }
    else
    {
      LOWORD(v11) = in6_pseudo((unsigned __int16 *)(v6 + 32), (unsigned __int16 *)(v6 + 48), bswap32(v93 + 17));
    }
    *(_WORD *)(v5 + 6) = v11;
    v13 = *(_QWORD *)(a1 + 48);
    v14 = *(_WORD *)(v13 + 94);
    if ((v14 & 0x100) == 0)
    {
LABEL_44:
      v10 = *(_QWORD *)(a1 + 48);
      v16 = *(_WORD *)(v10 + 94);
      if ((v16 & 0x100) != 0)
        goto LABEL_52;
      if ((v16 & 8) == 0)
        goto LABEL_46;
      if ((v16 & 4) != 0)
        v24 = 20;
      else
        v24 = 40;
      if ((v16 & 4) != 0)
        v25 = 26;
      else
        v25 = 46;
      if (a2)
      {
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0)
          goto LABEL_46;
        v26 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))g_channel_set_internet_checksum_handler;
        if (!g_channel_set_internet_checksum_handler)
          goto LABEL_46;
        *(_BYTE *)(a2 + 203) |= 3u;
        v27 = v26(a2, 3, v24, v25);
        if (!v27)
          goto LABEL_31;
        v28 = v27;
        if (v27 == 45)
        {
LABEL_46:
          v17 = *(_QWORD *)(a1 + 48);
          v18 = *(_WORD *)(v17 + 94);
          if (in_finalize_cksum(a2, 6u, 1))
          {
            if (a2)
            {
              if ((*(_WORD *)(a2 + 204) & 0x100) != 0
                && g_channel_check_validity
                && (g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)) & 1) == 0)
              {
LABEL_214:
                *(_QWORD *)(v17 + 64) = 0;
                *(_QWORD *)(v17 + 72) = 0;
                goto LABEL_31;
              }
LABEL_82:
              v32 = *(_DWORD *)(a2 + 52);
              if (v32)
              {
                v33 = (v32 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60)));
                v34 = *(_QWORD **)(v17 + 64);
                if ((v18 & 4) != 0)
                {
LABEL_199:
                  if (v34)
                  {
                    v85 = v34[17] + v33;
                    ++v34[16];
                    v34[17] = v85;
                  }
                  goto LABEL_31;
                }
              }
              else
              {
                v33 = 0;
                v34 = *(_QWORD **)(v17 + 64);
                if ((v18 & 4) != 0)
                  goto LABEL_199;
              }
LABEL_86:
              if (v34)
              {
                v35 = v34[19] + v33;
                ++v34[18];
                v34[19] = v35;
              }
LABEL_31:
              v10 = *(_QWORD *)(a1 + 48);
              if (!v10)
                goto LABEL_58;
LABEL_52:
              v19 = *(_QWORD *)(v10 + 72);
              if (!v19
                || (++*(_QWORD *)(v19 + 32), (v20 = *(_QWORD *)(a1 + 48)) == 0)
                || (v21 = *(_QWORD *)(v20 + 72)) == 0)
              {
LABEL_58:
                ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                if (_nw_signposts_once != -1)
                  dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
                if (!_nw_signposts_enabled || !kdebug_is_enabled())
                  goto LABEL_62;
                if (a2)
                {
LABEL_100:
                  kdebug_trace();
LABEL_62:
                  if (v93 >= 9)
                    **(_QWORD **)(a1 + 48) = v93 + **(_QWORD **)(a1 + 48) - 8;
                  return 1;
                }
                __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                v97 = "__nw_frame_effective_length";
                v86 = (char *)_os_log_send_and_compose_impl();
                type = OS_LOG_TYPE_ERROR;
                v94 = 0;
                if (__nwlog_fault(v86, &type, &v94))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    v87 = __nwlog_obj();
                    v88 = type;
                    if (!os_log_type_enabled(v87, type))
                      goto LABEL_235;
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v89 = "%{public}s called with null frame";
                    goto LABEL_234;
                  }
                  if (!v94)
                  {
                    v87 = __nwlog_obj();
                    v88 = type;
                    if (!os_log_type_enabled(v87, type))
                      goto LABEL_235;
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v89 = "%{public}s called with null frame, backtrace limit exceeded";
                    goto LABEL_234;
                  }
                  v90 = (char *)__nw_create_backtrace_string();
                  v87 = __nwlog_obj();
                  v88 = type;
                  v91 = os_log_type_enabled(v87, type);
                  if (v90)
                  {
                    if (v91)
                    {
                      *(_DWORD *)buf = 136446466;
                      v97 = "__nw_frame_effective_length";
                      v98 = 2082;
                      v99 = v90;
                      _os_log_impl(&dword_182FBE000, v87, v88, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    free(v90);
                    goto LABEL_235;
                  }
                  if (v91)
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v89 = "%{public}s called with null frame, no backtrace";
LABEL_234:
                    _os_log_impl(&dword_182FBE000, v87, v88, v89, buf, 0xCu);
                  }
                }
LABEL_235:
                if (v86)
                  free(v86);
                goto LABEL_100;
              }
              if (a2)
              {
                v22 = *(unsigned int *)(a2 + 52);
LABEL_57:
                *(_QWORD *)(v21 + 40) += v22;
                goto LABEL_58;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              v97 = "__nw_frame_effective_length";
              v54 = (char *)_os_log_send_and_compose_impl();
              type = OS_LOG_TYPE_ERROR;
              v94 = 0;
              if (__nwlog_fault(v54, &type, &v94))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  v55 = __nwlog_obj();
                  v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v57 = "%{public}s called with null frame";
LABEL_205:
                    _os_log_impl(&dword_182FBE000, v55, v56, v57, buf, 0xCu);
                  }
                }
                else if (v94)
                {
                  v76 = (char *)__nw_create_backtrace_string();
                  v55 = __nwlog_obj();
                  v56 = type;
                  v77 = os_log_type_enabled(v55, type);
                  if (v76)
                  {
                    if (v77)
                    {
                      *(_DWORD *)buf = 136446466;
                      v97 = "__nw_frame_effective_length";
                      v98 = 2082;
                      v99 = v76;
                      _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    free(v76);
                    goto LABEL_206;
                  }
                  if (v77)
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v57 = "%{public}s called with null frame, no backtrace";
                    goto LABEL_205;
                  }
                }
                else
                {
                  v55 = __nwlog_obj();
                  v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v97 = "__nw_frame_effective_length";
                    v57 = "%{public}s called with null frame, backtrace limit exceeded";
                    goto LABEL_205;
                  }
                }
              }
LABEL_206:
              if (v54)
                free(v54);
              v22 = 0;
              v21 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 72);
              goto LABEL_57;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v97 = "__nw_frame_check_validity";
            v58 = (char *)_os_log_send_and_compose_impl();
            type = OS_LOG_TYPE_ERROR;
            v94 = 0;
            if (__nwlog_fault(v58, &type, &v94))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                v59 = __nwlog_obj();
                v60 = type;
                if (!os_log_type_enabled(v59, type))
                  goto LABEL_212;
                *(_DWORD *)buf = 136446210;
                v97 = "__nw_frame_check_validity";
                v61 = "%{public}s called with null frame";
                goto LABEL_211;
              }
              if (!v94)
              {
                v59 = __nwlog_obj();
                v60 = type;
                if (!os_log_type_enabled(v59, type))
                  goto LABEL_212;
                *(_DWORD *)buf = 136446210;
                v97 = "__nw_frame_check_validity";
                v61 = "%{public}s called with null frame, backtrace limit exceeded";
                goto LABEL_211;
              }
              v78 = (char *)__nw_create_backtrace_string();
              v59 = __nwlog_obj();
              v60 = type;
              v79 = os_log_type_enabled(v59, type);
              if (v78)
              {
                if (v79)
                {
                  *(_DWORD *)buf = 136446466;
                  v97 = "__nw_frame_check_validity";
                  v98 = 2082;
                  v99 = v78;
                  _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v78);
                goto LABEL_212;
              }
              if (v79)
              {
                *(_DWORD *)buf = 136446210;
                v97 = "__nw_frame_check_validity";
                v61 = "%{public}s called with null frame, no backtrace";
LABEL_211:
                _os_log_impl(&dword_182FBE000, v59, v60, v61, buf, 0xCu);
              }
            }
LABEL_212:
            if (v58)
              free(v58);
            goto LABEL_214;
          }
          if (a2)
            goto LABEL_82;
          v92 = v18;
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v97 = "__nw_frame_unclaimed_length";
          v50 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v94 = 0;
          if (__nwlog_fault(v50, &type, &v94))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v51 = __nwlog_obj();
              v52 = type;
              if (!os_log_type_enabled(v51, type))
                goto LABEL_196;
              *(_DWORD *)buf = 136446210;
              v97 = "__nw_frame_unclaimed_length";
              v53 = "%{public}s called with null frame";
LABEL_195:
              _os_log_impl(&dword_182FBE000, v51, v52, v53, buf, 0xCu);
              goto LABEL_196;
            }
            if (!v94)
            {
              v51 = __nwlog_obj();
              v52 = type;
              if (!os_log_type_enabled(v51, type))
                goto LABEL_196;
              *(_DWORD *)buf = 136446210;
              v97 = "__nw_frame_unclaimed_length";
              v53 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_195;
            }
            v74 = (char *)__nw_create_backtrace_string();
            v51 = __nwlog_obj();
            v52 = type;
            v75 = os_log_type_enabled(v51, type);
            if (!v74)
            {
              if (!v75)
                goto LABEL_196;
              *(_DWORD *)buf = 136446210;
              v97 = "__nw_frame_unclaimed_length";
              v53 = "%{public}s called with null frame, no backtrace";
              goto LABEL_195;
            }
            if (v75)
            {
              *(_DWORD *)buf = 136446466;
              v97 = "__nw_frame_unclaimed_length";
              v98 = 2082;
              v99 = v74;
              _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v74);
          }
LABEL_196:
          if (v50)
            free(v50);
          v33 = 0;
          v34 = *(_QWORD **)(v17 + 64);
          if ((v92 & 4) != 0)
            goto LABEL_199;
          goto LABEL_86;
        }
LABEL_76:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v30 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 136446722;
          v97 = "nw_protocol_udp_finalize_output_frames_block_invoke";
          if (v30)
            v31 = (const char *)(v30 + 96);
          else
            v31 = "";
          v98 = 2082;
          v99 = (void *)v31;
          v100 = 1024;
          v101 = v28;
          _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp set internet checksum offload failed (err %d)", buf, 0x1Cu);
        }
        goto LABEL_46;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v97 = "__nw_frame_set_internet_checksum";
      v62 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (__nwlog_fault(v62, &type, &v94))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v63 = __nwlog_obj();
          v64 = type;
          if (os_log_type_enabled(v63, type))
          {
            *(_DWORD *)buf = 136446210;
            v97 = "__nw_frame_set_internet_checksum";
            v65 = "%{public}s called with null frame";
LABEL_217:
            _os_log_impl(&dword_182FBE000, v63, v64, v65, buf, 0xCu);
          }
        }
        else if (v94)
        {
          v80 = (char *)__nw_create_backtrace_string();
          v63 = __nwlog_obj();
          v64 = type;
          v81 = os_log_type_enabled(v63, type);
          if (v80)
          {
            if (v81)
            {
              *(_DWORD *)buf = 136446466;
              v97 = "__nw_frame_set_internet_checksum";
              v98 = 2082;
              v99 = v80;
              _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v80);
            goto LABEL_218;
          }
          if (v81)
          {
            *(_DWORD *)buf = 136446210;
            v97 = "__nw_frame_set_internet_checksum";
            v65 = "%{public}s called with null frame, no backtrace";
            goto LABEL_217;
          }
        }
        else
        {
          v63 = __nwlog_obj();
          v64 = type;
          if (os_log_type_enabled(v63, type))
          {
            *(_DWORD *)buf = 136446210;
            v97 = "__nw_frame_set_internet_checksum";
            v65 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_217;
          }
        }
      }
LABEL_218:
      if (v62)
        free(v62);
      v28 = 22;
      goto LABEL_76;
    }
    if ((v14 & 4) != 0)
      v15 = 18;
    else
      v15 = 66;
    if (a2)
    {
      if ((*(_WORD *)(a2 + 204) & 0x100) != 0)
        *(_BYTE *)(a2 + 203) |= v15;
      else
        *(_WORD *)(v13 + 94) = v14 & 0xFEFF;
      goto LABEL_44;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v97 = "__nw_frame_add_internet_csum_flags";
    v46 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault(v46, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v47 = __nwlog_obj();
        v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "__nw_frame_add_internet_csum_flags";
          v49 = "%{public}s called with null frame";
LABEL_183:
          _os_log_impl(&dword_182FBE000, v47, v48, v49, buf, 0xCu);
        }
      }
      else if (v94)
      {
        v66 = (char *)__nw_create_backtrace_string();
        v47 = __nwlog_obj();
        v48 = type;
        v67 = os_log_type_enabled(v47, type);
        if (v66)
        {
          if (v67)
          {
            *(_DWORD *)buf = 136446466;
            v97 = "__nw_frame_add_internet_csum_flags";
            v98 = 2082;
            v99 = v66;
            _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v66);
          goto LABEL_184;
        }
        if (v67)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "__nw_frame_add_internet_csum_flags";
          v49 = "%{public}s called with null frame, no backtrace";
          goto LABEL_183;
        }
      }
      else
      {
        v47 = __nwlog_obj();
        v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "__nw_frame_add_internet_csum_flags";
          v49 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_183;
        }
      }
    }
LABEL_184:
    if (v46)
      free(v46);
    *(_WORD *)(*(_QWORD *)(a1 + 48) + 94) &= ~0x100u;
    v82 = __nwlog_obj();
    if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
    {
      v83 = *(_QWORD *)(a1 + 48);
      *(_DWORD *)buf = 136446722;
      v97 = "nw_protocol_udp_finalize_output_frames_block_invoke";
      if (v83)
        v84 = (const char *)(v83 + 96);
      else
        v84 = "";
      v98 = 2082;
      v99 = (void *)v84;
      v100 = 1024;
      v101 = 22;
      _os_log_impl(&dword_182FBE000, v82, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp set internet checksum offload failed (err %d)", buf, 0x1Cu);
    }
    goto LABEL_44;
  }
  v36 = __nwlog_obj();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
  {
    v37 = *(_QWORD *)(a1 + 48);
    if (v37)
      v38 = (const char *)(v37 + 96);
    else
      v38 = "";
    *(_DWORD *)buf = 136446466;
    v97 = "nw_protocol_udp_finalize_output_frames_block_invoke";
    v98 = 2082;
    v99 = (void *)v38;
    _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_INFO, "%{public}s %{public}s UDP frame is no longer valid", buf, 0x16u);
  }
  v39 = *(_QWORD *)(a1 + 48);
  if (v39)
  {
    *(_QWORD *)(v39 + 64) = 0;
    *(_QWORD *)(v39 + 72) = 0;
  }
  return 1;
}

uint64_t nw_protocol_ipv4_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  nw_frame *tqh_first;
  nw_frame *v5;
  char v6;
  nw_protocol *output_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v10;
  uint64_t (*finalize_output_frames)(nw_protocol *, nw_frame_array_s *);
  uint64_t v12;
  nw_protocol_callbacks *v14;
  nw_protocol_callbacks *v15;
  void (**v16)(_QWORD);
  const void *v17;
  const char *name;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  const char *v36;
  const char *v37;
  _QWORD v38[2];
  uint64_t (*v39)(uint64_t, uint64_t);
  void *v40;
  nw_protocol **p_output_handler;
  nw_frame_array_s *v42;
  nw_protocol *v43;
  char v44;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  void *v49;
  __int16 v50;
  nw_protocol *v51;
  __int16 v52;
  char *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_protocol_ipv4_finalize_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_90;
      *(_DWORD *)buf = 136446210;
      v47 = "nw_protocol_ipv4_finalize_output_frames";
      v27 = "%{public}s called with null protocol";
LABEL_89:
      _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
      goto LABEL_90;
    }
    if (!v44)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv4_finalize_output_frames";
        v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v32 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv4_finalize_output_frames";
        v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (!v32)
      goto LABEL_63;
    *(_DWORD *)buf = 136446466;
    v47 = "nw_protocol_ipv4_finalize_output_frames";
    v48 = 2082;
    v49 = backtrace_string;
    v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_62:
    _os_log_impl(&dword_182FBE000, v25, v26, v33, buf, 0x16u);
    goto LABEL_63;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_protocol_ipv4_finalize_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_90;
      *(_DWORD *)buf = 136446210;
      v47 = "nw_protocol_ipv4_finalize_output_frames";
      v27 = "%{public}s called with null ipv4";
      goto LABEL_89;
    }
    if (!v44)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv4_finalize_output_frames";
        v27 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v34 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "nw_protocol_ipv4_finalize_output_frames";
        v27 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (!v34)
      goto LABEL_63;
    *(_DWORD *)buf = 136446466;
    v47 = "nw_protocol_ipv4_finalize_output_frames";
    v48 = 2082;
    v49 = backtrace_string;
    v33 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
    goto LABEL_62;
  }
  v38[0] = MEMORY[0x1E0C809B0];
  v38[1] = 0x40000000;
  v39 = ___ZL39nw_protocol_ipv4_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  v40 = &__block_descriptor_tmp_32_85743;
  p_output_handler = &a1[1].output_handler;
  v42 = a2;
  v43 = a1;
  tqh_first = a2->tqh_first;
  do
  {
    if (!tqh_first)
      break;
    v5 = (nw_frame *)*((_QWORD *)tqh_first + 4);
    v6 = ((uint64_t (*)(_QWORD *))v39)(v38);
    tqh_first = v5;
  }
  while ((v6 & 1) != 0);
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "__nw_protocol_finalize_output_frames";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_protocol_finalize_output_frames";
        v27 = "%{public}s called with null protocol";
        goto LABEL_89;
      }
LABEL_90:
      if (v24)
        free(v24);
      return 0;
    }
    if (!v44)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_protocol_finalize_output_frames";
        v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v35 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v47 = "__nw_protocol_finalize_output_frames";
        v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v47 = "__nw_protocol_finalize_output_frames";
      v48 = 2082;
      v49 = backtrace_string;
      v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_62;
    }
LABEL_63:
    free(backtrace_string);
    goto LABEL_90;
  }
  handle = output_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = output_handler[1].callbacks;
    if (callbacks)
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  v10 = output_handler->callbacks;
  if (v10)
  {
    finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v10->finalize_output_frames;
    if (finalize_output_frames)
    {
      v12 = finalize_output_frames(output_handler, a2);
      if (handle != &nw_protocol_ref_counted_handle)
        return v12;
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  name = output_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v47 = "__nw_protocol_finalize_output_frames";
  if (!name)
    name = "invalid";
  v48 = 2082;
  v49 = (void *)name;
  v50 = 2048;
  v51 = output_handler;
  v19 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v44 = 0;
  if (!__nwlog_fault(v19, &type, &v44))
    goto LABEL_73;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_73;
    v22 = output_handler->identifier->name;
    if (!v22)
      v22 = "invalid";
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v22;
    v50 = 2048;
    v51 = output_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_72:
    _os_log_impl(&dword_182FBE000, v20, v21, v23, buf, 0x20u);
    goto LABEL_73;
  }
  if (!v44)
  {
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_73;
    v36 = output_handler->identifier->name;
    if (!v36)
      v36 = "invalid";
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v36;
    v50 = 2048;
    v51 = output_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
    goto LABEL_72;
  }
  v28 = (char *)__nw_create_backtrace_string();
  v20 = __nwlog_obj();
  v21 = type;
  v29 = os_log_type_enabled(v20, type);
  if (!v28)
  {
    if (!v29)
      goto LABEL_73;
    v37 = output_handler->identifier->name;
    if (!v37)
      v37 = "invalid";
    *(_DWORD *)buf = 136446722;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v37;
    v50 = 2048;
    v51 = output_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
    goto LABEL_72;
  }
  if (v29)
  {
    v30 = output_handler->identifier->name;
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446978;
    v47 = "__nw_protocol_finalize_output_frames";
    v48 = 2082;
    v49 = (void *)v30;
    v50 = 2048;
    v51 = output_handler;
    v52 = 2082;
    v53 = v28;
    _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v28);
LABEL_73:
  if (v19)
    free(v19);
  v12 = 0;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_13:
    if (output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v14 = output_handler[1].callbacks;
      if (v14)
      {
        v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
        output_handler[1].callbacks = v15;
        if (!v15)
        {
          v16 = *(void (***)(_QWORD))output_handler[1].flow_id;
          if (v16)
          {
            *(_QWORD *)output_handler[1].flow_id = 0;
            v16[2](v16);
            _Block_release(v16);
          }
          if ((output_handler[1].flow_id[8] & 1) != 0)
          {
            v17 = *(const void **)output_handler[1].flow_id;
            if (v17)
              _Block_release(v17);
          }
          free(output_handler);
        }
      }
    }
  }
  return v12;
}

uint64_t ___ZL39nw_protocol_ipv4_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  _BOOL4 v17;
  const char *v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  _BOOL4 v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *v36;
  _BOOL4 v37;
  uint16x4_t v38;
  int v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  char *backtrace_string;
  _BOOL4 v51;
  int v52;
  char v53;
  os_log_type_t type;
  int __buf;
  const char *v56;
  __int16 v57;
  void *v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  uint64_t v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (nw_frame_get_finalizer_context(a2) == *(_QWORD *)(a1 + 32))
  {
    v14 = *(_QWORD *)(a2 + 32);
    v15 = *(_QWORD **)(a2 + 40);
    if (v14)
    {
      *(_QWORD *)(v14 + 40) = v15;
      v15 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) = v15;
    }
    *v15 = v14;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
  }
  else
  {
    nw_frame_unclaim(a2, v4, 0x14u, 0);
    v52 = 0;
    v5 = nw_frame_unclaimed_bytes(a2, &v52);
    v6 = *(_QWORD *)(a1 + 32);
    if (v5)
    {
      v7 = v5;
      v8 = *(_QWORD *)(v6 + 48);
      if (v8)
        ++*(_QWORD *)(v8 + 232);
      *(_QWORD *)(v5 + 12) = *(_QWORD *)(v6 + 56);
      *(_BYTE *)(v5 + 9) = *(_BYTE *)(v6 + 134);
      *(_BYTE *)(v5 + 8) = *(_BYTE *)(v6 + 135);
      *(_BYTE *)v5 = 69;
      *(_WORD *)(v5 + 2) = bswap32((unsigned __int16)v52) >> 16;
      if (a2)
      {
        v9 = *(_BYTE *)(a2 + 186) & 3;
        *(_BYTE *)(v5 + 1) = v9;
        if (*(_BYTE *)(a2 + 184))
          *(_BYTE *)(v5 + 1) = v9 | (4 * *(_BYTE *)(a2 + 184));
        v10 = *(_DWORD *)(a2 + 180);
        if (v10 == 2)
          goto LABEL_11;
        v11 = *(_QWORD *)(a1 + 32);
        if (v10)
        {
LABEL_76:
          v13 = 0;
          *(_DWORD *)(v7 + 4) = 0x400000;
          goto LABEL_77;
        }
LABEL_10:
        if ((*(_BYTE *)(v11 + 136) & 8) != 0)
        {
LABEL_11:
          *(_WORD *)(v7 + 6) = 0;
          LOWORD(__buf) = 0;
          v12 = (BYTE4(a2) ^ BYTE6(a2) ^ BYTE2(a2) ^ a2);
          do
            arc4random_buf(&__buf, 2uLL);
          while (v12 == (unsigned __int16)__buf);
          v13 = (unsigned __int16)__buf ^ v12;
          *(_WORD *)(v7 + 4) = v13;
          v11 = *(_QWORD *)(a1 + 32);
LABEL_77:
          *(_WORD *)(v7 + 10) = 0;
          if ((*(_BYTE *)(v11 + 136) & 0x20) != 0)
          {
            if ((*(_BYTE *)(v11 + 136) & 0x40) != 0)
            {
              *(_WORD *)(v7 + 10) = nw_ipv4_checksum((unsigned __int16 *)v7);
              v45 = *(_QWORD *)(v11 + 48);
              if (v45)
                *(int64x2_t *)(v45 + 312) = vaddq_s64(*(int64x2_t *)(v45 + 312), (int64x2_t)xmmword_183C6F230);
              *(_BYTE *)(v11 + 136) &= ~0x40u;
            }
            else
            {
              *(_WORD *)(v7 + 10) = -16657;
              *(_BYTE *)(v11 + 136) |= 0x40u;
            }
            goto LABEL_87;
          }
          if ((*(_BYTE *)(v11 + 136) & 0x10) == 0)
          {
            if ((v7 & 3) != 0)
            {
              v38.i16[0] = *(_WORD *)(v7 + 2);
              v38.i16[1] = *(_WORD *)v7;
              v38.i32[1] = *(_DWORD *)(v7 + 6);
              v39 = vaddvq_s32((int32x4_t)vaddl_u16(v38, *(uint16x4_t *)(v7 + 12)));
              LODWORD(v40) = ((v39 + v13) >> 16)
                           + (unsigned __int16)(v39 + v13)
                           + ((((v39 + v13) >> 16) + (unsigned __int16)(v39 + v13)) >> 16);
            }
            else
            {
              v41 = vaddlvq_u32(*(uint32x4_t *)v7);
              v42 = ((v41 + *(unsigned int *)(v7 + 16)) >> 32) + (v41 + *(_DWORD *)(v7 + 16));
              v40 = (((v42 >> 16) + (unsigned __int16)v42) >> 16) + (unsigned __int16)(WORD1(v42) + v42);
              LOWORD(v40) = WORD1(v40) + v40;
            }
            *(_WORD *)(v7 + 10) = ~(_WORD)v40;
            v43 = *(_QWORD *)(v11 + 48);
            if (v43)
              *(int64x2_t *)(v43 + 312) = vaddq_s64(*(int64x2_t *)(v43 + 312), (int64x2_t)xmmword_183C6F230);
LABEL_87:
            ++**(_QWORD **)(a1 + 32);
            return 1;
          }
          if (a2)
          {
            if ((*(_WORD *)(a2 + 204) & 0x100) != 0)
              *(_BYTE *)(a2 + 203) |= 4u;
            goto LABEL_87;
          }
          __nwlog_obj();
          __buf = 136446210;
          v56 = "__nw_frame_add_internet_csum_flags";
          v46 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v53 = 0;
          if (__nwlog_fault(v46, &type, &v53))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v47 = __nwlog_obj();
              v48 = type;
              if (!os_log_type_enabled(v47, type))
                goto LABEL_108;
              __buf = 136446210;
              v56 = "__nw_frame_add_internet_csum_flags";
              v49 = "%{public}s called with null frame";
              goto LABEL_107;
            }
            if (!v53)
            {
              v47 = __nwlog_obj();
              v48 = type;
              if (!os_log_type_enabled(v47, type))
                goto LABEL_108;
              __buf = 136446210;
              v56 = "__nw_frame_add_internet_csum_flags";
              v49 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_107;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            v47 = __nwlog_obj();
            v48 = type;
            v51 = os_log_type_enabled(v47, type);
            if (backtrace_string)
            {
              if (v51)
              {
                __buf = 136446466;
                v56 = "__nw_frame_add_internet_csum_flags";
                v57 = 2082;
                v58 = backtrace_string;
                _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
              }
              free(backtrace_string);
              goto LABEL_108;
            }
            if (v51)
            {
              __buf = 136446210;
              v56 = "__nw_frame_add_internet_csum_flags";
              v49 = "%{public}s called with null frame, no backtrace";
LABEL_107:
              _os_log_impl(&dword_182FBE000, v47, v48, v49, (uint8_t *)&__buf, 0xCu);
            }
          }
LABEL_108:
          if (v46)
            free(v46);
          goto LABEL_87;
        }
        goto LABEL_76;
      }
      __nwlog_obj();
      __buf = 136446210;
      v56 = "__nw_frame_get_ecn_flag";
      v20 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v53 = 0;
      if (__nwlog_fault(v20, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v21 = __nwlog_obj();
          v22 = type;
          if (!os_log_type_enabled(v21, type))
            goto LABEL_41;
          __buf = 136446210;
          v56 = "__nw_frame_get_ecn_flag";
          v23 = "%{public}s called with null frame";
LABEL_40:
          _os_log_impl(&dword_182FBE000, v21, v22, v23, (uint8_t *)&__buf, 0xCu);
          goto LABEL_41;
        }
        if (!v53)
        {
          v21 = __nwlog_obj();
          v22 = type;
          if (!os_log_type_enabled(v21, type))
            goto LABEL_41;
          __buf = 136446210;
          v56 = "__nw_frame_get_ecn_flag";
          v23 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_40;
        }
        v24 = (char *)__nw_create_backtrace_string();
        v21 = __nwlog_obj();
        v22 = type;
        v25 = os_log_type_enabled(v21, type);
        if (!v24)
        {
          if (!v25)
            goto LABEL_41;
          __buf = 136446210;
          v56 = "__nw_frame_get_ecn_flag";
          v23 = "%{public}s called with null frame, no backtrace";
          goto LABEL_40;
        }
        if (v25)
        {
          __buf = 136446466;
          v56 = "__nw_frame_get_ecn_flag";
          v57 = 2082;
          v58 = v24;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
        }
        free(v24);
      }
LABEL_41:
      if (v20)
        free(v20);
      *(_BYTE *)(v7 + 1) = 0;
      __nwlog_obj();
      __buf = 136446210;
      v56 = "__nw_frame_get_dscp_value";
      v26 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v53 = 0;
      if (__nwlog_fault(v26, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (!os_log_type_enabled(v27, type))
            goto LABEL_57;
          __buf = 136446210;
          v56 = "__nw_frame_get_dscp_value";
          v29 = "%{public}s called with null frame";
LABEL_56:
          _os_log_impl(&dword_182FBE000, v27, v28, v29, (uint8_t *)&__buf, 0xCu);
          goto LABEL_57;
        }
        if (!v53)
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (!os_log_type_enabled(v27, type))
            goto LABEL_57;
          __buf = 136446210;
          v56 = "__nw_frame_get_dscp_value";
          v29 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_56;
        }
        v30 = (char *)__nw_create_backtrace_string();
        v27 = __nwlog_obj();
        v28 = type;
        v31 = os_log_type_enabled(v27, type);
        if (!v30)
        {
          if (!v31)
            goto LABEL_57;
          __buf = 136446210;
          v56 = "__nw_frame_get_dscp_value";
          v29 = "%{public}s called with null frame, no backtrace";
          goto LABEL_56;
        }
        if (v31)
        {
          __buf = 136446466;
          v56 = "__nw_frame_get_dscp_value";
          v57 = 2082;
          v58 = v30;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
        }
        free(v30);
      }
LABEL_57:
      if (v26)
        free(v26);
      __nwlog_obj();
      __buf = 136446210;
      v56 = "__nw_frame_get_fragmentation";
      v32 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v53 = 0;
      if (!__nwlog_fault(v32, &type, &v53))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          __buf = 136446210;
          v56 = "__nw_frame_get_fragmentation";
          v35 = "%{public}s called with null frame";
LABEL_72:
          _os_log_impl(&dword_182FBE000, v33, v34, v35, (uint8_t *)&__buf, 0xCu);
        }
      }
      else if (v53)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = type;
        v37 = os_log_type_enabled(v33, type);
        if (v36)
        {
          if (v37)
          {
            __buf = 136446466;
            v56 = "__nw_frame_get_fragmentation";
            v57 = 2082;
            v58 = v36;
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
          }
          free(v36);
          goto LABEL_73;
        }
        if (v37)
        {
          __buf = 136446210;
          v56 = "__nw_frame_get_fragmentation";
          v35 = "%{public}s called with null frame, no backtrace";
          goto LABEL_72;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          __buf = 136446210;
          v56 = "__nw_frame_get_fragmentation";
          v35 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_72;
        }
      }
LABEL_73:
      if (v32)
        free(v32);
      v11 = *(_QWORD *)(a1 + 32);
      goto LABEL_10;
    }
    if (!v6 || (*(_BYTE *)(v6 + 136) & 1) == 0)
    {
      v16 = __nwlog_obj();
      v17 = os_log_type_enabled(v16, OS_LOG_TYPE_INFO);
      v6 = *(_QWORD *)(a1 + 32);
      if (v17)
      {
        v18 = (const char *)(v6 + 137);
        if (!v6)
          v18 = "";
        __buf = 136446978;
        v56 = "nw_protocol_ipv4_finalize_output_frames_block_invoke";
        v57 = 2082;
        v58 = (void *)v18;
        v19 = " ";
        if (!v6)
          v19 = "";
        v59 = 2080;
        v60 = v19;
        v61 = 2048;
        v62 = v6;
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", (uint8_t *)&__buf, 0x2Au);
        v6 = *(_QWORD *)(a1 + 32);
      }
    }
    *(_QWORD *)(v6 + 48) = 0;
  }
  return 1;
}

uint64_t nw_frame_unclaimed_bytes(uint64_t a1, _DWORD *a2)
{
  int v4;
  uint64_t result;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "__nw_frame_unclaimed_bytes";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12))
      goto LABEL_27;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v15 = "__nw_frame_unclaimed_bytes";
      v9 = "%{public}s called with null frame";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "__nw_frame_unclaimed_bytes";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_27;
      }
      if (!v11)
      {
LABEL_27:
        if (v6)
          free(v6);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v15 = "__nw_frame_unclaimed_bytes";
      v9 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v15 = "__nw_frame_unclaimed_bytes";
      v9 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_27;
  }
  if (!*(_QWORD *)(a1 + 112))
    return 0;
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0
    && g_channel_check_validity
    && (g_channel_check_validity(a1, *(_QWORD *)(a1 + 88)) & 1) == 0)
  {
    result = 0;
    if (a2)
      *a2 = 0;
  }
  else
  {
    if (a2)
    {
      v4 = *(_DWORD *)(a1 + 52);
      if (v4)
        v4 -= *(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60);
      *a2 = v4;
    }
    return *(_QWORD *)(a1 + 112) + *(unsigned int *)(a1 + 56);
  }
  return result;
}

BOOL nw_frame_unclaim(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *v11;
  _BOOL4 v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v16;
  _BOOL8 result;
  int v18;
  const char *v19;
  NSObject *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  _WORD v36[17];

  *(_QWORD *)&v36[13] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "__nw_frame_unclaim_internal";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v25, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_unclaim_internal";
          v28 = "%{public}s called with null frame";
LABEL_43:
          _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v26 = __nwlog_obj();
        v27 = type;
        v30 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v34 = "__nw_frame_unclaim_internal";
            v35 = 2082;
            *(_QWORD *)v36 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_44;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_unclaim_internal";
          v28 = "%{public}s called with null frame, no backtrace";
          goto LABEL_43;
        }
      }
      else
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_unclaim_internal";
          v28 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_43;
        }
      }
    }
LABEL_44:
    if (v25)
      free(v25);
    return 0;
  }
  if ((*(_WORD *)(a1 + 204) & 0x80) == 0)
    goto LABEL_21;
  if (a4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v34 = "__nw_frame_unclaim_internal";
    v35 = 1024;
    *(_DWORD *)v36 = a4;
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v7, &type, &v31))
      goto LABEL_18;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446466;
      v34 = "__nw_frame_unclaim_internal";
      v35 = 1024;
      *(_DWORD *)v36 = a4;
      v10 = "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate";
    }
    else if (v31)
    {
      v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v11)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          v34 = "__nw_frame_unclaim_internal";
          v35 = 1024;
          *(_DWORD *)v36 = a4;
          v36[2] = 2082;
          *(_QWORD *)&v36[3] = v11;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v11);
        goto LABEL_18;
      }
      if (!v12)
      {
LABEL_18:
        if (v7)
          free(v7);
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446466;
      v34 = "__nw_frame_unclaim_internal";
      v35 = 1024;
      *(_DWORD *)v36 = a4;
      v10 = "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446466;
      v34 = "__nw_frame_unclaim_internal";
      v35 = 1024;
      *(_DWORD *)v36 = a4;
      v10 = "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0x12u);
    goto LABEL_18;
  }
LABEL_20:
  *(_WORD *)(a1 + 196) += a3;
LABEL_21:
  v13 = *(_DWORD *)(a1 + 56);
  v14 = v13 >= a3;
  v15 = v13 - a3;
  if (v14)
  {
    v21 = *(_DWORD *)(a1 + 60);
    v14 = v21 >= a4;
    v22 = v21 - a4;
    if (v14)
    {
      *(_DWORD *)(a1 + 56) = v15;
      *(_DWORD *)(a1 + 60) = v22;
      return 1;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        v24 = *(_DWORD *)(a1 + 60);
        *(_DWORD *)buf = 136446722;
        v34 = "__nw_frame_unclaim_internal";
        v35 = 1024;
        *(_DWORD *)v36 = a4;
        v36[2] = 1024;
        *(_DWORD *)&v36[3] = v24;
        v19 = "%{public}s Frame cannot unclaim %u end bytes (has %u left)";
        v20 = v23;
        goto LABEL_27;
      }
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v18 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136446722;
      v34 = "__nw_frame_unclaim_internal";
      v35 = 1024;
      *(_DWORD *)v36 = a3;
      v36[2] = 1024;
      *(_DWORD *)&v36[3] = v18;
      v19 = "%{public}s Frame cannot unclaim %u start bytes (has %u left)";
      v20 = v16;
LABEL_27:
      _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, v19, buf, 0x18u);
      return 0;
    }
  }
  return result;
}

uint64_t nw_frame_get_finalizer_context(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_QWORD *)(a1 + 88);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_frame_get_finalizer_context";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_frame_get_finalizer_context";
        v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_frame_get_finalizer_context";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_frame_get_finalizer_context";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_frame_get_finalizer_context";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

uint64_t __nw_protocol_instance_report_done_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t extra;
  uint64_t object;
  _QWORD *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint64_t v15;
  char v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD *, uint64_t, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(_QWORD *);
  void *v25;
  char v26;
  uint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  void *v32;
  const char *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  char *backtrace_string;
  os_log_type_t v39;
  _BOOL4 v40;
  const char *v41;
  os_log_type_t v42;
  const char *v43;
  const char *v44;
  char v45;
  os_log_type_t type;
  uint64_t v47;
  char v48;
  _QWORD *v49;
  char v50;
  _BYTE buf[12];
  __int16 v52;
  const char *v53;
  __int16 v54;
  _QWORD *v55;
  __int16 v56;
  char *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  extra = nw_hash_node_get_extra(a2);
  *(_WORD *)(extra + 52) |= 0x200u;
  object = nw_hash_node_get_object(a2);
  if (!object)
    return 1;
  v6 = (_QWORD *)object;
  v7 = *(void **)(a1 + 32);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 40);
    v9 = v8 ? v8 - 96 : 0;
    v10 = *(_QWORD *)(object + 24);
    if (v10)
    {
      if (v8 && *(_QWORD *)(v10 + 56))
      {
        v11 = v7;
        v12 = v11[3];

        v13 = (void *)v6[5];
        if (v13 == &nw_protocol_ref_counted_handle)
        {
          v15 = v6[11];
          if (v15)
            v6[11] = v15 + 1;
          v14 = -1;
        }
        else
        {
          v14 = 0;
        }
        v49 = v6;
        v50 = v14;
        if (*(_UNKNOWN **)(v9 + 40) == &nw_protocol_ref_counted_handle)
        {
          v18 = *(_QWORD *)(v9 + 88);
          v17 = 0;
          if (v18)
            *(_QWORD *)(v9 + 88) = v18 + 1;
          v16 = -1;
        }
        else
        {
          v16 = 0;
          v17 = 1;
        }
        v47 = v9;
        v48 = v16;
        v19 = v6[3];
        if (v19)
        {
          v20 = *(void (**)(_QWORD *, uint64_t, uint64_t))(v19 + 56);
          if (v20)
          {
            v20(v6, v9, v12);
LABEL_22:
            if ((v17 & 1) == 0)
              nw::release_if_needed<nw_protocol *>(&v47);
            if (v13 == &nw_protocol_ref_counted_handle)
              nw::release_if_needed<nw_protocol *>((uint64_t *)&v49);
            goto LABEL_26;
          }
        }
        __nwlog_obj();
        v32 = (void *)objc_claimAutoreleasedReturnValue();
        v33 = (const char *)v6[2];
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_error";
        if (!v33)
          v33 = "invalid";
        v52 = 2082;
        v53 = v33;
        v54 = 2048;
        v55 = v6;
        v34 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v45 = 0;
        if (__nwlog_fault(v34, &type, &v45))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v35 = objc_claimAutoreleasedReturnValue();
            v36 = type;
            if (os_log_type_enabled(v35, type))
            {
              v37 = (const char *)v6[2];
              if (!v37)
                v37 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_error";
              v52 = 2082;
              v53 = v37;
              v54 = 2048;
              v55 = v6;
              _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid error callback", buf, 0x20u);
            }
          }
          else if (v45)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v35 = objc_claimAutoreleasedReturnValue();
            v39 = type;
            v40 = os_log_type_enabled(v35, type);
            if (backtrace_string)
            {
              if (v40)
              {
                v41 = (const char *)v6[2];
                if (!v41)
                  v41 = "invalid";
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "__nw_protocol_error";
                v52 = 2082;
                v53 = v41;
                v54 = 2048;
                v55 = v6;
                v56 = 2082;
                v57 = backtrace_string;
                _os_log_impl(&dword_182FBE000, v35, v39, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
              }

              free(backtrace_string);
              goto LABEL_73;
            }
            if (v40)
            {
              v44 = (const char *)v6[2];
              if (!v44)
                v44 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_error";
              v52 = 2082;
              v53 = v44;
              v54 = 2048;
              v55 = v6;
              _os_log_impl(&dword_182FBE000, v35, v39, "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace", buf, 0x20u);
            }
          }
          else
          {
            __nwlog_obj();
            v35 = objc_claimAutoreleasedReturnValue();
            v42 = type;
            if (os_log_type_enabled(v35, type))
            {
              v43 = (const char *)v6[2];
              if (!v43)
                v43 = "invalid";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_error";
              v52 = 2082;
              v53 = v43;
              v54 = 2048;
              v55 = v6;
              _os_log_impl(&dword_182FBE000, v35, v42, "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded", buf, 0x20u);
            }
          }

        }
LABEL_73:
        if (v34)
          free(v34);
        goto LABEL_22;
      }
    }
  }
LABEL_26:
  v21 = *(_QWORD *)(a1 + 40);
  if (v21)
    v22 = v21 - 96;
  else
    v22 = 0;
  v23 = v6[3];
  if (v23)
  {
    if (v21)
    {
      v24 = *(void (**)(_QWORD *))(v23 + 48);
      if (v24)
      {
        v25 = (void *)v6[5];
        if (v25 == &nw_protocol_ref_counted_handle)
        {
          v27 = v6[11];
          if (v27)
            v6[11] = v27 + 1;
          v26 = -1;
        }
        else
        {
          v26 = 0;
        }
        *(_QWORD *)buf = v6;
        buf[8] = v26;
        if (*(_UNKNOWN **)(v22 + 40) == &nw_protocol_ref_counted_handle)
        {
          v30 = *(_QWORD *)(v22 + 88);
          v29 = 0;
          if (v30)
            *(_QWORD *)(v22 + 88) = v30 + 1;
          v28 = -1;
        }
        else
        {
          v28 = 0;
          v29 = 1;
        }
        v49 = (_QWORD *)v22;
        v50 = v28;
        v24(v6);
        if ((v29 & 1) == 0)
          nw::release_if_needed<nw_protocol *>((uint64_t *)&v49);
        if (v25 == &nw_protocol_ref_counted_handle)
          nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      }
    }
  }
  return 1;
}

void sub_183008D28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19)
{
  _Unwind_Resume(exception_object);
}

void nw_hash_table_apply(char *a1, uint64_t a2)
{
  char *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  os_log_type_t v10;
  uint64_t v11;
  const char *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  os_log_type_t v20;
  int v21;
  _QWORD *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t **v25;
  int v26;
  int v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  os_log_type_t v31;
  uint64_t v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  NSObject *v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  uint64_t v41;
  uint64_t v42;
  os_log_type_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  os_log_type_t v50;
  uint64_t v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  char *v55;
  NSObject *v56;
  os_log_type_t v57;
  _BOOL4 v58;
  uint64_t v59;
  uint64_t v60;
  os_log_type_t v61;
  uint64_t v62;
  uint64_t v63;
  char v64;
  unsigned int v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  os_log_type_t v69;
  uint64_t v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  char *v74;
  NSObject *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  uint64_t v78;
  uint64_t v79;
  os_log_type_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  os_log_type_t v87;
  uint64_t v88;
  NSObject *v89;
  os_log_type_t v90;
  const char *v91;
  char *v92;
  NSObject *v93;
  os_log_type_t v94;
  _BOOL4 v95;
  uint64_t v96;
  uint64_t v97;
  os_log_type_t v98;
  uint64_t v99;
  uint64_t v100;
  NSObject *v101;
  unint64_t v102;
  const char *v103;
  int v104;
  void *v105;
  NSObject *v106;
  unint64_t v107;
  const char *v108;
  int v109;
  void *v110;
  NSObject *v111;
  void *v112;
  int v113;
  uint64_t v114;
  char *v115;
  NSObject *v116;
  os_log_type_t v117;
  uint64_t v118;
  const char *v119;
  char *v120;
  _BOOL4 v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  NSObject *v126;
  os_log_type_t v127;
  const char *v128;
  NSObject *v129;
  void *v130;
  char *v131;
  NSObject *v132;
  os_log_type_t v133;
  const char *v134;
  char *backtrace_string;
  _BOOL4 v136;
  char *v137;
  _BOOL4 v138;
  char *v139;
  _BOOL4 v140;
  int v141;
  os_unfair_lock_s *lock;
  _QWORD *v143;
  char v144;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v147;
  __int16 v148;
  const char *v149;
  __int16 v150;
  uint64_t v151;
  __int16 v152;
  uint64_t v153;
  __int16 v154;
  char *v155;
  uint64_t v156;

  v156 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v147 = "nw_hash_table_apply";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v144 = 0;
    if (!__nwlog_fault(v3, &type, &v144))
      goto LABEL_209;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v126 = __nwlog_obj();
      v127 = type;
      if (!os_log_type_enabled(v126, type))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null table";
      goto LABEL_208;
    }
    if (!v144)
    {
      v126 = __nwlog_obj();
      v127 = type;
      if (!os_log_type_enabled(v126, type))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null table, backtrace limit exceeded";
      goto LABEL_208;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v126 = __nwlog_obj();
    v127 = type;
    v136 = os_log_type_enabled(v126, type);
    if (!backtrace_string)
    {
      if (!v136)
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null table, no backtrace";
      goto LABEL_208;
    }
    if (v136)
    {
      *(_DWORD *)buf = 136446466;
      v147 = "nw_hash_table_apply";
      v148 = 2082;
      v149 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v126, v127, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_209:
    if (!v3)
      return;
    goto LABEL_165;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v147 = "nw_hash_table_apply";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v144 = 0;
    if (!__nwlog_fault(v3, &type, &v144))
      goto LABEL_209;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v126 = __nwlog_obj();
      v127 = type;
      if (!os_log_type_enabled(v126, type))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null apply_block";
      goto LABEL_208;
    }
    if (!v144)
    {
      v126 = __nwlog_obj();
      v127 = type;
      if (!os_log_type_enabled(v126, type))
        goto LABEL_209;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null apply_block, backtrace limit exceeded";
      goto LABEL_208;
    }
    v137 = (char *)__nw_create_backtrace_string();
    v126 = __nwlog_obj();
    v127 = type;
    v138 = os_log_type_enabled(v126, type);
    if (v137)
    {
      if (v138)
      {
        *(_DWORD *)buf = 136446466;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = v137;
        _os_log_impl(&dword_182FBE000, v126, v127, "%{public}s called with null apply_block, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v137);
      if (!v3)
        return;
      goto LABEL_165;
    }
    if (v138)
    {
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v128 = "%{public}s called with null apply_block, no backtrace";
LABEL_208:
      _os_log_impl(&dword_182FBE000, v126, v127, v128, buf, 0xCu);
      goto LABEL_209;
    }
    goto LABEL_209;
  }
  v3 = a1;
  if (*((_DWORD *)a1 + 8))
  {
    v4 = *((_DWORD *)a1 + 12);
    if ((v4 & 2) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v129 = __nwlog_obj();
  os_log_type_enabled(v129, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v147 = "nw_hash_table_lock";
  v130 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v130))
  {
LABEL_218:
    __break(1u);
    return;
  }
  free(v130);
  v4 = *((_DWORD *)v3 + 12);
  if ((v4 & 2) != 0)
  {
LABEL_5:
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 13);
    v4 = *((_DWORD *)v3 + 12);
  }
LABEL_6:
  if ((v4 & 1) != 0)
  {
    v5 = *((unsigned int *)v3 + 11) + 1;
    v6 = v5 << 31 >> 31;
    *((_DWORD *)v3 + 11) = v5;
    if (v6 == v5 && (v6 & 0x8000000000000000) == 0)
    {
      if (!*((_DWORD *)v3 + 8))
        goto LABEL_139;
LABEL_27:
      v21 = 0;
      v22 = v3 + 56;
      lock = (os_unfair_lock_s *)(v3 + 52);
      while (1)
      {
        v141 = v21;
        v23 = (uint64_t *)*v22;
        if (*v22)
          break;
LABEL_28:
        v21 = v141 + 1;
        v22 += 2;
        if ((v141 + 1) >= *((_DWORD *)v3 + 8))
          goto LABEL_138;
      }
      v143 = v22;
      while (1)
      {
        v24 = v23;
        v23 = (uint64_t *)*v23;
        v25 = (uint64_t **)v24[1];
        if (!v25 || *v25 != v24)
        {
          v101 = __nwlog_obj();
          os_log_type_enabled(v101, OS_LOG_TYPE_ERROR);
          v102 = *((unsigned __int8 *)v24 + 30);
          v103 = "invalid_state";
          if (v102 <= 3)
            v103 = off_1E14A86D0[v102];
          v104 = *((unsigned __int16 *)v24 + 14);
          *(_DWORD *)buf = 136446722;
          v147 = "nw_hash_table_apply";
          v148 = 2082;
          v149 = v103;
          v150 = 1024;
          LODWORD(v151) = v104;
          v105 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort((uint64_t)v105))
            goto LABEL_218;
          free(v105);
        }
        v26 = *((unsigned __int8 *)v24 + 30);
        if (v26 != 1)
        {
          if (v26 == 2)
          {
            if (*((_WORD *)v24 + 14))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v36 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446210;
                v147 = "nw_hash_table_apply";
                _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s Ignoring temp node remove", buf, 0xCu);
              }
            }
            else
            {
              nw_hash_node_free((uint64_t)v22, v24);
            }
          }
          else
          {
            v106 = __nwlog_obj();
            os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
            v107 = *((unsigned __int8 *)v24 + 30);
            v108 = "invalid_state";
            if (v107 <= 3)
              v108 = off_1E14A86D0[v107];
            v109 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446722;
            v147 = "nw_hash_table_apply";
            v148 = 2082;
            v149 = v108;
            v150 = 1024;
            LODWORD(v151) = v109;
            v110 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort((uint64_t)v110))
              goto LABEL_218;
            free(v110);
          }
          goto LABEL_32;
        }
        v27 = (unsigned __int16)(*((_WORD *)v24 + 14))++ + 1;
        if ((v27 & 0x10000) != 0)
          break;
LABEL_59:
        if (!v23)
          goto LABEL_78;
        v46 = (unsigned __int16)(*((_WORD *)v23 + 14))++ + 1;
        if ((v46 & 0x10000) == 0)
          goto LABEL_78;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v47 = *((unsigned __int16 *)v23 + 14);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "next_node->apply_count";
        v150 = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v47;
        v48 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v144 = 0;
        if (__nwlog_fault(v48, &type, &v144))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v49 = gLogObj;
            v50 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v51 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "next_node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v51;
              v52 = v49;
              v53 = v50;
              v54 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_74:
              _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0x2Au);
            }
          }
          else if (v144)
          {
            v55 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v56 = gLogObj;
            v57 = type;
            v58 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v55)
            {
              if (v58)
              {
                v59 = *((unsigned __int16 *)v23 + 14);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                v148 = 2082;
                v149 = "next_node->apply_count";
                v150 = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v59;
                v154 = 2082;
                v155 = v55;
                _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v55);
              goto LABEL_75;
            }
            if (v58)
            {
              v63 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "next_node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v63;
              v52 = v56;
              v53 = v57;
              v54 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_74;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v60 = gLogObj;
            v61 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v62 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "next_node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v62;
              v52 = v60;
              v53 = v61;
              v54 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_74;
            }
          }
        }
LABEL_75:
        if (v48)
          free(v48);
        *((_WORD *)v23 + 14) = -1;
        v22 = v143;
LABEL_78:
        if ((v3[48] & 2) != 0)
          os_unfair_lock_unlock(lock);
        v64 = (*(uint64_t (**)(uint64_t, uint64_t *))(a2 + 16))(a2, v24);
        if (*((_DWORD *)v3 + 8))
        {
          if ((v3[48] & 2) == 0)
            goto LABEL_83;
LABEL_82:
          os_unfair_lock_lock(lock);
          goto LABEL_83;
        }
        v111 = __nwlog_obj();
        os_log_type_enabled(v111, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v147 = "nw_hash_table_lock";
        v112 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort((uint64_t)v112))
          goto LABEL_218;
        free(v112);
        if ((v3[48] & 2) != 0)
          goto LABEL_82;
LABEL_83:
        v65 = (unsigned __int16)(*((_WORD *)v24 + 14))-- - 1;
        if (v65 < 0x10000)
          goto LABEL_101;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v66 = *((unsigned __int16 *)v24 + 14);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "node->apply_count";
        v150 = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v66;
        v67 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v144 = 0;
        if (__nwlog_fault(v67, &type, &v144))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v68 = gLogObj;
            v69 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v70 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v70;
              v71 = v68;
              v72 = v69;
              v73 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_97:
              _os_log_impl(&dword_182FBE000, v71, v72, v73, buf, 0x2Au);
            }
          }
          else if (v144)
          {
            v74 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v75 = gLogObj;
            v76 = type;
            v77 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v74)
            {
              if (v77)
              {
                v78 = *((unsigned __int16 *)v24 + 14);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                v148 = 2082;
                v149 = "node->apply_count";
                v150 = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v78;
                v154 = 2082;
                v155 = v74;
                _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v74);
              goto LABEL_98;
            }
            if (v77)
            {
              v82 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v82;
              v71 = v75;
              v72 = v76;
              v73 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_97;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v79 = gLogObj;
            v80 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v81 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v81;
              v71 = v79;
              v72 = v80;
              v73 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_97;
            }
          }
        }
LABEL_98:
        if (v67)
          free(v67);
        *((_WORD *)v24 + 14) = 0;
        v22 = v143;
LABEL_101:
        if (!v23)
          goto LABEL_120;
        v83 = (unsigned __int16)(*((_WORD *)v23 + 14))-- - 1;
        if (v83 < 0x10000)
          goto LABEL_120;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v84 = *((unsigned __int16 *)v23 + 14);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "next_node->apply_count";
        v150 = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v84;
        v85 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v144 = 0;
        if (__nwlog_fault(v85, &type, &v144))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v86 = gLogObj;
            v87 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v88 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "next_node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v88;
              v89 = v86;
              v90 = v87;
              v91 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_116:
              _os_log_impl(&dword_182FBE000, v89, v90, v91, buf, 0x2Au);
            }
          }
          else if (v144)
          {
            v92 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v93 = gLogObj;
            v94 = type;
            v95 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v92)
            {
              if (v95)
              {
                v96 = *((unsigned __int16 *)v23 + 14);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                v148 = 2082;
                v149 = "next_node->apply_count";
                v150 = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v96;
                v154 = 2082;
                v155 = v92;
                _os_log_impl(&dword_182FBE000, v93, v94, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v92);
              goto LABEL_117;
            }
            if (v95)
            {
              v100 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "next_node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v100;
              v89 = v93;
              v90 = v94;
              v91 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_116;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v97 = gLogObj;
            v98 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v99 = *((unsigned __int16 *)v23 + 14);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "next_node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v99;
              v89 = v97;
              v90 = v98;
              v91 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_116;
            }
          }
        }
LABEL_117:
        if (v85)
          free(v85);
        *((_WORD *)v23 + 14) = 0;
        v22 = v143;
LABEL_120:
        if (*((_BYTE *)v24 + 30) == 2 && !*((_WORD *)v24 + 14))
          nw_hash_node_free((uint64_t)v22, v24);
        if ((v64 & 1) == 0)
        {
          if (v23 && *((_BYTE *)v23 + 30) == 2 && !*((_WORD *)v23 + 14))
            nw_hash_node_free((uint64_t)v22, v23);
LABEL_138:
          LODWORD(v5) = *((_DWORD *)v3 + 11);
LABEL_139:
          *((_DWORD *)v3 + 11) = v5 - 1;
          if ((_DWORD)v5)
          {
            v113 = *((_DWORD *)v3 + 12);
            if ((_DWORD)v5 != 1)
            {
              if ((v113 & 2) != 0)
                goto LABEL_142;
              return;
            }
LABEL_162:
            if ((v113 & 2) != 0)
              os_unfair_lock_unlock((os_unfair_lock_t)v3 + 13);
            if ((v113 & 1) != 0)
              return;
LABEL_165:
            free(v3);
            return;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v114 = *((unsigned int *)v3 + 11);
          *(_DWORD *)buf = 136446978;
          v147 = "nw_hash_table_apply";
          v148 = 2082;
          v149 = "table->apply_count";
          v150 = 2048;
          v151 = 1;
          v152 = 2048;
          v153 = v114;
          v115 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v144 = 0;
          if (!__nwlog_fault(v115, &type, &v144))
            goto LABEL_159;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v116 = gLogObj;
            v117 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              v118 = *((unsigned int *)v3 + 11);
              *(_DWORD *)buf = 136446978;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "table->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v118;
              v119 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
              goto LABEL_158;
            }
            goto LABEL_159;
          }
          if (v144)
          {
            v120 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v116 = gLogObj;
            v117 = type;
            v121 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v120)
            {
              if (v121)
              {
                v122 = *((unsigned int *)v3 + 11);
                *(_DWORD *)buf = 136447234;
                v147 = "nw_hash_table_apply";
                v148 = 2082;
                v149 = "table->apply_count";
                v150 = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v122;
                v154 = 2082;
                v155 = v120;
                _os_log_impl(&dword_182FBE000, v116, v117, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v120);
              goto LABEL_159;
            }
            if (!v121)
            {
LABEL_159:
              if (v115)
                free(v115);
              *((_DWORD *)v3 + 11) = 0;
              v113 = *((_DWORD *)v3 + 12);
              goto LABEL_162;
            }
            v125 = *((unsigned int *)v3 + 11);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            v148 = 2082;
            v149 = "table->apply_count";
            v150 = 2048;
            v151 = 1;
            v152 = 2048;
            v153 = v125;
            v119 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v116 = gLogObj;
            v117 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type))
              goto LABEL_159;
            v123 = *((unsigned int *)v3 + 11);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            v148 = 2082;
            v149 = "table->apply_count";
            v150 = 2048;
            v151 = 1;
            v152 = 2048;
            v153 = v123;
            v119 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          }
LABEL_158:
          _os_log_impl(&dword_182FBE000, v116, v117, v119, buf, 0x2Au);
          goto LABEL_159;
        }
LABEL_32:
        if (!v23)
          goto LABEL_28;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = *((unsigned __int16 *)v24 + 14);
      *(_DWORD *)buf = 136446978;
      v147 = "nw_hash_table_apply";
      v148 = 2082;
      v149 = "node->apply_count";
      v150 = 2048;
      v151 = 1;
      v152 = 2048;
      v153 = v28;
      v29 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v144 = 0;
      if (__nwlog_fault(v29, &type, &v144))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v30 = gLogObj;
          v31 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            v32 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            v148 = 2082;
            v149 = "node->apply_count";
            v150 = 2048;
            v151 = 1;
            v152 = 2048;
            v153 = v32;
            v33 = v30;
            v34 = v31;
            v35 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_55:
            _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0x2Au);
          }
        }
        else if (v144)
        {
          v37 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = gLogObj;
          v39 = type;
          v40 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v37)
          {
            if (v40)
            {
              v41 = *((unsigned __int16 *)v24 + 14);
              *(_DWORD *)buf = 136447234;
              v147 = "nw_hash_table_apply";
              v148 = 2082;
              v149 = "node->apply_count";
              v150 = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v41;
              v154 = 2082;
              v155 = v37;
              _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v37);
            goto LABEL_56;
          }
          if (v40)
          {
            v45 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            v148 = 2082;
            v149 = "node->apply_count";
            v150 = 2048;
            v151 = 1;
            v152 = 2048;
            v153 = v45;
            v33 = v38;
            v34 = v39;
            v35 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_55;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v42 = gLogObj;
          v43 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            v44 = *((unsigned __int16 *)v24 + 14);
            *(_DWORD *)buf = 136446978;
            v147 = "nw_hash_table_apply";
            v148 = 2082;
            v149 = "node->apply_count";
            v150 = 2048;
            v151 = 1;
            v152 = 2048;
            v153 = v44;
            v33 = v42;
            v34 = v43;
            v35 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_55;
          }
        }
      }
LABEL_56:
      if (v29)
        free(v29);
      *((_WORD *)v24 + 14) = -1;
      v22 = v143;
      goto LABEL_59;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = *((unsigned int *)v3 + 11);
    *(_DWORD *)buf = 136446978;
    v147 = "nw_hash_table_apply";
    v148 = 2082;
    v149 = "table->apply_count";
    v150 = 2048;
    v151 = 1;
    v152 = 2048;
    v153 = v7;
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v144 = 0;
    if (__nwlog_fault(v8, &type, &v144))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_24;
        v11 = *((unsigned int *)v3 + 11);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "table->apply_count";
        v150 = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v11;
        v12 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_22:
        v19 = v9;
        v20 = v10;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v19, v20, v12, buf, 0x2Au);
        goto LABEL_24;
      }
      if (!v144)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_24;
        v18 = *((unsigned int *)v3 + 11);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "table->apply_count";
        v150 = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v18;
        v12 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_22;
      }
      v13 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      v16 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v13)
      {
        if (v16)
        {
          v17 = *((unsigned int *)v3 + 11);
          *(_DWORD *)buf = 136447234;
          v147 = "nw_hash_table_apply";
          v148 = 2082;
          v149 = "table->apply_count";
          v150 = 2048;
          v151 = 1;
          v152 = 2048;
          v153 = v17;
          v154 = 2082;
          v155 = v13;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v13);
      }
      else if (v16)
      {
        v124 = *((unsigned int *)v3 + 11);
        *(_DWORD *)buf = 136446978;
        v147 = "nw_hash_table_apply";
        v148 = 2082;
        v149 = "table->apply_count";
        v150 = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v124;
        v12 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        v19 = v14;
        v20 = v15;
        goto LABEL_23;
      }
    }
LABEL_24:
    if (v8)
      free(v8);
    LODWORD(v5) = -1;
    *((_DWORD *)v3 + 11) = -1;
    if (!*((_DWORD *)v3 + 8))
      goto LABEL_139;
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v147 = "nw_hash_table_apply";
  v131 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v144 = 0;
  if (__nwlog_fault(v131, &type, &v144))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v132 = __nwlog_obj();
      v133 = type;
      if (!os_log_type_enabled(v132, type))
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v134 = "%{public}s called with invalid hash table";
LABEL_213:
      _os_log_impl(&dword_182FBE000, v132, v133, v134, buf, 0xCu);
      goto LABEL_214;
    }
    if (!v144)
    {
      v132 = __nwlog_obj();
      v133 = type;
      if (!os_log_type_enabled(v132, type))
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v134 = "%{public}s called with invalid hash table, backtrace limit exceeded";
      goto LABEL_213;
    }
    v139 = (char *)__nw_create_backtrace_string();
    v132 = __nwlog_obj();
    v133 = type;
    v140 = os_log_type_enabled(v132, type);
    if (!v139)
    {
      if (!v140)
        goto LABEL_214;
      *(_DWORD *)buf = 136446210;
      v147 = "nw_hash_table_apply";
      v134 = "%{public}s called with invalid hash table, no backtrace";
      goto LABEL_213;
    }
    if (v140)
    {
      *(_DWORD *)buf = 136446466;
      v147 = "nw_hash_table_apply";
      v148 = 2082;
      v149 = v139;
      _os_log_impl(&dword_182FBE000, v132, v133, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v139);
  }
LABEL_214:
  if (v131)
    free(v131);
  if ((v3[48] & 2) != 0)
LABEL_142:
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 13);
}

uint64_t nw_hash_node_get_extra(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return a1 + 32;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_hash_node_get_extra";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_extra";
        v5 = "%{public}s called with null node";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_hash_node_get_extra";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null node, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_extra";
        v5 = "%{public}s called with null node, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_extra";
        v5 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

uint64_t nw_hash_node_get_object(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_QWORD *)(a1 + 16);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_hash_node_get_object";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_object";
        v5 = "%{public}s called with null node";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_hash_node_get_object";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null node, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_object";
        v5 = "%{public}s called with null node, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_hash_node_get_object";
        v5 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

BOOL nw_hash_table_get_some_node(os_unfair_lock_s *a1)
{
  uint32_t os_unfair_lock_opaque;
  uint32_t v3;
  int v4;
  os_unfair_lock_s *v5;
  os_unfair_lock_s *v6;
  _BOOL8 result;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  char *backtrace_string;
  _BOOL4 v19;
  char *v20;
  _BOOL4 v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_hash_table_get_some_node";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_hash_table_get_some_node";
      v11 = "%{public}s called with null table";
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v19 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_hash_table_get_some_node";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_45;
      }
      if (!v19)
      {
LABEL_45:
        if (v8)
          free(v8);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v25 = "nw_hash_table_get_some_node";
      v11 = "%{public}s called with null table, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_hash_table_get_some_node";
      v11 = "%{public}s called with null table, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_45;
  }
  if (a1[8]._os_unfair_lock_opaque)
  {
    os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 2) == 0)
      goto LABEL_5;
    goto LABEL_4;
  }
  v12 = __nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v25 = "nw_hash_table_lock";
  v13 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 2) == 0)
    {
LABEL_5:
      if ((os_unfair_lock_opaque & 1) != 0)
      {
        v3 = a1[8]._os_unfair_lock_opaque;
        if (v3)
        {
          v4 = 0;
          v5 = a1 + 14;
          do
          {
            v6 = v5;
            while (1)
            {
              v6 = *(os_unfair_lock_s **)&v6->_os_unfair_lock_opaque;
              if (!v6)
                break;
              if (BYTE2(v6[7]._os_unfair_lock_opaque) == 1)
                goto LABEL_14;
            }
            ++v4;
            v5 += 4;
          }
          while (v4 != v3);
        }
        v6 = 0;
LABEL_14:
        if ((os_unfair_lock_opaque & 2) != 0)
          os_unfair_lock_unlock(a1 + 13);
        return (BOOL)v6;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v25 = "nw_hash_table_get_some_node";
      v14 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v22 = 0;
      if (__nwlog_fault(v14, &type, &v22))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v15 = __nwlog_obj();
          v16 = type;
          if (!os_log_type_enabled(v15, type))
            goto LABEL_50;
          *(_DWORD *)buf = 136446210;
          v25 = "nw_hash_table_get_some_node";
          v17 = "%{public}s called with invalid hash table";
LABEL_49:
          _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
          goto LABEL_50;
        }
        if (!v22)
        {
          v15 = __nwlog_obj();
          v16 = type;
          if (!os_log_type_enabled(v15, type))
            goto LABEL_50;
          *(_DWORD *)buf = 136446210;
          v25 = "nw_hash_table_get_some_node";
          v17 = "%{public}s called with invalid hash table, backtrace limit exceeded";
          goto LABEL_49;
        }
        v20 = (char *)__nw_create_backtrace_string();
        v15 = __nwlog_obj();
        v16 = type;
        v21 = os_log_type_enabled(v15, type);
        if (!v20)
        {
          if (!v21)
            goto LABEL_50;
          *(_DWORD *)buf = 136446210;
          v25 = "nw_hash_table_get_some_node";
          v17 = "%{public}s called with invalid hash table, no backtrace";
          goto LABEL_49;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_hash_table_get_some_node";
          v26 = 2082;
          v27 = v20;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v20);
      }
LABEL_50:
      if (v14)
        free(v14);
      if ((a1[12]._os_unfair_lock_opaque & 2) != 0)
      {
        os_unfair_lock_unlock(a1 + 13);
        return 0;
      }
      return 0;
    }
LABEL_4:
    os_unfair_lock_lock(a1 + 13);
    os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

BOOL nw_endpoint_association_matches_key(void *a1, void *a2)
{
  void *v3;
  id v4;
  _BOOL8 v5;

  v3 = a2;
  v4 = nw_association_copy_path_parameters(a1);
  v5 = nw_path_parameters_are_equal(v4, v3, 1u);

  return v5;
}

void sub_18300B45C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_association_copy_path_parameters(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_association_copy_path_parameters";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_association_copy_path_parameters";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_association_copy_path_parameters";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_association_copy_path_parameters";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_association_copy_path_parameters";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_path_parameters_are_equal(void *a1, void *a2, unsigned int a3)
{
  char *v5;
  char *v6;
  _QWORD *v7;
  _BOOL8 v8;
  void *v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  BOOL v26;
  const char *v29;
  const char *v30;
  const char *v31;
  const char *v32;
  void *v33;
  void *v34;
  xpc_object_t *v35;
  xpc_object_t *v36;

  v5 = a1;
  v6 = a2;
  v7 = v6;
  v8 = v5 == v6;
  if (v5 != v6 && v5 && v6)
  {
    if (*((_QWORD *)v5 + 9) != *((_QWORD *)v6 + 9)
      || *((_QWORD *)v5 + 10) != *((_QWORD *)v6 + 10)
      || *((_QWORD *)v5 + 11) != *((_QWORD *)v6 + 11)
      || *(_QWORD *)(v5 + 94) != *(_QWORD *)(v6 + 94))
    {
      goto LABEL_14;
    }
    if (a3 != 3)
    {
      v16 = *((_QWORD *)v6 + 1);
      v17 = *((_QWORD *)v6 + 2);
      v18 = *((_QWORD *)v6 + 3);
      v19 = *((_QWORD *)v6 + 4);
      v20 = *((_QWORD *)v6 + 5);
      v21 = *((_QWORD *)v5 + 1) == v16 && *((_QWORD *)v5 + 2) == v17;
      v22 = v21 && *((_QWORD *)v5 + 3) == v18;
      v23 = v22 && *((_QWORD *)v5 + 4) == v19;
      v24 = v23 && *((_QWORD *)v5 + 5) == v20;
      v25 = v24 && *((_QWORD *)v5 + 6) == v7[6];
      v26 = v25 && *((_QWORD *)v5 + 7) == v7[7];
      if (!v26 || *((_QWORD *)v5 + 8) != v7[8])
        goto LABEL_14;
      if (a3 <= 1
        && (*(_QWORD *)(v5 + 102) != *(_QWORD *)((char *)v7 + 102)
         || v5[110] != (unint64_t)*((unsigned __int8 *)v7 + 110)))
      {
        goto LABEL_14;
      }
    }
    if (!nw_context_shares_workloop(*((void **)v5 + 17), (void *)v7[17]))
      goto LABEL_14;
    if (a3 - 5 < 0xFFFFFFFE
      || ((*((unsigned __int16 *)v5 + 54) | (v5[110] << 16)) & 0x20000) != 0
      || ((*((unsigned __int16 *)v7 + 54) | (*((unsigned __int8 *)v7 + 110) << 16)) & 0x20000) != 0)
    {
      v13 = (void *)*((_QWORD *)v5 + 17);
      if (v13 != (void *)v7[17]
        && (nw_context_get_isolate_protocol_cache(v13) || nw_context_get_isolate_protocol_cache((void *)v7[17])))
      {
        goto LABEL_14;
      }
    }
    v14 = (const char *)*((_QWORD *)v5 + 14);
    v15 = (const char *)v7[14];
    if (v14 != v15 && v14 && v15)
    {
      if (strcmp(v14, v15))
        goto LABEL_14;
    }
    else if (v14 != v15)
    {
      goto LABEL_14;
    }
    if (a3 <= 2)
    {
      v29 = (const char *)*((_QWORD *)v5 + 15);
      v30 = (const char *)v7[15];
      if (v29 != v30 && v29 && v30)
      {
        if (strcmp(v29, v30))
          goto LABEL_14;
      }
      else if (v29 != v30)
      {
        goto LABEL_14;
      }
      v31 = (const char *)*((_QWORD *)v5 + 16);
      v32 = (const char *)v7[16];
      if (v31 != v32 && v31 && v32)
      {
        if (strcmp(v31, v32))
          goto LABEL_14;
      }
      else if (v31 != v32)
      {
        goto LABEL_14;
      }
    }
    if (nw_protocol_option_is_equal(*((void **)v5 + 18), (void *)v7[18])
      && nw_protocol_option_is_equal(*((void **)v5 + 19), (void *)v7[19]))
    {
      v33 = (void *)*((_QWORD *)v5 + 20);
      if (a3)
      {
        if (!v33 || (v34 = (void *)v7[20]) == 0 || (nw_endpoint_is_equal(v33, v34, 0) & 1) != 0)
        {
LABEL_81:
          if (nw_interface_shallow_compare(*((void **)v5 + 21), (void *)v7[21]))
          {
            v35 = (xpc_object_t *)*((_QWORD *)v5 + 22);
            v36 = (xpc_object_t *)v7[22];
            if (v35)
            {
              if (v36
                && nw_unordered_xpc_array_is_equal(*v35, *v36)
                && nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 8), *(xpc_object_t *)(v7[22] + 8))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 16), *(xpc_object_t *)(v7[22] + 16))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 24), *(xpc_object_t *)(v7[22] + 24))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 32), *(xpc_object_t *)(v7[22] + 32))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 40), *(xpc_object_t *)(v7[22] + 40))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 48), *(xpc_object_t *)(v7[22] + 48))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 56),
                                   *(xpc_object_t *)(v7[22] + 56))
                && nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 64), *(xpc_object_t *)(v7[22] + 64))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 72), *(xpc_object_t *)(v7[22] + 72))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 80), *(xpc_object_t *)(v7[22] + 80))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 88), *(xpc_object_t *)(v7[22] + 88))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 96), *(xpc_object_t *)(v7[22] + 96))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 104), *(xpc_object_t *)(v7[22] + 104))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 112),
                                   *(xpc_object_t *)(v7[22] + 112))
                && nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 120), *(xpc_object_t *)(v7[22] + 120))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((_QWORD *)v5 + 22) + 136), *(xpc_object_t *)(v7[22] + 136))&& nw_protocol_option_is_equal(*(void **)(*((_QWORD *)v5 + 22) + 128), *(void **)(v7[22] + 128)))
              {
                goto LABEL_104;
              }
            }
            else if (!v36)
            {
LABEL_104:
              v8 = 1;
              goto LABEL_15;
            }
          }
        }
      }
      else if (nw_endpoint_is_equal(v33, (void *)v7[20], 0))
      {
        goto LABEL_81;
      }
    }
LABEL_14:
    v8 = 0;
  }
LABEL_15:

  return v8;
}

void sub_18300BB2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_option_is_equal(void *a1, void *a2)
{
  void **v3;
  void **v4;
  void **v5;
  uint64_t v6;
  void *v7;
  id v8;
  id v9;
  void *v10;
  _BOOL4 v11;
  void *v12;
  uint64_t (*v13)(void);

  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3 == v4)
    goto LABEL_17;
  v6 = 0;
  if (v3 && v4)
  {
    if (nw_endpoint_is_equal(v3[3], v4[3], 0)
      && *((unsigned __int8 *)v3 + 152) == *((unsigned __int8 *)v5 + 152)
      && nw_protocol_definition_is_equal_unsafe((uint64_t)v3[1], (uint64_t)v5[1]))
    {
      v7 = v5[5];
      v8 = v3[5];
      v9 = v7;
      v10 = v9;
      v11 = v8 == v9;
      if (v8 != v9 && v8 && v9)
        v11 = xpc_equal(v8, v9);

      if (v11)
      {
        v12 = v3[1];
        v13 = (uint64_t (*)(void))*((_QWORD *)v12 + 15);
        if (v13 || (v13 = (uint64_t (*)(void))*((_QWORD *)v12 + 14)) != 0)
        {
          v6 = v13();
          goto LABEL_18;
        }
LABEL_17:
        v6 = 1;
        goto LABEL_18;
      }
    }
    v6 = 0;
  }
LABEL_18:

  return v6;
}

void sub_18300BC64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_is_equal(void *a1, void *a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  int v9;

  v5 = a1;
  v6 = a2;
  v7 = (void *)v6;
  if (v5 | v6)
  {
    v8 = 0;
    if (v5 && v6)
    {
      v9 = objc_msgSend((id)v5, "type");
      if ((v9 - 1) < 4 || v9 == 6)
        v8 = objc_msgSend((id)v5, "isEqualToEndpoint:matchFlags:", v7, a3);
      else
        v8 = 0;
    }
  }
  else
  {
    v8 = 1;
  }

  return v8;
}

void sub_18300BD28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_18300BDDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18300BF90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_instance_enumerate_flows_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  char *v5;
  void **v6;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  BOOL v11;
  const char *v12;
  const char *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  const char *v20;
  void *v21;
  uint64_t v22;
  BOOL v23;
  const char *v24;
  const char *v25;
  NSObject *v26;
  os_log_type_t v27;
  uint64_t v28;
  BOOL v29;
  const char *v30;
  const char *v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  uint64_t v35;
  BOOL v36;
  const char *v37;
  const char *v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  uint64_t v42;
  BOOL v43;
  const char *v44;
  const char *v45;
  os_log_type_t v46;
  uint64_t v47;
  BOOL v48;
  const char *v49;
  const char *v50;
  os_log_type_t v51;
  uint64_t v52;
  BOOL v53;
  const char *v54;
  const char *v55;
  uint64_t v56;
  BOOL v57;
  const char *v58;
  const char *v59;
  uint64_t v60;
  const char *v61;
  BOOL v62;
  const char *v63;
  char v64;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  char *v73;
  __int16 v74;
  char *v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v8 = *(_QWORD *)(a1 + 32);
    if (v8 && *(char *)(v8 + 405) < 0)
      return 1;
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = *(_QWORD *)(a1 + 32);
    v11 = v10 == 0;
    if (v10)
      v12 = (const char *)(v10 + 407);
    else
      v12 = "";
    *(_DWORD *)buf = 136446722;
    v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
    if (v11)
      v13 = "";
    else
      v13 = " ";
    v68 = 2082;
    v69 = v12;
    v70 = 2080;
    v71 = v13;
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v64 = 0;
    if (__nwlog_fault(v14, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          v17 = *(_QWORD *)(a1 + 32);
          v18 = v17 == 0;
          if (v17)
            v19 = (const char *)(v17 + 407);
          else
            v19 = "";
          *(_DWORD *)buf = 136446722;
          if (v18)
            v20 = "";
          else
            v20 = " ";
          v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          v68 = 2082;
          v69 = v19;
          v70 = 2080;
          v71 = v20;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s %{public}s%sNull node while enumerating flows", buf, 0x20u);
        }
      }
      else if (v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        v34 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v34)
          {
            v35 = *(_QWORD *)(a1 + 32);
            v36 = v35 == 0;
            if (v35)
              v37 = (const char *)(v35 + 407);
            else
              v37 = "";
            if (v36)
              v38 = "";
            else
              v38 = " ";
            *(_DWORD *)buf = 136446978;
            v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
            v68 = 2082;
            v69 = v37;
            v70 = 2080;
            v71 = v38;
            v72 = 2082;
            v73 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v15, v33, "%{public}s %{public}s%sNull node while enumerating flows, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(backtrace_string);
          goto LABEL_104;
        }
        if (v34)
        {
          v56 = *(_QWORD *)(a1 + 32);
          v57 = v56 == 0;
          if (v56)
            v58 = (const char *)(v56 + 407);
          else
            v58 = "";
          *(_DWORD *)buf = 136446722;
          if (v57)
            v59 = "";
          else
            v59 = " ";
          v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          v68 = 2082;
          v69 = v58;
          v70 = 2080;
          v71 = v59;
          _os_log_impl(&dword_182FBE000, v15, v33, "%{public}s %{public}s%sNull node while enumerating flows, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        if (os_log_type_enabled(v15, type))
        {
          v47 = *(_QWORD *)(a1 + 32);
          v48 = v47 == 0;
          if (v47)
            v49 = (const char *)(v47 + 407);
          else
            v49 = "";
          *(_DWORD *)buf = 136446722;
          if (v48)
            v50 = "";
          else
            v50 = " ";
          v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          v68 = 2082;
          v69 = v49;
          v70 = 2080;
          v71 = v50;
          _os_log_impl(&dword_182FBE000, v15, v46, "%{public}s %{public}s%sNull node while enumerating flows, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
LABEL_104:
    if (!v14)
      return 1;
LABEL_105:
    free(v14);
    return 1;
  }
  v4 = *(void **)(a2 + 16);
  v5 = *(char **)(a1 + 32);
  if (!v4)
  {
    if (v5 && v5[405] < 0)
      return 1;
    __nwlog_obj();
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = *(_QWORD *)(a1 + 32);
    v23 = v22 == 0;
    if (v22)
      v24 = (const char *)(v22 + 407);
    else
      v24 = "";
    *(_DWORD *)buf = 136446978;
    v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
    v68 = 2082;
    v69 = v24;
    if (v23)
      v25 = "";
    else
      v25 = " ";
    v70 = 2080;
    v71 = v25;
    v72 = 2048;
    v73 = (char *)a2;
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v64 = 0;
    if (__nwlog_fault(v14, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          v28 = *(_QWORD *)(a1 + 32);
          v29 = v28 == 0;
          if (v28)
            v30 = (const char *)(v28 + 407);
          else
            v30 = "";
          *(_DWORD *)buf = 136446978;
          if (v29)
            v31 = "";
          else
            v31 = " ";
          v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          v68 = 2082;
          v69 = v30;
          v70 = 2080;
          v71 = v31;
          v72 = 2048;
          v73 = (char *)a2;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s %{public}s%sNull protocol in node %p", buf, 0x2Au);
        }
      }
      else if (v64)
      {
        v39 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v40 = type;
        v41 = os_log_type_enabled(v26, type);
        if (v39)
        {
          if (v41)
          {
            v42 = *(_QWORD *)(a1 + 32);
            v43 = v42 == 0;
            if (v42)
              v44 = (const char *)(v42 + 407);
            else
              v44 = "";
            if (v43)
              v45 = "";
            else
              v45 = " ";
            *(_DWORD *)buf = 136447234;
            v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
            v68 = 2082;
            v69 = v44;
            v70 = 2080;
            v71 = v45;
            v72 = 2048;
            v73 = (char *)a2;
            v74 = 2082;
            v75 = v39;
            _os_log_impl(&dword_182FBE000, v26, v40, "%{public}s %{public}s%sNull protocol in node %p, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(v39);
          if (!v14)
            return 1;
          goto LABEL_105;
        }
        if (v41)
        {
          v60 = *(_QWORD *)(a1 + 32);
          v61 = (const char *)(v60 + 407);
          v62 = v60 == 0;
          v63 = "";
          if (v62)
            v61 = "";
          *(_DWORD *)buf = 136446978;
          if (!v62)
            v63 = " ";
          v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          v68 = 2082;
          v69 = v61;
          v70 = 2080;
          v71 = v63;
          v72 = 2048;
          v73 = (char *)a2;
          _os_log_impl(&dword_182FBE000, v26, v40, "%{public}s %{public}s%sNull protocol in node %p, no backtrace", buf, 0x2Au);
        }
      }
      else
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v51 = type;
        if (os_log_type_enabled(v26, type))
        {
          v52 = *(_QWORD *)(a1 + 32);
          v53 = v52 == 0;
          if (v52)
            v54 = (const char *)(v52 + 407);
          else
            v54 = "";
          *(_DWORD *)buf = 136446978;
          if (v53)
            v55 = "";
          else
            v55 = " ";
          v67 = "nw_protocol_instance_enumerate_flows_block_invoke";
          v68 = 2082;
          v69 = v54;
          v70 = 2080;
          v71 = v55;
          v72 = 2048;
          v73 = (char *)a2;
          _os_log_impl(&dword_182FBE000, v26, v51, "%{public}s %{public}s%sNull protocol in node %p, backtrace limit exceeded", buf, 0x2Au);
        }
      }

    }
    goto LABEL_104;
  }
  v6 = v5;
  if (nw_protocol_definition_get_message_is_stream(v6[1]) && *(v6 - 6) == v4)
  {

  }
  else
  {

    if (v4 != (void *)-2)
      return (*(uint64_t (**)(_QWORD, void *, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v4, *(_QWORD *)(a2 + 32));
  }
  return 1;
}

uint64_t nw_protocol_definition_get_message_is_stream(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[184] >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_get_message_is_stream";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_get_message_is_stream";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_get_message_is_stream";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_get_message_is_stream";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_get_message_is_stream";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_context_shares_workloop(void *a1, void *a2)
{
  NWConcrete_nw_context *v3;
  NWConcrete_nw_context *v4;
  NWConcrete_nw_context *v5;
  void *v6;
  void *v7;
  _BOOL8 v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      v6 = (void *)nw_context_copy_globals_context(v3);
      v7 = (void *)nw_context_copy_globals_context(v5);
      v8 = v6 == v7;

      goto LABEL_4;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_context_shares_workloop";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null other", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null other, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null other, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_context_shares_workloop";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null other, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_context_shares_workloop";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null context", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_context_shares_workloop";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v11)
    free(v11);
  v8 = 0;
LABEL_4:

  return v8;
}

void sub_18300CE40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

BOOL nw_interface_shallow_compare(void *a1, void *a2)
{
  char *v3;
  const char *v4;
  char *v5;
  _BOOL8 v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v3 = a1;
  v4 = a2;
  v5 = (char *)v4;
  v6 = v3 == v4;
  if (v3 != v4 && v3 && v4)
  {
    v7 = *((_DWORD *)v4 + 24);
    v6 = (!v7 || (v8 = *((_DWORD *)v3 + 24)) == 0 || v8 == v7)
      && ((v9 = *((_DWORD *)v4 + 25)) == 0 || (v10 = *((_DWORD *)v3 + 25)) == 0 || v10 == v9)
      && *((_DWORD *)v3 + 2) == *((_DWORD *)v4 + 2)
      && strncmp(v3 + 104, v4 + 104, 0x19uLL) == 0;
  }

  return v6;
}

uint64_t __nw_protocol_instance_report_ready_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t extra;
  __int16 v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  nw_protocol *object;
  char *v10;
  nw_protocol *v11;
  NWConcrete_nw_protocol_instance *v12;
  unint64_t v13;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  const char *v20;
  int v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  extra = nw_hash_node_get_extra(a2);
  v5 = *(_WORD *)(extra + 52);
  if ((v5 & 0x10) == 0)
  {
    v6 = extra;
    v7 = v5 | 0x10;
    *(_WORD *)(extra + 52) = v5 | 0x10;
    if ((v5 & 4) != 0)
    {
      object = (nw_protocol *)nw_hash_node_get_object(a2);
      v10 = *(char **)(a1 + 32);
      if (v10)
        v11 = (nw_protocol *)(v10 - 96);
      else
        v11 = 0;
      v12 = v10;
      if (nw_protocol_definition_get_message_is_stream(v12->parent_definition)
        && *(nw_protocol **)&v12[-1].log_str[41] == object)
      {
        v13 = -2;
      }
      else
      {
        v13 = (unint64_t)object;
      }

      nw_protocol_implementation_report_connected(v12, v11, object, v13);
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 32);
      if ((!v8 || (*(char *)(v8 + 405) & 0x80000000) == 0) && gLogDatapath)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          v16 = *(_QWORD *)(a1 + 32);
          v17 = *(_QWORD *)(a1 + 40);
          v18 = v16 == 0;
          if (v16)
            v19 = (const char *)(v16 + 407);
          else
            v19 = "";
          v22 = "nw_protocol_instance_report_ready_block_invoke";
          v23 = 2082;
          v20 = " ";
          v21 = 136446978;
          if (v18)
            v20 = "";
          v24 = v19;
          v25 = 2080;
          v26 = v20;
          v27 = 2048;
          v28 = v17;
          _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDelaying the delivery of connected() on flow %llx", (uint8_t *)&v21, 0x2Au);
        }

        v7 = *(_WORD *)(v6 + 52);
      }
      *(_WORD *)(v6 + 52) = v7 | 0x20;
    }
  }
  return 1;
}

uint64_t __nw_context_endpoint_get_active_instance_count_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  uint64_t instance_count;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = (id)nw_hash_node_get_object(a2);
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_endpoint_get_active_instance_count";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_endpoint_get_active_instance_count";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_endpoint_get_active_instance_count";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_endpoint_get_active_instance_count";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_endpoint_get_active_instance_count";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v8)
      free(v8);
    goto LABEL_22;
  }
  v5 = (void *)*((_QWORD *)v3 + 26);
  if (!v5)
  {
LABEL_22:
    instance_count = 0;
    goto LABEL_23;
  }
  instance_count = nw_protocol_instance_registrar_get_instance_count(v5);
LABEL_23:

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += instance_count;
  return 1;
}

void sub_18300D390(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_unordered_xpc_array_is_equal(xpc_object_t object1, xpc_object_t object2)
{
  BOOL v3;
  uint64_t result;
  Class Class;
  objc_class *v7;
  size_t count;

  v3 = object1 == object2;
  result = object1 == object2;
  if (!v3 && object1 && object2)
  {
    if (xpc_equal(object1, object2))
    {
      return 1;
    }
    else
    {
      Class = object_getClass(object1);
      v7 = (objc_class *)MEMORY[0x1E0C812C8];
      if (Class == (Class)MEMORY[0x1E0C812C8]
        && object_getClass(object2) == v7
        && (count = xpc_array_get_count(object1), xpc_array_get_count(object2) == count))
      {
        return nw_unordered_xpc_array_is_equal_inner(object1, object2, count);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t ___ZL34nw_channel_notify_output_availableP10nw_channel_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *object;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  void (*v7)(_QWORD *, uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  void (**v16)(_QWORD);
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  void (**v20)(_QWORD);
  const void *v21;

  object = (_QWORD *)nw_hash_node_get_object(a2);
  v4 = *(_QWORD *)(a1 + 32);
  if (object)
  {
    v5 = object;
    v6 = object[3];
    if (v6)
    {
      v7 = *(void (**)(_QWORD *, uint64_t))(v6 + 72);
      if (v7)
      {
        v8 = (void *)object[5];
        if (v8 == &nw_protocol_ref_counted_handle)
        {
          v9 = object[11];
          if (v9)
            object[11] = v9 + 1;
        }
        if (*(_UNKNOWN **)(v4 + 64) == &nw_protocol_ref_counted_handle)
        {
          v10 = *(_QWORD *)(v4 + 112);
          if (v10)
            *(_QWORD *)(v4 + 112) = v10 + 1;
          v7(object, v4 + 24);
          if (*(_UNKNOWN **)(v4 + 64) == &nw_protocol_ref_counted_handle)
          {
            v14 = *(_QWORD *)(v4 + 112);
            if (v14)
            {
              v15 = v14 - 1;
              *(_QWORD *)(v4 + 112) = v15;
              if (!v15)
              {
                v16 = *(void (***)(_QWORD))(v4 + 88);
                if (v16)
                {
                  *(_QWORD *)(v4 + 88) = 0;
                  v16[2](v16);
                  _Block_release(v16);
                }
                if ((*(_BYTE *)(v4 + 96) & 1) != 0)
                {
                  v17 = *(const void **)(v4 + 88);
                  if (v17)
                    _Block_release(v17);
                }
                free((void *)(v4 + 24));
              }
            }
          }
        }
        else
        {
          v7(object, v4 + 24);
        }
        if (v8 == &nw_protocol_ref_counted_handle && (_UNKNOWN *)v5[5] == &nw_protocol_ref_counted_handle)
        {
          v18 = v5[11];
          if (v18)
          {
            v19 = v18 - 1;
            v5[11] = v19;
            if (!v19)
            {
              v20 = (void (**)(_QWORD))v5[8];
              if (v20)
              {
                v5[8] = 0;
                v20[2](v20);
                _Block_release(v20);
              }
              if ((v5[9] & 1) != 0)
              {
                v21 = (const void *)v5[8];
                if (v21)
                  _Block_release(v21);
              }
              free(v5);
            }
          }
        }
        v4 = *(_QWORD *)(a1 + 32);
      }
    }
  }
  if (!*(_QWORD *)(v4 + 176))
    return 0;
  result = *(_QWORD *)(v4 + 216);
  if (result)
  {
    v12 = os_channel_available_slot_count();
    v13 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 420);
    if (v13 - 1 >= v12)
      v13 = 0;
    return v12 != v13;
  }
  return result;
}

uint64_t static NWConnection.ContentContext.defaultMessage.getter()
{
  return sub_18303BFDC(&qword_1EDCD7AC8);
}

void __nw_endpoint_handler_initialize_association_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;

  v5 = a3;
  if (nw_path_changed_from_previous(v5))
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 268) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + 268) & 0xF7 | (8
                                                                                                * nw_endpoint_handler_get_alternate_path_state(*(void **)(a1 + 32), 0, 0, v5));
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 112));
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 64), a3);
  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 112));
  nw_endpoint_handler_path_change(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));

}

void sub_18300D6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_path_changed_from_previous(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[474] >> 4) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_changed_from_previous";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_changed_from_previous";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_changed_from_previous";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_changed_from_previous";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_changed_from_previous";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

ValueMetadata *type metadata accessor for NWPath.Status()
{
  return &type metadata for NWPath.Status;
}

BOOL nw_protocol_create_inbound_data(void *a1, size_t a2, void *a3)
{
  NWConcrete_nw_protocol_instance *v5;
  id v6;
  void *v7;
  uint64_t buffer_manager_with_context;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  void *v12;
  _BOOL8 result;
  _QWORD *data_from_pool;
  int v15;
  uint64_t v16;
  char *v17;
  _QWORD *v18;
  OS_nw_context *context;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  void *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  os_log_type_t v36;
  os_log_type_t v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  size_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  if (!v5)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_create_inbound_data";
    v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v21, &type, &v38))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (!v38)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_182FBE000, v22, v35, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    v29 = type;
    v30 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_create_inbound_data";
      v42 = 2082;
      v43 = (size_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_57:

    free(backtrace_string);
    goto LABEL_76;
  }
  v7 = *(void **)&v5->protocol_outbound_data_limit;
  if (!v7)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_create_inbound_data";
    v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v21, &type, &v38))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null instance->context", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (!v38)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_182FBE000, v22, v36, "%{public}s called with null instance->context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    v31 = type;
    v32 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_create_inbound_data";
        _os_log_impl(&dword_182FBE000, v22, v31, "%{public}s called with null instance->context, no backtrace", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_create_inbound_data";
      v42 = 2082;
      v43 = (size_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v22, v31, "%{public}s called with null instance->context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
  if (!a2)
  {
LABEL_9:
    v10 = 0;
    goto LABEL_10;
  }
  buffer_manager_with_context = nw_frame_get_buffer_manager_with_context(v7, a2);
  if (buffer_manager_with_context)
  {
    v9 = buffer_manager_with_context;
    v10 = nw_mem_buffer_allocate(buffer_manager_with_context);
    if (v10)
    {
LABEL_11:
      if (v6)
      {
        data_from_pool = nw_protocol_create_data_from_pool(v5, 0);
        if (data_from_pool)
        {
          nw_frame_reset((uint64_t)data_from_pool, v10, a2, (uint64_t)nw_protocol_inbound_data_finalizer, (uint64_t)v5);
          v15 = 0;
          goto LABEL_16;
        }
      }
      v16 = nw_frame_create(16 * (v6 != 0), v10, a2, (uint64_t)nw_protocol_inbound_data_finalizer, (uint64_t)v5);
      if (v16)
      {
        data_from_pool = (_QWORD *)v16;
        v15 = 1;
        if (!v6)
        {
LABEL_20:
          if (v9)
          {
            data_from_pool[13] = v9;
          }
          else if (v10)
          {
            *((_WORD *)data_from_pool + 102) |= 1u;
          }
          if (v15)
            v18 = data_from_pool;
          data_from_pool[2] = 0;
          context = v5->context;
          data_from_pool[3] = context;
          *(_QWORD *)context = data_from_pool;
          v5->context = (OS_nw_context *)(data_from_pool + 2);
LABEL_27:

          return (BOOL)data_from_pool;
        }
LABEL_16:
        if ((*((_WORD *)data_from_pool + 102) & 4) != 0)
          v17 = (char *)(data_from_pool + 26);
        else
          v17 = 0;
        *((_QWORD *)v17 + 1) = _Block_copy(v6);
        goto LABEL_20;
      }
      __nwlog_obj();
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_create_inbound_data";
      v21 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v38 = 0;
      if (__nwlog_fault(v21, &type, &v38))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          v27 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v41 = "nw_protocol_create_inbound_data";
            _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s nw_frame_create failed", buf, 0xCu);
          }
LABEL_75:

          goto LABEL_76;
        }
        if (!v38)
        {
          __nwlog_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          v37 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v41 = "nw_protocol_create_inbound_data";
            _os_log_impl(&dword_182FBE000, v22, v37, "%{public}s nw_frame_create failed, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_75;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        v34 = os_log_type_enabled(v22, type);
        if (!backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446210;
            v41 = "nw_protocol_create_inbound_data";
            _os_log_impl(&dword_182FBE000, v22, v33, "%{public}s nw_frame_create failed, no backtrace", buf, 0xCu);
          }
          goto LABEL_75;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v41 = "nw_protocol_create_inbound_data";
          v42 = 2082;
          v43 = (size_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v33, "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_57;
      }
LABEL_76:
      if (v21)
        free(v21);
      data_from_pool = 0;
      goto LABEL_27;
    }
  }
  v10 = (uint64_t)malloc_type_malloc(a2, 0xF2B69DE5uLL);
  if (v10)
  {
LABEL_10:
    v9 = 0;
    goto LABEL_11;
  }
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v41 = "strict_malloc";
  v42 = 2048;
  v43 = a2;
  v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    goto LABEL_9;
  }
  __break(1u);
  return result;
}

void sub_18300E1FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_mem_buffer_free(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD *v9;
  unsigned int v10;
  _QWORD *v11;
  int *v12;
  malloc_zone_t *v13;
  size_t v14;
  uint64_t v15;
  size_t v16;
  _QWORD *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  void *v21;
  void (*v22)(unint64_t, _QWORD);
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  uint64_t v27;
  NSObject *v28;
  void *v29;
  char *backtrace_string;
  _BOOL4 v31;
  char *v32;
  _BOOL4 v33;
  void *v34;
  void *v35;
  void *v36;
  NSObject *v37;
  char v38;
  os_log_type_t type;
  _BYTE buf[22];
  __int16 v41;
  unint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
    v23 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v23, &type, &v38))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
      v26 = "%{public}s called with null buffer_manager";
      goto LABEL_74;
    }
    if (!v38)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
      v26 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v31 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (!v31)
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
      v26 = "%{public}s called with null buffer_manager, no backtrace";
      goto LABEL_74;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null buffer_manager, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_75:
    if (!v23)
      return;
    goto LABEL_76;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
    v23 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v23, &type, &v38))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
      v26 = "%{public}s called with null buffer";
      goto LABEL_74;
    }
    if (!v38)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
      v26 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_74;
    }
    v32 = (char *)__nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v33 = os_log_type_enabled(v24, type);
    if (v32)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v32;
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null buffer, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v32);
      if (!v23)
        return;
LABEL_76:
      free(v23);
      return;
    }
    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
      v26 = "%{public}s called with null buffer, no backtrace";
LABEL_74:
      _os_log_impl(&dword_182FBE000, v24, v25, v26, buf, 0xCu);
      goto LABEL_75;
    }
    goto LABEL_75;
  }
  if (*(_QWORD *)(a1 + 88))
  {
    g_transaction_touched = 1;
    nw_mem_cache_update_set_timer();
    v4 = *(_QWORD *)(a1 + 88);
    nw_mem_cache_operations_during_interval = 1;
    if ((*(_BYTE *)(v4 + 176) & 2) != 0)
    {
      v27 = *(_QWORD *)(v4 + 288) + 8 * ((a2 >> *(_QWORD *)(v4 + 272)) & *(_QWORD *)(v4 + 280));
      while (1)
      {
        v27 = *(_QWORD *)v27;
        if (!v27)
          break;
        if (*(_QWORD *)(v27 + 8) == a2)
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          gettimeofday((timeval *)buf, 0);
          *(_QWORD *)(v27 + 32) = 1000 * *(_QWORD *)buf + *(_DWORD *)&buf[8] / 1000;
          *(_DWORD *)(v27 + 44) = backtrace((void **)(v27 + 48), 16);
          goto LABEL_5;
        }
      }
      v28 = __nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_mem_audit_buf";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v4 + 96;
      v41 = 2048;
      v42 = a2;
      v29 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v29))
      {
LABEL_77:
        __break(1u);
        return;
      }
      free(v29);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      gettimeofday((timeval *)buf, 0);
      MEMORY[0x20] = 1000 * *(_QWORD *)buf + *(_DWORD *)&buf[8] / 1000;
      MEMORY[0x2C] = backtrace((void **)0x30, 16);
    }
LABEL_5:
    v5 = *(_DWORD *)(v4 + 552);
    v6 = *(_DWORD *)(v4 + 560);
    if (v5 < v6)
    {
LABEL_6:
      v7 = *(_QWORD *)(v4 + 520);
      *(_DWORD *)(v4 + 552) = v5 + 1;
      *(_QWORD *)(v7 + 8 * (int)v5 + 8) = a2;
      ++*(_QWORD *)(v4 + 544);
      return;
    }
    while (1)
    {
      if (!*(_DWORD *)(v4 + 556))
      {
        *(_DWORD *)(v4 + 556) = v5;
        *(int8x16_t *)(v4 + 520) = vextq_s8(*(int8x16_t *)(v4 + 520), *(int8x16_t *)(v4 + 520), 8uLL);
LABEL_11:
        *(_DWORD *)(v4 + 552) = 0;
        goto LABEL_12;
      }
      if (!v6)
      {
        v22 = *(void (**)(unint64_t, _QWORD))(v4 + 192);
        if (v22)
          v22(a2, *(_QWORD *)(v4 + 208));
        nw_mem_slab_free(v4, a2);
        return;
      }
      v9 = *(_QWORD **)(v4 + 384);
      if (v9)
      {
        *(_QWORD *)(v4 + 384) = *v9;
        v10 = *(_DWORD *)(v4 + 392) - 1;
        *(_DWORD *)(v4 + 392) = v10;
        if (v10 < *(_DWORD *)(v4 + 396))
          *(_DWORD *)(v4 + 396) = v10;
        ++*(_QWORD *)(v4 + 376);
        v11 = *(_QWORD **)(v4 + 528);
        if (v11)
        {
          *v11 = *(_QWORD *)(v4 + 352);
          *(_QWORD *)(v4 + 352) = v11;
          ++*(_DWORD *)(v4 + 360);
        }
        *(_QWORD *)(v4 + 528) = *(_QWORD *)(v4 + 520);
        *(_DWORD *)(v4 + 556) = v5;
        *(_QWORD *)(v4 + 520) = v9;
        goto LABEL_11;
      }
      v12 = *(int **)(v4 + 336);
      v13 = (malloc_zone_t *)g_slab_zone;
      v14 = v12[1];
      v15 = 8 * *v12;
      v16 = v15 + 8;
      if (v15 == -8)
      {
        v18 = __nwlog_obj();
        os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "strict_malloc_zone_memalign";
        v34 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort((uint64_t)v34))
          goto LABEL_77;
        free(v34);
        if (v14 <= 7)
        {
LABEL_30:
          v19 = __nwlog_obj();
          os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "strict_malloc_zone_memalign";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v14;
          v35 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort((uint64_t)v35))
            goto LABEL_77;
          free(v35);
        }
      }
      else if (v14 <= 7)
      {
        goto LABEL_30;
      }
      if ((v14 & (v14 - 1)) != 0)
      {
        v20 = __nwlog_obj();
        os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "strict_malloc_zone_memalign";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v14;
        v36 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort((uint64_t)v36))
          goto LABEL_77;
        free(v36);
      }
      v17 = malloc_type_zone_memalign(v13, v14, v16, 0xD927051FuLL);
      if (v17)
      {
        v6 = *(_DWORD *)(v4 + 560);
        if (v6 != *v12)
        {
          malloc_zone_free((malloc_zone_t *)g_slab_zone, v17);
          v6 = *(_DWORD *)(v4 + 560);
          goto LABEL_12;
        }
LABEL_26:
        *v17 = *(_QWORD *)(v4 + 384);
        *(_QWORD *)(v4 + 384) = v17;
        ++*(_DWORD *)(v4 + 392);
        goto LABEL_12;
      }
      v37 = __nwlog_obj();
      os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "strict_malloc_zone_memalign";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v14;
      v41 = 2048;
      v42 = v16;
      v21 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v21))
        goto LABEL_77;
      free(v21);
      v6 = *(_DWORD *)(v4 + 560);
      if (v6 == *v12)
        goto LABEL_26;
LABEL_12:
      v5 = *(_DWORD *)(v4 + 552);
      if (v5 < v6)
        goto LABEL_6;
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_mem_buffer_free";
    _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s buffer cache is NULL", buf, 0xCu);
  }
}

BOOL nw_mem_buffer_allocate(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  _QWORD *v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _BOOL8 result;
  int v11;
  int v12;
  unsigned int v13;
  _QWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _BOOL8 v20;
  _BOOL8 v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  size_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  NSObject *v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int (*v42)(os_log_type_t *, __int128 *, _QWORD, uint64_t);
  __int128 *v43;
  uint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  const char *v53;
  char *backtrace_string;
  _BOOL4 v55;
  NSObject *v56;
  void *v57;
  NSObject *v58;
  void *v59;
  NSObject *v60;
  NSObject *v61;
  uint32_t v62;
  NSObject *v63;
  void *v64;
  __int128 v65;
  __int128 v66;
  os_log_type_t type[16];
  __int128 v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  mach_timebase_info info[8];

  info[6] = *(mach_timebase_info *)MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    info[0].numer = 136446210;
    *(_QWORD *)&info[0].denom = "nw_mem_buffer_allocate";
    v50 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v65) = 0;
    if (!__nwlog_fault(v50, type, &v65))
      goto LABEL_86;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v51 = __nwlog_obj();
      v52 = type[0];
      if (!os_log_type_enabled(v51, type[0]))
        goto LABEL_86;
      info[0].numer = 136446210;
      *(_QWORD *)&info[0].denom = "nw_mem_buffer_allocate";
      v53 = "%{public}s called with null buffer_manager";
    }
    else if ((_BYTE)v65)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v51 = __nwlog_obj();
      v52 = type[0];
      v55 = os_log_type_enabled(v51, type[0]);
      if (backtrace_string)
      {
        if (v55)
        {
          info[0].numer = 136446466;
          *(_QWORD *)&info[0].denom = "nw_mem_buffer_allocate";
          LOWORD(info[1].denom) = 2082;
          *(_QWORD *)((char *)&info[1].denom + 2) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s called with null buffer_manager, dumping backtrace:%{public}s", (uint8_t *)info, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_86;
      }
      if (!v55)
      {
LABEL_86:
        if (v50)
          free(v50);
        return 0;
      }
      info[0].numer = 136446210;
      *(_QWORD *)&info[0].denom = "nw_mem_buffer_allocate";
      v53 = "%{public}s called with null buffer_manager, no backtrace";
    }
    else
    {
      v51 = __nwlog_obj();
      v52 = type[0];
      if (!os_log_type_enabled(v51, type[0]))
        goto LABEL_86;
      info[0].numer = 136446210;
      *(_QWORD *)&info[0].denom = "nw_mem_buffer_allocate";
      v53 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v51, v52, v53, (uint8_t *)info, 0xCu);
    goto LABEL_86;
  }
  if (!*(_QWORD *)(a1 + 88))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      info[0].numer = 136446466;
      *(_QWORD *)&info[0].denom = "nw_mem_buffer_allocate";
      LOWORD(info[1].denom) = 2082;
      *(_QWORD *)((char *)&info[1].denom + 2) = a1 + 96;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s buffer cache is NULL for %{public}s", (uint8_t *)info, 0x16u);
    }
    return 0;
  }
  g_transaction_touched = 1;
  nw_mem_cache_update_set_timer();
  v2 = *(_QWORD *)(a1 + 88);
  *(_OWORD *)type = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  nw_mem_cache_operations_during_interval = 1;
  info[0] = 0;
  if (!mach_timebase_info(info))
  {
    v3 = mach_absolute_time() * info[0].numer / info[0].denom;
    *(_QWORD *)&nw_mem_get_current_time::current_time = v3 / 0x3B9ACA00;
    *((_QWORD *)&nw_mem_get_current_time::current_time + 1) = v3 % 0x3B9ACA00;
    *(_OWORD *)(v2 + 408) = nw_mem_get_current_time::current_time;
  }
  v4 = *(_DWORD *)(v2 + 552);
  if (v4 < 1)
  {
    v11 = *(_DWORD *)(v2 + 556);
    while (1)
    {
      v12 = v4;
      if (v11 >= 1)
      {
        v5 = *(_QWORD **)(v2 + 528);
        *(_QWORD *)(v2 + 528) = *(_QWORD *)(v2 + 520);
        *(_DWORD *)(v2 + 556) = v4;
        *(_QWORD *)(v2 + 520) = v5;
        v4 = v11;
        goto LABEL_7;
      }
      v4 = *(_DWORD *)(v2 + 560);
      if (!v4)
        break;
      v5 = *(_QWORD **)(v2 + 352);
      if (!v5)
        break;
      *(_QWORD *)(v2 + 352) = *v5;
      v13 = *(_DWORD *)(v2 + 360) - 1;
      *(_DWORD *)(v2 + 360) = v13;
      if (v13 < *(_DWORD *)(v2 + 364))
        *(_DWORD *)(v2 + 364) = v13;
      ++*(_QWORD *)(v2 + 344);
      v14 = *(_QWORD **)(v2 + 528);
      if (v14)
      {
        *v14 = *(_QWORD *)(v2 + 384);
        *(_QWORD *)(v2 + 384) = v14;
        ++*(_DWORD *)(v2 + 392);
      }
      *(_QWORD *)(v2 + 528) = *(_QWORD *)(v2 + 520);
      *(_DWORD *)(v2 + 556) = v12;
      *(_QWORD *)(v2 + 520) = v5;
      *(_DWORD *)(v2 + 552) = v4;
      v11 = v12;
      if (v4 > 0)
        goto LABEL_7;
    }
    ++*(_QWORD *)(v2 + 48);
    v15 = *(_DWORD **)(v2 + 296);
    if (v15)
    {
      LODWORD(v16) = v15[17];
    }
    else
    {
      v17 = *(_QWORD *)(v2 + 216);
      v18 = *(_QWORD *)(v17 + 120);
      v19 = *(_QWORD *)(v2 + 248);
      v70 = 0;
      v71 = 0;
      v69 = 0;
      v20 = nw_mem_region_alloc(v17, &v69, &v71, &v70, 1);
      if (!v20)
      {
        if (gLogDatapath)
        {
          v63 = __nwlog_obj();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
          {
            info[0].numer = 136446210;
            *(_QWORD *)&info[0].denom = "nw_mem_slab_create";
            _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_DEBUG, "%{public}s nw mem region alloc failure", (uint8_t *)info, 0xCu);
          }
        }
        v7 = 0;
        ++*(_QWORD *)v2;
        return v7;
      }
      v21 = v20;
      v15 = malloc_type_zone_memalign((malloc_zone_t *)g_slab_zone, 8uLL, 0x48uLL, 0xD927051FuLL);
      if (!v15)
      {
        v58 = __nwlog_obj();
        os_log_type_enabled(v58, OS_LOG_TYPE_ERROR);
        info[0].numer = 136446722;
        *(_QWORD *)&info[0].denom = "strict_malloc_zone_memalign";
        LOWORD(info[1].denom) = 2048;
        *(_QWORD *)((char *)&info[1].denom + 2) = 8;
        HIWORD(info[2].denom) = 2048;
        info[3] = (mach_timebase_info)72;
        v59 = (void *)_os_log_send_and_compose_impl();
        result = __nwlog_abort((uint64_t)v59);
        if (result)
          goto LABEL_99;
        free(v59);
      }
      *((_QWORD *)v15 + 8) = 0;
      *((_OWORD *)v15 + 2) = 0u;
      *((_OWORD *)v15 + 3) = 0u;
      *(_OWORD *)v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      *((_QWORD *)v15 + 2) = v2;
      *((_QWORD *)v15 + 3) = v21;
      v22 = v69;
      v23 = v19 / v18;
      v15[17] = v19 / v18;
      v24 = v71;
      *((_QWORD *)v15 + 4) = v22;
      *((_QWORD *)v15 + 5) = v24;
      *((_QWORD *)v15 + 6) = v70;
      if ((nw_mem_debug & 2) != 0)
        v25 = 176;
      else
        v25 = 40;
      v26 = (v19 / v18);
      if ((_DWORD)v23)
      {
        v27 = v21;
        do
        {
          v28 = malloc_type_zone_memalign((malloc_zone_t *)g_slab_zone, 8uLL, v25, 0xD927051FuLL);
          if (!v28)
          {
            v29 = __nwlog_obj();
            os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
            info[0].numer = 136446722;
            *(_QWORD *)&info[0].denom = "strict_malloc_zone_memalign";
            LOWORD(info[1].denom) = 2048;
            *(_QWORD *)((char *)&info[1].denom + 2) = 8;
            HIWORD(info[2].denom) = 2048;
            info[3] = (mach_timebase_info)v25;
            v64 = (void *)_os_log_send_and_compose_impl();
            result = __nwlog_abort((uint64_t)v64);
            if (result)
              goto LABEL_99;
            free(v64);
          }
          bzero(v28, v25);
          v28[1] = v27;
          v28[2] = v22;
          v28[3] = v15;
          *((_DWORD *)v28 + 8) = v15[17] - v26;
          *v28 = *((_QWORD *)v15 + 7);
          *((_QWORD *)v15 + 7) = v28;
          v27 += v18;
          if (v22)
            v22 += v18;
          else
            v22 = 0;
          --v26;
        }
        while (v26);
      }
      if (gLogDatapath)
      {
        v60 = __nwlog_obj();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          info[0].numer = 136446722;
          *(_QWORD *)&info[0].denom = "nw_mem_slab_create";
          LOWORD(info[1].denom) = 2048;
          *(_QWORD *)((char *)&info[1].denom + 2) = v2;
          HIWORD(info[2].denom) = 2048;
          info[3] = (mach_timebase_info)v15;
          _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p sl %p", (uint8_t *)info, 0x20u);
        }
        if (gLogDatapath)
        {
          v61 = __nwlog_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
          {
            v62 = *(_DWORD *)(*((_QWORD *)v15 + 5) + 40);
            info[0].numer = 136446978;
            *(_QWORD *)&info[0].denom = "nw_mem_slab_create";
            LOWORD(info[1].denom) = 1024;
            *(uint32_t *)((char *)&info[1].denom + 2) = v62;
            HIWORD(info[2].numer) = 2048;
            *(_QWORD *)&info[2].denom = v21;
            LOWORD(info[3].denom) = 2048;
            *(_QWORD *)((char *)&info[3].denom + 2) = v21 + v18;
            _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEBUG, "%{public}s   [%u] [%p-%p)", (uint8_t *)info, 0x26u);
          }
        }
      }
      ++*(_QWORD *)(v2 + 32);
      v16 = v15[17];
      v30 = *(_QWORD *)(v2 + 16);
      v31 = *(_QWORD *)(v2 + 8) + v16;
      *(_QWORD *)(v2 + 8) = v31;
      if (v31 > v30)
        *(_QWORD *)(v2 + 16) = v31;
    }
    v32 = v15[16];
    v15[16] = v32 + 1;
    v33 = (uint64_t *)*((_QWORD *)v15 + 7);
    v34 = *v33;
    *((_QWORD *)v15 + 7) = *v33;
    v7 = v33[1];
    v35 = *(_QWORD *)(v2 + 240);
    *(_QWORD *)type = v7;
    *(_QWORD *)&type[8] = v35;
    v36 = *((_QWORD *)v15 + 5);
    v37 = *((_DWORD *)v33 + 8);
    v38 = v37 + v16 * *(_DWORD *)(v36 + 40);
    *(_QWORD *)&v68 = __PAIR64__(v37, v38);
    *((_QWORD *)&v68 + 1) = v36;
    v65 = 0u;
    v66 = 0u;
    v39 = v33[2];
    if (v39)
    {
      *(_QWORD *)&v65 = v33[2];
      *((_QWORD *)&v65 + 1) = v35;
      *(_QWORD *)&v66 = __PAIR64__(v37, v38);
      *((_QWORD *)&v66 + 1) = *((_QWORD *)v15 + 6);
    }
    v40 = *(_QWORD *)(v2 + 288);
    v41 = 8 * ((v7 >> *(_QWORD *)(v2 + 272)) & *(_QWORD *)(v2 + 280));
    *v33 = *(_QWORD *)(v40 + v41);
    *(_QWORD *)(v40 + v41) = v33;
    if (v34)
    {
      if (v32)
      {
        if ((*(_BYTE *)(v2 + 176) & 2) == 0)
          goto LABEL_51;
        goto LABEL_68;
      }
      v46 = (_QWORD *)(v2 + 296);
      v47 = *(_QWORD *)(v2 + 296);
      *(_QWORD *)v15 = v47;
      v48 = (_QWORD *)(v2 + 304);
    }
    else
    {
      if (v32)
      {
        v44 = *(_QWORD *)v15;
        v45 = (_QWORD *)*((_QWORD *)v15 + 1);
        if (*(_QWORD *)v15)
        {
          *(_QWORD *)(v44 + 8) = v45;
          v45 = (_QWORD *)*((_QWORD *)v15 + 1);
        }
        else
        {
          *(_QWORD *)(v2 + 304) = v45;
        }
        *v45 = v44;
      }
      v46 = (_QWORD *)(v2 + 312);
      v47 = *(_QWORD *)(v2 + 312);
      *(_QWORD *)v15 = v47;
      v48 = (_QWORD *)(v2 + 320);
    }
    if (v47)
      v49 = (_QWORD *)(v47 + 8);
    else
      v49 = v48;
    *v49 = v15;
    *v46 = v15;
    *((_QWORD *)v15 + 1) = v46;
    if ((*(_BYTE *)(v2 + 176) & 2) == 0)
    {
LABEL_51:
      v42 = *(unsigned int (**)(os_log_type_t *, __int128 *, _QWORD, uint64_t))(v2 + 184);
      if (!v42)
        return v7;
      goto LABEL_52;
    }
LABEL_68:
    info[0] = 0;
    info[1] = 0;
    gettimeofday((timeval *)info, 0);
    v33[4] = 1000 * *(_QWORD *)info + (signed int)info[1].numer / 1000;
    *((_DWORD *)v33 + 11) = backtrace((void **)v33 + 6, 16);
    v42 = *(unsigned int (**)(os_log_type_t *, __int128 *, _QWORD, uint64_t))(v2 + 184);
    if (!v42)
      return v7;
LABEL_52:
    if (v39)
      v43 = &v65;
    else
      v43 = 0;
    if (!v42(type, v43, *(_QWORD *)(v2 + 208), 1))
      return v7;
    ++*(_QWORD *)v2;
    nw_mem_slab_free(v2, v7);
    return 0;
  }
  v5 = *(_QWORD **)(v2 + 520);
LABEL_7:
  v6 = v4 - 1;
  *(_DWORD *)(v2 + 552) = v6;
  v7 = v5[v6 + 1];
  ++*(_QWORD *)(v2 + 536);
  if ((*(_BYTE *)(v2 + 176) & 2) == 0)
    return v7;
  v8 = *(_QWORD *)(v2 + 288) + 8 * ((v7 >> *(_QWORD *)(v2 + 272)) & *(_QWORD *)(v2 + 280));
  while (1)
  {
    v8 = *(_QWORD *)v8;
    if (!v8)
      break;
    if (*(_QWORD *)(v8 + 8) == v7)
    {
      info[0] = 0;
      info[1] = 0;
      gettimeofday((timeval *)info, 0);
      *(_QWORD *)(v8 + 32) = 1000 * *(_QWORD *)info + (signed int)info[1].numer / 1000;
      *(_DWORD *)(v8 + 44) = backtrace((void **)(v8 + 48), 16);
      return v7;
    }
  }
  v56 = __nwlog_obj();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  info[0].numer = 136446722;
  *(_QWORD *)&info[0].denom = "nw_mem_audit_buf";
  LOWORD(info[1].denom) = 2082;
  *(_QWORD *)((char *)&info[1].denom + 2) = v2 + 96;
  HIWORD(info[2].denom) = 2048;
  info[3] = (mach_timebase_info)v7;
  v57 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v57);
  if (!result)
  {
    free(v57);
    info[0] = 0;
    info[1] = 0;
    gettimeofday((timeval *)info, 0);
    MEMORY[0x20] = 1000 * *(_QWORD *)info + (signed int)info[1].numer / 1000;
    MEMORY[0x2C] = backtrace((void **)0x30, 16);
    return v7;
  }
LABEL_99:
  __break(1u);
  return result;
}

void nw_mem_cache_update_set_timer()
{
  uint64_t source;
  id v1;
  dispatch_time_t v2;
  uint64_t v3;

  if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
  {
    os_unfair_lock_lock(&nw_mem_cache_lock);
    if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
    {
      source = nw_mem_cache_update_source;
      if (nw_mem_cache_update_source
        || (v1 = nw_context_copy_implicit_context(),
            source = nw_queue_context_create_source(v1, 2, 3, 0, &__block_literal_global_54774, 0),
            (nw_mem_cache_update_source = source) != 0))
      {
        v2 = dispatch_time(0x8000000000000000, 11000000000);
        nw_queue_set_timer_values(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        nw_queue_activate_source(nw_mem_cache_update_source, v3);
        nw_mem_cache_update_set_timer::cache_update_timer_set = 1;
      }
    }
    os_unfair_lock_unlock(&nw_mem_cache_lock);
  }
}

uint64_t nw_context_2k_buffer_manager(void *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = v1;
    v3 = nw_context_copy_globals_context(v1);

    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 180);
    if (!v4)
    {
      *(_QWORD *)(*(_QWORD *)(v3 + 32) + 180) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe, dword_1EDCDF2B8, (unsigned __int16)word_1EDCDF2BC);
      v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 180);
    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_context_2k_buffer_manager";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_context_2k_buffer_manager";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  v3 = 0;
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_18300FAA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_frame_get_buffer_manager_with_context(void *a1, unsigned int a2)
{
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v12 = "nw_frame_get_buffer_manager_with_context";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v9 = 0;
    if (!__nwlog_fault(v3, &type, &v9))
      goto LABEL_31;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_frame_get_buffer_manager_with_context";
      v6 = "%{public}s called with null context";
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v12 = "nw_frame_get_buffer_manager_with_context";
          v13 = 2082;
          v14 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_31;
      }
      if (!v8)
      {
LABEL_31:
        if (v3)
          free(v3);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v12 = "nw_frame_get_buffer_manager_with_context";
      v6 = "%{public}s called with null context, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_frame_get_buffer_manager_with_context";
      v6 = "%{public}s called with null context, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_31;
  }
  if (dword_1EDCDF2B8 >= a2)
    return nw_context_2k_buffer_manager(a1);
  if (dword_1EDCDF300 >= a2)
    return nw_context_8k_buffer_manager(a1);
  if (dword_1EDCDF348 >= a2)
    return nw_context_16k_buffer_manager(a1);
  if (dword_1EDCDF390 >= a2)
    return nw_context_64k_buffer_manager(a1);
  if (dword_1EDCDF3D8 >= a2)
    return nw_context_128k_buffer_manager(a1);
  if (dword_1EDCDF420 >= a2)
    return nw_context_512k_buffer_manager(a1);
  if (dword_1EDCDF468 < a2)
    return 0;
  return nw_context_1024k_buffer_manager(a1);
}

id nw_context_copy_implicit_context()
{
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  return (id)nw_context_copy_implicit_context::implicit_context;
}

uint64_t nw_context_16k_buffer_manager(void *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = v1;
    v3 = nw_context_copy_globals_context(v1);

    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 164);
    if (!v4)
    {
      *(_QWORD *)(*(_QWORD *)(v3 + 32) + 164) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe_0, dword_1EDCDF348, (unsigned __int16)word_1EDCDF34C);
      v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 164);
    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_context_16k_buffer_manager";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_16k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_context_16k_buffer_manager";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_16k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_16k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  v3 = 0;
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_18301018C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_context_8k_buffer_manager(void *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = v1;
    v3 = nw_context_copy_globals_context(v1);

    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 172);
    if (!v4)
    {
      *(_QWORD *)(*(_QWORD *)(v3 + 32) + 172) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe_1, dword_1EDCDF300, (unsigned __int16)word_1EDCDF304);
      v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 172);
    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_context_8k_buffer_manager";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_8k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_context_8k_buffer_manager";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_8k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_8k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  v3 = 0;
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_183010468(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_frame_uses_external_data(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return (*(unsigned __int16 *)(a1 + 204) >> 1) & 1;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_uses_external_data";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_uses_external_data";
        v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "__nw_frame_uses_external_data";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_uses_external_data";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_uses_external_data";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

uint64_t nw_context_64k_buffer_manager(void *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = v1;
    v3 = nw_context_copy_globals_context(v1);

    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 156);
    if (!v4)
    {
      *(_QWORD *)(*(_QWORD *)(v3 + 32) + 156) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe_2, dword_1EDCDF390, (unsigned __int16)word_1EDCDF394);
      v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 156);
    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_context_64k_buffer_manager";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_64k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_context_64k_buffer_manager";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_64k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_64k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  v3 = 0;
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_183010970(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void NWConnection.receive(minimumIncompleteLength:maximumLength:completion:)(uint32_t a1, uint32_t a2, uint64_t a3, uint64_t a4)
{
  sub_182FD5AA8(a1, a2, a3, a4, (uint64_t)&unk_1E1498358, (uint64_t)sub_183083FDC, (uint64_t)&block_descriptor_21);
}

uint64_t nw_protocol_metadata_copy_identifier(void *a1, _OWORD *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *a2 = *((_OWORD *)v3 + 1);
      v5 = 1;
      goto LABEL_4;
    }
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_metadata_copy_identifier";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null out_identifier", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v20)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null out_identifier, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null out_identifier, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_protocol_metadata_copy_identifier";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null out_identifier, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_metadata_copy_identifier";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v20)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_protocol_metadata_copy_identifier";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v8)
    free(v8);
  v5 = 0;
LABEL_4:

  return v5;
}

void network_release(void *object)
{
  if (object)
    os_release(object);
}

uint64_t type metadata accessor for NWActivity()
{
  return objc_opt_self();
}

uint64_t nw_protocol_data_get_size(void *a1)
{
  _DWORD *v1;
  void *v2;
  int v3;
  uint64_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_data_get_size";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null data", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_protocol_data_get_size";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = v1[13];
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = (v3 - (v1[14] + v1[15]));
LABEL_23:

  return v4;
}

void nw_protocol_socket_cancel(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = *(void **)(a1 + 80);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v3 = *(void **)(a1 + 88);
  if (v3)
  {
    os_release(v3);
    *(_QWORD *)(a1 + 88) = 0;
  }
  v4 = *(void **)(a1 + 56);
  if (v4)
  {
    nw_tcp_set_callbacks(v4, 0, 0);
    v5 = *(void **)(a1 + 56);
    if (v5)
    {
      os_release(v5);
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
  v6 = *(void **)(a1 + 136);
  if (v6)
  {
    xpc_release(v6);
    *(_QWORD *)(a1 + 136) = 0;
  }
  nw_socket_release_frame_array((nw_frame_array_s *)(a1 + 296));
  nw_socket_release_frame_array((nw_frame_array_s *)(a1 + 248));
  nw_socket_release_frame_array((nw_frame_array_s *)(a1 + 264));
  nw_socket_release_frame_array((nw_frame_array_s *)(a1 + 232));
  nw_socket_release_frame_array((nw_frame_array_s *)(a1 + 280));
  nw_socket_release_frame_array((nw_frame_array_s *)(a1 + 312));
  v7 = *(void **)(a1 + 160);
  if (v7)
  {
    os_release(v7);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v8 = *(void **)(a1 + 168);
  if (v8)
  {
    os_release(v8);
    *(_QWORD *)(a1 + 168) = 0;
  }
  *(_WORD *)(a1 + 333) |= 0x4000u;
}

void nw_socket_release_frame_array(nw_frame_array_s *a1)
{
  nw_frame *tqh_first;
  uint64_t v3;
  nw_frame **v4;

  while (1)
  {
    tqh_first = a1->tqh_first;
    if (!a1->tqh_first)
      break;
    v3 = *((_QWORD *)tqh_first + 2);
    v4 = (nw_frame **)*((_QWORD *)tqh_first + 3);
    if (v3)
    {
      *(_QWORD *)(v3 + 24) = v4;
      v4 = (nw_frame **)*((_QWORD *)tqh_first + 3);
    }
    else
    {
      a1->tqh_last = v4;
    }
    *v4 = (nw_frame *)v3;
    *((_QWORD *)tqh_first + 2) = 0;
    *((_QWORD *)tqh_first + 3) = 0;
    if (nw_frame_uses_external_data((uint64_t)tqh_first))
      nw_frame_set_external_data((uint64_t)tqh_first, 0, 0);
    else
      nw_frame_free_buffer((uint64_t)tqh_first);
    nw_frame_reset((uint64_t)tqh_first, 0, 0, 0, 0);
    os_release(tqh_first);
  }
}

BOOL nw_flow_process_input_frames(NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2, nw_protocol *a3, nw_frame_array_s *a4, int a5, char a6, int a7)
{
  char *handle;
  nw_frame *v11;
  id v12;
  void *v13;
  BOOL v14;
  uint64_t alloc;
  size_t v16;
  _DWORD *v17;
  int v18;
  unsigned int v19;
  unsigned int next_max_size;
  uint64_t buffer_manager_with_context;
  uint64_t v22;
  _BOOL8 v23;
  const void *v24;
  _BOOL8 v25;
  void *v26;
  BOOL v27;
  void *v28;
  id v29;
  void *v30;
  _BYTE *v31;
  void *v32;
  char v35;
  id *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  __int16 v42;
  uint64_t v43;
  NSObject *v44;
  id v45;
  NSObject *v46;
  NSObject *v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  NSObject *v51;
  int minimize_logging;
  char logging_disabled;
  NSObject *v54;
  const char *v55;
  const char *v56;
  nw_endpoint_t v57;
  const char *v58;
  const char *v59;
  const char *v60;
  id v61;
  void *v62;
  NSObject *v63;
  unsigned int v64;
  int v65;
  _BOOL4 v67;
  _BOOL4 v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  size_t v73;
  dispatch_data_t v74;
  unint64_t v75;
  NSObject *v76;
  NSObject *v77;
  NSObject *v78;
  dispatch_data_t concat;
  uint64_t finalizer_context;
  char v81;
  size_t v82;
  char *v83;
  NSObject *v84;
  uint64_t v85;
  uint64_t v86;
  _BOOL8 v87;
  const void *v88;
  _BOOL8 v89;
  NSObject *v90;
  dispatch_data_t v91;
  uint64_t manager;
  _BOOL8 v93;
  NSObject *v94;
  NSObject *v95;
  int v96;
  BOOL v97;
  int v98;
  void *v99;
  OS_nw_error *v100;
  NSObject *request_receive;
  int v102;
  NSObject *v103;
  BOOL v104;
  NSObject *v105;
  const char *v106;
  const char *v107;
  const char *v108;
  id v109;
  NSObject *v110;
  const char *v111;
  const char *v112;
  nw_endpoint_t v113;
  const char *v114;
  id v115;
  _QWORD *v116;
  void *v117;
  dispatch_data_t v118;
  void *v119;
  id v120;
  void *v121;
  NSObject *v122;
  os_log_type_t v123;
  OS_nw_error *last_error;
  _BOOL4 v125;
  NSObject *v126;
  BOOL v127;
  uint64_t v128;
  uint64_t v129;
  nw_frame **v130;
  char *v131;
  NSObject *v132;
  os_log_type_t v133;
  _BOOL4 v134;
  os_log_type_t v135;
  NSObject *v136;
  const char *id_string;
  const char *v138;
  nw_endpoint_t v139;
  const char *logging_description;
  const char *v141;
  const char *v142;
  id v143;
  void *v144;
  const char *v145;
  const char *v146;
  void *v147;
  char *v148;
  NSObject *v149;
  os_log_type_t v150;
  const char *v151;
  const char *v152;
  nw_endpoint_t v153;
  const char *v154;
  const char *v155;
  const char *v156;
  id v157;
  NSObject *v158;
  const char *v159;
  const char *v160;
  nw_endpoint_t v161;
  const char *v162;
  const char *v163;
  const char *v164;
  id v165;
  char *backtrace_string;
  NSObject *v167;
  os_log_type_t v168;
  _BOOL4 v169;
  os_log_type_t v170;
  char v171;
  uint64_t v172;
  NSObject *v173;
  const char *v174;
  const char *v175;
  const char *v176;
  const char *v177;
  const char *v178;
  id v179;
  void *v180;
  _QWORD *v181;
  id v182;
  uint64_t v183;
  nw_frame **v184;
  uint64_t *v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  NSObject *v189;
  const char *v190;
  const char *v191;
  const char *v192;
  const char *v193;
  const char *v194;
  id v195;
  uint64_t v196;
  nw_frame **v197;
  _BYTE *request_list_report;
  NSObject *v199;
  _BYTE *v200;
  void *v201;
  nw_frame *v202;
  nw_frame *v203;
  char v204;
  NSObject *v205;
  const char *v206;
  const char *v207;
  nw_endpoint_t v208;
  const char *v209;
  const char *v210;
  const char *v211;
  id v212;
  int v213;
  const char *v215;
  const char *v216;
  nw_endpoint_t v217;
  const char *v218;
  NSObject *log;
  const char *loga;
  dispatch_block_t v221;
  nw_frame *tqh_first;
  _BOOL4 is_inline;
  nw_frame_array_s *v225;
  int v227;
  NWConcrete_nw_endpoint_handler *v229;
  _BOOL4 v230;
  _BOOL4 v231;
  size_t size;
  const char *sizea;
  id *v234;
  const char *v235;
  _QWORD *v236;
  nw_endpoint_t v237;
  unsigned int v238;
  const char *v239;
  char *buffer;
  NSObject *buffera;
  const char *bufferb;
  int v243;
  const char *v244;
  NSObject *data1;
  id v246;
  id v247;
  NWConcrete_nw_endpoint_flow *v248;
  unsigned int v249;
  NSObject *v250;
  char *v251;
  unsigned int v252;
  nw_endpoint_t v253;
  nw_endpoint_t v254;
  dispatch_data_t data;
  dispatch_data_t dataa;
  _QWORD v257[2];
  uint64_t (*v258)(uint64_t, uint64_t);
  void *v259;
  char *v260;
  _QWORD v261[6];
  _QWORD v262[6];
  _QWORD v263[4];
  NWConcrete_nw_endpoint_flow *v264;
  NSObject *v265;
  char *v266;
  _QWORD destructor[6];
  _BOOL8 v268;
  _QWORD v269[6];
  char v270;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v273)(uint64_t, uint64_t);
  _BYTE v274[20];
  __int16 v275;
  const char *v276;
  __int16 v277;
  id v278;
  __int16 v279;
  _BYTE v280[34];
  __int16 v281;
  unsigned int v282;
  unsigned __int8 uu[16];
  uuid_string_t out;
  uint64_t v285;

  v285 = *MEMORY[0x1E0C80C00];
  v229 = a1;
  v248 = a2;
  handle = (char *)a3->handle;
  v225 = a4;
  tqh_first = a4->tqh_first;
  v251 = handle;
  if (!a4->tqh_first)
  {
    if ((*((_WORD *)handle + 166) & 0x10) == 0)
      goto LABEL_361;
    v28 = (void *)*((_QWORD *)handle + 33);
    if (!v28)
    {
      v187 = *((_QWORD *)handle + 32);
      if (v187 && nw_dictionary_get_count(v187))
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x3032000000;
        v273 = __Block_byref_object_copy__16456;
        *(_QWORD *)v274 = __Block_byref_object_dispose__16457;
        *(_QWORD *)&v274[8] = 0;
        memset(out, 0, sizeof(out));
        v188 = *((_QWORD *)handle + 32);
        v269[0] = MEMORY[0x1E0C809B0];
        v269[1] = 3221225472;
        v269[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke;
        v269[3] = &unk_1E149C778;
        v269[4] = buf;
        v269[5] = out;
        nw_dictionary_apply(v188, (uint64_t)v269);
        nw_dictionary_set_value(*((_QWORD *)handle + 32), out, 0);

        if (nw_content_context_get_is_final(*(nw_content_context_t *)(*(_QWORD *)&buf[8] + 40)))
          *((_WORD *)handle + 166) |= 0x80u;
        _Block_object_dispose(buf, 8);

      }
      else
      {

        *((_WORD *)handle + 166) |= 0x80u;
      }
      goto LABEL_342;
    }
    v29 = v28;
    v30 = (void *)*((_QWORD *)handle + 33);
    *((_QWORD *)handle + 33) = 0;

    v31 = v29;
    v32 = v31;
    if (v31 == (_BYTE *)&__block_literal_global_41718 || v31 == (_BYTE *)&__block_literal_global_5_41741)
    {

      goto LABEL_342;
    }
    if (v31 == (_BYTE *)&__block_literal_global_3_41726 || v31 == (_BYTE *)&__block_literal_global_4)
    {

    }
    else
    {
      v35 = v31[118];

      if ((v35 & 1) == 0)
      {
LABEL_38:

LABEL_342:
        request_list_report = nw_read_request_list_report(*((void **)handle + 27));
        v199 = *((_QWORD *)handle + 27);
        *((_QWORD *)handle + 27) = request_list_report;
        goto LABEL_360;
      }
    }
    *((_WORD *)handle + 166) |= 0x80u;
    goto LABEL_38;
  }
  is_inline = nw_context_is_inline(*((void **)handle + 23));
  v11 = a4->tqh_first;
  v12 = v11;
  v268 = 0;
  v13 = (void *)*((_QWORD *)handle + 27);
  if (v13)
    v14 = v11 == 0;
  else
    v14 = 1;
  if (v14 || (*((_WORD *)v11 + 102) & 1) != 0)
  {
LABEL_19:
    LODWORD(v16) = 0;
    alloc = 0;
    goto LABEL_20;
  }
  alloc = 0;
  LODWORD(v16) = 0;
  if (!*((_QWORD *)v11 + 13) && (a5 & 1) == 0)
  {
    v17 = v13;
    v18 = v17[17];

    if (v18 != 3)
    {
      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)a4, 1, buf);
      v19 = *(_DWORD *)buf;
      next_max_size = nw_read_request_get_next_max_size(*((void **)handle + 27));
      if (next_max_size)
      {
        if (v19 >= next_max_size)
          v16 = next_max_size;
        else
          v16 = v19;
        if (is_inline)
          goto LABEL_18;
        buffer_manager_with_context = nw_frame_get_buffer_manager_with_context(*((void **)handle + 23), v16);
        if (!buffer_manager_with_context)
          goto LABEL_18;
        v22 = buffer_manager_with_context;
        v23 = nw_mem_buffer_allocate(buffer_manager_with_context);
        v268 = v23;
        if (!v23)
          goto LABEL_18;
        v24 = (const void *)v23;
        v25 = nw_queue_copy_current_workloop();
        destructor[0] = MEMORY[0x1E0C809B0];
        destructor[1] = 3221225472;
        destructor[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_2;
        destructor[3] = &__block_descriptor_48_e5_v8__0l;
        destructor[4] = v22;
        destructor[5] = v268;
        alloc = (uint64_t)dispatch_data_create(v24, v16, (dispatch_queue_t)v25, destructor);

        handle = v251;
        if (!alloc)
LABEL_18:
          alloc = dispatch_data_create_alloc();
        goto LABEL_20;
      }
    }
    goto LABEL_19;
  }
LABEL_20:
  v26 = (void *)*((_QWORD *)handle + 27);
  if (v26)
    v27 = v12 == 0;
  else
    v27 = 1;
  if (v27)
  {
    data1 = 0;
    goto LABEL_347;
  }
  v238 = v16;
  data1 = 0;
  v252 = 0;
  v36 = (id *)(handle + 264);
  v221 = (dispatch_block_t)*MEMORY[0x1E0C80CE0];
  v37 = (uint64_t)v12;
  v234 = (id *)(handle + 264);
  while (1)
  {
    v38 = *(void **)(v37 + 32);
    v236 = (_QWORD *)(v37 + 32);
    if (!v38 && !*(_QWORD *)(v37 + 40))
      v38 = 0;
    v246 = v38;
    if (!*(_QWORD *)(v37 + 112)
      || (*(_WORD *)(v37 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v37, *(_QWORD *)(v37 + 88)))
    {
      v41 = 0;
      buffer = 0;
    }
    else
    {
      v40 = *(_DWORD *)(v37 + 52);
      v39 = *(unsigned int *)(v37 + 56);
      v41 = v40 ? v40 - (v39 + *(_DWORD *)(v37 + 60)) : 0;
      buffer = (char *)(*(_QWORD *)(v37 + 112) + v39);
    }
    memset(uu, 0, sizeof(uu));
    memset(out, 0, sizeof(out));
    v42 = *(_WORD *)(v37 + 204);
    v43 = *(_QWORD *)(v37 + 64);
    data = (dispatch_data_t)alloc;
    v249 = v41;
    if (v43)
    {
      v243 = (*(unsigned __int8 *)(v43 + 66) >> 6) & 1;
      if (*(_QWORD *)(v43 + 48))
      {
        *(_OWORD *)uu = *(_OWORD *)(v43 + 16);
LABEL_57:
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v136 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v229);
            v138 = nw_endpoint_handler_dry_run_string(v229);
            v139 = nw_endpoint_handler_copy_endpoint(v229);
            logging_description = nw_endpoint_get_logging_description(v139);
            v141 = nw_endpoint_handler_state_string(v229);
            v142 = nw_endpoint_handler_mode_string(v229);
            v143 = nw_endpoint_handler_copy_current_path(v229);
            v144 = v143;
            *(_DWORD *)buf = 136448770;
            v145 = ", complete";
            if (!v243)
              v145 = "";
            *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
            v146 = ", wake_packet";
            if ((v42 & 0x4000) == 0)
              v146 = "";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = id_string;
            *(_WORD *)&buf[22] = 2082;
            v273 = (uint64_t (*)(uint64_t, uint64_t))v138;
            *(_WORD *)v274 = 2082;
            *(_QWORD *)&v274[2] = logging_description;
            *(_WORD *)&v274[10] = 2082;
            *(_QWORD *)&v274[12] = v141;
            v275 = 2082;
            v276 = v142;
            v277 = 2114;
            v278 = v143;
            v279 = 1042;
            *(_DWORD *)v280 = 16;
            *(_WORD *)&v280[4] = 2098;
            *(_QWORD *)&v280[6] = uu;
            *(_WORD *)&v280[14] = 2080;
            *(_QWORD *)&v280[16] = v145;
            *(_WORD *)&v280[24] = 2080;
            *(_QWORD *)&v280[26] = v146;
            _os_log_impl(&dword_182FBE000, v136, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Found frame with context %{public,uuid_t}.16P%s%s", buf, 0x6Cu);

          }
          handle = v251;
          v36 = v234;
        }
        if ((a6 & 1) != 0 || v248->multiplexed_message_definition)
        {
          v45 = *v36;
          if (v45)
          {
LABEL_61:
            v46 = v45;
            v47 = v46;
            goto LABEL_64;
          }
          v47 = nw_content_context_create(*(const char **)(*((_QWORD *)handle + 4) + 16));
          nw_content_context_set_is_final(v47, 1);
          objc_storeStrong(v36, v47);
        }
        else
        {
          if (!*((_QWORD *)handle + 32))
          {
            v116 = nw_dictionary_create();
            v117 = (void *)*((_QWORD *)handle + 32);
            *((_QWORD *)handle + 32) = v116;

            handle = v251;
          }
          uuid_unparse_upper(uu, out);
          v45 = nw_dictionary_copy_value(*((_QWORD *)handle + 32), (uint64_t)out);
          if (v45)
            goto LABEL_61;
          v47 = nw_content_context_create(*(const char **)(*((_QWORD *)handle + 4) + 16));
          nw_dictionary_set_value(*((_QWORD *)handle + 32), out, v47);
        }
        v46 = 0;
LABEL_64:

        v263[0] = MEMORY[0x1E0C809B0];
        v263[1] = 3221225472;
        v263[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_79;
        v263[3] = &unk_1E149C7C0;
        v266 = v251;
        v264 = v248;
        v48 = v47;
        v265 = v48;
        nw_frame_foreach_protocol_metadata(v37, a5, (uint64_t)v263);
        v49 = v48;
        if ((v42 & 0x4000) == 0)
          goto LABEL_78;
        v50 = v48;
        v51 = v50;
        if (v50)
        {
          if (v50 != &__block_literal_global_5_41741
            && v50 != &__block_literal_global_4
            && v50 != &__block_literal_global_3_41726
            && v50 != &__block_literal_global_41718)
          {
            BYTE6(v50[14].isa) |= 0x80u;
          }
LABEL_71:

          minimize_logging = nw_endpoint_handler_get_minimize_logging(v229);
          logging_disabled = nw_endpoint_handler_get_logging_disabled(v229);
          if (minimize_logging)
          {
            if ((logging_disabled & 1) != 0)
              goto LABEL_78;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v54 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
            {
              v151 = nw_endpoint_handler_get_id_string(v229);
              v152 = nw_endpoint_handler_dry_run_string(v229);
              v153 = nw_endpoint_handler_copy_endpoint(v229);
              v154 = nw_endpoint_get_logging_description(v153);
              v155 = nw_endpoint_handler_state_string(v229);
              v156 = nw_endpoint_handler_mode_string(v229);
              v157 = nw_endpoint_handler_copy_current_path(v229);
              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v151;
              *(_WORD *)&buf[22] = 2082;
              v273 = (uint64_t (*)(uint64_t, uint64_t))v152;
              *(_WORD *)v274 = 2082;
              *(_QWORD *)&v274[2] = v154;
              *(_WORD *)&v274[10] = 2082;
              *(_QWORD *)&v274[12] = v155;
              v275 = 2082;
              v276 = v156;
              v277 = 2114;
              v278 = v157;
              _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] content_context is wake packet", buf, 0x48u);

            }
            goto LABEL_77;
          }
          if ((logging_disabled & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v54 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
            {
              v55 = nw_endpoint_handler_get_id_string(v229);
              v56 = nw_endpoint_handler_dry_run_string(v229);
              v57 = nw_endpoint_handler_copy_endpoint(v229);
              v58 = nw_endpoint_get_logging_description(v57);
              v59 = nw_endpoint_handler_state_string(v229);
              v60 = nw_endpoint_handler_mode_string(v229);
              v61 = nw_endpoint_handler_copy_current_path(v229);
              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v55;
              *(_WORD *)&buf[22] = 2082;
              v273 = (uint64_t (*)(uint64_t, uint64_t))v56;
              *(_WORD *)v274 = 2082;
              *(_QWORD *)&v274[2] = v58;
              *(_WORD *)&v274[10] = 2082;
              *(_QWORD *)&v274[12] = v59;
              v275 = 2082;
              v276 = v60;
              v277 = 2114;
              v278 = v61;
              _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] content_context is wake packet", buf, 0x48u);

            }
LABEL_77:

          }
LABEL_78:

          alloc = (uint64_t)data;
          handle = v251;
          v44 = v49;
          v41 = v249;
          goto LABEL_79;
        }
        __nwlog_obj();
        v147 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_set_is_wake_packet";
        v148 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v270 = 0;
        if (__nwlog_fault(v148, &type, &v270))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v149 = objc_claimAutoreleasedReturnValue();
            v150 = type;
            if (os_log_type_enabled(v149, type))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_content_context_set_is_wake_packet";
              _os_log_impl(&dword_182FBE000, v149, v150, "%{public}s called with null context", buf, 0xCu);
            }
          }
          else
          {
            if (v270)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v167 = objc_claimAutoreleasedReturnValue();
              v168 = type;
              v169 = os_log_type_enabled(v167, type);
              if (backtrace_string)
              {
                if (v169)
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "nw_content_context_set_is_wake_packet";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = backtrace_string;
                  _os_log_impl(&dword_182FBE000, v167, v168, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(backtrace_string);
              }
              else
              {
                if (v169)
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_content_context_set_is_wake_packet";
                  _os_log_impl(&dword_182FBE000, v167, v168, "%{public}s called with null context, no backtrace", buf, 0xCu);
                }

              }
              goto LABEL_303;
            }
            __nwlog_obj();
            v149 = objc_claimAutoreleasedReturnValue();
            v170 = type;
            if (os_log_type_enabled(v149, type))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_content_context_set_is_wake_packet";
              _os_log_impl(&dword_182FBE000, v149, v170, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
LABEL_303:
        if (v148)
          free(v148);
        goto LABEL_71;
      }
    }
    else
    {
      v243 = 0;
    }
    if ((*(_WORD *)(v37 + 204) & 0x4000) != 0)
      goto LABEL_57;
    v44 = 0;
LABEL_79:
    v62 = (void *)*((_QWORD *)handle + 27);
    v63 = v44;
    if (!v62 || v41)
      break;
    if (!alloc || !v246 || v252 >= v238)
    {
      if (alloc)
      {
        alloc = (uint64_t)data1;
      }
      else
      {
        v118 = 0;
        data = data1;
        if (!data1)
          goto LABEL_221;
      }
      if (dispatch_data_get_size(data))
      {
        v119 = (void *)*((_QWORD *)handle + 40);
        if (!v119 || (*((_BYTE *)v248 + 36) & 2) == 0)
        {
          v118 = data;
          goto LABEL_221;
        }
        *((_QWORD *)handle + 40) = 0;

        last_error = v248->last_error;
        v248->last_error = 0;

        *((_BYTE *)v248 + 36) &= ~2u;
        v118 = data;
      }
      else
      {

        v118 = 0;
      }
      handle = v251;
LABEL_221:

      if (v44)
        v125 = v243 != 0;
      else
        v125 = 0;
      if (!v125)
        goto LABEL_231;
      v126 = v44;
      if (v126 == &__block_literal_global_41718 || v126 == &__block_literal_global_5_41741)
      {

        goto LABEL_231;
      }
      if (v126 == &__block_literal_global_3_41726 || v126 == &__block_literal_global_4)
      {

      }
      else
      {
        v127 = (BYTE6(v126[14].isa) & 1) == 0;

        if (v127)
        {
LABEL_231:

          v64 = 0;
          data = 0;
          data1 = alloc;
          goto LABEL_232;
        }
      }
      *((_WORD *)v251 + 166) |= 0x80u;
      goto LABEL_231;
    }
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v158 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
      {
        v159 = nw_endpoint_handler_get_id_string(v229);
        v160 = nw_endpoint_handler_dry_run_string(v229);
        buffera = v158;
        v161 = nw_endpoint_handler_copy_endpoint(v229);
        v162 = nw_endpoint_get_logging_description(v161);
        v163 = nw_endpoint_handler_state_string(v229);
        v164 = nw_endpoint_handler_mode_string(v229);
        v165 = nw_endpoint_handler_copy_current_path(v229);
        *(_DWORD *)buf = 136449026;
        *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v159;
        *(_WORD *)&buf[22] = 2082;
        v273 = (uint64_t (*)(uint64_t, uint64_t))v160;
        *(_WORD *)v274 = 2082;
        *(_QWORD *)&v274[2] = v162;
        *(_WORD *)&v274[10] = 2082;
        *(_QWORD *)&v274[12] = v163;
        v275 = 2082;
        v276 = v164;
        v277 = 2114;
        v278 = v165;
        v279 = 2048;
        *(_QWORD *)v280 = v37;
        *(_WORD *)&v280[8] = 2112;
        *(_QWORD *)&v280[10] = data;
        *(_WORD *)&v280[18] = 2048;
        *(_QWORD *)&v280[20] = v246;
        *(_WORD *)&v280[28] = 1024;
        *(_DWORD *)&v280[30] = v252;
        v281 = 1024;
        v282 = v238;
        _os_log_impl(&dword_182FBE000, buffera, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping 0 length frame %p, aggregated_data %@, next_frame %p, aggregrated_amount_read %u, aggregated_data_length %u", buf, 0x72u);

        v158 = buffera;
      }

      v64 = 0;
LABEL_232:
      handle = v251;
      v44 = v63;
LABEL_233:
      v41 = v249;
LABEL_234:
      if (v64 < v41)
        goto LABEL_305;
    }
LABEL_235:
    if (v44 && v243)
    {
      if (*v234 == v44)
      {
        *v234 = 0;

      }
      else
      {
        v128 = *((_QWORD *)handle + 32);
        if (v128)
          nw_dictionary_set_value(v128, out, 0);
      }
    }
    v129 = *(_QWORD *)(v37 + 32);
    v130 = *(nw_frame ***)(v37 + 40);
    if (v129)
    {
      *(_QWORD *)(v129 + 40) = v130;
      v130 = *(nw_frame ***)(v37 + 40);
    }
    else
    {
      v225->tqh_last = v130;
    }
    *v130 = (nw_frame *)v129;
    *v236 = 0;
    *(_QWORD *)(v37 + 40) = 0;
    nw_frame_finalize(v37);
    v12 = v246;

    handle = v251;
    v26 = (void *)*((_QWORD *)v251 + 27);
    if (!v26)
      goto LABEL_346;
    v37 = (uint64_t)v12;
    alloc = (uint64_t)data;
    v36 = v234;
    if (!v12)
      goto LABEL_347;
  }
  v64 = 0;
  if (!v62 || !v41)
    goto LABEL_234;
  v64 = 0;
  v65 = a5;
  if (!v246)
    v65 = 1;
  v227 = v65;
  v67 = v44 == &__block_literal_global_41718 || v44 == &__block_literal_global_5_41741;
  v69 = v44 == &__block_literal_global_3_41726 || v44 == &__block_literal_global_4;
  v230 = v69;
  v231 = v67;
  size = v41;
  while (2)
  {
    v70 = nw_read_request_get_next_max_size(v62);
    v71 = v70;
    if (!v70)
      goto LABEL_234;
    v72 = v41 - v64;
    if (v41 - v64 >= v70)
      v73 = v70;
    else
      v73 = v72;
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v105 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
      {
        log = v105;
        v106 = nw_endpoint_handler_get_id_string(v229);
        v107 = nw_endpoint_handler_dry_run_string(v229);
        v217 = nw_endpoint_handler_copy_endpoint(v229);
        v108 = nw_endpoint_get_logging_description(v217);
        v216 = nw_endpoint_handler_state_string(v229);
        v215 = nw_endpoint_handler_mode_string(v229);
        v109 = nw_endpoint_handler_copy_current_path(v229);
        *(_DWORD *)buf = 136448770;
        *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v106;
        *(_WORD *)&buf[22] = 2082;
        v273 = (uint64_t (*)(uint64_t, uint64_t))v107;
        *(_WORD *)v274 = 2082;
        *(_QWORD *)&v274[2] = v108;
        *(_WORD *)&v274[10] = 2082;
        *(_QWORD *)&v274[12] = v216;
        v275 = 2082;
        v276 = v215;
        v277 = 2114;
        v278 = v109;
        v279 = 1024;
        *(_DWORD *)v280 = v73;
        *(_WORD *)&v280[4] = 1024;
        *(_DWORD *)&v280[6] = v249;
        *(_WORD *)&v280[10] = 1024;
        *(_DWORD *)&v280[12] = v71;
        *(_WORD *)&v280[16] = 1024;
        *(_DWORD *)&v280[18] = v64;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reading %u bytes out of a %u byte frame (max %u, %u so far)", buf, 0x60u);

        v105 = log;
      }

      handle = v251;
      v44 = v63;
    }
    v74 = data;
    if (data)
    {
      if (v238 >= v252 && v73 <= v238 - v252)
      {
        memcpy((void *)(v268 + v252), &buffer[v64], v73);
        v75 = v73;
        goto LABEL_152;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v120 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v73;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v238;
      LOWORD(v273) = 1024;
      *(_DWORD *)((char *)&v273 + 2) = v252;
      v121 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v270 = 0;
      if (__nwlog_fault((const char *)v121, &type, &v270))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v122 = (id)gLogObj;
          v123 = type;
          if (os_log_type_enabled(v122, type))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v73;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v238;
            LOWORD(v273) = 1024;
            *(_DWORD *)((char *)&v273 + 2) = v252;
            _os_log_impl(&dword_182FBE000, v122, v123, "%{public}s Trying to write beyond buffer: %u > %u - %u", buf, 0x1Eu);
          }
          goto LABEL_218;
        }
        if (v270)
        {
          v131 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v132 = (id)gLogObj;
          v133 = type;
          v134 = os_log_type_enabled(v132, type);
          if (v131)
          {
            if (v134)
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v73;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v238;
              LOWORD(v273) = 1024;
              *(_DWORD *)((char *)&v273 + 2) = v252;
              HIWORD(v273) = 2082;
              *(_QWORD *)v274 = v131;
              _os_log_impl(&dword_182FBE000, v132, v133, "%{public}s Trying to write beyond buffer: %u > %u - %u, dumping backtrace:%{public}s", buf, 0x28u);
            }

            free(v131);
            v44 = v63;
            if (!v121)
              goto LABEL_263;
LABEL_262:
            free(v121);
LABEL_263:
            handle = v251;
            goto LABEL_233;
          }
          if (v134)
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v73;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v238;
            LOWORD(v273) = 1024;
            *(_DWORD *)((char *)&v273 + 2) = v252;
            _os_log_impl(&dword_182FBE000, v132, v133, "%{public}s Trying to write beyond buffer: %u > %u - %u, no backtrace", buf, 0x1Eu);
          }

        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v122 = (id)gLogObj;
          v135 = type;
          if (os_log_type_enabled(v122, type))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v73;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v238;
            LOWORD(v273) = 1024;
            *(_DWORD *)((char *)&v273 + 2) = v252;
            _os_log_impl(&dword_182FBE000, v122, v135, "%{public}s Trying to write beyond buffer: %u > %u - %u, backtrace limit exceeded", buf, 0x1Eu);
          }
LABEL_218:

        }
      }
      v44 = v63;
      if (v121)
        goto LABEL_262;
      goto LABEL_263;
    }
    if (nw_frame_buffer_used_malloc(v37)
      && (char *)nw_frame_get_buffer(v37, 0) == buffer
      && !v64
      && (_DWORD)v73 == v249)
    {
      v76 = dispatch_data_create(buffer, size, 0, v221);
      v77 = v76;
      if (data1 && v76)
      {
        v78 = data1;
        concat = dispatch_data_create_concat(data1, v76);
      }
      else
      {
        concat = v76;
        v78 = data1;
      }

      nw_frame_will_free_buffer_externally(v37);
      goto LABEL_149;
    }
    if (nw_frame_buffer_used_manager(v37)
      && (char *)nw_frame_get_buffer(v37, 0) == buffer
      && !v64
      && (_DWORD)v73 == v249)
    {
      finalizer_context = nw_frame_get_finalizer_context(v37);
      v81 = is_inline;
      if (!finalizer_context)
        v81 = 1;
      if ((v81 & 1) == 0)
      {
        manager = nw_frame_buffer_get_manager(v37);
        nw_frame_will_free_buffer_externally(v37);
        v93 = nw_queue_copy_current_workloop();
        v262[0] = MEMORY[0x1E0C809B0];
        v262[1] = 3221225472;
        v262[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_81;
        v262[3] = &__block_descriptor_48_e5_v8__0l;
        v262[4] = manager;
        v262[5] = buffer;
        v94 = dispatch_data_create(buffer, size, (dispatch_queue_t)v93, v262);

        if (data1 && v94)
        {
          v95 = data1;
          concat = dispatch_data_create_concat(data1, v94);
        }
        else
        {
          concat = v94;
          v95 = data1;
        }

LABEL_149:
        v75 = size;
        goto LABEL_150;
      }
    }
    if (v64 || (_DWORD)v73 != v249)
    {
      v83 = &buffer[v64];
      if (!data1)
      {
        *(_QWORD *)buf = 0;
        data1 = dispatch_data_create_alloc();
        memcpy(*(void **)buf, v83, v73);
        v75 = v73;
        v74 = 0;
        goto LABEL_152;
      }
      *(_QWORD *)buf = 0;
      v84 = dispatch_data_create_alloc();
      memcpy(*(void **)buf, v83, v73);
      concat = dispatch_data_create_concat(data1, v84);

      v75 = v73;
LABEL_150:
      data1 = concat;
      goto LABEL_151;
    }
    if (is_inline)
    {
      v82 = size;
      goto LABEL_135;
    }
    v85 = nw_frame_get_buffer_manager_with_context(*((void **)handle + 23), v249);
    *(_QWORD *)buf = 0;
    v82 = size;
    if (v85)
    {
      v86 = v85;
      v87 = nw_mem_buffer_allocate(v85);
      *(_QWORD *)buf = v87;
      if (v87)
      {
        v88 = (const void *)v87;
        v89 = nw_queue_copy_current_workloop();
        v261[0] = MEMORY[0x1E0C809B0];
        v261[1] = 3221225472;
        v261[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_2_82;
        v261[3] = &__block_descriptor_48_e5_v8__0l;
        v261[4] = v86;
        v261[5] = *(_QWORD *)buf;
        v90 = dispatch_data_create(v88, size, (dispatch_queue_t)v89, v261);

        v82 = size;
        goto LABEL_137;
      }
    }
    else
    {
LABEL_135:
      *(_QWORD *)buf = 0;
    }
    v90 = dispatch_data_create_alloc();
LABEL_137:
    memcpy(*(void **)buf, buffer, v82);
    if (data1)
    {
      v91 = dispatch_data_create_concat(data1, v90);

      data1 = v91;
    }
    else
    {
      data1 = v90;
    }

    v75 = size;
LABEL_151:
    v74 = 0;
    handle = v251;
    v44 = v63;
LABEL_152:
    v248->received_application_byte_count += v75;
    if ((*((_BYTE *)v248 + 34) & 0x20) == 0)
      nw_context_count_input_bytes(*((void **)handle + 23), v75);
    v64 += v73;
    v252 += v73;
    if (v74)
    {
      v41 = v249;
      if (v246 && v252 < v238)
        goto LABEL_234;
LABEL_161:
      if (v243)
        v97 = v64 >= v41;
      else
        v97 = 0;
      v98 = v97;
      if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v110 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
        {
          v111 = nw_endpoint_handler_get_id_string(v229);
          v112 = nw_endpoint_handler_dry_run_string(v229);
          v113 = nw_endpoint_handler_copy_endpoint(v229);
          v114 = nw_endpoint_get_logging_description(v113);
          loga = nw_endpoint_handler_state_string(v229);
          v218 = nw_endpoint_handler_mode_string(v229);
          v115 = nw_endpoint_handler_copy_current_path(v229);
          *(_DWORD *)buf = 136448770;
          *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v111;
          *(_WORD *)&buf[22] = 2082;
          v273 = (uint64_t (*)(uint64_t, uint64_t))v112;
          *(_WORD *)v274 = 2082;
          *(_QWORD *)&v274[2] = v114;
          *(_WORD *)&v274[10] = 2082;
          *(_QWORD *)&v274[12] = loga;
          v275 = 2082;
          v276 = v218;
          v277 = 2114;
          v278 = v115;
          v279 = 1024;
          *(_DWORD *)v280 = v98;
          *(_WORD *)&v280[4] = 1024;
          *(_DWORD *)&v280[6] = v243;
          *(_WORD *)&v280[10] = 1024;
          *(_DWORD *)&v280[12] = v64;
          *(_WORD *)&v280[16] = 1024;
          *(_DWORD *)&v280[18] = v249;
          _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] mark_complete: %u, context_complete: %u, amount_read: %u, frame_length: %u", buf, 0x60u);

        }
        v74 = data;
        handle = v251;
        v44 = v63;
      }
      v99 = (void *)*((_QWORD *)handle + 40);
      if (v99 && (*((_BYTE *)v248 + 36) & 2) != 0)
      {
        *((_QWORD *)handle + 40) = 0;

        v100 = v248->last_error;
        v248->last_error = 0;

        *((_BYTE *)v248 + 36) &= ~2u;
        v74 = data;
        handle = v251;
        v44 = v63;
      }
      if (v74)
      {
        request_receive = nw_read_request_receive(*((void **)handle + 27), v74, v44, v98, *((void **)handle + 40));
        goto LABEL_173;
      }
      if (data1)
      {
        request_receive = nw_read_request_receive(*((void **)handle + 27), data1, v44, v98, *((void **)handle + 40));
        v74 = data1;
        data1 = 0;
LABEL_173:

        handle = v251;
        v44 = v63;
      }
      else
      {
        data1 = 0;
      }
      if (v44)
        v102 = v98;
      else
        v102 = 0;
      if (v102 == 1)
      {
        v103 = v44;
        if (v231)
        {

          handle = v251;
          v44 = v63;
        }
        else if (v230)
        {

          handle = v251;
          v44 = v63;
LABEL_183:
          *((_WORD *)handle + 166) |= 0x80u;
        }
        else
        {
          v104 = (BYTE6(v44[14].isa) & 1) == 0;

          handle = v251;
          v44 = v63;
          if (!v104)
            goto LABEL_183;
        }
      }
      data = 0;
      v62 = (void *)*((_QWORD *)handle + 27);
      if (!v62)
        goto LABEL_233;
      v41 = v249;
      if (v64 >= v249)
        goto LABEL_234;
      continue;
    }
    break;
  }
  v96 = v227;
  if (v72 >= v71)
    v96 = 1;
  v41 = v249;
  if (v96 == 1)
    goto LABEL_161;
  data = 0;
  if (v64 >= v249)
    goto LABEL_235;
LABEL_305:
  v171 = nw_endpoint_handler_get_logging_disabled(v229);
  if (v44)
  {
    if ((v171 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v173 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v173, OS_LOG_TYPE_DEBUG))
      {
        v174 = nw_endpoint_handler_get_id_string(v229);
        v175 = nw_endpoint_handler_dry_run_string(v229);
        v253 = nw_endpoint_handler_copy_endpoint(v229);
        v176 = nw_endpoint_get_logging_description(v253);
        v177 = nw_endpoint_handler_state_string(v229);
        v178 = nw_endpoint_handler_mode_string(v229);
        v179 = nw_endpoint_handler_copy_current_path(v229);
        *(_DWORD *)buf = 136448514;
        *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v174;
        *(_WORD *)&buf[22] = 2082;
        v273 = (uint64_t (*)(uint64_t, uint64_t))v175;
        *(_WORD *)v274 = 2082;
        *(_QWORD *)&v274[2] = v176;
        *(_WORD *)&v274[10] = 2082;
        *(_QWORD *)&v274[12] = v177;
        v275 = 2082;
        v276 = v178;
        v277 = 2114;
        v278 = v179;
        v279 = 1024;
        *(_DWORD *)v280 = v64;
        *(_WORD *)&v280[4] = 1024;
        *(_DWORD *)&v280[6] = v249;
        *(_WORD *)&v280[10] = 2082;
        *(_QWORD *)&v280[12] = out;
        _os_log_impl(&dword_182FBE000, v173, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Could not read entire frame (requests only took %u, had %u), saving for context %{public}s", buf, 0x5Eu);

      }
      v44 = v63;
    }
    nw_frame_claim(v37, v172, v64, 0);
    if (a7)
    {
      do
      {
        v181 = (_QWORD *)(v37 + 32);
        v180 = *(void **)(v37 + 32);
        if (!v180 && !*(_QWORD *)(v37 + 40))
          v180 = 0;
        v182 = v180;

        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v250 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v250, OS_LOG_TYPE_DEBUG))
          {
            v244 = nw_endpoint_handler_get_id_string(v229);
            bufferb = nw_endpoint_handler_dry_run_string(v229);
            v237 = nw_endpoint_handler_copy_endpoint(v229);
            v239 = nw_endpoint_get_logging_description(v237);
            v235 = nw_endpoint_handler_state_string(v229);
            sizea = nw_endpoint_handler_mode_string(v229);
            v247 = nw_endpoint_handler_copy_current_path(v229);
            v186 = nw_frame_unclaimed_length((_DWORD *)v37);
            *(_DWORD *)buf = 136448514;
            *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v244;
            *(_WORD *)&buf[22] = 2082;
            v273 = (uint64_t (*)(uint64_t, uint64_t))bufferb;
            *(_WORD *)v274 = 2082;
            *(_QWORD *)&v274[2] = v239;
            *(_WORD *)&v274[10] = 2082;
            *(_QWORD *)&v274[12] = v235;
            v275 = 2082;
            v276 = sizea;
            v277 = 2114;
            v278 = v247;
            v279 = 2048;
            *(_QWORD *)v280 = v37;
            *(_WORD *)&v280[8] = 1024;
            *(_DWORD *)&v280[10] = v186;
            *(_WORD *)&v280[14] = 2082;
            *(_QWORD *)&v280[16] = out;
            _os_log_impl(&dword_182FBE000, v250, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Saving frame %p of length %u for context %{public}s", buf, 0x62u);

          }
        }
        v183 = *(_QWORD *)(v37 + 32);
        v184 = *(nw_frame ***)(v37 + 40);
        if (v183)
        {
          *(_QWORD *)(v183 + 40) = v184;
          v184 = *(nw_frame ***)(v37 + 40);
        }
        else
        {
          v225->tqh_last = v184;
        }
        *v184 = (nw_frame *)v183;
        *v181 = 0;
        *(_QWORD *)(v37 + 40) = 0;
        v185 = (uint64_t *)*((_QWORD *)v251 + 35);
        *(_QWORD *)(v37 + 40) = v185;
        *v185 = v37;
        *((_QWORD *)v251 + 35) = v181;
        v246 = v182;

        v37 = (uint64_t)v246;
      }
      while (v246);
      v246 = 0;
      v44 = v63;
    }
  }
  else
  {
    if ((v171 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v189 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
      {
        v190 = nw_endpoint_handler_get_id_string(v229);
        v191 = nw_endpoint_handler_dry_run_string(v229);
        v254 = nw_endpoint_handler_copy_endpoint(v229);
        v192 = nw_endpoint_get_logging_description(v254);
        v193 = nw_endpoint_handler_state_string(v229);
        v194 = nw_endpoint_handler_mode_string(v229);
        v195 = nw_endpoint_handler_copy_current_path(v229);
        *(_DWORD *)buf = 136448258;
        *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v190;
        *(_WORD *)&buf[22] = 2082;
        v273 = (uint64_t (*)(uint64_t, uint64_t))v191;
        *(_WORD *)v274 = 2082;
        *(_QWORD *)&v274[2] = v192;
        *(_WORD *)&v274[10] = 2082;
        *(_QWORD *)&v274[12] = v193;
        v275 = 2082;
        v276 = v194;
        v277 = 2114;
        v278 = v195;
        v279 = 1024;
        *(_DWORD *)v280 = v64;
        *(_WORD *)&v280[4] = 1024;
        *(_DWORD *)&v280[6] = v249;
        _os_log_impl(&dword_182FBE000, v189, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Could not read entire frame (requests only took %u, had %u)", buf, 0x54u);

      }
      v44 = v63;
    }
    v196 = *(_QWORD *)(v37 + 32);
    v197 = *(nw_frame ***)(v37 + 40);
    if (v196)
    {
      *(_QWORD *)(v196 + 40) = v197;
      v197 = *(nw_frame ***)(v37 + 40);
    }
    else
    {
      v225->tqh_last = v197;
    }
    *v197 = (nw_frame *)v196;
    *v236 = 0;
    *(_QWORD *)(v37 + 40) = 0;
    nw_frame_finalize(v37);
  }

  handle = v251;
  v26 = (void *)*((_QWORD *)v251 + 27);
  v12 = (id)v37;
LABEL_346:
  alloc = (uint64_t)data;
LABEL_347:
  dataa = (dispatch_data_t)alloc;
  v200 = nw_read_request_list_report(v26);
  v201 = (void *)*((_QWORD *)handle + 27);
  *((_QWORD *)handle + 27) = v200;

  if (a7)
  {
    v202 = v225->tqh_first;
    if (v225->tqh_first)
    {
      *(_QWORD *)out = 0;
      *(_QWORD *)&out[8] = out;
      *(_DWORD *)&out[24] = 0;
      *(_QWORD *)&out[16] = 0x2020000000;
      v257[0] = MEMORY[0x1E0C809B0];
      v257[1] = 3221225472;
      v258 = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_83;
      v259 = &unk_1E149C7E8;
      v260 = out;
      do
      {
        if (!v202)
          break;
        v203 = (nw_frame *)*((_QWORD *)v202 + 4);
        v204 = ((uint64_t (*)(_QWORD *))v258)(v257);
        v202 = v203;
      }
      while ((v204 & 1) != 0);
      if ((nw_endpoint_handler_get_logging_disabled(v229) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v205 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v205, OS_LOG_TYPE_ERROR))
        {
          v206 = nw_endpoint_handler_get_id_string(v229);
          v207 = nw_endpoint_handler_dry_run_string(v229);
          v208 = nw_endpoint_handler_copy_endpoint(v229);
          v209 = nw_endpoint_get_logging_description(v208);
          v210 = nw_endpoint_handler_state_string(v229);
          v211 = nw_endpoint_handler_mode_string(v229);
          v212 = nw_endpoint_handler_copy_current_path(v229);
          v213 = *(_DWORD *)(*(_QWORD *)&out[8] + 24);
          *(_DWORD *)buf = 136448002;
          *(_QWORD *)&buf[4] = "nw_flow_process_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v206;
          *(_WORD *)&buf[22] = 2082;
          v273 = (uint64_t (*)(uint64_t, uint64_t))v207;
          *(_WORD *)v274 = 2082;
          *(_QWORD *)&v274[2] = v209;
          *(_WORD *)&v274[10] = 2082;
          *(_QWORD *)&v274[12] = v210;
          v275 = 2082;
          v276 = v211;
          v277 = 2114;
          v278 = v212;
          v279 = 1024;
          *(_DWORD *)v280 = v213;
          _os_log_impl(&dword_182FBE000, v205, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to use %u frames, marking as failed", buf, 0x4Eu);

        }
      }
      _Block_object_dispose(out, 8);
    }
  }

  v199 = data1;
LABEL_360:

LABEL_361:
  return tqh_first != 0;
}

void sub_183013774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,void *a44,void *a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52)
{
  void *v52;
  void *v53;
  void *v54;

  _Unwind_Resume(a1);
}

uint64_t nw_read_request_get_next_max_size(void *a1)
{
  id v1;
  id v2;
  uint64_t v3;
  char *v4;
  void *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  uint64_t v10;

  v1 = a1;
  if (!v1)
    return 0;
  v2 = v1;
  v3 = 0xFFFFFFFFLL;
  while (1)
  {
    v4 = (char *)v2;
    v5 = v4;
    if ((v4[176] & 1) != 0)
      goto LABEL_4;
    v6 = *((_DWORD *)v4 + 17);
    if ((v6 - 1) >= 2)
    {
      if (v6 == 3)
      {
        if (*((_QWORD *)v4 + 10) > *((_QWORD *)v4 + 11))
          goto LABEL_16;
        goto LABEL_4;
      }
      if (v6 != 4)
        goto LABEL_4;
    }
    v7 = *((_QWORD *)v4 + 10);
    v8 = *((_QWORD *)v4 + 11);
    v9 = v7 >= v8;
    v10 = v7 - v8;
    if (v10 != 0 && v9)
      break;
    if (*(_OWORD *)(v4 + 72) == 0)
    {
      v3 = 0;
      goto LABEL_16;
    }
LABEL_4:
    v2 = *((id *)v4 + 1);

    if (!v2)
      return 0;
  }
  if (v9)
    v3 = v10;
  else
    v3 = 0;
LABEL_16:

  return v3;
}

uint64_t nw_frame_get_buffer(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && g_channel_check_validity
      && (g_channel_check_validity(a1, *(_QWORD *)(a1 + 88)) & 1) == 0)
    {
      result = 0;
      if (a2)
        *a2 = 0;
    }
    else
    {
      if (a2)
        *a2 = *(_DWORD *)(a1 + 48);
      return *(_QWORD *)(a1 + 112);
    }
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "__nw_frame_get_buffer";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "__nw_frame_get_buffer";
        v8 = "%{public}s called with null frame";
LABEL_24:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "__nw_frame_get_buffer";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_25;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "__nw_frame_get_buffer";
        v8 = "%{public}s called with null frame, no backtrace";
        goto LABEL_24;
      }
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "__nw_frame_get_buffer";
        v8 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
LABEL_25:
  if (v5)
    free(v5);
  return 0;
}

void nw_frame_will_free_buffer_externally(uint64_t a1)
{
  int v1;
  int v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_QWORD *)(a1 + 104))
    {
      *(_QWORD *)(a1 + 104) = 0;
      *(_QWORD *)(a1 + 112) = 0;
      return;
    }
    v1 = *(unsigned __int16 *)(a1 + 204);
    v2 = v1 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v1 & 1) != 0)
    {
      *(_BYTE *)(a1 + 206) = BYTE2(v2);
      *(_WORD *)(a1 + 204) = v2 & 0xFFFE;
      *(_QWORD *)(a1 + 112) = 0;
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_frame_will_free_buffer_externally";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (__nwlog_fault(v3, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_20;
        *(_DWORD *)buf = 136446210;
        v14 = "nw_frame_will_free_buffer_externally";
        v6 = "%{public}s Frame buffer cannot be freed externally";
        goto LABEL_19;
      }
      if (!v11)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_20;
        *(_DWORD *)buf = 136446210;
        v14 = "nw_frame_will_free_buffer_externally";
        v6 = "%{public}s Frame buffer cannot be freed externally, backtrace limit exceeded";
        goto LABEL_19;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      v8 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!backtrace_string)
      {
        if (!v8)
          goto LABEL_20;
        *(_DWORD *)buf = 136446210;
        v14 = "nw_frame_will_free_buffer_externally";
        v6 = "%{public}s Frame buffer cannot be freed externally, no backtrace";
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446466;
        v14 = "nw_frame_will_free_buffer_externally";
        v15 = 2082;
        v16 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s Frame buffer cannot be freed externally, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
    }
LABEL_20:
    if (!v3)
      return;
    goto LABEL_21;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_frame_will_free_buffer_externally";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_20;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_20;
    *(_DWORD *)buf = 136446210;
    v14 = "nw_frame_will_free_buffer_externally";
    v6 = "%{public}s called with null frame";
    goto LABEL_19;
  }
  if (!v11)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_20;
    *(_DWORD *)buf = 136446210;
    v14 = "nw_frame_will_free_buffer_externally";
    v6 = "%{public}s called with null frame, backtrace limit exceeded";
    goto LABEL_19;
  }
  v9 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v10 = os_log_type_enabled(v4, type);
  if (!v9)
  {
    if (!v10)
      goto LABEL_20;
    *(_DWORD *)buf = 136446210;
    v14 = "nw_frame_will_free_buffer_externally";
    v6 = "%{public}s called with null frame, no backtrace";
LABEL_19:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_20;
  }
  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    v14 = "nw_frame_will_free_buffer_externally";
    v15 = 2082;
    v16 = v9;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v9);
  if (v3)
LABEL_21:
    free(v3);
}

uint64_t nw_frame_buffer_used_malloc(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_WORD *)(a1 + 204) & 1;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_frame_buffer_used_malloc";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_frame_buffer_used_malloc";
        v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_frame_buffer_used_malloc";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_frame_buffer_used_malloc";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_frame_buffer_used_malloc";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

void nw_context_count_input_bytes(void *a1, unint64_t a2)
{
  NWConcrete_nw_context *v3;
  NWConcrete_nw_context *v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  NSObject *v12;
  uint64_t v13;
  void *v14;
  _BOOL8 v15;

  v3 = a1;
  v4 = v3;
  if (g_some_context_has_cap == 1)
  {
    nw_context_assert_queue(v3);
    v15 = nw_context_copy_globals_context(v4);

    v3 = (NWConcrete_nw_context *)v15;
    v5 = *(_QWORD *)(v15 + 32);
    v6 = *(_QWORD *)(v5 + 76);
    if (v6)
    {
      v7 = v6 > a2;
      v8 = v6 - a2;
      if (v7)
      {
        *(_QWORD *)(v5 + 76) = v8;
      }
      else
      {
        *(_QWORD *)(v5 + 76) = 0;
        v9 = _Block_copy(*(const void **)(v5 + 92));
        v10 = *(_QWORD *)(v15 + 32);
        v11 = *(void **)(v10 + 84);
        *(_QWORD *)(v10 + 84) = 0;
        v12 = v11;

        v13 = *(_QWORD *)(v15 + 32);
        v14 = *(void **)(v13 + 92);
        *(_QWORD *)(v13 + 92) = 0;

        dispatch_async(v12, v9);
        v3 = (NWConcrete_nw_context *)v15;
      }
    }
  }

}

void sub_1830144D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_queue_copy_current_workloop()
{
  uint64_t v0;
  _BOOL8 result;
  NSObject *v2;
  void *v3;

  v0 = dispatch_workloop_copy_current();
  if (v0)
    return v0;
  __nwlog_obj();
  v2 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  v3 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
    return v0;
  }
  __break(1u);
  return result;
}

uint64_t nw_frame_buffer_get_manager(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_QWORD *)(a1 + 104);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_buffer_get_manager";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_buffer_get_manager";
        v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "__nw_frame_buffer_get_manager";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_buffer_get_manager";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_buffer_get_manager";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

BOOL nw_frame_buffer_used_manager(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_QWORD *)(a1 + 104) != 0;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_buffer_used_manager";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_buffer_used_manager";
        v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "__nw_frame_buffer_used_manager";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_buffer_used_manager";
        v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "__nw_frame_buffer_used_manager";
        v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

NSObject *nw_read_request_receive(void *a1, void *a2, void *a3, int a4, void *a5)
{
  id v9;
  NSObject *v10;
  id v11;
  id v12;
  char v13;
  id *v14;
  id *v15;
  id v16;
  id *v17;
  size_t size;
  unsigned int v20;
  NSObject *v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  size_t v25;
  size_t v26;
  uint64_t *v27;
  NSObject *v28;
  size_t v29;
  size_t v30;
  int v31;
  unsigned int *v32;
  char *v33;
  uint64_t v34;
  unsigned int *v35;
  _QWORD *v36;
  uint64_t v37;
  NSObject *v38;
  int v39;
  id v40;
  uint64_t v41;
  void *v42;
  uint64_t source;
  dispatch_time_t v44;
  uint64_t v45;
  id v46;
  void *v47;
  NSObject *v48;
  os_log_type_t v49;
  uint64_t v50;
  NSObject *v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  size_t v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  os_log_type_t v60;
  void *v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  char *backtrace_string;
  NSObject *v66;
  os_log_type_t v67;
  _BOOL4 v68;
  os_log_type_t v69;
  unint64_t v70;
  unint64_t v71;
  BOOL v72;
  size_t v73;
  size_t v74;
  size_t v75;
  dispatch_data_t v76;
  dispatch_data_t subrange;
  NSObject *v78;
  dispatch_data_t concat;
  id v80;
  uint64_t v81;
  id v82;
  unsigned int v83;
  BOOL v84;
  int v85;
  NSObject *v86;
  NSObject *log;
  id v89;
  int v90;
  id v91;
  id obj;
  int v93;
  _QWORD applier[4];
  unsigned int *v95;
  uint64_t *v96;
  uint64_t *v97;
  uint64_t *v98;
  size_t v99;
  int v100;
  uint64_t v101;
  uint64_t *v102;
  uint64_t v103;
  int v104;
  char v105;
  id location;
  os_log_type_t type;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t (*v111)(uint64_t, uint64_t);
  void (*v112)(uint64_t);
  NSObject *v113;
  size_t v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  _BYTE v119[24];
  void *v120;
  id v121[2];
  uint8_t buf[4];
  const char *v123;
  __int16 v124;
  _BYTE v125[14];
  uint64_t v126;

  v126 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a2;
  obj = a3;
  v11 = a3;
  v91 = a5;
  v12 = a5;
  if (v9)
  {
    v90 = a4;
    v93 = a4 ^ 1;
    v13 = 1;
    while (1)
    {
      v14 = (id *)v9;
      v15 = v14;
      if (((_BYTE)v14[22] & 1) == 0)
        break;
LABEL_158:
      v9 = v15[1];

      if (!v9)
        goto LABEL_159;
    }
    v17 = v14 + 17;
    v16 = v14[17];
    if (v16 != v11 && ((v16 == 0) & v13) == 0)
    {
LABEL_141:
      if (!v11 || *v17 == v11)
      {
        v83 = *((_DWORD *)v15 + 17);
        v84 = v83 != 4 && v10 == 0;
        v85 = v93;
        if (!v84)
          v85 = 1;
        if (v85 != 1 || v83 == 4 && (v15[10] <= v15[11] || v90))
        {
          *((_BYTE *)v15 + 176) |= 2u;
          if (_nw_signposts_once != -1)
            dispatch_once(&_nw_signposts_once, &__block_literal_global_51698);
          if (_nw_signposts_enabled && kdebug_is_enabled())
            kdebug_trace();
        }
      }
      v13 |= v10 != 0;
      goto LABEL_158;
    }
    objc_storeStrong(v14 + 17, obj);
    if (v12)
      objc_storeStrong(v15 + 19, v91);
    if (!v10 || (size = dispatch_data_get_size(v10)) == 0)
    {
LABEL_140:
      v13 = 0;
      goto LABEL_141;
    }
    v20 = *((_DWORD *)v15 + 17);
    if (v20 - 1 >= 2)
    {
      if (v20 == 3)
      {
        if (v15[11] >= v15[10])
          goto LABEL_135;
        nw_array_append((uint64_t)v15[20], v10);
        nw_array_append((uint64_t)v15[21], v11);
        v15[11] = (char *)v15[11] + 1;

        v80 = v15[17];
        v15[17] = 0;

        if (_nw_signposts_once != -1)
          dispatch_once(&_nw_signposts_once, &__block_literal_global_51698);
        if (!_nw_signposts_enabled)
        {
          v10 = 0;
LABEL_137:
          if (_nw_signposts_enabled && kdebug_is_enabled())
            kdebug_trace();
          goto LABEL_140;
        }
        if (kdebug_is_enabled())
        {
          v10 = 0;
          kdebug_trace();
          goto LABEL_135;
        }
LABEL_120:
        v10 = 0;
LABEL_135:
        if (_nw_signposts_once != -1)
          dispatch_once(&_nw_signposts_once, &__block_literal_global_51698);
        goto LABEL_137;
      }
      if (v20 != 4)
        goto LABEL_135;
      v108 = 0;
      v109 = (uint64_t)&v108;
      v110 = 0x3032000000;
      v111 = __Block_byref_object_copy__51808;
      v112 = __Block_byref_object_dispose__51809;
      v21 = v10;
      v113 = v21;
      v23 = (unint64_t)v15[10];
      v22 = (unint64_t)v15[11];
      v24 = v23 >= v22;
      v25 = v23 - v22;
      if (v25 == 0 || !v24)
      {
LABEL_119:

        _Block_object_dispose(&v108, 8);
        goto LABEL_120;
      }
      if (v24)
        v26 = v25;
      else
        v26 = 0;
      v115 = 0;
      v116 = &v115;
      v117 = 0x2020000000;
      v27 = &v118;
      LOBYTE(v118) = 0;
      v89 = v12;
      while (1)
      {
        v101 = 0;
        v102 = &v101;
        v104 = 0;
        v103 = 0x2020000000;
        *(_BYTE *)v27 = 0;
        v28 = *(NSObject **)(v109 + 40);
        v29 = dispatch_data_get_size(v28);
        v30 = v29;
        applier[0] = MEMORY[0x1E0C809B0];
        if (v26 >= v29)
          v31 = v29;
        else
          v31 = v26;
        applier[1] = 3221225472;
        applier[2] = __nw_read_request_receive_block_invoke;
        applier[3] = &unk_1E14A4900;
        v100 = v31;
        v32 = v15;
        v95 = v32;
        v96 = &v108;
        v97 = &v101;
        v98 = &v115;
        v99 = v30;
        dispatch_data_apply(v28, applier);
        v33 = (char *)v15[11] + *((unsigned int *)v102 + 6);
        v15[11] = v33;
        if (!v33 || ((_BYTE)v15[22] & 4) != 0)
          goto LABEL_49;
        v35 = v32;
        v36 = v15[7];
        if (!v36)
        {
          __nwlog_obj();
          v61 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v123 = "nw_read_request_start_file_updates";
          v62 = (char *)_os_log_send_and_compose_impl();

          LOBYTE(location) = 16;
          type = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v62, &location, &type))
          {
            if (location == 17)
            {
              __nwlog_obj();
              v63 = objc_claimAutoreleasedReturnValue();
              v64 = location;
              if (os_log_type_enabled(v63, (os_log_type_t)location))
              {
                *(_DWORD *)buf = 136446210;
                v123 = "nw_read_request_start_file_updates";
                _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s called with null request->connection", buf, 0xCu);
              }
              goto LABEL_87;
            }
            if (type)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v66 = objc_claimAutoreleasedReturnValue();
              v67 = location;
              log = v66;
              v68 = os_log_type_enabled(v66, (os_log_type_t)location);
              if (backtrace_string)
              {
                if (v68)
                {
                  *(_DWORD *)buf = 136446466;
                  v123 = "nw_read_request_start_file_updates";
                  v124 = 2082;
                  *(_QWORD *)v125 = backtrace_string;
                  _os_log_impl(&dword_182FBE000, log, v67, "%{public}s called with null request->connection, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(backtrace_string);
              }
              else
              {
                if (v68)
                {
                  *(_DWORD *)buf = 136446210;
                  v123 = "nw_read_request_start_file_updates";
                  _os_log_impl(&dword_182FBE000, log, v67, "%{public}s called with null request->connection, no backtrace", buf, 0xCu);
                }

              }
            }
            else
            {
              __nwlog_obj();
              v63 = objc_claimAutoreleasedReturnValue();
              v69 = location;
              if (os_log_type_enabled(v63, (os_log_type_t)location))
              {
                *(_DWORD *)buf = 136446210;
                v123 = "nw_read_request_start_file_updates";
                _os_log_impl(&dword_182FBE000, v63, v69, "%{public}s called with null request->connection, backtrace limit exceeded", buf, 0xCu);
              }
LABEL_87:

            }
          }
          if (v62)
            free(v62);
          goto LABEL_48;
        }
        *((_BYTE *)v15 + 176) |= 4u;
        v37 = v36[2];
        if (v37 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v37 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v38 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
          {
            v39 = *((_DWORD *)v15[7] + 112);
            v40 = v15[12];
            *(_DWORD *)buf = 136446722;
            v123 = "nw_read_request_start_file_updates";
            v124 = 1024;
            *(_DWORD *)v125 = v39;
            *(_WORD *)&v125[4] = 2112;
            *(_QWORD *)&v125[6] = v40;
            _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Activating progress updates on read request on %@", buf, 0x1Cu);
          }

        }
        v41 = (uint64_t)v15[13];
        if (v41)
        {
          nw_queue_cancel_source(v41, v34);
          v15[13] = 0;
        }
        objc_initWeak(&location, v35);
        v42 = (void *)*((_QWORD *)v15[7] + 3);
        *(_QWORD *)v119 = MEMORY[0x1E0C809B0];
        *(_QWORD *)&v119[8] = 3221225472;
        *(_QWORD *)&v119[16] = ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke;
        v120 = &unk_1E14A49C0;
        objc_copyWeak(v121, &location);
        source = nw_queue_context_create_source(v42, 2, 3, 0, v119, 0);
        v15[13] = (id)source;
        if (source)
        {
          v44 = dispatch_time(0x8000000000000000, 1000000);
          v45 = 1000000 * *((unsigned int *)v15 + 28);
          if (*(_QWORD *)source)
          {
            dispatch_source_set_timer(*(dispatch_source_t *)source, v44, v45, 0x3E8uLL);
          }
          else
          {
            *(_QWORD *)(source + 32) = v44;
            *(_QWORD *)(source + 40) = v45;
            if (*(_BYTE *)(source + 48) && *(_BYTE *)(source + 49))
              nw_queue_source_run_timer(source, v44);
          }
          nw_queue_activate_source((uint64_t)v15[13], v44);
          goto LABEL_47;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v46 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v123 = "nw_read_request_start_file_updates";
        v47 = (void *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v105 = 0;
        if (__nwlog_fault((const char *)v47, &type, &v105))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = (id)gLogObj;
            v49 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              v123 = "nw_read_request_start_file_updates";
              _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed", buf, 0xCu);
            }
LABEL_44:

            goto LABEL_45;
          }
          if (!v105)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = (id)gLogObj;
            v60 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              v123 = "nw_read_request_start_file_updates";
              _os_log_impl(&dword_182FBE000, v48, v60, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_44;
          }
          v56 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = (id)gLogObj;
          v58 = type;
          v59 = os_log_type_enabled(v57, type);
          if (v56)
          {
            if (v59)
            {
              *(_DWORD *)buf = 136446466;
              v123 = "nw_read_request_start_file_updates";
              v124 = 2082;
              *(_QWORD *)v125 = v56;
              _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            v12 = v89;
            free(v56);
            if (!v47)
              goto LABEL_47;
LABEL_46:
            free(v47);
            goto LABEL_47;
          }
          if (v59)
          {
            *(_DWORD *)buf = 136446210;
            v123 = "nw_read_request_start_file_updates";
            _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed, no backtrace", buf, 0xCu);
          }

          v12 = v89;
        }
LABEL_45:
        if (v47)
          goto LABEL_46;
LABEL_47:
        objc_destroyWeak(v121);
        objc_destroyWeak(&location);
LABEL_48:

LABEL_49:
        if (*((_BYTE *)v116 + 24))
        {
          if (*(_QWORD *)(v109 + 40))
          {
            v50 = *((_QWORD *)v15[7] + 2);
            if (v50)
            {
              if (!nw_path_parameters_get_logging_disabled(*(_QWORD *)(v50 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v51 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                {
                  v52 = *((_DWORD *)v15[7] + 112);
                  *(_DWORD *)v119 = 136446466;
                  *(_QWORD *)&v119[4] = "nw_read_request_receive";
                  *(_WORD *)&v119[12] = 1024;
                  *(_DWORD *)&v119[14] = v52;
                  _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Retrying write to file descriptor, partial write without eof", v119, 0x12u);
                }

              }
            }
          }
        }
        v54 = (unint64_t)v15[10];
        v53 = (unint64_t)v15[11];
        v24 = v54 >= v53;
        v55 = v54 - v53;
        if (v24)
          v26 = v55;
        else
          v26 = 0;
        if (_nw_signposts_once != -1)
          dispatch_once(&_nw_signposts_once, &__block_literal_global_51698);
        if (_nw_signposts_enabled && kdebug_is_enabled())
          kdebug_trace();

        _Block_object_dispose(&v101, 8);
        v27 = v116 + 3;
        if (!*((_BYTE *)v116 + 24))
        {
          _Block_object_dispose(&v115, 8);
          goto LABEL_119;
        }
      }
    }
    v71 = (unint64_t)v15[10];
    v70 = (unint64_t)v15[11];
    v24 = v71 >= v70;
    v73 = v71 - v70;
    v72 = v73 != 0 && v24;
    if (!v24)
      v73 = 0;
    if (!v72)
      goto LABEL_135;
    v74 = size;
    if (v73 >= size)
      v75 = size;
    else
      v75 = v73;
    if (v20 == 2)
    {
      v81 = (uint64_t)v15[15] + v70;
      *(_QWORD *)v119 = 0;
      *(_QWORD *)&v119[8] = v119;
      *(_QWORD *)&v119[16] = 0x2000000000;
      v120 = 0;
      v115 = 0;
      v116 = &v115;
      v117 = 0x2000000000;
      v118 = v81;
      v108 = MEMORY[0x1E0C809B0];
      v109 = 0x40000000;
      v110 = (uint64_t)__nw_dispatch_data_copyout_block_invoke;
      v111 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E14A3448;
      v113 = &v115;
      v114 = v75;
      v112 = (void (*)(uint64_t))v119;
      dispatch_data_apply(v10, &v108);
      v75 = *(_QWORD *)(*(_QWORD *)&v119[8] + 24);
      _Block_object_dispose(&v115, 8);
      _Block_object_dispose(v119, 8);
      if (v74 == v75)
      {
        subrange = 0;
        v75 = v74;
      }
      else
      {
        subrange = dispatch_data_create_subrange(v10, v75, v74 - v75);
      }
      goto LABEL_129;
    }
    if (v20 != 1)
    {
      v75 = 0;
LABEL_130:
      v15[11] = (char *)v15[11] + v75;
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_51698);
      if (!_nw_signposts_enabled)
        goto LABEL_137;
      if (kdebug_is_enabled())
        kdebug_trace();
      goto LABEL_135;
    }
    if (size <= v73)
    {
      subrange = 0;
      v78 = v15[16];
      if (!v78)
        goto LABEL_112;
    }
    else
    {
      v76 = dispatch_data_create_subrange(v10, 0, v75);
      subrange = dispatch_data_create_subrange(v10, v75, v74 - v75);

      v10 = v76;
      v78 = v15[16];
      if (!v78)
      {
LABEL_112:
        concat = v10;
LABEL_127:
        v82 = v15[16];
        v15[16] = concat;

LABEL_129:
        v10 = subrange;
        goto LABEL_130;
      }
    }
    concat = dispatch_data_create_concat(v78, v10);
    goto LABEL_127;
  }
LABEL_159:
  v86 = v10;

  return v86;
}

void sub_1830158E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id *location,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,id a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  void *v51;
  void *v52;
  void *v53;
  void *v54;

  _Unwind_Resume(a1);
}

nw_content_context_t nw_content_context_create(const char *context_identifier)
{
  NWConcrete_nw_content_context *v2;
  const char *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  nw_content_context_t result;
  id v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  NSObject *v40;
  void *v41;
  char *backtrace_string;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  char v46;
  os_log_type_t type;
  objc_super v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v2 = [NWConcrete_nw_content_context alloc];
  if (!v2)
    return 0;
  v48.receiver = v2;
  v48.super_class = (Class)NWConcrete_nw_content_context;
  v3 = objc_msgSendSuper2(&v48, sel_init);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v36 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
    v37 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if ((__nwlog_fault(v37, &type, &v46) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        v39 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
          _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        v43 = type;
        v44 = os_log_type_enabled(v38, type);
        if (backtrace_string)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
            v51 = 2082;
            v52 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v38, v43, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
          _os_log_impl(&dword_182FBE000, v38, v43, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        v45 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
          _os_log_impl(&dword_182FBE000, v38, v45, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_56:
    if (v37)
      free(v37);
    return 0;
  }
  if (context_identifier)
    goto LABEL_4;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v40 = (id)gLogObj;
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v50 = "_strict_strlcpy";
  v41 = (void *)_os_log_send_and_compose_impl();

  result = (nw_content_context_t)__nwlog_abort((uint64_t)v41);
  if (!(_DWORD)result)
  {
    free(v41);
LABEL_4:
    v4 = *(unsigned __int8 *)context_identifier;
    *((_BYTE *)v3 + 24) = v4;
    if (v4)
    {
      v5 = *((unsigned __int8 *)context_identifier + 1);
      *((_BYTE *)v3 + 25) = v5;
      if (v5)
      {
        v6 = *((unsigned __int8 *)context_identifier + 2);
        *((_BYTE *)v3 + 26) = v6;
        if (v6)
        {
          v7 = *((unsigned __int8 *)context_identifier + 3);
          *((_BYTE *)v3 + 27) = v7;
          if (v7)
          {
            v8 = *((unsigned __int8 *)context_identifier + 4);
            *((_BYTE *)v3 + 28) = v8;
            if (v8)
            {
              v9 = *((unsigned __int8 *)context_identifier + 5);
              *((_BYTE *)v3 + 29) = v9;
              if (v9)
              {
                v10 = *((unsigned __int8 *)context_identifier + 6);
                *((_BYTE *)v3 + 30) = v10;
                if (v10)
                {
                  v11 = *((unsigned __int8 *)context_identifier + 7);
                  *((_BYTE *)v3 + 31) = v11;
                  if (v11)
                  {
                    v12 = *((unsigned __int8 *)context_identifier + 8);
                    *((_BYTE *)v3 + 32) = v12;
                    if (v12)
                    {
                      v13 = *((unsigned __int8 *)context_identifier + 9);
                      *((_BYTE *)v3 + 33) = v13;
                      if (v13)
                      {
                        v14 = *((unsigned __int8 *)context_identifier + 10);
                        *((_BYTE *)v3 + 34) = v14;
                        if (v14)
                        {
                          v15 = *((unsigned __int8 *)context_identifier + 11);
                          *((_BYTE *)v3 + 35) = v15;
                          if (v15)
                          {
                            v16 = *((unsigned __int8 *)context_identifier + 12);
                            *((_BYTE *)v3 + 36) = v16;
                            if (v16)
                            {
                              v17 = *((unsigned __int8 *)context_identifier + 13);
                              *((_BYTE *)v3 + 37) = v17;
                              if (v17)
                              {
                                v18 = *((unsigned __int8 *)context_identifier + 14);
                                *((_BYTE *)v3 + 38) = v18;
                                if (v18)
                                {
                                  v19 = *((unsigned __int8 *)context_identifier + 15);
                                  *((_BYTE *)v3 + 39) = v19;
                                  if (v19)
                                  {
                                    v20 = *((unsigned __int8 *)context_identifier + 16);
                                    *((_BYTE *)v3 + 40) = v20;
                                    if (v20)
                                    {
                                      v21 = *((unsigned __int8 *)context_identifier + 17);
                                      *((_BYTE *)v3 + 41) = v21;
                                      if (v21)
                                      {
                                        v22 = *((unsigned __int8 *)context_identifier + 18);
                                        *((_BYTE *)v3 + 42) = v22;
                                        if (v22)
                                        {
                                          v23 = *((unsigned __int8 *)context_identifier + 19);
                                          *((_BYTE *)v3 + 43) = v23;
                                          if (v23)
                                          {
                                            v24 = *((unsigned __int8 *)context_identifier + 20);
                                            *((_BYTE *)v3 + 44) = v24;
                                            if (v24)
                                            {
                                              v25 = *((unsigned __int8 *)context_identifier + 21);
                                              *((_BYTE *)v3 + 45) = v25;
                                              if (v25)
                                              {
                                                v26 = *((unsigned __int8 *)context_identifier + 22);
                                                *((_BYTE *)v3 + 46) = v26;
                                                if (v26)
                                                {
                                                  v27 = *((unsigned __int8 *)context_identifier + 23);
                                                  *((_BYTE *)v3 + 47) = v27;
                                                  if (v27)
                                                  {
                                                    v28 = *((unsigned __int8 *)context_identifier + 24);
                                                    *((_BYTE *)v3 + 48) = v28;
                                                    if (v28)
                                                    {
                                                      v29 = *((unsigned __int8 *)context_identifier + 25);
                                                      *((_BYTE *)v3 + 49) = v29;
                                                      if (v29)
                                                      {
                                                        v30 = *((unsigned __int8 *)context_identifier + 26);
                                                        *((_BYTE *)v3 + 50) = v30;
                                                        if (v30)
                                                        {
                                                          v31 = *((unsigned __int8 *)context_identifier + 27);
                                                          *((_BYTE *)v3 + 51) = v31;
                                                          if (v31)
                                                          {
                                                            v32 = *((unsigned __int8 *)context_identifier + 28);
                                                            *((_BYTE *)v3 + 52) = v32;
                                                            if (v32)
                                                            {
                                                              v33 = *((unsigned __int8 *)context_identifier + 29);
                                                              *((_BYTE *)v3 + 53) = v33;
                                                              if (v33)
                                                              {
                                                                v34 = *((unsigned __int8 *)context_identifier + 30);
                                                                *((_BYTE *)v3 + 54) = v34;
                                                                if (v34)
                                                                  *((_BYTE *)v3 + 55) = 0;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    *((_QWORD *)v3 + 10) = 0x3FE0000000000000;
    return (nw_content_context_t)v3;
  }
  __break(1u);
  return result;
}

void sub_183015ED0(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void nw_content_context_set_is_final(nw_content_context_t context, BOOL is_final)
{
  nw_content_context_t v3;
  nw_content_context_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = context;
  v4 = v3;
  if (v3)
  {
    if (v3 != (nw_content_context_t)&__block_literal_global_5_41741
      && v3 != (nw_content_context_t)&__block_literal_global_4
      && v3 != (nw_content_context_t)&__block_literal_global_3_41726
      && v3 != (nw_content_context_t)&__block_literal_global_41718)
    {
      BYTE6(v3[14].isa) = BYTE6(v3[14].isa) & 0xFE | is_final;
    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_content_context_set_is_final";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_content_context_set_is_final";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_content_context_set_is_final";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_content_context_set_is_final";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_content_context_set_is_final";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v6)
    free(v6);
LABEL_7:

}

uint64_t nw_quic_stream_get_associated_stream_id(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_associated_stream_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_associated_stream_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_associated_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_stream(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_associated_stream_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_associated_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_associated_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_stream(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830164B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_tcp_options_set_no_delay(nw_protocol_options_t options, BOOL no_delay)
{
  NSObject *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  BOOL v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_no_delay_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = no_delay;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_tcp_options_set_no_delay";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_no_delay";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_tcp_options_set_no_delay";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_no_delay";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_no_delay";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1830167B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_ip_options_get_corrupt_checksums(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_corrupt_checksums_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_ip_options_get_corrupt_checksums";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_corrupt_checksums";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_ip_options_get_corrupt_checksums";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_corrupt_checksums";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_corrupt_checksums";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183016AC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_ip_options_get_calculate_receive_time(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_calculate_receive_time_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_ip_options_get_calculate_receive_time";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_calculate_receive_time";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_ip_options_get_calculate_receive_time";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_calculate_receive_time";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_calculate_receive_time";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183016DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void __nw_resolver_set_update_handler_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  const char *v5;
  NSObject *v6;
  uint32_t v7;
  int v8;
  nw_endpoint_type_t type;
  uint64_t v10;
  int required_address_family;
  int v12;
  uint64_t v13;
  void *v14;
  id *v15;
  id v16;
  id *v17;
  id v18;
  id v19;
  int v20;
  id *v21;
  int v22;
  void **v23;
  void (**v24)(void *, void *, _BOOL8, _BYTE *);
  void *v25;
  _BOOL8 v26;
  void **v27;
  id *v28;
  int v29;
  int v30;
  int scoped_interface_index;
  void *v32;
  NSObject *v33;
  NSObject *v34;
  _QWORD *v35;
  uint64_t v36;
  char v37;
  NSObject *v38;
  uint64_t v39;
  const char *v40;
  NSObject *v41;
  uint32_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t cached_content_for_protocol;
  id *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned __int8 *v51;
  int v52;
  uint64_t v53;
  void *v54;
  NSObject *v55;
  NSObject *v56;
  char v57;
  NSObject *v58;
  uint64_t v59;
  id v60;
  const char *v61;
  NSObject *v62;
  uint32_t v63;
  int v64;
  id v65;
  id v66;
  int dns_getaddrinfo_locked;
  void *v68;
  void *v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  char *backtrace_string;
  os_log_type_t v74;
  _BOOL4 v75;
  os_log_type_t v76;
  _QWORD v77[4];
  id v78;
  _QWORD v79[6];
  _QWORD v80[4];
  id v81;
  uint64_t v82;
  unsigned int v83;
  _QWORD v84[4];
  id v85;
  _BYTE *v86;
  _BYTE *v87;
  _BYTE *v88;
  char v89;
  uint8_t v90[4];
  const char *v91;
  __int16 v92;
  _BYTE v93[18];
  _BYTE buf[24];
  uint64_t (*v95)(uint64_t, uint64_t);
  void (*v96)(uint64_t);
  id v97;
  _BYTE v98[32];
  _BYTE v99[24];
  char v100;
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 12));
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 347) & 0x10) != 0 && (*(_BYTE *)(v2 + 346) & 0x20) == 0)
  {
    if (*(_BYTE *)(v2 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v3 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        goto LABEL_11;
      v4 = *(_QWORD *)(a1 + 32) + 256;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_resolver_set_update_handler_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v4;
      v5 = "%{public}s [C%{public}s] started";
      v6 = v3;
      v7 = 22;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = (id)gLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
LABEL_11:

        v2 = *(_QWORD *)(a1 + 32);
        goto LABEL_12;
      }
      v8 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 340);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_resolver_set_update_handler_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      v5 = "%{public}s [R%u] started";
      v6 = v3;
      v7 = 18;
    }
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, v5, buf, v7);
    goto LABEL_11;
  }
LABEL_12:
  if (!*(_QWORD *)(v2 + 96))
    goto LABEL_124;
  if ((*(_BYTE *)(v2 + 346) & 1) != 0)
  {
    v23 = (void **)(id)v2;
    nw_context_assert_queue(v23[4]);
    v24 = (void (**)(void *, void *, _BOOL8, _BYTE *))nw_endpoint_copy_custom_resolver_block(v23[3]);
    if (v24)
    {
      v25 = v23[3];
      v26 = nw_context_copy_workloop(v23[4]);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = ___ZL40nw_resolver_start_custom_resolver_lockedP22NWConcrete_nw_resolver_block_invoke;
      v95 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E149AD50;
      v27 = v23;
      v96 = (void (*)(uint64_t))v27;
      v24[2](v24, v25, v26, buf);

      goto LABEL_124;
    }
    __nwlog_obj();
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v99 = 136446210;
    *(_QWORD *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
    v70 = (char *)_os_log_send_and_compose_impl();

    v98[0] = 16;
    v90[0] = 0;
    if (__nwlog_fault(v70, v98, v90))
    {
      if (v98[0] == 17)
      {
        __nwlog_obj();
        v71 = objc_claimAutoreleasedReturnValue();
        v72 = v98[0];
        if (os_log_type_enabled(v71, (os_log_type_t)v98[0]))
        {
          *(_DWORD *)v99 = 136446210;
          *(_QWORD *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
          _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s called with null resolver_block", v99, 0xCu);
        }
      }
      else if (v90[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v71 = objc_claimAutoreleasedReturnValue();
        v74 = v98[0];
        v75 = os_log_type_enabled(v71, (os_log_type_t)v98[0]);
        if (backtrace_string)
        {
          if (v75)
          {
            *(_DWORD *)v99 = 136446466;
            *(_QWORD *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
            *(_WORD *)&v99[12] = 2082;
            *(_QWORD *)&v99[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v71, v74, "%{public}s called with null resolver_block, dumping backtrace:%{public}s", v99, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_141;
        }
        if (v75)
        {
          *(_DWORD *)v99 = 136446210;
          *(_QWORD *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
          _os_log_impl(&dword_182FBE000, v71, v74, "%{public}s called with null resolver_block, no backtrace", v99, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v71 = objc_claimAutoreleasedReturnValue();
        v76 = v98[0];
        if (os_log_type_enabled(v71, (os_log_type_t)v98[0]))
        {
          *(_DWORD *)v99 = 136446210;
          *(_QWORD *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
          _os_log_impl(&dword_182FBE000, v71, v76, "%{public}s called with null resolver_block, backtrace limit exceeded", v99, 0xCu);
        }
      }

    }
LABEL_141:
    if (v70)
      free(v70);

    goto LABEL_123;
  }
  type = nw_endpoint_get_type(*(nw_endpoint_t *)(v2 + 24));
  v10 = *(_QWORD *)(a1 + 32);
  if (type != nw_endpoint_type_host)
  {
    if ((nw_resolver_create_dns_service_locked((NWConcrete_nw_resolver *)v10) & 1) != 0)
      goto LABEL_124;
    goto LABEL_123;
  }
  required_address_family = nw_parameters_get_required_address_family(*(void **)(v10 + 16));
  if (required_address_family == 2
    || (nw_parameters_get_desperate_ivan(*(void **)(*(_QWORD *)(a1 + 32) + 16)) & 1) != 0)
  {
    v12 = 1;
LABEL_18:
    v13 = *(_QWORD *)(a1 + 32);
LABEL_19:
    *(_DWORD *)(v13 + 80) = v12;
    goto LABEL_20;
  }
  v13 = *(_QWORD *)(a1 + 32);
  if (required_address_family == 30)
  {
    v12 = 2;
    goto LABEL_19;
  }
  if (nw_parameters_get_allow_unusable_addresses(*(void **)(v13 + 16)))
  {
    v12 = 3;
    goto LABEL_18;
  }
LABEL_20:
  v14 = *(void **)(*(_QWORD *)(a1 + 32) + 16);
  if (!v14)
  {
    v28 = 0;
    v29 = 0;
    goto LABEL_113;
  }
  v15 = v14;
  v16 = v15[23];

  if (!v16)
  {
    v29 = 0;
    goto LABEL_72;
  }
  v17 = (id *)v16;
  v18 = v17[5];

  if (v18)
  {
    v19 = v18;
    v20 = objc_msgSend(v19, "type");

    if (v20 == 2 && (nw_endpoint_is_equal(v19, *(void **)(*(_QWORD *)(a1 + 32) + 24), 0) & 1) != 0)
      goto LABEL_39;
  }
  v21 = v17;
  v22 = *((_DWORD *)v21 + 38);
  if (v22 == 1)
  {
    v30 = *((_DWORD *)v21 + 39);

    if (v30 != 1)
      goto LABEL_43;
LABEL_39:
    *(_QWORD *)v99 = 0;
    *(_QWORD *)&v99[8] = v99;
    *(_QWORD *)&v99[16] = 0x2020000000;
    v100 = 0;
    *(_QWORD *)v98 = 0;
    *(_QWORD *)&v98[8] = v98;
    *(_QWORD *)&v98[16] = 0x2020000000;
    v98[24] = 0;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v95 = __Block_byref_object_copy__5622;
    v96 = __Block_byref_object_dispose__5623;
    v97 = 0;
    v84[0] = MEMORY[0x1E0C809B0];
    v84[1] = 3221225472;
    v84[2] = __nw_resolver_set_update_handler_block_invoke_73;
    v84[3] = &unk_1E149ACC0;
    v89 = required_address_family;
    v86 = v99;
    v87 = buf;
    v85 = *(id *)(a1 + 32);
    v88 = v98;
    nw_proxy_config_enumerate_resolved_endpoints(v17, v84);
    v83 = 0;
    scoped_interface_index = nw_resolver_get_scoped_interface_index(*(NWConcrete_nw_resolver **)(a1 + 32), &v83);
    v32 = *(void **)(*(_QWORD *)(a1 + 32) + 200);
    if (v32)
    {
      v33 = nw_path_copy_interface(v32);
      v34 = v33;
      if (v33)
        LODWORD(v32) = nw_interface_get_type(v33);
      else
        LODWORD(v32) = 0;
    }
    else
    {
      v34 = 0;
    }
    v35 = *(_QWORD **)(*(_QWORD *)&buf[8] + 40);
    if (v35 && v35[3] != v35[2])
    {
      v36 = *(_QWORD *)(a1 + 32);
      if (scoped_interface_index == -1 || (_DWORD)v32 == 4)
      {
        if (!v36)
        {
          __nwlog_obj();
          v38 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            v39 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
            *(_DWORD *)v90 = 136446466;
            v91 = "nw_resolver_set_update_handler_block_invoke_2";
            v92 = 2112;
            *(_QWORD *)v93 = v39;
            v40 = "%{public}s found proxy resolved endpoints %@";
            v41 = v38;
            v42 = 22;
LABEL_67:
            _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_INFO, v40, v90, v42);
          }
LABEL_68:

          v35 = *(_QWORD **)(*(_QWORD *)&buf[8] + 40);
          v36 = *(_QWORD *)(a1 + 32);
          goto LABEL_69;
        }
        v37 = *(_BYTE *)(v36 + 346);
LABEL_59:
        if ((v37 & 0x20) != 0)
        {
LABEL_69:
          objc_storeStrong((id *)(v36 + 144), v35);
          *(_BYTE *)(*(_QWORD *)(a1 + 32) + 346) |= 2u;
          nw_resolver_update_status_locked(*(void **)(a1 + 32), 0);
          v29 = 1;
          goto LABEL_70;
        }
        if (*(_BYTE *)(v36 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v38 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            goto LABEL_68;
          v43 = *(_QWORD *)(a1 + 32) + 256;
          v44 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
          *(_DWORD *)v90 = 136446722;
          v91 = "nw_resolver_set_update_handler_block_invoke";
          v92 = 2082;
          *(_QWORD *)v93 = v43;
          *(_WORD *)&v93[8] = 2112;
          *(_QWORD *)&v93[10] = v44;
          v40 = "%{public}s [C%{public}s] found proxy resolved endpoints %@";
          v41 = v38;
          v42 = 32;
          goto LABEL_67;
        }
        __nwlog_obj();
        v38 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
        {
          v45 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 340);
          v46 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
          *(_DWORD *)v90 = 136446722;
          v91 = "nw_resolver_set_update_handler_block_invoke";
          v92 = 1024;
          *(_DWORD *)v93 = v45;
          *(_WORD *)&v93[4] = 2112;
          *(_QWORD *)&v93[6] = v46;
          v40 = "%{public}s [R%u] found proxy resolved endpoints %@";
          v41 = v38;
          v42 = 28;
          goto LABEL_67;
        }
        goto LABEL_68;
      }
      v37 = *(_BYTE *)(v36 + 346);
      if ((v37 & 0x40) != 0 && *(_BYTE *)(*(_QWORD *)&v99[8] + 24)
        || (*(_BYTE *)(v36 + 346) & 0x80) != 0 && *(_BYTE *)(*(_QWORD *)&v98[8] + 24))
      {
        goto LABEL_59;
      }
    }
    v29 = 0;
LABEL_70:

    _Block_object_dispose(buf, 8);
    _Block_object_dispose(v98, 8);
    _Block_object_dispose(v99, 8);
    goto LABEL_71;
  }
  if (v22 == 4)
  {

    goto LABEL_39;
  }

LABEL_43:
  v29 = 0;
LABEL_71:

LABEL_72:
  v28 = nw_endpoint_copy_association_with_evaluator(*(void **)(*(_QWORD *)(a1 + 32) + 24), *(void **)(*(_QWORD *)(a1 + 32) + 16), 0);

  if (v28 && (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 346) & 2) == 0)
  {
    if (nw_protocol_copy_resolver_definition(void)::onceToken[0] != -1)
      dispatch_once(nw_protocol_copy_resolver_definition(void)::onceToken, &__block_literal_global_178);
    cached_content_for_protocol = nw_association_get_cached_content_for_protocol(v28, (void *)nw_protocol_copy_resolver_definition(void)::resolver_definition);
    v48 = (id *)cached_content_for_protocol;
    if (cached_content_for_protocol)
    {
      if (*(_BYTE *)(cached_content_for_protocol + 24))
        *(_BYTE *)(*(_QWORD *)(a1 + 32) + 347) |= 0x80u;
      if (*(_QWORD *)cached_content_for_protocol)
      {
        v49 = *(_QWORD *)(cached_content_for_protocol + 8);
        if (v49)
        {
          v50 = *(_QWORD *)(cached_content_for_protocol + 16);
          if (v50)
          {
            if (*(_QWORD *)(v49 + 24) - *(_QWORD *)(v49 + 16) == *(_QWORD *)(v50 + 24) - *(_QWORD *)(v50 + 16))
            {
              v80[0] = MEMORY[0x1E0C809B0];
              v80[1] = 3221225472;
              v80[2] = __nw_resolver_set_update_handler_block_invoke_76;
              v80[3] = &unk_1E14A3CF0;
              v82 = cached_content_for_protocol;
              v81 = *(id *)(a1 + 32);
              nw_array_apply((unsigned __int8 *)v49, (uint64_t)v80);

            }
          }
        }
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        LOBYTE(v95) = 0;
        *(_QWORD *)v99 = 0;
        *(_QWORD *)&v99[8] = v99;
        *(_QWORD *)&v99[16] = 0x2020000000;
        v100 = 0;
        v51 = (unsigned __int8 *)*v48;
        v79[0] = MEMORY[0x1E0C809B0];
        v79[1] = 3221225472;
        v79[2] = __nw_resolver_set_update_handler_block_invoke_78;
        v79[3] = &unk_1E14A8FF0;
        v79[4] = buf;
        v79[5] = v99;
        nw_array_apply(v51, (uint64_t)v79);
        *(_DWORD *)v90 = 0;
        v52 = nw_resolver_get_scoped_interface_index(*(NWConcrete_nw_resolver **)(a1 + 32), (unsigned int *)v90);
        v53 = *(_QWORD *)(a1 + 32);
        v54 = *(void **)(v53 + 200);
        if (v54)
        {
          v55 = nw_path_copy_interface(v54);
          v56 = v55;
          if (v55)
            LODWORD(v54) = nw_interface_get_type(v55);
          else
            LODWORD(v54) = 0;
          v53 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          v56 = 0;
        }
        if (v52 == -1 || (_DWORD)v54 == 4)
        {
          if (!v53)
          {
            __nwlog_obj();
            v58 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
            {
              v66 = *v48;
              *(_DWORD *)v98 = 136446466;
              *(_QWORD *)&v98[4] = "nw_resolver_set_update_handler_block_invoke_2";
              *(_WORD *)&v98[12] = 2112;
              *(_QWORD *)&v98[14] = v66;
              v61 = "%{public}s found cached endpoints %@";
              v62 = v58;
              v63 = 22;
              goto LABEL_109;
            }
LABEL_110:

            v53 = *(_QWORD *)(a1 + 32);
            goto LABEL_111;
          }
          v57 = *(_BYTE *)(v53 + 346);
        }
        else
        {
          v57 = *(_BYTE *)(v53 + 346);
          if (((v57 & 0x40) == 0 || !*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
            && ((*(_BYTE *)(v53 + 346) & 0x80) == 0 || !*(_BYTE *)(*(_QWORD *)&v99[8] + 24)))
          {
            goto LABEL_112;
          }
        }
        if ((v57 & 0x20) != 0)
        {
LABEL_111:
          objc_storeStrong((id *)(v53 + 144), *v48);
          *(_BYTE *)(*(_QWORD *)(a1 + 32) + 346) |= 2u;
          nw_resolver_update_status_locked(*(void **)(a1 + 32), 0);
          v29 = 1;
LABEL_112:

          _Block_object_dispose(v99, 8);
          _Block_object_dispose(buf, 8);
          goto LABEL_113;
        }
        if (*(_BYTE *)(v53 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v58 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
            goto LABEL_110;
          v59 = *(_QWORD *)(a1 + 32) + 256;
          v60 = *v48;
          *(_DWORD *)v98 = 136446722;
          *(_QWORD *)&v98[4] = "nw_resolver_set_update_handler_block_invoke";
          *(_WORD *)&v98[12] = 2082;
          *(_QWORD *)&v98[14] = v59;
          *(_WORD *)&v98[22] = 2112;
          *(_QWORD *)&v98[24] = v60;
          v61 = "%{public}s [C%{public}s] found cached endpoints %@";
          v62 = v58;
          v63 = 32;
          goto LABEL_109;
        }
        __nwlog_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
        {
          v64 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 340);
          v65 = *v48;
          *(_DWORD *)v98 = 136446722;
          *(_QWORD *)&v98[4] = "nw_resolver_set_update_handler_block_invoke";
          *(_WORD *)&v98[12] = 1024;
          *(_DWORD *)&v98[14] = v64;
          *(_WORD *)&v98[18] = 2112;
          *(_QWORD *)&v98[20] = v65;
          v61 = "%{public}s [R%u] found cached endpoints %@";
          v62 = v58;
          v63 = 28;
LABEL_109:
          _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_INFO, v61, v98, v63);
          goto LABEL_110;
        }
        goto LABEL_110;
      }
    }
  }
LABEL_113:
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 346) & 2) == 0)
  {
    if (networkd_settings_get_BOOL((const char *)nw_setting_disable_dns_xpc))
      goto LABEL_120;
    if (nw_resolver_can_use_dns_xpc::onceToken != -1)
      dispatch_once(&nw_resolver_can_use_dns_xpc::onceToken, &__block_literal_global_5650);
    if (nw_resolver_can_use_dns_xpc::can_use_dns_xpc == 1 && MEMORY[0x1E0DE5660])
      dns_getaddrinfo_locked = nw_resolver_create_dns_getaddrinfo_locked(*(NWConcrete_nw_resolver **)(a1 + 32), 0);
    else
LABEL_120:
      dns_getaddrinfo_locked = nw_resolver_create_dns_service_locked(*(NWConcrete_nw_resolver **)(a1 + 32));
    v29 = dns_getaddrinfo_locked;
  }

  if (!v29)
  {
LABEL_123:
    v68 = *(void **)(a1 + 32);
    v77[0] = MEMORY[0x1E0C809B0];
    v77[1] = 3221225472;
    v77[2] = __nw_resolver_set_update_handler_block_invoke_79;
    v77[3] = &unk_1E14ACFD0;
    v78 = v68;
    nw_resolver_update_status_locked(v78, v77);

  }
LABEL_124:
  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 12));
}

void sub_183017BC0(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  _Block_object_dispose((const void *)(v2 - 128), 8);
  _Block_object_dispose((const void *)(v2 - 208), 8);

  _Unwind_Resume(a1);
}

uint64_t nw_association_get_cached_content_for_protocol(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  id v6;
  uint64_t v7;
  _BOOL8 node;
  uint64_t *v9;
  time_t v10;
  _QWORD *v11;
  uint64_t v12;
  id v13;
  const char *logging_description;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  id v19;
  dispatch_queue_t *v20;
  dispatch_queue_t *v21;
  _BOOL8 v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  _QWORD *v30;
  const char *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  os_log_type_t v36;
  const char *v37;
  os_log_type_t v38;
  const char *v39;
  void *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  void *v45;
  os_log_type_t v46;
  char *backtrace_string;
  os_log_type_t v48;
  _BOOL4 v49;
  char *v50;
  os_log_type_t v51;
  _BOOL4 v52;
  void *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  os_log_type_t v57;
  os_log_type_t v58;
  char *v59;
  os_log_type_t v60;
  _BOOL4 v61;
  os_log_type_t v62;
  char v63;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v66;
  __int16 v67;
  void *v68;
  __int16 v69;
  uint64_t *v70;
  __int16 v71;
  char *v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_association_get_cached_content_for_protocol";
    v42 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (!__nwlog_fault(v42, &type, &v63))
      goto LABEL_97;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v48 = type;
      v49 = os_log_type_enabled(v43, type);
      if (backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_association_get_cached_content_for_protocol";
          v67 = 2082;
          v68 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v43, v48, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v42)
          goto LABEL_99;
        goto LABEL_98;
      }
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v43, v48, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v57 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v43, v57, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_96;
  }
  if (!v4)
  {
    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_association_get_cached_content_for_protocol";
    v42 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (!__nwlog_fault(v42, &type, &v63))
      goto LABEL_97;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v43, v46, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v63)
    {
      v50 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v51 = type;
      v52 = os_log_type_enabled(v43, type);
      if (v50)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_association_get_cached_content_for_protocol";
          v67 = 2082;
          v68 = v50;
          _os_log_impl(&dword_182FBE000, v43, v51, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v50);
LABEL_97:
        if (!v42)
        {
LABEL_99:
          v12 = 0;
          goto LABEL_58;
        }
LABEL_98:
        free(v42);
        goto LABEL_99;
      }
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v43, v51, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_182FBE000, v43, v58, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_96:

    goto LABEL_97;
  }
  v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);
  v7 = *((_QWORD *)v3 + 7);
  if (!v7)
    goto LABEL_56;
  node = nw_hash_table_get_node(v7, (uint64_t)v5, 0);
  if (!node)
    goto LABEL_56;
  v9 = (uint64_t *)node;
  v10 = time(0);
  v11 = v9 + 4;
  v12 = v9[9];
  if (v10 <= v9[8])
  {
    v19 = v6;
    if (v19)
    {
      v20 = (dispatch_queue_t *)v19;
      v21 = v20;
      if (((_BYTE)v20[17] & 8) == 0)
        dispatch_assert_queue_V2(v20[1]);

      v22 = nw_context_copy_cache_context(v21);
      v23 = v9[6];
      if (v23 || v9[7])
      {
        v24 = *(_QWORD *)(v22 + 24);
        v25 = *(_DWORD *)(v24 + 64);
        if (v25)
          *(_DWORD *)(v24 + 64) = v25 - 1;
        v26 = (uint64_t *)v9[7];
        if (v23)
        {
          *(_QWORD *)(v23 + 24) = v26;
          v26 = (uint64_t *)v9[7];
        }
        else
        {
          *(_QWORD *)(v24 + 24) = v26;
        }
        *v26 = v23;
        v9[6] = 0;
        v9[7] = 0;
      }
      v27 = v9[4];
      v28 = (uint64_t *)v9[5];
      if (v27)
      {
        *(_QWORD *)(v27 + 8) = v28;
        v28 = (uint64_t *)v9[5];
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(v22 + 24) + 8) = v28;
      }
      *v28 = v27;
      v29 = **(_QWORD **)(v22 + 24);
      *v11 = v29;
      v30 = *(_QWORD **)(v22 + 24);
      if (v29)
        v30 = (_QWORD *)*v30;
      v30[1] = v11;
      **(_QWORD **)(v22 + 24) = v11;
      v9[5] = *(_QWORD *)(v22 + 24);

      goto LABEL_57;
    }
    __nwlog_obj();
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_context_touch_cache_entry";
    v54 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (__nwlog_fault(v54, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v63)
      {
        v59 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        v61 = os_log_type_enabled(v55, type);
        if (v59)
        {
          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            v66 = "nw_context_touch_cache_entry";
            v67 = 2082;
            v68 = v59;
            _os_log_impl(&dword_182FBE000, v55, v60, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v59);
          goto LABEL_111;
        }
        if (v61)
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_182FBE000, v55, v60, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v62 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_182FBE000, v55, v62, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_111:
    if (v54)
      free(v54);
    goto LABEL_57;
  }
  if (v12)
    nw_protocol_definition_deallocate_cache_entry(v5, v9[9]);
  nw_context_remove_cache_entry(v6, v9 + 4);
  if (nw_hash_table_remove_node(*((_QWORD *)v3 + 7), (uint64_t)v9)
    || nw_path_parameters_get_logging_disabled(*((_QWORD *)v3 + 2)))
  {
    goto LABEL_56;
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v13 = (id)gconnectionLogObj;
  logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 1));
  *(_DWORD *)buf = 136446722;
  v66 = "nw_association_get_cached_content_for_protocol";
  v67 = 2082;
  v68 = (void *)logging_description;
  v69 = 2048;
  v70 = v9;
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v63 = 0;
  if (__nwlog_fault(v15, &type, &v63))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        v18 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v66 = "nw_association_get_cached_content_for_protocol";
        v67 = 2082;
        v68 = (void *)v18;
        v69 = 2048;
        v70 = v9;
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p", buf, 0x20u);
      }
    }
    else if (v63)
    {
      v31 = __nw_create_backtrace_string();
      if (v31)
      {
        v32 = (char *)v31;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v33 = (id)gconnectionLogObj;
        v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          v35 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
          *(_DWORD *)buf = 136446978;
          v66 = "nw_association_get_cached_content_for_protocol";
          v67 = 2082;
          v68 = (void *)v35;
          v69 = 2048;
          v70 = v9;
          v71 = 2082;
          v72 = v32;
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v32);
        if (!v15)
          goto LABEL_56;
        goto LABEL_55;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v38 = type;
      if (os_log_type_enabled(v16, type))
      {
        v39 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v66 = "nw_association_get_cached_content_for_protocol";
        v67 = 2082;
        v68 = (void *)v39;
        v69 = 2048;
        v70 = v9;
        _os_log_impl(&dword_182FBE000, v16, v38, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      v36 = type;
      if (os_log_type_enabled(v16, type))
      {
        v37 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v66 = "nw_association_get_cached_content_for_protocol";
        v67 = 2082;
        v68 = (void *)v37;
        v69 = 2048;
        v70 = v9;
        _os_log_impl(&dword_182FBE000, v16, v36, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded", buf, 0x20u);
      }
    }

  }
  if (v15)
LABEL_55:
    free(v15);
LABEL_56:
  v12 = 0;
LABEL_57:

LABEL_58:
  return v12;
}

void sub_183018824(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_required_address_family(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  id *v4;
  id v5;
  id v6;
  _BOOL4 is_equal_unsafe;
  int version;
  uint64_t v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_parameters_get_required_address_family";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_parameters_get_required_address_family";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_parameters_get_required_address_family";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_parameters_get_required_address_family";
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_parameters_get_required_address_family";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_30:
    if (v12)
      free(v12);
    goto LABEL_10;
  }
  v3 = *(void **)(v1[19] + 48);
  if (v3)
  {
    v4 = v3;
    v5 = v4[1];

    if (nw_protocol_setup_ip_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_52132);
    v6 = (id)g_ip_definition;
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v6);

    if (is_equal_unsafe)
    {
      version = nw_ip_options_get_version(*(void **)(v2[19] + 48));
      if (version == 4)
      {
        v9 = 2;
        goto LABEL_12;
      }
      if (version == 6)
      {
        v9 = 30;
LABEL_12:

        goto LABEL_13;
      }
    }

  }
LABEL_10:
  v9 = 0;
LABEL_13:

  return v9;
}

void sub_183018BBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_ip_options_get_local_address_preference(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_local_address_preference_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_ip_options_get_local_address_preference";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_local_address_preference";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_ip_options_get_local_address_preference";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_local_address_preference";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_local_address_preference";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183018ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_options_access_handle(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  uint64_t v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_options_access_handle";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_options_access_handle";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  if (!v4)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_options_access_handle";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null access_block", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v8)
        free(v8);
      goto LABEL_39;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_options_access_handle";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  if (!v3[18])
  {
LABEL_39:
    v6 = 0;
    goto LABEL_40;
  }
  v6 = (*((uint64_t (**)(id))v4 + 2))(v4);
LABEL_40:

  return v6;
}

void sub_1830193C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_local_address_preference_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 4);
  return 1;
}

uint64_t __nw_ip_options_get_version_block_invoke(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

id *nw_endpoint_copy_association(void *a1, void *a2)
{
  return nw_endpoint_copy_association_with_evaluator(a1, a2, 0);
}

uint64_t __nw_tcp_options_get_enable_fast_open_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x800) != 0;
  return 1;
}

uint64_t nw_parameters_get_desperate_ivan(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[98] >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_desperate_ivan";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_desperate_ivan";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_desperate_ivan";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_desperate_ivan";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_desperate_ivan";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_allow_unusable_addresses(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[98] >> 3) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_allow_unusable_addresses";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_allow_unusable_addresses";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_allow_unusable_addresses";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_allow_unusable_addresses";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_allow_unusable_addresses";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_path_copy_interface(void *a1)
{
  NWConcrete_nw_path *v1;
  void **p_isa;
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  p_isa = (void **)&v1->super.isa;
  if (!v1)
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_path_copy_interface";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_path_copy_interface";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_21:
    if (v5)
      free(v5);
    goto LABEL_23;
  }
  if (!nw_path_network_is_satisfied_update_reason(v1, 0) && !nw_path_endpoint_is_always_satisfied(p_isa[3]))
  {
LABEL_23:
    v3 = 0;
    goto LABEL_24;
  }
  v3 = p_isa[12];
LABEL_24:

  return v3;
}

void sub_183019C10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_options_get_retransmit_fin_drop_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x400) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_retransmit_connection_drop_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 12);
  return 1;
}

uint64_t __nw_tcp_options_get_persist_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 8);
  return 1;
}

uint64_t __nw_tcp_options_get_no_timewait_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 36) & 4) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_no_push_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 36) & 8) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_no_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 36) & 0x10) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_no_delay_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 36) & 2) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_maximum_segment_size_block_invoke(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_keepalive_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 36) & 0x20) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_background_traffic_management_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x200) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_disable_ack_stretching_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x80) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_reduce_buffering_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 36) & 1;
  return 1;
}

uint64_t __nw_tcp_options_set_no_delay_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 36);
  v2 = a2 + 36;
  v4 = v3 & 0xFFFFFFFD | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFFD | (2 * (*(_BYTE *)(a1 + 32) & 0x7F));
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

uint64_t __nw_ip_options_get_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 12);
  return 1;
}

uint64_t __nw_ip_options_get_fragmentation_value_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 8);
  return 1;
}

uint64_t __nw_ip_options_get_calculate_receive_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 13) & 2) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_fast_open_force_enable_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x4000) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_l4s_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 32);
  return 1;
}

uint64_t __nw_tcp_options_get_connection_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 4);
  return 1;
}

uint64_t __nw_tcp_options_get_reset_local_port_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 38) & 1;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_keepalive_offload_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 36) & 0x40) != 0;
  return 1;
}

uint64_t __nw_ip_options_get_corrupt_checksums_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 13) & 8) != 0;
  return 1;
}

uint64_t __nw_quic_stream_get_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 24) & 1;
  return 1;
}

uint64_t __nw_quic_stream_get_is_datagram_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 24) & 2) != 0;
  return 1;
}

uint64_t __nw_quic_stream_get_associated_stream_id_block_invoke(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t __nw_quic_connection_set_max_streams_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  v4 = _Block_copy(*(const void **)(a1 + 40));
  v5 = *(void **)(a2 + 176);
  *(_QWORD *)(a2 + 176) = v4;

  objc_storeStrong((id *)(a2 + 184), *(id *)(a1 + 32));
  return 1;
}

uint64_t __nw_quic_connection_set_keepalive_count_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 210) = *(_WORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_quic_connection_set_is_speculative_attempt_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFF7FFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 15);
  *(_WORD *)v2 = v3 & 0x7FFF | (*(unsigned __int8 *)(a1 + 32) << 15);
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

uint64_t __nw_quic_connection_set_sec_protocol_options_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 96), *(id *)(a1 + 32));
  return 1;
}

uint64_t __nw_quic_connection_set_initial_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_quic_connection_set_initial_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_quic_connection_set_idle_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 192) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_tcp_options_get_disable_blackhole_detection_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 37) & 1;
  return 1;
}

uint64_t __nw_tcp_options_get_disable_ecn_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(unsigned __int16 *)(a2 + 36) >> 15;
  return 1;
}

uint64_t __nw_ip_options_get_use_minimum_mtu_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 13) & 1;
  return 1;
}

uint64_t __nw_quic_connection_get_enable_l4s_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 200);
  return 1;
}

uint64_t __nw_quic_connection_copy_sec_protocol_options_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 96));
  return 1;
}

BOOL __nw_quic_connection_execute_session_state_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;
  NSObject *v6;
  id v7;
  _QWORD block[4];
  id v10;
  id v11;
  id v12;

  v2 = *(_QWORD *)(a2 + 168);
  if (v2)
  {
    v5 = _Block_copy(*(const void **)(a2 + 160));
    v6 = *(NSObject **)(a2 + 168);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __nw_quic_connection_execute_session_state_update_block_block_invoke_2;
    block[3] = &unk_1E14A8D98;
    v12 = v5;
    v10 = *(id *)(a1 + 32);
    v11 = *(id *)(a1 + 40);
    v7 = v5;
    dispatch_async(v6, block);

  }
  return v2 != 0;
}

uint64_t __nw_udp_options_set_no_metadata_block_invoke(uint64_t a1, _BYTE *a2)
{
  *a2 = *a2 & 0xFD | (2 * *(_BYTE *)(a1 + 32));
  return 1;
}

uint64_t __nw_udp_options_get_prefer_no_checksum_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2 & 1;
  return 1;
}

uint64_t __nw_udp_options_get_no_metadata_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*a2 & 2) != 0;
  return 1;
}

uint64_t __nw_udp_options_get_ignore_inbound_checksum_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*a2 & 4) != 0;
  return 1;
}

uint64_t __nw_quic_get_remote_transport_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v2 = *(unsigned __int16 *)(a2 + 215) | (*(unsigned __int8 *)(a2 + 217) << 16);
  if ((v2 & 0x20000) != 0)
  {
    v3 = *(_QWORD **)(a1 + 40);
    **(_QWORD **)(a1 + 32) = *(_QWORD *)(a2 + 48);
    *v3 = *(_QWORD *)(a2 + 56);
    v4 = *(_QWORD **)(a1 + 56);
    **(_QWORD **)(a1 + 48) = *(_QWORD *)(a2 + 64);
    *v4 = *(_QWORD *)(a2 + 72);
    v5 = *(_QWORD **)(a1 + 72);
    **(_QWORD **)(a1 + 64) = *(_QWORD *)(a2 + 80);
    *v5 = *(_QWORD *)(a2 + 88);
  }
  return (v2 >> 17) & 1;
}

uint64_t __nw_quic_connection_get_use_swift_tls_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 215) & 0x1000) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_tls_state_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 144));
  return 1;
}

uint64_t __nw_quic_connection_get_stream_path_affinity_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 196);
  return 1;
}

uint64_t __nw_quic_connection_get_source_connection_id_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 152));
  return 1;
}

uint64_t __nw_quic_connection_get_quic_state_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 136));
  return 1;
}

uint64_t __nw_quic_connection_get_probe_simultaneously_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 217) & 8) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_max_udp_payload_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 204);
  return 1;
}

uint64_t __nw_quic_connection_get_max_paths_per_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 213);
  return 1;
}

uint64_t __nw_quic_connection_get_max_datagram_frame_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 206);
  return 1;
}

uint64_t __nw_quic_connection_get_keepalive_count_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 210);
  return 1;
}

uint64_t __nw_quic_connection_get_is_speculative_attempt_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(unsigned __int16 *)(a2 + 215) >> 15;
  return 1;
}

uint64_t __nw_quic_connection_get_initial_packet_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 208);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 40);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 32);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_stream_data_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 24);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_stream_data_bidirectional_remote_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 16);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_stream_data_bidirectional_local_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 8);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_data_block_invoke(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t __nw_quic_connection_get_idle_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 192);
  return 1;
}

uint64_t __nw_quic_connection_get_force_version_negotiation_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 215) & 0x10) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_enable_multipath_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 217) & 4) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_disable_spin_bit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 217) & 1;
  return 1;
}

uint64_t __nw_quic_connection_get_disable_ecn_echo_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 216) & 1;
  return 1;
}

uint64_t __nw_quic_connection_get_disable_ecn_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 215) & 0x200) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_datagram_variant_flow_id_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 215) & 0x20) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_datagram_quarter_stream_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 215) & 0x40) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_datagram_context_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 215) & 0x80) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_ack_delay_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 212);
  return 1;
}

uint64_t __nw_quic_connection_get_pmtud_ignore_cost_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 215) & 2) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_pmtud_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 215) & 1;
  return 1;
}

uint64_t __nw_quic_stream_set_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 24) = *(_BYTE *)(a2 + 24) & 0xFE | *(_BYTE *)(a1 + 32);
  return 1;
}

uint64_t __nw_tcp_options_set_retransmit_connection_drop_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_tcp_options_set_keepalive_interval_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_tcp_options_set_keepalive_idle_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_tcp_options_set_enable_keepalive_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 36);
  v2 = a2 + 36;
  v4 = v3 & 0xFFFFFFDF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFDF | (32 * (*(_BYTE *)(a1 + 32) & 7));
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

uint64_t __nw_tcp_options_set_connection_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_tcp_options_get_keepalive_interval_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 20);
  return 1;
}

uint64_t __nw_tcp_options_get_keepalive_idle_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 16);
  return 1;
}

uint64_t __nw_tcp_options_get_keepalive_count_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 24);
  return 1;
}

uint64_t nw_protocol_instance_access_flow_state(void *a1, uint64_t a2, void *a3)
{
  char *v5;
  id v6;
  uint64_t (**v7)(_QWORD, _QWORD);
  uint64_t v8;
  uint64_t node;
  uint64_t v10;
  NSObject *v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  v7 = (uint64_t (**)(_QWORD, _QWORD))v6;
  if (!v5)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_instance_access_flow_state";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null instance", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (!v26)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_instance_access_flow_state";
      v30 = 2082;
      v31 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_32;
  }
  if (!v6)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_instance_access_flow_state";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null access_block", buf, 0xCu);
      }
LABEL_44:

LABEL_45:
      if (v14)
        free(v14);
      goto LABEL_11;
    }
    if (!v26)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_182FBE000, v15, v25, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_instance_access_flow_state";
      v30 = 2082;
      v31 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_32:

    free(backtrace_string);
    goto LABEL_45;
  }
  if (*(_DWORD *)(*((_QWORD *)v5 + 1) + 64) != 3 || (v8 = *((_QWORD *)v5 + 29)) == 0)
  {
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  node = nw_hash_table_get_node(v8, a2, 8);
  if (!node)
  {
    if ((v5[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446978;
        v29 = "nw_protocol_instance_access_flow_state";
        v30 = 2082;
        v31 = v5 + 407;
        v32 = 2080;
        v33 = " ";
        v34 = 2048;
        v35 = a2;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sFlow %llx not present, not getting state", buf, 0x2Au);
      }

    }
    goto LABEL_11;
  }
  v10 = v7[2](v7, *(_QWORD *)(node + 32));
LABEL_12:

  return v10;
}

void sub_18301AB70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_enable_tls_keylog()
{
  uint64_t result;

  result = os_variant_allows_internal_security_policies();
  if ((_DWORD)result)
    return networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_enable_tls_keylog);
  return result;
}

id nw_parameters_copy_prohibited_interface_types(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_prohibited_interface_types";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interface_types";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_prohibited_interface_types";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interface_types";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interface_types";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(id **)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *v3;
LABEL_23:

  return v4;
}

id nw_parameters_copy_prohibited_interface_subtypes(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_prohibited_interface_subtypes";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_prohibited_interface_subtypes";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 8);
LABEL_23:

  return v4;
}

void sub_18301B4D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  void *v14;

  a14.super_class = (Class)NWConcrete_nw_connection;
  -[_Unwind_Exception dealloc](&a14, sel_dealloc);
  _Unwind_Resume(a1);
}

void __nw_connection_start_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  id *v3;
  char *v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  const char *logging_description;
  os_unfair_lock_s *v9;
  os_unfair_lock_s *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  os_unfair_lock_s *v17;
  os_unfair_lock_s *v18;
  _QWORD *v19;
  _BOOL4 v20;
  const void *v21;
  dispatch_data_t v22;
  uint64_t v23;
  void *v24;
  uint32_t int64_with_default;
  uint32_t v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  _DWORD *v30;
  unsigned int v31;
  void **v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  const char *v39;
  NSObject *v40;
  uint32_t v41;
  int v42;
  void *v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  char *backtrace_string;
  os_log_type_t v48;
  _BOOL4 v49;
  os_log_type_t v50;
  int v51;
  _QWORD v52[4];
  NSObject *v53;
  _QWORD v54[4];
  os_unfair_lock_s *v55;
  char v56;
  os_log_type_t type;
  _BYTE buf[44];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v2 = &unk_1ECD84000;
  v3 = (id *)&unk_1ECD84000;
  if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16)))
  {
    v4 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)(*(_QWORD *)(a1 + 32) + 16), 1);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v5 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_QWORD *)(a1 + 32);
      v7 = *(_DWORD *)(v6 + 448);
      logging_description = nw_endpoint_get_logging_description(*(void **)(v6 + 8));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&buf[4] = v7;
      *(_WORD *)&buf[8] = 1042;
      *(_DWORD *)&buf[10] = 16;
      *(_WORD *)&buf[14] = 2098;
      *(_QWORD *)&buf[16] = v6 + 452;
      *(_WORD *)&buf[24] = 2082;
      *(_QWORD *)&buf[26] = logging_description;
      *(_WORD *)&buf[34] = 2082;
      *(_QWORD *)&buf[36] = v4;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEFAULT, "[C%u %{public,uuid_t}.16P %{public}s %{public}s] start", buf, 0x2Cu);
    }

    if (v4)
      free(v4);
  }
  v9 = *(os_unfair_lock_s **)(a1 + 32);
  v10 = v9 + 34;
  v11 = MEMORY[0x1E0C809B0];
  v54[0] = MEMORY[0x1E0C809B0];
  v54[1] = 3221225472;
  v54[2] = __nw_connection_start_block_invoke_15;
  v54[3] = &unk_1E14ACFD0;
  v55 = v9;
  os_unfair_lock_lock(v10);
  __nw_connection_start_block_invoke_15((uint64_t)v54);
  os_unfair_lock_unlock(v10);
  v12 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v12 + 72))
  {
    v13 = *(_DWORD *)(v12 + 80);
    v14 = (id)v12;
    nw_context_assert_queue(v14[3].isa);
    nw_connection_report_state_with_handler_on_nw_queue(v14, v13, v14[26].isa, v14[25].isa);
    goto LABEL_42;
  }
  if (*(_QWORD *)(v12 + 144))
  {
    if (*(_QWORD *)(v12 + 200))
    {
LABEL_14:
      objc_storeStrong((id *)(v12 + 48), (id)v12);
      v15 = *(_QWORD *)(a1 + 32);
      v16 = *(_DWORD *)(v15 + 80);
      *(_DWORD *)(v15 + 192) = *(_DWORD *)(a1 + 40);
      v17 = *(os_unfair_lock_s **)(a1 + 32);
      v18 = v17 + 34;
      v52[0] = v11;
      v52[1] = 3221225472;
      v52[2] = __nw_connection_start_block_invoke_16;
      v52[3] = &unk_1E14ACFD0;
      v53 = v17;
      os_unfair_lock_lock(v18);
      __nw_connection_start_block_invoke_16((uint64_t)v52);
      os_unfair_lock_unlock(v18);
      if (nw_parameters_get_attribution(*(nw_parameters_t *)(*(_QWORD *)(a1 + 32) + 16)) != nw_parameters_attribution_developer
        || !ne_tracker_should_save_stacktrace())
      {
        goto LABEL_20;
      }
      v19 = *(id *)(*(_QWORD *)(a1 + 32) + 16);
      if (v19)
      {
        v20 = (v19[12] & 0x8000000000) == 0;

        if (v20)
        {
LABEL_18:
          *(_QWORD *)buf = 0;
          v21 = (const void *)ne_tracker_copy_current_stacktrace();
          if (v21)
          {
            v22 = dispatch_data_create(v21, *(size_t *)buf, 0, (dispatch_block_t)*MEMORY[0x1E0C80CE0]);
            v23 = *(_QWORD *)(a1 + 32);
            v24 = *(void **)(v23 + 88);
            *(_QWORD *)(v23 + 88) = v22;

          }
        }
LABEL_20:
        int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_statistics_report_numerator, 1);
        v26 = networkd_settings_get_int64_with_default((const char *)nw_setting_statistics_report_denominator, 200000);
        if (arc4random_uniform(v26) < int64_with_default)
        {
          v27 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
          if (v27 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v27 + 104)))
          {
            if (v2[413] != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v28 = v3[416];
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              v29 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_connection_start_block_invoke_2";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v29;
              _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] selected for reporting", buf, 0x12u);
            }

          }
          *(_BYTE *)(*(_QWORD *)(a1 + 32) + 108) |= 4u;
        }
        if (v16 >= 1)
        {
          v30 = *(_DWORD **)(a1 + 32);
          v31 = v30[20];
          v32 = v30;
          nw_context_assert_queue(v32[3]);
          nw_connection_report_state_with_handler_on_nw_queue(v32, v31, v32[26], v32[25]);

        }
        nw_endpoint_handler_start(*(void **)(*(_QWORD *)(a1 + 32) + 144));
        v14 = v53;
        goto LABEL_42;
      }
      __nwlog_obj();
      v42 = v16;
      v43 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_parameters_get_skip_stack_trace_capture";
      v44 = (char *)_os_log_send_and_compose_impl();

      v51 = v42;
      type = OS_LOG_TYPE_ERROR;
      v56 = 0;
      if (__nwlog_fault(v44, &type, &v56))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v45 = objc_claimAutoreleasedReturnValue();
          v46 = type;
          if (os_log_type_enabled(v45, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s called with null parameters", buf, 0xCu);
          }
        }
        else if (v56)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v45 = objc_claimAutoreleasedReturnValue();
          v48 = type;
          v49 = os_log_type_enabled(v45, type);
          if (backtrace_string)
          {
            if (v49)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_parameters_get_skip_stack_trace_capture";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v45, v48, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_59;
          }
          if (v49)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_182FBE000, v45, v48, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v45 = objc_claimAutoreleasedReturnValue();
          v50 = type;
          if (os_log_type_enabled(v45, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_182FBE000, v45, v50, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_59:
      if (v44)
        free(v44);
      v3 = (id *)&unk_1ECD84000;
      v2 = (_QWORD *)&unk_1ECD84000;
      v16 = v51;
      goto LABEL_18;
    }
    if (nw_context_is_inline(*(void **)(v12 + 24)))
    {
      v12 = *(_QWORD *)(a1 + 32);
      goto LABEL_14;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_connection_start_block_invoke";
    v39 = "%{public}s Cannot start nw_connection without first setting the queue.";
    v40 = v14;
    v41 = 12;
LABEL_41:
    _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_ERROR, v39, buf, v41);
    goto LABEL_42;
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v14 = (id)gconnectionLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    v33 = *(_QWORD *)(a1 + 32);
    v34 = *(_DWORD *)(v33 + 448);
    v36 = *(_QWORD *)(v33 + 8);
    v35 = *(_QWORD *)(v33 + 16);
    v37 = *(unsigned int *)(v33 + 80);
    if (v37 > 5)
      v38 = "unknown";
    else
      v38 = off_1E149DE10[v37];
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&buf[4] = v34;
    *(_WORD *)&buf[8] = 2112;
    *(_QWORD *)&buf[10] = v36;
    *(_WORD *)&buf[18] = 2112;
    *(_QWORD *)&buf[20] = v35;
    *(_WORD *)&buf[28] = 2082;
    *(_QWORD *)&buf[30] = v38;
    v39 = "[C%u %@ %@] cannot start after being torn down, in state %{public}s";
    v40 = v14;
    v41 = 38;
    goto LABEL_41;
  }
LABEL_42:

}

void sub_18301BC84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{

  _Unwind_Resume(a1);
}

nw_parameters_attribution_t nw_parameters_get_attribution(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  nw_parameters_attribution_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    if (*((unsigned __int8 *)v1[13].isa + 102) <= 2u)
      v3 = (0x20201u >> (8 * *((_BYTE *)v1[13].isa + 102)));
    else
      v3 = 0;
    goto LABEL_5;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_attribution";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attribution";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_attribution";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attribution";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attribution";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_5:

  return v3;
}

void sub_18301C2FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

BOOL nw_path_parameters_get_logging_disabled(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_path_parameters_get_logging_disabled";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (__nwlog_fault(v4, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null path_parameters", buf, 0xCu);
        }
      }
      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            v14 = "nw_path_parameters_get_logging_disabled";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null path_parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v9)
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null path_parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null path_parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v4)
      free(v4);
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 136);
  if (v1)
    return *(_DWORD *)(v1 + 124) == 4;
  return 0;
}

BOOL nw_parameters_get_logging_disabled(uint64_t a1)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  char *backtrace_string;
  os_log_type_t v7;
  _BOOL4 v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
    return nw_path_parameters_get_logging_disabled(*(_QWORD *)(a1 + 104));
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_parameters_get_logging_disabled";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_parameters_get_logging_disabled";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_182FBE000, v4, v9, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v3)
    free(v3);
  return 1;
}

void nw_endpoint_handler_inherit_from_parent(NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_handler *a2, unsigned int next_top_id)
{
  NWConcrete_nw_endpoint_handler *v5;
  NWConcrete_nw_endpoint_handler *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint64_t v11;
  size_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  if (v6)
  {
    objc_storeStrong((id *)&v5->parent_handler, a2);
    v5->top_id = v6->top_id;
    *((_BYTE *)v5 + 268) = *((_BYTE *)v5 + 268) & 0xFE | *((_BYTE *)v6 + 268) & 1;
    if (v6->id_chain[0])
    {
      if (v6->id_chain[1])
      {
        if (v6->id_chain[2])
        {
          if (v6->id_chain[3])
          {
            if (v6->id_chain[4])
            {
              if (v6->id_chain[5])
              {
                if (v6->id_chain[6])
                {
                  if (v6->id_chain[7])
                  {
                    if (v6->id_chain[8])
                    {
                      if (v6->id_chain[9])
                      {
                        if (v6->id_chain[10])
                        {
                          if (v6->id_chain[11])
                          {
                            if (v6->id_chain[12])
                            {
                              if (v6->id_chain[13])
                              {
                                if (v6->id_chain[14])
                                {
                                  if (v6->id_chain[15])
                                  {
                                    __nwlog_obj();
                                    v7 = (void *)objc_claimAutoreleasedReturnValue();
                                    *(_DWORD *)buf = 136446210;
                                    v20 = "nw_endpoint_handler_inherit_from_parent";
                                    v8 = (char *)_os_log_send_and_compose_impl();

                                    type = OS_LOG_TYPE_ERROR;
                                    v17 = 0;
                                    if (__nwlog_fault(v8, &type, &v17))
                                    {
                                      if (type == OS_LOG_TYPE_FAULT)
                                      {
                                        __nwlog_obj();
                                        v9 = objc_claimAutoreleasedReturnValue();
                                        v10 = type;
                                        if (os_log_type_enabled(v9, type))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s reached maximum endpoint handler depth", buf, 0xCu);
                                        }
                                      }
                                      else if (v17)
                                      {
                                        backtrace_string = (char *)__nw_create_backtrace_string();
                                        __nwlog_obj();
                                        v9 = objc_claimAutoreleasedReturnValue();
                                        v14 = type;
                                        v15 = os_log_type_enabled(v9, type);
                                        if (backtrace_string)
                                        {
                                          if (v15)
                                          {
                                            *(_DWORD *)buf = 136446466;
                                            v20 = "nw_endpoint_handler_inherit_from_parent";
                                            v21 = 2082;
                                            v22 = backtrace_string;
                                            _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s reached maximum endpoint handler depth, dumping backtrace:%{public}s", buf, 0x16u);
                                          }

                                          free(backtrace_string);
                                          goto LABEL_56;
                                        }
                                        if (v15)
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s reached maximum endpoint handler depth, no backtrace", buf, 0xCu);
                                        }
                                      }
                                      else
                                      {
                                        __nwlog_obj();
                                        v9 = objc_claimAutoreleasedReturnValue();
                                        v16 = type;
                                        if (os_log_type_enabled(v9, type))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s reached maximum endpoint handler depth, backtrace limit exceeded", buf, 0xCu);
                                        }
                                      }

                                    }
LABEL_56:
                                    if (v8)
                                      free(v8);
                                    goto LABEL_44;
                                  }
                                  v11 = 15;
                                  v12 = 14;
                                }
                                else
                                {
                                  v11 = 14;
                                  v12 = 13;
                                }
                              }
                              else
                              {
                                v11 = 13;
                                v12 = 12;
                              }
                            }
                            else
                            {
                              v11 = 12;
                              v12 = 11;
                            }
                          }
                          else
                          {
                            v11 = 11;
                            v12 = 10;
                          }
                        }
                        else
                        {
                          v11 = 10;
                          v12 = 9;
                        }
                      }
                      else
                      {
                        v11 = 9;
                        v12 = 8;
                      }
                    }
                    else
                    {
                      v11 = 8;
                      v12 = 7;
                    }
                  }
                  else
                  {
                    v11 = 7;
                    v12 = 6;
                  }
                }
                else
                {
                  v11 = 6;
                  v12 = 5;
                }
              }
              else
              {
                v11 = 5;
                v12 = 4;
              }
            }
            else
            {
              v11 = 4;
              v12 = 3;
            }
          }
          else
          {
            v11 = 3;
            v12 = 2;
          }
        }
        else
        {
          v11 = 2;
          v12 = 1;
        }
      }
      else
      {
        v12 = 0;
        v11 = 1;
      }
      memcpy(v5->id_chain, v6->id_chain, v12);
    }
    else
    {
      v11 = 0;
    }
    v5->id_chain[v11] = nw_endpoint_handler_get_next_id(&v6->last_child_id.__a_.__a_value);
    snprintf(v5->id_str, 0x4BuLL, "%s.%u");
    goto LABEL_44;
  }
  if (!next_top_id)
    next_top_id = nw_endpoint_handler_get_next_top_id();
  v5->top_id = next_top_id;
  snprintf(v5->id_str, 0x4BuLL, "%u");
LABEL_44:

}

uint64_t nw_endpoint_handler_get_next_id(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  unsigned int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  do
  {
    v2 = __ldaxr(a1);
    v3 = v2 + 1;
  }
  while (__stlxr(v2 + 1, a1));
  if (v3 >= 0x100 && (_BYTE)v2 == 0xFF)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = 136446466;
      v7 = "nw_endpoint_handler_get_next_id";
      v8 = 1024;
      v9 = v3;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s reached %u child endpoint handlers, wrapping", (uint8_t *)&v6, 0x12u);
    }

    LOBYTE(v3) = nw_endpoint_handler_get_next_id(a1);
  }
  return v3;
}

void nw_connection_add_timestamp_locked_on_nw_queue(void *a1, _OWORD *a2)
{
  void **v3;
  void **v4;
  unsigned int v5;
  _QWORD *v6;
  NSObject *v7;
  int v8;
  unsigned int v9;
  unsigned __int16 v10;
  _OWORD *v11;
  NSObject *v12;
  int v13;
  int v14;
  void *v15;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  void *v20;
  os_log_type_t v21;
  void *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  _BOOL4 v31;
  NSObject *v32;
  void *v33;
  NSObject *v34;
  void *v35;
  os_log_type_t v36;
  os_log_type_t v37;
  os_log_type_t v38;
  char v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  _WORD v44[9];

  *(_QWORD *)&v44[5] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v17, &type, &v39))
      goto LABEL_81;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v39)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
          v43 = 2082;
          *(_QWORD *)v44 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v18, v25, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_81:
        if (!v17)
          goto LABEL_27;
LABEL_82:
        free(v17);
        goto LABEL_27;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v25, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v36, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_80:

    goto LABEL_81;
  }
  if (!a2)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v17, &type, &v39))
      goto LABEL_81;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v21, "%{public}s called with null timestamp", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (!v39)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v37, "%{public}s called with null timestamp, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_80;
    }
    v27 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v28 = type;
    v29 = os_log_type_enabled(v18, type);
    if (!v27)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v28, "%{public}s called with null timestamp, no backtrace", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
      v43 = 2082;
      *(_QWORD *)v44 = v27;
      _os_log_impl(&dword_182FBE000, v18, v28, "%{public}s called with null timestamp, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
  if (!v3[39])
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v17, &type, &v39))
      goto LABEL_81;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v23, "%{public}s called with null connection->timestamps", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (!v39)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v38, "%{public}s called with null connection->timestamps, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_80;
    }
    v27 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v30 = type;
    v31 = os_log_type_enabled(v18, type);
    if (!v27)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v18, v30, "%{public}s called with null connection->timestamps, no backtrace", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
      v43 = 2082;
      *(_QWORD *)v44 = v27;
      _os_log_impl(&dword_182FBE000, v18, v30, "%{public}s called with null connection->timestamps, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_57:

    free(v27);
    if (!v17)
      goto LABEL_27;
    goto LABEL_82;
  }
  nw_context_assert_queue(v3[3]);
  v5 = *((unsigned __int16 *)v4 + 161);
  if (v5 >= 0x40)
  {
    if ((*((_BYTE *)v4 + 108) & 0x10) == 0)
    {
      *((_BYTE *)v4 + 108) |= 0x10u;
      v6 = v4[2];
      if (v6)
      {
        if (!nw_path_parameters_get_logging_disabled(v6[13]))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v7 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            v8 = *((_DWORD *)v4 + 112);
            *(_DWORD *)buf = 136446466;
            v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
            v43 = 1024;
            *(_DWORD *)v44 = v8;
            _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Hit maximum timestamp count, will start dropping events", buf, 0x12u);
          }

        }
      }
    }
    memmove((char *)v4[39] + 880, (char *)v4[39] + 896, 0x80uLL);
    *((_OWORD *)v4[39] + 63) = *a2;
    goto LABEL_27;
  }
  v9 = *((unsigned __int16 *)v4 + 160);
  if (v5 <= v9 && (v9 & 0xF) == 0)
  {
    if (v5 == v9)
      goto LABEL_17;
LABEL_25:
    v11 = v4[39];
    goto LABEL_26;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = (id)gLogObj;
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  v13 = *((unsigned __int16 *)v4 + 160);
  v14 = *((unsigned __int16 *)v4 + 161);
  *(_DWORD *)buf = 136446722;
  v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
  v43 = 1024;
  *(_DWORD *)v44 = v13;
  v44[2] = 1024;
  *(_DWORD *)&v44[3] = v14;
  v15 = (void *)_os_log_send_and_compose_impl();

  if (__nwlog_abort((uint64_t)v15))
    goto LABEL_83;
  free(v15);
  v5 = *((unsigned __int16 *)v4 + 161);
  v9 = *((unsigned __int16 *)v4 + 160);
  if (v5 != v9)
    goto LABEL_25;
LABEL_17:
  if (v9 <= 0x30)
    v10 = v9 + 16;
  else
    v10 = 64;
  *((_WORD *)v4 + 160) = v10;
  if (!v10)
  {
    __nwlog_obj();
    v32 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v42 = "_strict_reallocf";
    v33 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v33))
      goto LABEL_83;
    free(v33);
  }
  v11 = reallocf(v4[39], 16 * v10);
  if (v11)
  {
LABEL_22:
    v4[39] = v11;
    v5 = *((unsigned __int16 *)v4 + 161);
LABEL_26:
    v11[v5] = *a2;
    ++*((_WORD *)v4 + 161);
LABEL_27:

    return;
  }
  __nwlog_obj();
  v34 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v42 = "_strict_reallocf";
  v43 = 2048;
  *(_QWORD *)v44 = 16 * v10;
  v35 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v35))
  {
    free(v35);
    v11 = 0;
    goto LABEL_22;
  }
LABEL_83:
  __break(1u);
}

void sub_18301D7D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_endpoint_handler_report_connection_idle(void *a1, int a2)
{
  const char *v2;
  id v3;
  id v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v7;
  NWConcrete_nw_endpoint_handler *v8;
  char v9;
  NSObject *v10;
  NWConcrete_nw_endpoint_handler *v11;
  NWConcrete_nw_endpoint_handler *v12;
  char v13;
  const char *v14;
  nw_endpoint_t v15;
  const char *v16;
  unsigned int *v17;
  unsigned int *v18;
  uint64_t v19;
  const char *v20;
  id v21;
  void *v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  const char *v31;
  void **v32;
  void **v33;
  const char *v34;
  os_log_type_t v35;
  const char *v36;
  const char *v37;
  void **v38;
  id v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(void);
  void *v44;
  NSObject *v45;
  os_log_type_t v46;
  const char *id_string;
  const char *v48;
  int v49;
  const char *logging_description;
  const char *v51;
  id v52;
  void *v53;
  const char *v54;
  char *backtrace_string;
  os_log_type_t v56;
  _BOOL4 v57;
  os_log_type_t v58;
  const char *v59;
  char *id_str;
  nw_endpoint_t v61;
  void *v62;
  char v63;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v66;
  __int16 v67;
  void *v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  void *v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  id v78;
  __int16 v79;
  const char *v80;
  uint64_t v81;

  LODWORD(v2) = a2;
  v81 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_endpoint_handler_report_connection_idle";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (!__nwlog_fault(v24, &type, &v63))
      goto LABEL_88;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v45 = objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v45 = objc_claimAutoreleasedReturnValue();
      v56 = type;
      v57 = os_log_type_enabled(v45, type);
      if (backtrace_string)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_endpoint_handler_report_connection_idle";
          v67 = 2082;
          v68 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v45, v56, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_88:
        v22 = 0;
        if (!v24)
          goto LABEL_64;
        goto LABEL_63;
      }
      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_182FBE000, v45, v56, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v45 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v45, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_182FBE000, v45, v58, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_88;
  }
  v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    v7 = nw_endpoint_handler_copy_flow(v5);
    v62 = v4;
    if (nw_endpoint_handler_get_minimize_logging(v5))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
      {
LABEL_47:
        v41 = *((_QWORD *)v7 + 51);
        buf[0] = v2;
        if (v41)
        {
          v42 = *(_QWORD *)(v41 + 24);
          if (v42)
          {
            v43 = *(void (**)(void))(v42 + 160);
            if (v43)
              v43();
          }
        }

        v22 = v62;
        goto LABEL_64;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v5);
        v48 = nw_endpoint_handler_dry_run_string(v5);
        v49 = (int)v2;
        v61 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v61);
        v2 = nw_endpoint_handler_state_string(v5);
        v51 = nw_endpoint_handler_mode_string(v5);
        v52 = nw_endpoint_handler_copy_current_path(v5);
        v53 = v52;
        *(_DWORD *)buf = 136448002;
        v66 = "nw_endpoint_handler_report_connection_idle";
        v54 = "not ";
        v68 = (void *)id_string;
        v67 = 2082;
        if (v49)
          v54 = "";
        v69 = 2082;
        v70 = v48;
        v71 = 2082;
        v72 = (void *)logging_description;
        v73 = 2082;
        v74 = v2;
        LOBYTE(v2) = v49;
        v75 = 2082;
        v76 = v51;
        v77 = 2114;
        v78 = v52;
        v79 = 2082;
        v80 = v54;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting connection %{public}sidle to protocols", buf, 0x52u);

      }
    }
    else
    {
      v8 = v5;
      v9 = *((_BYTE *)v8 + 268);

      if ((v9 & 0x20) != 0)
        goto LABEL_47;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        v11 = v8;

        v12 = v11;
        v13 = *((_BYTE *)v8 + 268);

        if ((v13 & 1) != 0)
          v14 = "dry-run ";
        else
          v14 = "";
        v15 = nw_endpoint_handler_copy_endpoint(v12);
        v16 = nw_endpoint_get_logging_description(v15);
        id_str = v11->id_str;
        v17 = v12;
        v18 = v17;
        v19 = v17[30];
        if (v19 > 5)
          v20 = "unknown-state";
        else
          v20 = off_1E149FC48[v19];
        v59 = v20;

        v32 = v18;
        v33 = v32;
        v34 = "path";
        switch(v5->mode)
        {
          case 0:
            break;
          case 1:
            v34 = "resolver";
            break;
          case 2:
            v34 = nw_endpoint_flow_mode_string(v32[31]);
            break;
          case 3:
            v34 = "proxy";
            break;
          case 4:
            v34 = "fallback";
            break;
          case 5:
            v34 = "transform";
            break;
          default:
            v34 = "unknown-mode";
            break;
        }

        v38 = v33;
        os_unfair_lock_lock((os_unfair_lock_t)v38 + 28);
        v39 = v38[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v38 + 28);

        v66 = "nw_endpoint_handler_report_connection_idle";
        v40 = "not ";
        *(_DWORD *)buf = 136448002;
        if ((_DWORD)v2)
          v40 = "";
        v67 = 2082;
        v68 = id_str;
        v69 = 2082;
        v70 = v14;
        v71 = 2082;
        v72 = (void *)v16;
        v73 = 2082;
        v74 = v59;
        v75 = 2082;
        v76 = v34;
        v77 = 2114;
        v78 = v39;
        v79 = 2082;
        v80 = v40;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting connection %{public}sidle to protocols", buf, 0x52u);

      }
    }

    goto LABEL_47;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v21 = (id)gLogObj;
  v22 = v4;
  if (mode > 5)
    v23 = "unknown-mode";
  else
    v23 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  v66 = "nw_endpoint_handler_report_connection_idle";
  v67 = 2082;
  v68 = (void *)v23;
  v69 = 2082;
  v70 = "flow";
  v24 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v63 = 0;
  if (!__nwlog_fault(v24, &type, &v63))
    goto LABEL_62;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = (id)gLogObj;
    v26 = type;
    if (os_log_type_enabled(v25, type))
    {
      if (mode > 5)
        v27 = "unknown-mode";
      else
        v27 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v66 = "nw_endpoint_handler_report_connection_idle";
      v67 = 2082;
      v68 = (void *)v27;
      v69 = 2082;
      v70 = "flow";
      _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_61:

LABEL_62:
    if (!v24)
      goto LABEL_64;
LABEL_63:
    free(v24);
    goto LABEL_64;
  }
  if (!v63)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = (id)gLogObj;
    v35 = type;
    if (os_log_type_enabled(v25, type))
    {
      if (mode > 5)
        v36 = "unknown-mode";
      else
        v36 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v66 = "nw_endpoint_handler_report_connection_idle";
      v67 = 2082;
      v68 = (void *)v36;
      v69 = 2082;
      v70 = "flow";
      _os_log_impl(&dword_182FBE000, v25, v35, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_61;
  }
  v28 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = (id)gLogObj;
  v29 = type;
  v30 = os_log_type_enabled(v25, type);
  if (!v28)
  {
    if (v30)
    {
      if (mode > 5)
        v37 = "unknown-mode";
      else
        v37 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v66 = "nw_endpoint_handler_report_connection_idle";
      v67 = 2082;
      v68 = (void *)v37;
      v69 = 2082;
      v70 = "flow";
      _os_log_impl(&dword_182FBE000, v25, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_61;
  }
  if (v30)
  {
    if (mode > 5)
      v31 = "unknown-mode";
    else
      v31 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    v66 = "nw_endpoint_handler_report_connection_idle";
    v67 = 2082;
    v68 = (void *)v31;
    v69 = 2082;
    v70 = "flow";
    v71 = 2082;
    v72 = v28;
    _os_log_impl(&dword_182FBE000, v25, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v28);
  if (v24)
    goto LABEL_63;
LABEL_64:

}

void sub_18301E1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void nw_protocol_udp_connected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *v3;
  void *v4;
  nw_protocol_callbacks *v5;
  void *v6;
  nw_protocol_callbacks *v7;
  nw_protocol_callbacks *v8;
  void (*connected)(nw_protocol *, nw_protocol *);
  nw_protocol_callbacks *v10;
  nw_protocol_callbacks *v11;
  void (**v12)(_QWORD);
  const void *v13;
  nw_protocol *v14;
  NSObject *v15;
  nw_protocol_callbacks *v16;
  nw_protocol_callbacks *v17;
  void (**v18)(_QWORD);
  const void *v19;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  const char *v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  NSObject *v30;
  char *v31;
  _BOOL4 v32;
  const char *v33;
  char *backtrace_string;
  _BOOL4 v35;
  char *v36;
  _BOOL4 v37;
  const char *v38;
  nw_protocol *default_input_handler;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v42;
  uint64_t (*get_path)(nw_protocol *);
  void *v44;
  nw_protocol *v45;
  nw_protocol *v46;
  void *v47;
  nw_protocol_callbacks *v48;
  nw_protocol_callbacks *v49;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v51;
  id v52;
  char csum_flags;
  __int16 output_handler_context_high;
  void *output_handler_context;
  unsigned __int8 *v56;
  __int16 v57;
  nw_protocol *stats_region;
  NSObject *v59;
  nw_protocol_callbacks *v60;
  nw_protocol_callbacks *v61;
  void (**v62)(_QWORD);
  const void *v63;
  nw_protocol_callbacks *v64;
  nw_protocol_callbacks *v65;
  void (**v66)(_QWORD);
  const void *v67;
  const char *name;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  const char *v73;
  _BOOL4 v74;
  const char *v75;
  const char *v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  const char *v80;
  const char *v81;
  char *v82;
  NSObject *v83;
  os_log_type_t v84;
  const char *v85;
  const char *v86;
  char *v87;
  _BOOL4 v88;
  const char *v89;
  char *v90;
  NSObject *v91;
  os_log_type_t v92;
  const char *v93;
  const char *v94;
  char *v95;
  _BOOL4 v96;
  const char *v97;
  char *v98;
  _BOOL4 v99;
  const char *v100;
  char *v101;
  _BOOL4 v102;
  const char *v103;
  const char *v104;
  const char *v105;
  NSObject *v106;
  char v107;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v110;
  __int16 v111;
  nw_protocol *v112;
  __int16 v113;
  nw_protocol *v114;
  __int16 v115;
  char *v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v110 = "nw_protocol_udp_connected";
    v26 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (!__nwlog_fault(v26, &type, &v107))
      goto LABEL_207;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v110 = "nw_protocol_udp_connected";
      v29 = "%{public}s called with null protocol";
    }
    else if (v107)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v28 = type;
      v35 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          v110 = "nw_protocol_udp_connected";
          v111 = 2082;
          v112 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_207:
        if (!v26)
          return;
        goto LABEL_208;
      }
      if (!v35)
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v110 = "nw_protocol_udp_connected";
      v29 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v110 = "nw_protocol_udp_connected";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_206;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v110 = "nw_protocol_udp_connected";
    v26 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (!__nwlog_fault(v26, &type, &v107))
      goto LABEL_207;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v107)
      {
        v27 = __nwlog_obj();
        v28 = type;
        if (!os_log_type_enabled(v27, type))
          goto LABEL_207;
        *(_DWORD *)buf = 136446210;
        v110 = "nw_protocol_udp_connected";
        v29 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_206;
      }
      v36 = (char *)__nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v28 = type;
      v37 = os_log_type_enabled(v27, type);
      if (!v36)
      {
        if (!v37)
          goto LABEL_207;
        *(_DWORD *)buf = 136446210;
        v110 = "nw_protocol_udp_connected";
        v29 = "%{public}s called with null udp, no backtrace";
        goto LABEL_206;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        v110 = "nw_protocol_udp_connected";
        v111 = 2082;
        v112 = (nw_protocol *)v36;
        v38 = "%{public}s called with null udp, dumping backtrace:%{public}s";
LABEL_140:
        _os_log_impl(&dword_182FBE000, v27, v28, v38, buf, 0x16u);
      }
LABEL_141:
      free(v36);
      if (!v26)
        return;
LABEL_208:
      v14 = (nw_protocol *)v26;
LABEL_32:
      free(v14);
      return;
    }
    v27 = __nwlog_obj();
    v28 = type;
    if (!os_log_type_enabled(v27, type))
      goto LABEL_207;
    *(_DWORD *)buf = 136446210;
    v110 = "nw_protocol_udp_connected";
    v29 = "%{public}s called with null udp";
LABEL_206:
    _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
    goto LABEL_207;
  }
  if (gLogDatapath)
  {
    v30 = __nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v110 = "nw_protocol_udp_connected";
      v111 = 2082;
      v112 = a1 + 3;
      _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got a connected event from the lower layer", buf, 0x16u);
    }
  }
  if (!a1->default_input_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v110 = "nw_protocol_udp_connected";
      v111 = 2082;
      v112 = a1 + 3;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler found, ignoring connected call", buf, 0x16u);
    }
    return;
  }
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
  if (_nw_signposts_enabled && kdebug_is_enabled())
  {
    kdebug_trace();
    if (a1[1].default_input_handler)
      goto LABEL_10;
  }
  else if (a1[1].default_input_handler)
  {
    goto LABEL_10;
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v110 = "__nw_protocol_get_path";
    v82 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (!__nwlog_fault(v82, &type, &v107))
      goto LABEL_241;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v83 = __nwlog_obj();
      v84 = type;
      if (!os_log_type_enabled(v83, type))
        goto LABEL_241;
      *(_DWORD *)buf = 136446210;
      v110 = "__nw_protocol_get_path";
      v85 = "%{public}s called with null protocol";
    }
    else if (v107)
    {
      v98 = (char *)__nw_create_backtrace_string();
      v83 = __nwlog_obj();
      v84 = type;
      v99 = os_log_type_enabled(v83, type);
      if (v98)
      {
        if (v99)
        {
          *(_DWORD *)buf = 136446466;
          v110 = "__nw_protocol_get_path";
          v111 = 2082;
          v112 = (nw_protocol *)v98;
          _os_log_impl(&dword_182FBE000, v83, v84, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v98);
        goto LABEL_241;
      }
      if (!v99)
      {
LABEL_241:
        if (v82)
          free(v82);
        goto LABEL_243;
      }
      *(_DWORD *)buf = 136446210;
      v110 = "__nw_protocol_get_path";
      v85 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v83 = __nwlog_obj();
      v84 = type;
      if (!os_log_type_enabled(v83, type))
        goto LABEL_241;
      *(_DWORD *)buf = 136446210;
      v110 = "__nw_protocol_get_path";
      v85 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v83, v84, v85, buf, 0xCu);
    goto LABEL_241;
  }
  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = default_input_handler[1].callbacks;
    if (callbacks)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  v42 = default_input_handler->callbacks;
  if (v42)
  {
    get_path = (uint64_t (*)(nw_protocol *))v42->get_path;
    if (get_path)
    {
      v44 = (void *)get_path(default_input_handler);
      if (handle != &nw_protocol_ref_counted_handle)
        goto LABEL_91;
      goto LABEL_90;
    }
  }
  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v110 = "__nw_protocol_get_path";
  if (!name)
    name = "invalid";
  v111 = 2082;
  v112 = (nw_protocol *)name;
  v113 = 2048;
  v114 = default_input_handler;
  v69 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v107 = 0;
  if (__nwlog_fault(v69, &type, &v107))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v70 = __nwlog_obj();
      v71 = type;
      if (!os_log_type_enabled(v70, type))
        goto LABEL_219;
      v72 = default_input_handler->identifier->name;
      if (!v72)
        v72 = "invalid";
      *(_DWORD *)buf = 136446722;
      v110 = "__nw_protocol_get_path";
      v111 = 2082;
      v112 = (nw_protocol *)v72;
      v113 = 2048;
      v114 = default_input_handler;
      v73 = "%{public}s protocol %{public}s (%p) has invalid get_path callback";
LABEL_218:
      _os_log_impl(&dword_182FBE000, v70, v71, v73, buf, 0x20u);
      goto LABEL_219;
    }
    if (!v107)
    {
      v70 = __nwlog_obj();
      v71 = type;
      if (!os_log_type_enabled(v70, type))
        goto LABEL_219;
      v100 = default_input_handler->identifier->name;
      if (!v100)
        v100 = "invalid";
      *(_DWORD *)buf = 136446722;
      v110 = "__nw_protocol_get_path";
      v111 = 2082;
      v112 = (nw_protocol *)v100;
      v113 = 2048;
      v114 = default_input_handler;
      v73 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, backtrace limit exceeded";
      goto LABEL_218;
    }
    v87 = (char *)__nw_create_backtrace_string();
    v70 = __nwlog_obj();
    v71 = type;
    v88 = os_log_type_enabled(v70, type);
    if (!v87)
    {
      if (!v88)
        goto LABEL_219;
      v103 = default_input_handler->identifier->name;
      if (!v103)
        v103 = "invalid";
      *(_DWORD *)buf = 136446722;
      v110 = "__nw_protocol_get_path";
      v111 = 2082;
      v112 = (nw_protocol *)v103;
      v113 = 2048;
      v114 = default_input_handler;
      v73 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, no backtrace";
      goto LABEL_218;
    }
    if (v88)
    {
      v89 = default_input_handler->identifier->name;
      if (!v89)
        v89 = "invalid";
      *(_DWORD *)buf = 136446978;
      v110 = "__nw_protocol_get_path";
      v111 = 2082;
      v112 = (nw_protocol *)v89;
      v113 = 2048;
      v114 = default_input_handler;
      v115 = 2082;
      v116 = v87;
      _os_log_impl(&dword_182FBE000, v70, v71, "%{public}s protocol %{public}s (%p) has invalid get_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v87);
  }
LABEL_219:
  if (v69)
    free(v69);
  v44 = 0;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_90:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v60 = default_input_handler[1].callbacks;
      if (v60)
      {
        v61 = (nw_protocol_callbacks *)((char *)v60 - 1);
        default_input_handler[1].callbacks = v61;
        if (!v61)
        {
          v62 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v62)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v62[2](v62);
            _Block_release(v62);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v63 = *(const void **)default_input_handler[1].flow_id;
            if (v63)
              _Block_release(v63);
          }
          free(default_input_handler);
        }
      }
    }
  }
LABEL_91:
  if (v44)
  {
    v45 = (nw_protocol *)os_retain(v44);
    a1[1].default_input_handler = v45;
    LODWORD(a1[2].default_input_handler) = nw_path_get_effective_traffic_class(v45);
    HIDWORD(a1[2].default_input_handler) = nw_path_get_maximum_datagram_size(a1[1].default_input_handler);
    v46 = a1->default_input_handler;
    if (v46)
    {
      v47 = v46->handle;
      if (v47 == &nw_protocol_ref_counted_handle)
      {
        v48 = v46[1].callbacks;
        if (v48)
          v46[1].callbacks = (nw_protocol_callbacks *)((char *)&v48->add_input_handler + 1);
      }
      v49 = v46->callbacks;
      if (v49)
      {
        get_parameters = (uint64_t (*)(nw_protocol *))v49->get_parameters;
        if (get_parameters)
        {
          v51 = (void *)get_parameters(v46);
          if (v47 != &nw_protocol_ref_counted_handle)
          {
LABEL_100:
            v52 = nw_parameters_copy_context(v51);
            a1[1].output_handler_context = nw_path_copy_flow_registration(v52, (uint64_t)a1);
            if (v52)
              os_release(v52);
            csum_flags = nw_path_get_csum_flags(v44);
            output_handler_context_high = HIWORD(a1[2].output_handler_context);
            if ((output_handler_context_high & 4) != 0 && (csum_flags & 4) != 0
              || (output_handler_context_high & 4) == 0 && (csum_flags & 0x40) != 0)
            {
              HIWORD(a1[2].output_handler_context) = output_handler_context_high & 0xFEF7 | 0x100;
            }
            output_handler_context = a1[1].output_handler_context;
            if (output_handler_context)
            {
              v56 = output_handler_context;
              v57 = v56[148];

              HIWORD(a1[2].output_handler_context) = HIWORD(a1[2].output_handler_context) & 0xFFF7 | (4 * v57) & 8;
              a1[2].handle = nw_path_flow_registration_get_stats_area((uint64_t)a1[1].output_handler_context, 2);
              stats_region = (nw_protocol *)nw_path_flow_registration_get_stats_region(a1[1].output_handler_context, (uint64_t)a1->identifier->name);
              a1[2].output_handler = stats_region;
              if (!stats_region)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v59 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v110 = "nw_protocol_udp_connected";
                  v111 = 2082;
                  v112 = a1 + 3;
                  v113 = 2048;
                  v114 = (nw_protocol *)&g_udp_stats;
                  _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp->udp_stats is NULL setting to global %p", buf, 0x20u);
                }
                a1[2].output_handler = (nw_protocol *)&g_udp_stats;
              }
            }
            goto LABEL_10;
          }
LABEL_99:
          if (v46->handle == &nw_protocol_ref_counted_handle)
          {
            v64 = v46[1].callbacks;
            if (v64)
            {
              v65 = (nw_protocol_callbacks *)((char *)v64 - 1);
              v46[1].callbacks = v65;
              if (!v65)
              {
                v66 = *(void (***)(_QWORD))v46[1].flow_id;
                if (v66)
                {
                  *(_QWORD *)v46[1].flow_id = 0;
                  v66[2](v66);
                  _Block_release(v66);
                }
                if ((v46[1].flow_id[8] & 1) != 0)
                {
                  v67 = *(const void **)v46[1].flow_id;
                  if (v67)
                    _Block_release(v67);
                }
                free(v46);
              }
            }
          }
          goto LABEL_100;
        }
      }
      __nwlog_obj();
      v75 = v46->identifier->name;
      *(_DWORD *)buf = 136446722;
      v110 = "__nw_protocol_get_parameters";
      if (!v75)
        v75 = "invalid";
      v111 = 2082;
      v112 = (nw_protocol *)v75;
      v113 = 2048;
      v114 = v46;
      v76 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v107 = 0;
      v77 = (char *)v76;
      if (__nwlog_fault(v76, &type, &v107))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v78 = __nwlog_obj();
          v79 = type;
          if (!os_log_type_enabled(v78, type))
            goto LABEL_234;
          v80 = v46->identifier->name;
          if (!v80)
            v80 = "invalid";
          *(_DWORD *)buf = 136446722;
          v110 = "__nw_protocol_get_parameters";
          v111 = 2082;
          v112 = (nw_protocol *)v80;
          v113 = 2048;
          v114 = v46;
          v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_233:
          _os_log_impl(&dword_182FBE000, v78, v79, v81, buf, 0x20u);
          goto LABEL_234;
        }
        if (!v107)
        {
          v78 = __nwlog_obj();
          v79 = type;
          if (!os_log_type_enabled(v78, type))
            goto LABEL_234;
          v104 = v46->identifier->name;
          if (!v104)
            v104 = "invalid";
          *(_DWORD *)buf = 136446722;
          v110 = "__nw_protocol_get_parameters";
          v111 = 2082;
          v112 = (nw_protocol *)v104;
          v113 = 2048;
          v114 = v46;
          v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
          goto LABEL_233;
        }
        v95 = (char *)__nw_create_backtrace_string();
        v78 = __nwlog_obj();
        v79 = type;
        v96 = os_log_type_enabled(v78, type);
        if (!v95)
        {
          if (!v96)
            goto LABEL_234;
          v105 = v46->identifier->name;
          if (!v105)
            v105 = "invalid";
          *(_DWORD *)buf = 136446722;
          v110 = "__nw_protocol_get_parameters";
          v111 = 2082;
          v112 = (nw_protocol *)v105;
          v113 = 2048;
          v114 = v46;
          v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
          goto LABEL_233;
        }
        if (v96)
        {
          if (v46->identifier)
            v97 = v46->identifier->name;
          else
            v97 = "invalid";
          *(_DWORD *)buf = 136446978;
          v110 = "__nw_protocol_get_parameters";
          v111 = 2082;
          v112 = (nw_protocol *)v97;
          v113 = 2048;
          v114 = v46;
          v115 = 2082;
          v116 = v95;
          _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v95);
      }
LABEL_234:
      if (v77)
        free(v77);
      v51 = 0;
      if (v47 != &nw_protocol_ref_counted_handle)
        goto LABEL_100;
      goto LABEL_99;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v110 = "__nw_protocol_get_parameters";
    v90 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (__nwlog_fault(v90, &type, &v107))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v91 = __nwlog_obj();
        v92 = type;
        if (os_log_type_enabled(v91, type))
        {
          *(_DWORD *)buf = 136446210;
          v110 = "__nw_protocol_get_parameters";
          v93 = "%{public}s called with null protocol";
LABEL_249:
          _os_log_impl(&dword_182FBE000, v91, v92, v93, buf, 0xCu);
        }
      }
      else if (v107)
      {
        v101 = (char *)__nw_create_backtrace_string();
        v91 = __nwlog_obj();
        v92 = type;
        v102 = os_log_type_enabled(v91, type);
        if (v101)
        {
          if (v102)
          {
            *(_DWORD *)buf = 136446466;
            v110 = "__nw_protocol_get_parameters";
            v111 = 2082;
            v112 = (nw_protocol *)v101;
            _os_log_impl(&dword_182FBE000, v91, v92, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v101);
          goto LABEL_250;
        }
        if (v102)
        {
          *(_DWORD *)buf = 136446210;
          v110 = "__nw_protocol_get_parameters";
          v93 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_249;
        }
      }
      else
      {
        v91 = __nwlog_obj();
        v92 = type;
        if (os_log_type_enabled(v91, type))
        {
          *(_DWORD *)buf = 136446210;
          v110 = "__nw_protocol_get_parameters";
          v93 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_249;
        }
      }
    }
LABEL_250:
    if (v90)
      free(v90);
    v51 = 0;
    goto LABEL_100;
  }
LABEL_243:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v106 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v110 = "nw_protocol_udp_connected";
    v111 = 2082;
    v112 = a1 + 3;
    _os_log_impl(&dword_182FBE000, v106, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Unable to get path from input protocol, cannot publish UDP stats", buf, 0x16u);
  }
LABEL_10:
  v3 = a1->default_input_handler;
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v110 = "__nw_protocol_connected";
    v26 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (!__nwlog_fault(v26, &type, &v107))
      goto LABEL_207;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v110 = "__nw_protocol_connected";
      v29 = "%{public}s called with null protocol";
      goto LABEL_206;
    }
    if (!v107)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v110 = "__nw_protocol_connected";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_206;
    }
    v36 = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v74 = os_log_type_enabled(v27, type);
    if (!v36)
    {
      if (!v74)
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      v110 = "__nw_protocol_connected";
      v29 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_206;
    }
    if (v74)
    {
      *(_DWORD *)buf = 136446466;
      v110 = "__nw_protocol_connected";
      v111 = 2082;
      v112 = (nw_protocol *)v36;
      v38 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_140;
    }
    goto LABEL_141;
  }
  v4 = v3->handle;
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = v3[1].callbacks;
    if (v5)
      v3[1].callbacks = (nw_protocol_callbacks *)((char *)&v5->add_input_handler + 1);
  }
  v6 = a1->handle;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = a1[1].callbacks;
    if (v7)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
  }
  v8 = v3->callbacks;
  if (v8)
  {
    connected = (void (*)(nw_protocol *, nw_protocol *))v8->connected;
    if (connected)
    {
      connected(v3, a1);
      goto LABEL_20;
    }
  }
  __nwlog_obj();
  v20 = v3->identifier->name;
  *(_DWORD *)buf = 136446722;
  v110 = "__nw_protocol_connected";
  if (!v20)
    v20 = "invalid";
  v111 = 2082;
  v112 = (nw_protocol *)v20;
  v113 = 2048;
  v114 = v3;
  v21 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v107 = 0;
  if (__nwlog_fault(v21, &type, &v107))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_179;
      v24 = v3->identifier->name;
      if (!v24)
        v24 = "invalid";
      *(_DWORD *)buf = 136446722;
      v110 = "__nw_protocol_connected";
      v111 = 2082;
      v112 = (nw_protocol *)v24;
      v113 = 2048;
      v114 = v3;
      v25 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_178;
    }
    if (!v107)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_179;
      v86 = v3->identifier->name;
      if (!v86)
        v86 = "invalid";
      *(_DWORD *)buf = 136446722;
      v110 = "__nw_protocol_connected";
      v111 = 2082;
      v112 = (nw_protocol *)v86;
      v113 = 2048;
      v114 = v3;
      v25 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_178;
    }
    v31 = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v32 = os_log_type_enabled(v22, type);
    if (v31)
    {
      if (v32)
      {
        v33 = v3->identifier->name;
        if (!v33)
          v33 = "invalid";
        *(_DWORD *)buf = 136446978;
        v110 = "__nw_protocol_connected";
        v111 = 2082;
        v112 = (nw_protocol *)v33;
        v113 = 2048;
        v114 = v3;
        v115 = 2082;
        v116 = v31;
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v31);
      goto LABEL_179;
    }
    if (v32)
    {
      v94 = v3->identifier->name;
      if (!v94)
        v94 = "invalid";
      *(_DWORD *)buf = 136446722;
      v110 = "__nw_protocol_connected";
      v111 = 2082;
      v112 = (nw_protocol *)v94;
      v113 = 2048;
      v114 = v3;
      v25 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_178:
      _os_log_impl(&dword_182FBE000, v22, v23, v25, buf, 0x20u);
    }
  }
LABEL_179:
  if (v21)
    free(v21);
LABEL_20:
  if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    v16 = a1[1].callbacks;
    if (v16)
    {
      v17 = (nw_protocol_callbacks *)((char *)v16 - 1);
      a1[1].callbacks = v17;
      if (!v17)
      {
        v18 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v18)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v18[2](v18);
          _Block_release(v18);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v19 = *(const void **)a1[1].flow_id;
          if (v19)
            _Block_release(v19);
        }
        free(a1);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && v3->handle == &nw_protocol_ref_counted_handle)
  {
    v10 = v3[1].callbacks;
    if (v10)
    {
      v11 = (nw_protocol_callbacks *)((char *)v10 - 1);
      v3[1].callbacks = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))v3[1].flow_id;
        if (v12)
        {
          *(_QWORD *)v3[1].flow_id = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((v3[1].flow_id[8] & 1) != 0)
        {
          v13 = *(const void **)v3[1].flow_id;
          if (v13)
            _Block_release(v13);
        }
        v14 = v3;
        goto LABEL_32;
      }
    }
  }
}

int *nw_protocol_instance_get_stats(void *a1, int a2, uint64_t a3)
{
  NWConcrete_nw_protocol_instance *v5;
  NWConcrete_nw_protocol_instance *v6;
  uint64_t v7;
  uint64_t wakeup;
  int *stats_area;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_instance_get_stats";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v11, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_protocol_instance_get_stats";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_24:
    if (v11)
      free(v11);
    goto LABEL_26;
  }
  if (a3)
  {
    v7 = nw_protocol_implementation_lookup_path(v5, a3, 0);
    if (v7)
    {
      wakeup = *(_QWORD *)(v7 + 24);
      if (wakeup)
        goto LABEL_7;
    }
LABEL_26:
    stats_area = 0;
    goto LABEL_27;
  }
  wakeup = (uint64_t)v5->wakeup;
  if (!wakeup)
    goto LABEL_26;
LABEL_7:
  stats_area = nw_path_flow_registration_get_stats_area(wakeup, a2);
LABEL_27:

  return stats_area;
}

void sub_18301FB08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

int *nw_path_flow_registration_get_stats_area(uint64_t a1, int a2)
{
  int *result;
  int v5;
  NSObject *v8;
  _DWORD *v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  NWConcrete_nw_path_evaluator *v17;
  id v18;
  os_log_type_t v19;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  _WORD v33[17];

  *(_QWORD *)&v33[13] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_flow_registration_get_stats_area";
    v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v21, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null registration", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        v26 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v31 = "nw_path_flow_registration_get_stats_area";
            v32 = 2082;
            *(_QWORD *)v33 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null registration, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null registration, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s called with null registration, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_56:
    if (v21)
      free(v21);
    return 0;
  }
  if ((*(_BYTE *)(a1 + 148) & 1) == 0)
    return 0;
  if ((a2 - 1) >= 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v31 = "nw_path_flow_registration_get_stats_area";
    v32 = 1024;
    *(_DWORD *)v33 = a2;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_flow_registration_get_stats_area";
          v32 = 1024;
          *(_DWORD *)v33 = a2;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s Requested unknown stats type %u", buf, 0x12u);
        }
      }
      else if (v28)
      {
        v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (v14)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446722;
            v31 = "nw_path_flow_registration_get_stats_area";
            v32 = 1024;
            *(_DWORD *)v33 = a2;
            v33[2] = 2082;
            *(_QWORD *)&v33[3] = v14;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s Requested unknown stats type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v11)
            return 0;
          goto LABEL_24;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_flow_registration_get_stats_area";
          v32 = 1024;
          *(_DWORD *)v33 = a2;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s Requested unknown stats type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_flow_registration_get_stats_area";
          v32 = 1024;
          *(_DWORD *)v33 = a2;
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s Requested unknown stats type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
    if (v11)
LABEL_24:
      free(v11);
    return 0;
  }
  result = *(int **)(a1 + 64);
  if (!result || (v5 = *result) == 0)
  {
    v17 = nw_path_flow_registration_copy_parent_evaluator((NWConcrete_nw_path_flow_registration *)a1);
    v18 = nw_parameters_copy_context(*((void **)v17 + 1));
    nw_context_assert_queue(v18);
    *(_QWORD *)(a1 + 64) = 0;

    return 0;
  }
  if ((v5 != 3 || a2 != 2) && v5 != a2)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = *(_DWORD **)(a1 + 64);
      if (v9)
        LODWORD(v9) = *v9;
      *(_DWORD *)buf = 136446722;
      v31 = "nw_path_flow_registration_get_stats_area";
      v32 = 1024;
      *(_DWORD *)v33 = (_DWORD)v9;
      v33[2] = 1024;
      *(_DWORD *)&v33[3] = a2;
      _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s Requested stats type does not match allocated type (%u != %u)", buf, 0x18u);
    }

    return 0;
  }
  return result;
}

void sub_183020118(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_channel_connect(nw_protocol *a1, nw_protocol *a2)
{
  _WORD *handle;
  nw_protocol *v4;
  char *output_handler_context;
  BOOL v6;
  _QWORD *v7;
  nw_protocol_callbacks *callbacks;
  void (*connected)(nw_protocol *, nw_protocol *);
  void *v10;
  nw_protocol_callbacks *v11;
  nw_protocol_callbacks *v12;
  uint64_t result;
  void *v14;
  nw_protocol_callbacks *v15;
  void *v16;
  nw_protocol_callbacks *v17;
  nw_protocol_callbacks *v18;
  void (*input_available)(nw_protocol *, nw_protocol *);
  nw_protocol_callbacks *v20;
  void (*input_flush)(nw_protocol *, nw_protocol *);
  void *v22;
  nw_protocol_callbacks *v23;
  nw_protocol_callbacks *v24;
  nw_protocol_callbacks *v25;
  void (**v26)(_QWORD);
  const void *v27;
  nw_protocol_callbacks *v28;
  nw_protocol_callbacks *v29;
  void (**v30)(_QWORD);
  const void *v31;
  nw_protocol_callbacks *v32;
  nw_protocol_callbacks *v33;
  nw_protocol_callbacks *v34;
  void (**v35)(_QWORD);
  const void *v36;
  nw_protocol_callbacks *v37;
  nw_protocol_callbacks *v38;
  void (**v39)(_QWORD);
  const void *v40;
  nw_protocol_callbacks *v41;
  nw_protocol_callbacks *v42;
  void (**v43)(_QWORD);
  const void *v44;
  nw_protocol_callbacks *v45;
  nw_protocol_callbacks *v46;
  void (**v47)(_QWORD);
  const void *v48;
  char *v49;
  NSObject *v50;
  os_log_type_t v51;
  const char *v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  const char *name;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  const char *v62;
  char *backtrace_string;
  _BOOL4 v64;
  const char *v65;
  _BOOL4 v66;
  char *v67;
  _BOOL4 v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  char *v72;
  _BOOL4 v73;
  const char *v74;
  char *v75;
  _BOOL4 v76;
  const char *v77;
  const char *v78;
  char v79;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v82;
  __int16 v83;
  void *v84;
  __int16 v85;
  nw_protocol *v86;
  __int16 v87;
  char *v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "nw_channel_connect";
    v49 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    if (!__nwlog_fault(v49, &type, &v79))
      goto LABEL_163;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v50 = __nwlog_obj();
      v51 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446210;
        v82 = "nw_channel_connect";
        v52 = "%{public}s called with null channel_protocol";
LABEL_162:
        _os_log_impl(&dword_182FBE000, v50, v51, v52, buf, 0xCu);
      }
LABEL_163:
      if (v49)
        free(v49);
      return 0;
    }
    if (!v79)
    {
      v50 = __nwlog_obj();
      v51 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446210;
        v82 = "nw_channel_connect";
        v52 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
        goto LABEL_162;
      }
      goto LABEL_163;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v50 = __nwlog_obj();
    v51 = type;
    v64 = os_log_type_enabled(v50, type);
    if (!backtrace_string)
    {
      if (v64)
      {
        *(_DWORD *)buf = 136446210;
        v82 = "nw_channel_connect";
        v52 = "%{public}s called with null channel_protocol, no backtrace";
        goto LABEL_162;
      }
      goto LABEL_163;
    }
    if (v64)
    {
      *(_DWORD *)buf = 136446466;
      v82 = "nw_channel_connect";
      v83 = 2082;
      v84 = backtrace_string;
      v65 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_127:
      _os_log_impl(&dword_182FBE000, v50, v51, v65, buf, 0x16u);
    }
LABEL_128:
    free(backtrace_string);
    goto LABEL_163;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "nw_channel_connect";
    v49 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    if (!__nwlog_fault(v49, &type, &v79))
      goto LABEL_163;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v50 = __nwlog_obj();
      v51 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446210;
        v82 = "nw_channel_connect";
        v52 = "%{public}s called with null channel";
        goto LABEL_162;
      }
      goto LABEL_163;
    }
    if (!v79)
    {
      v50 = __nwlog_obj();
      v51 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446210;
        v82 = "nw_channel_connect";
        v52 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_162;
      }
      goto LABEL_163;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v50 = __nwlog_obj();
    v51 = type;
    v66 = os_log_type_enabled(v50, type);
    if (!backtrace_string)
    {
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        v82 = "nw_channel_connect";
        v52 = "%{public}s called with null channel, no backtrace";
        goto LABEL_162;
      }
      goto LABEL_163;
    }
    if (v66)
    {
      *(_DWORD *)buf = 136446466;
      v82 = "nw_channel_connect";
      v83 = 2082;
      v84 = backtrace_string;
      v65 = "%{public}s called with null channel, dumping backtrace:%{public}s";
      goto LABEL_127;
    }
    goto LABEL_128;
  }
  v4 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "__nw_protocol_get_output_handler_context";
    v53 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    if (__nwlog_fault(v53, &type, &v79))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v54 = __nwlog_obj();
        v55 = type;
        if (os_log_type_enabled(v54, type))
        {
          *(_DWORD *)buf = 136446210;
          v82 = "__nw_protocol_get_output_handler_context";
          v56 = "%{public}s called with null protocol";
LABEL_168:
          _os_log_impl(&dword_182FBE000, v54, v55, v56, buf, 0xCu);
        }
      }
      else if (v79)
      {
        v67 = (char *)__nw_create_backtrace_string();
        v54 = __nwlog_obj();
        v55 = type;
        v68 = os_log_type_enabled(v54, type);
        if (v67)
        {
          if (v68)
          {
            *(_DWORD *)buf = 136446466;
            v82 = "__nw_protocol_get_output_handler_context";
            v83 = 2082;
            v84 = v67;
            _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v67);
          goto LABEL_169;
        }
        if (v68)
        {
          *(_DWORD *)buf = 136446210;
          v82 = "__nw_protocol_get_output_handler_context";
          v56 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_168;
        }
      }
      else
      {
        v54 = __nwlog_obj();
        v55 = type;
        if (os_log_type_enabled(v54, type))
        {
          *(_DWORD *)buf = 136446210;
          v82 = "__nw_protocol_get_output_handler_context";
          v56 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_168;
        }
      }
    }
LABEL_169:
    if (v53)
      free(v53);
    v7 = 0;
    v6 = 1;
    goto LABEL_19;
  }
  output_handler_context = (char *)a2->output_handler_context;
  v6 = output_handler_context == 0;
  if (output_handler_context)
  {
    v7 = output_handler_context + 32;
    output_handler_context[153] |= 8u;
    callbacks = a2->callbacks;
    if (!callbacks)
      goto LABEL_19;
  }
  else
  {
    v7 = 0;
    callbacks = a2->callbacks;
    if (!callbacks)
      goto LABEL_19;
  }
  connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
  if (connected)
  {
    v10 = a2->handle;
    if (v10 == &nw_protocol_ref_counted_handle)
    {
      v11 = a2[1].callbacks;
      if (v11)
        a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v11->add_input_handler + 1);
    }
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      v12 = a1[1].callbacks;
      if (v12)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v12->add_input_handler + 1);
      connected(a2, a1);
      if (a1->handle == &nw_protocol_ref_counted_handle)
      {
        v24 = a1[1].callbacks;
        if (v24)
        {
          v25 = (nw_protocol_callbacks *)((char *)v24 - 1);
          a1[1].callbacks = v25;
          if (!v25)
          {
            v26 = *(void (***)(_QWORD))a1[1].flow_id;
            if (v26)
            {
              *(_QWORD *)a1[1].flow_id = 0;
              v26[2](v26);
              _Block_release(v26);
            }
            if ((a1[1].flow_id[8] & 1) != 0)
            {
              v27 = *(const void **)a1[1].flow_id;
              if (v27)
                _Block_release(v27);
            }
            free(a1);
          }
        }
      }
    }
    else
    {
      connected(a2, a1);
    }
    if (v10 == &nw_protocol_ref_counted_handle && v4->handle == &nw_protocol_ref_counted_handle)
    {
      v28 = v4[1].callbacks;
      if (v28)
      {
        v29 = (nw_protocol_callbacks *)((char *)v28 - 1);
        v4[1].callbacks = v29;
        if (!v29)
        {
          v30 = *(void (***)(_QWORD))v4[1].flow_id;
          if (v30)
          {
            *(_QWORD *)v4[1].flow_id = 0;
            v30[2](v30);
            _Block_release(v30);
          }
          if ((v4[1].flow_id[8] & 1) != 0)
          {
            v31 = *(const void **)v4[1].flow_id;
            if (v31)
              _Block_release(v31);
          }
          free(v4);
        }
      }
    }
  }
LABEL_19:
  result = 1;
  if (!v6 && v7 && (handle[222] & 0x80) != 0 && *v7)
  {
    if (v4)
    {
      v14 = v4->handle;
      if (v14 == &nw_protocol_ref_counted_handle)
      {
        v15 = v4[1].callbacks;
        if (v15)
          v4[1].callbacks = (nw_protocol_callbacks *)((char *)&v15->add_input_handler + 1);
      }
      v16 = a1->handle;
      if (v16 == &nw_protocol_ref_counted_handle)
      {
        v17 = a1[1].callbacks;
        if (v17)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v17->add_input_handler + 1);
      }
      v18 = v4->callbacks;
      if (v18)
      {
        input_available = (void (*)(nw_protocol *, nw_protocol *))v18->input_available;
        if (input_available)
        {
          input_available(v4, a1);
LABEL_33:
          if (v16 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
          {
            v33 = a1[1].callbacks;
            if (v33)
            {
              v34 = (nw_protocol_callbacks *)((char *)v33 - 1);
              a1[1].callbacks = v34;
              if (!v34)
              {
                v35 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v35)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v35[2](v35);
                  _Block_release(v35);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v36 = *(const void **)a1[1].flow_id;
                  if (v36)
                    _Block_release(v36);
                }
                free(a1);
              }
            }
          }
          if (v14 == &nw_protocol_ref_counted_handle && v4->handle == &nw_protocol_ref_counted_handle)
          {
            v37 = v4[1].callbacks;
            if (v37)
            {
              v38 = (nw_protocol_callbacks *)((char *)v37 - 1);
              v4[1].callbacks = v38;
              if (!v38)
              {
                v39 = *(void (***)(_QWORD))v4[1].flow_id;
                if (v39)
                {
                  *(_QWORD *)v4[1].flow_id = 0;
                  v39[2](v39);
                  _Block_release(v39);
                }
                if ((v4[1].flow_id[8] & 1) != 0)
                {
                  v40 = *(const void **)v4[1].flow_id;
                  if (v40)
                    _Block_release(v40);
                }
                free(v4);
              }
            }
          }
          v20 = v4->callbacks;
          if (!v20)
            return 1;
          input_flush = (void (*)(nw_protocol *, nw_protocol *))v20->input_flush;
          if (!input_flush)
            return 1;
          v22 = v4->handle;
          if (v22 == &nw_protocol_ref_counted_handle)
          {
            v23 = v4[1].callbacks;
            if (v23)
              v4[1].callbacks = (nw_protocol_callbacks *)((char *)&v23->add_input_handler + 1);
          }
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v32 = a1[1].callbacks;
            if (v32)
              a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
            input_flush(v4, a1);
            if (a1->handle == &nw_protocol_ref_counted_handle)
            {
              v41 = a1[1].callbacks;
              if (v41)
              {
                v42 = (nw_protocol_callbacks *)((char *)v41 - 1);
                a1[1].callbacks = v42;
                if (!v42)
                {
                  v43 = *(void (***)(_QWORD))a1[1].flow_id;
                  if (v43)
                  {
                    *(_QWORD *)a1[1].flow_id = 0;
                    v43[2](v43);
                    _Block_release(v43);
                  }
                  if ((a1[1].flow_id[8] & 1) != 0)
                  {
                    v44 = *(const void **)a1[1].flow_id;
                    if (v44)
                      _Block_release(v44);
                  }
                  free(a1);
                }
              }
            }
          }
          else
          {
            input_flush(v4, a1);
          }
          if (v22 != &nw_protocol_ref_counted_handle)
            return 1;
          if (v4->handle != &nw_protocol_ref_counted_handle)
            return 1;
          v45 = v4[1].callbacks;
          if (!v45)
            return 1;
          v46 = (nw_protocol_callbacks *)((char *)v45 - 1);
          v4[1].callbacks = v46;
          if (v46)
            return 1;
          v47 = *(void (***)(_QWORD))v4[1].flow_id;
          if (v47)
          {
            *(_QWORD *)v4[1].flow_id = 0;
            v47[2](v47);
            _Block_release(v47);
          }
          if ((v4[1].flow_id[8] & 1) != 0)
          {
            v48 = *(const void **)v4[1].flow_id;
            if (v48)
              _Block_release(v48);
          }
          goto LABEL_98;
        }
      }
      __nwlog_obj();
      name = v4->identifier->name;
      *(_DWORD *)buf = 136446722;
      v82 = "__nw_protocol_input_available";
      if (!name)
        name = "invalid";
      v83 = 2082;
      v84 = (void *)name;
      v85 = 2048;
      v86 = v4;
      v58 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v79 = 0;
      if (__nwlog_fault(v58, &type, &v79))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v59 = __nwlog_obj();
          v60 = type;
          if (!os_log_type_enabled(v59, type))
            goto LABEL_181;
          v61 = v4->identifier->name;
          if (!v61)
            v61 = "invalid";
          *(_DWORD *)buf = 136446722;
          v82 = "__nw_protocol_input_available";
          v83 = 2082;
          v84 = (void *)v61;
          v85 = 2048;
          v86 = v4;
          v62 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
          goto LABEL_180;
        }
        if (!v79)
        {
          v59 = __nwlog_obj();
          v60 = type;
          if (!os_log_type_enabled(v59, type))
            goto LABEL_181;
          v77 = v4->identifier->name;
          if (!v77)
            v77 = "invalid";
          *(_DWORD *)buf = 136446722;
          v82 = "__nw_protocol_input_available";
          v83 = 2082;
          v84 = (void *)v77;
          v85 = 2048;
          v86 = v4;
          v62 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
          goto LABEL_180;
        }
        v72 = (char *)__nw_create_backtrace_string();
        v59 = __nwlog_obj();
        v60 = type;
        v73 = os_log_type_enabled(v59, type);
        if (v72)
        {
          if (v73)
          {
            if (v4->identifier)
              v74 = v4->identifier->name;
            else
              v74 = "invalid";
            *(_DWORD *)buf = 136446978;
            v82 = "__nw_protocol_input_available";
            v83 = 2082;
            v84 = (void *)v74;
            v85 = 2048;
            v86 = v4;
            v87 = 2082;
            v88 = v72;
            _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v72);
          goto LABEL_181;
        }
        if (v73)
        {
          v78 = v4->identifier->name;
          if (!v78)
            v78 = "invalid";
          *(_DWORD *)buf = 136446722;
          v82 = "__nw_protocol_input_available";
          v83 = 2082;
          v84 = (void *)v78;
          v85 = 2048;
          v86 = v4;
          v62 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
LABEL_180:
          _os_log_impl(&dword_182FBE000, v59, v60, v62, buf, 0x20u);
        }
      }
LABEL_181:
      if (v58)
        free(v58);
      goto LABEL_33;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "__nw_protocol_input_available";
    v4 = (nw_protocol *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v79))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v69 = __nwlog_obj();
        v70 = type;
        if (!os_log_type_enabled(v69, type))
          goto LABEL_188;
        *(_DWORD *)buf = 136446210;
        v82 = "__nw_protocol_input_available";
        v71 = "%{public}s called with null protocol";
        goto LABEL_187;
      }
      if (!v79)
      {
        v69 = __nwlog_obj();
        v70 = type;
        if (!os_log_type_enabled(v69, type))
          goto LABEL_188;
        *(_DWORD *)buf = 136446210;
        v82 = "__nw_protocol_input_available";
        v71 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_187;
      }
      v75 = (char *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = type;
      v76 = os_log_type_enabled(v69, type);
      if (v75)
      {
        if (v76)
        {
          *(_DWORD *)buf = 136446466;
          v82 = "__nw_protocol_input_available";
          v83 = 2082;
          v84 = v75;
          _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v75);
        if (!v4)
          return 1;
LABEL_98:
        free(v4);
        return 1;
      }
      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        v82 = "__nw_protocol_input_available";
        v71 = "%{public}s called with null protocol, no backtrace";
LABEL_187:
        _os_log_impl(&dword_182FBE000, v69, v70, v71, buf, 0xCu);
      }
    }
LABEL_188:
    if (!v4)
      return 1;
    goto LABEL_98;
  }
  return result;
}

void nw_protocol_ipv4_connected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*connected)(nw_protocol *, nw_protocol *);
  void *handle;
  nw_protocol_callbacks *v8;
  void *v9;
  nw_protocol_callbacks *v10;
  nw_protocol_callbacks *v11;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v13;
  id v14;
  id v15;
  void *v16;
  nw_protocol_identifier *stats_region;
  nw_protocol *output_handler;
  nw_protocol_callbacks *v19;
  void (*get_message_properties)(nw_protocol *, nw_protocol *, _BYTE *);
  void *v21;
  nw_protocol_callbacks *v22;
  nw_protocol_callbacks *v23;
  nw_protocol_callbacks *v24;
  nw_protocol_callbacks *v25;
  void (**v26)(_QWORD);
  const void *v27;
  nw_protocol *v28;
  nw_protocol_callbacks *v29;
  nw_protocol_callbacks *v30;
  void (*v31)(nw_protocol *, nw_protocol *);
  nw_protocol_callbacks *v32;
  nw_protocol_callbacks *v33;
  nw_protocol_callbacks *v34;
  nw_protocol_callbacks *v35;
  void (**v36)(_QWORD);
  const void *v37;
  nw_protocol_callbacks *v38;
  nw_protocol_callbacks *v39;
  void (**v40)(_QWORD);
  const void *v41;
  nw_protocol *v42;
  nw_protocol_callbacks *v43;
  nw_protocol_callbacks *v44;
  void (**v45)(_QWORD);
  const void *v46;
  nw_protocol_callbacks *v47;
  nw_protocol_callbacks *v48;
  void (**v49)(_QWORD);
  const void *v50;
  nw_protocol_callbacks *v51;
  nw_protocol_callbacks *v52;
  void (**v53)(_QWORD);
  const void *v54;
  const char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  NSObject *v59;
  const char *name;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  const char *v64;
  const char *v65;
  char *backtrace_string;
  _BOOL4 v67;
  char *v68;
  _BOOL4 v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  char *v74;
  _BOOL4 v75;
  const char *v76;
  char *v77;
  _BOOL4 v78;
  const char *v79;
  NSObject *v80;
  const char *v81;
  void *v82;
  char v83;
  os_log_type_t type;
  _BYTE buf[12];
  __int16 v86;
  char *v87;
  __int16 v88;
  const char *v89;
  __int16 v90;
  char *p_output_handler;
  __int16 v92;
  void *v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
    v55 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (!__nwlog_fault(v55, &type, &v83))
      goto LABEL_171;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
      v58 = "%{public}s called with null protocol";
      goto LABEL_170;
    }
    if (!v83)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
      v58 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_170;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type;
    v67 = os_log_type_enabled(v56, type);
    if (!backtrace_string)
    {
      if (!v67)
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
      v58 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_170;
    }
    if (v67)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
      v86 = 2082;
      v87 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_171:
    if (!v55)
      return;
    goto LABEL_172;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
    v55 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (!__nwlog_fault(v55, &type, &v83))
      goto LABEL_171;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
      v58 = "%{public}s called with null ipv4";
      goto LABEL_170;
    }
    if (!v83)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
      v58 = "%{public}s called with null ipv4, backtrace limit exceeded";
      goto LABEL_170;
    }
    v68 = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type;
    v69 = os_log_type_enabled(v56, type);
    if (v68)
    {
      if (v69)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
        v86 = 2082;
        v87 = v68;
        _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s called with null ipv4, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v68);
      if (!v55)
        return;
LABEL_172:
      v42 = (nw_protocol *)v55;
LABEL_88:
      free(v42);
      return;
    }
    if (v69)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
      v58 = "%{public}s called with null ipv4, no backtrace";
LABEL_170:
      _os_log_impl(&dword_182FBE000, v56, v57, v58, buf, 0xCu);
      goto LABEL_171;
    }
    goto LABEL_171;
  }
  if (((uint64_t)a1[3].handle & 1) == 0)
  {
    if (gLogDatapath)
    {
      v59 = __nwlog_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
        v86 = 2082;
        v87 = (char *)&a1[3].handle + 1;
        v88 = 2080;
        v89 = " ";
        v90 = 2048;
        p_output_handler = (char *)&a1[1].output_handler;
        _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Got a connected event from the lower layer", buf, 0x2Au);
      }
    }
  }
  default_input_handler = a1->default_input_handler;
  if (a1->output_handler != a2)
  {
    if (!default_input_handler)
      return;
    callbacks = default_input_handler->callbacks;
    if (!callbacks)
      return;
    if (!a2)
      return;
    connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
    if (!connected)
      return;
    handle = default_input_handler->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      v8 = default_input_handler[1].callbacks;
      if (v8)
        default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v8->add_input_handler + 1);
    }
    if (a2->handle != &nw_protocol_ref_counted_handle)
    {
      connected(default_input_handler, a2);
      goto LABEL_77;
    }
    v23 = a2[1].callbacks;
    if (v23)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v23->add_input_handler + 1);
    connected(default_input_handler, a2);
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      v24 = a2[1].callbacks;
      if (v24)
      {
        v25 = (nw_protocol_callbacks *)((char *)v24 - 1);
        a2[1].callbacks = v25;
        if (!v25)
        {
          v26 = *(void (***)(_QWORD))a2[1].flow_id;
          if (v26)
          {
            *(_QWORD *)a2[1].flow_id = 0;
            v26[2](v26);
            _Block_release(v26);
          }
          if ((a2[1].flow_id[8] & 1) != 0)
          {
            v27 = *(const void **)a2[1].flow_id;
            if (v27)
              _Block_release(v27);
          }
          v28 = a2;
LABEL_76:
          free(v28);
          goto LABEL_77;
        }
      }
    }
    goto LABEL_77;
  }
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v70 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (__nwlog_fault(v70, &type, &v83))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v71 = __nwlog_obj();
        v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol";
LABEL_188:
          _os_log_impl(&dword_182FBE000, v71, v72, v73, buf, 0xCu);
        }
      }
      else if (v83)
      {
        v77 = (char *)__nw_create_backtrace_string();
        v71 = __nwlog_obj();
        v72 = type;
        v78 = os_log_type_enabled(v71, type);
        if (v77)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
            v86 = 2082;
            v87 = v77;
            _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v77);
          goto LABEL_189;
        }
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_188;
        }
      }
      else
      {
        v71 = __nwlog_obj();
        v72 = type;
        if (os_log_type_enabled(v71, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_188;
        }
      }
    }
LABEL_189:
    if (v70)
      free(v70);
    v13 = 0;
    goto LABEL_23;
  }
  v9 = default_input_handler->handle;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    v10 = default_input_handler[1].callbacks;
    if (v10)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v10->add_input_handler + 1);
  }
  v11 = default_input_handler->callbacks;
  if (v11)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v11->get_parameters;
    if (get_parameters)
    {
      v13 = (void *)get_parameters(default_input_handler);
      if (v9 != &nw_protocol_ref_counted_handle)
        goto LABEL_23;
      goto LABEL_22;
    }
  }
  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
  if (!name)
    name = "invalid";
  v86 = 2082;
  v87 = (char *)name;
  v88 = 2048;
  v89 = (const char *)default_input_handler;
  v61 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v83 = 0;
  if (!__nwlog_fault(v61, &type, &v83))
    goto LABEL_180;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v62 = __nwlog_obj();
    v63 = type;
    if (!os_log_type_enabled(v62, type))
      goto LABEL_180;
    v64 = default_input_handler->identifier->name;
    if (!v64)
      v64 = "invalid";
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v64;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_179:
    _os_log_impl(&dword_182FBE000, v62, v63, v65, buf, 0x20u);
    goto LABEL_180;
  }
  if (!v83)
  {
    v62 = __nwlog_obj();
    v63 = type;
    if (!os_log_type_enabled(v62, type))
      goto LABEL_180;
    v79 = default_input_handler->identifier->name;
    if (!v79)
      v79 = "invalid";
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v79;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_179;
  }
  v82 = v9;
  v74 = (char *)__nw_create_backtrace_string();
  v62 = __nwlog_obj();
  v63 = type;
  v75 = os_log_type_enabled(v62, type);
  if (!v74)
  {
    v9 = v82;
    if (!v75)
      goto LABEL_180;
    v81 = default_input_handler->identifier->name;
    if (!v81)
      v81 = "invalid";
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v81;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_179;
  }
  if (v75)
  {
    v76 = default_input_handler->identifier->name;
    if (!v76)
      v76 = "invalid";
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v76;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v90 = 2082;
    p_output_handler = v74;
    _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v74);
  v9 = v82;
LABEL_180:
  if (v61)
    free(v61);
  v13 = 0;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
LABEL_22:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v43 = default_input_handler[1].callbacks;
      if (v43)
      {
        v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
        default_input_handler[1].callbacks = v44;
        if (!v44)
        {
          v45 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v45)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v45[2](v45);
            _Block_release(v45);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v46 = *(const void **)default_input_handler[1].flow_id;
            if (v46)
              _Block_release(v46);
          }
          free(default_input_handler);
        }
      }
    }
  }
LABEL_23:
  v14 = nw_parameters_copy_context(v13);
  v15 = nw_path_copy_flow_registration(v14, (uint64_t)a1);
  if (v15)
  {
    v16 = v15;
    stats_region = (nw_protocol_identifier *)nw_path_flow_registration_get_stats_region(v15, (uint64_t)a1->identifier->name);
    a1[2].identifier = stats_region;
    if (!stats_region)
    {
      if (((uint64_t)a1[3].handle & 1) == 0)
      {
        if (gLogDatapath)
        {
          v80 = __nwlog_obj();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_ipv4_connected";
            v86 = 2082;
            v87 = (char *)&a1[3].handle + 1;
            v88 = 2080;
            v89 = " ";
            v90 = 2048;
            p_output_handler = (char *)&a1[1].output_handler;
            v92 = 2048;
            v93 = &g_ip_stats;
            _os_log_impl(&dword_182FBE000, v80, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p ipv4->ip_stats is NULL setting to global %p", buf, 0x34u);
          }
        }
      }
      a1[2].identifier = (nw_protocol_identifier *)&g_ip_stats;
    }
    os_release(v16);
  }
  if (v14)
    os_release(v14);
  *(_QWORD *)buf = 0;
  output_handler = a1->output_handler;
  if (output_handler)
  {
    v19 = output_handler->callbacks;
    if (v19)
    {
      get_message_properties = (void (*)(nw_protocol *, nw_protocol *, _BYTE *))v19->get_message_properties;
      if (get_message_properties)
      {
        v21 = output_handler->handle;
        if (v21 == &nw_protocol_ref_counted_handle)
        {
          v22 = output_handler[1].callbacks;
          if (v22)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v22->add_input_handler + 1);
        }
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v29 = a1[1].callbacks;
          if (v29)
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v29->add_input_handler + 1);
          get_message_properties(output_handler, a1, buf);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v47 = a1[1].callbacks;
            if (v47)
            {
              v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
              a1[1].callbacks = v48;
              if (!v48)
              {
                v49 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v49)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v49[2](v49);
                  _Block_release(v49);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v50 = *(const void **)a1[1].flow_id;
                  if (v50)
                    _Block_release(v50);
                }
                free(a1);
              }
            }
          }
        }
        else
        {
          get_message_properties(output_handler, a1, buf);
        }
        if (v21 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v51 = output_handler[1].callbacks;
          if (v51)
          {
            v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
            output_handler[1].callbacks = v52;
            if (!v52)
            {
              v53 = *(void (***)(_QWORD))output_handler[1].flow_id;
              if (v53)
              {
                *(_QWORD *)output_handler[1].flow_id = 0;
                v53[2](v53);
                _Block_release(v53);
              }
              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                v54 = *(const void **)output_handler[1].flow_id;
                if (v54)
                  _Block_release(v54);
              }
              free(output_handler);
            }
          }
        }
        if ((*(_DWORD *)buf - 1) <= 0xFFFFFFFD)
          LODWORD(a1[3].callbacks) = *(_DWORD *)buf;
      }
    }
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
    return;
  v30 = default_input_handler->callbacks;
  if (!v30)
    return;
  v31 = (void (*)(nw_protocol *, nw_protocol *))v30->connected;
  if (!v31)
    return;
  handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    v32 = default_input_handler[1].callbacks;
    if (v32)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    v31(default_input_handler, a1);
    goto LABEL_77;
  }
  v33 = a1[1].callbacks;
  if (v33)
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v33->add_input_handler + 1);
  v31(default_input_handler, a1);
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v34 = a1[1].callbacks;
    if (v34)
    {
      v35 = (nw_protocol_callbacks *)((char *)v34 - 1);
      a1[1].callbacks = v35;
      if (!v35)
      {
        v36 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v36)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v36[2](v36);
          _Block_release(v36);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v37 = *(const void **)a1[1].flow_id;
          if (v37)
            _Block_release(v37);
        }
        v28 = a1;
        goto LABEL_76;
      }
    }
  }
LABEL_77:
  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    v38 = default_input_handler[1].callbacks;
    if (v38)
    {
      v39 = (nw_protocol_callbacks *)((char *)v38 - 1);
      default_input_handler[1].callbacks = v39;
      if (!v39)
      {
        v40 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
        if (v40)
        {
          *(_QWORD *)default_input_handler[1].flow_id = 0;
          v40[2](v40);
          _Block_release(v40);
        }
        if ((default_input_handler[1].flow_id[8] & 1) != 0)
        {
          v41 = *(const void **)default_input_handler[1].flow_id;
          if (v41)
            _Block_release(v41);
        }
        v42 = default_input_handler;
        goto LABEL_88;
      }
    }
  }
}

uint64_t nw_protocol_instance_get_stats_region(void *a1, uint64_t a2)
{
  NWConcrete_nw_protocol_instance *v3;
  NWConcrete_nw_protocol_instance *v4;
  uint64_t v5;
  id wakeup;
  uint64_t stats_region;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_instance_get_stats_region";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_protocol_instance_get_stats_region";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_protocol_instance_get_stats_region";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_protocol_instance_get_stats_region";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_protocol_instance_get_stats_region";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_24:
    if (v9)
      free(v9);
    goto LABEL_26;
  }
  if (a2)
  {
    v5 = nw_protocol_implementation_lookup_path(v3, a2, 0);
    if (!v5)
      goto LABEL_26;
    wakeup = *(id *)(v5 + 24);
    if (!wakeup)
      goto LABEL_26;
  }
  else
  {
    wakeup = v3->wakeup;
    if (!wakeup)
    {
LABEL_26:
      stats_region = 0;
      goto LABEL_27;
    }
  }
  stats_region = nw_path_flow_registration_get_stats_region(wakeup, *(_QWORD *)&v4[-1].log_str[9]);
LABEL_27:

  return stats_region;
}

uint64_t nw_path_flow_registration_get_stats_region(void *a1, uint64_t a2)
{
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_path_flow_registration_get_stats_region";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null flow_registration", buf, 0xCu);
      }
      goto LABEL_42;
    }
    if (!v20)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
      goto LABEL_42;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_path_flow_registration_get_stats_region";
      v24 = 2082;
      v25 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_30;
  }
  if (!a2)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_path_flow_registration_get_stats_region";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null protocol_identifier", buf, 0xCu);
      }
LABEL_42:

LABEL_43:
      if (v8)
        free(v8);
      goto LABEL_6;
    }
    if (!v20)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null protocol_identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_flow_registration_get_stats_region";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null protocol_identifier, no backtrace", buf, 0xCu);
      }
      goto LABEL_42;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_path_flow_registration_get_stats_region";
      v24 = 2082;
      v25 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_30:

    free(backtrace_string);
    goto LABEL_43;
  }
  if (v3[13] == a2)
  {
    v5 = v3[16];
    goto LABEL_10;
  }
  if (v3[12] == a2)
  {
    v5 = v3[15];
    goto LABEL_10;
  }
  if (v3[11] == a2)
  {
    v5 = v3[14];
    goto LABEL_10;
  }
LABEL_6:
  v5 = 0;
LABEL_10:

  return v5;
}

id nw_path_copy_flow_registration(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  uint64_t globals_for_path;
  uint64_t v6;
  uint64_t node;
  id v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    globals_for_path = nw_context_get_globals_for_path(v3);
    os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
    v6 = *(_QWORD *)(globals_for_path + 40);
    if (v6 && (node = nw_hash_table_get_node(v6, a2, 16)) != 0)
      v8 = *(id *)(node + 16);
    else
      v8 = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)(globals_for_path + 124));
    goto LABEL_7;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_path_copy_flow_registration";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_path_copy_flow_registration";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_path_copy_flow_registration";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_path_copy_flow_registration";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_path_copy_flow_registration";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v11)
    free(v11);
  v8 = 0;
LABEL_7:

  return v8;
}

void sub_1830226E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_channel_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  char *v18;
  _BOOL4 v19;
  NSObject *v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  _WORD v26[17];

  *(_QWORD *)&v26[13] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_get_message_properties";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v6, &type, &v21))
      goto LABEL_46;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_channel_get_message_properties";
      v9 = "%{public}s called with null protocol";
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_channel_get_message_properties";
          v25 = 2082;
          *(_QWORD *)v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_46:
        if (!v6)
          return;
        goto LABEL_47;
      }
      if (!v15)
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_channel_get_message_properties";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_channel_get_message_properties";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_45:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_46;
  }
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if (a2)
    {
      v5 = *(_QWORD *)(a2 + 56);
      if (v5)
      {
        if (a3)
        {
          *a3 = *(_DWORD *)(v3 + 436);
          a3[1] = a3[1] & 0xFFFFFFF8 | (*(unsigned __int8 *)(v5 + 153) >> 2) & 1;
        }
        return;
      }
      goto LABEL_53;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "__nw_protocol_get_output_handler_context";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v10, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_51;
        *(_DWORD *)buf = 136446210;
        v24 = "__nw_protocol_get_output_handler_context";
        v13 = "%{public}s called with null protocol";
        goto LABEL_50;
      }
      if (!v21)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_51;
        *(_DWORD *)buf = 136446210;
        v24 = "__nw_protocol_get_output_handler_context";
        v13 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_50;
      }
      v18 = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v19 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "__nw_protocol_get_output_handler_context";
          v25 = 2082;
          *(_QWORD *)v26 = v18;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v18);
        goto LABEL_51;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "__nw_protocol_get_output_handler_context";
        v13 = "%{public}s called with null protocol, no backtrace";
LABEL_50:
        _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
      }
    }
LABEL_51:
    if (v10)
      free(v10);
LABEL_53:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v24 = "nw_channel_get_message_properties";
      v25 = 1042;
      *(_DWORD *)v26 = 16;
      v26[2] = 2098;
      *(_QWORD *)&v26[3] = a2;
      _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s Can't find hash table entry for %{public,uuid_t}.16P", buf, 0x1Cu);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_channel_get_message_properties";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v6, &type, &v21))
    goto LABEL_46;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_46;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_get_message_properties";
    v9 = "%{public}s called with null channel";
    goto LABEL_45;
  }
  if (!v21)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_46;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_get_message_properties";
    v9 = "%{public}s called with null channel, backtrace limit exceeded";
    goto LABEL_45;
  }
  v16 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v17 = os_log_type_enabled(v7, type);
  if (!v16)
  {
    if (!v17)
      goto LABEL_46;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_channel_get_message_properties";
    v9 = "%{public}s called with null channel, no backtrace";
    goto LABEL_45;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_channel_get_message_properties";
    v25 = 2082;
    *(_QWORD *)v26 = v16;
    _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v6)
LABEL_47:
    free(v6);
}

void nw_socket_update_input_source(char *a1)
{
  unsigned __int16 *v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  NSObject *v14;
  int v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_socket_update_input_source";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_socket_update_input_source";
      v11 = "%{public}s called with null socket_handler";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      v13 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_socket_update_input_source";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_33;
      }
      if (!v13)
      {
LABEL_33:
        if (v8)
          free(v8);
        return;
      }
      *(_DWORD *)buf = 136446210;
      v19 = "nw_socket_update_input_source";
      v11 = "%{public}s called with null socket_handler, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_socket_update_input_source";
      v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_33;
  }
  v2 = (unsigned __int16 *)(a1 + 333);
  if ((*(_WORD *)(a1 + 333) & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v14 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v15 = *((_DWORD *)a1 + 49);
      *(_DWORD *)buf = 136446722;
      v19 = "nw_socket_update_input_source";
      v20 = 2082;
      v21 = a1 + 340;
      v22 = 1024;
      v23 = v15;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Input available for %d", buf, 0x1Cu);
    }
  }
  v3 = *v2;
  v4 = v3 | (*((unsigned __int8 *)v2 + 2) << 16);
  if ((v3 & 0x4000) != 0)
    return;
  *((_BYTE *)v2 + 2) = BYTE2(v4);
  *v2 = v4 | 0x200;
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
  if (_nw_signposts_enabled && kdebug_is_enabled())
  {
    kdebug_trace();
    v5 = *((_QWORD *)a1 + 6);
    if (!v5)
      goto LABEL_13;
  }
  else
  {
    v5 = *((_QWORD *)a1 + 6);
    if (!v5)
      goto LABEL_13;
  }
  v6 = *(_QWORD *)(v5 + 24);
  if (v6)
  {
    v7 = *(void (**)(void))(v6 + 64);
    if (v7)
      v7();
  }
LABEL_13:
  if ((*v2 & 0x600) == 0x200)
  {
    if (_nw_signposts_once == -1)
    {
      if (_nw_signposts_enabled)
        goto LABEL_16;
    }
    else
    {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
      if (_nw_signposts_enabled)
      {
LABEL_16:
        if (kdebug_is_enabled())
          kdebug_trace();
      }
    }
    nw_queue_suspend_source(*((_QWORD *)a1 + 18));
    *v2 |= 0x400u;
  }
}

uint64_t nw_channel_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, int a5, nw_frame_array_s *a6)
{
  _WORD *handle;
  unsigned int v11;
  _QWORD *output_handler_context;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  NSObject *v17;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  char *backtrace_string;
  _BOOL4 v24;
  const char *v25;
  _BOOL4 v26;
  _BOOL4 v27;
  _QWORD v28[2];
  uint64_t (*v29)(uint64_t, uint64_t);
  void *v30;
  _BYTE *v31;
  os_log_type_t *v32;
  char *v33;
  nw_frame_array_s *v34;
  int v35;
  int v36;
  os_log_type_t type[8];
  os_log_type_t *v38;
  uint64_t v39;
  int v40;
  char v41;
  _BYTE buf[28];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
    v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v19, type, &v41))
      goto LABEL_52;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null channel_protocol";
      goto LABEL_51;
    }
    if (!v41)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type[0];
    v24 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v24)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null channel_protocol, no backtrace";
      goto LABEL_51;
    }
    if (!v24)
      goto LABEL_38;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v25 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_37:
    _os_log_impl(&dword_182FBE000, v20, v21, v25, buf, 0x16u);
    goto LABEL_38;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
    v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v19, type, &v41))
      goto LABEL_52;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null channel";
      goto LABEL_51;
    }
    if (!v41)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type[0];
    v26 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v26)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null channel, no backtrace";
      goto LABEL_51;
    }
    if (!v26)
      goto LABEL_38;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v25 = "%{public}s called with null channel, dumping backtrace:%{public}s";
    goto LABEL_37;
  }
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
    v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v19, type, &v41))
      goto LABEL_52;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null input_protocol";
      goto LABEL_51;
    }
    if (!v41)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      v22 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type[0];
    v27 = os_log_type_enabled(v20, type[0]);
    if (backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }
LABEL_38:
      free(backtrace_string);
      goto LABEL_52;
    }
    if (!v27)
      goto LABEL_52;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
    v22 = "%{public}s called with null input_protocol, no backtrace";
LABEL_51:
    _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
LABEL_52:
    if (v19)
      free(v19);
    return 0;
  }
  v11 = ((unsigned __int16)handle[222] | (*((unsigned __int8 *)handle + 446) << 16)) & 0xFFF9FFFF | 0x20000;
  handle[222] = handle[222];
  *((_BYTE *)handle + 446) = BYTE2(v11);
  nw_channel_update_input_source((uint64_t)handle, (uint64_t)a2, 0);
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_channel_get_input_frames";
      *(_WORD *)&buf[12] = 1042;
      *(_DWORD *)&buf[14] = 16;
      *(_WORD *)&buf[18] = 2098;
      *(_QWORD *)&buf[20] = a2;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_ERROR, "%{public}s Can't find hash table entry for %{public,uuid_t}.16P", buf, 0x1Cu);
    }
    return 0;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_DWORD *)&buf[24] = 0;
  *(_QWORD *)&buf[16] = 0x2000000000;
  *(_QWORD *)type = 0;
  v38 = type;
  v40 = 0;
  v39 = 0x2000000000;
  v28[0] = MEMORY[0x1E0C809B0];
  v28[1] = 0x40000000;
  v29 = ___ZL27nw_channel_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
  v30 = &unk_1E14ACD48;
  v31 = buf;
  v32 = type;
  v35 = a5;
  v36 = a4;
  v33 = (char *)(output_handler_context + 4);
  v34 = a6;
  v13 = output_handler_context[4];
  do
  {
    if (!v13)
      break;
    v14 = *(_QWORD *)(v13 + 32);
    v15 = ((uint64_t (*)(_QWORD *))v29)(v28);
    v13 = v14;
  }
  while ((v15 & 1) != 0);
  v16 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v16;
}

void nw_channel_update_input_source(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  _WORD *v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  char v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  char v22;
  _QWORD v23[2];
  uint64_t (*v24)(uint64_t, uint64_t);
  void *v25;
  uint64_t v26;

  if ((*(_WORD *)(a1 + 444) & 1) == 0 && *(_QWORD *)(a1 + 168) && *(_QWORD *)(a1 + 224))
  {
    if (!uuid_is_null((const unsigned __int8 *)(a1 + 352))
      && (unint64_t)*(unsigned int *)(a1 + 416) >= *(_QWORD *)(a1 + 112) >> 1)
    {
      v23[0] = MEMORY[0x1E0C809B0];
      v23[1] = 0x40000000;
      v24 = ___ZL30nw_channel_update_input_sourceP10nw_channelP11nw_protocolb_block_invoke;
      v25 = &__block_descriptor_tmp_60_86545;
      v26 = a1;
      v6 = *(_QWORD *)(a1 + 336);
      do
      {
        if (!v6)
          break;
        v7 = *(_QWORD *)(v6 + 32);
        v8 = ((uint64_t (*)(_QWORD *))v24)(v23);
        v6 = v7;
      }
      while ((v8 & 1) != 0);
    }
    if (*(_QWORD *)(a1 + 224))
    {
      v9 = (_WORD *)(a1 + 444);
      *(_WORD *)(a1 + 444) |= 1u;
      v10 = os_channel_available_slot_count();
      if (v10)
        v12 = 1;
      else
        v12 = a3 == 0;
      if (v12)
      {
        v13 = v10;
        if (*(_DWORD *)(a1 + 416) - 1 >= v10)
          v14 = 0;
        else
          v14 = *(_DWORD *)(a1 + 416);
        if (v10)
        {
          v15 = (unsigned __int16)*v9;
          v16 = v15 | (*(unsigned __int8 *)(a1 + 446) << 16);
          if ((v15 & 8) == 0)
          {
            *(_BYTE *)(a1 + 446) = BYTE2(v16);
            *v9 = v16 | 8;
            nw_queue_suspend_source(*(_QWORD *)(a1 + 168));
          }
        }
        if (v13 != v14)
        {
          do
          {
            v17 = nw_channel_add_input_frames(a1, a2);
            if (!*(_QWORD *)(a1 + 224))
              break;
            v18 = os_channel_available_slot_count();
            v13 = v18;
            if ((v17 & 1) == 0)
              break;
            v19 = *(_DWORD *)(a1 + 416);
            if (v19 - 1 >= v18)
              v19 = 0;
          }
          while (v18 != v19);
        }
        if (v13)
          goto LABEL_30;
      }
      else
      {
        v22 = nw_channel_check_defunct(a1);
        if ((v22 & 1) != 0)
          goto LABEL_30;
      }
      v20 = (unsigned __int16)*v9;
      if ((v20 & 8) != 0)
      {
        v21 = v20 & 0xFFFFFFF7 | (*(unsigned __int8 *)(a1 + 446) << 16);
        *v9 = v20 & 0xFFF7;
        *(_BYTE *)(a1 + 446) = BYTE2(v21);
        nw_queue_resume_source(*(_QWORD *)(a1 + 168), v11);
      }
LABEL_30:
      *v9 &= ~1u;
    }
  }
}

uint64_t ___ZL27nw_channel_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v10;
  _QWORD *v11;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v3 = *(_DWORD *)(v2 + 24);
  if (v3 >= *(_DWORD *)(a1 + 64) || *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) >= *(_DWORD *)(a1 + 68))
    return 0;
  *(_DWORD *)(v2 + 24) = v3 + 1;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += nw_frame_unclaimed_length((_DWORD *)a2);
  v7 = *(_QWORD *)(a2 + 32);
  v8 = *(_QWORD **)(a2 + 40);
  v6 = (_QWORD *)(a2 + 32);
  if (v7)
  {
    *(_QWORD *)(v7 + 40) = v8;
    v8 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) = v8;
  }
  *v8 = v7;
  *v6 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v10 = *(_QWORD *)(a1 + 56);
  v11 = *(_QWORD **)(v10 + 8);
  *(_QWORD *)(a2 + 40) = v11;
  *v11 = a2;
  *(_QWORD *)(v10 + 8) = v6;
  return 1;
}

uint64_t nw_frame_unclaimed_length(_DWORD *a1)
{
  int v1;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v12 = "__nw_frame_unclaimed_length";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v9 = 0;
    if (!__nwlog_fault(v3, &type, &v9))
      goto LABEL_18;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "__nw_frame_unclaimed_length";
      v6 = "%{public}s called with null frame";
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v12 = "__nw_frame_unclaimed_length";
          v13 = 2082;
          v14 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (!v8)
      {
LABEL_18:
        if (v3)
          free(v3);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v12 = "__nw_frame_unclaimed_length";
      v6 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "__nw_frame_unclaimed_length";
      v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_18;
  }
  v1 = a1[13];
  if (v1)
    return (v1 - (a1[14] + a1[15]));
  return 0;
}

void nw_protocol_default_input_available(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*input_available)(void);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_available";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_default_input_available";
      v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_default_input_available";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v5)
          return;
        goto LABEL_35;
      }
      if (!v10)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_default_input_available";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_default_input_available";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_34;
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      input_available = (void (*)(void))callbacks->input_available;
      if (input_available)
        input_available();
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_default_input_available";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_available";
    v8 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_33;
  }
  if (!v13)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_available";
    v8 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
    goto LABEL_33;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_available";
    v8 = "%{public}s called with null protocol->default_input_handler, no backtrace";
    goto LABEL_33;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_protocol_default_input_available";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5)
LABEL_35:
    free(v5);
}

void nw_queue_suspend_source(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  NSObject *v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_queue_suspend_source";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v5, &type, &v12))
      goto LABEL_31;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_queue_suspend_source";
        v8 = "%{public}s called with null source";
LABEL_29:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            v15 = "nw_queue_suspend_source";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_31;
        }
        if (!v10)
          goto LABEL_30;
        *(_DWORD *)buf = 136446210;
        v15 = "nw_queue_suspend_source";
        v8 = "%{public}s called with null source, no backtrace";
        goto LABEL_29;
      }
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_queue_suspend_source";
        v8 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_29;
      }
    }
LABEL_30:

LABEL_31:
    if (v5)
      free(v5);
    return;
  }
  v2 = *(NSObject **)a1;
  if (v2)
  {
    dispatch_suspend(v2);
    return;
  }
  v3 = *(void **)(a1 + 16);
  if (*(_BYTE *)(a1 + 48))
  {
    if (v3)
    {
      if (*(_BYTE *)(a1 + 49))
      {
        nw_context_reset_timer_block_with_time(*(void **)(a1 + 8), a1, -1, v3);
        *(_BYTE *)(a1 + 49) = 0;
      }
      return;
    }
    goto LABEL_11;
  }
  if (!v3)
  {
LABEL_11:
    if (gLogDatapath)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_queue_suspend_source";
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not suspending source", buf, 0xCu);
      }

    }
    return;
  }
  if (*(_BYTE *)(a1 + 49))
  {
    nw_context_dequeue_source_block(*(void **)(a1 + 8), *(void **)(a1 + 16));
    *(_BYTE *)(a1 + 49) = 0;
  }
}

void nw_protocol_default_input_flush(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*input_flush)(void);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_flush = (void (*)(void))callbacks->input_flush;
        if (input_flush)
          input_flush();
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_default_input_flush";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_input_flush";
      v8 = "%{public}s called with null protocol";
      goto LABEL_19;
    }
    if (!v11)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_input_flush";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_19;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v10 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v14 = "nw_protocol_default_input_flush";
        v15 = 2082;
        v16 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_20;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_input_flush";
      v8 = "%{public}s called with null protocol, no backtrace";
LABEL_19:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    }
  }
LABEL_20:
  if (v5)
    free(v5);
}

void nw_flow_passthrough_input_available(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*input_available)(void);
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_available = (void (*)(void))callbacks->input_available;
        if (input_available)
          input_available();
      }
    }
    return;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_flow_passthrough_input_available";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_flow_passthrough_input_available";
        v9 = "%{public}s called with null protocol";
LABEL_19:
        _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v15 = "nw_flow_passthrough_input_available";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (!v11)
          goto LABEL_20;
        *(_DWORD *)buf = 136446210;
        v15 = "nw_flow_passthrough_input_available";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_19;
      }
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_flow_passthrough_input_available";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
LABEL_20:

  }
LABEL_21:
  if (v6)
    free(v6);
}

void nw_protocol_http2_transport_input_available(nw_protocol *a1, nw_protocol *a2)
{
  _BYTE *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  NSObject *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char *v10;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_transport_input_available";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v3, &type, &v12))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_http2_transport_input_available";
      v6 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v9 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_http2_transport_input_available";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v3)
          return;
LABEL_38:
        free(v3);
        return;
      }
      if (!v9)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_http2_transport_input_available";
      v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_http2_transport_input_available";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_37;
  }
  handle = a1->handle;
  if (handle)
  {
    if (gLogDatapath)
    {
      v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v15 = "nw_protocol_http2_transport_input_available";
        v16 = 2082;
        v17 = handle + 205;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }
    if ((handle[204] & 0x40) == 0)
      nw_protocol_http2_transport_process_input((uint64_t)handle);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_http2_transport_input_available";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
    goto LABEL_37;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_transport_input_available";
    v6 = "%{public}s called with null http2_transport";
    goto LABEL_36;
  }
  if (!v12)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_transport_input_available";
    v6 = "%{public}s called with null http2_transport, backtrace limit exceeded";
    goto LABEL_36;
  }
  v10 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v11 = os_log_type_enabled(v4, type);
  if (!v10)
  {
    if (!v11)
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_http2_transport_input_available";
    v6 = "%{public}s called with null http2_transport, no backtrace";
    goto LABEL_36;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    v15 = "nw_protocol_http2_transport_input_available";
    v16 = 2082;
    v17 = v10;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v3)
    goto LABEL_38;
}

uint64_t nw_parameters_get_uid(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(unsigned int *)(*((_QWORD *)v1 + 13) + 68);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_uid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_uid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_uid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_uid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_uid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_get_reuse_local_address(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  BOOL v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = BYTE1(v1[12].isa) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_reuse_local_address";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_reuse_local_address";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_reuse_local_address";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_reuse_local_address";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_reuse_local_address";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_dry_run(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 96) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_dry_run";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_dry_run";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_dry_run";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_dry_run";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_dry_run";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

ValueMetadata *type metadata accessor for NWInterface.InterfaceType()
{
  return &type metadata for NWInterface.InterfaceType;
}

void nw_protocol_data_access_buffer(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void (**v5)(_QWORD, _QWORD, _QWORD);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = (void (**)(_QWORD, _QWORD, _QWORD))v4;
  if (!v3)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_data_access_buffer";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null data", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_protocol_data_access_buffer";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_47:
        if (!v10)
          goto LABEL_34;
LABEL_48:
        free(v10);
        goto LABEL_34;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_46:

    goto LABEL_47;
  }
  if (v4)
  {
    v6 = v3[14];
    if (v6)
    {
      if ((*((_WORD *)v3 + 102) & 0x100) == 0
        || !g_channel_check_validity
        || g_channel_check_validity(v3, v3[11]))
      {
        LODWORD(v6) = *((_DWORD *)v3 + 13);
        v7 = *((unsigned int *)v3 + 14);
        if ((_DWORD)v6)
          LODWORD(v6) = v6 - (v7 + *((_DWORD *)v3 + 15));
        v8 = v3[14] + v7;
        goto LABEL_33;
      }
      LODWORD(v6) = 0;
    }
    v8 = 0;
LABEL_33:
    v5[2](v5, v8, v6);
    goto LABEL_34;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_protocol_data_access_buffer";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23))
    goto LABEL_47;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_protocol_data_access_buffer";
      _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null access_block", buf, 0xCu);
    }
    goto LABEL_46;
  }
  if (!v23)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_protocol_data_access_buffer";
      _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_46;
  }
  v18 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  v19 = type;
  v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_protocol_data_access_buffer";
      _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_46;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_protocol_data_access_buffer";
    v27 = 2082;
    v28 = v18;
    _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10)
    goto LABEL_48;
LABEL_34:

}

void sub_183025B68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t dispatch thunk of NWActivity.__allocating_init(domain:label:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 104))();
}

uint64_t nw_protocol_data_get_ecn_flag(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 186) & 3;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_data_get_ecn_flag";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null data", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_data_get_ecn_flag";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_tcp_options_set_retransmit_connection_drop_time(nw_protocol_options_t options, uint32_t retransmit_connection_drop_time)
{
  NSObject *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  uint32_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_retransmit_connection_drop_time_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = retransmit_connection_drop_time;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_retransmit_connection_drop_time";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1830260EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_tcp_options_set_connection_timeout(nw_protocol_options_t options, uint32_t connection_timeout)
{
  NSObject *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  uint32_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_connection_timeout_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = connection_timeout;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_tcp_options_set_connection_timeout";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_connection_timeout";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_tcp_options_set_connection_timeout";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_connection_timeout";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_connection_timeout";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1830263C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_tcp_options_set_enable_keepalive(nw_protocol_options_t options, BOOL enable_keepalive)
{
  NSObject *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  BOOL v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_enable_keepalive_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = enable_keepalive;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_tcp_options_set_enable_keepalive";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_enable_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_tcp_options_set_enable_keepalive";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_enable_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_enable_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1830266A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_tcp_options_set_keepalive_interval(nw_protocol_options_t options, uint32_t keepalive_interval)
{
  NSObject *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  uint32_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_keepalive_interval_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = keepalive_interval;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_tcp_options_set_keepalive_interval";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_tcp_options_set_keepalive_interval";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_183026980(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_tcp_options_set_keepalive_idle_time(nw_protocol_options_t options, uint32_t keepalive_idle_time)
{
  NSObject *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  uint32_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = options;
  if (nw_protocol_options_is_tcp(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_set_keepalive_idle_time_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = keepalive_idle_time;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_tcp_options_set_keepalive_idle_time";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_keepalive_idle_time";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_tcp_options_set_keepalive_idle_time";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_keepalive_idle_time";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_tcp_options_set_keepalive_idle_time";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_183026C5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_disable_blackhole_detection(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_disable_blackhole_detection_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_blackhole_detection";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183026F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_tfo(void *a1)
{
  NWConcrete_nw_parameters *v1;
  NWConcrete_nw_parameters *v2;
  OS_nw_protocol_options *v3;
  OS_nw_protocol_options *v4;
  _BOOL8 enable_fast_open;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_parameters_copy_tcp_options(v1, 0);
    v4 = v3;
    if (v3)
      enable_fast_open = nw_tcp_options_get_enable_fast_open(v3);
    else
      enable_fast_open = 0;

    goto LABEL_6;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_parameters_get_tfo";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_tfo";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_parameters_get_tfo";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_tfo";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_tfo";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v8)
    free(v8);
  enable_fast_open = 0;
LABEL_6:

  return enable_fast_open;
}

void sub_183027284(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_socket_add_input_handler(nw_protocol *a1, nw_protocol_identifier *a2)
{
  nw_protocol_callbacks *v4;
  uint64_t (*supports_external_data)(nw_protocol_identifier *);
  int v6;
  nw_protocol_callbacks *v7;
  __int16 v8;
  int v9;
  uint64_t (*get_parameters)(nw_protocol_identifier *);
  void *v11;
  nw_protocol_callbacks *v12;
  uint64_t *v13;
  id v14;
  id *v15;
  NSObject *v16;
  nw_protocol_options_t v17;
  char *v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  _BOOL8 result;
  const char *v24;
  NSObject *v25;
  int v26;
  int ip_protocol;
  int v28;
  int v29;
  id *v30;
  _WORD *v31;
  int v32;
  int v33;
  nw_protocol_callbacks *v34;
  uint64_t (*get_path)(nw_protocol_identifier *);
  void *v36;
  nw_protocol_callbacks *v37;
  NSObject *v38;
  unsigned int maximum_datagram_size;
  NSObject *v40;
  nw_protocol_callbacks *callbacks;
  uint64_t v42;
  nw_protocol_callbacks *v43;
  nw_protocol_callbacks *v44;
  void (**v45)(_QWORD);
  const void *v46;
  nw_protocol_callbacks *v47;
  nw_protocol_callbacks *v48;
  void (**v49)(_QWORD);
  const void *v50;
  nw_protocol_callbacks *v51;
  nw_protocol_callbacks *v52;
  void (**v53)(_QWORD);
  const void *v54;
  char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  char *backtrace_string;
  _BOOL4 v60;
  const char *v61;
  _BOOL4 v62;
  _BOOL4 v63;
  char v64;
  os_log_type_t type[3];
  uint8_t buf[4];
  const char *v67;
  __int16 v68;
  char *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v67 = "nw_socket_add_input_handler";
    v55 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v64 = 0;
    if (!__nwlog_fault(v55, type, &v64))
      goto LABEL_153;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type[0];
      if (!os_log_type_enabled(v56, type[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null protocol";
      goto LABEL_152;
    }
    if (!v64)
    {
      v56 = __nwlog_obj();
      v57 = type[0];
      if (!os_log_type_enabled(v56, type[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_152;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type[0];
    v60 = os_log_type_enabled(v56, type[0]);
    if (!backtrace_string)
    {
      if (!v60)
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_152;
    }
    if (!v60)
      goto LABEL_139;
    *(_DWORD *)buf = 136446466;
    v67 = "nw_socket_add_input_handler";
    v68 = 2082;
    v69 = backtrace_string;
    v61 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_138:
    _os_log_impl(&dword_182FBE000, v56, v57, v61, buf, 0x16u);
    goto LABEL_139;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v67 = "nw_socket_add_input_handler";
    v55 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v64 = 0;
    if (!__nwlog_fault(v55, type, &v64))
      goto LABEL_153;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type[0];
      if (!os_log_type_enabled(v56, type[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null socket_handler";
      goto LABEL_152;
    }
    if (!v64)
    {
      v56 = __nwlog_obj();
      v57 = type[0];
      if (!os_log_type_enabled(v56, type[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_152;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type[0];
    v62 = os_log_type_enabled(v56, type[0]);
    if (!backtrace_string)
    {
      if (!v62)
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_152;
    }
    if (!v62)
      goto LABEL_139;
    *(_DWORD *)buf = 136446466;
    v67 = "nw_socket_add_input_handler";
    v68 = 2082;
    v69 = backtrace_string;
    v61 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
    goto LABEL_138;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v67 = "nw_socket_add_input_handler";
    v55 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v64 = 0;
    if (!__nwlog_fault(v55, type, &v64))
      goto LABEL_153;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type[0];
      if (!os_log_type_enabled(v56, type[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null input_protocol";
      goto LABEL_152;
    }
    if (!v64)
    {
      v56 = __nwlog_obj();
      v57 = type[0];
      if (!os_log_type_enabled(v56, type[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v67 = "nw_socket_add_input_handler";
      v58 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_152;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type[0];
    v63 = os_log_type_enabled(v56, type[0]);
    if (backtrace_string)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446466;
        v67 = "nw_socket_add_input_handler";
        v68 = 2082;
        v69 = backtrace_string;
        v61 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_138;
      }
LABEL_139:
      free(backtrace_string);
      goto LABEL_153;
    }
    if (!v63)
      goto LABEL_153;
    *(_DWORD *)buf = 136446210;
    v67 = "nw_socket_add_input_handler";
    v58 = "%{public}s called with null input_protocol, no backtrace";
LABEL_152:
    _os_log_impl(&dword_182FBE000, v56, v57, v58, buf, 0xCu);
LABEL_153:
    if (v55)
      free(v55);
    return 0;
  }
  v4 = *(nw_protocol_callbacks **)&a2->name[24];
  if (v4)
  {
    supports_external_data = (uint64_t (*)(nw_protocol_identifier *))v4->supports_external_data;
    if (!supports_external_data)
      goto LABEL_157;
    if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
    {
      v7 = *(nw_protocol_callbacks **)&a2[2].name[8];
      if (v7)
        *(_QWORD *)&a2[2].name[8] = (char *)&v7->add_input_handler + 1;
      v6 = supports_external_data(a2);
      if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
      {
        v43 = *(nw_protocol_callbacks **)&a2[2].name[8];
        if (v43)
        {
          v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
          *(_QWORD *)&a2[2].name[8] = v44;
          if (!v44)
          {
            v45 = *(void (***)(_QWORD))&a2[1].name[24];
            if (v45)
            {
              *(_QWORD *)&a2[1].name[24] = 0;
              v45[2](v45);
              _Block_release(v45);
            }
            if ((a2[1].level & 1) != 0)
            {
              v46 = *(const void **)&a2[1].name[24];
              if (v46)
                _Block_release(v46);
            }
            free(a2);
          }
        }
      }
    }
    else
    {
      v6 = supports_external_data(a2);
    }
    v8 = v6 ? 4096 : 0;
    v9 = *(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0xEFFF | (HIBYTE(a1[6].handle) << 16);
    *(_WORD *)((char *)&a1[6].handle + 5) = *(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0xEFFF | v8;
    HIBYTE(a1[6].handle) = BYTE2(v9);
    v4 = *(nw_protocol_callbacks **)&a2->name[24];
    if (v4)
    {
LABEL_157:
      get_parameters = (uint64_t (*)(nw_protocol_identifier *))v4->get_parameters;
      if (get_parameters)
      {
        if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
        {
          v12 = *(nw_protocol_callbacks **)&a2[2].name[8];
          if (v12)
            *(_QWORD *)&a2[2].name[8] = (char *)&v12->add_input_handler + 1;
          v11 = (void *)get_parameters(a2);
          if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
          {
            v47 = *(nw_protocol_callbacks **)&a2[2].name[8];
            if (v47)
            {
              v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
              *(_QWORD *)&a2[2].name[8] = v48;
              if (!v48)
              {
                v49 = *(void (***)(_QWORD))&a2[1].name[24];
                if (v49)
                {
                  *(_QWORD *)&a2[1].name[24] = 0;
                  v49[2](v49);
                  _Block_release(v49);
                }
                if ((a2[1].level & 1) != 0)
                {
                  v50 = *(const void **)&a2[1].name[24];
                  if (v50)
                    _Block_release(v50);
                }
                free(a2);
              }
            }
          }
        }
        else
        {
          v11 = (void *)get_parameters(a2);
        }
        if (v11)
        {
          v13 = v11;
          v14 = *(id *)(v13[13] + 136);

          *(_QWORD *)a1[4].flow_id = v14;
          v15 = v13;
          v16 = v15[19];

          v17 = nw_protocol_stack_copy_transport_protocol(v16);
          v18 = (char *)&a1[6].default_input_handler + 4;
          nw_protocol_options_get_log_id_str(v17, (_BYTE *)&a1[6].default_input_handler + 4, 84);
          LODWORD(a1[6].handle) = nw_protocol_options_get_log_id_num(v17);
          if (nw_protocol_options_is_udp(v17))
          {
            if (nw_udp_options_get_no_metadata(v17))
              v19 = 0x100000;
            else
              v19 = 0;
            v20 = (*(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16)) & 0xFFEFFFFF;
            *(_WORD *)((char *)&a1[6].handle + 5) = *(_WORD *)((char *)&a1[6].handle + 5);
            v21 = (v20 | v19) >> 16;
          }
          else if (nw_protocol_options_is_quic(v17))
          {
            v21 = (*(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16) | 0x100000u) >> 16;
          }
          else
          {
            if (!nw_protocol_options_is_tcp(v17))
              goto LABEL_40;
            if (nw_tcp_options_get_reset_local_port(v17))
              v26 = -8388608;
            else
              v26 = 0;
            v21 = (v26 & 0xFF80FFFF | ((HIBYTE(a1[6].handle) & 0x7F) << 16)) >> 16;
          }
          HIBYTE(a1[6].handle) = v21;
LABEL_40:
          if (v17)
            os_release(v17);
          if (v16)
            os_release(v16);
          ip_protocol = nw_parameters_get_ip_protocol(v15);
          v28 = ip_protocol;
          if (ip_protocol == 17)
          {
            v29 = 1;
          }
          else if (ip_protocol == 6)
          {
            v29 = 2;
          }
          else
          {
            v30 = v15;
            v29 = *((unsigned __int8 *)v30 + 92);

          }
          LODWORD(a1[4].handle) = v29;
          v31 = (_WORD *)((char *)&a1[6].handle + 5);
          if (nw_path_parameters_get_logging_disabled(v13[13]))
            v32 = 128;
          else
            v32 = 0;
          v33 = *(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0xFF7F | (HIBYTE(a1[6].handle) << 16);
          *v31 = *(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0xFF7F | v32;
          HIBYTE(a1[6].handle) = BYTE2(v33);
          LODWORD(a1[4].callbacks) = 9216;
          v34 = *(nw_protocol_callbacks **)&a2->name[24];
          if (v34)
          {
            get_path = (uint64_t (*)(nw_protocol_identifier *))v34->get_path;
            if (get_path)
            {
              if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
              {
                v37 = *(nw_protocol_callbacks **)&a2[2].name[8];
                if (v37)
                  *(_QWORD *)&a2[2].name[8] = (char *)&v37->add_input_handler + 1;
                v36 = (void *)get_path(a2);
                if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
                {
                  v51 = *(nw_protocol_callbacks **)&a2[2].name[8];
                  if (v51)
                  {
                    v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
                    *(_QWORD *)&a2[2].name[8] = v52;
                    if (!v52)
                    {
                      v53 = *(void (***)(_QWORD))&a2[1].name[24];
                      if (v53)
                      {
                        *(_QWORD *)&a2[1].name[24] = 0;
                        v53[2](v53);
                        _Block_release(v53);
                      }
                      if ((a2[1].level & 1) != 0)
                      {
                        v54 = *(const void **)&a2[1].name[24];
                        if (v54)
                          _Block_release(v54);
                      }
                      free(a2);
                    }
                  }
                }
              }
              else
              {
                v36 = (void *)get_path(a2);
              }
              if (v36)
              {
                if (nw_path_is_multilayer_packet_logging_enabled(v36))
                {
                  if ((*v31 & 0x80) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v38 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136446466;
                      v67 = "nw_socket_add_input_handler";
                      v68 = 2082;
                      v69 = (char *)&a1[6].default_input_handler + 4;
                      _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Multilayer packet logging enabled", buf, 0x16u);
                    }
                  }
                  *v31 |= 0x100u;
                }
                if (v28 == 17)
                {
                  maximum_datagram_size = nw_path_get_maximum_datagram_size(v36);
                  if (maximum_datagram_size >> 10 <= 8)
                    LODWORD(a1[4].callbacks) = maximum_datagram_size;
                }
                goto LABEL_76;
              }
              v32 = *v31 & 0x80;
            }
          }
          if (!v32)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v40 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v67 = "nw_socket_add_input_handler";
              v68 = 2082;
              v69 = (char *)&a1[6].default_input_handler + 4;
              _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Failed to copy path, will not use multilayer packet logging", buf, 0x16u);
            }
          }
LABEL_76:
          nw_protocol_set_flow_id_from_protocol(a1, a2);
          a1[2].identifier = a2;
          if (nw_socket_initialize_socket(a1))
          {
            a1[4].identifier = (nw_protocol_identifier *)0x100000001;
            if (!*(_QWORD *)&a2->level)
            {
              *(_QWORD *)&a2->level = a1;
              if (a1->handle == &nw_protocol_ref_counted_handle)
              {
                callbacks = a1[1].callbacks;
                if (callbacks)
                  a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
              }
            }
            return 1;
          }
          if ((*v31 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v42 = gconnectionLogObj;
            result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
            if (result)
            {
              *(_DWORD *)buf = 136446466;
              v67 = "nw_socket_add_input_handler";
              v68 = 2082;
              v69 = v18;
              v24 = "%{public}s %{public}s Failed to initialize socket";
              v25 = v42;
              goto LABEL_87;
            }
            return result;
          }
          return 0;
        }
      }
    }
  }
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) != 0)
    return 0;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v22 = gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136446466;
    v67 = "nw_socket_add_input_handler";
    v68 = 2082;
    v69 = (char *)&a1[6].default_input_handler + 4;
    v24 = "%{public}s %{public}s Parameters are NULL when adding input_handler";
    v25 = v22;
LABEL_87:
    _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, v24, buf, 0x16u);
    return 0;
  }
  return result;
}

BOOL nw_protocol_options_is_udp(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1)
      dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45078);
    v2 = nw_protocol_options_matches_definition(v1, (void *)g_udp_definition);
    goto LABEL_5;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_options_is_udp";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_udp";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_options_is_udp";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_udp";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_udp";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_5:

  return v2;
}

void sub_183028154(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

size_t nw_protocol_options_get_log_id_str(void *a1, _BYTE *a2, uint64_t a3)
{
  const char *v5;
  unsigned __int8 *v6;
  const char *v7;
  unsigned __int8 *v8;
  int v9;
  size_t v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  os_log_type_t v28;
  os_log_type_t v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = (unsigned __int8 *)v5;
  if (!v5)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_options_get_log_id_str";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v13, &type, &v30))
      goto LABEL_59;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null options", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (!v30)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_182FBE000, v14, v27, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_protocol_options_get_log_id_str";
      v34 = 2082;
      v35 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_40:

    free(backtrace_string);
    goto LABEL_59;
  }
  if (!a2)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_options_get_log_id_str";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v13, &type, &v30))
      goto LABEL_59;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null log_id_str", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (!v30)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_182FBE000, v14, v28, "%{public}s called with null log_id_str, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_182FBE000, v14, v23, "%{public}s called with null log_id_str, no backtrace", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_protocol_options_get_log_id_str";
      v34 = 2082;
      v35 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v23, "%{public}s called with null log_id_str, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_40;
  }
  if (!a3)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_options_get_log_id_str";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v13, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_protocol_options_get_log_id_str";
          _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null log_id_str_len", buf, 0xCu);
        }
LABEL_58:

        goto LABEL_59;
      }
      if (!v30)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_protocol_options_get_log_id_str";
          _os_log_impl(&dword_182FBE000, v14, v29, "%{public}s called with null log_id_str_len, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_58;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_protocol_options_get_log_id_str";
          _os_log_impl(&dword_182FBE000, v14, v25, "%{public}s called with null log_id_str_len, no backtrace", buf, 0xCu);
        }
        goto LABEL_58;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v33 = "nw_protocol_options_get_log_id_str";
        v34 = 2082;
        v35 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v14, v25, "%{public}s called with null log_id_str_len, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_40;
    }
LABEL_59:
    if (v13)
      free(v13);
    v10 = 0;
    goto LABEL_10;
  }
  *a2 = 0;
  v7 = v5 + 48;
  if (a3 == 1)
  {
LABEL_8:
    *a2 = 0;
  }
  else
  {
    v8 = v6 + 48;
    while (1)
    {
      v9 = *v8;
      *a2 = v9;
      if (!v9)
        break;
      ++a2;
      ++v8;
      if ((unint64_t)--a3 <= 1)
        goto LABEL_8;
    }
  }
  v10 = strlen(v7);
LABEL_10:

  return v10;
}

uint64_t nw_protocol_options_get_log_id_num(void *a1)
{
  unsigned __int16 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[68];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_options_get_log_id_num";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_get_log_id_num";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_options_get_log_id_num";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_get_log_id_num";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_get_log_id_num";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_protocol_transform_contains_protocol(void *a1, void *a2)
{
  nw_protocol_stack_t *v3;
  id v4;
  void *v5;
  id v6;
  _BOOL4 is_equal_unsafe;
  id v8;
  NSObject *v9;
  id v10;
  int v11;
  nw_protocol_options_t v12;
  nw_protocol_options_t v13;
  nw_protocol_options_t v14;
  BOOL is_quic_stream;
  BOOL v16;
  uint64_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  void *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  os_log_type_t v31;
  _QWORD iterate_block[4];
  id v34;
  _BYTE *v35;
  BOOL v36;
  char v37;
  os_log_type_t type;
  _BYTE buf[24];
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v19, &type, &v37))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_67:
        if (!v19)
          goto LABEL_69;
LABEL_68:
        free(v19);
        goto LABEL_69;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_66:

    goto LABEL_67;
  }
  if (!v4)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v19, &type, &v37))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v37)
    {
      v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      v29 = os_log_type_enabled(v20, type);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v27;
          _os_log_impl(&dword_182FBE000, v20, v28, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v27);
        if (!v19)
          goto LABEL_69;
        goto LABEL_68;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_182FBE000, v20, v28, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_182FBE000, v20, v31, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_66;
  }
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  v6 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  if (nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v6))
  {
    is_equal_unsafe = 1;
  }
  else
  {
    if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
    v8 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v8);

  }
  v9 = v3[7];
  if (!v9)
    goto LABEL_69;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2020000000;
  v40 = 0;
  iterate_block[0] = MEMORY[0x1E0C809B0];
  iterate_block[1] = 3221225472;
  iterate_block[2] = __nw_protocol_transform_contains_protocol_block_invoke;
  iterate_block[3] = &unk_1E14A79A0;
  v36 = is_equal_unsafe;
  v35 = buf;
  v10 = v5;
  v34 = v10;
  nw_protocol_stack_iterate_application_protocols(v9, iterate_block);
  if (*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
  {
    v11 = 1;
    goto LABEL_32;
  }
  v12 = nw_protocol_stack_copy_transport_protocol(v3[7]);
  v13 = v12;
  if (!v12)
  {
    v14 = nw_protocol_stack_copy_internet_protocol(v3[7]);
    if (!v14)
      goto LABEL_29;
    if (is_equal_unsafe)
      goto LABEL_21;
    goto LABEL_26;
  }
  if (!is_equal_unsafe)
  {
    if (nw_protocol_options_matches_definition(v12, v10))
      goto LABEL_24;
    v14 = nw_protocol_stack_copy_internet_protocol(v3[7]);
    if (!v14)
      goto LABEL_29;
LABEL_26:
    if (nw_protocol_options_matches_definition(v14, v10))
      goto LABEL_27;
    goto LABEL_29;
  }
  v14 = v12;
  if (nw_protocol_options_is_quic_connection(v14))
  {
LABEL_27:
    v11 = 1;
LABEL_30:

    goto LABEL_31;
  }
  is_quic_stream = nw_protocol_options_is_quic_stream(v14);

  if (!is_quic_stream)
  {
    v14 = nw_protocol_stack_copy_internet_protocol(v3[7]);
    if (!v14)
      goto LABEL_29;
LABEL_21:
    v14 = v14;
    if (nw_protocol_options_is_quic_connection(v14))
    {

      goto LABEL_27;
    }
    v16 = nw_protocol_options_is_quic_stream(v14);

    if (v16)
      goto LABEL_27;
LABEL_29:
    v11 = 0;
    goto LABEL_30;
  }
LABEL_24:
  v11 = 1;
LABEL_31:

LABEL_32:
  _Block_object_dispose(buf, 8);
  if (!v11)
  {
LABEL_69:
    v17 = 0;
    goto LABEL_70;
  }
  v17 = 1;
LABEL_70:

  return v17;
}

void sub_1830291A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

nw_protocol_options_t nw_protocol_stack_copy_transport_protocol(nw_protocol_stack_t stack)
{
  nw_protocol_stack_t v1;
  nw_protocol_stack_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = stack;
  v2 = v1;
  if (v1)
  {
    v3 = v1[3].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_stack_copy_transport_protocol";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_stack_copy_transport_protocol";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_tcp_options_get_enable_fast_open(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_enable_fast_open_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_fast_open";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_fast_open";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_fast_open";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_fast_open";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_fast_open";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830297B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_upper_transport_protocol(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  id v5;
  _BOOL4 v6;
  void *v7;
  unsigned __int8 v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_parameters_get_upper_transport_protocol";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_parameters_get_upper_transport_protocol";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v21 = "nw_parameters_get_upper_transport_protocol";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_parameters_get_upper_transport_protocol";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_parameters_get_upper_transport_protocol";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_30:
    if (v10)
      free(v10);
    goto LABEL_32;
  }
  v3 = v1[19];
  if (!v3)
    goto LABEL_32;
  v4 = *(void **)(v3 + 24);
  if (!v4)
    goto LABEL_32;
  v5 = v4;
  if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1)
    dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45078);
  v6 = nw_protocol_options_matches_definition(v5, (void *)g_udp_definition);

  v7 = *(void **)(v2[19] + 24);
  if (!v6)
  {
    if (!nw_protocol_options_is_tcp(v7)
      && !nw_protocol_options_is_custom_ip(*(void **)(v2[19] + 24))
      && nw_protocol_options_is_quic(*(nw_protocol_options_t *)(v2[19] + 24)))
    {
      v8 = -3;
      goto LABEL_33;
    }
LABEL_32:
    v8 = 0;
    goto LABEL_33;
  }
  if (nw_udp_options_get_use_quic_stats(v7))
    v8 = -3;
  else
    v8 = 0;
LABEL_33:

  return v8;
}

void sub_183029B10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_tcp(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
    v2 = nw_protocol_options_matches_definition(v1, (void *)g_tcp_definition);
    goto LABEL_5;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_options_is_tcp";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_tcp";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_options_is_tcp";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_tcp";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_options_is_tcp";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_5:

  return v2;
}

void sub_183029DF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_quic(nw_protocol_options_t options)
{
  NSObject *v1;
  NSObject *v2;
  BOOL v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = options;
  v2 = v1;
  if (v1)
  {
    v3 = nw_protocol_options_is_quic_connection(v1) || nw_protocol_options_is_quic_stream(v2);
    goto LABEL_5;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_options_is_quic";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_is_quic";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_options_is_quic";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_is_quic";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_is_quic";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_5:

  return v3;
}

void sub_18302A0BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_custom_ip(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  _BOOL8 is_equal_unsafe;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[1];

    if (nw_protocol_copy_custom_ip_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_copy_custom_ip_definition(void)::onceToken, &__block_literal_global_6_52361);
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_custom_ip_definition(void)::definition);

    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_options_is_custom_ip";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_custom_ip";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_options_is_custom_ip";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_custom_ip";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_custom_ip";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_18302A3B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_reset_local_port(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_reset_local_port_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_reset_local_port";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_reset_local_port";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_reset_local_port";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_reset_local_port";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_reset_local_port";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_18302A6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_flow_passthrough_supports_external_data(nw_protocol *a1)
{
  nw_protocol *default_input_handler;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_flow_passthrough_supports_external_data";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v4, &type, &v10))
      goto LABEL_19;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_flow_passthrough_supports_external_data";
        v7 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
    }
    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            v13 = "nw_flow_passthrough_supports_external_data";
            v14 = 2082;
            v15 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v9)
          goto LABEL_18;
        *(_DWORD *)buf = 136446210;
        v13 = "nw_flow_passthrough_supports_external_data";
        v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_flow_passthrough_supports_external_data";
        v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:

LABEL_19:
    if (v4)
      free(v4);
    return 0;
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
    return nw_protocol_supports_external_data((uint64_t)default_input_handler);
  return 0;
}

uint64_t nw_endpoint_handler_is_dry_run(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 268) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_is_dry_run";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_is_dry_run";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_is_dry_run";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_is_dry_run";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_is_dry_run";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_array_contains_object(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  _QWORD *v4;
  _QWORD *v5;

  result = 0;
  if (a1 && a2)
  {
    v5 = *(_QWORD **)(a1 + 16);
    v4 = *(_QWORD **)(a1 + 24);
    if (v5 != v4)
    {
      while (*v5 != a2)
      {
        if (++v5 == v4)
        {
          v5 = v4;
          return v5 != v4;
        }
      }
    }
    return v5 != v4;
  }
  return result;
}

const char *nw_endpoint_event_event_string(int a1, int a2)
{
  unsigned __int16 v2;
  char **v3;
  const char *result;

  switch(a1)
  {
    case 1:
      v2 = a2 - 1;
      if ((a2 - 1) >= 0xA)
        goto LABEL_17;
      v3 = off_1E14A01E0;
      goto LABEL_16;
    case 2:
      v2 = a2 - 1;
      if ((unsigned __int16)(a2 - 1) >= 8u)
        goto LABEL_17;
      v3 = off_1E14A0230;
      goto LABEL_16;
    case 3:
      v2 = a2 - 1;
      if ((a2 - 1) >= 0xF)
        goto LABEL_17;
      v3 = off_1E14A0270;
      goto LABEL_16;
    case 4:
      v2 = a2 - 1;
      if ((a2 - 1) >= 6)
        goto LABEL_17;
      v3 = off_1E14A02E8;
      goto LABEL_16;
    case 5:
      v2 = a2 - 1;
      if ((a2 - 1) >= 5)
        goto LABEL_17;
      v3 = off_1E14A0318;
      goto LABEL_16;
    case 6:
      v2 = a2 - 1;
      if ((a2 - 1) >= 5)
        goto LABEL_17;
      v3 = off_1E14A0358;
      goto LABEL_16;
    case 7:
      v2 = a2 - 1;
      if ((a2 - 1) >= 3)
        goto LABEL_17;
      v3 = off_1E14A0340;
LABEL_16:
      result = v3[v2];
      break;
    default:
LABEL_17:
      result = "unknown";
      break;
  }
  return result;
}

void nw_endpoint_handler_access_proxy_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void (**v5)(_QWORD, _QWORD);
  _DWORD *v6;
  int v7;
  id *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = (void (**)(_QWORD, _QWORD))v4;
  if (!v3)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_endpoint_handler_access_proxy_handler";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_endpoint_handler_access_proxy_handler";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v10)
          goto LABEL_9;
        goto LABEL_44;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_42:

    goto LABEL_43;
  }
  if (!v4)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_endpoint_handler_access_proxy_handler";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null accessor", buf, 0xCu);
      }
    }
    else if (v23)
    {
      v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_endpoint_handler_access_proxy_handler";
          v27 = 2082;
          v28 = v18;
          _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null accessor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v10)
          goto LABEL_9;
LABEL_44:
        free(v10);
        goto LABEL_9;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null accessor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null accessor, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_42;
  }
  v6 = v3;
  while (1)
  {
    v6 = v6;
    v7 = v6[29];

    if (v7 == 3)
      break;
    v8 = v6;
    v6 = v8[9];

    if (!v6)
      goto LABEL_8;
  }
  ((void (**)(_QWORD, _DWORD *))v5)[2](v5, v6);
LABEL_8:

LABEL_9:
}

void sub_18302B230(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_connection_async_client(void *a1, dispatch_qos_class_t a2, void *a3)
{
  id v5;
  void *v6;
  NSObject *v7;
  dispatch_block_t v8;
  id v9;

  v9 = a1;
  v5 = a3;
  v6 = (void *)*((_QWORD *)v9 + 25);
  if (v6)
  {
    v7 = v6;
    v8 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, a2, 0, v5);
    dispatch_async(v7, v8);

  }
  else if (!*((_QWORD *)v9 + 5))
  {
    nw_context_queue_block(*((void **)v9 + 3), v5);
  }

}

void sub_18302B2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_should_skip_probe_sampling(void *a1)
{
  _BYTE *v1;
  _BOOL8 v2;

  v1 = a1;
  if (os_variant_allows_internal_security_policies())
    v2 = (v1[101] & 0x40) != 0
      || networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_disable_tls_experiment_sampling);
  else
    v2 = 0;

  return v2;
}

void sub_18302B368(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_set_no_wake_from_sleep(void *a1, int a2)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  _QWORD v15[5];
  char v16;
  char v17;
  os_log_type_t type;
  _BYTE buf[24];
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_tcp(v3))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_tcp_set_no_wake_from_sleep";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s nw_tcp_set_no_wake_from_sleep do_not_wake %d", buf, 0x12u);
    }

    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v20 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __nw_tcp_set_no_wake_from_sleep_block_invoke;
    v15[3] = &unk_1E14A87F0;
    v15[4] = buf;
    v16 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v15);
    v5 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_set_no_wake_from_sleep";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v8, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_set_no_wake_from_sleep";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  v5 = 22;
LABEL_5:

  return v5;
}

void sub_18302B6F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_set_no_wake_from_sleep_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t (*v5)(_QWORD, _QWORD);

  v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  v5 = *(uint64_t (**)(_QWORD, _QWORD))(a2 + 40);
  if (v5)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5(*(_QWORD *)(a2 + 48), *(unsigned __int8 *)(a1 + 40));
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_stream_get_id(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_18302BA7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_id_block_invoke(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t nw_protocol_metadata_create_reply(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(id);
  uint64_t v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_metadata_create_reply";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
      goto LABEL_37;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
      goto LABEL_37;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_metadata_create_reply";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  v3 = *((_QWORD *)v1 + 1);
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_metadata_create_reply";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata->definition", buf, 0xCu);
      }
LABEL_37:

LABEL_38:
      if (v8)
        free(v8);
      goto LABEL_40;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null metadata->definition, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_create_reply";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null metadata->definition, no backtrace", buf, 0xCu);
      }
      goto LABEL_37;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_metadata_create_reply";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null metadata->definition, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_25:

    free(backtrace_string);
    goto LABEL_38;
  }
  v4 = *(_QWORD *)(v3 + 72);
  if (!v4 || (v5 = *(uint64_t (**)(id))(v4 + 24)) == 0)
  {
LABEL_40:
    v6 = 0;
    goto LABEL_41;
  }
  v6 = v5(v1);
LABEL_41:

  return v6;
}

void sub_18302BF74(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id *nw_quic_create_connection_metadata()
{
  __int128 v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  if (uuid_is_null((const unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid))
    goto LABEL_6;
  if ((_QWORD)nw_uuid_generate_insecure(unsigned char *)::last_used_uuid != -1)
  {
    *(_QWORD *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid
                                                                           + 1;
    goto LABEL_7;
  }
  if (*((_QWORD *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1) == -1)
  {
LABEL_6:
    uuid_generate_random((unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid);
    BYTE9(nw_uuid_generate_insecure(unsigned char *)::last_used_uuid) = -1;
  }
  else
  {
    ++*((_QWORD *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1);
  }
LABEL_7:
  v1 = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  BYTE9(v1) &= ~1u;
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  return nw_protocol_metadata_create((void *)nw_protocol_copy_quic_connection_definition::quic_definition, &v1);
}

id *nw_tcp_create_metadata(_OWORD *a1)
{
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
  return nw_protocol_metadata_create((void *)g_tcp_definition, a1);
}

id *nw_protocol_metadata_create_singleton(void *a1)
{
  id v1;
  _QWORD *v2;
  uint64_t v3;
  size_t v4;
  objc_class *v5;
  id *Instance;
  id *v7;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  if (uuid_is_null((const unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid))
    goto LABEL_6;
  if ((_QWORD)nw_uuid_generate_insecure(unsigned char *)::last_used_uuid != -1)
  {
    *(_QWORD *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid
                                                                           + 1;
    goto LABEL_7;
  }
  if (*((_QWORD *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1) == -1)
  {
LABEL_6:
    uuid_generate_random((unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid);
    BYTE9(nw_uuid_generate_insecure(unsigned char *)::last_used_uuid) = -1;
  }
  else
  {
    ++*((_QWORD *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1);
  }
LABEL_7:
  v9 = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  v2 = v1;
  v3 = v2[10];
  if (v3)
    v4 = *(unsigned int *)(v3 + 260);
  else
    v4 = 0;
  v5 = (objc_class *)objc_opt_class();
  Instance = (id *)class_createInstance(v5, v4);
  v7 = -[NWConcrete_nw_protocol_metadata initWithDefinition:identifier:](Instance, v2, &v9);

  return v7;
}

void sub_18302C224(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_18302C770(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_metadata_copy_message_options(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(id);
  uint64_t v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_metadata_copy_message_options";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
      goto LABEL_37;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
      goto LABEL_37;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_metadata_copy_message_options";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  v3 = *((_QWORD *)v1 + 1);
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_metadata_copy_message_options";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata->definition", buf, 0xCu);
      }
LABEL_37:

LABEL_38:
      if (v8)
        free(v8);
      goto LABEL_40;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null metadata->definition, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null metadata->definition, no backtrace", buf, 0xCu);
      }
      goto LABEL_37;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_metadata_copy_message_options";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null metadata->definition, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_25:

    free(backtrace_string);
    goto LABEL_38;
  }
  v4 = *(_QWORD *)(v3 + 72);
  if (!v4 || (v5 = *(uint64_t (**)(id))(v4 + 48)) == 0)
  {
LABEL_40:
    v6 = 0;
    goto LABEL_41;
  }
  v6 = v5(v1);
LABEL_41:

  return v6;
}

void sub_18302CC40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_quic_metadata_copy_stream_options(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_metadata_copy_stream_options_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_metadata_copy_stream_options";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_metadata_copy_stream_options";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_metadata_copy_stream_options";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_metadata_copy_stream_options";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_metadata_copy_stream_options";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_18302CF70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_metadata_copy_stream_options_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 32));
  return 1;
}

void nw_quic_connection_metadata_set_stream_options(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_metadata_set_stream_options_block_invoke;
    v13[3] = &unk_1E14A9F20;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_metadata_set_stream_options";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_metadata_set_stream_options";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_metadata_set_stream_options";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_metadata_set_stream_options";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_metadata_set_stream_options";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18302D2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_stream_metadata(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_stream_metadata_block_invoke;
    v13[3] = &unk_1E14A9F20;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_stream_metadata";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_stream_metadata";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_stream_metadata";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_stream_metadata";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_stream_metadata";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18302D5BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

id nw_quic_connection_copy_stream_metadata(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_copy_stream_metadata_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_copy_stream_metadata";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_stream_metadata";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_copy_stream_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_stream_metadata";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_stream_metadata";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_18302D900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

BOOL nw_protocol_metadata_is_quic_connection(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  _BOOL8 is_equal_unsafe;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[1];

    if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_quic_connection_definition::quic_definition);

    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_metadata_is_quic_connection";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_quic_connection";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_metadata_is_quic_connection";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_quic_connection";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_quic_connection";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_18302DC18(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_copy_stream_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 40));
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_quic_connection_set_stream_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  objc_storeStrong((id *)(a2 + 40), *(id *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_quic_connection_metadata_set_stream_options_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 32), *(id *)(a1 + 32));
  return 1;
}

void nw_quic_stream_set_type(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_type_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_stream_set_type";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_type";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_stream_set_type";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_type";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_type";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_18302DFC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_type_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 46) = *(_BYTE *)(a1 + 32);
  return 1;
}

void nw_quic_stream_set_id(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_id_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_stream_set_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_stream_set_id";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_18302E2AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_stream_set_connection_metadata(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_stream_set_connection_metadata_block_invoke;
    v13[3] = &unk_1E14A9F20;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_stream_set_connection_metadata";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_set_connection_metadata";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_stream_set_connection_metadata";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_set_connection_metadata";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_set_connection_metadata";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18302E5A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void nw_quic_stream_set_application_error_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_stream_set_application_error_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_stream_set_application_error_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_set_application_error_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_stream_set_application_error_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_set_application_error_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_set_application_error_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18302E8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_metadata_is_quic_stream(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  _BOOL8 is_equal_unsafe;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[1];

    if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_quic_stream_definition::quic_definition);

    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_metadata_is_quic_stream";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_quic_stream";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_metadata_is_quic_stream";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_quic_stream";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_quic_stream";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_18302EBB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_tcp_set_callbacks(void *a1, uint64_t a2, uint64_t a3)
{
  NSObject *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[6];
  char v15;
  os_log_type_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (nw_protocol_metadata_is_tcp(v5))
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_tcp_set_callbacks_block_invoke;
    v14[3] = &__block_descriptor_48_e9_B16__0_v8l;
    v14[4] = a2;
    v14[5] = a3;
    nw_protocol_metadata_access_handle((uint64_t)v5, (uint64_t)v14);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_tcp_set_callbacks";
  v7 = (char *)_os_log_send_and_compose_impl();

  v16 = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_tcp_set_callbacks";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v16;
      v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_tcp_set_callbacks";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_tcp_set_callbacks";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_tcp_set_callbacks";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_18302EEA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_metadata_access_handle(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  void *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_metadata_access_handle";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_metadata_access_handle";
        v8 = "%{public}s called with null metadata";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_metadata_access_handle";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v5)
          return 0;
LABEL_35:
        free(v5);
        return 0;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_metadata_access_handle";
        v8 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_32;
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_metadata_access_handle";
        v8 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_32;
      }
    }
LABEL_33:

    goto LABEL_34;
  }
  if (!a2)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_metadata_access_handle";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_metadata_access_handle";
        v8 = "%{public}s called with null access_block";
        goto LABEL_32;
      }
    }
    else
    {
      if (v14)
      {
        v12 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        v13 = os_log_type_enabled(v6, type);
        if (v12)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_protocol_metadata_access_handle";
            v18 = 2082;
            v19 = v12;
            _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v12);
          if (!v5)
            return 0;
          goto LABEL_35;
        }
        if (!v13)
          goto LABEL_33;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_metadata_access_handle";
        v8 = "%{public}s called with null access_block, no backtrace";
        goto LABEL_32;
      }
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_metadata_access_handle";
        v8 = "%{public}s called with null access_block, backtrace limit exceeded";
        goto LABEL_32;
      }
    }
    goto LABEL_33;
  }
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  return 0;
}

BOOL nw_protocol_metadata_is_tcp(nw_protocol_metadata_t metadata)
{
  NSObject *v1;
  BOOL v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = metadata;
  if (v1)
  {
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
    v2 = nw_protocol_metadata_matches_definition((uint64_t)v1, g_tcp_definition);
    goto LABEL_5;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_metadata_is_tcp";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_metadata_is_tcp";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_metadata_is_tcp";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_metadata_is_tcp";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_metadata_is_tcp";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_5:

  return v2;
}

void sub_18302F5C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_tcp_set_callbacks_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  __int128 *v5;
  __int128 v6;
  __int128 v7;

  v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 32);
  v5 = *(__int128 **)(a1 + 40);
  if (v5)
  {
    v6 = *v5;
    v7 = v5[2];
    *(_OWORD *)(a2 + 16) = v5[1];
    *(_OWORD *)(a2 + 32) = v7;
  }
  else
  {
    v6 = 0uLL;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
  }
  *(_OWORD *)a2 = v6;
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_quic_stream_set_application_error_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_quic_stream_set_connection_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a2 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
  objc_storeStrong((id *)(a2 + 32), *(id *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_quic_stream_set_id_block_invoke(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_endpoint_handler_migration_callback(void *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  id v6;

  v6 = a1;
  v3 = a2;
  *((_DWORD *)v6 + 20) = 655361;
  nw_endpoint_handler_report(v6, 0, (_WORD *)v6 + 40, 0);
  v4 = _Block_copy(*((const void **)v6 + 6));
  v5 = v4;
  if (v4)
    (*((void (**)(void *, id))v4 + 2))(v4, v3);

}

void sub_18302F780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_connect(void *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_mode_handler *v2;
  const char *v3;
  void *v4;
  char v5;
  NWConcrete_nw_endpoint_handler *v6;
  char v7;
  NSObject *v8;
  NWConcrete_nw_endpoint_handler *v9;
  NWConcrete_nw_endpoint_handler *v10;
  char v11;
  const char *v12;
  nw_endpoint_t v13;
  const char *v14;
  char *id_str;
  unsigned int *v16;
  unsigned int *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  void *v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(const char *, char *);
  uint64_t v26;
  void **v27;
  void **v28;
  const char *v29;
  void **v30;
  id v31;
  void *v32;
  const char *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  void *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  char *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  const char *v45;
  char *backtrace_string;
  os_log_type_t v47;
  _BOOL4 v48;
  const char *id_string;
  const char *v50;
  nw_endpoint_t v51;
  const char *logging_description;
  const char *v53;
  const char *v54;
  id v55;
  os_log_type_t v56;
  const char *v57;
  os_log_type_t v58;
  const char *v59;
  const char *v61;
  char v62;
  os_log_type_t type;
  uint64_t v64;
  char v65;
  os_log_type_t v66[8];
  char v67;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  void *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  void *v75;
  __int16 v76;
  const char *v77;
  __int16 v78;
  const char *v79;
  __int16 v80;
  id v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = nw_endpoint_handler_copy_flow(v1);
  if (!v2)
  {
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_endpoint_flow_connect";
    v39 = (char *)_os_log_send_and_compose_impl();

    v66[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v64) = 0;
    if (__nwlog_fault(v39, v66, &v64))
    {
      if (v66[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v41 = v66[0];
        if (os_log_type_enabled(v40, v66[0]))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_endpoint_flow_connect";
          _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if ((_BYTE)v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v47 = v66[0];
        v48 = os_log_type_enabled(v40, v66[0]);
        if (backtrace_string)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            v69 = "nw_endpoint_flow_connect";
            v70 = 2082;
            v71 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v40, v47, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_98;
        }
        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_endpoint_flow_connect";
          _os_log_impl(&dword_182FBE000, v40, v47, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v58 = v66[0];
        if (os_log_type_enabled(v40, v66[0]))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_endpoint_flow_connect";
          _os_log_impl(&dword_182FBE000, v40, v58, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_98:
    if (v39)
      free(v39);
    v26 = 0;
    goto LABEL_94;
  }
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_79826);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  v1->event = (nw_endpoint_handler_event_s)196611;
  nw_endpoint_handler_report(v1, 0, &v1->event.domain, 0);
  v3 = (const char *)*((_QWORD *)v2 + 51);
  if (!v3)
  {
    if (nw_endpoint_handler_get_minimize_logging(v1))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) != 0)
        goto LABEL_43;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v8 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v1);
        v50 = nw_endpoint_handler_dry_run_string(v1);
        v51 = nw_endpoint_handler_copy_endpoint(v1);
        logging_description = nw_endpoint_get_logging_description(v51);
        v53 = nw_endpoint_handler_state_string(v1);
        v54 = nw_endpoint_handler_mode_string(v1);
        v55 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        v69 = "nw_endpoint_flow_connect";
        v70 = 2082;
        v71 = (void *)id_string;
        v72 = 2082;
        v73 = v50;
        v74 = 2082;
        v75 = (void *)logging_description;
        v76 = 2082;
        v77 = v53;
        v78 = 2082;
        v79 = v54;
        v80 = 2114;
        v81 = v55;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connect bottom protocol", buf, 0x48u);

      }
    }
    else
    {
      v6 = v1;
      v7 = *((_BYTE *)v6 + 268);

      if ((v7 & 0x20) != 0)
      {
LABEL_43:
        v26 = 1;
        goto LABEL_94;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v8 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        v9 = v6;

        v10 = v9;
        v11 = *((_BYTE *)v6 + 268);

        if ((v11 & 1) != 0)
          v12 = "dry-run ";
        else
          v12 = "";
        v13 = nw_endpoint_handler_copy_endpoint(v10);
        v14 = nw_endpoint_get_logging_description(v13);
        id_str = v9->id_str;
        v16 = v10;
        v17 = v16;
        v18 = v16[30];
        if (v18 > 5)
          v19 = "unknown-state";
        else
          v19 = off_1E149FC48[v18];
        v61 = v19;

        v27 = v17;
        v28 = v27;
        v29 = "path";
        switch(*((_DWORD *)v27 + 29))
        {
          case 0:
            break;
          case 1:
            v29 = "resolver";
            break;
          case 2:
            v29 = nw_endpoint_flow_mode_string(v27[31]);
            break;
          case 3:
            v29 = "proxy";
            break;
          case 4:
            v29 = "fallback";
            break;
          case 5:
            v29 = "transform";
            break;
          default:
            v29 = "unknown-mode";
            break;
        }

        v30 = v28;
        os_unfair_lock_lock((os_unfair_lock_t)v30 + 28);
        v31 = v30[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v30 + 28);

        *(_DWORD *)buf = 136447746;
        v69 = "nw_endpoint_flow_connect";
        v70 = 2082;
        v71 = id_str;
        v72 = 2082;
        v73 = v12;
        v74 = 2082;
        v75 = (void *)v14;
        v76 = 2082;
        v77 = v61;
        v78 = 2082;
        v79 = v29;
        v80 = 2114;
        v81 = v31;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connect bottom protocol", buf, 0x48u);

      }
    }

    goto LABEL_43;
  }
  v4 = (void *)*((_QWORD *)v3 + 5);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v20 = *((_QWORD *)v3 + 11);
    if (v20)
      *((_QWORD *)v3 + 11) = v20 + 1;
    v5 = -1;
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)v66 = v3;
  v67 = v5;
  v21 = (void *)*((_QWORD *)v2 + 52);
  if (v21 == &nw_protocol_ref_counted_handle)
  {
    v23 = *((_QWORD *)v2 + 58);
    if (v23)
      *((_QWORD *)v2 + 58) = v23 + 1;
    v22 = -1;
  }
  else
  {
    v22 = 0;
  }
  v64 = (uint64_t)v2 + 376;
  v65 = v22;
  v24 = *((_QWORD *)v3 + 3);
  if (v24)
  {
    v25 = *(uint64_t (**)(const char *, char *))(v24 + 24);
    if (v25)
    {
      v26 = v25(v3, (char *)v2 + 376);
      if (v21 != &nw_protocol_ref_counted_handle)
        goto LABEL_31;
      goto LABEL_92;
    }
  }
  __nwlog_obj();
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = (const char *)*((_QWORD *)v3 + 2);
  *(_DWORD *)buf = 136446722;
  v69 = "__nw_protocol_connect";
  if (!v33)
    v33 = "invalid";
  v70 = 2082;
  v71 = (void *)v33;
  v72 = 2048;
  v73 = v3;
  v34 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v62 = 0;
  if (__nwlog_fault(v34, &type, &v62))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        v37 = (const char *)*((_QWORD *)v3 + 2);
        if (!v37)
          v37 = "invalid";
        *(_DWORD *)buf = 136446722;
        v69 = "__nw_protocol_connect";
        v70 = 2082;
        v71 = (void *)v37;
        v72 = 2048;
        v73 = v3;
        _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid connect callback", buf, 0x20u);
      }
LABEL_88:

      goto LABEL_89;
    }
    if (!v62)
    {
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v35, type))
      {
        v57 = (const char *)*((_QWORD *)v3 + 2);
        if (!v57)
          v57 = "invalid";
        *(_DWORD *)buf = 136446722;
        v69 = "__nw_protocol_connect";
        v70 = 2082;
        v71 = (void *)v57;
        v72 = 2048;
        v73 = v3;
        _os_log_impl(&dword_182FBE000, v35, v56, "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded", buf, 0x20u);
      }
      goto LABEL_88;
    }
    v42 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v35 = objc_claimAutoreleasedReturnValue();
    v43 = type;
    v44 = os_log_type_enabled(v35, type);
    if (!v42)
    {
      if (v44)
      {
        v59 = (const char *)*((_QWORD *)v3 + 2);
        if (!v59)
          v59 = "invalid";
        *(_DWORD *)buf = 136446722;
        v69 = "__nw_protocol_connect";
        v70 = 2082;
        v71 = (void *)v59;
        v72 = 2048;
        v73 = v3;
        _os_log_impl(&dword_182FBE000, v35, v43, "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace", buf, 0x20u);
      }
      goto LABEL_88;
    }
    if (v44)
    {
      v45 = (const char *)*((_QWORD *)v3 + 2);
      if (!v45)
        v45 = "invalid";
      *(_DWORD *)buf = 136446978;
      v69 = "__nw_protocol_connect";
      v70 = 2082;
      v71 = (void *)v45;
      v72 = 2048;
      v73 = v3;
      v74 = 2082;
      v75 = v42;
      _os_log_impl(&dword_182FBE000, v35, v43, "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }

    free(v42);
  }
LABEL_89:
  if (v34)
    free(v34);
  v26 = 0;
  if (v21 != &nw_protocol_ref_counted_handle)
  {
LABEL_31:
    if (v4 == &nw_protocol_ref_counted_handle)
      goto LABEL_93;
    goto LABEL_94;
  }
LABEL_92:
  nw::release_if_needed<nw_protocol *>(&v64);
  if (v4 == &nw_protocol_ref_counted_handle)
LABEL_93:
    nw::release_if_needed<nw_protocol *>((uint64_t *)v66);
LABEL_94:

  return v26;
}

void sub_1830301B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_receive_report(void *a1, int a2, int a3, unsigned __int16 *a4, void *a5, void *a6)
{
  void *v11;
  NWConcrete_nw_endpoint_handler *v12;
  id v13;
  unsigned int *v14;
  uint64_t v15;
  unsigned int *v16;
  char v17;
  NSObject *v18;
  unsigned int *v19;
  char *v20;
  char v21;
  const char *v22;
  const char *logging_description;
  unsigned int *v24;
  unsigned int *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  void **v31;
  const char *v32;
  void **v33;
  id v34;
  id v35;
  const char *v36;
  nw_endpoint_t v37;
  const char *v38;
  const char *v39;
  const char *v40;
  char *v41;
  const char *v42;
  const char *v43;
  id v44;
  int v45;
  __int16 v46;
  NWConcrete_nw_endpoint_mode_handler *v47;
  os_unfair_lock_s *v48;
  int v49;
  void *v50;
  NWConcrete_nw_endpoint_mode_handler *v51;
  NWConcrete_nw_endpoint_mode_handler *v52;
  void *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  char *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  os_log_type_t v60;
  unsigned int v61;
  void *v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  _BOOL8 v66;
  void *v67;
  id *v68;
  id *v69;
  int v70;
  uint64_t v71;
  id *v72;
  id *v73;
  BOOL v74;
  unsigned int *v75;
  char v76;
  NSObject *v77;
  char *v78;
  char *v79;
  _BOOL4 v80;
  const char *v81;
  nw_endpoint_t v82;
  const char *v83;
  unsigned int *v84;
  unsigned int *v85;
  uint64_t v86;
  const char *v87;
  unsigned int *v88;
  _BOOL4 v89;
  NSObject *v90;
  char *v91;
  char *v92;
  _BOOL4 v93;
  const char *v94;
  nw_endpoint_t v95;
  const char *v96;
  unsigned int *v97;
  unsigned int *v98;
  uint64_t v99;
  const char *v100;
  NWConcrete_nw_endpoint_mode_handler *v101;
  unsigned int *v102;
  NSObject *v103;
  char *v104;
  char *v105;
  _BOOL4 v106;
  const char *v107;
  nw_endpoint_t v108;
  const char *v109;
  unsigned int *v110;
  unsigned int *v111;
  uint64_t v112;
  const char *v113;
  void **v114;
  void **v115;
  const char *v116;
  void **v117;
  void **v118;
  const char *v119;
  void **v120;
  const char *v121;
  void *v122;
  unsigned int *v123;
  nw_endpoint_t v124;
  const char *v125;
  const char *v126;
  const char *v127;
  unsigned int *v128;
  void **v129;
  id v130;
  NWConcrete_nw_endpoint_mode_handler *v131;
  unsigned int *v132;
  uint64_t v133;
  NWConcrete_nw_endpoint_mode_handler *v134;
  char *v135;
  unsigned int *v136;
  _BOOL4 v137;
  NSObject *v138;
  char *v139;
  char *v140;
  _BOOL4 v141;
  const char *v142;
  nw_endpoint_t v143;
  const char *v144;
  unsigned int *v145;
  unsigned int *v146;
  uint64_t v147;
  const char *v148;
  id v149;
  const char *v150;
  void *v151;
  NSObject *v152;
  os_log_type_t v153;
  const char *v154;
  char *v155;
  os_log_type_t v156;
  _BOOL4 v157;
  const char *v158;
  os_log_type_t v159;
  const char *v160;
  const char *v161;
  nw_endpoint_t v162;
  const char *v163;
  void **v164;
  id v165;
  char *v166;
  id v167;
  void *v168;
  const char *v169;
  NWConcrete_nw_endpoint_mode_handler *v170;
  uint64_t v171;
  char *v172;
  _QWORD *v173;
  void *v174;
  id v175;
  char *v176;
  NSObject *v177;
  os_log_type_t v178;
  NSObject *v179;
  char *v180;
  os_log_type_t v181;
  _BOOL4 v182;
  os_log_type_t v183;
  nw_endpoint_t v184;
  const char *v185;
  const char *v186;
  const char *v187;
  void **v188;
  id v189;
  NWConcrete_nw_endpoint_mode_handler *v190;
  unsigned int *v191;
  BOOL v192;
  NSObject *v193;
  char *v194;
  char *v195;
  _BOOL4 v196;
  const char *v197;
  nw_endpoint_t v198;
  const char *v199;
  unsigned int *v200;
  unsigned int *v201;
  uint64_t v202;
  const char *v203;
  void **v204;
  void **v205;
  const char *v206;
  void **v207;
  void **v208;
  const char *v209;
  unsigned int *v210;
  _BOOL4 v211;
  NSObject *v212;
  char *v213;
  char *v214;
  _BOOL4 v215;
  const char *v216;
  nw_endpoint_t v217;
  const char *v218;
  unsigned int *v219;
  unsigned int *v220;
  uint64_t v221;
  const char *v222;
  void **v223;
  void **v224;
  const char *v225;
  void **v226;
  id v227;
  char *v228;
  id v229;
  void *v230;
  const char *v231;
  void **v232;
  id v233;
  unsigned int *v234;
  BOOL v235;
  char *v236;
  char *v237;
  _BOOL4 v238;
  const char *v239;
  nw_endpoint_t v240;
  const char *v241;
  unsigned int *v242;
  unsigned int *v243;
  uint64_t v244;
  const char *v245;
  void **v246;
  const char *v247;
  char *v248;
  NSObject *v249;
  NWConcrete_nw_endpoint_mode_handler *v250;
  nw_endpoint_t v251;
  const char *v252;
  const char *v253;
  const char *v254;
  void **v255;
  id v256;
  const char *v257;
  nw_endpoint_t v258;
  void **v259;
  id v260;
  NWConcrete_nw_endpoint_handler *v262;
  int state;
  int minimize_logging;
  char logging_disabled;
  NSObject *v266;
  const char *v267;
  const char *v268;
  nw_endpoint_t v269;
  const char *v270;
  const char *v271;
  const char *v272;
  id v273;
  NWConcrete_nw_endpoint_handler *v274;
  int v275;
  int v276;
  char v277;
  NWConcrete_nw_endpoint_mode_handler *v278;
  NSObject *v279;
  const char *v280;
  const char *v281;
  nw_endpoint_t v282;
  const char *v283;
  const char *v284;
  const char *v285;
  id v286;
  unsigned int *v287;
  unsigned int v288;
  unsigned int *v289;
  void *v290;
  char *v291;
  NSObject *v292;
  os_log_type_t v293;
  char *backtrace_string;
  os_log_type_t v295;
  _BOOL4 v296;
  void *v297;
  char *v298;
  NSObject *v299;
  os_log_type_t v300;
  os_log_type_t v301;
  void *v302;
  os_log_type_t v303;
  void *v304;
  char *v305;
  NSObject *v306;
  os_log_type_t v307;
  void *v308;
  os_log_type_t v309;
  char *v310;
  os_log_type_t v311;
  _BOOL4 v312;
  char *v313;
  os_log_type_t v314;
  _BOOL4 v315;
  char *v316;
  os_log_type_t v317;
  _BOOL4 v318;
  os_log_type_t v319;
  _BOOL4 v320;
  os_log_type_t v321;
  const char *v322;
  nw_endpoint_t v323;
  const char *v324;
  const char *v325;
  const char *v326;
  id v327;
  os_log_type_t v328;
  os_log_type_t v329;
  os_log_type_t v330;
  const char *v331;
  const char *v332;
  nw_endpoint_t v333;
  const char *v334;
  const char *v335;
  const char *v336;
  id v337;
  const char *v338;
  const char *v339;
  nw_endpoint_t v340;
  const char *v341;
  const char *v342;
  const char *v343;
  id v344;
  const char *v345;
  const char *id_string;
  const char *v347;
  NSObject *v348;
  os_log_t v349;
  NSObject *v350;
  NSObject *v351;
  os_log_t v352;
  void *v353;
  int v354;
  int v355;
  unsigned __int16 *v356;
  unsigned int *v357;
  const char *v358;
  int v359;
  NWConcrete_nw_endpoint_handler *v360;
  nw_endpoint_t v361;
  NWConcrete_nw_endpoint_mode_handler *v362;
  NSObject *log;
  NWConcrete_nw_endpoint_handler *loga;
  id v365;
  unsigned int *v366;
  const char *v367;
  NSObject *v368;
  const char *v369;
  void *v370;
  NWConcrete_nw_endpoint_handler *v371;
  os_log_type_t type[8];
  uint64_t v373;
  uint64_t (*v374)(_QWORD *, uint64_t);
  void *v375;
  os_log_type_t *v376;
  char *v377;
  char *v378;
  os_log_type_t v379[8];
  os_log_type_t *v380;
  uint64_t v381;
  char v382;
  char v383;
  uint8_t buf[4];
  const char *v385;
  __int16 v386;
  char *v387;
  __int16 v388;
  const char *v389;
  __int16 v390;
  void *v391;
  __int16 v392;
  void *v393;
  __int16 v394;
  void *v395;
  __int16 v396;
  id v397;
  __int16 v398;
  const char *v399;
  __int16 v400;
  const char *v401;
  __int16 v402;
  const char *v403;
  __int16 v404;
  const char *v405;
  __int16 v406;
  const char *v407;
  __int16 v408;
  id v409;
  uint64_t v410;

  v11 = a1;
  v410 = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v365 = a5;
  v13 = a6;
  v370 = v13;
  v371 = v12;
  if (!v13)
  {
    __nwlog_obj();
    v290 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v385 = "nw_endpoint_flow_receive_report";
    v291 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v379[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v291, type, v379))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v292 = objc_claimAutoreleasedReturnValue();
        v293 = type[0];
        if (os_log_type_enabled(v292, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v385 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_182FBE000, v292, v293, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v379[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v292 = objc_claimAutoreleasedReturnValue();
        v295 = type[0];
        v296 = os_log_type_enabled(v292, type[0]);
        if (backtrace_string)
        {
          if (v296)
          {
            *(_DWORD *)buf = 136446466;
            v385 = "nw_endpoint_flow_receive_report";
            v386 = 2082;
            v387 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v292, v295, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_396;
        }
        if (v296)
        {
          *(_DWORD *)buf = 136446210;
          v385 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_182FBE000, v292, v295, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v292 = objc_claimAutoreleasedReturnValue();
        v301 = type[0];
        if (os_log_type_enabled(v292, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v385 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_182FBE000, v292, v301, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_396:
    if (v291)
      free(v291);
    goto LABEL_18;
  }
  v14 = (unsigned int *)v13;
  v15 = v14[29];

  if ((_DWORD)v15 == 2)
  {
    v355 = a3;
    v357 = v14;
    v16 = v14;
    v17 = *((_BYTE *)v16 + 268);

    v366 = v16;
    v356 = a4;
    if ((v17 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v18 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v19 = v16;

        v20 = v19;
        v21 = *((_BYTE *)v16 + 268);

        if ((v21 & 1) != 0)
          v22 = "dry-run ";
        else
          v22 = "";
        log = v18;
        v361 = nw_endpoint_handler_copy_endpoint(v20);
        logging_description = nw_endpoint_get_logging_description(v361);
        v24 = v20;
        v25 = v24;
        v26 = v24[30];
        if (v26 > 5)
          v27 = "unknown-state";
        else
          v27 = off_1E149FC48[v26];

        v31 = v25;
        v359 = a2;
        v349 = (os_log_t)v27;
        v353 = v11;
        v32 = "path";
        switch(v357[29])
        {
          case 0u:
            break;
          case 1u:
            v32 = "resolver";
            break;
          case 2u:
            v32 = nw_endpoint_flow_mode_string(v31[31]);
            break;
          case 3u:
            v32 = "proxy";
            break;
          case 4u:
            v32 = "fallback";
            break;
          case 5u:
            v32 = "transform";
            break;
          default:
            v32 = "unknown-mode";
            break;
        }
        v347 = v32;

        v33 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v33 + 28);
        v34 = v33[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v33 + 28);

        v35 = v34;
        id_string = nw_endpoint_handler_get_id_string(v371);
        v36 = nw_endpoint_handler_dry_run_string(v371);
        v37 = nw_endpoint_handler_copy_endpoint(v371);
        v38 = logging_description;
        v39 = v22;
        v40 = nw_endpoint_get_logging_description(v37);
        v41 = (char *)(v19 + 42);
        v42 = nw_endpoint_handler_state_string(v371);
        v43 = nw_endpoint_handler_mode_string(v371);
        v44 = nw_endpoint_handler_copy_current_path(v371);
        *(_DWORD *)buf = 136449282;
        v385 = "nw_endpoint_flow_receive_report";
        v386 = 2082;
        v387 = v41;
        v388 = 2082;
        v389 = v39;
        v390 = 2082;
        v391 = (void *)v38;
        v392 = 2082;
        v393 = v349;
        v394 = 2082;
        v395 = (void *)v347;
        v396 = 2114;
        v397 = v35;
        v398 = 2082;
        v399 = id_string;
        v400 = 2082;
        v401 = v36;
        v402 = 2082;
        v403 = v40;
        v404 = 2082;
        v405 = v42;
        v406 = 2082;
        v407 = v43;
        v408 = 2114;
        v409 = v44;
        v18 = log;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received child report: [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

        a2 = v359;
        v11 = v353;

      }
      v12 = v371;
      v16 = v366;
      a4 = v356;
    }
    if (a4 && *a4 == 3)
    {
      v45 = a4[1];
      if (v45 == 6)
      {
        v46 = 13;
        goto LABEL_36;
      }
      if (v45 == 9)
      {
        v46 = 15;
LABEL_36:
        *((_WORD *)v16 + 40) = 3;
        *((_WORD *)v16 + 41) = v46;
        nw_endpoint_handler_report(v16, v12, (_WORD *)v16 + 40, v365);
        goto LABEL_37;
      }
    }
    nw_endpoint_handler_report(v16, v12, a4, v365);
LABEL_37:
    v47 = nw_endpoint_handler_copy_flow((NWConcrete_nw_endpoint_handler *)v16);
    v48 = (os_unfair_lock_s *)((char *)v47 + 880);
    os_unfair_lock_lock((os_unfair_lock_t)v47 + 220);
    v49 = 0;
    v362 = v47;
    loga = 0;
    if (a2 == 2 && v355 == 3)
    {
      v49 = 0;
      loga = 0;
      if (a4)
      {
        if (v12 && !*((_QWORD *)v47 + 117))
        {
          if (*a4 == 3 && a4[1] == 6)
          {
            v50 = (void *)*((_QWORD *)v47 + 118);
            *((_QWORD *)v47 + 118) = 0;

            objc_storeStrong((id *)v47 + 117, v11);
            v51 = nw_endpoint_handler_copy_flow(v371);
            v52 = v51;
            if (!*((_QWORD *)v47 + 96) && v51 && *((_QWORD *)v51 + 96))
            {
              *((_BYTE *)v47 + 35) |= 2u;
              nw_endpoint_flow_reinitialize_protocol_for_handling_requests(v371);
            }
            loga = v371;
            if ((*((_BYTE *)v47 + 32) & 2) == 0)
              goto LABEL_68;
            __nwlog_obj();
            v53 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v385 = "nw_endpoint_flow_receive_report";
            v54 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v379[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v54, type, v379))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v55 = objc_claimAutoreleasedReturnValue();
                v56 = type[0];
                if (os_log_type_enabled(v55, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_endpoint_flow_receive_report";
                  _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s leaf flow had child flow become ready", buf, 0xCu);
                }
              }
              else if (v379[0])
              {
                v57 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v55 = objc_claimAutoreleasedReturnValue();
                v58 = type[0];
                v59 = os_log_type_enabled(v55, type[0]);
                if (v57)
                {
                  if (v59)
                  {
                    *(_DWORD *)buf = 136446466;
                    v385 = "nw_endpoint_flow_receive_report";
                    v386 = 2082;
                    v387 = v57;
                    _os_log_impl(&dword_182FBE000, v55, v58, "%{public}s leaf flow had child flow become ready, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v57);
                  goto LABEL_66;
                }
                if (v59)
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_endpoint_flow_receive_report";
                  _os_log_impl(&dword_182FBE000, v55, v58, "%{public}s leaf flow had child flow become ready, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                __nwlog_obj();
                v55 = objc_claimAutoreleasedReturnValue();
                v60 = type[0];
                if (os_log_type_enabled(v55, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_endpoint_flow_receive_report";
                  _os_log_impl(&dword_182FBE000, v55, v60, "%{public}s leaf flow had child flow become ready, backtrace limit exceeded", buf, 0xCu);
                }
              }

            }
LABEL_66:
            if (v54)
              free(v54);
LABEL_68:

            v49 = 1;
            v12 = v371;
            v47 = v362;
            v16 = v366;
            a4 = v356;
            goto LABEL_69;
          }
          loga = 0;
          v49 = 0;
        }
      }
    }
LABEL_69:
    v61 = 0;
    v62 = (void *)*((_QWORD *)v47 + 117);
    if (a4 && v62 == v16)
    {
      v63 = *a4;
      if (v63 == 1)
      {
        v64 = a4[1];
        if (v64 <= 6)
        {
          v61 = (0x68u >> v64) & 1;
          goto LABEL_77;
        }
      }
      else if (v63 == 3)
      {
        v61 = a4[1] == 8;
        goto LABEL_77;
      }
      v61 = 0;
    }
LABEL_77:
    v354 = v49;
    if (a2 == 2 && a4 && !v62 && *a4 == 3 && a4[1] == 9)
    {
      v65 = *((_QWORD *)v47 + 118);
      if (!v65)
      {
        v66 = nw_array_create();
        v67 = (void *)*((_QWORD *)v47 + 118);
        *((_QWORD *)v47 + 118) = v66;

        v47 = v362;
        v65 = *((_QWORD *)v362 + 118);
        v12 = v371;
        v16 = v366;
        a4 = v356;
      }
      if (!v65 || !v12)
        goto LABEL_91;
      v69 = *(id **)(v65 + 16);
      v68 = *(id **)(v65 + 24);
      if (v69 != v68)
      {
        while (*v69 != v12)
        {
          if (++v69 == v68)
          {
            v69 = *(id **)(v65 + 24);
            break;
          }
        }
      }
      if (v69 == v68)
      {
LABEL_91:
        nw_array_append(v65, v12);
LABEL_112:
        v360 = v12;
        v354 = 1;
        goto LABEL_114;
      }
      goto LABEL_113;
    }
    if (a4 && v62 == v12 && (*((_BYTE *)v47 + 32) & 1) != 0 && *a4 == 1)
    {
      v70 = a4[1];
      if (a2 != 2 || v70 == 7)
      {
        os_unfair_lock_unlock(v48);
        if (v70 == 7)
        {
          nw_endpoint_flow_cleanup_protocol(v16, (uint64_t)v47 + 376, 1);
          *((_WORD *)v47 + 354) &= ~1u;
          nw_endpoint_flow_initialize_protocol(v16, (uint64_t)v47 + 376, *((_BYTE *)v47 + 32) & 1);
          v122 = (void *)*((_QWORD *)v47 + 117);
          *((_QWORD *)v47 + 117) = 0;

          v123 = v366;
          v123[30] = 2;

          v12 = v371;
          v47 = v362;
          v16 = v366;
          nw_endpoint_handler_report(v123, 0, v356, 0);
          if (!loga)
          {
            v360 = 0;
            goto LABEL_339;
          }
          v360 = 0;
          goto LABEL_117;
        }
        v360 = 0;
        if (!v61)
        {
LABEL_116:
          if (!loga)
          {
            if (!v360)
            {
              v360 = 0;
              if (!v354)
              {
LABEL_341:
                if (*((NWConcrete_nw_endpoint_handler **)v47 + 116) != v12)
                {
LABEL_342:
                  v30 = 1;
                  goto LABEL_343;
                }
                if (v355 == 4)
                {
                  *((_BYTE *)v47 + 35) |= 4u;
                  v262 = v16;
                  state = v262->state;

                  if (state != 5
                    && (*((_BYTE *)v362 + 32) & 1) != 0
                    && nw_endpoint_handler_get_has_better_path(v262, 0))
                  {
                    minimize_logging = nw_endpoint_handler_get_minimize_logging(v262);
                    logging_disabled = nw_endpoint_handler_get_logging_disabled(v262);
                    if (minimize_logging)
                    {
                      if ((logging_disabled & 1) != 0)
                        goto LABEL_356;
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v266 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v266, OS_LOG_TYPE_DEBUG))
                      {
                        v338 = nw_endpoint_handler_get_id_string(v262);
                        v339 = nw_endpoint_handler_dry_run_string(v262);
                        v340 = nw_endpoint_handler_copy_endpoint(v262);
                        v341 = nw_endpoint_get_logging_description(v340);
                        v342 = nw_endpoint_handler_state_string(v262);
                        v343 = nw_endpoint_handler_mode_string(v262);
                        v344 = nw_endpoint_handler_copy_current_path(v262);
                        *(_DWORD *)buf = 136447746;
                        v385 = "nw_endpoint_flow_receive_report";
                        v386 = 2082;
                        v387 = (char *)v338;
                        v388 = 2082;
                        v389 = v339;
                        v390 = 2082;
                        v391 = (void *)v341;
                        v392 = 2082;
                        v393 = (void *)v342;
                        v394 = 2082;
                        v395 = (void *)v343;
                        v396 = 2114;
                        v397 = v344;
                        _os_log_impl(&dword_182FBE000, v266, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connected child failed when a better path is available", buf, 0x48u);

                      }
                    }
                    else
                    {
                      if ((logging_disabled & 1) != 0)
                      {
LABEL_356:
                        nw_endpoint_handler_handle_failure(v262);
                        goto LABEL_342;
                      }
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v266 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v266, OS_LOG_TYPE_INFO))
                      {
                        v267 = nw_endpoint_handler_get_id_string(v262);
                        v268 = nw_endpoint_handler_dry_run_string(v262);
                        v269 = nw_endpoint_handler_copy_endpoint(v262);
                        v270 = nw_endpoint_get_logging_description(v269);
                        v271 = nw_endpoint_handler_state_string(v262);
                        v272 = nw_endpoint_handler_mode_string(v262);
                        v273 = nw_endpoint_handler_copy_current_path(v262);
                        *(_DWORD *)buf = 136447746;
                        v385 = "nw_endpoint_flow_receive_report";
                        v386 = 2082;
                        v387 = (char *)v267;
                        v388 = 2082;
                        v389 = v268;
                        v390 = 2082;
                        v391 = (void *)v270;
                        v392 = 2082;
                        v393 = (void *)v271;
                        v394 = 2082;
                        v395 = (void *)v272;
                        v396 = 2114;
                        v397 = v273;
                        _os_log_impl(&dword_182FBE000, v266, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connected child failed when a better path is available", buf, 0x48u);

                      }
                    }

                    goto LABEL_356;
                  }
                  v16 = v366;
                  if ((*((_BYTE *)v362 + 33) & 4) == 0)
                  {
                    v274 = v262;
                    v275 = v262->state;

                    if (v275 == 5)
                      goto LABEL_342;
                    v276 = nw_endpoint_handler_get_minimize_logging(v274);
                    v277 = nw_endpoint_handler_get_logging_disabled(v274);
                    v278 = v362;
                    if (v276)
                    {
                      if ((v277 & 1) != 0)
                        goto LABEL_370;
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v279 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v279, OS_LOG_TYPE_DEBUG))
                      {
                        v331 = nw_endpoint_handler_get_id_string(v274);
                        v332 = nw_endpoint_handler_dry_run_string(v274);
                        v333 = nw_endpoint_handler_copy_endpoint(v274);
                        v334 = nw_endpoint_get_logging_description(v333);
                        v335 = nw_endpoint_handler_state_string(v274);
                        v336 = nw_endpoint_handler_mode_string(v274);
                        v337 = nw_endpoint_handler_copy_current_path(v274);
                        *(_DWORD *)buf = 136447746;
                        v385 = "nw_endpoint_flow_receive_report";
                        v386 = 2082;
                        v387 = (char *)v331;
                        v388 = 2082;
                        v389 = v332;
                        v390 = 2082;
                        v391 = (void *)v334;
                        v392 = 2082;
                        v393 = (void *)v335;
                        v394 = 2082;
                        v395 = (void *)v336;
                        v396 = 2114;
                        v397 = v337;
                        _os_log_impl(&dword_182FBE000, v279, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed", buf, 0x48u);

                      }
                    }
                    else
                    {
                      if ((v277 & 1) != 0)
                      {
LABEL_370:
                        if ((*((_BYTE *)v278 + 33) & 8) == 0)
                          nw_endpoint_handler_handle_failure(v274);
                        v274->event = (nw_endpoint_handler_event_s)720899;
                        nw_endpoint_handler_report(v274, 0, &v274->event.domain, 0);
                        goto LABEL_342;
                      }
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v279 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v279, OS_LOG_TYPE_INFO))
                      {
                        v280 = nw_endpoint_handler_get_id_string(v274);
                        v281 = nw_endpoint_handler_dry_run_string(v274);
                        v282 = nw_endpoint_handler_copy_endpoint(v274);
                        v283 = nw_endpoint_get_logging_description(v282);
                        v284 = nw_endpoint_handler_state_string(v274);
                        v285 = nw_endpoint_handler_mode_string(v274);
                        v286 = nw_endpoint_handler_copy_current_path(v274);
                        *(_DWORD *)buf = 136447746;
                        v385 = "nw_endpoint_flow_receive_report";
                        v386 = 2082;
                        v387 = (char *)v280;
                        v388 = 2082;
                        v389 = v281;
                        v390 = 2082;
                        v391 = (void *)v283;
                        v392 = 2082;
                        v393 = (void *)v284;
                        v394 = 2082;
                        v395 = (void *)v285;
                        v396 = 2114;
                        v397 = v286;
                        _os_log_impl(&dword_182FBE000, v279, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed", buf, 0x48u);

                      }
                    }

                    v278 = v362;
                    goto LABEL_370;
                  }
                }
                else if ((*((_BYTE *)v47 + 33) & 4) == 0 || v355 <= 3 && (*((_BYTE *)v47 + 32) & 0x20) != 0)
                {
                  goto LABEL_342;
                }
                v287 = v16;
                v288 = v287[30];

                if (v288 != 5)
                {
                  v289 = v287;
                  v287[30] = v355;

                  nw_endpoint_handler_report(v289, 0, v356, 0);
                }
                goto LABEL_342;
              }
LABEL_340:
              nw_endpoint_flow_setup_protocols((NWConcrete_nw_endpoint_handler *)v16, 0, 0, 1, 0);
              goto LABEL_341;
            }
            v88 = v16;
            v89 = (v16[67] & 0x20) == 0;

            if (v89)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v90 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
              {
                v91 = v88;

                v92 = v91;
                v93 = (v366[67] & 1) == 0;

                if (v93)
                  v94 = "";
                else
                  v94 = "dry-run ";
                v95 = nw_endpoint_handler_copy_endpoint(v92);
                v96 = nw_endpoint_get_logging_description(v95);
                v97 = v92;
                v98 = v97;
                v99 = v97[30];
                if (v99 > 5)
                  v100 = "unknown-state";
                else
                  v100 = off_1E149FC48[v99];

                v120 = v98;
                v121 = "path";
                switch(v357[29])
                {
                  case 0u:
                    break;
                  case 1u:
                    v121 = "resolver";
                    break;
                  case 2u:
                    v121 = nw_endpoint_flow_mode_string(v120[31]);
                    break;
                  case 3u:
                    v121 = "proxy";
                    break;
                  case 4u:
                    v121 = "fallback";
                    break;
                  case 5u:
                    v121 = "transform";
                    break;
                  default:
                    v121 = "unknown-mode";
                    break;
                }
                v352 = (os_log_t)v121;

                v184 = v95;
                v185 = v100;
                v186 = v96;
                v187 = v94;
                v188 = v120;
                os_unfair_lock_lock((os_unfair_lock_t)v188 + 28);
                v189 = v188[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v188 + 28);

                *(_DWORD *)buf = 136447746;
                v385 = "nw_endpoint_flow_receive_report";
                v386 = 2082;
                v387 = v91 + 168;
                v388 = 2082;
                v389 = v187;
                v390 = 2082;
                v391 = (void *)v186;
                v392 = 2082;
                v393 = (void *)v185;
                v394 = 2082;
                v395 = v352;
                v396 = 2114;
                v397 = v189;
                _os_log_impl(&dword_182FBE000, v90, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] adding candidate child protocol", buf, 0x48u);

              }
            }
            v190 = nw_endpoint_handler_copy_flow(v360);
            v131 = v190;
            if (v190)
            {
              if ((nw_flow_replay_add_candidate_output_handler(v88, (uint64_t)v362 + 376, (uint64_t)v190 + 376) & 1) == 0)
              {
                v191 = v88;
                v192 = (v366[67] & 0x20) == 0;

                if (v192)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v193 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v193, OS_LOG_TYPE_ERROR))
                  {
                    v194 = v191;

                    v195 = v194;
                    v196 = (v366[67] & 1) == 0;

                    if (v196)
                      v197 = "";
                    else
                      v197 = "dry-run ";
                    v198 = nw_endpoint_handler_copy_endpoint(v195);
                    v199 = nw_endpoint_get_logging_description(v198);
                    v200 = v195;
                    v201 = v200;
                    v202 = v200[30];
                    if (v202 > 5)
                      v203 = "unknown-state";
                    else
                      v203 = off_1E149FC48[v202];
                    v367 = v203;

                    v204 = v201;
                    v205 = v204;
                    v206 = "path";
                    switch(v357[29])
                    {
                      case 0u:
                        break;
                      case 1u:
                        v206 = "resolver";
                        break;
                      case 2u:
                        v206 = nw_endpoint_flow_mode_string(v204[31]);
                        break;
                      case 3u:
                        v206 = "proxy";
                        break;
                      case 4u:
                        v206 = "fallback";
                        break;
                      case 5u:
                        v206 = "transform";
                        break;
                      default:
                        v206 = "unknown-mode";
                        break;
                    }

                    v232 = v205;
                    os_unfair_lock_lock((os_unfair_lock_t)v232 + 28);
                    v233 = v232[8];
                    os_unfair_lock_unlock((os_unfair_lock_t)v232 + 28);

                    *(_DWORD *)buf = 136447746;
                    v385 = "nw_endpoint_flow_receive_report";
                    v386 = 2082;
                    v387 = v194 + 168;
                    v388 = 2082;
                    v389 = v197;
                    v390 = 2082;
                    v391 = (void *)v199;
                    v392 = 2082;
                    v393 = (void *)v367;
                    v394 = 2082;
                    v395 = (void *)v206;
                    v396 = 2114;
                    v397 = v233;
                    _os_log_impl(&dword_182FBE000, v193, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach to candidate child flow", buf, 0x48u);

                  }
                  goto LABEL_326;
                }
LABEL_327:

                v30 = 0;
LABEL_343:

                goto LABEL_344;
              }

LABEL_338:
              v12 = v371;
              v47 = v362;
              v16 = v366;
LABEL_339:
              if ((v354 & 1) == 0)
                goto LABEL_341;
              goto LABEL_340;
            }
            __nwlog_obj();
            v308 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v385 = "nw_endpoint_flow_receive_report";
            v298 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v379[0] = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v298, type, v379))
              goto LABEL_465;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v299 = objc_claimAutoreleasedReturnValue();
              v309 = type[0];
              if (os_log_type_enabled(v299, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v385 = "nw_endpoint_flow_receive_report";
                _os_log_impl(&dword_182FBE000, v299, v309, "%{public}s called with null candidate_child_flow", buf, 0xCu);
              }
              goto LABEL_464;
            }
            if (v379[0] == OS_LOG_TYPE_DEFAULT)
            {
              __nwlog_obj();
              v299 = objc_claimAutoreleasedReturnValue();
              v330 = type[0];
              if (os_log_type_enabled(v299, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v385 = "nw_endpoint_flow_receive_report";
                _os_log_impl(&dword_182FBE000, v299, v330, "%{public}s called with null candidate_child_flow, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_464;
            }
            v313 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v299 = objc_claimAutoreleasedReturnValue();
            v319 = type[0];
            v320 = os_log_type_enabled(v299, type[0]);
            if (!v313)
            {
              if (v320)
              {
                *(_DWORD *)buf = 136446210;
                v385 = "nw_endpoint_flow_receive_report";
                _os_log_impl(&dword_182FBE000, v299, v319, "%{public}s called with null candidate_child_flow, no backtrace", buf, 0xCu);
              }
              goto LABEL_464;
            }
            if (v320)
            {
              *(_DWORD *)buf = 136446466;
              v385 = "nw_endpoint_flow_receive_report";
              v386 = 2082;
              v387 = v313;
              _os_log_impl(&dword_182FBE000, v299, v319, "%{public}s called with null candidate_child_flow, dumping backtrace:%{public}s", buf, 0x16u);
            }
            goto LABEL_432;
          }
LABEL_117:
          v74 = *((_QWORD *)v47 + 83) == 0;
          v75 = v16;
          v76 = *((_BYTE *)v16 + 268);

          if (!v74)
          {
            if ((v76 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v77 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
              {
                v350 = v77;
                v78 = v75;

                v79 = v78;
                v80 = (v366[67] & 1) == 0;

                if (v80)
                  v81 = "";
                else
                  v81 = "dry-run ";
                v82 = nw_endpoint_handler_copy_endpoint(v79);
                v83 = nw_endpoint_get_logging_description(v82);
                v84 = v79;
                v85 = v84;
                v86 = v84[30];
                if (v86 > 5)
                  v87 = "unknown-state";
                else
                  v87 = off_1E149FC48[v86];

                v114 = v85;
                v115 = v114;
                v116 = "path";
                switch(v357[29])
                {
                  case 0u:
                    break;
                  case 1u:
                    v116 = "resolver";
                    break;
                  case 2u:
                    v116 = nw_endpoint_flow_mode_string(v114[31]);
                    break;
                  case 3u:
                    v116 = "proxy";
                    break;
                  case 4u:
                    v116 = "fallback";
                    break;
                  case 5u:
                    v116 = "transform";
                    break;
                  default:
                    v116 = "unknown-mode";
                    break;
                }

                v124 = v82;
                v125 = v87;
                v126 = v83;
                v127 = v81;
                v128 = v75;
                v129 = v115;
                os_unfair_lock_lock((os_unfair_lock_t)v129 + 28);
                v130 = v129[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v129 + 28);

                v75 = v128;
                *(_DWORD *)buf = 136447746;
                v385 = "nw_endpoint_flow_receive_report";
                v386 = 2082;
                v387 = v78 + 168;
                v388 = 2082;
                v389 = v127;
                v390 = 2082;
                v391 = (void *)v126;
                v392 = 2082;
                v393 = (void *)v125;
                v394 = 2082;
                v395 = (void *)v116;
                v396 = 2114;
                v397 = v130;
                _os_log_impl(&dword_182FBE000, v350, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] selecting connected child protocol from candidates", buf, 0x48u);

                v77 = v350;
              }

            }
            v131 = nw_endpoint_handler_copy_flow(loga);
            if (v131)
            {
              v132 = v75;
              v133 = v357[29];

              if ((_DWORD)v133 == 2)
              {
                v134 = v362;
                v135 = (char *)*((_QWORD *)v362 + 83);
                if (!v135)
                {
LABEL_337:
                  *((_WORD *)v134 + 354) &= ~0x800u;
                  nw_protocol_set_output_handler((uint64_t)v134 + 472, (uint64_t)v131 + 376);

                  goto LABEL_338;
                }
                *(_QWORD *)v379 = 0;
                v380 = v379;
                v381 = 0x2020000000;
                v382 = 0;
                *(_QWORD *)type = MEMORY[0x1E0C809B0];
                v373 = 3221225472;
                v374 = __nw_flow_replay_select_output_handler_block_invoke;
                v375 = &unk_1E149C6C0;
                v376 = v379;
                v377 = (char *)v131 + 376;
                v378 = (char *)v362 + 376;
                nw_hash_table_apply(v135, (uint64_t)type);
                if (*((_BYTE *)v380 + 24))
                {
LABEL_336:
                  _Block_object_dispose(v379, 8);
                  goto LABEL_337;
                }
                if (nw_endpoint_handler_get_minimize_logging(v132))
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v132) & 1) != 0)
                    goto LABEL_335;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v138 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
                  {
                    v358 = nw_endpoint_handler_get_id_string(v132);
                    v322 = nw_endpoint_handler_dry_run_string(v132);
                    v323 = nw_endpoint_handler_copy_endpoint(v132);
                    v324 = nw_endpoint_get_logging_description(v323);
                    v325 = nw_endpoint_handler_state_string(v132);
                    v326 = nw_endpoint_handler_mode_string(v132);
                    v327 = nw_endpoint_handler_copy_current_path(v132);
                    *(_DWORD *)buf = 136447746;
                    v385 = "nw_flow_replay_select_output_handler";
                    v386 = 2082;
                    v387 = (char *)v358;
                    v388 = 2082;
                    v389 = v322;
                    v390 = 2082;
                    v391 = (void *)v324;
                    v392 = 2082;
                    v393 = (void *)v325;
                    v394 = 2082;
                    v395 = (void *)v326;
                    v396 = 2114;
                    v397 = v327;
                    _os_log_impl(&dword_182FBE000, v138, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Did not find selected output handler, adding to the candidate list", buf, 0x48u);

                  }
                }
                else
                {
                  v136 = v132;
                  v137 = (v366[67] & 0x20) == 0;

                  if (!v137)
                  {
LABEL_335:
                    v134 = v362;
                    nw_flow_replay_add_candidate_output_handler(v132, (uint64_t)v362 + 376, (uint64_t)v131 + 376);
                    goto LABEL_336;
                  }
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v138 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v138, OS_LOG_TYPE_INFO))
                  {
                    v348 = v138;
                    v139 = v136;

                    v140 = v139;
                    v141 = (v366[67] & 1) == 0;

                    if (v141)
                      v142 = "";
                    else
                      v142 = "dry-run ";
                    v143 = nw_endpoint_handler_copy_endpoint(v140);
                    v144 = nw_endpoint_get_logging_description(v143);
                    v145 = v140;
                    v146 = v145;
                    v147 = v145[30];
                    if (v147 > 5)
                      v148 = "unknown-state";
                    else
                      v148 = off_1E149FC48[v147];
                    v345 = v148;

                    v207 = v146;
                    v208 = v207;
                    v209 = "path";
                    switch(v357[29])
                    {
                      case 0u:
                        break;
                      case 1u:
                        v209 = "resolver";
                        break;
                      case 2u:
                        v209 = nw_endpoint_flow_mode_string(v207[31]);
                        break;
                      case 3u:
                        v209 = "proxy";
                        break;
                      case 4u:
                        v209 = "fallback";
                        break;
                      case 5u:
                        v209 = "transform";
                        break;
                      default:
                        v209 = "unknown-mode";
                        break;
                    }

                    v259 = v208;
                    os_unfair_lock_lock((os_unfair_lock_t)v259 + 28);
                    v260 = v259[8];
                    os_unfair_lock_unlock((os_unfair_lock_t)v259 + 28);

                    *(_DWORD *)buf = 136447746;
                    v385 = "nw_flow_replay_select_output_handler";
                    v386 = 2082;
                    v387 = v139 + 168;
                    v388 = 2082;
                    v389 = v142;
                    v390 = 2082;
                    v391 = (void *)v144;
                    v392 = 2082;
                    v393 = (void *)v345;
                    v394 = 2082;
                    v395 = (void *)v209;
                    v396 = 2114;
                    v397 = v260;
                    _os_log_impl(&dword_182FBE000, v348, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Did not find selected output handler, adding to the candidate list", buf, 0x48u);

                    v138 = v348;
                  }
                }

                goto LABEL_335;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v149 = (id)gLogObj;
              if (v133 > 5)
                v150 = "unknown-mode";
              else
                v150 = off_1E149FC18[v133];
              *(_DWORD *)buf = 136446722;
              v385 = "nw_flow_replay_select_output_handler";
              v386 = 2082;
              v387 = (char *)v150;
              v388 = 2082;
              v389 = "flow";
              v151 = (void *)_os_log_send_and_compose_impl();

              v379[0] = OS_LOG_TYPE_ERROR;
              v383 = 0;
              if (__nwlog_fault((const char *)v151, v379, &v383))
              {
                if (v379[0] == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v152 = (id)gLogObj;
                  v153 = v379[0];
                  if (os_log_type_enabled(v152, v379[0]))
                  {
                    if (v133 > 5)
                      v154 = "unknown-mode";
                    else
                      v154 = off_1E149FC18[v133];
                    *(_DWORD *)buf = 136446722;
                    v385 = "nw_flow_replay_select_output_handler";
                    v386 = 2082;
                    v387 = (char *)v154;
                    v388 = 2082;
                    v389 = "flow";
                    _os_log_impl(&dword_182FBE000, v152, v153, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
                  }
                }
                else if (v383)
                {
                  v155 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v152 = (id)gLogObj;
                  v156 = v379[0];
                  v157 = os_log_type_enabled(v152, v379[0]);
                  if (v155)
                  {
                    if (v157)
                    {
                      if (v133 > 5)
                        v158 = "unknown-mode";
                      else
                        v158 = off_1E149FC18[v133];
                      *(_DWORD *)buf = 136446978;
                      v385 = "nw_flow_replay_select_output_handler";
                      v386 = 2082;
                      v387 = (char *)v158;
                      v388 = 2082;
                      v389 = "flow";
                      v390 = 2082;
                      v391 = v155;
                      _os_log_impl(&dword_182FBE000, v152, v156, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
                    }

                    free(v155);
                    if (!v151)
                    {
LABEL_308:

                      v234 = v132;
                      v235 = (v366[67] & 0x20) == 0;

                      if (v235)
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v193 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v193, OS_LOG_TYPE_ERROR))
                        {
                          v236 = v234;

                          v237 = v236;
                          v238 = (v366[67] & 1) == 0;

                          if (v238)
                            v239 = "";
                          else
                            v239 = "dry-run ";
                          v240 = nw_endpoint_handler_copy_endpoint(v237);
                          v241 = nw_endpoint_get_logging_description(v240);
                          v242 = v237;
                          v243 = v242;
                          v244 = v242[30];
                          if (v244 > 5)
                            v245 = "unknown-state";
                          else
                            v245 = off_1E149FC48[v244];

                          v246 = v243;
                          v247 = "path";
                          switch(v357[29])
                          {
                            case 0u:
                              break;
                            case 1u:
                              v247 = "resolver";
                              break;
                            case 2u:
                              v247 = nw_endpoint_flow_mode_string(v246[31]);
                              break;
                            case 3u:
                              v247 = "proxy";
                              break;
                            case 4u:
                              v247 = "fallback";
                              break;
                            case 5u:
                              v247 = "transform";
                              break;
                            default:
                              v247 = "unknown-mode";
                              break;
                          }
                          v369 = v247;

                          v248 = v236;
                          v249 = v193;
                          v250 = v131;
                          v251 = v240;
                          v252 = v245;
                          v253 = v241;
                          v254 = v239;
                          v255 = v246;
                          os_unfair_lock_lock((os_unfair_lock_t)v255 + 28);
                          v256 = v255[8];
                          os_unfair_lock_unlock((os_unfair_lock_t)v255 + 28);

                          v257 = v254;
                          v258 = v251;
                          v131 = v250;
                          v193 = v249;
                          *(_DWORD *)buf = 136447746;
                          v385 = "nw_endpoint_flow_receive_report";
                          v386 = 2082;
                          v387 = v248 + 168;
                          v388 = 2082;
                          v389 = v257;
                          v390 = 2082;
                          v391 = (void *)v253;
                          v392 = 2082;
                          v393 = (void *)v252;
                          v394 = 2082;
                          v395 = (void *)v369;
                          v396 = 2114;
                          v397 = v256;
                          _os_log_impl(&dword_182FBE000, v249, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to select the connected candidate child flow", buf, 0x48u);

                        }
LABEL_326:

                        goto LABEL_327;
                      }
                      goto LABEL_327;
                    }
LABEL_307:
                    free(v151);
                    goto LABEL_308;
                  }
                  if (v157)
                  {
                    if (v133 > 5)
                      v161 = "unknown-mode";
                    else
                      v161 = off_1E149FC18[v133];
                    *(_DWORD *)buf = 136446722;
                    v385 = "nw_flow_replay_select_output_handler";
                    v386 = 2082;
                    v387 = (char *)v161;
                    v388 = 2082;
                    v389 = "flow";
                    _os_log_impl(&dword_182FBE000, v152, v156, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
                  }
                }
                else
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v152 = (id)gLogObj;
                  v159 = v379[0];
                  if (os_log_type_enabled(v152, v379[0]))
                  {
                    if (v133 > 5)
                      v160 = "unknown-mode";
                    else
                      v160 = off_1E149FC18[v133];
                    *(_DWORD *)buf = 136446722;
                    v385 = "nw_flow_replay_select_output_handler";
                    v386 = 2082;
                    v387 = (char *)v160;
                    v388 = 2082;
                    v389 = "flow";
                    _os_log_impl(&dword_182FBE000, v152, v159, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
                  }
                }

              }
              if (!v151)
                goto LABEL_308;
              goto LABEL_307;
            }
            __nwlog_obj();
            v297 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v385 = "nw_endpoint_flow_receive_report";
            v298 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v379[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v298, type, v379))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v299 = objc_claimAutoreleasedReturnValue();
                v300 = type[0];
                if (os_log_type_enabled(v299, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_endpoint_flow_receive_report";
                  _os_log_impl(&dword_182FBE000, v299, v300, "%{public}s called with null child_flow", buf, 0xCu);
                }
LABEL_464:

                goto LABEL_465;
              }
              if (v379[0] == OS_LOG_TYPE_DEFAULT)
              {
                __nwlog_obj();
                v299 = objc_claimAutoreleasedReturnValue();
                v321 = type[0];
                if (os_log_type_enabled(v299, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_endpoint_flow_receive_report";
                  _os_log_impl(&dword_182FBE000, v299, v321, "%{public}s called with null child_flow, backtrace limit exceeded", buf, 0xCu);
                }
                goto LABEL_464;
              }
              v310 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v299 = objc_claimAutoreleasedReturnValue();
              v311 = type[0];
              v312 = os_log_type_enabled(v299, type[0]);
              if (!v310)
              {
                if (v312)
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_endpoint_flow_receive_report";
                  _os_log_impl(&dword_182FBE000, v299, v311, "%{public}s called with null child_flow, no backtrace", buf, 0xCu);
                }
                goto LABEL_464;
              }
              if (v312)
              {
                *(_DWORD *)buf = 136446466;
                v385 = "nw_endpoint_flow_receive_report";
                v386 = 2082;
                v387 = v310;
                _os_log_impl(&dword_182FBE000, v299, v311, "%{public}s called with null child_flow, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v310);
            }
LABEL_465:
            if (!v298)
            {
LABEL_467:
              v131 = 0;
              goto LABEL_327;
            }
LABEL_466:
            free(v298);
            goto LABEL_467;
          }
          v101 = v362;
          v102 = v366;
          if ((v76 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v103 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
            {
              v351 = v103;
              v104 = v75;

              v105 = v104;
              v106 = (v366[67] & 1) == 0;

              if (v106)
                v107 = "";
              else
                v107 = "dry-run ";
              v108 = nw_endpoint_handler_copy_endpoint(v105);
              v109 = nw_endpoint_get_logging_description(v108);
              v110 = v105;
              v111 = v110;
              v112 = v110[30];
              if (v112 > 5)
                v113 = "unknown-state";
              else
                v113 = off_1E149FC48[v112];

              v117 = v111;
              v118 = v117;
              v119 = "path";
              switch(v357[29])
              {
                case 0u:
                  break;
                case 1u:
                  v119 = "resolver";
                  break;
                case 2u:
                  v119 = nw_endpoint_flow_mode_string(v117[31]);
                  break;
                case 3u:
                  v119 = "proxy";
                  break;
                case 4u:
                  v119 = "fallback";
                  break;
                case 5u:
                  v119 = "transform";
                  break;
                default:
                  v119 = "unknown-mode";
                  break;
              }

              v162 = v108;
              v163 = v109;
              v164 = v118;
              os_unfair_lock_lock((os_unfair_lock_t)v164 + 28);
              v165 = v164[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v164 + 28);

              v166 = v104 + 168;
              v167 = v165;
              v168 = v167;
              v169 = (const char *)*((_QWORD *)v362 + 94);
              if (v169)
              {
                v169 = (const char *)*((_QWORD *)v169 + 2);
                if (!v169)
                  v169 = "invalid";
              }
              *(_DWORD *)buf = 136448002;
              v385 = "nw_endpoint_flow_receive_report";
              v386 = 2082;
              v387 = v166;
              v388 = 2082;
              v389 = v107;
              v390 = 2082;
              v391 = (void *)v163;
              v392 = 2082;
              v393 = (void *)v113;
              v394 = 2082;
              v395 = (void *)v119;
              v396 = 2114;
              v397 = v167;
              v398 = 2082;
              v399 = v169;
              _os_log_impl(&dword_182FBE000, v351, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connecting %{public}s to child's shared protocol", buf, 0x52u);

              v103 = v351;
            }

            v101 = v362;
            v102 = v366;
          }
          v170 = nw_endpoint_handler_copy_flow(loga);
          v131 = v170;
          if (v170)
          {
            v171 = *((_QWORD *)v101 + 94);
            if (v171)
            {
              v172 = (char *)v170 + 376;
              if ((NWConcrete_nw_endpoint_mode_handler *)((char *)v170 + 376) != (NWConcrete_nw_endpoint_mode_handler *)v171)
              {
                v173 = (_QWORD *)*((_QWORD *)v170 + 50);
                if (v173 && *v173)
                {
                  if ((nw_protocol_add_input_handler((uint64_t)v170 + 376, v171) & 1) != 0)
                  {
                    v174 = (void *)*((_QWORD *)v131 + 68);
                    *((_QWORD *)v131 + 68) = v131;

                    goto LABEL_338;
                  }
LABEL_267:
                  v210 = v75;
                  v211 = (v102[67] & 0x20) == 0;

                  if (v211)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v212 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
                    {
                      v213 = v210;

                      v214 = v213;
                      v215 = (v366[67] & 1) == 0;

                      if (v215)
                        v216 = "";
                      else
                        v216 = "dry-run ";
                      v217 = nw_endpoint_handler_copy_endpoint(v214);
                      v218 = nw_endpoint_get_logging_description(v217);
                      v219 = v214;
                      v220 = v219;
                      v221 = v219[30];
                      if (v221 > 5)
                        v222 = "unknown-state";
                      else
                        v222 = off_1E149FC48[v221];

                      v223 = v220;
                      v224 = v223;
                      v225 = "path";
                      switch(v357[29])
                      {
                        case 0u:
                          break;
                        case 1u:
                          v225 = "resolver";
                          break;
                        case 2u:
                          v225 = nw_endpoint_flow_mode_string(v223[31]);
                          break;
                        case 3u:
                          v225 = "proxy";
                          break;
                        case 4u:
                          v225 = "fallback";
                          break;
                        case 5u:
                          v225 = "transform";
                          break;
                        default:
                          v225 = "unknown-mode";
                          break;
                      }

                      v368 = v212;
                      v226 = v224;
                      os_unfair_lock_lock((os_unfair_lock_t)v226 + 28);
                      v227 = v226[8];
                      os_unfair_lock_unlock((os_unfair_lock_t)v226 + 28);

                      v228 = v213 + 168;
                      v229 = v227;
                      v230 = v229;
                      v231 = (const char *)*((_QWORD *)v362 + 94);
                      if (v231)
                      {
                        v231 = (const char *)*((_QWORD *)v231 + 2);
                        if (!v231)
                          v231 = "invalid";
                      }
                      *(_DWORD *)buf = 136448002;
                      v385 = "nw_endpoint_flow_receive_report";
                      v386 = 2082;
                      v387 = v228;
                      v388 = 2082;
                      v389 = v216;
                      v390 = 2082;
                      v391 = (void *)v218;
                      v392 = 2082;
                      v393 = (void *)v222;
                      v394 = 2082;
                      v395 = (void *)v225;
                      v396 = 2114;
                      v397 = v229;
                      v398 = 2082;
                      v399 = v231;
                      v212 = v368;
                      _os_log_impl(&dword_182FBE000, v368, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach protocol %{public}s to newly connected child flow", buf, 0x52u);

                    }
                  }
                  goto LABEL_327;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v179 = (id)gLogObj;
                if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446466;
                  v385 = "nw_protocol_utilities_add_input_handler";
                  v386 = 2048;
                  v387 = v172;
                  _os_log_impl(&dword_182FBE000, v179, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
                }

LABEL_228:
                v102 = v366;
                goto LABEL_267;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v175 = (id)gLogObj;
              *(_DWORD *)buf = 136446466;
              v385 = "nw_protocol_utilities_add_input_handler";
              v386 = 2048;
              v387 = v172;
              v176 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              v379[0] = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v176, type, v379))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v177 = (id)gLogObj;
                  v178 = type[0];
                  if (os_log_type_enabled(v177, type[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v385 = "nw_protocol_utilities_add_input_handler";
                    v386 = 2048;
                    v387 = v172;
                    _os_log_impl(&dword_182FBE000, v177, v178, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
                  }
                }
                else if (v379[0])
                {
                  v180 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v177 = objc_claimAutoreleasedReturnValue();
                  v181 = type[0];
                  v182 = os_log_type_enabled(v177, type[0]);
                  if (v180)
                  {
                    if (v182)
                    {
                      *(_DWORD *)buf = 136446722;
                      v385 = "nw_protocol_utilities_add_input_handler";
                      v386 = 2048;
                      v387 = v172;
                      v388 = 2082;
                      v389 = v180;
                      _os_log_impl(&dword_182FBE000, v177, v181, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                    }

                    free(v180);
                    goto LABEL_265;
                  }
                  if (v182)
                  {
                    *(_DWORD *)buf = 136446466;
                    v385 = "nw_protocol_utilities_add_input_handler";
                    v386 = 2048;
                    v387 = v172;
                    _os_log_impl(&dword_182FBE000, v177, v181, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
                  }
                }
                else
                {
                  __nwlog_obj();
                  v177 = objc_claimAutoreleasedReturnValue();
                  v183 = type[0];
                  if (os_log_type_enabled(v177, type[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v385 = "nw_protocol_utilities_add_input_handler";
                    v386 = 2048;
                    v387 = v172;
                    _os_log_impl(&dword_182FBE000, v177, v183, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
                  }
                }

              }
LABEL_265:
              v102 = v366;
              if (v176)
                free(v176);
              goto LABEL_267;
            }
            __nwlog_obj();
            v304 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v385 = "nw_protocol_utilities_add_input_handler";
            v305 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v379[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v305, type, v379))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v306 = objc_claimAutoreleasedReturnValue();
                v307 = type[0];
                if (os_log_type_enabled(v306, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl(&dword_182FBE000, v306, v307, "%{public}s called with null input_protocol", buf, 0xCu);
                }
              }
              else if (v379[0])
              {
                v316 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v306 = objc_claimAutoreleasedReturnValue();
                v317 = type[0];
                v318 = os_log_type_enabled(v306, type[0]);
                if (v316)
                {
                  if (v318)
                  {
                    *(_DWORD *)buf = 136446466;
                    v385 = "nw_protocol_utilities_add_input_handler";
                    v386 = 2082;
                    v387 = v316;
                    _os_log_impl(&dword_182FBE000, v306, v317, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v316);
                  goto LABEL_460;
                }
                if (v318)
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl(&dword_182FBE000, v306, v317, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                __nwlog_obj();
                v306 = objc_claimAutoreleasedReturnValue();
                v329 = type[0];
                if (os_log_type_enabled(v306, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v385 = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl(&dword_182FBE000, v306, v329, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
                }
              }

            }
LABEL_460:
            if (v305)
              free(v305);
            goto LABEL_228;
          }
          __nwlog_obj();
          v302 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v385 = "nw_endpoint_flow_receive_report";
          v298 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v379[0] = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v298, type, v379))
            goto LABEL_465;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v299 = objc_claimAutoreleasedReturnValue();
            v303 = type[0];
            if (os_log_type_enabled(v299, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              v385 = "nw_endpoint_flow_receive_report";
              _os_log_impl(&dword_182FBE000, v299, v303, "%{public}s called with null child_flow", buf, 0xCu);
            }
            goto LABEL_464;
          }
          if (v379[0] == OS_LOG_TYPE_DEFAULT)
          {
            __nwlog_obj();
            v299 = objc_claimAutoreleasedReturnValue();
            v328 = type[0];
            if (os_log_type_enabled(v299, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              v385 = "nw_endpoint_flow_receive_report";
              _os_log_impl(&dword_182FBE000, v299, v328, "%{public}s called with null child_flow, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_464;
          }
          v313 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v299 = objc_claimAutoreleasedReturnValue();
          v314 = type[0];
          v315 = os_log_type_enabled(v299, type[0]);
          if (!v313)
          {
            if (v315)
            {
              *(_DWORD *)buf = 136446210;
              v385 = "nw_endpoint_flow_receive_report";
              _os_log_impl(&dword_182FBE000, v299, v314, "%{public}s called with null child_flow, no backtrace", buf, 0xCu);
            }
            goto LABEL_464;
          }
          if (v315)
          {
            *(_DWORD *)buf = 136446466;
            v385 = "nw_endpoint_flow_receive_report";
            v386 = 2082;
            v387 = v313;
            _os_log_impl(&dword_182FBE000, v299, v314, "%{public}s called with null child_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }
LABEL_432:

          free(v313);
          if (!v298)
            goto LABEL_467;
          goto LABEL_466;
        }
LABEL_115:
        nw_endpoint_handler_report(v16, 0, a4, 0);
        goto LABEL_116;
      }
    }
    else if (a2 != 2)
    {
      goto LABEL_113;
    }
    v360 = 0;
    v71 = *((_QWORD *)v47 + 118);
    if (!v71 || !v12)
      goto LABEL_114;
    v73 = *(id **)(v71 + 16);
    v72 = *(id **)(v71 + 24);
    if (v73 != v72)
    {
      while (*v73 != v12)
      {
        if (++v73 == v72)
        {
          v73 = v72;
          break;
        }
      }
    }
    v360 = 0;
    if (!a4 || v73 == v72)
    {
LABEL_114:
      os_unfair_lock_unlock(v48);
      if (!v61)
        goto LABEL_116;
      goto LABEL_115;
    }
    if (*a4 == 3 && a4[1] == 4)
      goto LABEL_112;
LABEL_113:
    v360 = 0;
    goto LABEL_114;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v28 = (id)gLogObj;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    if (v15 > 5)
      v29 = "unknown-mode";
    else
      v29 = off_1E149FC18[v15];
    *(_DWORD *)buf = 136446722;
    v385 = "nw_endpoint_flow_receive_report";
    v386 = 2082;
    v387 = (char *)v29;
    v388 = 2082;
    v389 = "flow";
    _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_18:
  v30 = 0;
LABEL_344:

  return v30;
}

void sub_183033618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,void *a25,void *a26,void *a27,uint64_t a28,uint64_t a29,void *a30)
{
  void *v30;
  void *v31;

  _Unwind_Resume(a1);
}

void nw_endpoint_handler_report(void *a1, void *a2, _WORD *a3, void *a4)
{
  unsigned int *v7;
  id v8;
  NWConcrete_nw_endpoint_handler *v9;
  NWConcrete_nw_endpoint_handler *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t fallback_timer;
  id WeakRetained;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int *v17;

  v17 = a1;
  v7 = a2;
  v8 = a4;
  if (v17[30] != 5)
  {
    v9 = v17;
    v10 = v9;
    if (a3)
    {
      if ((*((_BYTE *)v9 + 268) & 0x10) == 0 && *a3 == 3)
      {
        v11 = (unsigned __int16)a3[1];
        if (v11 <= 0xD && ((1 << v11) & 0x2060) != 0)
          *((_BYTE *)v9 + 268) |= 0x10u;
      }
    }
    if (v9->fallback_timer)
    {
      if (!nw_endpoint_handler_should_reset_for_fallback(v9))
      {
        fallback_timer = (uint64_t)v10->fallback_timer;
        if (fallback_timer)
        {
          nw_queue_cancel_source(fallback_timer, v12);
          v10->fallback_timer = 0;
        }
      }
    }

    WeakRetained = objc_loadWeakRetained((id *)&v10->callback_context);
    v15 = v7 + 30;
    if (v7)
    {
      v16 = v7;
    }
    else
    {
      v15 = v17 + 30;
      v16 = (unsigned int *)v10;
    }
    ((void (*)(unsigned int *, _QWORD, _QWORD, _WORD *, id, id))v10->report_callback)(v16, v16[29], *v15, a3, v8, WeakRetained);

  }
}

void sub_183033A04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_endpoint_flow_reinitialize_protocol_for_handling_requests(void *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  unsigned int mode;
  NWConcrete_nw_endpoint_mode_handler *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  id v13;
  const char *v14;
  void *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  const char *v22;
  os_log_type_t v23;
  const char *v24;
  const char *v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  void *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_endpoint_handler_get_mode";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v6, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_endpoint_handler_get_mode";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_22:
    if (v6)
      free(v6);
    mode = 0;
    goto LABEL_25;
  }
  mode = v1->mode;

  if (mode == 2)
  {
    v4 = nw_endpoint_handler_copy_flow(v2);
    if ((*((_BYTE *)v4 + 32) & 8) != 0)
    {
      *((_QWORD *)v4 + 19) = nw_flow_input_available;
      *((_QWORD *)v4 + 20) = nw_flow_output_available;
      *((_QWORD *)v4 + 31) = nw_flow_notify;
      *((_QWORD *)v4 + 33) = nw_flow_supports_external_data;
      *((_QWORD *)v4 + 34) = nw_flow_input_finished;
    }

    goto LABEL_46;
  }
LABEL_25:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = (id)gLogObj;
  if (mode > 5)
    v14 = "unknown-mode";
  else
    v14 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
  v30 = 2082;
  v31 = (void *)v14;
  v32 = 2082;
  v33 = "flow";
  v15 = (void *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (!__nwlog_fault((const char *)v15, &type, &v26))
  {
LABEL_44:
    if (!v15)
      goto LABEL_46;
LABEL_45:
    free(v15);
    goto LABEL_46;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    v17 = type;
    if (os_log_type_enabled(v16, type))
    {
      if (mode > 5)
        v18 = "unknown-mode";
      else
        v18 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
      v30 = 2082;
      v31 = (void *)v18;
      v32 = 2082;
      v33 = "flow";
      _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_43:

    goto LABEL_44;
  }
  if (!v26)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    v23 = type;
    if (os_log_type_enabled(v16, type))
    {
      if (mode > 5)
        v24 = "unknown-mode";
      else
        v24 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
      v30 = 2082;
      v31 = (void *)v24;
      v32 = 2082;
      v33 = "flow";
      _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_43;
  }
  v19 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = (id)gLogObj;
  v20 = type;
  v21 = os_log_type_enabled(v16, type);
  if (!v19)
  {
    if (v21)
    {
      if (mode > 5)
        v25 = "unknown-mode";
      else
        v25 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
      v30 = 2082;
      v31 = (void *)v25;
      v32 = 2082;
      v33 = "flow";
      _os_log_impl(&dword_182FBE000, v16, v20, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_43;
  }
  if (v21)
  {
    if (mode > 5)
      v22 = "unknown-mode";
    else
      v22 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
    v30 = 2082;
    v31 = (void *)v22;
    v32 = 2082;
    v33 = "flow";
    v34 = 2082;
    v35 = v19;
    _os_log_impl(&dword_182FBE000, v16, v20, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v19);
  if (v15)
    goto LABEL_45;
LABEL_46:

}

void sub_18303407C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_has_better_path(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_handler *v4;
  unsigned int v5;
  uint64_t v6;
  NWConcrete_nw_endpoint_handler *v7;
  NWConcrete_nw_endpoint_handler *parent_handler;
  NWConcrete_nw_endpoint_handler *v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_endpoint_handler_get_has_better_path";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_endpoint_handler_get_has_better_path";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v12)
      free(v12);
    v6 = 0;
    goto LABEL_9;
  }
  v5 = *((unsigned __int8 *)v3 + 268);
  v6 = (v5 >> 3) & 1;
  if ((v5 & 8) != 0 && a2)
  {
    v7 = v3;
    while (1)
    {
      parent_handler = v7->parent_handler;
      if (!parent_handler)
        break;
      v9 = parent_handler;

      v7 = v9;
      if ((*((_BYTE *)v9 + 268) & 8) == 0)
      {

        v6 = 0;
        goto LABEL_9;
      }
    }

    v6 = 1;
  }
LABEL_9:

  return v6;
}

BOOL nw_connection_uses_multipath(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v19 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_uses_multipath_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_uses_multipath_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_uses_multipath";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_uses_multipath";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_uses_multipath_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = nw_endpoint_handler_uses_multipath(*(void **)(v2 + 144));
  }
  else
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        v6 = 136446466;
        v7 = "nw_connection_uses_multipath_block_invoke";
        v8 = 1024;
        v9 = v5;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s [C%u]  has no connected handler", (uint8_t *)&v6, 0x12u);
      }

    }
  }
}

BOOL nw_endpoint_handler_uses_multipath(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _QWORD *v3;
  _QWORD *v4;
  id v5;
  void *v6;
  id *v7;
  id v8;
  uint64_t v9;
  _BOOL8 v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(void);
  uint64_t v15;
  void **v16;
  NSObject *v17;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  char *backtrace_string;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  os_log_type_t v34;
  NSObject *v35;
  os_log_type_t type[8];
  os_log_type_t *v37;
  uint64_t v38;
  char v39;
  char v40;
  _BYTE buf[24];
  void *v42;
  os_log_type_t *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    if (v2[29]._os_unfair_lock_opaque != 2)
    {
      v10 = 0;
LABEL_30:
      os_unfair_lock_unlock(v2 + 28);
      goto LABEL_31;
    }
    v3 = *(id *)&v2[62]._os_unfair_lock_opaque;
    v4 = v3;
    if (v3)
    {
      *(_QWORD *)type = 0;
      v37 = type;
      v38 = 0x2020000000;
      v39 = 0;
      if (!nw_endpoint_flow_is_multipath(v3))
      {
LABEL_28:
        v10 = *((_BYTE *)v37 + 24) != 0;
        _Block_object_dispose(type, 8);
LABEL_29:

        goto LABEL_30;
      }
      v5 = nw_endpoint_flow_copy_connected_socket_wrapper(v4);
      v6 = (void *)v4[117];
      if (v6)
      {
        v7 = v6;
        v8 = v7[4];

        if (v8 && nw_parameters_get_upper_transport_protocol(v8) == 253)
          goto LABEL_16;
        v9 = v4[90];
        if (!v9)
          goto LABEL_14;
      }
      else
      {
        v8 = 0;
        v9 = v4[90];
        if (!v9)
          goto LABEL_14;
      }
      v11 = *(const char **)(v9 + 16);
      if (!v11 || strcmp(v11, "quic"))
      {
LABEL_14:
        if (v5)
        {
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = __nw_endpoint_flow_uses_multipath_block_invoke;
          v42 = &unk_1E14AB578;
          v43 = type;
          nw_fd_wrapper_get_fd(v5, buf);
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = (id)gLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_uses_multipath";
            _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s Protocol not supported", buf, 0xCu);
          }

        }
LABEL_27:

        goto LABEL_28;
      }
LABEL_16:
      if (gLogDatapath)
      {
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s Querying QUIC for migration status", buf, 0xCu);
        }

      }
      v12 = v4[51];
      if (v12)
      {
        v13 = *(_QWORD *)(v12 + 24);
        if (v13)
        {
          v14 = *(uint64_t (**)(void))(v13 + 224);
          if (v14)
          {
            v15 = v14();
            v16 = (void **)v15;
            if (v15)
            {
              *((_BYTE *)v37 + 24) = (*(_BYTE *)(v15 + 12) & 2) != 0;
              nw_array_remove_all_objects(*(_QWORD *)v15);
              if (*v16)
                os_release(*v16);
              free(v16);
            }
          }
        }
      }
      goto LABEL_27;
    }
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_uses_multipath";
    v24 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v24, type, &v40))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v26 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v31 = type[0];
        v32 = os_log_type_enabled(v25, type[0]);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_uses_multipath";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v25, v31, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_70;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_182FBE000, v25, v31, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v34 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_182FBE000, v25, v34, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_70:
    if (v24)
      free(v24);
    v10 = 0;
    goto LABEL_29;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_endpoint_handler_uses_multipath";
  v20 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (__nwlog_fault(v20, type, &v40))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v40)
    {
      v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v28 = type[0];
      v29 = os_log_type_enabled(v21, type[0]);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_uses_multipath";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v27;
          _os_log_impl(&dword_182FBE000, v21, v28, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v27);
        goto LABEL_58;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_182FBE000, v21, v28, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v33 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_182FBE000, v21, v33, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_58:
  if (v20)
    free(v20);
  v10 = 0;
LABEL_31:

  return v10;
}

void sub_183034ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a6);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_is_multipath(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_mode_handler *v4;
  uint64_t is_multipath;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 220);
    if ((v2[8]._os_unfair_lock_opaque & 2) != 0)
    {
      is_multipath = (v2[8]._os_unfair_lock_opaque & 0x8000) != 0;
    }
    else
    {
      v3 = *(NWConcrete_nw_endpoint_handler **)&v2[234]._os_unfair_lock_opaque;
      if (v3)
      {
        v4 = nw_endpoint_handler_copy_flow(v3);
        is_multipath = nw_endpoint_flow_is_multipath();

      }
      else
      {
        is_multipath = 0;
      }
    }
    os_unfair_lock_unlock(v2 + 220);
    goto LABEL_8;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_endpoint_flow_is_multipath";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_endpoint_flow_is_multipath";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_25:
  if (v8)
    free(v8);
  is_multipath = 0;
LABEL_8:

  return is_multipath;
}

void sub_1830351E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t NWPath.isConstrained.getter()
{
  return sub_183062514((uint64_t (*)(void))nw_path_is_constrained);
}

void nw_protocol_instance_add_inbound(void *a1, uint64_t a2, void *a3, void *a4, int a5, int a6)
{
  char *v11;
  _BYTE *v12;
  NSObject *v13;
  void *v14;
  dispatch_queue_t *v15;
  dispatch_queue_t *v16;
  uint64_t node;
  int v18;
  int v19;
  _QWORD *v20;
  __int16 v21;
  _QWORD *v22;
  uint64_t v23;
  void (*v24)(_QWORD *, char *);
  void *v25;
  char v26;
  int v27;
  int v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  void (*v32)(void);
  void *v33;
  char v34;
  NSObject *v35;
  uint64_t v36;
  void *v37;
  char v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  void (*v42)(void);
  void *v43;
  char v44;
  uint64_t v45;
  void *v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(_QWORD *, char *);
  void *v51;
  char v52;
  uint64_t v53;
  void *v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  char v59;
  uint64_t v60;
  void *v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  void *v65;
  os_log_type_t v66;
  char *backtrace_string;
  os_log_type_t v68;
  _BOOL4 v69;
  void *v70;
  os_log_type_t v71;
  char *v72;
  os_log_type_t v73;
  _BOOL4 v74;
  os_log_type_t v75;
  _BOOL4 v76;
  os_log_type_t v77;
  os_log_type_t v78;
  os_log_type_t v79;
  char v80;
  os_log_type_t type[8];
  char v82;
  _BYTE buf[12];
  __int16 v84;
  char *v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  uint64_t v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = a3;
  v13 = a4;
  if (!v11)
  {
    __nwlog_obj();
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
    v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (!__nwlog_fault(v62, type, &v80))
      goto LABEL_150;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v63 = objc_claimAutoreleasedReturnValue();
      v64 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v80)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v63 = objc_claimAutoreleasedReturnValue();
      v68 = type[0];
      v69 = os_log_type_enabled(v63, type[0]);
      if (backtrace_string)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
          v84 = 2082;
          v85 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v63, v68, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_150:
        if (!v62)
          goto LABEL_100;
LABEL_151:
        free(v62);
        goto LABEL_100;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v68, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v63 = objc_claimAutoreleasedReturnValue();
      v77 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v77, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_149:

    goto LABEL_150;
  }
  if (!v12)
  {
    __nwlog_obj();
    v65 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
    v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (!__nwlog_fault(v62, type, &v80))
      goto LABEL_150;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v63 = objc_claimAutoreleasedReturnValue();
      v66 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v66, "%{public}s called with null data", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (!v80)
    {
      __nwlog_obj();
      v63 = objc_claimAutoreleasedReturnValue();
      v78 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v78, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_149;
    }
    v72 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v63 = objc_claimAutoreleasedReturnValue();
    v73 = type[0];
    v74 = os_log_type_enabled(v63, type[0]);
    if (!v72)
    {
      if (v74)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v73, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (v74)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
      v84 = 2082;
      v85 = v72;
      _os_log_impl(&dword_182FBE000, v63, v73, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_130;
  }
  v14 = (void *)*((_QWORD *)v11 + 15);
  if (v14)
  {
    v15 = v14;
    v16 = v15;
    if (((_BYTE)v15[17] & 8) == 0)
      dispatch_assert_queue_V2(v15[1]);

  }
  if (v13)
    nw_frame_set_metadata((uint64_t)v12, v13, 1, a5);
  if (a6)
    v12[186] |= 0x80u;
  if (*(_DWORD *)(*((_QWORD *)v11 + 1) + 64) == 3)
  {
    node = nw_hash_table_get_node(*((_QWORD *)v11 + 29), a2, 8);
    if (node)
    {
      v18 = *((_DWORD *)v12 + 13);
      if (v18)
        v18 -= *((_DWORD *)v12 + 14) + *((_DWORD *)v12 + 15);
      v19 = *(_DWORD *)(node + 68) + v18;
      ++*(_DWORD *)(node + 64);
      *(_DWORD *)(node + 68) = v19;
      *((_QWORD *)v12 + 4) = 0;
      v20 = *(_QWORD **)(node + 56);
      *((_QWORD *)v12 + 5) = v20;
      *v20 = v12;
      *(_QWORD *)(node + 56) = v12 + 32;
      v21 = *(_WORD *)(node + 84);
      if ((v21 & 0x10) != 0)
      {
        if ((v11[403] & 0x10) != 0)
        {
          if (a6)
            *(_WORD *)(node + 84) = v21 | 0x40;
        }
        else
        {
          v22 = *(_QWORD **)(node + 16);
          if (v22)
          {
            v23 = v22[3];
            if (v23)
            {
              v24 = *(void (**)(_QWORD *, char *))(v23 + 64);
              if (v24)
              {
                v25 = (void *)v22[5];
                if (v25 == &nw_protocol_ref_counted_handle)
                {
                  v45 = v22[11];
                  if (v45)
                    v22[11] = v45 + 1;
                  v26 = -1;
                }
                else
                {
                  v26 = 0;
                }
                *(_QWORD *)buf = v22;
                buf[8] = v26;
                v46 = (void *)*((_QWORD *)v11 - 7);
                if (v46 == &nw_protocol_ref_counted_handle)
                {
                  v48 = *((_QWORD *)v11 - 1);
                  if (v48)
                    *((_QWORD *)v11 - 1) = v48 + 1;
                  v47 = -1;
                }
                else
                {
                  v47 = 0;
                }
                *(_QWORD *)type = v11 - 96;
                v82 = v47;
                v24(v22, v11 - 96);
                if (v46 == &nw_protocol_ref_counted_handle)
                  nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                if (v25 == &nw_protocol_ref_counted_handle)
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              }
            }
            if (a6)
            {
              v49 = v22[3];
              if (v49)
              {
                v50 = *(void (**)(_QWORD *, char *))(v49 + 184);
                if (v50)
                {
                  v51 = (void *)v22[5];
                  if (v51 == &nw_protocol_ref_counted_handle)
                  {
                    v57 = v22[11];
                    if (v57)
                      v22[11] = v57 + 1;
                    v52 = -1;
                  }
                  else
                  {
                    v52 = 0;
                  }
                  *(_QWORD *)buf = v22;
                  buf[8] = v52;
                  v58 = (void *)*((_QWORD *)v11 - 7);
                  if (v58 == &nw_protocol_ref_counted_handle)
                  {
                    v60 = *((_QWORD *)v11 - 1);
                    if (v60)
                      *((_QWORD *)v11 - 1) = v60 + 1;
                    v59 = -1;
                  }
                  else
                  {
                    v59 = 0;
                  }
                  *(_QWORD *)type = v11 - 96;
                  v82 = v59;
                  v50(v22, v11 - 96);
                  if (v58 == &nw_protocol_ref_counted_handle)
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  if (v51 == &nw_protocol_ref_counted_handle)
                  {
LABEL_99:
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    goto LABEL_100;
                  }
                }
              }
            }
          }
        }
      }
    }
    else if ((v11[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = (id)gLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        v84 = 2082;
        v85 = v11 + 407;
        v86 = 2080;
        v87 = " ";
        v88 = 2048;
        v89 = a2;
        _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot add inbound data, flow %llx does not exist", buf, 0x2Au);
      }

    }
    goto LABEL_100;
  }
  if (a2 != -1)
  {
    __nwlog_obj();
    v70 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
    v62 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (!__nwlog_fault(v62, type, &v80))
      goto LABEL_150;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v63 = objc_claimAutoreleasedReturnValue();
      v71 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v71, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW)", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (!v80)
    {
      __nwlog_obj();
      v63 = objc_claimAutoreleasedReturnValue();
      v79 = type[0];
      if (os_log_type_enabled(v63, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v79, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_149;
    }
    v72 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v63 = objc_claimAutoreleasedReturnValue();
    v75 = type[0];
    v76 = os_log_type_enabled(v63, type[0]);
    if (!v72)
    {
      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
        _os_log_impl(&dword_182FBE000, v63, v75, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), no backtrace", buf, 0xCu);
      }
      goto LABEL_149;
    }
    if (v76)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_add_inbound";
      v84 = 2082;
      v85 = v72;
      _os_log_impl(&dword_182FBE000, v63, v75, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_130:

    free(v72);
    if (!v62)
      goto LABEL_100;
    goto LABEL_151;
  }
  v27 = *((_DWORD *)v12 + 13);
  if (v27)
    v27 -= *((_DWORD *)v12 + 14) + *((_DWORD *)v12 + 15);
  v28 = *((_DWORD *)v11 + 51) + v27;
  ++*((_DWORD *)v11 + 50);
  *((_DWORD *)v11 + 51) = v28;
  *((_QWORD *)v12 + 4) = 0;
  v29 = (_QWORD *)*((_QWORD *)v11 + 24);
  *((_QWORD *)v12 + 5) = v29;
  *v29 = v12;
  *((_QWORD *)v11 + 24) = v12 + 32;
  if ((v11[402] & 8) != 0)
  {
    if ((v11[403] & 0x10) != 0)
    {
      if (a6)
        v11[403] |= 0x40u;
    }
    else
    {
      v30 = (_QWORD *)*((_QWORD *)v11 - 6);
      if (!v30)
        goto LABEL_51;
      v31 = v30[3];
      if (!v31)
        goto LABEL_51;
      v32 = *(void (**)(void))(v31 + 64);
      if (!v32)
        goto LABEL_51;
      v33 = (void *)v30[5];
      if (v33 == &nw_protocol_ref_counted_handle)
      {
        v36 = v30[11];
        if (v36)
          v30[11] = v36 + 1;
        v34 = -1;
      }
      else
      {
        v34 = 0;
      }
      *(_QWORD *)buf = v30;
      buf[8] = v34;
      v37 = (void *)*((_QWORD *)v11 - 7);
      if (v37 == &nw_protocol_ref_counted_handle)
      {
        v39 = *((_QWORD *)v11 - 1);
        if (v39)
          *((_QWORD *)v11 - 1) = v39 + 1;
        v38 = -1;
      }
      else
      {
        v38 = 0;
      }
      *(_QWORD *)type = v11 - 96;
      v82 = v38;
      v32();
      if (v37 == &nw_protocol_ref_counted_handle)
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v33 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
        if (!a6)
          goto LABEL_100;
      }
      else
      {
LABEL_51:
        if (!a6)
          goto LABEL_100;
      }
      v40 = (_QWORD *)*((_QWORD *)v11 - 6);
      if (v40)
      {
        v41 = v40[3];
        if (v41)
        {
          v42 = *(void (**)(void))(v41 + 184);
          if (v42)
          {
            v43 = (void *)v40[5];
            if (v43 == &nw_protocol_ref_counted_handle)
            {
              v53 = v40[11];
              if (v53)
                v40[11] = v53 + 1;
              v44 = -1;
            }
            else
            {
              v44 = 0;
            }
            *(_QWORD *)buf = v40;
            buf[8] = v44;
            v54 = (void *)*((_QWORD *)v11 - 7);
            if (v54 == &nw_protocol_ref_counted_handle)
            {
              v56 = *((_QWORD *)v11 - 1);
              if (v56)
                *((_QWORD *)v11 - 1) = v56 + 1;
              v55 = -1;
            }
            else
            {
              v55 = 0;
            }
            *(_QWORD *)type = v11 - 96;
            v82 = v55;
            v42();
            if (v54 == &nw_protocol_ref_counted_handle)
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            if (v43 == &nw_protocol_ref_counted_handle)
              goto LABEL_99;
          }
        }
      }
    }
  }
LABEL_100:

}

void sub_183035D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  va_list va;
  uint64_t v16;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v14 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  if (v12 == v11)
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  if (v10 == v11)
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_udp_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, uint64_t a5, nw_frame_array_s *a6)
{
  void *handle;
  BOOL v8;
  nw_protocol **p_output_handler;
  uint64_t v12;
  uint64_t v13;
  nw_protocol *output_handler;
  void *v15;
  nw_protocol_callbacks *callbacks;
  void *v17;
  nw_protocol_callbacks *v18;
  nw_protocol_callbacks *v19;
  uint64_t (*get_input_frames)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, _QWORD *);
  int v21;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *v23;
  void *v24;
  nw_protocol_callbacks *v25;
  void *v26;
  nw_protocol_callbacks *v27;
  nw_protocol_callbacks *v28;
  void (*error)(nw_protocol *, nw_protocol *, _QWORD);
  uint64_t v30;
  uint64_t v31;
  char v32;
  NSObject *v34;
  nw_protocol_callbacks *v35;
  nw_protocol_callbacks *v36;
  void (**v37)(_QWORD);
  const void *v38;
  nw_protocol_callbacks *v39;
  nw_protocol_callbacks *v40;
  void (**v41)(_QWORD);
  const void *v42;
  nw_protocol_callbacks *v43;
  nw_protocol_callbacks *v44;
  void (**v45)(_QWORD);
  const void *v46;
  nw_protocol_callbacks *v47;
  nw_protocol_callbacks *v48;
  void (**v49)(_QWORD);
  const void *v50;
  const char *name;
  const char *v52;
  os_log_type_t v53;
  const char *v54;
  NSObject *v55;
  os_log_type_t v56;
  const char *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  char *v64;
  _BOOL4 v65;
  const char *v66;
  const char *v67;
  const char *v68;
  const char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  char *v73;
  NSObject *v74;
  os_log_type_t v75;
  _BOOL4 v76;
  NSObject *v77;
  os_log_type_t v78;
  const char *v79;
  _BOOL4 v80;
  char *v81;
  const char *v82;
  const char *v83;
  NSObject *v84;
  os_log_type_t v85;
  const char *v86;
  const char *v87;
  uint64_t v88;
  NSObject *v90;
  os_log_type_t v91;
  const char *v92;
  char *v93;
  char *backtrace_string;
  _BOOL4 v96;
  const char *v97;
  _BOOL4 v98;
  os_log_type_t v99;
  NSObject *log;
  os_log_type_t loga;
  NSObject *logb;
  os_log_type_t logc;
  os_log_type_t type[8];
  os_log_type_t typea;
  NSObject *typeb;
  os_log_type_t typec[8];
  const char *typed;
  NSObject *typee;
  char *v110;
  char *v111;
  nw_protocol *v112;
  nw_protocol **v113;
  _QWORD v114[2];
  uint64_t (*v115)(_QWORD *);
  void *v116;
  os_log_type_t *v117;
  nw_protocol **v118;
  nw_protocol *v119;
  nw_frame_array_s *v120;
  os_log_type_t v121[8];
  os_log_type_t *v122;
  uint64_t v123;
  int v124;
  _QWORD v125[2];
  char v126;
  os_log_type_t v127;
  uint8_t buf[4];
  const char *v129;
  __int16 v130;
  void *v131;
  __int16 v132;
  nw_protocol *v133;
  __int16 v134;
  void *v135;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v129 = "nw_protocol_udp_get_input_frames";
    v93 = (char *)_os_log_send_and_compose_impl();
    v121[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v125[0]) = 0;
    if (!__nwlog_fault(v93, v121, v125))
      goto LABEL_190;
    if (v121[0] == OS_LOG_TYPE_FAULT)
    {
      v90 = __nwlog_obj();
      v91 = v121[0];
      if (os_log_type_enabled(v90, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_udp_get_input_frames";
        v92 = "%{public}s called with null protocol";
LABEL_189:
        _os_log_impl(&dword_182FBE000, v90, v91, v92, buf, 0xCu);
      }
LABEL_190:
      if (v93)
        free(v93);
      return 0;
    }
    if (!LOBYTE(v125[0]))
    {
      v90 = __nwlog_obj();
      v91 = v121[0];
      if (os_log_type_enabled(v90, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_udp_get_input_frames";
        v92 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v90 = __nwlog_obj();
    v91 = v121[0];
    v96 = os_log_type_enabled(v90, v121[0]);
    if (!backtrace_string)
    {
      if (v96)
      {
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_udp_get_input_frames";
        v92 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (v96)
    {
      *(_DWORD *)buf = 136446466;
      v129 = "nw_protocol_udp_get_input_frames";
      v130 = 2082;
      v131 = backtrace_string;
      v97 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_179:
      _os_log_impl(&dword_182FBE000, v90, v91, v97, buf, 0x16u);
    }
LABEL_180:
    free(backtrace_string);
    goto LABEL_190;
  }
  handle = a1->handle;
  v8 = handle == &nw_protocol_ref_counted_handle;
  if (handle == &nw_protocol_ref_counted_handle)
    p_output_handler = &a1[1].output_handler;
  else
    p_output_handler = 0;
  v113 = p_output_handler;
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v129 = "nw_protocol_udp_get_input_frames";
    v93 = (char *)_os_log_send_and_compose_impl();
    v121[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v125[0]) = 0;
    if (!__nwlog_fault(v93, v121, v125))
      goto LABEL_190;
    if (v121[0] == OS_LOG_TYPE_FAULT)
    {
      v90 = __nwlog_obj();
      v91 = v121[0];
      if (os_log_type_enabled(v90, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_udp_get_input_frames";
        v92 = "%{public}s called with null udp";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (!LOBYTE(v125[0]))
    {
      v90 = __nwlog_obj();
      v91 = v121[0];
      if (os_log_type_enabled(v90, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_udp_get_input_frames";
        v92 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v90 = __nwlog_obj();
    v91 = v121[0];
    v98 = os_log_type_enabled(v90, v121[0]);
    if (!backtrace_string)
    {
      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_udp_get_input_frames";
        v92 = "%{public}s called with null udp, no backtrace";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (v98)
    {
      *(_DWORD *)buf = 136446466;
      v129 = "nw_protocol_udp_get_input_frames";
      v130 = 2082;
      v131 = backtrace_string;
      v97 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_179;
    }
    goto LABEL_180;
  }
  if (a3 >= 0xFFFFFFF8)
    v12 = 0xFFFFFFFFLL;
  else
    v12 = a3 + 8;
  if (a4 >= 0xFFFFFFF8)
    v13 = 0xFFFFFFFFLL;
  else
    v13 = a4 + 8;
  v125[0] = 0;
  v125[1] = v125;
  *(_QWORD *)v121 = 0;
  v122 = v121;
  v124 = 0;
  v112 = a1 + 3;
  v123 = 0x2000000000;
  while (1)
  {
    output_handler = a1->output_handler;
    if (output_handler)
    {
      v15 = output_handler->handle;
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        callbacks = output_handler[1].callbacks;
        if (callbacks)
          output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      v17 = a1->handle;
      if (v17 == &nw_protocol_ref_counted_handle)
      {
        v18 = a1[1].callbacks;
        if (v18)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
      }
      v19 = output_handler->callbacks;
      if (v19)
      {
        get_input_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, _QWORD *))v19->get_input_frames;
        if (get_input_frames)
        {
          v21 = get_input_frames(output_handler, a1, v12, v13, a5, v125);
          if (v17 != &nw_protocol_ref_counted_handle)
          {
LABEL_25:
            if (v15 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
            {
              v39 = output_handler[1].callbacks;
              if (v39)
              {
                v40 = (nw_protocol_callbacks *)((char *)v39 - 1);
                output_handler[1].callbacks = v40;
                if (!v40)
                {
                  v41 = *(void (***)(_QWORD))output_handler[1].flow_id;
                  if (v41)
                  {
                    *(_QWORD *)output_handler[1].flow_id = 0;
                    v41[2](v41);
                    _Block_release(v41);
                  }
                  if ((output_handler[1].flow_id[8] & 1) != 0)
                  {
                    v42 = *(const void **)output_handler[1].flow_id;
                    if (v42)
                      _Block_release(v42);
                  }
                  free(output_handler);
                }
              }
            }
            goto LABEL_27;
          }
LABEL_24:
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v35 = a1[1].callbacks;
            if (v35)
            {
              v36 = (nw_protocol_callbacks *)((char *)v35 - 1);
              a1[1].callbacks = v36;
              if (!v36)
              {
                v37 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v37)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v37[2](v37);
                  _Block_release(v37);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v38 = *(const void **)a1[1].flow_id;
                  if (v38)
                    _Block_release(v38);
                }
                free(a1);
              }
            }
          }
          goto LABEL_25;
        }
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      name = output_handler->identifier->name;
      if (!name)
        name = "invalid";
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_get_input_frames";
      v130 = 2082;
      v131 = (void *)name;
      v132 = 2048;
      v133 = output_handler;
      v52 = (const char *)_os_log_send_and_compose_impl();
      v127 = OS_LOG_TYPE_ERROR;
      v126 = 0;
      v110 = (char *)v52;
      if (__nwlog_fault(v52, &v127, &v126))
      {
        if (v127 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v53 = v127;
          *(_QWORD *)type = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, v127))
            goto LABEL_133;
          v54 = output_handler->identifier->name;
          if (!v54)
            v54 = "invalid";
          *(_DWORD *)buf = 136446722;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v54;
          v132 = 2048;
          v133 = output_handler;
          v55 = *(NSObject **)type;
          v56 = v53;
          v57 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_132:
          _os_log_impl(&dword_182FBE000, v55, v56, v57, buf, 0x20u);
          goto LABEL_133;
        }
        if (!v126)
        {
          v77 = __nwlog_obj();
          v78 = v127;
          *(_QWORD *)typec = v77;
          if (!os_log_type_enabled(v77, v127))
            goto LABEL_133;
          v79 = output_handler->identifier->name;
          if (!v79)
            v79 = "invalid";
          *(_DWORD *)buf = 136446722;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v79;
          v132 = 2048;
          v133 = output_handler;
          v55 = *(NSObject **)typec;
          v56 = v78;
          v57 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
          goto LABEL_132;
        }
        v64 = (char *)__nw_create_backtrace_string();
        log = __nwlog_obj();
        typea = v127;
        v65 = os_log_type_enabled(log, v127);
        if (!v64)
        {
          if (!v65)
            goto LABEL_133;
          v83 = output_handler->identifier->name;
          if (!v83)
            v83 = "invalid";
          *(_DWORD *)buf = 136446722;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v83;
          v132 = 2048;
          v133 = output_handler;
          v55 = log;
          v56 = typea;
          v57 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
          goto LABEL_132;
        }
        if (v65)
        {
          v66 = output_handler->identifier->name;
          if (!v66)
            v66 = "invalid";
          *(_DWORD *)buf = 136446978;
          v129 = "__nw_protocol_get_input_frames";
          v130 = 2082;
          v131 = (void *)v66;
          v132 = 2048;
          v133 = output_handler;
          v134 = 2082;
          v135 = v64;
          _os_log_impl(&dword_182FBE000, log, typea, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v64);
      }
LABEL_133:
      if (v110)
        free(v110);
      v21 = 0;
      if (v17 != &nw_protocol_ref_counted_handle)
        goto LABEL_25;
      goto LABEL_24;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v129 = "__nw_protocol_get_input_frames";
    v58 = (char *)_os_log_send_and_compose_impl();
    v127 = OS_LOG_TYPE_ERROR;
    v126 = 0;
    if (__nwlog_fault(v58, &v127, &v126))
    {
      if (v127 == OS_LOG_TYPE_FAULT)
      {
        v59 = __nwlog_obj();
        v60 = v127;
        if (os_log_type_enabled(v59, v127))
        {
          *(_DWORD *)buf = 136446210;
          v129 = "__nw_protocol_get_input_frames";
          v61 = v59;
          v62 = v60;
          v63 = "%{public}s called with null protocol";
LABEL_141:
          _os_log_impl(&dword_182FBE000, v61, v62, v63, buf, 0xCu);
        }
      }
      else if (v126)
      {
        v73 = (char *)__nw_create_backtrace_string();
        v74 = __nwlog_obj();
        v75 = v127;
        v76 = os_log_type_enabled(v74, v127);
        if (v73)
        {
          if (v76)
          {
            *(_DWORD *)buf = 136446466;
            v129 = "__nw_protocol_get_input_frames";
            v130 = 2082;
            v131 = v73;
            _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v73);
          goto LABEL_142;
        }
        if (v76)
        {
          *(_DWORD *)buf = 136446210;
          v129 = "__nw_protocol_get_input_frames";
          v61 = v74;
          v62 = v75;
          v63 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_141;
        }
      }
      else
      {
        v84 = __nwlog_obj();
        v85 = v127;
        if (os_log_type_enabled(v84, v127))
        {
          *(_DWORD *)buf = 136446210;
          v129 = "__nw_protocol_get_input_frames";
          v61 = v84;
          v62 = v85;
          v63 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_141;
        }
      }
    }
LABEL_142:
    if (v58)
      free(v58);
    v21 = 0;
LABEL_27:
    if ((HIWORD(a1[2].output_handler_context) & 0x200) == 0)
      goto LABEL_44;
    default_input_handler = a1->default_input_handler;
    if (!default_input_handler)
      goto LABEL_44;
    v23 = default_input_handler->callbacks;
    if (!v23 || !v23->error)
      goto LABEL_44;
    HIWORD(a1[2].output_handler_context) &= ~0x200u;
    v24 = default_input_handler->handle;
    if (v24 == &nw_protocol_ref_counted_handle)
    {
      v25 = default_input_handler[1].callbacks;
      if (v25)
        default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v25->add_input_handler + 1);
    }
    v26 = a1->handle;
    if (v26 == &nw_protocol_ref_counted_handle)
    {
      v27 = a1[1].callbacks;
      if (v27)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v27->add_input_handler + 1);
    }
    v28 = default_input_handler->callbacks;
    if (!v28 || (error = (void (*)(nw_protocol *, nw_protocol *, _QWORD))v28->error) == 0)
    {
      __nwlog_obj();
      v67 = default_input_handler->identifier->name;
      if (!v67)
        v67 = "invalid";
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_error";
      v130 = 2082;
      v131 = (void *)v67;
      v132 = 2048;
      v133 = default_input_handler;
      v68 = (const char *)_os_log_send_and_compose_impl();
      v127 = OS_LOG_TYPE_ERROR;
      v126 = 0;
      v111 = (char *)v68;
      if (!__nwlog_fault(v68, &v127, &v126))
        goto LABEL_154;
      if (v127 == OS_LOG_TYPE_FAULT)
      {
        typeb = __nwlog_obj();
        loga = v127;
        if (!os_log_type_enabled(typeb, v127))
          goto LABEL_154;
        v69 = default_input_handler->identifier->name;
        if (!v69)
          v69 = "invalid";
        *(_DWORD *)buf = 136446722;
        v129 = "__nw_protocol_error";
        v130 = 2082;
        v131 = (void *)v69;
        v132 = 2048;
        v133 = default_input_handler;
        v70 = typeb;
        v71 = loga;
        v72 = "%{public}s protocol %{public}s (%p) has invalid error callback";
      }
      else if (v126)
      {
        typed = __nw_create_backtrace_string();
        logb = __nwlog_obj();
        v99 = v127;
        v80 = os_log_type_enabled(logb, v127);
        v81 = (char *)typed;
        if (typed)
        {
          if (v80)
          {
            v82 = default_input_handler->identifier->name;
            if (!v82)
              v82 = "invalid";
            *(_DWORD *)buf = 136446978;
            v129 = "__nw_protocol_error";
            v130 = 2082;
            v131 = (void *)v82;
            v132 = 2048;
            v133 = default_input_handler;
            v134 = 2082;
            v135 = (void *)typed;
            _os_log_impl(&dword_182FBE000, logb, v99, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
            v81 = (char *)typed;
          }
          free(v81);
          goto LABEL_154;
        }
        if (!v80)
        {
LABEL_154:
          if (v111)
            free(v111);
          goto LABEL_40;
        }
        v87 = default_input_handler->identifier->name;
        if (!v87)
          v87 = "invalid";
        *(_DWORD *)buf = 136446722;
        v129 = "__nw_protocol_error";
        v130 = 2082;
        v131 = (void *)v87;
        v132 = 2048;
        v133 = default_input_handler;
        v70 = logb;
        v71 = v99;
        v72 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
      }
      else
      {
        typee = __nwlog_obj();
        logc = v127;
        if (!os_log_type_enabled(typee, v127))
          goto LABEL_154;
        v86 = default_input_handler->identifier->name;
        if (!v86)
          v86 = "invalid";
        *(_DWORD *)buf = 136446722;
        v129 = "__nw_protocol_error";
        v130 = 2082;
        v131 = (void *)v86;
        v132 = 2048;
        v133 = default_input_handler;
        v70 = typee;
        v71 = logc;
        v72 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v70, v71, v72, buf, 0x20u);
      goto LABEL_154;
    }
    error(default_input_handler, a1, 0);
LABEL_40:
    if (v26 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
    {
      v43 = a1[1].callbacks;
      if (v43)
      {
        v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
        a1[1].callbacks = v44;
        if (!v44)
        {
          v45 = *(void (***)(_QWORD))a1[1].flow_id;
          if (v45)
          {
            *(_QWORD *)a1[1].flow_id = 0;
            v45[2](v45);
            _Block_release(v45);
          }
          if ((a1[1].flow_id[8] & 1) != 0)
          {
            v46 = *(const void **)a1[1].flow_id;
            if (v46)
              _Block_release(v46);
          }
          free(a1);
        }
      }
    }
    if (v24 == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v47 = default_input_handler[1].callbacks;
      if (v47)
      {
        v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
        default_input_handler[1].callbacks = v48;
        if (!v48)
        {
          v49 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v49)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v49[2](v49);
            _Block_release(v49);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v50 = *(const void **)default_input_handler[1].flow_id;
            if (v50)
              _Block_release(v50);
          }
          free(default_input_handler);
        }
      }
    }
LABEL_44:
    v114[0] = MEMORY[0x1E0C809B0];
    v114[1] = 0x40000000;
    v115 = (uint64_t (*)(_QWORD *))___ZL32nw_protocol_udp_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    v116 = &unk_1E1499C40;
    v119 = a1;
    v120 = a6;
    v117 = v121;
    v118 = v113;
    v30 = v125[0];
    do
    {
      if (!v30)
        break;
      v31 = *(_QWORD *)(v30 + 32);
      v32 = v115(v114);
      v30 = v31;
    }
    while ((v32 & 1) != 0);
    if (*((_DWORD *)v122 + 6) || v21 == 0)
      break;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v129 = "nw_protocol_udp_get_input_frames";
      v130 = 2082;
      v131 = v112;
      _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Dropped inbound packets, checking for more", buf, 0x16u);
    }
  }
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  v88 = *((unsigned int *)v122 + 6);
  _Block_object_dispose(v121, 8);
  return v88;
}

uint64_t ___ZL32nw_protocol_udp_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  _QWORD *v7;
  _BOOL4 v8;
  NSObject *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  NSObject *v15;
  _BOOL4 v16;
  const char *v17;
  unsigned int v18;
  unsigned int v19;
  NSObject *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  const char *v24;
  unsigned int v25;
  NSObject *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  __int16 v35;
  NSObject *singleton;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  char *backtrace_string;
  _BOOL4 v51;
  NSObject *v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  unsigned int v56;
  char v57;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v60;
  __int16 v61;
  void *v62;
  __int16 v63;
  unsigned int v64;
  __int16 v65;
  unsigned int v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v56 = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &v56);
  if (!v4)
    goto LABEL_89;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v60 = "__nw_frame_check_validity";
    v46 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v46, &type, &v57))
      goto LABEL_87;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (!os_log_type_enabled(v47, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v60 = "__nw_frame_check_validity";
      v49 = "%{public}s called with null frame";
    }
    else if (v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v47 = __nwlog_obj();
      v48 = type;
      v51 = os_log_type_enabled(v47, type);
      if (backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          v60 = "__nw_frame_check_validity";
          v61 = 2082;
          v62 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_87;
      }
      if (!v51)
      {
LABEL_87:
        if (v46)
          free(v46);
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      v60 = "__nw_frame_check_validity";
      v49 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (!os_log_type_enabled(v47, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v60 = "__nw_frame_check_validity";
      v49 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v47, v48, v49, buf, 0xCu);
    goto LABEL_87;
  }
  v5 = (unsigned __int16 *)v4;
  if ((*(_WORD *)(a2 + 204) & 0x100) == 0
    || !g_channel_check_validity
    || (g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)) & 1) != 0)
  {
    v6 = a1[5];
    v7 = *(_QWORD **)(v6 + 64);
    if (v7)
      ++*v7;
    v8 = v56 < 8;
    if (v56 <= 7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v10 = a1[5];
        v11 = (const char *)(v10 + 96);
        if (!v10)
          v11 = "";
        *(_DWORD *)buf = 136446722;
        v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        v61 = 2082;
        v62 = (void *)v11;
        v63 = 1024;
        v64 = v56;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received UDP packet shorter than header %u", buf, 0x1Cu);
      }
      v6 = a1[5];
      v12 = *(_QWORD *)(v6 + 64);
      if (v12)
        ++*(_QWORD *)(v12 + 8);
    }
    v13 = *v5;
    v14 = *(unsigned __int16 *)(v6 + 90);
    if (v13 != v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      v16 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      v6 = a1[5];
      if (v16)
      {
        v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        v61 = 2082;
        *(_DWORD *)buf = 136446978;
        if (v6)
          v17 = (const char *)(v6 + 96);
        else
          v17 = "";
        v62 = (void *)v17;
        v63 = 1024;
        v64 = __rev16(v13);
        v65 = 1024;
        v66 = __rev16(v14);
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received remote port %u != %u", buf, 0x22u);
        v6 = a1[5];
      }
      v8 = 1;
    }
    v18 = v5[1];
    v19 = *(unsigned __int16 *)(v6 + 88);
    if (v18 != v19)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v21 = __rev16(v19);
        v22 = __rev16(v18);
        v23 = a1[5];
        v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        v61 = 2082;
        *(_DWORD *)buf = 136446978;
        if (v23)
          v24 = (const char *)(v23 + 96);
        else
          v24 = "";
        v62 = (void *)v24;
        v63 = 1024;
        v64 = v22;
        v65 = 1024;
        v66 = v21;
        _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received local port %u != %u", buf, 0x22u);
      }
      v8 = 1;
    }
    v25 = bswap32(v5[2]) >> 16;
    if (v56 >= v25)
    {
      v29 = a1[5];
      if ((*(_WORD *)(v29 + 94) & 4) != 0)
        goto LABEL_48;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v27 = a1[5];
        v28 = "";
        if (v27)
          v28 = (const char *)(v27 + 96);
        *(_DWORD *)buf = 136446978;
        v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        v61 = 2082;
        v62 = (void *)v28;
        v63 = 1024;
        v64 = v25;
        v65 = 1024;
        v66 = v56;
        _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received length %u > %u", buf, 0x22u);
      }
      v29 = a1[5];
      v30 = *(_QWORD *)(v29 + 64);
      if (v30)
        ++*(_QWORD *)(v30 + 24);
      v8 = 1;
      if ((*(_WORD *)(v29 + 94) & 4) != 0)
      {
LABEL_48:
        v35 = *(_WORD *)(v29 + 94);
        if ((v35 & 0x40) != 0 || !v5[3])
        {
          if (!v8)
            goto LABEL_54;
        }
        else if (((v8 | udp_validate_cksum_internal(a2, v56, (unsigned __int16 *)(v29 + 48), (unsigned __int16 *)(v29 + 32), (v35 & 4) == 0, v29) ^ 1) & 1) == 0)
        {
          v35 = *(_WORD *)(a1[5] + 94);
LABEL_54:
          if ((v35 & 0x20) != 0)
          {
            nw_frame_set_metadata(a2, 0, 1, 1);
          }
          else
          {
            if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1)
              dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45078);
            singleton = nw_protocol_metadata_create_singleton((void *)g_udp_definition);
            if (singleton)
            {
              v38 = singleton;
              nw_frame_set_metadata(a2, singleton, 1, 1);
              os_release(v38);
            }
          }
          nw_frame_claim(a2, v37, 8, v56 - v25);
          v39 = a1[7];
          *(_QWORD *)(a2 + 32) = 0;
          v40 = *(uint64_t **)(v39 + 8);
          *(_QWORD *)(a2 + 40) = v40;
          *v40 = a2;
          *(_QWORD *)(v39 + 8) = a2 + 32;
          ++*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
          v41 = a1[5];
          if (v41)
          {
            v42 = *(_QWORD *)(v41 + 72);
            if (v42)
            {
              ++*(_QWORD *)(v42 + 16);
              v43 = a1[5];
              if (v43)
              {
                v44 = *(_QWORD *)(v43 + 72);
                if (v44)
                  *(_QWORD *)(v44 + 24) += *(unsigned int *)(a2 + 52);
              }
            }
          }
          if (_nw_signposts_once != -1)
            dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
          if (_nw_signposts_enabled && kdebug_is_enabled())
            kdebug_trace();
          if (v56 >= 9)
            *(_QWORD *)(a1[5] + 8) = v56 + *(_QWORD *)(a1[5] + 8) - 8;
          return 1;
        }
        nw_frame_finalize(a2);
        return 1;
      }
    }
    if (!v5[3])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v32 = a1[5];
        if (v32)
          v33 = (const char *)(v32 + 96);
        else
          v33 = "";
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        v61 = 2082;
        v62 = (void *)v33;
        _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received an IPv6 packet with zero checksum", buf, 0x16u);
      }
      v29 = a1[5];
      v34 = *(_QWORD *)(v29 + 64);
      if (v34)
        ++*(_QWORD *)(v34 + 16);
      v8 = 1;
    }
    goto LABEL_48;
  }
LABEL_89:
  v52 = __nwlog_obj();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
  {
    v53 = a1[5];
    if (v53)
      v54 = (const char *)(v53 + 96);
    else
      v54 = "";
    *(_DWORD *)buf = 136446466;
    v60 = "nw_protocol_udp_get_input_frames_block_invoke";
    v61 = 2082;
    v62 = (void *)v54;
    _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_INFO, "%{public}s %{public}s UDP frame is no longer valid", buf, 0x16u);
  }
  v55 = a1[5];
  if (v55)
  {
    *(_QWORD *)(v55 + 64) = 0;
    *(_QWORD *)(v55 + 72) = 0;
  }
  return 1;
}

void nw_frame_foreach_protocol_metadata(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v6;
  char v7;
  _QWORD *v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  NSObject *singleton;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  _QWORD *isa;
  NSObject *v19;
  uint64_t v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  char *v27;
  _BOOL4 v28;
  void *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  char *v33;
  os_log_type_t v34;
  _BOOL4 v35;
  os_log_type_t v36;
  void *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  char *v41;
  os_log_type_t v42;
  _BOOL4 v43;
  os_log_type_t v44;
  char v45;
  os_log_type_t v46;
  _BYTE buf[24];
  void *v48;
  uint64_t v49;
  os_log_type_t type[4];
  const char *v51;
  __int16 v52;
  char *v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
    v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v46 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v21, type, &v46))
      goto LABEL_64;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type[0];
      if (!os_log_type_enabled(v22, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
      v24 = "%{public}s called with null frame";
      goto LABEL_63;
    }
    if (v46 == OS_LOG_TYPE_DEFAULT)
    {
      v22 = __nwlog_obj();
      v23 = type[0];
      if (!os_log_type_enabled(v22, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
      v24 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_63;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type[0];
    v26 = os_log_type_enabled(v22, type[0]);
    if (!backtrace_string)
    {
      if (!v26)
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
      v24 = "%{public}s called with null frame, no backtrace";
      goto LABEL_63;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_64:
    if (!v21)
      return;
    goto LABEL_65;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
    v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v46 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v21, type, &v46))
      goto LABEL_64;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type[0];
      if (!os_log_type_enabled(v22, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
      v24 = "%{public}s called with null block";
      goto LABEL_63;
    }
    if (v46 == OS_LOG_TYPE_DEFAULT)
    {
      v22 = __nwlog_obj();
      v23 = type[0];
      if (!os_log_type_enabled(v22, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
      v24 = "%{public}s called with null block, backtrace limit exceeded";
      goto LABEL_63;
    }
    v27 = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type[0];
    v28 = os_log_type_enabled(v22, type[0]);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v27;
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v27);
      if (!v21)
        return;
LABEL_65:
      free(v21);
      return;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_foreach_protocol_metadata";
      v24 = "%{public}s called with null block, no backtrace";
LABEL_63:
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
      goto LABEL_64;
    }
    goto LABEL_64;
  }
  v6 = *(_QWORD **)(a1 + 64);
  if (v6)
  {
    v7 = 0;
    while (1)
    {
      v8 = (_QWORD *)*v6;
      v9 = v6[6];
      if (v9)
      {
        if (nw_protocol_setup_ip_definition(void)::onceToken != -1)
          dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_52132);
        v10 = nw_protocol_metadata_matches_definition(v9, g_ip_definition);
        if (!(*(unsigned int (**)(uint64_t, _QWORD))(a3 + 16))(a3, v6[6]))
          return;
        v7 |= v10;
      }
      v6 = v8;
      if (!v8)
        goto LABEL_13;
    }
  }
  v7 = 0;
LABEL_13:
  if ((v7 & 1) == 0 && a2)
  {
    if ((*(_WORD *)(a1 + 204) & 0x10) != 0)
      v11 = 0;
    else
      v11 = *(_QWORD *)(a1 + 152);
    v12 = *(unsigned __int8 *)(a1 + 185);
    v13 = *(_BYTE *)(a1 + 186) & 3;
    if (!v11 && !v12)
    {
      if ((_DWORD)v13)
        __asm { BR              X9 }
      return;
    }
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_52132);
    singleton = nw_protocol_metadata_create_singleton((void *)g_ip_definition);
    nw_ip_metadata_set_ecn_flag(singleton, (nw_ip_ecn_flag_t)v13);
    v15 = singleton;
    v16 = v15;
    if (v15)
    {
      v17 = MEMORY[0x1E0C809B0];
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = __nw_ip_metadata_set_receive_time_block_invoke;
      v48 = &__block_descriptor_40_e9_B16__0_v8l;
      v49 = v11;
      isa = v15[4].isa;
      if (isa)
        __nw_ip_metadata_set_receive_time_block_invoke((uint64_t)buf, isa);

      v19 = v16;
      *(_QWORD *)buf = v17;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = __nw_ip_metadata_set_hop_limit_block_invoke;
      v48 = &__block_descriptor_33_e9_B16__0_v8l;
      LOBYTE(v49) = v12;
      v20 = (uint64_t)v16[4].isa;
      if (v20)
        __nw_ip_metadata_set_hop_limit_block_invoke((uint64_t)buf, v20);
LABEL_29:

      (*(void (**)(uint64_t, NSObject *))(a3 + 16))(a3, v16);
      if (v16)
        os_release(v16);
      return;
    }
    __nwlog_obj();
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)type = 136446210;
    v51 = "nw_ip_metadata_set_receive_time";
    v30 = (char *)_os_log_send_and_compose_impl();

    v46 = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v30, &v46, &v45))
    {
      if (v46 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v32 = v46;
        if (os_log_type_enabled(v31, v46))
        {
          *(_DWORD *)type = 136446210;
          v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null metadata", (uint8_t *)type, 0xCu);
        }
LABEL_77:

        goto LABEL_78;
      }
      if (!v45)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v36 = v46;
        if (os_log_type_enabled(v31, v46))
        {
          *(_DWORD *)type = 136446210;
          v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl(&dword_182FBE000, v31, v36, "%{public}s called with null metadata, backtrace limit exceeded", (uint8_t *)type, 0xCu);
        }
        goto LABEL_77;
      }
      v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v34 = v46;
      v35 = os_log_type_enabled(v31, v46);
      if (!v33)
      {
        if (v35)
        {
          *(_DWORD *)type = 136446210;
          v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl(&dword_182FBE000, v31, v34, "%{public}s called with null metadata, no backtrace", (uint8_t *)type, 0xCu);
        }
        goto LABEL_77;
      }
      if (v35)
      {
        *(_DWORD *)type = 136446466;
        v51 = "nw_ip_metadata_set_receive_time";
        v52 = 2082;
        v53 = v33;
        _os_log_impl(&dword_182FBE000, v31, v34, "%{public}s called with null metadata, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
      }

      free(v33);
    }
LABEL_78:
    if (v30)
      free(v30);
    __nwlog_obj();
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)type = 136446210;
    v51 = "nw_ip_metadata_set_hop_limit";
    v38 = (char *)_os_log_send_and_compose_impl();

    v46 = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v38, &v46, &v45))
      goto LABEL_96;
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      v40 = v46;
      if (os_log_type_enabled(v39, v46))
      {
        *(_DWORD *)type = 136446210;
        v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s called with null metadata", (uint8_t *)type, 0xCu);
      }
    }
    else if (v45)
    {
      v41 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      v42 = v46;
      v43 = os_log_type_enabled(v39, v46);
      if (v41)
      {
        if (v43)
        {
          *(_DWORD *)type = 136446466;
          v51 = "nw_ip_metadata_set_hop_limit";
          v52 = 2082;
          v53 = v41;
          _os_log_impl(&dword_182FBE000, v39, v42, "%{public}s called with null metadata, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
        }

        free(v41);
        goto LABEL_96;
      }
      if (v43)
      {
        *(_DWORD *)type = 136446210;
        v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl(&dword_182FBE000, v39, v42, "%{public}s called with null metadata, no backtrace", (uint8_t *)type, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      v44 = v46;
      if (os_log_type_enabled(v39, v46))
      {
        *(_DWORD *)type = 136446210;
        v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl(&dword_182FBE000, v39, v44, "%{public}s called with null metadata, backtrace limit exceeded", (uint8_t *)type, 0xCu);
      }
    }

LABEL_96:
    if (v38)
      free(v38);
    goto LABEL_29;
  }
}

void nw_frame_set_metadata(uint64_t a1, NSObject *object, int a3, int a4)
{
  unsigned int dscp_value;
  nw_service_class_t service_class;
  int v10;
  uint64_t v11;
  void *v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  NSObject *v23;
  uint64_t *v24;
  char v25;
  char v26;
  NSObject *v27;
  objc_class *v28;
  void *v29;
  id *v30;
  id v31;
  void *v32;
  _QWORD *v33;
  char v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  char *v38;
  _BOOL4 v39;
  NSObject *v40;
  os_log_type_t v41;
  uint32_t v42;
  NSObject *v43;
  os_log_type_t v44;
  char *backtrace_string;
  _BOOL4 v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  NSObject *v51;
  void *v52;
  int v53;
  char *v54;
  _BOOL4 v55;
  int v56;
  char v57;
  os_log_type_t type[16];
  uint8_t buf[4];
  const char *v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  char *v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v60 = "__nw_frame_set_metadata";
    v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v19, type, &v57))
      goto LABEL_70;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v43 = __nwlog_obj();
      v44 = type[0];
      if (!os_log_type_enabled(v43, type[0]))
        goto LABEL_70;
      *(_DWORD *)buf = 136446210;
      v60 = "__nw_frame_set_metadata";
      v22 = "%{public}s called with null frame";
    }
    else if (v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v43 = __nwlog_obj();
      v44 = type[0];
      v46 = os_log_type_enabled(v43, type[0]);
      if (backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          v60 = "__nw_frame_set_metadata";
          v61 = 2082;
          v62 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_70;
      }
      if (!v46)
        goto LABEL_70;
      *(_DWORD *)buf = 136446210;
      v60 = "__nw_frame_set_metadata";
      v22 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v43 = __nwlog_obj();
      v44 = type[0];
      if (!os_log_type_enabled(v43, type[0]))
        goto LABEL_70;
      *(_DWORD *)buf = 136446210;
      v60 = "__nw_frame_set_metadata";
      v22 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    v40 = v43;
    v41 = v44;
    v42 = 12;
    goto LABEL_69;
  }
  if (object)
  {
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_52132);
    if (!nw_protocol_metadata_matches_definition((uint64_t)object, g_ip_definition))
      goto LABEL_14;
    *(_BYTE *)(a1 + 186) = *(_BYTE *)(a1 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(object) & 3;
    dscp_value = nw_ip_metadata_get_dscp_value(object);
    if (dscp_value < 0x40)
    {
      *(_BYTE *)(a1 + 184) = dscp_value;
LABEL_8:
      service_class = nw_ip_metadata_get_service_class(object);
      if (service_class > nw_service_class_signaling)
        v10 = 0;
      else
        v10 = dword_183BA8F60[service_class];
      *(_DWORD *)(a1 + 176) = v10;
      *(_DWORD *)(a1 + 180) = nw_ip_metadata_get_fragmentation_value(object);
LABEL_14:
      v11 = a1 + 204;
      if ((*(_WORD *)(a1 + 204) & 8) == 0)
        goto LABEL_15;
      v56 = a4;
      v23 = object;
      *(_OWORD *)type = *(_OWORD *)&v23[2].isa;

      v24 = *(uint64_t **)(a1 + 64);
      if (!v24)
        goto LABEL_47;
      v25 = 0;
      if (a4)
        v26 = 64;
      else
        v26 = 0;
      while (1)
      {
        v27 = v23;
        v28 = v23[1].isa;

        v29 = (void *)v24[6];
        if (v29)
        {
          v30 = v29;
          v31 = v30[1];

          if (nw_protocol_definition_is_equal_unsafe((uint64_t)v28, (uint64_t)v31)
            && !uuid_compare((const unsigned __int8 *)type, (const unsigned __int8 *)v24 + 16))
          {
            os_retain(v27);
            v32 = (void *)v24[6];
            if (v32)
              os_release(v32);
            v24[6] = (uint64_t)v27;
            *((_BYTE *)v24 + 66) = *((_BYTE *)v24 + 66) & 0xBF | v26;
            v25 = 1;
            if (!v31)
              goto LABEL_40;
LABEL_39:
            os_release(v31);
            goto LABEL_40;
          }
          if (v31)
            goto LABEL_39;
        }
LABEL_40:
        if (v28)
          os_release(v28);
        v24 = (uint64_t *)*v24;
        if (!v24)
        {
          if ((v25 & 1) == 0)
          {
LABEL_47:
            v33 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
            if (v33)
              goto LABEL_48;
            v51 = __nwlog_obj();
            os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446722;
            v60 = "strict_calloc";
            v61 = 2048;
            v62 = 1;
            v63 = 2048;
            v64 = 72;
            v52 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort((uint64_t)v52))
            {
              __break(1u);
            }
            else
            {
              free(v52);
LABEL_48:
              v33[6] = os_retain(v23);
              *((_OWORD *)v33 + 1) = *(_OWORD *)type;
              if (v56)
                v34 = 64;
              else
                v34 = 0;
              *((_BYTE *)v33 + 66) = *((_BYTE *)v33 + 66) & 0xBF | v34;
              if (a3)
              {
                v35 = *(_QWORD *)(a1 + 64);
                *v33 = v35;
                if (v35)
                  v36 = (_QWORD *)(v35 + 8);
                else
                  v36 = (_QWORD *)(a1 + 72);
                *v36 = v33;
                *(_QWORD *)(a1 + 64) = v33;
                v33[1] = a1 + 64;
              }
              else
              {
                *v33 = 0;
                v37 = *(_QWORD **)(a1 + 72);
                v33[1] = v37;
                *v37 = v33;
                *(_QWORD *)(a1 + 72) = v33;
              }
            }
          }
          return;
        }
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v60 = "__nw_frame_set_dscp_value";
    v47 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (__nwlog_fault(v47, type, &v57))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v48 = __nwlog_obj();
        v49 = type[0];
        if (!os_log_type_enabled(v48, type[0]))
          goto LABEL_103;
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_set_dscp_value";
        v50 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
        goto LABEL_102;
      }
      v53 = a4;
      if (!v57)
      {
        v48 = __nwlog_obj();
        v49 = type[0];
        if (!os_log_type_enabled(v48, type[0]))
          goto LABEL_103;
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_set_dscp_value";
        v50 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
        goto LABEL_102;
      }
      v54 = (char *)__nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = type[0];
      v55 = os_log_type_enabled(v48, type[0]);
      if (v54)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          v60 = "__nw_frame_set_dscp_value";
          v61 = 2082;
          v62 = (uint64_t)v54;
          _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v54);
        a4 = v53;
        goto LABEL_103;
      }
      a4 = v53;
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        v60 = "__nw_frame_set_dscp_value";
        v50 = "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace";
LABEL_102:
        _os_log_impl(&dword_182FBE000, v48, v49, v50, buf, 0xCu);
      }
    }
LABEL_103:
    if (v47)
      free(v47);
    goto LABEL_8;
  }
  v11 = a1 + 204;
  if ((*(_WORD *)(a1 + 204) & 8) != 0)
    return;
LABEL_15:
  v12 = *(void **)(a1 + 168);
  if (v12)
  {
    os_release(v12);
    *(_QWORD *)(a1 + 168) = 0;
  }
  if (object)
  {
    *(_QWORD *)(a1 + 168) = os_retain(object);
    v13 = *(unsigned __int16 *)(a1 + 204);
    v14 = v13 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v13 & 0x20) == 0)
    {
      v15 = object;
      *(_OWORD *)(a1 + 136) = *(_OWORD *)&v15[2].isa;

      v14 = *(unsigned __int16 *)(a1 + 204) | (*(unsigned __int8 *)(a1 + 206) << 16);
    }
    *(_BYTE *)(v11 + 2) = BYTE2(v14);
    *(_WORD *)v11 = v14 | 8;
  }
  v16 = a1 + 120;
  v17 = *(_QWORD *)(a1 + 64);
  if (a4)
    v18 = 64;
  else
    v18 = 0;
  *(_BYTE *)(a1 + 186) = *(_BYTE *)(a1 + 186) & 0xBF | v18;
  if (!v17)
  {
    *(_QWORD *)(a1 + 64) = v16;
    *(_QWORD *)(a1 + 72) = v16;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = a1 + 64;
    return;
  }
  if (v17 != v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v60 = "__nw_frame_set_metadata";
    v61 = 2048;
    v62 = v17;
    v63 = 2048;
    v64 = a1 + 120;
    v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v19, type, &v57))
      goto LABEL_70;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v21 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_70;
      *(_DWORD *)buf = 136446722;
      v60 = "__nw_frame_set_metadata";
      v61 = 2048;
      v62 = v17;
      v63 = 2048;
      v64 = v16;
      v22 = "%{public}s Existing metadata %p doesn't match expected %p";
      goto LABEL_68;
    }
    if (!v57)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v21 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_70;
      *(_DWORD *)buf = 136446722;
      v60 = "__nw_frame_set_metadata";
      v61 = 2048;
      v62 = v17;
      v63 = 2048;
      v64 = v16;
      v22 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
      goto LABEL_68;
    }
    v38 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    v21 = type[0];
    v39 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446978;
        v60 = "__nw_frame_set_metadata";
        v61 = 2048;
        v62 = v17;
        v63 = 2048;
        v64 = v16;
        v65 = 2082;
        v66 = v38;
        _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v38);
      if (!v19)
        return;
LABEL_71:
      free(v19);
      return;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446722;
      v60 = "__nw_frame_set_metadata";
      v61 = 2048;
      v62 = v17;
      v63 = 2048;
      v64 = v16;
      v22 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
LABEL_68:
      v40 = v20;
      v41 = v21;
      v42 = 32;
LABEL_69:
      _os_log_impl(&dword_182FBE000, v40, v41, v22, buf, v42);
    }
LABEL_70:
    if (!v19)
      return;
    goto LABEL_71;
  }
}

BOOL nw_protocol_metadata_matches_definition(uint64_t a1, uint64_t a2)
{
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  void *v8;
  char *v9;
  _BOOL4 v10;
  char *backtrace_string;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
      return nw_protocol_definition_is_equal_unsafe(*(_QWORD *)(a1 + 8), a2);
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_metadata_matches_definition";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v4, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_protocol_metadata_matches_definition";
          v7 = "%{public}s called with null definition";
          goto LABEL_31;
        }
      }
      else
      {
        if (v13)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v5 = objc_claimAutoreleasedReturnValue();
          v6 = type;
          v12 = os_log_type_enabled(v5, type);
          if (backtrace_string)
          {
            if (v12)
            {
              *(_DWORD *)buf = 136446466;
              v16 = "nw_protocol_metadata_matches_definition";
              v17 = 2082;
              v18 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v4)
              return 0;
            goto LABEL_34;
          }
          if (!v12)
            goto LABEL_32;
          *(_DWORD *)buf = 136446210;
          v16 = "nw_protocol_metadata_matches_definition";
          v7 = "%{public}s called with null definition, no backtrace";
          goto LABEL_31;
        }
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_protocol_metadata_matches_definition";
          v7 = "%{public}s called with null definition, backtrace limit exceeded";
          goto LABEL_31;
        }
      }
      goto LABEL_32;
    }
  }
  else
  {
    __nwlog_obj();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_metadata_matches_definition";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v4, &type, &v13))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null metadata";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
LABEL_32:

      goto LABEL_33;
    }
    if (!v13)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    v9 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    v6 = type;
    v10 = os_log_type_enabled(v5, type);
    if (!v9)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_metadata_matches_definition";
        v7 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "nw_protocol_metadata_matches_definition";
      v17 = 2082;
      v18 = v9;
      _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v9);
  }
LABEL_33:
  if (v4)
LABEL_34:
    free(v4);
  return 0;
}

uint64_t ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_83(uint64_t a1, uint64_t a2)
{
  nw_frame_finalize(a2);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return 1;
}

void nw_content_context_set_metadata_for_protocol(nw_content_context_t context, nw_protocol_metadata_t protocol_metadata)
{
  nw_content_context_t v3;
  NSObject *v4;
  NSObject *v5;
  unsigned __int8 *isa;
  NSObject *v7;
  void ***v8;
  void ***v9;
  void ***v10;
  uint64_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  char *v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  os_log_type_t v25;
  _QWORD v26[4];
  NSObject *v27;
  uint64_t *v28;
  os_log_type_t *v29;
  _BYTE *v30;
  os_log_type_t type[8];
  os_log_type_t *v32;
  uint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  void (*v35)(uint64_t);
  id v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  char v40;
  _BYTE buf[24];
  uint64_t (*v42)(uint64_t, uint64_t);
  void (*v43)(uint64_t);
  id v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v3 = context;
  v4 = protocol_metadata;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
    v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v37) = 0;
    if (!__nwlog_fault(v13, type, &v37))
      goto LABEL_53;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if ((_BYTE)v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type[0];
      v20 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_53:
        if (!v13)
          goto LABEL_19;
LABEL_54:
        free(v13);
        goto LABEL_19;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v24 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
        _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_52:

    goto LABEL_53;
  }
  if (v4)
  {
    if (v3 != (nw_content_context_t)&__block_literal_global_5_41741
      && v3 != (nw_content_context_t)&__block_literal_global_4
      && v3 != (nw_content_context_t)&__block_literal_global_3_41726
      && v3 != (nw_content_context_t)&__block_literal_global_41718)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&v3[14]);
      v37 = 0;
      v38 = &v37;
      v39 = 0x2020000000;
      v40 = 0;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v42 = __Block_byref_object_copy__41932;
      v43 = __Block_byref_object_dispose__41933;
      v44 = 0;
      *(_QWORD *)type = 0;
      v32 = type;
      v33 = 0x3032000000;
      v34 = __Block_byref_object_copy__41932;
      v35 = __Block_byref_object_dispose__41933;
      v36 = 0;
      isa = (unsigned __int8 *)v3[11].isa;
      v26[0] = MEMORY[0x1E0C809B0];
      v26[1] = 3221225472;
      v26[2] = __nw_content_context_set_metadata_for_protocol_block_invoke;
      v26[3] = &unk_1E14A1FE8;
      v7 = v5;
      v27 = v7;
      v28 = &v37;
      v29 = type;
      v30 = buf;
      nw_array_apply(isa, (uint64_t)v26);
      if (*((_BYTE *)v38 + 24))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
      }
      else
      {
        v8 = (void ***)v3[11].isa;
        v9 = (void ***)nw_array_create();
        v10 = v9;
        if (v8)
        {
          if (v9 == v8)
            v10 = v8;
          else
            std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>((uint64_t)(v9 + 2), v8[2], v8[3], v8[3] - v8[2]);
          v11 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
          if (v11)
            nw_array_remove_object((uint64_t)v10, v11);
        }
        nw_array_append((uint64_t)v10, v7);
        objc_storeStrong((id *)&v3[11].isa, v10);
        if (nw_protocol_metadata_supports_replies(v7))
          BYTE6(v3[14].isa) |= 0x40u;
        os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);

      }
      _Block_object_dispose(type, 8);

      _Block_object_dispose(buf, 8);
      _Block_object_dispose(&v37, 8);
    }
    goto LABEL_19;
  }
  __nwlog_obj();
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
  v13 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v37) = 0;
  if (!__nwlog_fault(v13, type, &v37))
    goto LABEL_53;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v17 = type[0];
    if (os_log_type_enabled(v14, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
      _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null protocol_metadata", buf, 0xCu);
    }
    goto LABEL_52;
  }
  if (!(_BYTE)v37)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v25 = type[0];
    if (os_log_type_enabled(v14, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
      _os_log_impl(&dword_182FBE000, v14, v25, "%{public}s called with null protocol_metadata, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_52;
  }
  v21 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v14 = objc_claimAutoreleasedReturnValue();
  v22 = type[0];
  v23 = os_log_type_enabled(v14, type[0]);
  if (!v21)
  {
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
      _os_log_impl(&dword_182FBE000, v14, v22, "%{public}s called with null protocol_metadata, no backtrace", buf, 0xCu);
    }
    goto LABEL_52;
  }
  if (v23)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_content_context_set_metadata_for_protocol";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v21;
    _os_log_impl(&dword_182FBE000, v14, v22, "%{public}s called with null protocol_metadata, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v21);
  if (v13)
    goto LABEL_54;
LABEL_19:

}

uint64_t udp_validate_cksum_internal(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, int a5, uint64_t a6)
{
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  NSObject *v27;
  const char *v28;
  const char *v29;
  const char *v30;
  uint64_t v31;
  NSObject *v32;
  const char *v33;
  const char *v34;
  char v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  char *backtrace_string;
  _BOOL4 v45;
  char *v46;
  _BOOL4 v47;
  const char *v48;
  os_log_type_t type[4];
  int v50;
  char v51;
  char v52;
  os_log_type_t v53;
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  void *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  int v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v51 = 0;
  v50 = 0;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v55 = "__nw_frame_get_internet_checksum";
    v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v53 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v36, type, &v53))
      goto LABEL_90;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type[0];
      if (!os_log_type_enabled(v37, type[0]))
        goto LABEL_90;
      *(_DWORD *)buf = 136446210;
      v55 = "__nw_frame_get_internet_checksum";
      v39 = "%{public}s called with null frame";
    }
    else if (v53)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type[0];
      v45 = os_log_type_enabled(v37, type[0]);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v55 = "__nw_frame_get_internet_checksum";
          v56 = 2082;
          v57 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_90;
      }
      if (!v45)
      {
LABEL_90:
        if (v36)
          free(v36);
        goto LABEL_5;
      }
      *(_DWORD *)buf = 136446210;
      v55 = "__nw_frame_get_internet_checksum";
      v39 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v37 = __nwlog_obj();
      v38 = type[0];
      if (!os_log_type_enabled(v37, type[0]))
        goto LABEL_90;
      *(_DWORD *)buf = 136446210;
      v55 = "__nw_frame_get_internet_checksum";
      v39 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v37, v38, v39, buf, 0xCu);
    goto LABEL_90;
  }
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0
    || !g_channel_get_internet_checksum_handler
    || g_channel_get_internet_checksum_handler(a1, &v51, (char *)&v50 + 2, &v50))
  {
    goto LABEL_5;
  }
  v16 = *(unsigned __int16 *)(a1 + 204);
  if ((~v16 & 0x1800) == 0)
  {
    v13 = (unsigned __int16)v50;
    goto LABEL_44;
  }
  if (!v51)
  {
LABEL_5:
    *(_DWORD *)type = 0;
    LOWORD(v50) = ~(unsigned __int16)inet_cksum(a1, 0, a2, (int *)type);
    if (!*(_DWORD *)type)
    {
LABEL_10:
      v12 = a2;
      goto LABEL_11;
    }
    if (a1)
    {
      if ((*(_WORD *)(a1 + 204) & 0x100) == 0
        || !g_channel_check_validity
        || (g_channel_check_validity(a1, *(_QWORD *)(a1 + 88)) & 1) != 0)
      {
        goto LABEL_10;
      }
LABEL_99:
      if (a6)
      {
        *(_QWORD *)(a6 + 64) = 0;
        *(_QWORD *)(a6 + 72) = 0;
      }
      return 0;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v55 = "__nw_frame_check_validity";
    v40 = (char *)_os_log_send_and_compose_impl();
    v53 = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (__nwlog_fault(v40, &v53, &v52))
    {
      if (v53 == OS_LOG_TYPE_FAULT)
      {
        v41 = __nwlog_obj();
        v42 = v53;
        if (!os_log_type_enabled(v41, v53))
          goto LABEL_97;
        *(_DWORD *)buf = 136446210;
        v55 = "__nw_frame_check_validity";
        v43 = "%{public}s called with null frame";
        goto LABEL_96;
      }
      if (!v52)
      {
        v41 = __nwlog_obj();
        v42 = v53;
        if (!os_log_type_enabled(v41, v53))
          goto LABEL_97;
        *(_DWORD *)buf = 136446210;
        v55 = "__nw_frame_check_validity";
        v43 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_96;
      }
      v46 = (char *)__nw_create_backtrace_string();
      v41 = __nwlog_obj();
      v42 = v53;
      v47 = os_log_type_enabled(v41, v53);
      if (v46)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          v55 = "__nw_frame_check_validity";
          v56 = 2082;
          v57 = v46;
          _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v46);
        goto LABEL_97;
      }
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        v55 = "__nw_frame_check_validity";
        v43 = "%{public}s called with null frame, no backtrace";
LABEL_96:
        _os_log_impl(&dword_182FBE000, v41, v42, v43, buf, 0xCu);
      }
    }
LABEL_97:
    if (v40)
      free(v40);
    goto LABEL_99;
  }
  if ((v16 & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a1, *(_QWORD *)(a1 + 88))
    || (v17 = *(_QWORD *)(a1 + 112)) == 0
    || (v18 = *(_DWORD *)(a1 + 48)) == 0)
  {
    v32 = __nwlog_obj();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      goto LABEL_62;
    v48 = "";
    if (a6)
      v48 = (const char *)(a6 + 96);
    *(_DWORD *)buf = 136446466;
    v55 = "udp_validate_cksum_internal";
    v56 = 2082;
    v57 = (void *)v48;
    v34 = "%{public}s %{public}s Frame buffer no longer valid";
    goto LABEL_61;
  }
  v19 = *(_QWORD *)(a1 + 112);
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0
    || (v19 = *(_QWORD *)(a1 + 112), !g_channel_check_validity)
    || g_channel_check_validity(a1, *(_QWORD *)(a1 + 88)) && (v19 = *(_QWORD *)(a1 + 112)) != 0)
  {
    v20 = (unsigned __int16)(v19 + *(_DWORD *)(a1 + 56) - v17);
    v21 = v20 + a2;
    if ((a5 & 1) != 0 || !HIWORD(v50) || HIWORD(v50) == v20)
    {
      if (a5)
      {
        if (HIWORD(v50) == v20 && v18 == v21)
        {
          v12 = 0;
          goto LABEL_12;
        }
      }
      else if (v18 == v21)
      {
        v12 = 0;
        goto LABEL_40;
      }
    }
    v22 = v18 - v21;
    LOWORD(v50) = in_adjust_cksum(v17, v18, HIWORD(v50), v20, a2, (unsigned __int16)v50);
    if (v20 <= HIWORD(v50))
      v12 = v22 - v20 + HIWORD(v50);
    else
      v12 = v22 + v20 - HIWORD(v50);
LABEL_11:
    if (a5)
    {
LABEL_12:
      v13 = in6_pseudo(a3, a4, bswap32(a2 + 17) + (unsigned __int16)v50);
      if (a6)
      {
        if (v12)
        {
          v14 = *(_QWORD *)(a6 + 64);
          if (v14)
          {
            v15 = *(_QWORD *)(v14 + 64) + v12;
            ++*(_QWORD *)(v14 + 56);
            *(_QWORD *)(v14 + 64) = v15;
          }
        }
      }
      goto LABEL_44;
    }
LABEL_40:
    v23 = *(unsigned int *)a4 + (unint64_t)*(unsigned int *)a3 + bswap32(a2 + 17) + (unsigned __int16)v50;
    LODWORD(v23) = ((WORD1(v23) + (unsigned __int16)v23 + HIDWORD(v23)) >> 16)
                 + (unsigned __int16)(WORD1(v23) + v23 + WORD2(v23));
    v13 = (unsigned __int16)(((WORD1(v23) + (unsigned __int16)v23) >> 16)
                           + WORD1(v23)
                           + v23
                           + ((((WORD1(v23) + (unsigned __int16)v23) >> 16)
                             + (unsigned __int16)(WORD1(v23) + v23)) >> 16));
    if (a6)
    {
      if (v12)
      {
        v24 = *(_QWORD *)(a6 + 64);
        if (v24)
        {
          v25 = *(_QWORD *)(v24 + 48) + v12;
          ++*(_QWORD *)(v24 + 40);
          *(_QWORD *)(v24 + 48) = v25;
        }
      }
    }
LABEL_44:
    LOWORD(v50) = ~(_WORD)v13;
    if (v13 == 0xFFFF)
      return 1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v27 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v28 = (const char *)(a6 + 96);
      if (!a6)
        v28 = "";
      *(_DWORD *)buf = 136447490;
      v55 = "udp_validate_cksum_internal";
      v56 = 2082;
      v57 = (void *)v28;
      v29 = "IPv6";
      if (!a5)
        v29 = "IPv4";
      v58 = 2082;
      v59 = v29;
      v30 = "non-offload";
      v60 = 2082;
      if (v51)
        v30 = "offload";
      v61 = v30;
      v62 = 1024;
      v63 = (unsigned __int16)v50;
      v64 = 1024;
      v65 = a2;
      _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp incorrect %{public}s-UDP %{public}s checksum 0x%x ulen %u", buf, 0x36u);
    }
    if (a6)
    {
      v31 = *(_QWORD *)(a6 + 64);
      if (v31)
      {
        result = 0;
        ++*(_QWORD *)(v31 + 16);
        return result;
      }
    }
    return 0;
  }
  v32 = __nwlog_obj();
  if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
  {
    v33 = "";
    if (a6)
      v33 = (const char *)(a6 + 96);
    *(_DWORD *)buf = 136446466;
    v55 = "udp_validate_cksum_internal";
    v56 = 2082;
    v57 = (void *)v33;
    v34 = "%{public}s %{public}s Frame buffer no longer valid for UDP";
LABEL_61:
    _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_INFO, v34, buf, 0x16u);
  }
LABEL_62:
  result = 0;
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0)
  {
    if (g_channel_check_validity)
    {
      v35 = g_channel_check_validity(a1, *(_QWORD *)(a1 + 88));
      result = 0;
      if (a6)
      {
        if ((v35 & 1) == 0)
        {
          result = 0;
          *(_QWORD *)(a6 + 64) = 0;
          *(_QWORD *)(a6 + 72) = 0;
        }
      }
    }
  }
  return result;
}

uint64_t nw_protocol_metadata_supports_replies(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 1);
    if (v3)
    {
      v4 = (*(unsigned __int8 *)(v3 + 184) >> 1) & 1;
      goto LABEL_4;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_metadata_supports_replies";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null metadata->definition", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v19)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null metadata->definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null metadata->definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_protocol_metadata_supports_replies";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null metadata->definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_metadata_supports_replies";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v19)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_protocol_metadata_supports_replies";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_4:

  return v4;
}

BOOL nw_array_remove_object(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  char *v7;
  _BOOL8 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  char *backtrace_string;
  uint64_t v24;
  _BOOL4 v25;
  const char *v26;
  uint64_t v27;
  _BOOL4 v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj(0, a2);
    *(_DWORD *)buf = 136446210;
    v32 = "nw_array_remove_object";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    v16 = __nwlog_fault(v7, &type, &v29);
    if (!(_DWORD)v16)
      goto LABEL_51;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v29)
      {
        v18 = __nwlog_obj(v16, v17);
        v19 = type;
        if (!os_log_type_enabled(v18, type))
          goto LABEL_51;
        *(_DWORD *)buf = 136446210;
        v32 = "nw_array_remove_object";
        v20 = "%{public}s called with null array, backtrace limit exceeded";
        goto LABEL_50;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj(backtrace_string, v24);
      v19 = type;
      v25 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (!v25)
          goto LABEL_51;
        *(_DWORD *)buf = 136446210;
        v32 = "nw_array_remove_object";
        v20 = "%{public}s called with null array, no backtrace";
        goto LABEL_50;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        v32 = "nw_array_remove_object";
        v33 = 2082;
        v34 = backtrace_string;
        v26 = "%{public}s called with null array, dumping backtrace:%{public}s";
LABEL_40:
        _os_log_impl(&dword_182FBE000, v18, v19, v26, buf, 0x16u);
      }
LABEL_41:
      free(backtrace_string);
      goto LABEL_51;
    }
    v18 = __nwlog_obj(v16, v17);
    v19 = type;
    if (!os_log_type_enabled(v18, type))
      goto LABEL_51;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_array_remove_object";
    v20 = "%{public}s called with null array";
LABEL_50:
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
LABEL_51:
    if (!v7)
      return 0;
    goto LABEL_10;
  }
  if (!a2)
  {
    __nwlog_obj(a1, 0);
    *(_DWORD *)buf = 136446210;
    v32 = "nw_array_remove_object";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    v21 = __nwlog_fault(v7, &type, &v29);
    if (!(_DWORD)v21)
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj(v21, v22);
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_51;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_array_remove_object";
      v20 = "%{public}s called with null object";
      goto LABEL_50;
    }
    if (!v29)
    {
      v18 = __nwlog_obj(v21, v22);
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_51;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_array_remove_object";
      v20 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_50;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj(backtrace_string, v27);
    v19 = type;
    v28 = os_log_type_enabled(v18, type);
    if (backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        v32 = "nw_array_remove_object";
        v33 = 2082;
        v34 = backtrace_string;
        v26 = "%{public}s called with null object, dumping backtrace:%{public}s";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    if (!v28)
      goto LABEL_51;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_array_remove_object";
    v20 = "%{public}s called with null object, no backtrace";
    goto LABEL_50;
  }
  v4 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  if (v4 != v3)
  {
    while (*(_QWORD *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v3)
      {
        v4 = *(_QWORD *)(a1 + 24);
        break;
      }
    }
  }
  if (v4 == v3)
    return 0;
  if (!atomic_load((unsigned __int8 *)(a1 + 40)))
  {
    v9 = v4 + 8;
    v10 = *(_QWORD *)(a1 + 24);
    if (v4 + 8 == v10)
    {
      if (v9 == v4)
      {
LABEL_23:
        *(_QWORD *)(a1 + 24) = v4;
        return 1;
      }
    }
    else
    {
      do
      {
        if (*(_QWORD *)v4)
          os_release(*(void **)v4);
        v11 = v4 + 8;
        *(_QWORD *)v4 = *(_QWORD *)(v4 + 8);
        *(_QWORD *)(v4 + 8) = 0;
        v12 = v4 + 16;
        v4 += 8;
      }
      while (v12 != v10);
      v9 = *(_QWORD *)(a1 + 24);
      v4 = v11;
      if (v9 == v11)
        goto LABEL_23;
    }
    v13 = v9;
    do
    {
      v15 = *(void **)(v13 - 8);
      v13 -= 8;
      v14 = v15;
      if (v15)
        os_release(v14);
      *(_QWORD *)(v9 - 8) = 0;
      v9 = v13;
    }
    while (v13 != v4);
    goto LABEL_23;
  }
  v6 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v6);
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v32 = "nw_array_remove_object";
  v7 = (char *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
LABEL_10:
    free(v7);
    return 0;
  }
  __break(1u);
  return result;
}

id *nw_flow_copy_write_request(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  id v4;
  void *v5;
  void *v6;
  id *v7;
  id *v8;
  os_unfair_lock_s *v9;
  os_unfair_lock_s *v10;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int minimize_logging;
  char logging_disabled;
  NSObject *v21;
  const char *v22;
  const char *v23;
  nw_endpoint_t v24;
  const char *v25;
  const char *v26;
  id v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  id v31;
  int v32;
  char v33;
  NSObject *v34;
  const char *v35;
  const char *v36;
  NSObject *v37;
  nw_endpoint_t v38;
  const char *v39;
  const char *v40;
  const char *v41;
  id v42;
  id *v43;
  char v44;
  const char *v45;
  const char *v46;
  nw_endpoint_t v47;
  const char *v48;
  const char *v49;
  const char *v50;
  id v51;
  void *v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  const char *v57;
  nw_endpoint_t v58;
  const char *v59;
  const char *v60;
  const char *v61;
  id v62;
  char *backtrace_string;
  NSObject *v64;
  os_log_type_t v65;
  _BOOL4 v66;
  os_log_type_t v67;
  const char *id_string;
  const char *v69;
  nw_endpoint_t v70;
  const char *logging_description;
  const char *v72;
  id v73;
  const char *log;
  NSObject *loga;
  const char *logb;
  void *v78;
  uint64_t v79;
  id v82;
  id *v83;
  char v84;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v87;
  __int16 v88;
  void *v89;
  __int16 v90;
  const char *v91;
  __int16 v92;
  const char *v93;
  __int16 v94;
  const char *v95;
  __int16 v96;
  const char *v97;
  __int16 v98;
  id v99;
  __int16 v100;
  os_unfair_lock_s *v101;
  uint64_t v102;

  v3 = a1;
  v102 = *MEMORY[0x1E0C80C00];
  v4 = *(id *)(a1 + 160);
  v78 = v4;
  v79 = v3;
  v5 = *(void **)(v3 + 192);
  v6 = *(void **)(v3 + 200);
  if (!v5)
    goto LABEL_4;
LABEL_2:
  if (!v6)
    goto LABEL_7;
  while (1)
  {
    v7 = nw_write_request_copy_next_incomplete_request(v6, (*(_DWORD *)(a2 + 4) & 2) != 0, (*(unsigned __int16 *)(v3 + 332) >> 1) & 1, *(void **)(v3 + 224));
    if (!v7)
      break;
LABEL_8:
    v8 = v7;
    v82 = v8[8];
    v83 = v8;

    if (v82)
    {
      v9 = (os_unfair_lock_s *)v82;
      v10 = v9;
      if (a3)
      {
        if (v9 != (os_unfair_lock_s *)&__block_literal_global_5_41741
          && v9 != (os_unfair_lock_s *)&__block_literal_global_4
          && v9 != (os_unfair_lock_s *)&__block_literal_global_3_41726
          && v9 != (os_unfair_lock_s *)&__block_literal_global_41718)
        {
          *a3 = 0;
          if ((v9[29]._os_unfair_lock_opaque & 0x10000) == 0)
          {
            os_unfair_lock_lock(v9 + 28);
            v14 = *(_QWORD *)&v10[16]._os_unfair_lock_opaque;
            if (v14)
            {
              if ((v10[29]._os_unfair_lock_opaque & 0x20000) == 0)
              {
                BYTE2(v10[29]._os_unfair_lock_opaque) |= 2u;
                v15 = *(_QWORD *)&v10[18]._os_unfair_lock_opaque;
                v16 = mach_absolute_time();
                v17 = nw_delta_nanos(v15, v16);
                v18 = (v17 / 0xF4240);
                if (v17 > 0xF423FFFFFFFFFLL)
                  v18 = 0xFFFFFFFFLL;
                v14 = *(_QWORD *)&v10[16]._os_unfair_lock_opaque;
                if (v14 < v18)
                {
                  os_unfair_lock_unlock(v10 + 28);

                  minimize_logging = nw_endpoint_handler_get_minimize_logging(v4);
                  logging_disabled = nw_endpoint_handler_get_logging_disabled(v4);
                  if (minimize_logging)
                  {
                    if ((logging_disabled & 1) != 0)
                    {
LABEL_87:
                      v28 = 60;
                      goto LABEL_55;
                    }
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v21 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v4);
                      v69 = nw_endpoint_handler_dry_run_string(v4);
                      v70 = nw_endpoint_handler_copy_endpoint(v4);
                      logging_description = nw_endpoint_get_logging_description(v70);
                      v72 = nw_endpoint_handler_state_string(v4);
                      logb = nw_endpoint_handler_mode_string(v4);
                      v73 = nw_endpoint_handler_copy_current_path(v4);
                      *(_DWORD *)buf = 136448002;
                      v87 = "nw_flow_copy_write_request";
                      v88 = 2082;
                      v89 = (void *)id_string;
                      v90 = 2082;
                      v91 = v69;
                      v92 = 2082;
                      v93 = logging_description;
                      v94 = 2082;
                      v95 = v72;
                      v96 = 2082;
                      v97 = logb;
                      v98 = 2114;
                      v99 = v73;
                      v100 = 2112;
                      v101 = v10;
                      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ is expired, failing request", buf, 0x52u);

                    }
                  }
                  else
                  {
                    if ((logging_disabled & 1) != 0)
                      goto LABEL_87;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v21 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
                    {
                      v22 = nw_endpoint_handler_get_id_string(v4);
                      v23 = nw_endpoint_handler_dry_run_string(v4);
                      v24 = nw_endpoint_handler_copy_endpoint(v4);
                      v25 = nw_endpoint_get_logging_description(v24);
                      v26 = nw_endpoint_handler_state_string(v4);
                      log = nw_endpoint_handler_mode_string(v4);
                      v27 = nw_endpoint_handler_copy_current_path(v4);
                      *(_DWORD *)buf = 136448002;
                      v87 = "nw_flow_copy_write_request";
                      v88 = 2082;
                      v89 = (void *)v22;
                      v90 = 2082;
                      v91 = v23;
                      v92 = 2082;
                      v93 = v25;
                      v94 = 2082;
                      v95 = v26;
                      v96 = 2082;
                      v97 = log;
                      v98 = 2114;
                      v99 = v27;
                      v100 = 2112;
                      v101 = v10;
                      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ is expired, failing request", buf, 0x52u);

                    }
                  }
                  v28 = 60;
                  goto LABEL_54;
                }
              }
              v29 = *(_QWORD *)&v10[18]._os_unfair_lock_opaque;
              v30 = dword_1ECD84D64;
              if (!dword_1ECD84D64)
              {
                mach_timebase_info((mach_timebase_info_t)&time_base);
                v30 = dword_1ECD84D64;
              }
              *a3 = 1000000 * v14 * v30 / time_base + v29;
            }
            os_unfair_lock_unlock(v10 + 28);
          }
        }
        goto LABEL_37;
      }
      __nwlog_obj();
      v52 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v87 = "nw_content_context_is_expired";
      v53 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v84 = 0;
      if (__nwlog_fault(v53, &type, &v84))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v54 = objc_claimAutoreleasedReturnValue();
          v55 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_content_context_is_expired";
            _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s called with null expire_time", buf, 0xCu);
          }
          goto LABEL_62;
        }
        if (v84)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v64 = objc_claimAutoreleasedReturnValue();
          v65 = type;
          v66 = os_log_type_enabled(v64, type);
          if (backtrace_string)
          {
            if (v66)
            {
              *(_DWORD *)buf = 136446466;
              v87 = "nw_content_context_is_expired";
              v88 = 2082;
              v89 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s called with null expire_time, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v66)
            {
              *(_DWORD *)buf = 136446210;
              v87 = "nw_content_context_is_expired";
              _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s called with null expire_time, no backtrace", buf, 0xCu);
            }

          }
        }
        else
        {
          __nwlog_obj();
          v54 = objc_claimAutoreleasedReturnValue();
          v67 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_content_context_is_expired";
            _os_log_impl(&dword_182FBE000, v54, v67, "%{public}s called with null expire_time, backtrace limit exceeded", buf, 0xCu);
          }
LABEL_62:

        }
      }
      if (v53)
        free(v53);
LABEL_37:

      v31 = nw_content_context_copy_error(v10);
      if (v31)
      {
        v32 = nw_endpoint_handler_get_minimize_logging(v4);
        v33 = nw_endpoint_handler_get_logging_disabled(v4);
        if (v32)
        {
          if ((v33 & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v34 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              v56 = nw_endpoint_handler_get_id_string(v4);
              v57 = nw_endpoint_handler_dry_run_string(v4);
              loga = v34;
              v58 = nw_endpoint_handler_copy_endpoint(v4);
              v59 = nw_endpoint_get_logging_description(v58);
              v60 = nw_endpoint_handler_state_string(v4);
              v61 = nw_endpoint_handler_mode_string(v4);
              v62 = nw_endpoint_handler_copy_current_path(v4);
              *(_DWORD *)buf = 136448002;
              v87 = "nw_flow_copy_write_request";
              v88 = 2082;
              v89 = (void *)v56;
              v90 = 2082;
              v91 = v57;
              v92 = 2082;
              v93 = v59;
              v94 = 2082;
              v95 = v60;
              v96 = 2082;
              v97 = v61;
              v98 = 2114;
              v99 = v62;
              v100 = 2112;
              v101 = v10;
              v34 = loga;
              _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ has antecedent error, failing request", buf, 0x52u);

            }
LABEL_44:

          }
        }
        else if ((v33 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v34 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
          {
            v35 = nw_endpoint_handler_get_id_string(v4);
            v36 = nw_endpoint_handler_dry_run_string(v4);
            v37 = v34;
            v38 = nw_endpoint_handler_copy_endpoint(v4);
            v39 = nw_endpoint_get_logging_description(v38);
            v40 = nw_endpoint_handler_state_string(v4);
            v41 = nw_endpoint_handler_mode_string(v4);
            v42 = nw_endpoint_handler_copy_current_path(v78);
            *(_DWORD *)buf = 136448002;
            v87 = "nw_flow_copy_write_request";
            v88 = 2082;
            v89 = (void *)v35;
            v90 = 2082;
            v91 = v36;
            v92 = 2082;
            v93 = v39;
            v94 = 2082;
            v95 = v40;
            v96 = 2082;
            v97 = v41;
            v4 = v78;
            v98 = 2114;
            v99 = v42;
            v100 = 2112;
            v101 = v10;
            v34 = v37;
            _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ has antecedent error, failing request", buf, 0x52u);

          }
          goto LABEL_44;
        }
        nw_write_request_report_error_with_override(v83, 0, v31);

        goto LABEL_56;
      }
    }
    if ((*(_BYTE *)(a2 + 4) & 1) == 0)
      goto LABEL_90;
    v43 = v83;
    v44 = *((_BYTE *)v43 + 128);

    if ((v44 & 1) != 0)
    {
      v83 = v43;
LABEL_90:

      goto LABEL_91;
    }
    if ((nw_endpoint_handler_get_logging_disabled(v4) & 1) != 0)
    {
      v28 = 45;
      goto LABEL_55;
    }
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v21 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v45 = nw_endpoint_handler_get_id_string(v4);
      v46 = nw_endpoint_handler_dry_run_string(v4);
      v47 = nw_endpoint_handler_copy_endpoint(v4);
      v48 = nw_endpoint_get_logging_description(v47);
      v49 = nw_endpoint_handler_state_string(v4);
      v50 = nw_endpoint_handler_mode_string(v4);
      v51 = nw_endpoint_handler_copy_current_path(v78);
      *(_DWORD *)buf = 136447746;
      v87 = "nw_flow_copy_write_request";
      v88 = 2082;
      v89 = (void *)v45;
      v90 = 2082;
      v91 = v46;
      v92 = 2082;
      v93 = v48;
      v94 = 2082;
      v95 = v49;
      v96 = 2082;
      v97 = v50;
      v4 = v78;
      v98 = 2114;
      v99 = v51;
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Protocol does not support sending incomplete send content", buf, 0x48u);

    }
    v28 = 45;
LABEL_54:

LABEL_55:
    nw_write_request_fail(v83, v28);
LABEL_56:

    v3 = v79;
    v5 = *(void **)(v79 + 192);
    v6 = *(void **)(v79 + 200);
    if (v5)
      goto LABEL_2;
LABEL_4:
    if (!v6)
      goto LABEL_88;
  }
  v5 = *(void **)(v3 + 192);
  if (!v5)
    goto LABEL_88;
LABEL_7:
  v7 = nw_write_request_copy_next_incomplete_request(v5, (*(_DWORD *)(a2 + 4) & 2) != 0, (*(unsigned __int16 *)(v3 + 332) >> 1) & 1, *(void **)(v3 + 224));
  if (v7)
    goto LABEL_8;
LABEL_88:
  v83 = 0;
LABEL_91:

  return v83;
}

void sub_18303B4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

id *nw_write_request_copy_next_incomplete_request(void *a1, char a2, int a3, void *a4)
{
  id *v7;
  id v8;
  id *v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  if (!v7)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_write_request_copy_next_incomplete_request";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null request", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_write_request_copy_next_incomplete_request";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_39:
    if (v12)
      free(v12);
    v9 = 0;
    goto LABEL_15;
  }
  if (a3 && (a2 & 1) == 0)
  {
    while (((_BYTE)v7[16] & 2) != 0
         || !v7[7] && !v7[9]
         || nw_content_context_is_blocked_by_antecedents(v7[8])
         || v7[8] != v8)
    {
      v9 = (id *)v7[1];

      v7 = v9;
      if (!v9)
        goto LABEL_14;
    }
  }
  else
  {
    while (((_BYTE)v7[16] & 2) != 0 || !v7[7] && !v7[9] || nw_content_context_is_blocked_by_antecedents(v7[8]))
    {
      v9 = (id *)v7[1];

      v7 = v9;
      if (!v9)
        goto LABEL_14;
    }
  }
  if (v7[7] || v7[9])
  {
    v7 = v7;
    v9 = v7;
  }
  else
  {
    v9 = 0;
  }
LABEL_14:

LABEL_15:
  return v9;
}

BOOL nw_content_context_is_blocked_by_antecedents(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = 0;
    if (v1 != (os_unfair_lock_s *)&__block_literal_global_5_41741
      && v1 != (os_unfair_lock_s *)&__block_literal_global_4
      && v1 != (os_unfair_lock_s *)&__block_literal_global_3_41726
      && v1 != (os_unfair_lock_s *)&__block_literal_global_41718)
    {
      os_unfair_lock_lock(v1 + 28);
      v4 = *(_QWORD *)&v2[14]._os_unfair_lock_opaque;
      if (v4)
        v3 = (*(_BYTE *)(v4 + 118) & 4) == 0;
      else
        v3 = 0;
      os_unfair_lock_unlock(v2 + 28);
    }
    goto LABEL_10;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_content_context_is_blocked_by_antecedents";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_content_context_is_blocked_by_antecedents";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_27:
  if (v7)
    free(v7);
  v3 = 0;
LABEL_10:

  return v3;
}

id nw_content_context_copy_error(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v6;

  v1 = a1;
  v2 = v1;
  if (v1 == (os_unfair_lock_s *)&__block_literal_global_5_41741
    || v1 == (os_unfair_lock_s *)&__block_literal_global_4
    || v1 == (os_unfair_lock_s *)&__block_literal_global_3_41726
    || v1 == (os_unfair_lock_s *)&__block_literal_global_41718)
  {
    v6 = 0;
  }
  else
  {
    os_unfair_lock_lock(v1 + 28);
    v6 = *(id *)&v2[24]._os_unfair_lock_opaque;
    if (!v6)
    {
      if (*(_QWORD *)&v2[14]._os_unfair_lock_opaque)
        v6 = (id)nw_content_context_copy_error();
      else
        v6 = 0;
    }
    os_unfair_lock_unlock(v2 + 28);
  }

  return v6;
}

void sub_18303BCB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_data_set_ecn_flag(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 186) = *((_BYTE *)v3 + 186) & 0xFC | a2 & 3;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_data_set_ecn_flag";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_data_set_ecn_flag";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null data", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_data_set_ecn_flag";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_data_set_ecn_flag";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_data_set_ecn_flag";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t sub_18303BFDC(_QWORD *a1)
{
  if (*a1 != -1)
    swift_once();
  return swift_retain();
}

unsigned __int8 *nw_parameters_copy_protocol_options(void *a1, void *a2, _DWORD *a3)
{
  id v5;
  id v6;
  void *v7;
  unsigned __int8 *v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (v5)
  {
    if (v6)
    {
      v8 = nw_parameters_copy_protocol_options_internal(v5, v6, a3);
      goto LABEL_4;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_parameters_copy_protocol_options";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null protocol_instance", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null protocol_instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null protocol_instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_parameters_copy_protocol_options";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null protocol_instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_parameters_copy_protocol_options";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null parameters", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_parameters_copy_protocol_options";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v11)
    free(v11);
  v8 = 0;
LABEL_4:

  return v8;
}

void sub_18303C4D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_get_parameters(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  void (**v10)(_QWORD);
  const void *v11;
  const char *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  _BOOL4 v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  const char *v27;
  const char *v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  void *v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v32 = "__nw_protocol_get_parameters";
    v18 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v18, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "__nw_protocol_get_parameters";
          v21 = "%{public}s called with null protocol";
LABEL_59:
          _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v19 = __nwlog_obj();
        v20 = type;
        v26 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "__nw_protocol_get_parameters";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_60;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "__nw_protocol_get_parameters";
          v21 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_59;
        }
      }
      else
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "__nw_protocol_get_parameters";
          v21 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_59;
        }
      }
    }
LABEL_60:
    if (v18)
      free(v18);
    return 0;
  }
  v2 = *(void **)(a1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(a1 + 88);
    if (v3)
      *(_QWORD *)(a1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 112);
    if (v5)
    {
      v6 = v5(a1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_8;
    }
  }
  __nwlog_obj();
  v12 = *(const char **)(a1 + 16);
  *(_DWORD *)buf = 136446722;
  v32 = "__nw_protocol_get_parameters";
  if (!v12)
    v12 = "invalid";
  v33 = 2082;
  v34 = (void *)v12;
  v35 = 2048;
  v36 = a1;
  v13 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v29 = 0;
  if (!__nwlog_fault(v13, &type, &v29))
    goto LABEL_51;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_51;
    v16 = *(const char **)(a1 + 16);
    if (!v16)
      v16 = "invalid";
    *(_DWORD *)buf = 136446722;
    v32 = "__nw_protocol_get_parameters";
    v33 = 2082;
    v34 = (void *)v16;
    v35 = 2048;
    v36 = a1;
    v17 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_50:
    _os_log_impl(&dword_182FBE000, v14, v15, v17, buf, 0x20u);
    goto LABEL_51;
  }
  if (!v29)
  {
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_51;
    v27 = *(const char **)(a1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446722;
    v32 = "__nw_protocol_get_parameters";
    v33 = 2082;
    v34 = (void *)v27;
    v35 = 2048;
    v36 = a1;
    v17 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_50;
  }
  v22 = (char *)__nw_create_backtrace_string();
  v14 = __nwlog_obj();
  v15 = type;
  v23 = os_log_type_enabled(v14, type);
  if (!v22)
  {
    if (!v23)
      goto LABEL_51;
    v28 = *(const char **)(a1 + 16);
    if (!v28)
      v28 = "invalid";
    *(_DWORD *)buf = 136446722;
    v32 = "__nw_protocol_get_parameters";
    v33 = 2082;
    v34 = (void *)v28;
    v35 = 2048;
    v36 = a1;
    v17 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_50;
  }
  if (v23)
  {
    v24 = *(const char **)(a1 + 16);
    if (!v24)
      v24 = "invalid";
    *(_DWORD *)buf = 136446978;
    v32 = "__nw_protocol_get_parameters";
    v33 = 2082;
    v34 = (void *)v24;
    v35 = 2048;
    v36 = a1;
    v37 = 2082;
    v38 = v22;
    _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v22);
LABEL_51:
  if (v13)
    free(v13);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_8:
    if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v8 = *(_QWORD *)(a1 + 88);
      if (v8)
      {
        v9 = v8 - 1;
        *(_QWORD *)(a1 + 88) = v9;
        if (!v9)
        {
          v10 = *(void (***)(_QWORD))(a1 + 64);
          if (v10)
          {
            *(_QWORD *)(a1 + 64) = 0;
            v10[2](v10);
            _Block_release(v10);
          }
          if ((*(_BYTE *)(a1 + 72) & 1) != 0)
          {
            v11 = *(const void **)(a1 + 64);
            if (v11)
              _Block_release(v11);
          }
          free((void *)a1);
        }
      }
    }
  }
  return v6;
}

id nw_flow_get_parameters(nw_protocol *a1)
{
  return *((id *)a1->handle + 22);
}

unsigned __int8 *nw_parameters_copy_protocol_options_legacy(void *a1, nw_protocol *a2)
{
  id v3;
  NWConcrete_nw_protocol_instance_stub *v4;
  unsigned __int8 *v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (v3)
  {
    if (a2)
    {
      v4 = nw_protocol_instance_stub_create(a2);
      v5 = nw_parameters_copy_protocol_options_internal(v3, v4, 0);

      goto LABEL_4;
    }
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_parameters_copy_protocol_options_legacy";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null protocol_handle", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v20)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null protocol_handle, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null protocol_handle, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_parameters_copy_protocol_options_legacy";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null protocol_handle, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_parameters_copy_protocol_options_legacy";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v20)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_parameters_copy_protocol_options_legacy";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v8)
    free(v8);
  v5 = 0;
LABEL_4:

  return v5;
}

void sub_18303CF04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_options_get_protocol_handle(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_options_get_protocol_handle";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_get_protocol_handle";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_options_get_protocol_handle";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_get_protocol_handle";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_get_protocol_handle";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

NWConcrete_nw_protocol_instance_stub *nw_protocol_instance_stub_create(nw_protocol *a1)
{
  NWConcrete_nw_protocol_instance_stub *result;
  id v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  objc_super v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  result = [NWConcrete_nw_protocol_instance_stub alloc];
  if (!result)
    return result;
  v13.receiver = result;
  v13.super_class = (Class)NWConcrete_nw_protocol_instance_stub;
  result = (NWConcrete_nw_protocol_instance_stub *)-[nw_protocol init](&v13, sel_init);
  if (result)
  {
    result->protocol = a1;
    return result;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s [super init] failed", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v4)
    free(v4);
  return 0;
}

uint64_t nw_flow_supports_external_data(nw_protocol *a1)
{
  return 1;
}

uint64_t nw_protocol_default_supports_external_data(nw_protocol *a1)
{
  return 0;
}

void __nw_queue_context_create_source_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void **v3;
  void *v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    (*(void (**)(void))(v2 + 16))();
  v3 = *(void ***)(a1 + 40);
  v4 = *v3;
  *v3 = 0;

  free(v3);
}

void ___ZL34nw_socket_init_socket_event_sourceP9nw_socketj_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  char v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void (**v8)(_QWORD);
  const void *v9;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v3 = *(_BYTE *)(v2 + 48);
  if ((v3 & 1) != 0)
  {
    v4 = *(void **)(v2 + 40);
    if (v4)
    {
      os_release(v4);
      v3 = *(_BYTE *)(v2 + 48);
    }
  }
  *(_QWORD *)(v2 + 40) = 0;
  *(_BYTE *)(v2 + 48) = v3 | 1;
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v5)
  {
    if (*(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
    {
      v6 = *(_QWORD *)(v5 + 88);
      if (v6)
      {
        v7 = v6 - 1;
        *(_QWORD *)(v5 + 88) = v7;
        if (!v7)
        {
          v8 = *(void (***)(_QWORD))(v5 + 64);
          if (v8)
          {
            *(_QWORD *)(v5 + 64) = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if ((*(_BYTE *)(v5 + 72) & 1) != 0)
          {
            v9 = *(const void **)(v5 + 64);
            if (v9)
              _Block_release(v9);
          }
          free((void *)v5);
        }
      }
    }
  }
}

void ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  char v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void (**v8)(_QWORD);
  const void *v9;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v3 = *(_BYTE *)(v2 + 48);
  if ((v3 & 1) != 0)
  {
    v4 = *(void **)(v2 + 40);
    if (v4)
    {
      os_release(v4);
      v3 = *(_BYTE *)(v2 + 48);
    }
  }
  *(_QWORD *)(v2 + 40) = 0;
  *(_BYTE *)(v2 + 48) = v3 | 1;
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v5)
  {
    if (*(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
    {
      v6 = *(_QWORD *)(v5 + 88);
      if (v6)
      {
        v7 = v6 - 1;
        *(_QWORD *)(v5 + 88) = v7;
        if (!v7)
        {
          v8 = *(void (***)(_QWORD))(v5 + 64);
          if (v8)
          {
            *(_QWORD *)(v5 + 64) = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if ((*(_BYTE *)(v5 + 72) & 1) != 0)
          {
            v9 = *(const void **)(v5 + 64);
            if (v9)
              _Block_release(v9);
          }
          free((void *)v5);
        }
      }
    }
  }
}

void ___ZL29nw_socket_setup_output_eventsP9nw_socket_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  char v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void (**v8)(_QWORD);
  const void *v9;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v3 = *(_BYTE *)(v2 + 48);
  if ((v3 & 1) != 0)
  {
    v4 = *(void **)(v2 + 40);
    if (v4)
    {
      os_release(v4);
      v3 = *(_BYTE *)(v2 + 48);
    }
  }
  *(_QWORD *)(v2 + 40) = 0;
  *(_BYTE *)(v2 + 48) = v3 | 1;
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v5)
  {
    if (*(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
    {
      v6 = *(_QWORD *)(v5 + 88);
      if (v6)
      {
        v7 = v6 - 1;
        *(_QWORD *)(v5 + 88) = v7;
        if (!v7)
        {
          v8 = *(void (***)(_QWORD))(v5 + 64);
          if (v8)
          {
            *(_QWORD *)(v5 + 64) = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if ((*(_BYTE *)(v5 + 72) & 1) != 0)
          {
            v9 = *(const void **)(v5 + 64);
            if (v9)
              _Block_release(v9);
          }
          free((void *)v5);
        }
      }
    }
  }
}

void sub_18303D7F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)NWConcrete_nw_fd_wrapper;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_fd_wrapper_close(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  int os_unfair_lock_opaque;
  NSObject *v4;
  int v5;
  id v6;
  uint32_t v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint32_t v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  uint32_t v16;
  os_log_type_t v17;
  uint32_t v18;
  uint32_t v19;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  _BYTE v33[10];
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    os_unfair_lock_opaque = v2[2]._os_unfair_lock_opaque;
    if ((v2[6]._os_unfair_lock_opaque & 1) == 0)
    {
      if (os_unfair_lock_opaque < 0)
      {
LABEL_20:
        os_unfair_lock_unlock(v2 + 3);
        goto LABEL_21;
      }
      close(os_unfair_lock_opaque);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_fd_wrapper_close";
        v32 = 2114;
        *(_QWORD *)v33 = v2;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, "%{public}s closed %{public}@", buf, 0x16u);
      }

LABEL_19:
      v2[2]._os_unfair_lock_opaque = -1;
      goto LABEL_20;
    }
    if (!guarded_close_np())
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_fd_wrapper_close";
        v32 = 2114;
        *(_QWORD *)v33 = v2;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s closed %{public}@", buf, 0x16u);
      }

      goto LABEL_18;
    }
    v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    v7 = v2[2]._os_unfair_lock_opaque;
    *(_DWORD *)buf = 136446722;
    v31 = "nw_fd_wrapper_close";
    v32 = 1024;
    *(_DWORD *)v33 = v7;
    *(_WORD *)&v33[4] = 1024;
    *(_DWORD *)&v33[6] = v5;
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v8, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          v11 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v31 = "nw_fd_wrapper_close";
          v32 = 1024;
          *(_DWORD *)v33 = v11;
          *(_WORD *)&v33[4] = 1024;
          *(_DWORD *)&v33[6] = v5;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s Failed to close guarded fd %d %{darwin.errno}d", buf, 0x18u);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v14 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            v16 = v2[2]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446978;
            v31 = "nw_fd_wrapper_close";
            v32 = 1024;
            *(_DWORD *)v33 = v16;
            *(_WORD *)&v33[4] = 1024;
            *(_DWORD *)&v33[6] = v5;
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s Failed to close guarded fd %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          if (!v8)
            goto LABEL_18;
          goto LABEL_14;
        }
        if (v15)
        {
          v19 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v31 = "nw_fd_wrapper_close";
          v32 = 1024;
          *(_DWORD *)v33 = v19;
          *(_WORD *)&v33[4] = 1024;
          *(_DWORD *)&v33[6] = v5;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s Failed to close guarded fd %d %{darwin.errno}d, no backtrace", buf, 0x18u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v9, type))
        {
          v18 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v31 = "nw_fd_wrapper_close";
          v32 = 1024;
          *(_DWORD *)v33 = v18;
          *(_WORD *)&v33[4] = 1024;
          *(_DWORD *)&v33[6] = v5;
          _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s Failed to close guarded fd %d %{darwin.errno}d, backtrace limit exceeded", buf, 0x18u);
        }
      }

    }
    if (!v8)
    {
LABEL_18:
      LOBYTE(v2[6]._os_unfair_lock_opaque) &= ~1u;
      goto LABEL_19;
    }
LABEL_14:
    free(v8);
    goto LABEL_18;
  }
  __nwlog_obj();
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v31 = "nw_fd_wrapper_close";
  v21 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (__nwlog_fault(v21, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_fd_wrapper_close";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null wrapper", buf, 0xCu);
      }
    }
    else if (v28)
    {
      v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v22, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_fd_wrapper_close";
          v32 = 2082;
          *(_QWORD *)v33 = v24;
          _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        goto LABEL_50;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_fd_wrapper_close";
        _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_fd_wrapper_close";
        _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_50:
  if (v21)
    free(v21);
LABEL_21:

}

void sub_18303DEE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_flow_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  nw_flow_protocol *handle;
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_handler *v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  OS_nw_parameters *parameters;
  OS_nw_parameters *v8;
  uint64_t v9;
  NWConcrete_nw_endpoint_handler *v10;
  char v11;
  NSObject *v12;
  NWConcrete_nw_endpoint_handler *v13;
  char *v14;
  char v15;
  const char *v16;
  nw_endpoint_t v17;
  const char *v18;
  unsigned int *v19;
  unsigned int *v20;
  uint64_t v21;
  const char *v22;
  NSObject *v23;
  const char *v24;
  NWConcrete_nw_endpoint_handler *v25;
  char v26;
  NWConcrete_nw_endpoint_handler *v27;
  NWConcrete_nw_endpoint_handler *v28;
  char v29;
  const char *v30;
  nw_endpoint_t v31;
  const char *logging_description;
  unsigned int *v33;
  unsigned int *v34;
  uint64_t v35;
  const char *v36;
  void **v37;
  void **v38;
  const char *v39;
  const char *v40;
  void **v41;
  void **v42;
  const char *v43;
  const char *v44;
  void **v45;
  id v46;
  void **v47;
  id v48;
  NWConcrete_nw_endpoint_mode_handler *v49;
  unsigned int v50;
  OS_nw_content_context *v51;
  int v52;
  OS_nw_error *v53;
  OS_nw_context *context;
  NWConcrete_nw_endpoint_mode_handler *v55;
  OS_nw_content_context *v56;
  OS_nw_error *v57;
  void *v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  char *backtrace_string;
  os_log_type_t v63;
  _BOOL4 v64;
  os_log_type_t v65;
  const char *v66;
  nw_endpoint_t v67;
  const char *v68;
  const char *v69;
  const char *v70;
  id v71;
  char *id_str;
  const char *v73;
  os_log_t log;
  NSObject *loga;
  const char *v76;
  const char *v77;
  const char *id_string;
  _QWORD v79[4];
  NWConcrete_nw_endpoint_handler *v80;
  NWConcrete_nw_endpoint_mode_handler *v81;
  OS_nw_error *v82;
  OS_nw_content_context *v83;
  nw_flow_protocol *v84;
  nw_flow_protocol *v85;
  char v86;
  char v87;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v90;
  __int16 v91;
  void *v92;
  __int16 v93;
  const char *v94;
  __int16 v95;
  const char *v96;
  __int16 v97;
  const char *v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  id v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  handle = (nw_flow_protocol *)a1->handle;
  v3 = handle->handler;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v90 = "nw_flow_disconnected";
    v59 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v87 = 0;
    if (__nwlog_fault(v59, &type, &v87))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          v90 = "nw_flow_disconnected";
          _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v87)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        v64 = os_log_type_enabled(v60, type);
        if (backtrace_string)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136446466;
            v90 = "nw_flow_disconnected";
            v91 = 2082;
            v92 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v60, v63, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_70;
        }
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          v90 = "nw_flow_disconnected";
          _os_log_impl(&dword_182FBE000, v60, v63, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v65 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          v90 = "nw_flow_disconnected";
          _os_log_impl(&dword_182FBE000, v60, v65, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_70:
    if (v59)
      free(v59);
    goto LABEL_53;
  }
  v5 = v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    if ((*((_WORD *)handle + 166) & 0x100) != 0)
    {
      v25 = v5;
      v26 = *((_BYTE *)v25 + 268);

      if ((v26 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          v27 = v25;

          v28 = v27;
          v29 = *((_BYTE *)v25 + 268);

          if ((v29 & 1) != 0)
            v30 = "dry-run ";
          else
            v30 = "";
          v31 = nw_endpoint_handler_copy_endpoint(v28);
          logging_description = nw_endpoint_get_logging_description(v31);
          v77 = v30;
          id_str = v27->id_str;
          v33 = v28;
          v34 = v33;
          v35 = v33[30];
          if (v35 > 5)
            v36 = "unknown-state";
          else
            v36 = off_1E149FC48[v35];
          loga = v12;

          v37 = v34;
          v38 = v37;
          v39 = logging_description;
          v40 = "path";
          switch(v5->mode)
          {
            case 0:
              break;
            case 1:
              v40 = "resolver";
              break;
            case 2:
              v40 = nw_endpoint_flow_mode_string(v37[31]);
              break;
            case 3:
              v40 = "proxy";
              break;
            case 4:
              v40 = "fallback";
              break;
            case 5:
              v40 = "transform";
              break;
            default:
              v40 = "unknown-mode";
              break;
          }

          v45 = v38;
          os_unfair_lock_lock((os_unfair_lock_t)v45 + 28);
          v46 = v45[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v45 + 28);

          *(_DWORD *)buf = 136447746;
          v90 = "nw_flow_disconnected";
          v91 = 2082;
          v92 = id_str;
          v93 = 2082;
          v94 = v77;
          v95 = 2082;
          v96 = v39;
          v97 = 2082;
          v98 = v36;
          v99 = 2082;
          v100 = v40;
          v101 = 2114;
          v102 = v46;
          v12 = loga;
          _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected for unregistered flow", buf, 0x48u);

        }
        goto LABEL_49;
      }
    }
    else
    {
      parameters = handle->parameters;
      if (!parameters)
        goto LABEL_50;
      v8 = parameters;
      v9 = *((_QWORD *)v8 + 12);

      if ((v9 & 0x4000000000) != 0)
        goto LABEL_50;
      if (nw_endpoint_handler_get_minimize_logging(v5))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
          goto LABEL_50;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v5);
          v66 = nw_endpoint_handler_dry_run_string(v5);
          v67 = nw_endpoint_handler_copy_endpoint(v5);
          v68 = nw_endpoint_get_logging_description(v67);
          v69 = nw_endpoint_handler_state_string(v5);
          v70 = nw_endpoint_handler_mode_string(v5);
          v71 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136447746;
          v90 = "nw_flow_disconnected";
          v91 = 2082;
          v92 = (void *)id_string;
          v93 = 2082;
          v94 = v66;
          v95 = 2082;
          v96 = v68;
          v97 = 2082;
          v98 = v69;
          v99 = 2082;
          v100 = v70;
          v101 = 2114;
          v102 = v71;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected", buf, 0x48u);

        }
        goto LABEL_49;
      }
      v10 = v5;
      v11 = *((_BYTE *)v10 + 268);

      if ((v11 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v13 = v10;

          v14 = v13;
          v15 = *((_BYTE *)v10 + 268);

          if ((v15 & 1) != 0)
            v16 = "dry-run ";
          else
            v16 = "";
          v17 = nw_endpoint_handler_copy_endpoint(v14);
          v18 = nw_endpoint_get_logging_description(v17);
          log = (os_log_t)v13->id_str;
          v76 = v16;
          v19 = v14;
          v20 = v19;
          v21 = v19[30];
          if (v21 > 5)
            v22 = "unknown-state";
          else
            v22 = off_1E149FC48[v21];
          v73 = v22;

          v41 = v20;
          v42 = v41;
          v43 = v18;
          v44 = "path";
          switch(v5->mode)
          {
            case 0:
              break;
            case 1:
              v44 = "resolver";
              break;
            case 2:
              v44 = nw_endpoint_flow_mode_string(v41[31]);
              break;
            case 3:
              v44 = "proxy";
              break;
            case 4:
              v44 = "fallback";
              break;
            case 5:
              v44 = "transform";
              break;
            default:
              v44 = "unknown-mode";
              break;
          }

          v47 = v42;
          os_unfair_lock_lock((os_unfair_lock_t)v47 + 28);
          v48 = v47[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v47 + 28);

          *(_DWORD *)buf = 136447746;
          v90 = "nw_flow_disconnected";
          v91 = 2082;
          v92 = log;
          v93 = 2082;
          v94 = v76;
          v95 = 2082;
          v96 = v43;
          v97 = 2082;
          v98 = v73;
          v99 = 2082;
          v100 = v44;
          v101 = 2114;
          v102 = v48;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected", buf, 0x48u);

        }
LABEL_49:

      }
    }
LABEL_50:
    *((_WORD *)handle + 166) |= 0x210u;
    v49 = nw_endpoint_handler_copy_flow(v5);
    v50 = *((unsigned __int16 *)handle + 166);
    v51 = handle->output_context;
    if ((v50 & 0x100) == 0)
      nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v49, handle, 1);
    v52 = (v50 >> 8) & 1;
    v53 = handle->last_error;
    context = handle->context;
    v79[0] = MEMORY[0x1E0C809B0];
    v79[1] = 3221225472;
    v79[2] = ___ZL20nw_flow_disconnectedP11nw_protocolS0__block_invoke;
    v79[3] = &unk_1E149C900;
    v80 = v5;
    v84 = handle;
    v55 = v49;
    v81 = v55;
    v82 = v53;
    v86 = v52;
    v56 = v51;
    v83 = v56;
    v85 = handle;
    v57 = v53;
    nw_queue_context_async(context, v79);

    goto LABEL_53;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v23 = (id)gLogObj;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5)
      v24 = "unknown-mode";
    else
      v24 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v90 = "nw_flow_disconnected";
    v91 = 2082;
    v92 = (void *)v24;
    v93 = 2082;
    v94 = "flow";
    _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_53:
}

void sub_18303E8D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_flow_input_available(nw_protocol *a1, nw_protocol *a2)
{
  nw_flow_protocol *handle;
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_handler *v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v7;
  NSObject *v8;
  const char *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  handle = (nw_flow_protocol *)a1->handle;
  v3 = handle->handler;
  v4 = v3;
  if (v3)
  {
    v5 = v3;
    mode = v5->mode;

    if ((_DWORD)mode == 2)
    {
      v7 = nw_endpoint_handler_copy_flow(v5);
      nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v7, handle, 0);

    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5)
          v9 = "unknown-mode";
        else
          v9 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v21 = "nw_flow_input_available";
        v22 = 2082;
        v23 = (void *)v9;
        v24 = 2082;
        v25 = "flow";
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }

    }
    goto LABEL_10;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_flow_input_available";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_flow_input_available";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_flow_input_available";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_flow_input_available";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_flow_input_available";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_27:
  if (v11)
    free(v11);
LABEL_10:

}

void sub_18303ECCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_endpoint_handler_service_reads(void *a1)
{
  id v1;
  void *v2;
  NWConcrete_nw_endpoint_handler *v3;
  uint64_t mode;
  NWConcrete_nw_endpoint_flow *v5;
  id v6;
  const char *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *v12;
  os_log_type_t v13;
  _BOOL4 v14;
  const char *v15;
  os_log_type_t v16;
  const char *v17;
  const char *v18;
  void *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  void *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_endpoint_handler_service_reads";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v8, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v25)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      v23 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_182FBE000, v9, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v28 = "nw_endpoint_handler_service_reads";
        v29 = 2082;
        v30 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_36:
    if (!v8)
      goto LABEL_38;
LABEL_37:
    free(v8);
    goto LABEL_38;
  }
  v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if ((_DWORD)mode == 2)
  {
    v5 = (NWConcrete_nw_endpoint_flow *)nw_endpoint_handler_copy_flow(v3);
    nw_flow_service_reads(v3, v5, &v5->shared_protocol, 0);

    goto LABEL_38;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  if (mode > 5)
    v7 = "unknown-mode";
  else
    v7 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  v28 = "nw_endpoint_handler_service_reads";
  v29 = 2082;
  v30 = (void *)v7;
  v31 = 2082;
  v32 = "flow";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      if (mode > 5)
        v11 = "unknown-mode";
      else
        v11 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v28 = "nw_endpoint_handler_service_reads";
      v29 = 2082;
      v30 = (void *)v11;
      v31 = 2082;
      v32 = "flow";
      _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      if (mode > 5)
        v17 = "unknown-mode";
      else
        v17 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v28 = "nw_endpoint_handler_service_reads";
      v29 = 2082;
      v30 = (void *)v17;
      v31 = 2082;
      v32 = "flow";
      _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_35;
  }
  v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  v13 = type;
  v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      if (mode > 5)
        v18 = "unknown-mode";
      else
        v18 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v28 = "nw_endpoint_handler_service_reads";
      v29 = 2082;
      v30 = (void *)v18;
      v31 = 2082;
      v32 = "flow";
      _os_log_impl(&dword_182FBE000, v9, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_35;
  }
  if (v14)
  {
    if (mode > 5)
      v15 = "unknown-mode";
    else
      v15 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    v28 = "nw_endpoint_handler_service_reads";
    v29 = 2082;
    v30 = (void *)v15;
    v31 = 2082;
    v32 = "flow";
    v33 = 2082;
    v34 = v12;
    _os_log_impl(&dword_182FBE000, v9, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v12);
  if (v8)
    goto LABEL_37;
LABEL_38:

}

void sub_18303F310(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_flow_service_reads(NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2, nw_flow_protocol *a3, int a4)
{
  const char *v4;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  void (*get_message_properties)(void);
  NSObject *v10;
  const char *id_string;
  const char *v12;
  nw_endpoint_t v13;
  const char *logging_description;
  const char *v15;
  const char *v16;
  id v17;
  __int16 v18;
  OS_nw_read_request *request_list_report;
  OS_nw_read_request *read_requests;
  char v21;
  unsigned int v22;
  unint64_t v23;
  NWConcrete_nw_read_request *v24;
  _BOOL8 request_list_append;
  OS_nw_read_request *v26;
  OS_nw_read_request *v27;
  OS_nw_read_request *v28;
  OS_nw_read_request *v29;
  int maximum_datagram_count;
  OS_nw_read_request *v31;
  int v32;
  int v33;
  NSObject *v34;
  const char *v35;
  nw_endpoint_t v36;
  const char *v37;
  const char *v38;
  id v39;
  NSObject *v40;
  const char *v41;
  nw_endpoint_t v42;
  const char *v43;
  const char *v44;
  const char *v45;
  id v46;
  BOOL v47;
  NSObject *v48;
  const char *v49;
  nw_endpoint_t v50;
  const char *v51;
  const char *v52;
  id v53;
  const char *v54;
  nw_endpoint_t v55;
  const char *v56;
  const char *v57;
  const char *v58;
  id v59;
  __int16 v60;
  NSObject *v61;
  const char *v62;
  const char *v63;
  nw_endpoint_t v64;
  const char *v65;
  const char *v66;
  const char *v67;
  id v68;
  int v69;
  int v70;
  NSObject *v71;
  const char *v72;
  const char *v73;
  const char *v74;
  const char *v75;
  const char *v76;
  id v77;
  __int16 v78;
  OS_nw_error *last_error;
  OS_nw_read_request *v80;
  _DWORD *v81;
  OS_nw_read_request *v82;
  void *v84;
  char *v85;
  NSObject *v86;
  os_log_type_t tqh_first;
  char *backtrace_string;
  NSObject *v89;
  os_log_type_t v90;
  _BOOL4 v91;
  NSObject *v92;
  const char *v93;
  const char *v94;
  nw_endpoint_t v95;
  const char *v96;
  const char *v97;
  const char *v98;
  id v99;
  os_log_type_t v100;
  NSObject *v101;
  const char *v102;
  const char *v103;
  nw_endpoint_t v104;
  const char *v105;
  const char *v106;
  const char *v107;
  id v108;
  const char *v109;
  char v110;
  _BOOL4 v111;
  nw_frame_array_s *p_pending_input_frames;
  nw_protocol *v113;
  nw_endpoint_t v114;
  NWConcrete_nw_endpoint_flow *v115;
  OS_nw_read_request *v116;
  const char *v117;
  NWConcrete_nw_endpoint_handler *v118;
  nw_frame_array_s type;
  _QWORD v120[4];
  NWConcrete_nw_endpoint_handler *v121;
  nw_flow_protocol *v122;
  char v123;
  uint64_t v124;
  uint8_t buf[4];
  const char *v126;
  __int16 v127;
  const char *v128;
  __int16 v129;
  const char *v130;
  __int16 v131;
  const char *v132;
  __int16 v133;
  const char *v134;
  __int16 v135;
  const char *v136;
  __int16 v137;
  id v138;
  __int16 v139;
  _BYTE v140[10];
  uint64_t v141;

  LODWORD(v4) = a4;
  v141 = *MEMORY[0x1E0C80C00];
  v118 = a1;
  v115 = a2;
  if (!a3)
  {
    __nwlog_obj();
    v84 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v126 = "nw_flow_service_reads";
    v85 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(type.tqh_first) = 16;
    LOBYTE(v124) = 0;
    if (__nwlog_fault(v85, &type, &v124))
    {
      if (LOBYTE(type.tqh_first) == 17)
      {
        __nwlog_obj();
        v86 = objc_claimAutoreleasedReturnValue();
        tqh_first = (os_log_type_t)type.tqh_first;
        if (os_log_type_enabled(v86, (os_log_type_t)type.tqh_first))
        {
          *(_DWORD *)buf = 136446210;
          v126 = "nw_flow_service_reads";
          _os_log_impl(&dword_182FBE000, v86, tqh_first, "%{public}s called with null flow_protocol", buf, 0xCu);
        }
      }
      else
      {
        if ((_BYTE)v124)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v89 = objc_claimAutoreleasedReturnValue();
          v90 = (os_log_type_t)type.tqh_first;
          v91 = os_log_type_enabled(v89, (os_log_type_t)type.tqh_first);
          if (backtrace_string)
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446466;
              v126 = "nw_flow_service_reads";
              v127 = 2082;
              v128 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s called with null flow_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446210;
              v126 = "nw_flow_service_reads";
              _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s called with null flow_protocol, no backtrace", buf, 0xCu);
            }

          }
          goto LABEL_132;
        }
        __nwlog_obj();
        v86 = objc_claimAutoreleasedReturnValue();
        v100 = (os_log_type_t)type.tqh_first;
        if (os_log_type_enabled(v86, (os_log_type_t)type.tqh_first))
        {
          *(_DWORD *)buf = 136446210;
          v126 = "nw_flow_service_reads";
          _os_log_impl(&dword_182FBE000, v86, v100, "%{public}s called with null flow_protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_132:
    if (v85)
      free(v85);
    goto LABEL_15;
  }
  output_handler = a3->protocol.output_handler;
  if (!output_handler)
  {
    if ((nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_endpoint_handler_get_id_string(v118);
        v12 = nw_endpoint_handler_dry_run_string(v118);
        v13 = nw_endpoint_handler_copy_endpoint(v118);
        logging_description = nw_endpoint_get_logging_description(v13);
        v15 = nw_endpoint_handler_state_string(v118);
        v16 = nw_endpoint_handler_mode_string(v118);
        v17 = nw_endpoint_handler_copy_current_path(v118);
        *(_DWORD *)buf = 136447746;
        v126 = "nw_flow_service_reads";
        v127 = 2082;
        v128 = id_string;
        v129 = 2082;
        v130 = v12;
        v131 = 2082;
        v132 = logging_description;
        v133 = 2082;
        v134 = v15;
        v135 = 2082;
        v136 = v16;
        v137 = 2114;
        v138 = v17;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No output handler", buf, 0x48u);

      }
    }
LABEL_15:
    v111 = 0;
    goto LABEL_103;
  }
  v124 = 0;
  callbacks = output_handler->callbacks;
  v113 = output_handler;
  if (callbacks)
  {
    get_message_properties = (void (*)(void))callbacks->get_message_properties;
    if (get_message_properties)
      get_message_properties();
  }
  if ((_DWORD)v4)
    LODWORD(v4) = nw_endpoint_handler_get_state(v118) != 5 && (v124 & 0x100000000) == 0;
  v18 = *((_WORD *)a3 + 166);
  v111 = (v18 & 4) == 0;
  if ((v18 & 4) == 0)
  {
    *((_WORD *)a3 + 166) = v18 | 4;
    request_list_report = (OS_nw_read_request *)nw_read_request_list_report(a3->read_requests);
    read_requests = a3->read_requests;
    a3->read_requests = request_list_report;

    v110 = (char)v4;
    if (!a3->read_requests && gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v101 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
      {
        v102 = nw_endpoint_handler_get_id_string(v118);
        v103 = nw_endpoint_handler_dry_run_string(v118);
        v104 = nw_endpoint_handler_copy_endpoint(v118);
        v105 = nw_endpoint_get_logging_description(v104);
        v106 = nw_endpoint_handler_state_string(v118);
        v107 = nw_endpoint_handler_mode_string(v118);
        v108 = nw_endpoint_handler_copy_current_path(v118);
        *(_DWORD *)buf = 136448002;
        v126 = "nw_flow_service_reads";
        v127 = 2082;
        v128 = v102;
        v129 = 2082;
        v130 = v103;
        v131 = 2082;
        v132 = v105;
        v133 = 2082;
        v134 = v106;
        v135 = 2082;
        v136 = v107;
        v137 = 2114;
        v138 = v108;
        v139 = 2048;
        *(_QWORD *)v140 = a3;
        _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %p No read requests, skipping read", buf, 0x52u);

      }
      LOBYTE(v4) = v110;
    }
    p_pending_input_frames = &a3->pending_input_frames;
    while (1)
    {
      if (a3->read_requests)
        v21 = 1;
      else
        v21 = (char)v4;
      if ((v21 & 1) == 0 && (*((_WORD *)a3 + 166) & 0x40) == 0)
      {
LABEL_95:
        if ((v4 & 1) != 0 || (v78 = *((_WORD *)a3 + 166), (v78 & 0x40) != 0))
        {
          if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v92 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
            {
              v93 = nw_endpoint_handler_get_id_string(v118);
              v94 = nw_endpoint_handler_dry_run_string(v118);
              v95 = nw_endpoint_handler_copy_endpoint(v118);
              v96 = nw_endpoint_get_logging_description(v95);
              v97 = nw_endpoint_handler_state_string(v118);
              v98 = nw_endpoint_handler_mode_string(v118);
              v99 = nw_endpoint_handler_copy_current_path(v118);
              *(_DWORD *)buf = 136447746;
              v126 = "nw_flow_service_reads";
              v127 = 2082;
              v128 = v93;
              v129 = 2082;
              v130 = v94;
              v131 = 2082;
              v132 = v96;
              v133 = 2082;
              v134 = v97;
              v135 = 2082;
              v136 = v98;
              v137 = 2114;
              v138 = v99;
              _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Handling remaining read requests", buf, 0x48u);

            }
          }
          last_error = a3->last_error;
          v80 = a3->read_requests;
          if (last_error)
          {
            nw_read_request_report_error_with_override(a3->read_requests, 0, last_error);
          }
          else
          {
            v81 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 96);
            nw_read_request_report_error_with_override(v80, 0, v81);

          }
          v82 = a3->read_requests;
          a3->read_requests = 0;

          v78 = *((_WORD *)a3 + 166);
        }
        *((_WORD *)a3 + 166) = v78 & 0xFFFB;
        goto LABEL_103;
      }
      if ((v4 & 1) != 0 || (*((_WORD *)a3 + 166) & 0x40) != 0)
      {
        v22 = BYTE4(v124) & 4;
        if ((v124 & 0x400000000) != 0)
          v23 = 1;
        else
          v23 = 0xFFFFFFFFLL;
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v48 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
          {
            v49 = nw_endpoint_handler_get_id_string(v118);
            v4 = nw_endpoint_handler_dry_run_string(v118);
            v50 = nw_endpoint_handler_copy_endpoint(v118);
            v51 = nw_endpoint_get_logging_description(v50);
            v117 = nw_endpoint_handler_state_string(v118);
            v52 = nw_endpoint_handler_mode_string(v118);
            v53 = nw_endpoint_handler_copy_current_path(v118);
            *(_DWORD *)buf = 136448002;
            v126 = "nw_flow_service_reads";
            v127 = 2082;
            v128 = v49;
            v129 = 2082;
            v130 = v4;
            v131 = 2082;
            v132 = v51;
            v133 = 2082;
            v134 = v117;
            v135 = 2082;
            v136 = v52;
            v137 = 2114;
            v138 = v53;
            v139 = 2048;
            *(_QWORD *)v140 = v23;
            _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Setting min_length on final data read to %zu", buf, 0x52u);

            LOBYTE(v4) = v110;
          }

        }
        v120[0] = MEMORY[0x1E0C809B0];
        v120[1] = 3221225472;
        v120[2] = ___ZL21nw_flow_service_readsP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP16nw_flow_protocolb_block_invoke;
        v120[3] = &unk_1E149C750;
        v121 = v118;
        v122 = a3;
        v123 = v22 >> 2;
        v24 = nw_read_request_create(v23, 0xFFFFFFFFuLL, 0, 0, v120);
        request_list_append = nw_read_request_list_append(a3->read_requests, v24);
        v26 = a3->read_requests;
        a3->read_requests = (OS_nw_read_request *)request_list_append;

      }
      if (p_pending_input_frames->tqh_first)
      {
        nw_flow_process_input_frames(v118, v115, &a3->protocol, p_pending_input_frames, BYTE4(v124) & 1, (v124 & 0x400000000) != 0, 0);
        v27 = a3->read_requests;
        if (!v27)
          goto LABEL_95;
      }
      else
      {
        v27 = a3->read_requests;
      }
      v28 = v27;
      v29 = v28;
      v116 = v28;
      if ((v124 & 0x100000000) != 0)
      {
        maximum_datagram_count = nw_read_request_get_maximum_datagram_count(v28);
        if (!maximum_datagram_count)
        {
          v70 = -1;
LABEL_88:
          if ((nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v71 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
            {
              v72 = nw_endpoint_handler_get_id_string(v118);
              v73 = nw_endpoint_handler_dry_run_string(v118);
              v4 = v72;
              v114 = nw_endpoint_handler_copy_endpoint(v118);
              v74 = nw_endpoint_get_logging_description(v114);
              v75 = nw_endpoint_handler_state_string(v118);
              v76 = nw_endpoint_handler_mode_string(v118);
              v77 = nw_endpoint_handler_copy_current_path(v118);
              *(_DWORD *)buf = 136448258;
              v126 = "nw_flow_service_reads";
              v127 = 2082;
              v128 = v4;
              v129 = 2082;
              v130 = v73;
              v131 = 2082;
              v132 = v74;
              v133 = 2082;
              v134 = v75;
              v135 = 2082;
              v136 = v76;
              v137 = 2114;
              v138 = v77;
              v139 = 1024;
              *(_DWORD *)v140 = maximum_datagram_count;
              *(_WORD *)&v140[4] = 1024;
              *(_DWORD *)&v140[6] = v70;
              _os_log_impl(&dword_182FBE000, v71, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Read request has %u frame count, %u byte count", buf, 0x54u);

              LOBYTE(v4) = v110;
            }

          }
          goto LABEL_95;
        }
      }
      else if (nw_read_request_get_next_max_size(a3->read_requests))
      {
        maximum_datagram_count = -1;
      }
      else
      {
        v70 = 0;
        maximum_datagram_count = -1;
        if (!nw_read_request_is_metadata_only(v29))
          goto LABEL_88;
      }
      v31 = v116;
      if (nw_read_request_is_metadata_only(v116))
        v32 = 1;
      else
        v32 = maximum_datagram_count;
      type.tqh_first = 0;
      type.tqh_last = (nw_frame **)&type;
      v33 = ((uint64_t (*)(void))v113->callbacks->get_input_frames)();
      if (v32 == -1)
      {
        if (!gLogDatapath || (nw_endpoint_handler_get_logging_disabled(v118) & 1) != 0)
          goto LABEL_54;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v34 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          v54 = nw_endpoint_handler_get_id_string(v118);
          v4 = nw_endpoint_handler_dry_run_string(v118);
          v55 = nw_endpoint_handler_copy_endpoint(v118);
          v56 = nw_endpoint_get_logging_description(v55);
          v57 = nw_endpoint_handler_state_string(v118);
          v58 = nw_endpoint_handler_mode_string(v118);
          v59 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448002;
          v126 = "nw_flow_service_reads";
          v127 = 2082;
          v128 = v54;
          v129 = 2082;
          v130 = v4;
          v131 = 2082;
          v132 = v56;
          v133 = 2082;
          v134 = v57;
          v135 = 2082;
          v136 = v58;
          v137 = 2114;
          v138 = v59;
          v139 = 1024;
          *(_DWORD *)v140 = v33;
          _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u frames to read", buf, 0x4Eu);

          LOBYTE(v4) = v110;
        }
      }
      else
      {
        if (!gLogDatapath || (nw_endpoint_handler_get_logging_disabled(v118) & 1) != 0)
          goto LABEL_54;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v34 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          v35 = nw_endpoint_handler_get_id_string(v118);
          v4 = nw_endpoint_handler_dry_run_string(v118);
          v36 = nw_endpoint_handler_copy_endpoint(v118);
          v37 = nw_endpoint_get_logging_description(v36);
          v109 = nw_endpoint_handler_state_string(v118);
          v38 = nw_endpoint_handler_mode_string(v118);
          v39 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448258;
          v126 = "nw_flow_service_reads";
          v127 = 2082;
          v128 = v35;
          v129 = 2082;
          v130 = v4;
          v131 = 2082;
          v132 = v37;
          v133 = 2082;
          v134 = v109;
          v135 = 2082;
          v136 = v38;
          v137 = 2114;
          v138 = v39;
          v139 = 1024;
          *(_DWORD *)v140 = v33;
          *(_WORD *)&v140[4] = 1024;
          *(_DWORD *)&v140[6] = v32;
          _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u frames to read, request wants %u frames", buf, 0x54u);

          LOBYTE(v4) = v110;
        }
      }

      v31 = v116;
LABEL_54:
      if (!type.tqh_first && v33 && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v40 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          v4 = nw_endpoint_handler_get_id_string(v118);
          v41 = nw_endpoint_handler_dry_run_string(v118);
          v42 = nw_endpoint_handler_copy_endpoint(v118);
          v43 = nw_endpoint_get_logging_description(v42);
          v44 = nw_endpoint_handler_state_string(v118);
          v45 = nw_endpoint_handler_mode_string(v118);
          v46 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448002;
          v126 = "nw_flow_service_reads";
          v127 = 2082;
          v128 = v4;
          v129 = 2082;
          v130 = v41;
          v131 = 2082;
          v132 = v43;
          v133 = 2082;
          v134 = v44;
          v135 = 2082;
          v136 = v45;
          v137 = 2114;
          v138 = v46;
          v139 = 1024;
          *(_DWORD *)v140 = v33;
          _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler reported %u frames to read, but array is empty", buf, 0x4Eu);

          LOBYTE(v4) = v110;
        }

        v31 = v116;
      }
      v47 = nw_flow_process_input_frames(v118, v115, &a3->protocol, &type, BYTE4(v124) & 1, (v124 & 0x400000000) != 0, 1);

      if (!v47)
        goto LABEL_95;
    }
  }
  if ((v18 & 0x40) == 0)
  {
    if ((_DWORD)v4)
      v60 = 64;
    else
      v60 = 0;
    *((_WORD *)a3 + 166) = v18 & 0xFFBF | v60;
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v61 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
    {
      v62 = nw_endpoint_handler_get_id_string(v118);
      v63 = nw_endpoint_handler_dry_run_string(v118);
      v64 = nw_endpoint_handler_copy_endpoint(v118);
      v65 = nw_endpoint_get_logging_description(v64);
      v66 = nw_endpoint_handler_state_string(v118);
      v67 = nw_endpoint_handler_mode_string(v118);
      v68 = nw_endpoint_handler_copy_current_path(v118);
      v69 = (*((unsigned __int16 *)a3 + 166) >> 6) & 1;
      *(_DWORD *)buf = 136448002;
      v126 = "nw_flow_service_reads";
      v127 = 2082;
      v128 = v62;
      v129 = 2082;
      v130 = v63;
      v131 = 2082;
      v132 = v65;
      v133 = 2082;
      v134 = v66;
      v135 = 2082;
      v136 = v67;
      v137 = 2114;
      v138 = v68;
      v139 = 1024;
      *(_DWORD *)v140 = v69;
      _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Already servicing reads, ignore read (deferred final read is %{BOOL}d)", buf, 0x4Eu);

    }
  }
LABEL_103:

  return v111;
}

void sub_183040470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24)
{
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

_BYTE *nw_read_request_list_report(void *a1)
{
  _BYTE *v1;
  _BYTE *v2;
  id *v3;
  id *v4;
  id v5;
  _BOOL8 v6;

  v1 = a1;
  v2 = v1;
  if (!v1)
    return v2;
  v3 = (id *)v1;
  do
  {
    if (((_BYTE)v3[22] & 1) == 0)
    {
      if (((_BYTE)v3[22] & 0xA) != 0 || (v5 = v3[9], v3[11] >= v5) && (v5 || v3[10] || v3[17] && !v3[10]))
      {
        if (_nw_signposts_once == -1)
        {
          if (_nw_signposts_enabled)
            goto LABEL_9;
        }
        else
        {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_51698);
          if (_nw_signposts_enabled)
          {
LABEL_9:
            if (kdebug_is_enabled())
              kdebug_trace();
          }
        }
        nw_read_request_report(v3, 0);
      }
    }
    v4 = (id *)v3[1];

    v3 = v4;
  }
  while (v4);
  do
  {
    if ((v2[176] & 1) == 0)
      break;
    v6 = nw_read_request_list_remove_head(v2);

    v2 = (_BYTE *)v6;
  }
  while (v6);
  return v2;
}

void sub_1830406F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_protocol_default_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  void (*v5)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a3)
    {
      v3 = *(_QWORD *)(a1 + 32);
      if (v3)
      {
        v4 = *(_QWORD *)(v3 + 24);
        if (v4)
        {
          v5 = *(void (**)(void))(v4 + 248);
          if (v5)
            v5();
        }
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_default_get_message_properties";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_get_message_properties";
      v9 = "%{public}s called with null protocol";
      goto LABEL_20;
    }
    if (!v12)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_get_message_properties";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v15 = "nw_protocol_default_get_message_properties";
        v16 = 2082;
        v17 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_get_message_properties";
      v9 = "%{public}s called with null protocol, no backtrace";
LABEL_20:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_21:
  if (v6)
    free(v6);
}

BOOL nw_read_request_is_metadata_only(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_read_request_is_metadata_only";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v6, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_read_request_is_metadata_only";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null request", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_read_request_is_metadata_only";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_read_request_is_metadata_only";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_read_request_is_metadata_only";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_22:
    if (v6)
      free(v6);
    goto LABEL_3;
  }
  if (!*((_QWORD *)v1 + 9))
  {
    v3 = *((_QWORD *)v1 + 10) == 0;
    goto LABEL_5;
  }
LABEL_3:
  v3 = 0;
LABEL_5:

  return v3;
}

uint64_t nw_flow_passthrough_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_input_frames)(void);
  NSObject *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  void *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_flow_passthrough_get_input_frames";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v12, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_flow_passthrough_get_input_frames";
        v15 = "%{public}s called with null protocol";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_flow_passthrough_get_input_frames";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v12)
          return 0;
LABEL_39:
        free(v12);
        return 0;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_flow_passthrough_get_input_frames";
        v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_flow_passthrough_get_input_frames";
        v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_flow_passthrough_get_input_frames";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v12, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_flow_passthrough_get_input_frames";
        v15 = "%{public}s called with null protocol->output_handler";
        goto LABEL_36;
      }
    }
    else
    {
      if (v21)
      {
        v19 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v20 = os_log_type_enabled(v13, type);
        if (v19)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v24 = "nw_flow_passthrough_get_input_frames";
            v25 = 2082;
            v26 = v19;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol->output_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v19);
          if (!v12)
            return 0;
          goto LABEL_39;
        }
        if (!v20)
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_flow_passthrough_get_input_frames";
        v15 = "%{public}s called with null protocol->output_handler, no backtrace";
        goto LABEL_36;
      }
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_flow_passthrough_get_input_frames";
        v15 = "%{public}s called with null protocol->output_handler, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
    goto LABEL_37;
  }
  callbacks = output_handler->callbacks;
  if (callbacks)
  {
    get_input_frames = (uint64_t (*)(void))callbacks->get_input_frames;
    if (get_input_frames)
      return get_input_frames();
  }
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    v24 = "nw_flow_passthrough_get_input_frames";
    _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s Output protocol handler does not support get_input_frames", buf, 0xCu);
  }

  return 0;
}

void nw_protocol_socket_get_message_properties(uint64_t a1, uint64_t a2, int *a3)
{
  int v3;
  unsigned int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_socket_get_message_properties";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_socket_get_message_properties";
      v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_socket_get_message_properties";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v5)
          return;
LABEL_38:
        free(v5);
        return;
      }
      if (!v10)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_socket_get_message_properties";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_socket_get_message_properties";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_37;
  }
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      if (*(_DWORD *)(a1 + 296) == 1)
      {
        v3 = *(_DWORD *)(a1 + 280);
        v4 = a3[1] & 0xFFFFFFFB;
      }
      else
      {
        v3 = -1;
        v4 = a3[1] | 4;
      }
      *a3 = v3;
      a3[1] = v4;
      a3[1] = v4 & 0xFFFFFFFC | (*(_DWORD *)(a1 + 296) == 1);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_socket_get_message_properties";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_37;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_socket_get_message_properties";
    v8 = "%{public}s called with null socket_handler";
    goto LABEL_36;
  }
  if (!v13)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_socket_get_message_properties";
    v8 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_36;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_socket_get_message_properties";
    v8 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_36;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_protocol_socket_get_message_properties";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5)
    goto LABEL_38;
}

BOOL nw_read_request_list_remove_head(void *a1)
{
  id v1;
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  _BOOL8 result;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  NSObject *v11;
  void *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_read_request_list_remove_head";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_read_request_list_remove_head";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null head", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_read_request_list_remove_head";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null head, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_read_request_list_remove_head";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null head, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_read_request_list_remove_head";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null head, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_25:
    if (v8)
      free(v8);
    v3 = 0;
    goto LABEL_6;
  }
  v3 = *((id *)v1 + 1);
  v4 = (void *)v2[1];
  v2[1] = 0;

  if (!v3)
  {
LABEL_5:
    v2[2] = 0;
LABEL_6:

    return (BOOL)v3;
  }
  v5 = v2[2];
  if (v5)
  {
LABEL_4:
    v3[2] = v5;
    goto LABEL_5;
  }
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "nw_read_request_list_remove_head";
  v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    v5 = v2[2];
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

void sub_183041890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_read_request;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_http2_transport_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, int a5, nw_frame_array_s *a6)
{
  char *handle;
  _QWORD *output_handler_context;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  _QWORD *v19;
  nw_frame *tqh_first;
  nw_frame *v21;
  char v22;
  uint64_t v23;
  NSObject *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  const char *v38;
  NSObject *v39;
  char *v40;
  _BOOL4 v41;
  const char *v42;
  _BOOL4 v43;
  NSObject *v44;
  NSObject *v45;
  int v46;
  int v47;
  _QWORD v48[2];
  uint64_t (*v49)(uint64_t, uint64_t);
  void *v50;
  nw_frame_array_s *v51;
  _QWORD v52[2];
  uint64_t (*v53)(uint64_t, uint64_t);
  void *v54;
  os_log_type_t *v55;
  uint64_t *v56;
  _BYTE *v57;
  char *v58;
  _QWORD *v59;
  nw_frame_array_s *v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  int v66;
  os_log_type_t type[8];
  os_log_type_t *v68;
  uint64_t v69;
  int v70;
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  char *v74;
  __int16 v75;
  int v76;
  __int16 v77;
  nw_protocol *v78;
  _BYTE v79[24];
  __int128 v80;
  _QWORD v81[3];

  v81[2] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        v39 = __nwlog_obj();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v79 = 136447234;
          *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
          *(_WORD *)&v79[12] = 2082;
          *(_QWORD *)&v79[14] = handle + 205;
          *(_WORD *)&v79[22] = 1024;
          LODWORD(v80) = a3;
          WORD2(v80) = 1024;
          *(_DWORD *)((char *)&v80 + 6) = a4;
          WORD5(v80) = 1024;
          HIDWORD(v80) = a5;
          _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called min_bytes: %u, max_bytes: %u, max_frame_count: %u", v79, 0x28u);
        }
      }
      *(_QWORD *)v79 = 0;
      *(_QWORD *)&v79[8] = v79;
      *(_QWORD *)&v79[16] = 0x3802000000;
      *(_QWORD *)&v80 = __Block_byref_object_copy__37957;
      *((_QWORD *)&v80 + 1) = __Block_byref_object_dispose__37958;
      v81[0] = 0;
      v81[1] = v81;
      a6->tqh_first = 0;
      a6->tqh_last = &a6->tqh_first;
      if (a2)
      {
        output_handler_context = a2->output_handler_context;
        if (output_handler_context)
        {
          v13 = (_QWORD *)output_handler_context[4];
          if (v13)
          {
            *(_QWORD *)type = 0;
            v68 = type;
            v70 = 0;
            v69 = 0x2000000000;
            v63 = 0;
            v64 = &v63;
            v66 = 0;
            v65 = 0x2000000000;
            v14 = MEMORY[0x1E0C809B0];
            v52[0] = MEMORY[0x1E0C809B0];
            v52[1] = 0x40000000;
            v53 = ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v54 = &unk_1E14A0DC8;
            v55 = type;
            v56 = &v63;
            v61 = a5;
            v62 = a4;
            v57 = v79;
            v58 = handle;
            v59 = v13;
            v60 = a6;
            v15 = *v13;
            do
            {
              if (!v15)
                break;
              v16 = *(_QWORD *)(v15 + 16);
              v17 = ((uint64_t (*)(_QWORD *))v53)(v52);
              v15 = v16;
            }
            while ((v17 & 1) != 0);
            if (*((_DWORD *)v64 + 6) >= a3)
            {
              v31 = *(_QWORD *)&v79[8];
              v32 = *(_QWORD *)&v79[8] + 40;
              v33 = *(_QWORD *)(*(_QWORD *)&v79[8] + 40);
              if (v33)
              {
                **((_QWORD **)handle + 19) = v33;
                *(_QWORD *)(*(_QWORD *)(v31 + 40) + 24) = *((_QWORD *)handle + 19);
                *((_QWORD *)handle + 19) = *(_QWORD *)(v31 + 48);
                *(_QWORD *)(v31 + 40) = 0;
                *(_QWORD *)(v31 + 48) = v32;
              }
              if (gLogDatapath)
              {
                v45 = __nwlog_obj();
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
                {
                  v46 = *((_DWORD *)v68 + 6);
                  v47 = *((_DWORD *)v64 + 6);
                  *(_DWORD *)buf = 136446978;
                  v72 = "nw_protocol_http2_transport_get_input_frames";
                  v73 = 2082;
                  v74 = handle + 205;
                  v75 = 1024;
                  v76 = v46;
                  v77 = 1024;
                  LODWORD(v78) = v47;
                  _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s returning %u frames (%u total bytes)", buf, 0x22u);
                }
              }
              v23 = *((unsigned int *)v68 + 6);
            }
            else
            {
              if (*((_DWORD *)v68 + 6))
              {
                v18 = *(_QWORD *)&v79[8];
                v19 = (_QWORD *)(*(_QWORD *)&v79[8] + 40);
                if (*v13)
                {
                  **(_QWORD **)(*(_QWORD *)&v79[8] + 48) = *v13;
                  *(_QWORD *)(*v13 + 24) = *(_QWORD *)(v18 + 48);
                  *(_QWORD *)(v18 + 48) = v13[1];
                  *v13 = 0;
                  v13[1] = v13;
                }
                if (*v19)
                {
                  *(_QWORD *)v13[1] = *v19;
                  *(_QWORD *)(*(_QWORD *)(v18 + 40) + 24) = v13[1];
                  v13[1] = *(_QWORD *)(v18 + 48);
                  *(_QWORD *)(v18 + 40) = 0;
                  *(_QWORD *)(v18 + 48) = v19;
                }
                v48[0] = v14;
                v48[1] = 0x40000000;
                v49 = ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_37;
                v50 = &__block_descriptor_tmp_38_37966;
                v51 = a6;
                tqh_first = a6->tqh_first;
                do
                {
                  if (!tqh_first)
                    break;
                  v21 = (nw_frame *)*((_QWORD *)tqh_first + 4);
                  v22 = ((uint64_t (*)(_QWORD *))v49)(v48);
                  tqh_first = v21;
                }
                while ((v22 & 1) != 0);
                a6->tqh_first = 0;
                a6->tqh_last = &a6->tqh_first;
              }
              if (gLogDatapath && (v44 = __nwlog_obj(), os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)))
              {
                *(_DWORD *)buf = 136446722;
                v72 = "nw_protocol_http2_transport_get_input_frames";
                v73 = 2082;
                v74 = handle + 205;
                v75 = 1024;
                v76 = a3;
                _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s failed to find enough (%u) bytes to return, returning 0 frames", buf, 0x1Cu);
                v23 = 0;
              }
              else
              {
                v23 = 0;
              }
            }
            _Block_object_dispose(&v63, 8);
            _Block_object_dispose(type, 8);
            goto LABEL_46;
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          v72 = "nw_protocol_http2_transport_get_input_frames";
          v73 = 2082;
          v74 = handle + 205;
          v75 = 1042;
          v76 = 16;
          v77 = 2098;
          v78 = a2;
          _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s %{public}s can't find hash table entry for %{public,uuid_t}.16P", buf, 0x26u);
        }
LABEL_45:
        v23 = 0;
LABEL_46:
        _Block_object_dispose(v79, 8);
        return v23;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v72 = "nw_protocol_http2_transport_get_input_frames";
      v25 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v63) = 0;
      if (__nwlog_fault(v25, type, &v63))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = gLogObj;
          v27 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
            goto LABEL_43;
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_http2_transport_get_input_frames";
          v28 = "%{public}s called with null input_protocol";
          goto LABEL_42;
        }
        if (!(_BYTE)v63)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = gLogObj;
          v27 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
            goto LABEL_43;
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_http2_transport_get_input_frames";
          v28 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_42;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = gLogObj;
        v27 = type[0];
        v30 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v72 = "nw_protocol_http2_transport_get_input_frames";
            v73 = 2082;
            v74 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_43;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v72 = "nw_protocol_http2_transport_get_input_frames";
          v28 = "%{public}s called with null input_protocol, no backtrace";
LABEL_42:
          _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
        }
      }
LABEL_43:
      if (v25)
        free(v25);
      goto LABEL_45;
    }
    __nwlog_obj();
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
    v35 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v35, buf, type))
      goto LABEL_81;
    if (buf[0] == 17)
    {
      v36 = __nwlog_obj();
      v37 = buf[0];
      if (os_log_type_enabled(v36, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
        v38 = "%{public}s called with null http2_transport";
        goto LABEL_80;
      }
      goto LABEL_81;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v36 = __nwlog_obj();
      v37 = buf[0];
      if (os_log_type_enabled(v36, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
        v38 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_80;
      }
      goto LABEL_81;
    }
    v40 = (char *)__nw_create_backtrace_string();
    v36 = __nwlog_obj();
    v37 = buf[0];
    v43 = os_log_type_enabled(v36, (os_log_type_t)buf[0]);
    if (!v40)
    {
      if (v43)
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
        v38 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_80;
      }
      goto LABEL_81;
    }
    if (v43)
    {
      *(_DWORD *)v79 = 136446466;
      *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
      *(_WORD *)&v79[12] = 2082;
      *(_QWORD *)&v79[14] = v40;
      v42 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
      goto LABEL_66;
    }
    goto LABEL_67;
  }
  __nwlog_obj();
  *(_DWORD *)v79 = 136446210;
  *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
  v35 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v35, buf, type))
    goto LABEL_81;
  if (buf[0] != 17)
  {
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v36 = __nwlog_obj();
      v37 = buf[0];
      if (os_log_type_enabled(v36, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
        v38 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_80;
      }
      goto LABEL_81;
    }
    v40 = (char *)__nw_create_backtrace_string();
    v36 = __nwlog_obj();
    v37 = buf[0];
    v41 = os_log_type_enabled(v36, (os_log_type_t)buf[0]);
    if (!v40)
    {
      if (v41)
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
        v38 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_80;
      }
      goto LABEL_81;
    }
    if (v41)
    {
      *(_DWORD *)v79 = 136446466;
      *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
      *(_WORD *)&v79[12] = 2082;
      *(_QWORD *)&v79[14] = v40;
      v42 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_66:
      _os_log_impl(&dword_182FBE000, v36, v37, v42, v79, 0x16u);
    }
LABEL_67:
    free(v40);
    goto LABEL_81;
  }
  v36 = __nwlog_obj();
  v37 = buf[0];
  if (os_log_type_enabled(v36, (os_log_type_t)buf[0]))
  {
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "nw_protocol_http2_transport_get_input_frames";
    v38 = "%{public}s called with null protocol";
LABEL_80:
    _os_log_impl(&dword_182FBE000, v36, v37, v38, v79, 0xCu);
  }
LABEL_81:
  if (v35)
    free(v35);
  return 0;
}

uint64_t ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  size_t v8;
  unsigned int v9;
  _BOOL8 input_frame;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t *v23;
  void *v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  char *backtrace_string;
  _BOOL4 v36;
  uint64_t v37;
  const char *v38;
  const void *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  const char *v49;
  void *v50;
  NSObject *v51;
  uint64_t v52;
  const char *v53;
  NSObject *v54;
  uint64_t v55;
  const char *v56;
  NSObject *v57;
  uint64_t v58;
  const char *v59;
  int v60;
  char v61;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v64;
  __int16 v65;
  void *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  int v70;
  __int16 v71;
  char *v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  if ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 1) <= *(_DWORD *)(a1 + 80))
  {
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v6 = *(_DWORD *)(v5 + 24);
    v7 = *(_DWORD *)(a1 + 84);
    v8 = v7 - v6;
    if (v7 > v6)
    {
      v9 = v4;
      if (v8 >= v4)
      {
        *(_DWORD *)(v5 + 24) = v6 + v4;
        v16 = *(_QWORD *)(a2 + 16);
        v17 = *(_QWORD **)(a2 + 24);
        v15 = (_QWORD *)(a2 + 16);
        if (v16)
        {
          *(_QWORD *)(v16 + 24) = v17;
          v17 = *(_QWORD **)(a2 + 24);
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v17;
        }
        *v17 = v16;
        *v15 = 0;
        *(_QWORD *)(a2 + 24) = 0;
        v22 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
        v23 = *(uint64_t **)(v22 + 48);
        *(_QWORD *)(a2 + 24) = v23;
        *v23 = a2;
        *(_QWORD *)(v22 + 48) = v15;
        if (gLogDatapath)
        {
          v54 = __nwlog_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          {
            v55 = *(_QWORD *)(a1 + 56);
            *(_DWORD *)buf = 136446722;
            v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            if (v55)
              v56 = (const char *)(v55 + 205);
            else
              v56 = "";
            v65 = 2082;
            v66 = (void *)v56;
            v67 = 1024;
            v68 = v9;
            _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s delivering entire incoming frame (%u bytes)", buf, 0x1Cu);
          }
        }
        v11 = a2;
        goto LABEL_48;
      }
      if (gLogDatapath)
      {
        v51 = __nwlog_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          v52 = *(_QWORD *)(a1 + 56);
          *(_DWORD *)buf = 136446978;
          v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          if (v52)
            v53 = (const char *)(v52 + 205);
          else
            v53 = "";
          v65 = 2082;
          v66 = (void *)v53;
          v67 = 1024;
          v68 = v8;
          v69 = 1024;
          v70 = v9;
          _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s remaining space %u less than frame length %u", buf, 0x22u);
        }
      }
      input_frame = http2_transport_create_input_frame(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v8);
      if (input_frame)
      {
        v11 = input_frame;
        http2_transport_input_frame_context_reset(input_frame, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
        nw_frame_inherit_metadata(a2, v11, 0);
        if (!*(_QWORD *)(v11 + 112)
          || (*(_WORD *)(v11 + 204) & 0x100) != 0
          && g_channel_check_validity
          && !g_channel_check_validity(v11, *(_QWORD *)(v11 + 88)))
        {
          v14 = 0;
          v24 = 0;
          if (!(_DWORD)v8)
            goto LABEL_47;
        }
        else
        {
          v13 = *(_DWORD *)(v11 + 52);
          v12 = *(unsigned int *)(v11 + 56);
          if (v13)
            v14 = v13 - (v12 + *(_DWORD *)(v11 + 60));
          else
            v14 = 0;
          v24 = (void *)(*(_QWORD *)(v11 + 112) + v12);
          if (v14 == (_DWORD)v8)
          {
LABEL_47:
            v39 = (const void *)nw_frame_unclaimed_bytes(a2, 0);
            memcpy(v24, v39, v8);
            v40 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
            *(_QWORD *)(v11 + 16) = 0;
            v41 = *(uint64_t **)(v40 + 48);
            *(_QWORD *)(v11 + 24) = v41;
            *v41 = v11;
            *(_QWORD *)(v40 + 48) = v11 + 16;
            nw_frame_claim(a2, v42, v8, 0);
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v8;
            if (gLogDatapath)
            {
              v57 = __nwlog_obj();
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
              {
                v58 = *(_QWORD *)(a1 + 56);
                if (v58)
                  v59 = (const char *)(v58 + 205);
                else
                  v59 = "";
                v60 = nw_frame_unclaimed_length((_DWORD *)a2);
                *(_DWORD *)buf = 136447234;
                v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
                v65 = 2082;
                v66 = (void *)v59;
                v67 = 1024;
                v68 = v8;
                v69 = 1024;
                v70 = v9;
                v71 = 1024;
                LODWORD(v72) = v60;
                _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s delivering partial frame (%u bytes of %u, %u bytes remaining)", buf, 0x28u);
              }
            }
LABEL_48:
            ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            v43 = *(_QWORD *)(a1 + 72);
            *(_QWORD *)(v11 + 32) = 0;
            v44 = *(uint64_t **)(v43 + 8);
            *(_QWORD *)(v11 + 40) = v44;
            *v44 = v11;
            *(_QWORD *)(v43 + 8) = v11 + 32;
            return 1;
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = *(_QWORD *)(a1 + 56);
        if (v25)
          v26 = (const char *)(v25 + 205);
        else
          v26 = "";
        *(_DWORD *)buf = 136446978;
        v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
        v65 = 2082;
        v66 = (void *)v26;
        v67 = 1024;
        v68 = v14;
        v69 = 1024;
        v70 = v8;
        v27 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v61 = 0;
        if (!__nwlog_fault(v27, &type, &v61))
          goto LABEL_67;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v28 = __nwlog_obj();
          v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            v30 = *(_QWORD *)(a1 + 56);
            if (v30)
              v31 = (const char *)(v30 + 205);
            else
              v31 = "";
            *(_DWORD *)buf = 136446978;
            v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            v65 = 2082;
            v66 = (void *)v31;
            v67 = 1024;
            v68 = v14;
            v69 = 1024;
            v70 = v8;
            v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame";
LABEL_66:
            _os_log_impl(&dword_182FBE000, v28, v29, v32, buf, 0x22u);
          }
        }
        else if (v61)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v28 = __nwlog_obj();
          v29 = type;
          v36 = os_log_type_enabled(v28, type);
          if (backtrace_string)
          {
            if (v36)
            {
              v37 = *(_QWORD *)(a1 + 56);
              if (v37)
                v38 = (const char *)(v37 + 205);
              else
                v38 = "";
              *(_DWORD *)buf = 136447234;
              v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
              v65 = 2082;
              v66 = (void *)v38;
              v67 = 1024;
              v68 = v14;
              v69 = 1024;
              v70 = v8;
              v71 = 2082;
              v72 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_create_input_frame, dumping backtrace:%{public}s", buf, 0x2Cu);
            }
            free(backtrace_string);
            goto LABEL_67;
          }
          if (v36)
          {
            v48 = *(_QWORD *)(a1 + 56);
            if (v48)
              v49 = (const char *)(v48 + 205);
            else
              v49 = "";
            *(_DWORD *)buf = 136446978;
            v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            v65 = 2082;
            v66 = (void *)v49;
            v67 = 1024;
            v68 = v14;
            v69 = 1024;
            v70 = v8;
            v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame, no backtrace";
            goto LABEL_66;
          }
        }
        else
        {
          v28 = __nwlog_obj();
          v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            v46 = *(_QWORD *)(a1 + 56);
            if (v46)
              v47 = (const char *)(v46 + 205);
            else
              v47 = "";
            *(_DWORD *)buf = 136446978;
            v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            v65 = 2082;
            v66 = (void *)v47;
            v67 = 1024;
            v68 = v14;
            v69 = 1024;
            v70 = v8;
            v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame, backtrace limit exceeded";
            goto LABEL_66;
          }
        }
LABEL_67:
        if (v27)
          free(v27);
        if ((*(_WORD *)(v11 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(v11, *(_QWORD *)(v11 + 88)))
        {
          v50 = *(void **)(v11 + 112);
          if (v50)
            free(v50);
        }
        nw_frame_reset(v11, 0, 0, 0, 0);
        os_release((void *)v11);
        return 0;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
      v18 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (__nwlog_fault(v18, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v19 = gLogObj;
          v20 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_59;
          *(_DWORD *)buf = 136446210;
          v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          v21 = "%{public}s http2_transport_create_input_frame failed";
          goto LABEL_58;
        }
        if (!v61)
        {
          v19 = __nwlog_obj();
          v20 = type;
          if (!os_log_type_enabled(v19, type))
            goto LABEL_59;
          *(_DWORD *)buf = 136446210;
          v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          v21 = "%{public}s http2_transport_create_input_frame failed, backtrace limit exceeded";
          goto LABEL_58;
        }
        v33 = (char *)__nw_create_backtrace_string();
        v19 = __nwlog_obj();
        v20 = type;
        v34 = os_log_type_enabled(v19, type);
        if (v33)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            v65 = 2082;
            v66 = v33;
            _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s http2_transport_create_input_frame failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v33);
          goto LABEL_59;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          v21 = "%{public}s http2_transport_create_input_frame failed, no backtrace";
LABEL_58:
          _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
        }
      }
LABEL_59:
      if (v18)
        free(v18);
    }
  }
  return 0;
}

void nw_frame_inherit_metadata(uint64_t a1, uint64_t a2, int a3)
{
  int v4;
  uint64_t **v5;
  int v6;
  NSObject *v7;
  unsigned int dscp_value;
  nw_service_class_t service_class;
  int v10;
  void *v11;
  int v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  os_log_type_t v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char v22;
  NSObject *v23;
  uint64_t *v24;
  char v25;
  NSObject *v26;
  objc_class *v27;
  void *v28;
  id *v29;
  id v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  _BOOL4 v37;
  uint64_t v38;
  os_log_type_t v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  NSObject *v46;
  void *v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  NSObject *v52;
  os_log_type_t v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  const char *v57;
  char *backtrace_string;
  _BOOL4 v59;
  char *v60;
  _BOOL4 v61;
  _OWORD *v63;
  uint64_t **v65;
  uint64_t v66;
  char v67;
  os_log_type_t type[16];
  uint8_t buf[4];
  const char *v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  char *v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v70 = "__nw_frame_inherit_metadata";
    v54 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v54, type, &v67))
      goto LABEL_114;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v55 = __nwlog_obj();
      v56 = type[0];
      if (!os_log_type_enabled(v55, type[0]))
        goto LABEL_114;
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_inherit_metadata";
      v57 = "%{public}s called with null original_frame";
      goto LABEL_113;
    }
    if (!v67)
    {
      v55 = __nwlog_obj();
      v56 = type[0];
      if (!os_log_type_enabled(v55, type[0]))
        goto LABEL_114;
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_inherit_metadata";
      v57 = "%{public}s called with null original_frame, backtrace limit exceeded";
      goto LABEL_113;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v55 = __nwlog_obj();
    v56 = type[0];
    v59 = os_log_type_enabled(v55, type[0]);
    if (!backtrace_string)
    {
      if (!v59)
        goto LABEL_114;
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_inherit_metadata";
      v57 = "%{public}s called with null original_frame, no backtrace";
      goto LABEL_113;
    }
    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      v70 = "__nw_frame_inherit_metadata";
      v71 = 2082;
      v72 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null original_frame, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_114:
    if (!v54)
      return;
    goto LABEL_115;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v70 = "__nw_frame_inherit_metadata";
    v54 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v54, type, &v67))
      goto LABEL_114;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v55 = __nwlog_obj();
      v56 = type[0];
      if (!os_log_type_enabled(v55, type[0]))
        goto LABEL_114;
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_inherit_metadata";
      v57 = "%{public}s called with null new_frame";
      goto LABEL_113;
    }
    if (!v67)
    {
      v55 = __nwlog_obj();
      v56 = type[0];
      if (!os_log_type_enabled(v55, type[0]))
        goto LABEL_114;
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_inherit_metadata";
      v57 = "%{public}s called with null new_frame, backtrace limit exceeded";
      goto LABEL_113;
    }
    v60 = (char *)__nw_create_backtrace_string();
    v55 = __nwlog_obj();
    v56 = type[0];
    v61 = os_log_type_enabled(v55, type[0]);
    if (v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446466;
        v70 = "__nw_frame_inherit_metadata";
        v71 = 2082;
        v72 = (uint64_t)v60;
        _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null new_frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v60);
      if (!v54)
        return;
LABEL_115:
      free(v54);
      return;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_inherit_metadata";
      v57 = "%{public}s called with null new_frame, no backtrace";
LABEL_113:
      _os_log_impl(&dword_182FBE000, v55, v56, v57, buf, 0xCu);
      goto LABEL_114;
    }
    goto LABEL_114;
  }
  v4 = a3;
  v5 = *(uint64_t ***)(a1 + 64);
  if (!v5)
  {
LABEL_82:
    if (v4)
    {
      if (*(char *)(a1 + 186) < 0)
        *(_BYTE *)(a2 + 186) |= 0x80u;
    }
    return;
  }
  v65 = (uint64_t **)(a2 + 64);
  v66 = a2 + 120;
  v63 = (_OWORD *)(a2 + 136);
  while (v4)
  {
    v6 = (*((unsigned __int8 *)v5 + 66) >> 6) & 1;
    v7 = v5[6];
    if (v7)
      goto LABEL_9;
LABEL_17:
    if ((*(_WORD *)(a2 + 204) & 8) != 0)
      goto LABEL_6;
LABEL_22:
    v11 = *(void **)(a2 + 168);
    if (v11)
    {
      os_release(v11);
      *(_QWORD *)(a2 + 168) = 0;
    }
    if (v7)
    {
      *(_QWORD *)(a2 + 168) = os_retain(v7);
      v12 = *(unsigned __int16 *)(a2 + 204);
      v13 = v12 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v12 & 0x20) == 0)
      {
        v14 = v7;
        *v63 = *(_OWORD *)&v14[2].isa;

        v13 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
        v4 = a3;
      }
      *(_BYTE *)(a2 + 206) = BYTE2(v13);
      *(_WORD *)(a2 + 204) = v13 | 8;
    }
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xBF | ((_BYTE)v6 << 6);
    v15 = *(_QWORD *)(a2 + 64);
    if (!v15)
    {
      *(_QWORD *)(a2 + 64) = v66;
      *(_QWORD *)(a2 + 72) = v66;
      *(_QWORD *)(a2 + 120) = 0;
      *(_QWORD *)(a2 + 128) = v65;
      goto LABEL_6;
    }
    if (v15 != v66)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446722;
      v70 = "__nw_frame_set_metadata";
      v71 = 2048;
      v72 = v15;
      v73 = 2048;
      v74 = v66;
      v16 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v67 = 0;
      if (!__nwlog_fault(v16, type, &v67))
        goto LABEL_62;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = gLogObj;
        v18 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          v70 = "__nw_frame_set_metadata";
          v71 = 2048;
          v72 = v15;
          v73 = 2048;
          v74 = v66;
          v19 = v17;
          v20 = v18;
          v21 = "%{public}s Existing metadata %p doesn't match expected %p";
          goto LABEL_61;
        }
        goto LABEL_62;
      }
      if (v67)
      {
        v34 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = type[0];
        v37 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v34)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446978;
            v70 = "__nw_frame_set_metadata";
            v71 = 2048;
            v72 = v15;
            v73 = 2048;
            v74 = v66;
            v75 = 2082;
            v76 = v34;
            _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v34);
          goto LABEL_62;
        }
        if (!v37)
        {
LABEL_62:
          if (v16)
            free(v16);
          goto LABEL_6;
        }
        *(_DWORD *)buf = 136446722;
        v70 = "__nw_frame_set_metadata";
        v71 = 2048;
        v72 = v15;
        v73 = 2048;
        v74 = v66;
        v19 = v35;
        v20 = v36;
        v21 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = gLogObj;
        v39 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_62;
        *(_DWORD *)buf = 136446722;
        v70 = "__nw_frame_set_metadata";
        v71 = 2048;
        v72 = v15;
        v73 = 2048;
        v74 = v66;
        v19 = v38;
        v20 = v39;
        v21 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
      }
LABEL_61:
      _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0x20u);
      goto LABEL_62;
    }
LABEL_6:
    v5 = (uint64_t **)*v5;
    if (!v5)
      goto LABEL_82;
  }
  LOBYTE(v6) = 0;
  v7 = v5[6];
  if (!v7)
    goto LABEL_17;
LABEL_9:
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_52132);
  if (nw_protocol_metadata_matches_definition((uint64_t)v7, g_ip_definition))
  {
    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(v7) & 3;
    dscp_value = nw_ip_metadata_get_dscp_value(v7);
    if (dscp_value < 0x40)
    {
      *(_BYTE *)(a2 + 184) = dscp_value;
      goto LABEL_14;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v70 = "__nw_frame_set_dscp_value";
    v40 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v40, type, &v67))
      goto LABEL_80;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v41 = __nwlog_obj();
      v42 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v70 = "__nw_frame_set_dscp_value";
        v43 = v41;
        v44 = v42;
        v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
        goto LABEL_79;
      }
      goto LABEL_80;
    }
    if (!v67)
    {
      v52 = __nwlog_obj();
      v53 = type[0];
      if (!os_log_type_enabled(v52, type[0]))
        goto LABEL_80;
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_set_dscp_value";
      v43 = v52;
      v44 = v53;
      v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
      goto LABEL_79;
    }
    v48 = (char *)__nw_create_backtrace_string();
    v49 = __nwlog_obj();
    v50 = type[0];
    v51 = os_log_type_enabled(v49, type[0]);
    if (v48)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        v70 = "__nw_frame_set_dscp_value";
        v71 = 2082;
        v72 = (uint64_t)v48;
        _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v48);
      goto LABEL_80;
    }
    if (v51)
    {
      *(_DWORD *)buf = 136446210;
      v70 = "__nw_frame_set_dscp_value";
      v43 = v49;
      v44 = v50;
      v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace";
LABEL_79:
      _os_log_impl(&dword_182FBE000, v43, v44, v45, buf, 0xCu);
    }
LABEL_80:
    if (v40)
      free(v40);
LABEL_14:
    service_class = nw_ip_metadata_get_service_class(v7);
    if (service_class > nw_service_class_signaling)
      v10 = 0;
    else
      v10 = dword_183BA8F60[service_class];
    *(_DWORD *)(a2 + 176) = v10;
    *(_DWORD *)(a2 + 180) = nw_ip_metadata_get_fragmentation_value(v7);
  }
  if ((*(_WORD *)(a2 + 204) & 8) == 0)
    goto LABEL_22;
  v22 = v6;
  memset(type, 0, sizeof(type));
  v23 = v7;
  *(_OWORD *)type = *(_OWORD *)&v23[2].isa;

  v24 = *v65;
  if (!*v65)
    goto LABEL_49;
  v25 = 0;
  while (2)
  {
    v26 = v23;
    v27 = v23[1].isa;

    v28 = (void *)v24[6];
    if (v28)
    {
      v29 = v28;
      v30 = v29[1];

      if (nw_protocol_definition_is_equal_unsafe((uint64_t)v27, (uint64_t)v30)
        && !uuid_compare((const unsigned __int8 *)type, (const unsigned __int8 *)v24 + 16))
      {
        os_retain(v26);
        v31 = (void *)v24[6];
        if (v31)
          os_release(v31);
        v24[6] = (uint64_t)v26;
        *((_BYTE *)v24 + 66) = *((_BYTE *)v24 + 66) & 0xBF | (v22 << 6);
        v25 = 1;
        if (v30)
LABEL_41:
          os_release(v30);
      }
      else if (v30)
      {
        goto LABEL_41;
      }
    }
    if (v27)
      os_release(v27);
    v24 = (uint64_t *)*v24;
    if (v24)
      continue;
    break;
  }
  if ((v25 & 1) != 0)
    goto LABEL_51;
LABEL_49:
  v32 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (v32)
    goto LABEL_50;
  v46 = __nwlog_obj();
  os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v70 = "strict_calloc";
  v71 = 2048;
  v72 = 1;
  v73 = 2048;
  v74 = 72;
  v47 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v47))
  {
    free(v47);
LABEL_50:
    v32[6] = os_retain(v23);
    *((_OWORD *)v32 + 1) = *(_OWORD *)type;
    *((_BYTE *)v32 + 66) = *((_BYTE *)v32 + 66) & 0xBF | (v22 << 6);
    *v32 = 0;
    v33 = *(_QWORD **)(a2 + 72);
    v32[1] = v33;
    *v33 = v32;
    *(_QWORD *)(a2 + 72) = v32;
LABEL_51:
    v4 = a3;
    goto LABEL_6;
  }
  __break(1u);
}

nw_endpoint_t nw_path_copy_endpoint_from_tlv(int a1, size_t __n, void *__src)
{
  unsigned int v3;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  id v9;
  os_log_type_t v10;
  unsigned int v11;
  size_t v12;
  NSObject *address;
  id *host_with_numeric_port;
  const sockaddr *v15;
  nw_txt_record_t v16;
  nw_txt_record_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  os_log_type_t v27;
  os_log_type_t v28;
  dispatch_data_t v30;
  dispatch_data_t v31;
  size_t v32;
  const char *v33;
  size_t v34;
  const char *v35;
  size_t v36;
  size_t v37;
  const char *v38;
  size_t v39;
  const char *v40;
  size_t v41;
  const char *v42;
  size_t v43;
  const char *v44;
  size_t v45;
  int v46;
  int v47;
  size_t v48;
  size_t v49;
  BOOL v50;
  nw_txt_record_t v51;
  size_t v52;
  size_t v53;
  void *v54;
  os_log_type_t v55;
  void *v56;
  os_log_type_t v57;
  void *v58;
  os_log_type_t v59;
  void *v60;
  os_log_type_t v61;
  void *v62;
  NSObject *v63;
  os_log_type_t v64;
  void *v65;
  os_log_type_t v66;
  void *v67;
  os_log_type_t v68;
  char *v69;
  os_log_type_t v70;
  _BOOL4 v71;
  os_log_type_t v72;
  _BOOL4 v73;
  os_log_type_t v74;
  _BOOL4 v75;
  os_log_type_t v76;
  _BOOL4 v77;
  os_log_type_t v78;
  _BOOL4 v79;
  void *v80;
  os_log_type_t v81;
  void *v82;
  os_log_type_t v83;
  os_log_type_t v84;
  _BOOL4 v85;
  os_log_type_t v86;
  _BOOL4 v87;
  os_log_type_t v88;
  os_log_type_t v89;
  os_log_type_t v90;
  os_log_type_t v91;
  os_log_type_t v92;
  void *v93;
  os_log_type_t v94;
  os_log_type_t v95;
  _BOOL4 v96;
  os_log_type_t v97;
  _BOOL4 v98;
  os_log_type_t v99;
  os_log_type_t v100;
  void *v101;
  os_log_type_t v102;
  os_log_type_t v103;
  _BOOL4 v104;
  os_log_type_t v105;
  os_log_type_t v106;
  os_log_type_t v107;
  _BOOL4 v108;
  os_log_type_t v109;
  os_log_type_t v110;
  char v111;
  os_log_type_t v112;
  os_log_type_t type[16];
  uint8_t buf[4];
  const char *v115;
  __int16 v116;
  int v117;
  __int16 v118;
  unsigned int v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  int v123;
  __int16 v124;
  char *v125;
  sockaddr __dst[16];
  uint64_t v127;

  v3 = __n;
  v127 = *MEMORY[0x1E0C80C00];
  memset(__dst, 0, sizeof(__dst));
  if ((__n - 257) <= 0xFFFFFF06)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v115 = "nw_path_copy_endpoint_from_tlv";
    v116 = 1024;
    v117 = a1;
    v118 = 1024;
    v119 = v3;
    v120 = 2080;
    v121 = "nw_path_copy_endpoint_from_tlv";
    v122 = 1024;
    v123 = 1693;
    v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v112 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v6, type, &v112))
      goto LABEL_50;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1693;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
LABEL_49:

LABEL_50:
      if (!v6)
        return 0;
LABEL_51:
      free(v6);
      return 0;
    }
    if (v112 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v27 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1693;
        _os_log_impl(&dword_182FBE000, v7, v27, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v19 = type[0];
    v20 = os_log_type_enabled(v7, type[0]);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1693;
        _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
      goto LABEL_49;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136447490;
      v115 = "nw_path_copy_endpoint_from_tlv";
      v116 = 1024;
      v117 = a1;
      v118 = 1024;
      v119 = v3;
      v120 = 2080;
      v121 = "nw_path_copy_endpoint_from_tlv";
      v122 = 1024;
      v123 = 1693;
      v124 = 2082;
      v125 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }
LABEL_31:

    free(backtrace_string);
    if (!v6)
      return 0;
    goto LABEL_51;
  }
  memcpy(__dst, __src, __n);
  if (__dst[0].sa_len > v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v115 = "nw_path_copy_endpoint_from_tlv";
    v116 = 1024;
    v117 = a1;
    v118 = 1024;
    v119 = v3;
    v120 = 2080;
    v121 = "nw_path_copy_endpoint_from_tlv";
    v122 = 1024;
    v123 = 1874;
    v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v112 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v6, type, &v112))
      goto LABEL_50;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v10 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1874;
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
      goto LABEL_49;
    }
    if (v112 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v28 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1874;
        _os_log_impl(&dword_182FBE000, v7, v28, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v21 = type[0];
    v22 = os_log_type_enabled(v7, type[0]);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136447234;
        v115 = "nw_path_copy_endpoint_from_tlv";
        v116 = 1024;
        v117 = a1;
        v118 = 1024;
        v119 = v3;
        v120 = 2080;
        v121 = "nw_path_copy_endpoint_from_tlv";
        v122 = 1024;
        v123 = 1874;
        _os_log_impl(&dword_182FBE000, v7, v21, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
      goto LABEL_49;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136447490;
      v115 = "nw_path_copy_endpoint_from_tlv";
      v116 = 1024;
      v117 = a1;
      v118 = 1024;
      v119 = v3;
      v120 = 2080;
      v121 = "nw_path_copy_endpoint_from_tlv";
      v122 = 1024;
      v123 = 1874;
      v124 = 2082;
      v125 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v7, v21, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }
    goto LABEL_31;
  }
  v11 = __dst[0].sa_len - 8;
  if (v3 - 8 >= v11)
    v12 = v11;
  else
    v12 = v3 - 8;
  if (!__dst[0].sa_family)
  {
    host_with_numeric_port = 0;
    switch(*(_DWORD *)&__dst[0].sa_data[2])
    {
      case 0:
        return (nw_endpoint_t)host_with_numeric_port;
      case 2:
        v23 = strnlen(&__dst[0].sa_data[6], v12);
        if (v23 >= v12)
        {
          __nwlog_obj();
          v54 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1719;
          v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112))
            goto LABEL_50;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v55 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1719;
              _os_log_impl(&dword_182FBE000, v7, v55, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v70 = type[0];
            v71 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v71)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1719;
                v124 = 2082;
                v125 = v69;
                _os_log_impl(&dword_182FBE000, v7, v70, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v71)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1719;
              _os_log_impl(&dword_182FBE000, v7, v70, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v88 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1719;
              _os_log_impl(&dword_182FBE000, v7, v88, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        v24 = v23;
        host_with_numeric_port = (id *)nw_endpoint_create_host_with_numeric_port(&__dst[0].sa_data[6], bswap32(*(unsigned __int16 *)__dst[0].sa_data) >> 16);
        if (host_with_numeric_port)
        {
          v25 = v24 + 1;
          v26 = v12 - (v24 + 1);
          if (v12 > v24 + 1)
            goto LABEL_80;
        }
        return (nw_endpoint_t)host_with_numeric_port;
      case 3:
        v32 = strnlen(&__dst[0].sa_data[6], v12);
        if (v32 >= v12)
        {
          __nwlog_obj();
          v56 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1735;
          v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112))
            goto LABEL_50;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v57 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1735;
              _os_log_impl(&dword_182FBE000, v7, v57, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v72 = type[0];
            v73 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v73)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1735;
                v124 = 2082;
                v125 = v69;
                _os_log_impl(&dword_182FBE000, v7, v72, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v73)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1735;
              _os_log_impl(&dword_182FBE000, v7, v72, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v89 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1735;
              _os_log_impl(&dword_182FBE000, v7, v89, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        v33 = &__dst[0].sa_data[v32 + 7];
        v34 = strnlen(v33, v12 - (v32 + 1)) + v32 + 1;
        if (v34 >= v12)
        {
          __nwlog_obj();
          v65 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1742;
          v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112))
            goto LABEL_50;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v66 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1742;
              _os_log_impl(&dword_182FBE000, v7, v66, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v84 = type[0];
            v85 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v85)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1742;
                v124 = 2082;
                v125 = v69;
                _os_log_impl(&dword_182FBE000, v7, v84, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v85)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1742;
              _os_log_impl(&dword_182FBE000, v7, v84, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v99 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1742;
              _os_log_impl(&dword_182FBE000, v7, v99, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        v35 = &__dst[0].sa_data[v34 + 7];
        v36 = strnlen(v35, v12 - (v34 + 1)) + v34 + 1;
        if (v36 >= v12)
        {
          __nwlog_obj();
          v80 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1749;
          v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112))
            goto LABEL_50;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v81 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1749;
              _os_log_impl(&dword_182FBE000, v7, v81, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v95 = type[0];
            v96 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v96)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1749;
                v124 = 2082;
                v125 = v69;
                _os_log_impl(&dword_182FBE000, v7, v95, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v96)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1749;
              _os_log_impl(&dword_182FBE000, v7, v95, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v105 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1749;
              _os_log_impl(&dword_182FBE000, v7, v105, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        host_with_numeric_port = (id *)nw_endpoint_create_bonjour_service(&__dst[0].sa_data[6], v33, v35);
        if (host_with_numeric_port)
        {
          v25 = v36 + 1;
          v26 = v12 - (v36 + 1);
          if (v12 > v36 + 1)
            goto LABEL_80;
        }
        return (nw_endpoint_t)host_with_numeric_port;
      case 4:
        if (strnlen(&__dst[0].sa_data[6], v12) >= v12)
        {
          __nwlog_obj();
          v58 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1726;
          v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112))
            goto LABEL_50;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v59 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1726;
              _os_log_impl(&dword_182FBE000, v7, v59, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v74 = type[0];
            v75 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v75)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1726;
                v124 = 2082;
                v125 = v69;
                _os_log_impl(&dword_182FBE000, v7, v74, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v75)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1726;
              _os_log_impl(&dword_182FBE000, v7, v74, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v90 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1726;
              _os_log_impl(&dword_182FBE000, v7, v90, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        return nw_endpoint_create_url(&__dst[0].sa_data[6]);
      case 5:
        v52 = strnlen(&__dst[0].sa_data[6], v12);
        if (v52 >= v12)
        {
          __nwlog_obj();
          v60 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1846;
          v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112))
            goto LABEL_50;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v61 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1846;
              _os_log_impl(&dword_182FBE000, v7, v61, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112 == OS_LOG_TYPE_DEFAULT)
          {
            __nwlog_obj();
            v7 = objc_claimAutoreleasedReturnValue();
            v91 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1846;
              _os_log_impl(&dword_182FBE000, v7, v91, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
            goto LABEL_49;
          }
          v69 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v7 = objc_claimAutoreleasedReturnValue();
          v76 = type[0];
          v77 = os_log_type_enabled(v7, type[0]);
          if (!v69)
          {
            if (v77)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1846;
              _os_log_impl(&dword_182FBE000, v7, v76, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v77)
          {
            *(_DWORD *)buf = 136447490;
            v115 = "nw_path_copy_endpoint_from_tlv";
            v116 = 1024;
            v117 = a1;
            v118 = 1024;
            v119 = v3;
            v120 = 2080;
            v121 = "nw_path_copy_endpoint_from_tlv";
            v122 = 1024;
            v123 = 1846;
            v124 = 2082;
            v125 = v69;
            _os_log_impl(&dword_182FBE000, v7, v76, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
          }
LABEL_185:

          goto LABEL_239;
        }
        v53 = v52;
        host_with_numeric_port = (id *)nw_endpoint_create_srv(&__dst[0].sa_data[6]);
        if (host_with_numeric_port)
        {
          v25 = v53 + 1;
          v26 = v12 - (v53 + 1);
          if (v12 > v53 + 1)
          {
LABEL_80:
            v17 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[0].sa_data[v25 + 6], v26);
            nw_endpoint_set_txt_record(host_with_numeric_port, v17);
            goto LABEL_21;
          }
        }
        return (nw_endpoint_t)host_with_numeric_port;
      case 6:
        memset(type, 0, sizeof(type));
        uuid_clear((unsigned __int8 *)type);
        v37 = strnlen(&__dst[0].sa_data[6], v12);
        if (v37 >= v12)
        {
          __nwlog_obj();
          v62 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136447234;
          v115 = "nw_path_copy_endpoint_from_tlv";
          v116 = 1024;
          v117 = a1;
          v118 = 1024;
          v119 = v3;
          v120 = 2080;
          v121 = "nw_path_copy_endpoint_from_tlv";
          v122 = 1024;
          v123 = 1771;
          v6 = (char *)_os_log_send_and_compose_impl();

          v112 = OS_LOG_TYPE_ERROR;
          v111 = 0;
          if (!__nwlog_fault(v6, &v112, &v111))
            goto LABEL_50;
          if (v112 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v63 = objc_claimAutoreleasedReturnValue();
            v64 = v112;
            if (os_log_type_enabled(v63, v112))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1771;
              _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_258;
          }
          if (!v111)
          {
            __nwlog_obj();
            v63 = objc_claimAutoreleasedReturnValue();
            v92 = v112;
            if (os_log_type_enabled(v63, v112))
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1771;
              _os_log_impl(&dword_182FBE000, v63, v92, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
            goto LABEL_258;
          }
          v69 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v63 = objc_claimAutoreleasedReturnValue();
          v78 = v112;
          v79 = os_log_type_enabled(v63, v112);
          if (!v69)
          {
            if (v79)
            {
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1771;
              _os_log_impl(&dword_182FBE000, v63, v78, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
            goto LABEL_258;
          }
          if (v79)
          {
            *(_DWORD *)buf = 136447490;
            v115 = "nw_path_copy_endpoint_from_tlv";
            v116 = 1024;
            v117 = a1;
            v118 = 1024;
            v119 = v3;
            v120 = 2080;
            v121 = "nw_path_copy_endpoint_from_tlv";
            v122 = 1024;
            v123 = 1771;
            v124 = 2082;
            v125 = v69;
            _os_log_impl(&dword_182FBE000, v63, v78, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
          }
        }
        else
        {
          v38 = &__dst[0].sa_data[v37 + 7];
          v39 = strnlen(v38, v12 - (v37 + 1)) + v37 + 1;
          if (v39 >= v12)
          {
            __nwlog_obj();
            v67 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136447234;
            v115 = "nw_path_copy_endpoint_from_tlv";
            v116 = 1024;
            v117 = a1;
            v118 = 1024;
            v119 = v3;
            v120 = 2080;
            v121 = "nw_path_copy_endpoint_from_tlv";
            v122 = 1024;
            v123 = 1778;
            v6 = (char *)_os_log_send_and_compose_impl();

            v112 = OS_LOG_TYPE_ERROR;
            v111 = 0;
            if (!__nwlog_fault(v6, &v112, &v111))
              goto LABEL_50;
            if (v112 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v63 = objc_claimAutoreleasedReturnValue();
              v68 = v112;
              if (os_log_type_enabled(v63, v112))
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1778;
                _os_log_impl(&dword_182FBE000, v63, v68, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
              }
              goto LABEL_258;
            }
            if (!v111)
            {
              __nwlog_obj();
              v63 = objc_claimAutoreleasedReturnValue();
              v100 = v112;
              if (os_log_type_enabled(v63, v112))
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1778;
                _os_log_impl(&dword_182FBE000, v63, v100, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
              }
              goto LABEL_258;
            }
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v63 = objc_claimAutoreleasedReturnValue();
            v86 = v112;
            v87 = os_log_type_enabled(v63, v112);
            if (!v69)
            {
              if (v87)
              {
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1778;
                _os_log_impl(&dword_182FBE000, v63, v86, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
              }
              goto LABEL_258;
            }
            if (v87)
            {
              *(_DWORD *)buf = 136447490;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1778;
              v124 = 2082;
              v125 = v69;
              _os_log_impl(&dword_182FBE000, v63, v86, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
            }
          }
          else
          {
            v40 = &__dst[0].sa_data[v39 + 7];
            v41 = strnlen(v40, v12 - (v39 + 1)) + v39 + 1;
            if (v41 >= v12)
            {
              __nwlog_obj();
              v82 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136447234;
              v115 = "nw_path_copy_endpoint_from_tlv";
              v116 = 1024;
              v117 = a1;
              v118 = 1024;
              v119 = v3;
              v120 = 2080;
              v121 = "nw_path_copy_endpoint_from_tlv";
              v122 = 1024;
              v123 = 1785;
              v6 = (char *)_os_log_send_and_compose_impl();

              v112 = OS_LOG_TYPE_ERROR;
              v111 = 0;
              if (!__nwlog_fault(v6, &v112, &v111))
                goto LABEL_50;
              if (v112 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v63 = objc_claimAutoreleasedReturnValue();
                v83 = v112;
                if (os_log_type_enabled(v63, v112))
                {
                  *(_DWORD *)buf = 136447234;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  v116 = 1024;
                  v117 = a1;
                  v118 = 1024;
                  v119 = v3;
                  v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  v122 = 1024;
                  v123 = 1785;
                  _os_log_impl(&dword_182FBE000, v63, v83, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
                }
                goto LABEL_258;
              }
              if (!v111)
              {
                __nwlog_obj();
                v63 = objc_claimAutoreleasedReturnValue();
                v106 = v112;
                if (os_log_type_enabled(v63, v112))
                {
                  *(_DWORD *)buf = 136447234;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  v116 = 1024;
                  v117 = a1;
                  v118 = 1024;
                  v119 = v3;
                  v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  v122 = 1024;
                  v123 = 1785;
                  _os_log_impl(&dword_182FBE000, v63, v106, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
                }
                goto LABEL_258;
              }
              v69 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v63 = objc_claimAutoreleasedReturnValue();
              v97 = v112;
              v98 = os_log_type_enabled(v63, v112);
              if (!v69)
              {
                if (v98)
                {
                  *(_DWORD *)buf = 136447234;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  v116 = 1024;
                  v117 = a1;
                  v118 = 1024;
                  v119 = v3;
                  v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  v122 = 1024;
                  v123 = 1785;
                  _os_log_impl(&dword_182FBE000, v63, v97, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
                }
                goto LABEL_258;
              }
              if (v98)
              {
                *(_DWORD *)buf = 136447490;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1785;
                v124 = 2082;
                v125 = v69;
                _os_log_impl(&dword_182FBE000, v63, v97, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
            }
            else
            {
              v42 = &__dst[0].sa_data[v41 + 7];
              v43 = strnlen(v42, v12 - (v41 + 1)) + v41 + 1;
              if (v43 >= v12)
              {
                __nwlog_obj();
                v93 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1792;
                v6 = (char *)_os_log_send_and_compose_impl();

                v112 = OS_LOG_TYPE_ERROR;
                v111 = 0;
                if (!__nwlog_fault(v6, &v112, &v111))
                  goto LABEL_50;
                if (v112 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v63 = objc_claimAutoreleasedReturnValue();
                  v94 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    v116 = 1024;
                    v117 = a1;
                    v118 = 1024;
                    v119 = v3;
                    v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    v122 = 1024;
                    v123 = 1792;
                    _os_log_impl(&dword_182FBE000, v63, v94, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                if (!v111)
                {
                  __nwlog_obj();
                  v63 = objc_claimAutoreleasedReturnValue();
                  v109 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    v116 = 1024;
                    v117 = a1;
                    v118 = 1024;
                    v119 = v3;
                    v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    v122 = 1024;
                    v123 = 1792;
                    _os_log_impl(&dword_182FBE000, v63, v109, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                v69 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v63 = objc_claimAutoreleasedReturnValue();
                v103 = v112;
                v104 = os_log_type_enabled(v63, v112);
                if (!v69)
                {
                  if (v104)
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    v116 = 1024;
                    v117 = a1;
                    v118 = 1024;
                    v119 = v3;
                    v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    v122 = 1024;
                    v123 = 1792;
                    _os_log_impl(&dword_182FBE000, v63, v103, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                if (v104)
                {
                  *(_DWORD *)buf = 136447490;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  v116 = 1024;
                  v117 = a1;
                  v118 = 1024;
                  v119 = v3;
                  v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  v122 = 1024;
                  v123 = 1792;
                  v124 = 2082;
                  v125 = v69;
                  _os_log_impl(&dword_182FBE000, v63, v103, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
                }
              }
              else
              {
                v44 = &__dst[0].sa_data[v43 + 7];
                v45 = strnlen(v44, v12 - (v43 + 1)) + v43 + 1;
                if (v45 < v12)
                {
                  v46 = *(_DWORD *)&__dst[0].sa_data[v45 + 7];
                  v47 = *(_DWORD *)&__dst[0].sa_data[v45 + 11];
                  v48 = v45 + 9;
                  v49 = v45 + 25;
                  if (v49 <= v12)
                  {
                    *(sockaddr *)type = *(sockaddr *)&__dst[0].sa_data[v48 + 6];
                    v48 = v49;
                  }
                  host_with_numeric_port = (id *)nw_endpoint_create_application_service_internal(v38, &__dst[0].sa_data[6], (const unsigned __int8 *)type, v40, v42, v46, v47, v44);
                  if (host_with_numeric_port)
                    v50 = v48 + 1 >= v12;
                  else
                    v50 = 1;
                  if (!v50)
                  {
                    v51 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[0].sa_data[v48 + 6], v12 - v48);
                    nw_endpoint_set_txt_record(host_with_numeric_port, v51);

                  }
                  return (nw_endpoint_t)host_with_numeric_port;
                }
                __nwlog_obj();
                v101 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136447234;
                v115 = "nw_path_copy_endpoint_from_tlv";
                v116 = 1024;
                v117 = a1;
                v118 = 1024;
                v119 = v3;
                v120 = 2080;
                v121 = "nw_path_copy_endpoint_from_tlv";
                v122 = 1024;
                v123 = 1799;
                v6 = (char *)_os_log_send_and_compose_impl();

                v112 = OS_LOG_TYPE_ERROR;
                v111 = 0;
                if (!__nwlog_fault(v6, &v112, &v111))
                  goto LABEL_50;
                if (v112 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v63 = objc_claimAutoreleasedReturnValue();
                  v102 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    v116 = 1024;
                    v117 = a1;
                    v118 = 1024;
                    v119 = v3;
                    v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    v122 = 1024;
                    v123 = 1799;
                    _os_log_impl(&dword_182FBE000, v63, v102, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
                  }
LABEL_258:

                  goto LABEL_50;
                }
                if (!v111)
                {
                  __nwlog_obj();
                  v63 = objc_claimAutoreleasedReturnValue();
                  v110 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    v116 = 1024;
                    v117 = a1;
                    v118 = 1024;
                    v119 = v3;
                    v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    v122 = 1024;
                    v123 = 1799;
                    _os_log_impl(&dword_182FBE000, v63, v110, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                v69 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v63 = objc_claimAutoreleasedReturnValue();
                v107 = v112;
                v108 = os_log_type_enabled(v63, v112);
                if (!v69)
                {
                  if (v108)
                  {
                    *(_DWORD *)buf = 136447234;
                    v115 = "nw_path_copy_endpoint_from_tlv";
                    v116 = 1024;
                    v117 = a1;
                    v118 = 1024;
                    v119 = v3;
                    v120 = 2080;
                    v121 = "nw_path_copy_endpoint_from_tlv";
                    v122 = 1024;
                    v123 = 1799;
                    _os_log_impl(&dword_182FBE000, v63, v107, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                if (v108)
                {
                  *(_DWORD *)buf = 136447490;
                  v115 = "nw_path_copy_endpoint_from_tlv";
                  v116 = 1024;
                  v117 = a1;
                  v118 = 1024;
                  v119 = v3;
                  v120 = 2080;
                  v121 = "nw_path_copy_endpoint_from_tlv";
                  v122 = 1024;
                  v123 = 1799;
                  v124 = 2082;
                  v125 = v69;
                  _os_log_impl(&dword_182FBE000, v63, v107, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
                }
              }
            }
          }
        }

LABEL_239:
        free(v69);
        if (!v6)
          return 0;
        goto LABEL_51;
      default:
        if (!(_DWORD)v12)
          return 0;
        v30 = dispatch_data_create(&__dst[0].sa_data[6], v12, 0, 0);
        if (!v30)
          return 0;
        v31 = v30;
        host_with_numeric_port = (id *)nw_endpoint_create_custom(*(unsigned int *)&__dst[0].sa_data[2], v30, 0);

        return (nw_endpoint_t)host_with_numeric_port;
    }
  }
  address = nw_endpoint_create_address(__dst);
  host_with_numeric_port = (id *)&address->isa;
  if (address)
  {
    v15 = nw_endpoint_get_address(address);
    if (v3 >= 0x1D)
    {
      if (v15)
      {
        v16 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[1].sa_data[10], v3 - 28);
        host_with_numeric_port = host_with_numeric_port;
        v17 = v16;
        objc_storeStrong(host_with_numeric_port + 23, v16);

LABEL_21:
      }
    }
  }
  return (nw_endpoint_t)host_with_numeric_port;
}

