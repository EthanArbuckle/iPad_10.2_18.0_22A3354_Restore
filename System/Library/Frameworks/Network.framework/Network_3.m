void nw_connection_fillout_failed_resolution_report_on_nw_queue(void *a1, void *a2)
{
  void **v3;
  id v4;
  _DWORD *v5;
  _DWORD *v6;
  int v7;
  NWConcrete_nw_resolution_report *v8;
  nw_endpoint_t v9;
  nw_endpoint_t v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  _DWORD *v15;
  int v16;
  nw_endpoint_t v17;
  nw_endpoint_t v18;
  NSObject *v19;
  unsigned int isa;
  NWConcrete_nw_resolution_report *v21;
  void *v22;
  int event_milliseconds;
  nw_endpoint_t v24;
  OS_nw_endpoint *preferred_endpoint;
  OS_nw_array *v26;
  OS_nw_array *resolved_endpoints;
  void *v28;
  void *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  void *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  char *v37;
  os_log_type_t v38;
  _BOOL4 v39;
  char *backtrace_string;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  os_log_type_t v44;
  void *v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  os_log_type_t v52;
  os_log_type_t type[8];
  unsigned __int16 v54;
  BOOL v55;
  __int16 v56;
  _BYTE buf[12];
  __int16 v58;
  char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    nw_context_assert_queue(v3[3]);
    v5 = v4;
    if (v5)
    {
      v6 = v5;
      v7 = v5[29];

      if (v7 == 1)
      {
        v8 = objc_alloc_init(NWConcrete_nw_resolution_report);
        v56 = WORD2(v6) ^ WORD1(v6) ^ HIWORD(v6) ^ (unsigned __int16)v6;
        v9 = nw_endpoint_handler_copy_endpoint(v6);
        v10 = v9;
        if (v9 && (v11 = v9, v12 = -[NSObject type](v11, "type"), v11, v12 == 3))
        {
          v13 = 4;
          v14 = 3;
        }
        else
        {
          v13 = 2;
          v14 = 1;
        }
        event_milliseconds = nw_connection_get_event_milliseconds(v3, 2, v14, &v56, 0);
        v8->milliseconds = nw_connection_get_event_milliseconds(v3, 2, v13, &v56, 0)
                         - event_milliseconds;
        v8->endpoint_count = nw_endpoint_handler_get_resolved_endpoint_count(v6);
        v8->source = nw_endpoint_handler_get_resolution_source(v6);
        v8->protocol = nw_endpoint_handler_get_resolution_protocol(v6);
        v24 = nw_endpoint_handler_copy_preferred_resolved_endpoint(v6);
        preferred_endpoint = v8->preferred_endpoint;
        v8->preferred_endpoint = (OS_nw_endpoint *)v24;

        v26 = (OS_nw_array *)nw_endpoint_handler_copy_resolved_endpoints(v6);
        resolved_endpoints = v8->resolved_endpoints;
        v8->resolved_endpoints = v26;

        v55 = 0;
        nw_endpoint_handler_get_svcb_report(v6, 0, &v55, 0);
        *((_BYTE *)v8 + 70) = *((_BYTE *)v8 + 70) & 0xFE | v55;
        *(_QWORD *)buf = 0;
        nw_endpoint_handler_get_resolution_provider(v6, (uint64_t)buf);
        v8->provider_name = *(char **)buf;
        v54 = 0;
        *(_QWORD *)type = 0;
        nw_endpoint_handler_get_extended_dns_error(v6, &v54, (char **)type);
        v8->extended_dns_error_code = v54;
        v8->extended_dns_error_extra_text = *(char **)type;
        v28 = v3[54];
        v3[54] = v8;

      }
      else
      {
        v15 = v6;
        v16 = v6[29];

        if (v16 == 3 && !v3[54])
        {
          v17 = nw_endpoint_handler_copy_endpoint(v15);
          v18 = v17;
          if (v17)
          {
            v19 = v17;
            isa = v19[28].isa;

            if (isa)
            {
              v21 = objc_alloc_init(NWConcrete_nw_resolution_report);
              if (isa < 4)
                v21->extended_dns_error_code = isa + 14;
              v22 = v3[54];
              v3[54] = v21;

            }
          }

        }
      }
      goto LABEL_17;
    }
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
    v34 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v56) = 0;
    if (__nwlog_fault(v34, type, &v56))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v36 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s called with null handler", buf, 0xCu);
        }
LABEL_51:

        goto LABEL_52;
      }
      if (!(_BYTE)v56)
      {
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v44 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v35, v44, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v41 = type[0];
      v42 = os_log_type_enabled(v35, type[0]);
      if (!backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v35, v41, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
        v58 = 2082;
        v59 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v35, v41, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_52:
    if (v34)
      free(v34);
    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
    v46 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v56) = 0;
    if (!__nwlog_fault(v46, type, &v56))
      goto LABEL_70;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      v48 = type[0];
      if (os_log_type_enabled(v47, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v56)
    {
      v49 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      v50 = type[0];
      v51 = os_log_type_enabled(v47, type[0]);
      if (v49)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          v58 = 2082;
          v59 = v49;
          _os_log_impl(&dword_182FBE000, v47, v50, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v49);
        goto LABEL_70;
      }
      if (v51)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_182FBE000, v47, v50, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      v52 = type[0];
      if (os_log_type_enabled(v47, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_182FBE000, v47, v52, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_70:
    if (v46)
      free(v46);
    goto LABEL_17;
  }
  __nwlog_obj();
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_fillout_failed_resolution_report_on_nw_queue";
  v30 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v56) = 0;
  if (__nwlog_fault(v30, type, &v56))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v32 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_fillout_failed_resolution_report_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if ((_BYTE)v56)
    {
      v37 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v38 = type[0];
      v39 = os_log_type_enabled(v31, type[0]);
      if (v37)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_fillout_failed_resolution_report_on_nw_queue";
          v58 = 2082;
          v59 = v37;
          _os_log_impl(&dword_182FBE000, v31, v38, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v37);
        goto LABEL_47;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_fillout_failed_resolution_report_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v31, v38, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v43 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_fillout_failed_resolution_report_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v31, v43, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_47:
  if (v30)
    free(v30);
LABEL_17:

}

void sub_18318E7D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_resolution_protocol(void *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  int mode;
  id *v4;
  unsigned int *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  id v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_endpoint_handler_get_mode";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        v18 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v36 = "nw_endpoint_handler_get_mode";
            v37 = 2082;
            v38 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v10, v22, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_32:
    if (v9)
      free(v9);
LABEL_34:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v36 = "nw_endpoint_handler_get_resolution_protocol";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v24, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_endpoint_handler_get_resolution_protocol";
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }
      else if (v33)
      {
        v28 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v29 = type;
        v30 = os_log_type_enabled(v25, type);
        if (v28)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v36 = "nw_endpoint_handler_get_resolution_protocol";
            v37 = 2082;
            v38 = v28;
            _os_log_impl(&dword_182FBE000, v25, v29, "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v28);
          if (!v24)
            goto LABEL_41;
          goto LABEL_40;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_endpoint_handler_get_resolution_protocol";
          _os_log_impl(&dword_182FBE000, v25, v29, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v31 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_endpoint_handler_get_resolution_protocol";
          _os_log_impl(&dword_182FBE000, v25, v31, "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v24)
    {
LABEL_41:
      v7 = 0;
      goto LABEL_42;
    }
LABEL_40:
    free(v24);
    goto LABEL_41;
  }
  mode = v1->mode;

  if (mode != 1)
    goto LABEL_34;
  v4 = (id *)nw_endpoint_handler_copy_resolver(v2);
  v5 = (unsigned int *)v4[1];
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_resolver_get_resolution_protocol";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v13, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_resolver_get_resolution_protocol";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null resolver", buf, 0xCu);
        }
      }
      else if (v33)
      {
        v19 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        v21 = os_log_type_enabled(v14, type);
        if (v19)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            v36 = "nw_resolver_get_resolution_protocol";
            v37 = 2082;
            v38 = v19;
            _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v19);
          goto LABEL_61;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_resolver_get_resolution_protocol";
          _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_resolver_get_resolution_protocol";
          _os_log_impl(&dword_182FBE000, v14, v32, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_61:
    if (v13)
      free(v13);
    v7 = 0;
    goto LABEL_5;
  }
  v7 = v5[62];
LABEL_5:

LABEL_42:
  return v7;
}

void sub_18318EF88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_endpoint_handler_get_extended_dns_error(void *a1, _WORD *a2, char **a3)
{
  NWConcrete_nw_endpoint_handler *v5;
  NWConcrete_nw_endpoint_handler *v6;
  int mode;
  id *v8;
  const char **v9;
  const char **v10;
  const char *v11;
  char *v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  NSObject *v27;
  void *v28;
  os_log_type_t v29;
  id v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  char *v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  os_log_type_t v38;
  char v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  char *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_endpoint_handler_get_mode";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v14, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        v23 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_endpoint_handler_get_mode";
            v43 = 2082;
            v44 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v15, v29, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_39:
    if (v14)
      free(v14);
LABEL_41:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v42 = "nw_endpoint_handler_get_extended_dns_error";
    v31 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v31, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = (id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_endpoint_handler_get_extended_dns_error";
          _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }
      else if (v39)
      {
        v34 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = (id)gLogObj;
        v35 = type;
        v36 = os_log_type_enabled(v32, type);
        if (v34)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_endpoint_handler_get_extended_dns_error";
            v43 = 2082;
            v44 = v34;
            _os_log_impl(&dword_182FBE000, v32, v35, "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v34);
          if (!v31)
            goto LABEL_48;
          goto LABEL_47;
        }
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_endpoint_handler_get_extended_dns_error";
          _os_log_impl(&dword_182FBE000, v32, v35, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = (id)gLogObj;
        v37 = type;
        if (os_log_type_enabled(v32, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_endpoint_handler_get_extended_dns_error";
          _os_log_impl(&dword_182FBE000, v32, v37, "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v31)
      goto LABEL_48;
LABEL_47:
    free(v31);
    goto LABEL_48;
  }
  mode = v5->mode;

  if (mode != 1)
    goto LABEL_41;
  v8 = (id *)nw_endpoint_handler_copy_resolver(v6);
  v9 = (const char **)v8[1];
  v10 = v9;
  if (!v9)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_resolver_get_extended_dns_error";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v18, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_resolver_get_extended_dns_error";
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null resolver", buf, 0xCu);
        }
      }
      else if (v39)
      {
        v24 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        v26 = os_log_type_enabled(v19, type);
        if (v24)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_resolver_get_extended_dns_error";
            v43 = 2082;
            v44 = v24;
            _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v24);
          goto LABEL_67;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_resolver_get_extended_dns_error";
          _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v38 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_resolver_get_extended_dns_error";
          _os_log_impl(&dword_182FBE000, v19, v38, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_67:
    if (v18)
      free(v18);
    goto LABEL_10;
  }
  if (a2)
    *a2 = *((_WORD *)v9 + 172);
  if (!a3)
    goto LABEL_10;
  v11 = v9[28];
  if (!v11)
    goto LABEL_10;
  v12 = strdup(v11);
  if (v12)
  {
LABEL_9:
    *a3 = v12;
LABEL_10:

LABEL_48:
    return;
  }
  __nwlog_obj();
  v27 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v42 = "strict_strdup";
  v28 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v28))
  {
    free(v28);
    goto LABEL_9;
  }
  __break(1u);
}

void sub_18318F7A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_handler_copy_preferred_resolved_endpoint(void *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  int mode;
  NWConcrete_nw_endpoint_mode_handler *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  nw_endpoint_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  id v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_endpoint_handler_get_mode";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v10, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_endpoint_handler_get_mode";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_25:
    if (v10)
      free(v10);
LABEL_27:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }
      else if (v26)
      {
        v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v22 = type;
        v23 = os_log_type_enabled(v19, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
            v30 = 2082;
            v31 = v21;
            _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v21);
          if (!v18)
            goto LABEL_46;
          goto LABEL_45;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_endpoint_handler_copy_preferred_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v19, v24, "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v18)
    {
LABEL_46:
      v8 = 0;
      goto LABEL_47;
    }
LABEL_45:
    free(v18);
    goto LABEL_46;
  }
  mode = v1->mode;

  if (mode != 1)
    goto LABEL_27;
  v4 = nw_endpoint_handler_copy_resolver(v2);
  v5 = *((_QWORD *)v4 + 5);
  if (v5
    && *(_QWORD *)(v5 + 16) != *(_QWORD *)(v5 + 24)
    && (nw_array_get_object_at_index(v5, 0), (v6 = (void *)objc_claimAutoreleasedReturnValue()) != 0))
  {
    v7 = v6;
    v8 = nw_endpoint_handler_copy_endpoint(v6);

  }
  else
  {
    v8 = 0;
  }

LABEL_47:
  return v8;
}

void sub_18318FCFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_resolution_provider(void *a1, uint64_t a2)
{
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_handler *v4;
  int mode;
  id *v6;
  const unsigned __int8 *v7;
  unsigned __int8 *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  id v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  os_log_type_t v35;
  char v36;
  os_log_type_t type;
  _BYTE buf[24];
  void *v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v12, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        v21 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_36:
    if (v12)
      free(v12);
LABEL_38:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_resolution_provider";
    v27 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v27, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_resolution_provider";
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
        }
      }
      else if (v36)
      {
        v30 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        v31 = type;
        v32 = os_log_type_enabled(v28, type);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_resolution_provider";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30;
            _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v30);
          if (!v27)
            goto LABEL_57;
          goto LABEL_56;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_resolution_provider";
          _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_resolution_provider";
          _os_log_impl(&dword_182FBE000, v28, v33, "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v27)
    {
LABEL_57:
      v10 = 0;
      goto LABEL_58;
    }
LABEL_56:
    free(v27);
    goto LABEL_57;
  }
  mode = v3->mode;

  if (mode != 1)
    goto LABEL_38;
  v6 = (id *)nw_endpoint_handler_copy_resolver(v4);
  v7 = (const unsigned __int8 *)v6[1];
  v8 = (unsigned __int8 *)v7;
  if (!v7)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_resolver_get_resolution_provider";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v16, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_resolver_get_resolution_provider";
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null resolver", buf, 0xCu);
        }
      }
      else if (v36)
      {
        v22 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        v24 = os_log_type_enabled(v17, type);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_resolver_get_resolution_provider";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v22;
            _os_log_impl(&dword_182FBE000, v17, v23, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v22);
          goto LABEL_65;
        }
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_resolver_get_resolution_provider";
          _os_log_impl(&dword_182FBE000, v17, v23, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v35 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_resolver_get_resolution_provider";
          _os_log_impl(&dword_182FBE000, v17, v35, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_65:
    if (v16)
      free(v16);
    v10 = 0;
    goto LABEL_9;
  }
  if (a2 && !uuid_is_null(v7 + 232) && ((char)v8[347] & 0x80000000) == 0)
  {
    v9 = (void *)*((_QWORD *)v8 + 25);
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __nw_resolver_get_resolution_provider_block_invoke;
    v39 = &unk_1E149ACE8;
    v40 = v8;
    v41 = a2;
    nw_path_enumerate_resolver_configs(v9, buf);

  }
  v10 = *((unsigned int *)v8 + 63);
LABEL_9:

LABEL_58:
  return v10;
}

void sub_1831904D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

BOOL nw_establishment_report_get_used_proxy(nw_establishment_report_t report)
{
  nw_establishment_report_t v1;
  nw_establishment_report_t v2;
  _BOOL4 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = report;
  v2 = v1;
  if (v1)
  {
    v3 = (BYTE4(v1[10].isa) >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_establishment_report_get_used_proxy";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_establishment_report_get_used_proxy";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_establishment_report_get_used_proxy";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_establishment_report_get_used_proxy";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_establishment_report_get_used_proxy";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_get_ipv4_network_signature(void *a1, void *a2, _BYTE *a3)
{
  NWConcrete_nw_path *v5;
  NWConcrete_nw_path *v6;
  OS_nw_interface *direct;
  uint64_t ipv4_network_signature;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  os_log_type_t v25;
  os_log_type_t v26;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_get_ipv4_network_signature";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v24, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_path_get_ipv4_network_signature";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_36;
  }
  if (!a2)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_get_ipv4_network_signature";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null signature", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null signature, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_path_get_ipv4_network_signature";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null signature, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_36;
  }
  if (!a3)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_get_ipv4_network_signature";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null signature_len", buf, 0xCu);
      }
LABEL_54:

LABEL_55:
      if (v10)
        free(v10);
      goto LABEL_57;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v26, "%{public}s called with null signature_len, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_path_get_ipv4_network_signature";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null signature_len, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_36:

    free(backtrace_string);
    goto LABEL_55;
  }
  if (!nw_path_network_is_satisfied_update_reason(v5, 0) || (direct = v6->direct) == 0)
  {
LABEL_57:
    ipv4_network_signature = 0;
    goto LABEL_58;
  }
  ipv4_network_signature = nw_interface_get_ipv4_network_signature(direct, a2, a3);
LABEL_58:

  return ipv4_network_signature;
}

void sub_183190E70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_interface_get_ipv4_network_signature(void *a1, void *a2, _BYTE *a3)
{
  unsigned __int8 *v5;
  void *v6;
  id v7;
  int v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  int v12;
  size_t v13;
  uint64_t v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  int v18;
  os_log_type_t v19;
  int v20;
  int v21;
  void *v23;
  NSObject *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  void *v28;
  os_log_type_t v29;
  char *backtrace_string;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  os_log_type_t v38;
  os_log_type_t v39;
  char v40;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  _WORD v45[17];

  *(_QWORD *)&v45[13] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_interface_get_ipv4_network_signature";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null interface", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v40)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v37, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v31 = type;
    v32 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_interface_get_ipv4_network_signature";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (!a2)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_interface_get_ipv4_network_signature";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s called with null signature", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (!v40)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v38, "%{public}s called with null signature, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v33 = type;
    v34 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null signature, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_interface_get_ipv4_network_signature";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null signature, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_56;
  }
  if (!a3)
  {
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_interface_get_ipv4_network_signature";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v9, &type, &v40))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s called with null signature_len", buf, 0xCu);
      }
LABEL_74:

      goto LABEL_23;
    }
    if (!v40)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v39, "%{public}s called with null signature_len, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v35 = type;
    v36 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_interface_get_ipv4_network_signature";
        _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s called with null signature_len, no backtrace", buf, 0xCu);
      }
      goto LABEL_74;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_interface_get_ipv4_network_signature";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s called with null signature_len, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_56:

    free(backtrace_string);
    goto LABEL_23;
  }
  if (*a3 <= 0x13u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = *a3;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_interface_get_ipv4_network_signature";
    v44 = 1024;
    *(_DWORD *)v45 = v8;
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v9, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          v12 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv4_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v12;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s signature length %u is less than IFNET_SIGNATURELEN", buf, 0x12u);
        }
      }
      else if (v40)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v16 = type;
        v17 = os_log_type_enabled(v10, type);
        if (v15)
        {
          if (v17)
          {
            v18 = *a3;
            *(_DWORD *)buf = 136446722;
            v43 = "nw_interface_get_ipv4_network_signature";
            v44 = 1024;
            *(_DWORD *)v45 = v18;
            v45[2] = 2082;
            *(_QWORD *)&v45[3] = v15;
            _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v15);
          if (!v9)
            goto LABEL_25;
          goto LABEL_24;
        }
        if (v17)
        {
          v21 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv4_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v21;
          _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          v20 = *a3;
          *(_DWORD *)buf = 136446466;
          v43 = "nw_interface_get_ipv4_network_signature";
          v44 = 1024;
          *(_DWORD *)v45 = v20;
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s signature length %u is less than IFNET_SIGNATURELEN, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
LABEL_23:
    if (!v9)
    {
LABEL_25:
      v14 = 0;
      goto LABEL_26;
    }
LABEL_24:
    free(v9);
    goto LABEL_25;
  }
  v13 = v5[32];
  *a3 = v13;
  memcpy(a2, v5 + 12, v13);
  v14 = 1;
LABEL_26:

  return v14;
}

void nw_quic_connection_set_is_early_data_accepted(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_is_early_data_accepted_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_is_early_data_accepted";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_is_early_data_accepted";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_is_early_data_accepted";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_is_early_data_accepted";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_is_early_data_accepted";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_183191AA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_is_early_data_accepted_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 216) = *(_BYTE *)(a2 + 216) & 0xFE | *(_BYTE *)(a1 + 32);
  return 1;
}

uint64_t ___ZL37nw_endpoint_resolver_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1)
{
  return nw_endpoint_resolver_start_next_child(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
}

Swift::Void __swiftcall NWPathMonitor.cancel()()
{
  uint64_t v0;

  nw_path_monitor_cancel(*(nw_path_monitor_t *)(v0 + 24));
}

void sub_183191AE4(uint64_t a1, unint64_t *a2)
{
  unint64_t ForeignTypeMetadata;
  uint64_t v4;

  if (!*a2)
  {
    ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4)
      atomic_store(ForeignTypeMetadata, a2);
  }
}

BOOL nw_endpoint_handler_register_context_internal(void *a1, void *a2, void *a3)
{
  id v5;
  id *v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  nw_protocol_metadata_t v10;
  void *v11;
  void *v12;
  NWConcrete_nw_protocol_options *v13;
  uint64_t v14;
  id v15;
  id *v16;
  id v17;
  id v18;
  const char *id_string;
  const char *v20;
  nw_endpoint_t v21;
  const char *logging_description;
  const char *v23;
  const char *v24;
  id v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  const char *v30;
  nw_endpoint_t v31;
  const char *v32;
  const char *v33;
  const char *v34;
  id v35;
  const char *backtrace_string;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  const char *v41;
  const char *v42;
  const char *v43;
  const char *v44;
  id v45;
  _BOOL8 v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  void (*v51)(_QWORD *, id *);
  NSObject *v52;
  const char *v53;
  const char *v54;
  nw_endpoint_t v55;
  const char *v56;
  const char *v57;
  const char *v58;
  id v59;
  char *v60;
  id v61;
  const char *v62;
  const char *v63;
  nw_endpoint_t v64;
  const char *v65;
  const char *v66;
  const char *v67;
  id v68;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  const char *v73;
  nw_endpoint_t v74;
  const char *v75;
  const char *v76;
  const char *v77;
  id v78;
  const char *v79;
  char *v80;
  NSObject *v81;
  os_log_type_t v82;
  const char *v83;
  const char *v84;
  const char *v85;
  const char *v86;
  const char *v87;
  const char *v88;
  id v89;
  id v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  NSObject *v94;
  NSObject *v95;
  os_log_type_t v96;
  const char *v97;
  const char *v98;
  nw_endpoint_t v99;
  const char *v100;
  const char *v101;
  const char *v102;
  id v103;
  char *v104;
  NSObject *v105;
  os_log_type_t v106;
  _BOOL4 v107;
  os_log_type_t v108;
  const char *v109;
  const char *v110;
  nw_endpoint_t v111;
  const char *v112;
  const char *v113;
  const char *v114;
  id v115;
  os_log_type_t v116;
  const char *v117;
  const char *v118;
  nw_endpoint_t v119;
  const char *v120;
  const char *v121;
  const char *v122;
  id v123;
  id v124;
  os_log_type_t v125;
  const char *v126;
  const char *v127;
  nw_endpoint_t v128;
  const char *v129;
  const char *v130;
  const char *v131;
  id v132;
  id v133;
  os_log_type_t v134;
  NSObject *v135;
  const char *v136;
  const char *v137;
  nw_endpoint_t v138;
  const char *v139;
  const char *v140;
  const char *v141;
  id v142;
  char *v143;
  char *v144;
  _BOOL8 result;
  NSObject *v146;
  void *v147;
  char *v148;
  NSObject *v149;
  os_log_type_t v150;
  const char *v151;
  char *v152;
  NSObject *v153;
  os_log_type_t v154;
  _BOOL4 v155;
  void *v156;
  os_log_type_t v157;
  NSObject *v158;
  os_log_type_t v159;
  char *v160;
  os_log_type_t v161;
  _BOOL4 v162;
  void *v163;
  id v164;
  const char *v165;
  const char *v166;
  char *v167;
  NSObject *v168;
  os_log_type_t v169;
  id v170;
  const char *v171;
  const char *v172;
  char *v173;
  NSObject *v174;
  os_log_type_t v175;
  _BOOL4 v176;
  id v177;
  const char *v178;
  const char *v179;
  os_log_type_t v180;
  os_log_type_t v181;
  id v182;
  const char *v183;
  const char *v184;
  id v185;
  const char *v186;
  const char *v187;
  char *v188;
  char *v189;
  char *v190;
  char *v191;
  char *v192;
  char *v193;
  char *v194;
  char *v195;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  NSObject *logc;
  NSObject *logd;
  NSObject *loge;
  NSObject *logf;
  NSObject *logg;
  uint64_t logh;
  nw_protocol_metadata_t v205;
  nw_endpoint_t v206;
  uint64_t v207;
  nw_endpoint_t v208;
  NSObject *v209;
  id v210;
  char v211;
  char v212;
  os_log_type_t type[8];
  _BYTE buf[12];
  __int16 v215;
  uint64_t v216;
  __int16 v217;
  uint64_t v218;
  __int16 v219;
  const char *v220;
  __int16 v221;
  const char *v222;
  __int16 v223;
  const char *v224;
  __int16 v225;
  id v226;
  __int16 v227;
  char *v228;
  __int16 v229;
  char *v230;
  uint64_t v231;

  v231 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v210 = a2;
  v209 = a3;
  v6 = (id *)malloc_type_calloc(1uLL, 0x150uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_2:
    objc_storeStrong(v6 + 31, a3);
    nw_endpoint_flow_initialize_protocol(v5, (uint64_t)v6, 1);
    v7 = *((_QWORD *)v210 + 97);
    v207 = v7;
    if (v7)
    {
      v8 = *(uint64_t **)(v7 + 24);
      v9 = atomic_load(nw_protocol_get_zombie_callbacks(void)::once_flag);
      if (v9 != -1)
      {
        *(_QWORD *)buf = &v212;
        *(_QWORD *)type = buf;
        std::__call_once(nw_protocol_get_zombie_callbacks(void)::once_flag, type, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<nw_protocol_get_zombie_callbacks(void)::$_0 &&>>);
      }
      if (v8 != &nw_protocol_get_zombie_callbacks(void)::callbacks)
        goto LABEL_6;
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v18 = (id)gconnectionLogObj;
        id_string = nw_endpoint_handler_get_id_string(v5);
        v20 = nw_endpoint_handler_dry_run_string(v5);
        v21 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v21);
        v23 = nw_endpoint_handler_state_string(v5);
        v24 = nw_endpoint_handler_mode_string(v5);
        v25 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136448002;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
        v215 = 2082;
        v216 = (uint64_t)id_string;
        v217 = 2082;
        v218 = (uint64_t)v20;
        v219 = 2082;
        v220 = logging_description;
        v221 = 2082;
        v222 = v23;
        v223 = 2082;
        v224 = v24;
        v225 = 2114;
        v226 = v25;
        v227 = 2048;
        v228 = (char *)v207;
        v26 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v212 = 0;
        if ((__nwlog_fault(v26, type, &v212) & 1) != 0)
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v27 = (id)gconnectionLogObj;
            v28 = type[0];
            if (os_log_type_enabled(v27, type[0]))
            {
              v29 = nw_endpoint_handler_get_id_string(v5);
              v30 = nw_endpoint_handler_dry_run_string(v5);
              log = v27;
              v31 = nw_endpoint_handler_copy_endpoint(v5);
              v188 = v26;
              v32 = nw_endpoint_get_logging_description(v31);
              v33 = nw_endpoint_handler_state_string(v5);
              v34 = nw_endpoint_handler_mode_string(v5);
              v35 = nw_endpoint_handler_copy_current_path(v5);
              *(_DWORD *)buf = 136448002;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
              v215 = 2082;
              v216 = (uint64_t)v29;
              v217 = 2082;
              v218 = (uint64_t)v30;
              v219 = 2082;
              v220 = v32;
              v221 = 2082;
              v222 = v33;
              v223 = 2082;
              v224 = v34;
              v225 = 2114;
              v226 = v35;
              v227 = 2048;
              v228 = (char *)v207;
              v27 = log;
              _os_log_impl(&dword_182FBE000, log, v28, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p", buf, 0x52u);

              v26 = v188;
            }

          }
          else
          {
            if (v212)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v37 = (char *)backtrace_string;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v38 = (id)gconnectionLogObj;
                v39 = type[0];
                if (os_log_type_enabled(v38, type[0]))
                {
                  v40 = nw_endpoint_handler_get_id_string(v5);
                  v41 = nw_endpoint_handler_dry_run_string(v5);
                  loga = v38;
                  v189 = v26;
                  v206 = nw_endpoint_handler_copy_endpoint(v5);
                  v42 = nw_endpoint_get_logging_description(v206);
                  v43 = nw_endpoint_handler_state_string(v5);
                  v44 = nw_endpoint_handler_mode_string(v5);
                  v45 = nw_endpoint_handler_copy_current_path(v5);
                  *(_DWORD *)buf = 136448258;
                  *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                  v215 = 2082;
                  v216 = (uint64_t)v40;
                  v217 = 2082;
                  v218 = (uint64_t)v41;
                  v219 = 2082;
                  v220 = v42;
                  v221 = 2082;
                  v222 = v43;
                  v223 = 2082;
                  v224 = v44;
                  v225 = 2114;
                  v226 = v45;
                  v227 = 2048;
                  v228 = (char *)v207;
                  v229 = 2082;
                  v230 = v37;
                  v38 = loga;
                  _os_log_impl(&dword_182FBE000, loga, v39, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p, dumping backtrace:%{public}s", buf, 0x5Cu);

                  v26 = v189;
                }

                free(v37);
                if (!v26)
                  goto LABEL_97;
                goto LABEL_96;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v95 = (id)gconnectionLogObj;
              v116 = type[0];
              if (os_log_type_enabled(v95, type[0]))
              {
                v117 = nw_endpoint_handler_get_id_string(v5);
                v118 = nw_endpoint_handler_dry_run_string(v5);
                logf = v95;
                v119 = nw_endpoint_handler_copy_endpoint(v5);
                v194 = v26;
                v120 = nw_endpoint_get_logging_description(v119);
                v121 = nw_endpoint_handler_state_string(v5);
                v122 = nw_endpoint_handler_mode_string(v5);
                v123 = nw_endpoint_handler_copy_current_path(v5);
                *(_DWORD *)buf = 136448002;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                v215 = 2082;
                v216 = (uint64_t)v117;
                v217 = 2082;
                v218 = (uint64_t)v118;
                v219 = 2082;
                v220 = v120;
                v221 = 2082;
                v222 = v121;
                v223 = 2082;
                v224 = v122;
                v225 = 2114;
                v226 = v123;
                v227 = 2048;
                v228 = (char *)v207;
                v95 = logf;
                _os_log_impl(&dword_182FBE000, logf, v116, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p, no backtrace", buf, 0x52u);

                v26 = v194;
              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v95 = (id)gconnectionLogObj;
              v96 = type[0];
              if (os_log_type_enabled(v95, type[0]))
              {
                v97 = nw_endpoint_handler_get_id_string(v5);
                v98 = nw_endpoint_handler_dry_run_string(v5);
                logd = v95;
                v99 = nw_endpoint_handler_copy_endpoint(v5);
                v192 = v26;
                v100 = nw_endpoint_get_logging_description(v99);
                v101 = nw_endpoint_handler_state_string(v5);
                v102 = nw_endpoint_handler_mode_string(v5);
                v103 = nw_endpoint_handler_copy_current_path(v5);
                *(_DWORD *)buf = 136448002;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                v215 = 2082;
                v216 = (uint64_t)v97;
                v217 = 2082;
                v218 = (uint64_t)v98;
                v219 = 2082;
                v220 = v100;
                v221 = 2082;
                v222 = v101;
                v223 = 2082;
                v224 = v102;
                v225 = 2114;
                v226 = v103;
                v227 = 2048;
                v228 = (char *)v207;
                v95 = logd;
                _os_log_impl(&dword_182FBE000, logd, v96, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attempted to register context with zombified multiplexed protocol %p, backtrace limit exceeded", buf, 0x52u);

                v26 = v192;
              }
            }

          }
        }
        if (v26)
LABEL_96:
          free(v26);
      }
LABEL_97:
      nw_endpoint_flow_cleanup_protocol(v5, (uint64_t)v6, 1);
      v124 = v6[23];
      v6[23] = 0;

      free(v6);
      v6 = 0;
LABEL_123:

      return (BOOL)v6;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_is_zombie";
    v148 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v212 = 0;
    if (__nwlog_fault(v148, type, &v212))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v149 = __nwlog_obj();
        v150 = type[0];
        if (!os_log_type_enabled(v149, type[0]))
          goto LABEL_144;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_is_zombie";
        v151 = "%{public}s called with null protocol";
LABEL_142:
        v158 = v149;
        v159 = v150;
LABEL_143:
        _os_log_impl(&dword_182FBE000, v158, v159, v151, buf, 0xCu);
        goto LABEL_144;
      }
      if (!v212)
      {
        v149 = __nwlog_obj();
        v150 = type[0];
        if (!os_log_type_enabled(v149, type[0]))
          goto LABEL_144;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_is_zombie";
        v151 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_142;
      }
      v152 = (char *)__nw_create_backtrace_string();
      v153 = __nwlog_obj();
      v154 = type[0];
      v155 = os_log_type_enabled(v153, type[0]);
      if (v152)
      {
        if (v155)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_is_zombie";
          v215 = 2082;
          v216 = (uint64_t)v152;
          _os_log_impl(&dword_182FBE000, v153, v154, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v152);
        goto LABEL_144;
      }
      if (v155)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_is_zombie";
        v151 = "%{public}s called with null protocol, no backtrace";
        v158 = v153;
        v159 = v154;
        goto LABEL_143;
      }
    }
LABEL_144:
    if (v148)
      free(v148);
LABEL_6:
    v10 = nw_content_context_copy_protocol_metadata(v209, *((nw_protocol_definition_t *)v210 + 96));
    v205 = v10;
    if (v10)
    {
      objc_storeStrong(v6 + 29, v10);
      v11 = (void *)nw_protocol_metadata_copy_message_options(v205);
      v12 = v11;
      if (v11)
      {
        v13 = nw_protocol_options_copy(v11);

        nw_parameters_set_protocol_instance(v13, v14, v207);
        v15 = v6[22];
        if (v15)
        {
          v16 = (id *)v15;
          v17 = v16[19];

          nw_protocol_stack_replace_protocol(v17, *((void **)v210 + 96), v13);
        }
      }
      else
      {
        v13 = 0;
      }

    }
    v211 = 0;
    v46 = nw_hash_table_add_object(*((_QWORD *)v210 + 108), (uint64_t)v6, &v211);
    if (v46 && v211)
    {
      v47 = v46;
      if (v207)
      {
        if ((id *)v207 != v6)
        {
          v48 = *(_QWORD **)(v207 + 24);
          if (v48 && v6 && *v48)
          {
            if ((nw_protocol_add_input_handler(v207, (uint64_t)v6) & 1) != 0)
            {
              v49 = v6[4];
              if (v49)
              {
                v50 = v49[3];
                if (v50)
                {
                  v51 = *(void (**)(_QWORD *, id *))(v50 + 24);
                  if (v51)
                  {
                    v51(v49, v6);
LABEL_42:
                    if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v52 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                      {
                        v53 = nw_endpoint_handler_get_id_string(v5);
                        v54 = nw_endpoint_handler_dry_run_string(v5);
                        v55 = nw_endpoint_handler_copy_endpoint(v5);
                        v56 = nw_endpoint_get_logging_description(v55);
                        v57 = nw_endpoint_handler_state_string(v5);
                        v58 = nw_endpoint_handler_mode_string(v5);
                        v59 = nw_endpoint_handler_copy_current_path(v5);
                        v60 = *(char **)(v207 + 16);
                        *(_DWORD *)buf = 136448258;
                        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                        v215 = 2082;
                        v216 = (uint64_t)v53;
                        v217 = 2082;
                        v218 = (uint64_t)v54;
                        v219 = 2082;
                        v220 = v56;
                        v221 = 2082;
                        v222 = v57;
                        v223 = 2082;
                        v224 = v58;
                        v225 = 2114;
                        v226 = v59;
                        v227 = 2048;
                        v228 = (char *)v6;
                        v229 = 2080;
                        v230 = v60;
                        _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added per-message protocol %p to %s", buf, 0x5Cu);

                      }
                    }
                    goto LABEL_122;
                  }
                }
              }
              __nwlog_obj();
              v163 = (void *)objc_claimAutoreleasedReturnValue();
              v164 = v6[4];
              v165 = "invalid";
              if (v164)
              {
                v166 = (const char *)*((_QWORD *)v164 + 2);
                if (v166)
                  v165 = v166;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
              v215 = 2082;
              v216 = (uint64_t)v165;
              v167 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              v212 = 0;
              if (__nwlog_fault(v167, type, &v212))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v168 = objc_claimAutoreleasedReturnValue();
                  v169 = type[0];
                  if (os_log_type_enabled(v168, type[0]))
                  {
                    v170 = v6[4];
                    v171 = "invalid";
                    if (v170)
                    {
                      v172 = (const char *)*((_QWORD *)v170 + 2);
                      if (v172)
                        v171 = v172;
                    }
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                    v215 = 2082;
                    v216 = (uint64_t)v171;
                    _os_log_impl(&dword_182FBE000, v168, v169, "%{public}s protocol %{public}s has invalid connect callback", buf, 0x16u);
                  }
                }
                else
                {
                  if (v212)
                  {
                    v173 = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    v174 = objc_claimAutoreleasedReturnValue();
                    v175 = type[0];
                    v176 = os_log_type_enabled(v174, type[0]);
                    if (v173)
                    {
                      if (v176)
                      {
                        v177 = v6[4];
                        v178 = "invalid";
                        if (v177)
                        {
                          v179 = (const char *)*((_QWORD *)v177 + 2);
                          if (v179)
                            v178 = v179;
                        }
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                        v215 = 2082;
                        v216 = (uint64_t)v178;
                        v217 = 2082;
                        v218 = (uint64_t)v173;
                        _os_log_impl(&dword_182FBE000, v174, v175, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
                      }

                      free(v173);
                    }
                    else
                    {
                      if (v176)
                      {
                        v185 = v6[4];
                        v186 = "invalid";
                        if (v185)
                        {
                          v187 = (const char *)*((_QWORD *)v185 + 2);
                          if (v187)
                            v186 = v187;
                        }
                        *(_DWORD *)buf = 136446466;
                        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                        v215 = 2082;
                        v216 = (uint64_t)v186;
                        _os_log_impl(&dword_182FBE000, v174, v175, "%{public}s protocol %{public}s has invalid connect callback, no backtrace", buf, 0x16u);
                      }

                    }
                    goto LABEL_190;
                  }
                  __nwlog_obj();
                  v168 = objc_claimAutoreleasedReturnValue();
                  v181 = type[0];
                  if (os_log_type_enabled(v168, type[0]))
                  {
                    v182 = v6[4];
                    v183 = "invalid";
                    if (v182)
                    {
                      v184 = (const char *)*((_QWORD *)v182 + 2);
                      if (v184)
                        v183 = v184;
                    }
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
                    v215 = 2082;
                    v216 = (uint64_t)v183;
                    _os_log_impl(&dword_182FBE000, v168, v181, "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded", buf, 0x16u);
                  }
                }

              }
LABEL_190:
              if (v167)
                free(v167);
              goto LABEL_42;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v94 = (id)gLogObj;
            if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
              v215 = 2048;
              v216 = v207;
              _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
            }

          }
          goto LABEL_114;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v90 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        v215 = 2048;
        v216 = (uint64_t)v6;
        v91 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v212 = 0;
        if (__nwlog_fault(v91, type, &v212))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v92 = (id)gLogObj;
            v93 = type[0];
            if (os_log_type_enabled(v92, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
              v215 = 2048;
              v216 = (uint64_t)v6;
              _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
            }
LABEL_174:

            goto LABEL_112;
          }
          if (!v212)
          {
            __nwlog_obj();
            v92 = objc_claimAutoreleasedReturnValue();
            v134 = type[0];
            if (os_log_type_enabled(v92, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
              v215 = 2048;
              v216 = (uint64_t)v6;
              _os_log_impl(&dword_182FBE000, v92, v134, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_174;
          }
          v104 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v105 = objc_claimAutoreleasedReturnValue();
          v106 = type[0];
          v107 = os_log_type_enabled(v105, type[0]);
          if (v104)
          {
            if (v107)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
              v215 = 2048;
              v216 = (uint64_t)v6;
              v217 = 2082;
              v218 = (uint64_t)v104;
              _os_log_impl(&dword_182FBE000, v105, v106, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v104);
            if (!v91)
              goto LABEL_114;
            goto LABEL_113;
          }
          if (v107)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
            v215 = 2048;
            v216 = (uint64_t)v6;
            _os_log_impl(&dword_182FBE000, v105, v106, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
          }
LABEL_111:

        }
      }
      else
      {
        __nwlog_obj();
        v156 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        v91 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v212 = 0;
        if (!__nwlog_fault(v91, type, &v212))
          goto LABEL_112;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v92 = objc_claimAutoreleasedReturnValue();
          v157 = type[0];
          if (os_log_type_enabled(v92, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v92, v157, "%{public}s called with null protocol", buf, 0xCu);
          }
          goto LABEL_174;
        }
        if (!v212)
        {
          __nwlog_obj();
          v92 = objc_claimAutoreleasedReturnValue();
          v180 = type[0];
          if (os_log_type_enabled(v92, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v92, v180, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_174;
        }
        v160 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v105 = objc_claimAutoreleasedReturnValue();
        v161 = type[0];
        v162 = os_log_type_enabled(v105, type[0]);
        if (!v160)
        {
          if (v162)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v105, v161, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }
          goto LABEL_111;
        }
        if (v162)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
          v215 = 2082;
          v216 = (uint64_t)v160;
          _os_log_impl(&dword_182FBE000, v105, v161, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v160);
      }
LABEL_112:
      if (!v91)
      {
LABEL_114:
        if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v135 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
          {
            v136 = nw_endpoint_handler_get_id_string(v5);
            v137 = nw_endpoint_handler_dry_run_string(v5);
            v138 = nw_endpoint_handler_copy_endpoint(v5);
            logh = v47;
            v139 = nw_endpoint_get_logging_description(v138);
            v140 = nw_endpoint_handler_state_string(v5);
            v141 = nw_endpoint_handler_mode_string(v5);
            v142 = nw_endpoint_handler_copy_current_path(v5);
            v143 = (char *)v6[2];
            v144 = *(char **)(v207 + 16);
            *(_DWORD *)buf = 136448258;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
            v215 = 2082;
            v216 = (uint64_t)v136;
            v217 = 2082;
            v218 = (uint64_t)v137;
            v219 = 2082;
            v220 = v139;
            v221 = 2082;
            v222 = v140;
            v223 = 2082;
            v224 = v141;
            v225 = 2114;
            v226 = v142;
            v227 = 2082;
            v228 = v143;
            v229 = 2082;
            v230 = v144;
            _os_log_impl(&dword_182FBE000, v135, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s to %{public}s", buf, 0x5Cu);

            v47 = logh;
          }

        }
        nw_hash_table_remove_node(*((_QWORD *)v210 + 108), v47);
        goto LABEL_121;
      }
LABEL_113:
      free(v91);
      goto LABEL_114;
    }
    if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v61 = (id)gconnectionLogObj;
      v62 = nw_endpoint_handler_get_id_string(v5);
      v63 = nw_endpoint_handler_dry_run_string(v5);
      v64 = nw_endpoint_handler_copy_endpoint(v5);
      v65 = nw_endpoint_get_logging_description(v64);
      v66 = nw_endpoint_handler_state_string(v5);
      v67 = nw_endpoint_handler_mode_string(v5);
      v68 = nw_endpoint_handler_copy_current_path(v5);
      *(_DWORD *)buf = 136447746;
      *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
      v215 = 2082;
      v216 = (uint64_t)v62;
      v217 = 2082;
      v218 = (uint64_t)v63;
      v219 = 2082;
      v220 = v65;
      v221 = 2082;
      v222 = v66;
      v223 = 2082;
      v224 = v67;
      v225 = 2114;
      v226 = v68;
      v69 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v212 = 0;
      if ((__nwlog_fault(v69, type, &v212) & 1) != 0)
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v70 = (id)gconnectionLogObj;
          v71 = type[0];
          if (os_log_type_enabled(v70, type[0]))
          {
            v72 = nw_endpoint_handler_get_id_string(v5);
            v73 = nw_endpoint_handler_dry_run_string(v5);
            logb = v70;
            v74 = nw_endpoint_handler_copy_endpoint(v5);
            v190 = v69;
            v75 = nw_endpoint_get_logging_description(v74);
            v76 = nw_endpoint_handler_state_string(v5);
            v77 = nw_endpoint_handler_mode_string(v5);
            v78 = nw_endpoint_handler_copy_current_path(v5);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
            v215 = 2082;
            v216 = (uint64_t)v72;
            v217 = 2082;
            v218 = (uint64_t)v73;
            v219 = 2082;
            v220 = v75;
            v221 = 2082;
            v222 = v76;
            v223 = 2082;
            v224 = v77;
            v225 = 2114;
            v226 = v78;
            v70 = logb;
            _os_log_impl(&dword_182FBE000, logb, v71, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table", buf, 0x48u);

            v69 = v190;
          }
        }
        else if (v212)
        {
          v79 = __nw_create_backtrace_string();
          if (v79)
          {
            v80 = (char *)v79;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v81 = (id)gconnectionLogObj;
            v82 = type[0];
            if (os_log_type_enabled(v81, type[0]))
            {
              v83 = nw_endpoint_handler_get_id_string(v5);
              v84 = nw_endpoint_handler_dry_run_string(v5);
              logc = v81;
              v85 = v83;
              v191 = v69;
              v208 = nw_endpoint_handler_copy_endpoint(v5);
              v86 = nw_endpoint_get_logging_description(v208);
              v87 = nw_endpoint_handler_state_string(v5);
              v88 = nw_endpoint_handler_mode_string(v5);
              v89 = nw_endpoint_handler_copy_current_path(v5);
              *(_DWORD *)buf = 136448002;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
              v215 = 2082;
              v216 = (uint64_t)v85;
              v217 = 2082;
              v218 = (uint64_t)v84;
              v219 = 2082;
              v220 = v86;
              v221 = 2082;
              v222 = v87;
              v223 = 2082;
              v224 = v88;
              v225 = 2114;
              v226 = v89;
              v227 = 2082;
              v228 = v80;
              v81 = logc;
              _os_log_impl(&dword_182FBE000, logc, v82, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table, dumping backtrace:%{public}s", buf, 0x52u);

              v69 = v191;
            }

            free(v80);
            if (!v69)
              goto LABEL_105;
            goto LABEL_104;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v70 = (id)gconnectionLogObj;
          v125 = type[0];
          if (os_log_type_enabled(v70, type[0]))
          {
            v126 = nw_endpoint_handler_get_id_string(v5);
            v127 = nw_endpoint_handler_dry_run_string(v5);
            logg = v70;
            v128 = nw_endpoint_handler_copy_endpoint(v5);
            v195 = v69;
            v129 = nw_endpoint_get_logging_description(v128);
            v130 = nw_endpoint_handler_state_string(v5);
            v131 = nw_endpoint_handler_mode_string(v5);
            v132 = nw_endpoint_handler_copy_current_path(v5);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
            v215 = 2082;
            v216 = (uint64_t)v126;
            v217 = 2082;
            v218 = (uint64_t)v127;
            v219 = 2082;
            v220 = v129;
            v221 = 2082;
            v222 = v130;
            v223 = 2082;
            v224 = v131;
            v225 = 2114;
            v226 = v132;
            v70 = logg;
            _os_log_impl(&dword_182FBE000, logg, v125, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table, no backtrace", buf, 0x48u);

            v69 = v195;
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v70 = (id)gconnectionLogObj;
          v108 = type[0];
          if (os_log_type_enabled(v70, type[0]))
          {
            v109 = nw_endpoint_handler_get_id_string(v5);
            v110 = nw_endpoint_handler_dry_run_string(v5);
            loge = v70;
            v111 = nw_endpoint_handler_copy_endpoint(v5);
            v193 = v69;
            v112 = nw_endpoint_get_logging_description(v111);
            v113 = nw_endpoint_handler_state_string(v5);
            v114 = nw_endpoint_handler_mode_string(v5);
            v115 = nw_endpoint_handler_copy_current_path(v5);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context_internal";
            v215 = 2082;
            v216 = (uint64_t)v109;
            v217 = 2082;
            v218 = (uint64_t)v110;
            v219 = 2082;
            v220 = v112;
            v221 = 2082;
            v222 = v113;
            v223 = 2082;
            v224 = v114;
            v225 = 2114;
            v226 = v115;
            v70 = loge;
            _os_log_impl(&dword_182FBE000, loge, v108, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add new flow protocol to hash table, backtrace limit exceeded", buf, 0x48u);

            v69 = v193;
          }
        }

      }
      if (v69)
LABEL_104:
        free(v69);
    }
LABEL_105:
    nw_endpoint_flow_cleanup_protocol(v5, (uint64_t)v6, 1);
    v133 = v6[23];
    v6[23] = 0;

    free(v6);
LABEL_121:
    v6 = 0;
LABEL_122:

    goto LABEL_123;
  }
  __nwlog_obj();
  v146 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v146, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "strict_calloc";
  v215 = 2048;
  v216 = 1;
  v217 = 2048;
  v218 = 336;
  v147 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v147);
  if (!result)
  {
    free(v147);
    goto LABEL_2;
  }
  __break(1u);
  return result;
}

void sub_183193738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

nw_protocol_metadata_t nw_content_context_copy_protocol_metadata(nw_content_context_t context, nw_protocol_definition_t protocol)
{
  nw_content_context_t v3;
  NSObject *v4;
  NSObject *v5;
  unsigned __int8 *isa;
  NSObject *v7;
  void *v8;
  NSObject *v9;
  NSObject *v10;
  nw_protocol_metadata_t v11;
  void *v12;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _QWORD v22[4];
  NSObject *v23;
  _BYTE *v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  id v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = context;
  v4 = protocol;
  if (v3)
  {
    v5 = 0;
    if (v3 != (nw_content_context_t)&__block_literal_global_5_41741
      && v3 != (nw_content_context_t)&__block_literal_global_4
      && v3 != (nw_content_context_t)&__block_literal_global_3_41726
      && v3 != (nw_content_context_t)&__block_literal_global_41718)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&v3[14]);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v28 = __Block_byref_object_copy__41932;
      v29 = __Block_byref_object_dispose__41933;
      v30 = 0;
      isa = (unsigned __int8 *)v3[11].isa;
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 3221225472;
      v22[2] = __nw_content_context_copy_protocol_metadata_block_invoke;
      v22[3] = &unk_1E14AB5F0;
      v7 = v4;
      v23 = v7;
      v24 = buf;
      nw_array_apply(isa, (uint64_t)v22);
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
      v8 = *(void **)(*(_QWORD *)&buf[8] + 40);
      if (!v8)
      {
        v9 = nw_content_context_copy_connection(v3);
        v10 = v9;
        if (v9)
        {
          v11 = nw_connection_copy_protocol_metadata(v9, v7);
          v12 = *(void **)(*(_QWORD *)&buf[8] + 40);
          *(_QWORD *)(*(_QWORD *)&buf[8] + 40) = v11;

        }
        v8 = *(void **)(*(_QWORD *)&buf[8] + 40);
      }
      v5 = v8;

      _Block_object_dispose(buf, 8);
    }
    goto LABEL_11;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_content_context_copy_protocol_metadata";
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v15, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_copy_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_content_context_copy_protocol_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_copy_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_content_context_copy_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_28:
  if (v15)
    free(v15);
  v5 = 0;
LABEL_11:

  return v5;
}

void sub_183193C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26)
{
  void *v26;
  void *v27;
  void *v28;

  _Block_object_dispose(&a21, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_content_context_copy_connection(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = 0;
    if (v1 != (os_unfair_lock_s *)&__block_literal_global_5_41741
      && v1 != (os_unfair_lock_s *)&__block_literal_global_4
      && v1 != (os_unfair_lock_s *)&__block_literal_global_3_41726
      && v1 != (os_unfair_lock_s *)&__block_literal_global_41718)
    {
      os_unfair_lock_lock(v1 + 28);
      if ((v2[29]._os_unfair_lock_opaque & 0x100000) != 0
        && (v4 = *(_QWORD *)&v2[26]._os_unfair_lock_opaque) != 0
        && *(_QWORD *)(v4 + 24) != *(_QWORD *)(v4 + 16))
      {
        nw_array_get_object_at_index(v4, 0);
        v3 = objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v3 = 0;
      }
      os_unfair_lock_unlock(v2 + 28);
    }
    goto LABEL_12;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_content_context_copy_connection";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_copy_connection";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_content_context_copy_connection";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_copy_connection";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_copy_connection";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_29:
  if (v7)
    free(v7);
  v3 = 0;
LABEL_12:

  return v3;
}

uint64_t nw_protocol_default_connect(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  uint64_t (*connect)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_default_connect";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12))
      goto LABEL_20;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_connect";
      v9 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_default_connect";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v11)
      {
LABEL_20:
        if (v6)
          free(v6);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_connect";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_connect";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_20;
  }
  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      connect = (uint64_t (*)(void))callbacks->connect;
      if (connect)
        return connect();
    }
  }
  return 0;
}

void nw_protocol_stack_replace_protocol(void *a1, void *a2, void *a3)
{
  id *v5;
  id v6;
  id v7;
  id *v8;
  id v9;
  id v10;
  uint64_t v11;
  unsigned __int8 *v12;
  void *v13;
  id v14;
  unsigned __int8 *v15;
  void *v16;
  id v17;
  id *v18;
  id v19;
  id v20;
  id *v21;
  id v22;
  id v23;
  id *v24;
  id v25;
  void *v26;
  void *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  void *v31;
  os_log_type_t v32;
  void *v33;
  os_log_type_t v34;
  char *backtrace_string;
  os_log_type_t v36;
  _BOOL4 v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  os_log_type_t v44;
  os_log_type_t v45;
  id v46;
  _QWORD v47[5];
  id v48;
  id *v49;
  id *v50;
  _BYTE *v51;
  _QWORD v52[5];
  id v53;
  id *v54;
  id *v55;
  _BYTE *v56;
  char v57;
  os_log_type_t v58;
  _BYTE buf[24];
  uint64_t (*v60)(uint64_t, uint64_t);
  void (*v61)(uint64_t);
  id v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (!v5)
  {
    v26 = v7;
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
    v28 = (char *)_os_log_send_and_compose_impl();

    v58 = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v28, &v58, &v57))
      goto LABEL_78;
    if (v58 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v30 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v36 = v58;
      v37 = os_log_type_enabled(v29, v58);
      if (backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v29, v36, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_78:
        if (!v28)
          goto LABEL_28;
LABEL_79:
        free(v28);
        goto LABEL_28;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v36, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v43 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v43, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_77:

    goto LABEL_78;
  }
  if (!v6)
  {
    v26 = v7;
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
    v28 = (char *)_os_log_send_and_compose_impl();

    v58 = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v28, &v58, &v57))
      goto LABEL_78;
    if (v58 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v32 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null old_protocol", buf, 0xCu);
      }
      goto LABEL_77;
    }
    if (!v57)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v44 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v44, "%{public}s called with null old_protocol, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_77;
    }
    v38 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = objc_claimAutoreleasedReturnValue();
    v39 = v58;
    v40 = os_log_type_enabled(v29, v58);
    if (!v38)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v39, "%{public}s called with null old_protocol, no backtrace", buf, 0xCu);
      }
      goto LABEL_77;
    }
    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v38;
      _os_log_impl(&dword_182FBE000, v29, v39, "%{public}s called with null old_protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_58;
  }
  if (!v7)
  {
    v26 = 0;
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
    v28 = (char *)_os_log_send_and_compose_impl();

    v58 = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (!__nwlog_fault(v28, &v58, &v57))
      goto LABEL_78;
    if (v58 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v34 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null new_options", buf, 0xCu);
      }
      goto LABEL_77;
    }
    if (!v57)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v45 = v58;
      if (os_log_type_enabled(v29, v58))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v45, "%{public}s called with null new_options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_77;
    }
    v38 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = objc_claimAutoreleasedReturnValue();
    v41 = v58;
    v42 = os_log_type_enabled(v29, v58);
    if (!v38)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
        _os_log_impl(&dword_182FBE000, v29, v41, "%{public}s called with null new_options, no backtrace", buf, 0xCu);
      }
      goto LABEL_77;
    }
    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_stack_replace_protocol";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v38;
      _os_log_impl(&dword_182FBE000, v29, v41, "%{public}s called with null new_options, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_58:

    free(v38);
    if (!v28)
      goto LABEL_28;
    goto LABEL_79;
  }
  v46 = v7;
  v8 = (id *)v7;
  v9 = v8[1];

  v10 = v5[1];
  v11 = MEMORY[0x1E0C809B0];
  if (v10)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v60 = __Block_byref_object_copy__19149;
    v61 = __Block_byref_object_dispose__19150;
    v62 = v10;
    v12 = (unsigned __int8 *)v5[1];
    v52[0] = v11;
    v52[1] = 3221225472;
    v52[2] = __nw_protocol_stack_replace_protocol_block_invoke;
    v52[3] = &unk_1E149CF38;
    v52[4] = v9;
    v53 = v6;
    v56 = buf;
    v54 = v5;
    v55 = v8;
    nw_array_apply(v12, (uint64_t)v52);
    v13 = *(void **)(*(_QWORD *)&buf[8] + 40);
    if (v13)
      objc_storeStrong(v5 + 1, v13);

    _Block_object_dispose(buf, 8);
  }
  v14 = v5[2];
  if (v14)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v60 = __Block_byref_object_copy__19149;
    v61 = __Block_byref_object_dispose__19150;
    v62 = v14;
    v15 = (unsigned __int8 *)v5[2];
    v47[0] = v11;
    v47[1] = 3221225472;
    v47[2] = __nw_protocol_stack_replace_protocol_block_invoke_3;
    v47[3] = &unk_1E149CF38;
    v47[4] = v9;
    v48 = v6;
    v51 = buf;
    v49 = v5;
    v50 = v8;
    nw_array_apply(v15, (uint64_t)v47);
    v16 = *(void **)(*(_QWORD *)&buf[8] + 40);
    if (v16)
      objc_storeStrong(v5 + 2, v16);

    _Block_object_dispose(buf, 8);
  }
  v17 = v5[3];
  if (v17)
  {
    v18 = (id *)v17;
    v19 = v18[1];

    if (nw_protocol_definition_is_equal_unsafe((uint64_t)v9, (uint64_t)v19)
      || nw_protocol_definition_is_equal_unsafe((uint64_t)v6, (uint64_t)v19))
    {
      objc_storeStrong(v5 + 3, a3);
    }

  }
  v20 = v5[4];
  if (v20)
  {
    v21 = (id *)v20;
    v22 = v21[1];

    if (nw_protocol_definition_is_equal_unsafe((uint64_t)v9, (uint64_t)v22)
      || nw_protocol_definition_is_equal_unsafe((uint64_t)v6, (uint64_t)v22))
    {
      objc_storeStrong(v5 + 4, a3);
    }

  }
  v23 = v5[6];
  if (v23)
  {
    v24 = (id *)v23;
    v25 = v24[1];

    if (nw_protocol_definition_is_equal_unsafe((uint64_t)v9, (uint64_t)v25)
      || nw_protocol_definition_is_equal_unsafe((uint64_t)v6, (uint64_t)v25))
    {
      objc_storeStrong(v5 + 6, a3);
    }

  }
  v26 = v46;
LABEL_28:

}

void sub_183194B98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void nw_parameters_set_protocol_instance(void *a1, uint64_t a2, uint64_t a3)
{
  id v4;
  void *v5;
  _QWORD *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = v4;
  if (v4)
  {
    v6 = v4;
    v6[2] = a3;

    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_parameters_set_protocol_instance";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_protocol_instance";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol_parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_parameters_set_protocol_instance";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_protocol_instance";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null protocol_parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_protocol_instance";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null protocol_parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

}

void sub_18319609C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_copy_properties_block_invoke(uint64_t a1, void *a2, void *a3)
{
  nw_endpoint_add_alternative(*(void **)(a1 + 32), a2, a3);
  return 1;
}

void nw_endpoint_add_alternative(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  NSObject *v7;
  NSObject *v8;
  id v9;
  _BOOL4 is_equal_unsafe;
  NSObject *v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  os_log_type_t v29;
  os_log_type_t v30;
  _QWORD v31[4];
  id v32;
  id v33;
  NSObject *v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_endpoint_add_alternative";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_add_alternative";
          v39 = 2082;
          v40 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_66:
        if (!v13)
          goto LABEL_16;
LABEL_67:
        free(v13);
        goto LABEL_16;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v28, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_65:

    goto LABEL_66;
  }
  if (!v6)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_endpoint_add_alternative";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null alternative_endpoint", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (!v35)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v29, "%{public}s called with null alternative_endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_65;
    }
    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v24 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s called with null alternative_endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_endpoint_add_alternative";
      v39 = 2082;
      v40 = v23;
      _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s called with null alternative_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (v5 == v6)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_endpoint_add_alternative";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null (endpoint != alternative_endpoint)", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (!v35)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s called with null (endpoint != alternative_endpoint), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_65;
    }
    v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v26 = type;
    v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_182FBE000, v14, v26, "%{public}s called with null (endpoint != alternative_endpoint), no backtrace", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_endpoint_add_alternative";
      v39 = 2082;
      v40 = v23;
      _os_log_impl(&dword_182FBE000, v14, v26, "%{public}s called with null (endpoint != alternative_endpoint), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_46:

    free(v23);
    if (!v13)
      goto LABEL_16;
    goto LABEL_67;
  }
  if (v6 != &__block_literal_global_6232 || v7)
  {
    if (v7)
    {
      if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
        dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
      v9 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
      is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v8, (uint64_t)v9);

      if (is_equal_unsafe)
      {
        if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
        v11 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;

        v8 = v11;
      }
    }
    v31[0] = MEMORY[0x1E0C809B0];
    v31[1] = 3221225472;
    v31[2] = __nw_endpoint_add_alternative_block_invoke;
    v31[3] = &unk_1E14AAAA0;
    v32 = v5;
    v33 = v6;
    v34 = v8;
    v8 = v8;
    nw_endpoint_locked(v32, v31);

  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v38 = "nw_endpoint_add_alternative";
      _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s Cannot set an unknown alternative endpoint without a protocol", buf, 0xCu);
    }
  }
LABEL_16:

}

void sub_183196A84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void nw_endpoint_resolver_start_next_child(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v4;
  NWConcrete_nw_endpoint_handler *v5;
  int state;
  uint64_t v7;
  NWConcrete_nw_endpoint_handler *v8;
  char v9;
  uint64_t v10;
  NSObject *v11;
  NWConcrete_nw_endpoint_handler *v12;
  NWConcrete_nw_endpoint_handler *v13;
  char v14;
  const char *v15;
  nw_endpoint_t v16;
  const char *v17;
  NWConcrete_nw_endpoint_handler *v18;
  NWConcrete_nw_endpoint_handler *v19;
  uint64_t v20;
  const char *v21;
  NSObject *v22;
  const char *v23;
  NWConcrete_nw_endpoint_handler *v24;
  char v25;
  NSObject *v26;
  NWConcrete_nw_endpoint_handler *v27;
  NWConcrete_nw_endpoint_handler *v28;
  char v29;
  const char *v30;
  nw_endpoint_t v31;
  const char *v32;
  char *v33;
  NWConcrete_nw_endpoint_handler *v34;
  NWConcrete_nw_endpoint_handler *v35;
  uint64_t v36;
  const char *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NWConcrete_nw_endpoint_handler *v42;
  char v43;
  NSObject *v44;
  NWConcrete_nw_endpoint_handler *v45;
  NWConcrete_nw_endpoint_handler *v46;
  char v47;
  const char *v48;
  const char *v49;
  NWConcrete_nw_endpoint_handler *v50;
  NWConcrete_nw_endpoint_handler *v51;
  uint64_t v52;
  const char *v53;
  NWConcrete_nw_endpoint_handler *v54;
  char v55;
  NSObject *v56;
  NSObject *v57;
  NSObject *v58;
  char v59;
  const char *v60;
  nw_endpoint_t v61;
  const char *v62;
  NSObject *v63;
  NSObject *v64;
  uint64_t v65;
  const char *v66;
  void **v67;
  void **v68;
  const char *v69;
  void **v70;
  void **v71;
  int v72;
  const char *v73;
  void **v74;
  id v75;
  uint64_t v76;
  uint64_t v77;
  void **v78;
  void **v79;
  const char *v80;
  void **v81;
  id v82;
  void **v83;
  void **v84;
  const char *v85;
  const char *v86;
  void **v87;
  id v88;
  void **v89;
  id v90;
  id v91;
  _BOOL8 child_parameters;
  NWConcrete_nw_endpoint_handler *v93;
  NWConcrete_nw_endpoint_handler *v94;
  id v95;
  void *v96;
  NWConcrete_nw_endpoint_handler *v97;
  NWConcrete_nw_path *v98;
  NSObject *p_super;
  const sockaddr *address;
  int minimize_logging;
  char logging_disabled;
  NSObject *v103;
  const char *v104;
  const char *v105;
  nw_endpoint_t v106;
  const char *v107;
  const char *v108;
  const char *v109;
  id v110;
  NWConcrete_nw_endpoint_handler *v111;
  int v112;
  NWConcrete_nw_endpoint_handler *v113;
  _BOOL4 v114;
  const char *v115;
  const char *v116;
  nw_endpoint_t v117;
  const char *v118;
  const char *v119;
  const char *v120;
  id v121;
  NWConcrete_nw_endpoint_handler *v122;
  int v123;
  NWConcrete_nw_endpoint_mode_handler *v124;
  int v125;
  char v126;
  const char *v127;
  const char *v128;
  nw_endpoint_t v129;
  const char *v130;
  const char *v131;
  const char *v132;
  id v133;
  int v134;
  char v135;
  NSObject *v136;
  const char *v137;
  const char *v138;
  nw_endpoint_t v139;
  const char *v140;
  const char *v141;
  const char *v142;
  id v143;
  id v144;
  uint64_t v145;
  dispatch_time_t v146;
  uint64_t v147;
  void *v148;
  char *v149;
  NSObject *v150;
  os_log_type_t v151;
  NWConcrete_nw_endpoint_handler *v152;
  void *v153;
  char *v154;
  NSObject *v155;
  os_log_type_t v156;
  char *backtrace_string;
  os_log_type_t v158;
  _BOOL4 v159;
  char *v160;
  os_log_type_t v161;
  _BOOL4 v162;
  os_log_type_t v163;
  const char *id_string;
  const char *v165;
  nw_endpoint_t v166;
  const char *logging_description;
  const char *v168;
  const char *v169;
  id v170;
  os_log_type_t v171;
  const char *v172;
  const char *v173;
  nw_endpoint_t v174;
  const char *v175;
  const char *v176;
  const char *v177;
  id v178;
  const char *v179;
  const char *v180;
  nw_endpoint_t v181;
  const char *v182;
  const char *v183;
  const char *v184;
  id v185;
  void *v186;
  char *v187;
  NSObject *v188;
  os_log_type_t v189;
  void *v190;
  os_log_type_t v191;
  void *v192;
  os_log_type_t v193;
  NSObject *v194;
  const char *v195;
  const char *v196;
  nw_endpoint_t v197;
  const char *v198;
  const char *v199;
  const char *v200;
  id v201;
  char *v202;
  os_log_type_t v203;
  _BOOL4 v204;
  char *v205;
  os_log_type_t v206;
  _BOOL4 v207;
  os_log_type_t v208;
  _BOOL4 v209;
  const char *v210;
  const char *v211;
  nw_endpoint_t v212;
  const char *v213;
  const char *v214;
  const char *v215;
  id v216;
  os_log_type_t v217;
  os_log_type_t v218;
  os_log_type_t v219;
  const char *v220;
  const char *v221;
  nw_endpoint_t v222;
  const char *v223;
  const char *v224;
  const char *v225;
  id v226;
  const char *v227;
  nw_endpoint_t v228;
  const char *v229;
  const char *v230;
  const char *v231;
  id v232;
  const char *v233;
  nw_endpoint_t log;
  const char *loga;
  NSObject *logc;
  unint64_t logb;
  const char *logd;
  NSObject *endpoint;
  nw_endpoint_t endpointa;
  char *id_str;
  void *v242;
  NWConcrete_nw_endpoint_mode_handler *v243;
  NWConcrete_nw_endpoint_handler *v244;
  _QWORD v245[4];
  NSObject *v246;
  char v247;
  os_log_type_t type[4];
  _BYTE buf[22];
  __int16 v250;
  const char *v251;
  __int16 v252;
  const char *v253;
  __int16 v254;
  const char *v255;
  __int16 v256;
  const char *v257;
  __int16 v258;
  id v259;
  __int16 v260;
  unint64_t v261;
  uint64_t v262;

  v262 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v244 = v1;
    v2 = v1;
    mode = v2->mode;

    if ((_DWORD)mode != 1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = (id)gLogObj;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5)
          v23 = "unknown-mode";
        else
          v23 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v23;
        v250 = 2082;
        v251 = "resolver";
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }

      goto LABEL_188;
    }
    v4 = nw_endpoint_handler_copy_resolver(v2);
    v5 = v2;
    state = v5->state;

    v243 = v4;
    if ((state & 0xFFFFFFFE) == 4)
    {
      if (nw_endpoint_handler_get_minimize_logging(v5))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
          goto LABEL_69;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v11 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v5);
          v165 = nw_endpoint_handler_dry_run_string(v5);
          v166 = nw_endpoint_handler_copy_endpoint(v5);
          logging_description = nw_endpoint_get_logging_description(v166);
          v168 = nw_endpoint_handler_state_string(v5);
          v169 = nw_endpoint_handler_mode_string(v5);
          v170 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = id_string;
          v250 = 2082;
          v251 = v165;
          v252 = 2082;
          v253 = logging_description;
          v254 = 2082;
          v255 = v168;
          v256 = 2082;
          v257 = v169;
          v258 = 2114;
          v259 = v170;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] not starting next child", buf, 0x48u);

        }
      }
      else
      {
        v8 = v5;
        v9 = *((_BYTE *)v8 + 268);

        if ((v9 & 0x20) != 0)
        {
LABEL_69:
          v76 = *((_QWORD *)v243 + 7);
          if (v76)
          {
            nw_queue_cancel_source(v76, v10);
            *((_QWORD *)v243 + 7) = 0;
          }
          v77 = *((_QWORD *)v243 + 8);
          if (v77)
          {
            nw_queue_cancel_source(v77, v10);
            *((_QWORD *)v243 + 8) = 0;
          }
          goto LABEL_187;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v11 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          v12 = v8;

          v13 = v12;
          v14 = *((_BYTE *)v8 + 268);

          if ((v14 & 1) != 0)
            v15 = "dry-run ";
          else
            v15 = "";
          v16 = nw_endpoint_handler_copy_endpoint(v13);
          v17 = nw_endpoint_get_logging_description(v16);
          id_str = v12->id_str;
          v18 = v13;
          v19 = v18;
          v20 = v5->state;
          if (v20 > 5)
            v21 = "unknown-state";
          else
            v21 = off_1E149FC48[v20];

          v67 = v19;
          v68 = v67;
          v69 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              v69 = "resolver";
              break;
            case 2:
              v69 = nw_endpoint_flow_mode_string(v67[31]);
              break;
            case 3:
              v69 = "proxy";
              break;
            case 4:
              v69 = "fallback";
              break;
            case 5:
              v69 = "transform";
              break;
            default:
              v69 = "unknown-mode";
              break;
          }

          v74 = v68;
          os_unfair_lock_lock((os_unfair_lock_t)v74 + 28);
          v75 = v74[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v74 + 28);

          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = id_str;
          v250 = 2082;
          v251 = v15;
          v252 = 2082;
          v253 = v17;
          v254 = 2082;
          v255 = v21;
          v256 = 2082;
          v257 = v69;
          v258 = 2114;
          v259 = v75;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] not starting next child", buf, 0x48u);

        }
      }

      goto LABEL_69;
    }
    if (*((_QWORD *)v4 + 4))
    {
      if (nw_endpoint_handler_get_minimize_logging(v5))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
          goto LABEL_187;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v26 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          v172 = nw_endpoint_handler_get_id_string(v5);
          v173 = nw_endpoint_handler_dry_run_string(v5);
          v174 = nw_endpoint_handler_copy_endpoint(v5);
          v175 = nw_endpoint_get_logging_description(v174);
          v176 = nw_endpoint_handler_state_string(v5);
          v177 = nw_endpoint_handler_mode_string(v5);
          v178 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v172;
          v250 = 2082;
          v251 = v173;
          v252 = 2082;
          v253 = v175;
          v254 = 2082;
          v255 = v176;
          v256 = 2082;
          v257 = v177;
          v258 = 2114;
          v259 = v178;
          _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already connected, not starting next child", buf, 0x48u);

        }
      }
      else
      {
        v24 = v5;
        v25 = *((_BYTE *)v24 + 268);

        if ((v25 & 0x20) != 0)
        {
LABEL_187:

LABEL_188:
          v152 = v244;
          goto LABEL_189;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v26 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          v27 = v24;

          v28 = v27;
          v29 = *((_BYTE *)v24 + 268);

          if ((v29 & 1) != 0)
            v30 = "dry-run ";
          else
            v30 = "";
          v31 = nw_endpoint_handler_copy_endpoint(v28);
          v32 = nw_endpoint_get_logging_description(v31);
          v33 = v27->id_str;
          v34 = v28;
          v35 = v34;
          v36 = v5->state;
          if (v36 > 5)
            v37 = "unknown-state";
          else
            v37 = off_1E149FC48[v36];

          v70 = v35;
          v71 = v70;
          v72 = v2->mode;
          v73 = "path";
          switch(v72)
          {
            case 0:
              break;
            case 1:
              v73 = "resolver";
              break;
            case 2:
              v73 = nw_endpoint_flow_mode_string(v70[31]);
              break;
            case 3:
              v73 = "proxy";
              break;
            case 4:
              v73 = "fallback";
              break;
            case 5:
              v73 = "transform";
              break;
            default:
              v73 = "unknown-mode";
              break;
          }

          v81 = v71;
          os_unfair_lock_lock((os_unfair_lock_t)v81 + 28);
          v82 = v81[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v81 + 28);

          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v33;
          v250 = 2082;
          v251 = v30;
          v252 = 2082;
          v253 = v32;
          v254 = 2082;
          v255 = v37;
          v256 = 2082;
          v257 = v73;
          v258 = 2114;
          v259 = v82;
          _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already connected, not starting next child", buf, 0x48u);

        }
      }

      goto LABEL_187;
    }
    v38 = *((unsigned int *)v4 + 5);
    v39 = *((_QWORD *)v4 + 5);
    if (!v39 || v38 >= (uint64_t)(*(_QWORD *)(v39 + 24) - *(_QWORD *)(v39 + 16)) >> 3)
    {
      v54 = v5;
      v55 = *((_BYTE *)v54 + 268);

      if ((v55 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v56 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
        {
          v57 = v54;

          v58 = v57;
          v59 = *((_BYTE *)v54 + 268);

          if ((v59 & 1) != 0)
            v60 = "dry-run ";
          else
            v60 = "";
          v61 = nw_endpoint_handler_copy_endpoint(v58);
          v62 = nw_endpoint_get_logging_description(v61);
          v63 = v58;
          v64 = v63;
          v65 = v5->state;
          endpointa = v57 + 21;
          if (v65 > 5)
            v66 = "unknown-state";
          else
            v66 = off_1E149FC48[v65];
          loga = v66;

          v78 = v64;
          v79 = v78;
          v80 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              v80 = "resolver";
              break;
            case 2:
              v80 = nw_endpoint_flow_mode_string(v78[31]);
              break;
            case 3:
              v80 = "proxy";
              break;
            case 4:
              v80 = "fallback";
              break;
            case 5:
              v80 = "transform";
              break;
            default:
              v80 = "unknown-mode";
              break;
          }

          v87 = v79;
          os_unfair_lock_lock((os_unfair_lock_t)v87 + 28);
          v88 = v87[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v87 + 28);

          *(_DWORD *)buf = 136448002;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = endpointa;
          v250 = 2082;
          v251 = v60;
          v252 = 2082;
          v253 = v62;
          v254 = 2082;
          v255 = loga;
          v256 = 2082;
          v257 = v80;
          v258 = 2114;
          v259 = v88;
          v260 = 1024;
          LODWORD(v261) = v38;
          _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no child at index %u", buf, 0x4Eu);

        }
      }
      *((_BYTE *)v243 + 24) |= 2u;
      nw_endpoint_resolver_check_desperate_ivan(v54);
      goto LABEL_187;
    }
    *((_BYTE *)v4 + 24) &= ~2u;
    *((_DWORD *)v4 + 5) = v38 + 1;
    v40 = *((_QWORD *)v4 + 7);
    if (v40)
    {
      nw_queue_cancel_source(v40, v7);
      *((_QWORD *)v4 + 7) = 0;
    }
    v41 = *((_QWORD *)v4 + 8);
    if (v41)
    {
      nw_queue_cancel_source(v41, v7);
      *((_QWORD *)v4 + 8) = 0;
    }
    nw_array_get_object_at_index(*((_QWORD *)v4 + 5), v38);
    v242 = (void *)objc_claimAutoreleasedReturnValue();
    endpoint = nw_endpoint_handler_copy_endpoint(v242);
    if (nw_endpoint_handler_get_minimize_logging(v5))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
      {
LABEL_101:
        if (nw_endpoint_handler_get_state(v242) != 5)
          goto LABEL_109;
        child_parameters = nw_endpoint_resolver_create_child_parameters(v5);
        if (nw_endpoint_get_is_approved_app_domain(endpoint))
          nw_parameters_set_is_approved_app_domain((void *)child_parameters);
        v93 = v242;
        v94 = v5;
        v95 = (id)child_parameters;
        v96 = v95;
        if (v93)
        {
          if (v95)
          {
            if (!v93->parameters)
            {
              objc_storeStrong((id *)&v93->parameters, (id)child_parameters);
              nw_endpoint_handler_inherit_from_parent(v93, v94, 0);
              objc_storeWeak((id *)&v93->callback_context, v94);
              v93->state = 0;
LABEL_108:

LABEL_109:
              if (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address)
              {
                v97 = v5;
                os_unfair_lock_lock(&v97->lock);
                v98 = v97->current_path;
                os_unfair_lock_unlock(&v97->lock);

                *(_DWORD *)type = 0;
                *(_QWORD *)buf = 0;
                *(_QWORD *)&buf[8] = 0;
                p_super = &v98->super;
                if (nw_path_get_vpn_config_uuid(v98, (unsigned __int8 (*)[16])buf, (int *)type, 1, 1))
                {
                  type[0] = OS_LOG_TYPE_DEFAULT;
                  address = nw_endpoint_get_address(endpoint);
                  if (nw_path_voluntary_agent_matches_address(v98, (uint64_t)address))
                  {
                    if (type[0])
                    {
                      if (!nw_endpoint_handler_trigger_agents(v97, 1))
                      {
LABEL_185:

                        goto LABEL_186;
                      }
                      minimize_logging = nw_endpoint_handler_get_minimize_logging(v97);
                      logging_disabled = nw_endpoint_handler_get_logging_disabled(v97);
                      if (minimize_logging)
                      {
                        if ((logging_disabled & 1) != 0)
                          goto LABEL_121;
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v103 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
                        {
                          v227 = nw_endpoint_handler_get_id_string(v97);
                          logd = nw_endpoint_handler_dry_run_string(v97);
                          v228 = nw_endpoint_handler_copy_endpoint(v97);
                          v229 = nw_endpoint_get_logging_description(v228);
                          v230 = nw_endpoint_handler_state_string(v97);
                          v231 = nw_endpoint_handler_mode_string(v97);
                          v232 = nw_endpoint_handler_copy_current_path(v97);
                          *(_DWORD *)buf = 136447746;
                          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v227;
                          v250 = 2082;
                          v251 = logd;
                          v252 = 2082;
                          v253 = v229;
                          v254 = 2082;
                          v255 = v230;
                          v256 = 2082;
                          v257 = v231;
                          v258 = 2114;
                          v259 = v232;
                          _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child flow requires agent trigger before attempting to connect", buf, 0x48u);

                        }
                      }
                      else
                      {
                        if ((logging_disabled & 1) != 0)
                        {
LABEL_121:
                          nw_endpoint_handler_reset_mode(v97, 0);
                          goto LABEL_185;
                        }
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v103 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v103, OS_LOG_TYPE_INFO))
                        {
                          logc = v103;
                          v104 = nw_endpoint_handler_get_id_string(v97);
                          v105 = nw_endpoint_handler_dry_run_string(v97);
                          v106 = nw_endpoint_handler_copy_endpoint(v97);
                          v107 = nw_endpoint_get_logging_description(v106);
                          v108 = nw_endpoint_handler_state_string(v97);
                          v109 = nw_endpoint_handler_mode_string(v97);
                          v110 = nw_endpoint_handler_copy_current_path(v97);
                          *(_DWORD *)buf = 136447746;
                          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v104;
                          v250 = 2082;
                          v251 = v105;
                          v252 = 2082;
                          v253 = v107;
                          v254 = 2082;
                          v255 = v108;
                          v256 = 2082;
                          v257 = v109;
                          v258 = 2114;
                          v259 = v110;
                          _os_log_impl(&dword_182FBE000, logc, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child flow requires agent trigger before attempting to connect", buf, 0x48u);

                          v103 = logc;
                        }
                      }

                      p_super = &v98->super;
                      goto LABEL_121;
                    }
                    nw_endpoint_resolver_setup_trigger_agent_timer(v97, 1);
                  }
                }

              }
              nw_endpoint_handler_start(v242);
              v111 = v5;
              v112 = v5->state;

              if ((v112 & 0xFFFFFFFE) == 4)
              {
                if (nw_endpoint_handler_get_minimize_logging(v111))
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v111) & 1) != 0)
                    goto LABEL_186;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v194 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
                  {
                    v195 = nw_endpoint_handler_get_id_string(v111);
                    v196 = nw_endpoint_handler_dry_run_string(v111);
                    v197 = nw_endpoint_handler_copy_endpoint(v111);
                    v198 = nw_endpoint_get_logging_description(v197);
                    v199 = nw_endpoint_handler_state_string(v111);
                    v200 = nw_endpoint_handler_mode_string(v111);
                    v201 = nw_endpoint_handler_copy_current_path(v111);
                    *(_DWORD *)buf = 136447746;
                    *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v195;
                    v250 = 2082;
                    v251 = v196;
                    v252 = 2082;
                    v253 = v198;
                    v254 = 2082;
                    v255 = v199;
                    v256 = 2082;
                    v257 = v200;
                    v258 = 2114;
                    v259 = v201;
                    _os_log_impl(&dword_182FBE000, v194, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, handler cancelled or failed", buf, 0x48u);

                  }
                  p_super = v194;
                  goto LABEL_185;
                }
                v113 = v111;
                v114 = (*((_BYTE *)v113 + 268) & 0x20) == 0;

                if (v114)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  p_super = (id)gconnectionLogObj;
                  if (os_log_type_enabled(p_super, OS_LOG_TYPE_INFO))
                  {
                    v115 = nw_endpoint_handler_get_id_string(v113);
                    v116 = nw_endpoint_handler_dry_run_string(v113);
                    v117 = nw_endpoint_handler_copy_endpoint(v113);
                    v118 = nw_endpoint_get_logging_description(v117);
                    v119 = nw_endpoint_handler_state_string(v113);
                    v120 = nw_endpoint_handler_mode_string(v113);
                    v121 = nw_endpoint_handler_copy_current_path(v113);
                    *(_DWORD *)buf = 136447746;
                    *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v115;
                    v250 = 2082;
                    v251 = v116;
                    v252 = 2082;
                    v253 = v118;
                    v254 = 2082;
                    v255 = v119;
                    v256 = 2082;
                    v257 = v120;
                    v258 = 2114;
                    v259 = v121;
                    _os_log_impl(&dword_182FBE000, p_super, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, handler cancelled or failed", buf, 0x48u);

                  }
                  goto LABEL_185;
                }
LABEL_186:

                goto LABEL_187;
              }
              v122 = v111;
              v123 = v2->mode;

              if (v123 != 1)
              {
                v125 = nw_endpoint_handler_get_minimize_logging(v122);
                v126 = nw_endpoint_handler_get_logging_disabled(v122);
                if (v125)
                {
                  if ((v126 & 1) != 0)
                    goto LABEL_186;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  p_super = (id)gconnectionLogObj;
                  if (os_log_type_enabled(p_super, OS_LOG_TYPE_DEBUG))
                  {
                    v210 = nw_endpoint_handler_get_id_string(v122);
                    v211 = nw_endpoint_handler_dry_run_string(v122);
                    v212 = nw_endpoint_handler_copy_endpoint(v122);
                    v213 = nw_endpoint_get_logging_description(v212);
                    v214 = nw_endpoint_handler_state_string(v122);
                    v215 = nw_endpoint_handler_mode_string(v122);
                    v216 = nw_endpoint_handler_copy_current_path(v122);
                    *(_DWORD *)buf = 136447746;
                    *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v210;
                    v250 = 2082;
                    v251 = v211;
                    v252 = 2082;
                    v253 = v213;
                    v254 = 2082;
                    v255 = v214;
                    v256 = 2082;
                    v257 = v215;
                    v258 = 2114;
                    v259 = v216;
                    _os_log_impl(&dword_182FBE000, p_super, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, no longer resolver mode", buf, 0x48u);

                  }
                  goto LABEL_185;
                }
                if ((v126 & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  p_super = (id)gconnectionLogObj;
                  if (os_log_type_enabled(p_super, OS_LOG_TYPE_INFO))
                  {
                    v127 = nw_endpoint_handler_get_id_string(v122);
                    v128 = nw_endpoint_handler_dry_run_string(v122);
                    v129 = nw_endpoint_handler_copy_endpoint(v122);
                    v130 = nw_endpoint_get_logging_description(v129);
                    v131 = nw_endpoint_handler_state_string(v122);
                    v132 = nw_endpoint_handler_mode_string(v122);
                    v133 = nw_endpoint_handler_copy_current_path(v122);
                    *(_DWORD *)buf = 136447746;
                    *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v127;
                    v250 = 2082;
                    v251 = v128;
                    v252 = 2082;
                    v253 = v130;
                    v254 = 2082;
                    v255 = v131;
                    v256 = 2082;
                    v257 = v132;
                    v258 = 2114;
                    v259 = v133;
                    _os_log_impl(&dword_182FBE000, p_super, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, no longer resolver mode", buf, 0x48u);

                  }
                  goto LABEL_185;
                }
                goto LABEL_186;
              }
              if (*((_QWORD *)v243 + 4))
                goto LABEL_186;
              v124 = v243;
              if ((*((_BYTE *)v243 + 24) & 1) != 0)
                logb = 2000000000;
              else
                logb = nw_endpoint_handler_get_child_timeout_nanos(v242);
              v134 = nw_endpoint_handler_get_minimize_logging(v122);
              v135 = nw_endpoint_handler_get_logging_disabled(v122);
              if (v134)
              {
                if ((v135 & 1) != 0)
                {
LABEL_149:
                  v144 = nw_endpoint_handler_copy_context(v122);
                  v245[0] = MEMORY[0x1E0C809B0];
                  v245[1] = 3221225472;
                  v245[2] = ___ZL37nw_endpoint_resolver_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke;
                  v245[3] = &unk_1E14ACFD0;
                  v246 = v122;
                  *((_QWORD *)v124 + 7) = nw_queue_context_create_source(v144, 2, 3, 0, v245, 0);

                  v145 = *((_QWORD *)v124 + 7);
                  if (v145)
                  {
                    v146 = dispatch_time(0x8000000000000000, logb);
                    nw_queue_set_timer_values(v145, v146, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
                    nw_queue_activate_source(*((_QWORD *)v243 + 7), v147);
LABEL_184:
                    p_super = v246;
                    goto LABEL_185;
                  }
                  __nwlog_obj();
                  v148 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                  v149 = (char *)_os_log_send_and_compose_impl();

                  type[0] = OS_LOG_TYPE_ERROR;
                  v247 = 0;
                  if (__nwlog_fault(v149, type, &v247))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      __nwlog_obj();
                      v150 = objc_claimAutoreleasedReturnValue();
                      v151 = type[0];
                      if (os_log_type_enabled(v150, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                        _os_log_impl(&dword_182FBE000, v150, v151, "%{public}s nw_queue_context_create_source(timer) failed", buf, 0xCu);
                      }
                    }
                    else if (v247)
                    {
                      backtrace_string = (char *)__nw_create_backtrace_string();
                      __nwlog_obj();
                      v150 = objc_claimAutoreleasedReturnValue();
                      v158 = type[0];
                      v159 = os_log_type_enabled(v150, type[0]);
                      if (backtrace_string)
                      {
                        if (v159)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = backtrace_string;
                          _os_log_impl(&dword_182FBE000, v150, v158, "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s", buf, 0x16u);
                        }

                        free(backtrace_string);
                        goto LABEL_182;
                      }
                      if (v159)
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                        _os_log_impl(&dword_182FBE000, v150, v158, "%{public}s nw_queue_context_create_source(timer) failed, no backtrace", buf, 0xCu);
                      }
                    }
                    else
                    {
                      __nwlog_obj();
                      v150 = objc_claimAutoreleasedReturnValue();
                      v163 = type[0];
                      if (os_log_type_enabled(v150, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                        _os_log_impl(&dword_182FBE000, v150, v163, "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded", buf, 0xCu);
                      }
                    }

                  }
LABEL_182:
                  if (v149)
                    free(v149);
                  goto LABEL_184;
                }
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v136 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
                {
                  v220 = nw_endpoint_handler_get_id_string(v122);
                  v221 = nw_endpoint_handler_dry_run_string(v122);
                  v222 = nw_endpoint_handler_copy_endpoint(v122);
                  v223 = nw_endpoint_get_logging_description(v222);
                  v224 = nw_endpoint_handler_state_string(v122);
                  v225 = nw_endpoint_handler_mode_string(v122);
                  v226 = nw_endpoint_handler_copy_current_path(v122);
                  *(_DWORD *)buf = 136448002;
                  *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v220;
                  v250 = 2082;
                  v251 = v221;
                  v252 = 2082;
                  v253 = v223;
                  v254 = 2082;
                  v255 = v224;
                  v256 = 2082;
                  v257 = v225;
                  v258 = 2114;
                  v259 = v226;
                  v260 = 2048;
                  v261 = logb / 0xF4240;
                  _os_log_impl(&dword_182FBE000, v136, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums", buf, 0x52u);

                }
              }
              else
              {
                if ((v135 & 1) != 0)
                  goto LABEL_149;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v136 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v136, OS_LOG_TYPE_INFO))
                {
                  v137 = nw_endpoint_handler_get_id_string(v122);
                  v138 = nw_endpoint_handler_dry_run_string(v122);
                  v139 = nw_endpoint_handler_copy_endpoint(v122);
                  v140 = nw_endpoint_get_logging_description(v139);
                  v141 = nw_endpoint_handler_state_string(v122);
                  v142 = nw_endpoint_handler_mode_string(v122);
                  v143 = nw_endpoint_handler_copy_current_path(v122);
                  *(_DWORD *)buf = 136448002;
                  *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v137;
                  v250 = 2082;
                  v251 = v138;
                  v252 = 2082;
                  v253 = v140;
                  v254 = 2082;
                  v255 = v141;
                  v256 = 2082;
                  v257 = v142;
                  v258 = 2114;
                  v259 = v143;
                  v260 = 2048;
                  v261 = logb / 0xF4240;
                  _os_log_impl(&dword_182FBE000, v136, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums", buf, 0x52u);

                }
              }

              v124 = v243;
              goto LABEL_149;
            }
            __nwlog_obj();
            v192 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
            v187 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v247 = 0;
            if (!__nwlog_fault(v187, type, &v247))
              goto LABEL_274;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v188 = objc_claimAutoreleasedReturnValue();
              v193 = type[0];
              if (os_log_type_enabled(v188, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
                _os_log_impl(&dword_182FBE000, v188, v193, "%{public}s called with null (handler->parameters == nil)", buf, 0xCu);
              }
              goto LABEL_273;
            }
            if (!v247)
            {
              __nwlog_obj();
              v188 = objc_claimAutoreleasedReturnValue();
              v219 = type[0];
              if (os_log_type_enabled(v188, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
                _os_log_impl(&dword_182FBE000, v188, v219, "%{public}s called with null (handler->parameters == nil), backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_273;
            }
            v205 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v188 = objc_claimAutoreleasedReturnValue();
            v208 = type[0];
            v209 = os_log_type_enabled(v188, type[0]);
            if (!v205)
            {
              if (v209)
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
                _os_log_impl(&dword_182FBE000, v188, v208, "%{public}s called with null (handler->parameters == nil), no backtrace", buf, 0xCu);
              }
              goto LABEL_273;
            }
            if (v209)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v205;
              _os_log_impl(&dword_182FBE000, v188, v208, "%{public}s called with null (handler->parameters == nil), dumping backtrace:%{public}s", buf, 0x16u);
            }
          }
          else
          {
            __nwlog_obj();
            v190 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
            v187 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v247 = 0;
            if (!__nwlog_fault(v187, type, &v247))
              goto LABEL_274;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v188 = objc_claimAutoreleasedReturnValue();
              v191 = type[0];
              if (os_log_type_enabled(v188, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
                _os_log_impl(&dword_182FBE000, v188, v191, "%{public}s called with null parameters", buf, 0xCu);
              }
              goto LABEL_273;
            }
            if (!v247)
            {
              __nwlog_obj();
              v188 = objc_claimAutoreleasedReturnValue();
              v218 = type[0];
              if (os_log_type_enabled(v188, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
                _os_log_impl(&dword_182FBE000, v188, v218, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_273;
            }
            v205 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v188 = objc_claimAutoreleasedReturnValue();
            v206 = type[0];
            v207 = os_log_type_enabled(v188, type[0]);
            if (!v205)
            {
              if (v207)
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
                _os_log_impl(&dword_182FBE000, v188, v206, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
              }
              goto LABEL_273;
            }
            if (v207)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v205;
              _os_log_impl(&dword_182FBE000, v188, v206, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
            }
          }

          free(v205);
          if (!v187)
            goto LABEL_108;
          goto LABEL_275;
        }
        __nwlog_obj();
        v186 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
        v187 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v247 = 0;
        if (!__nwlog_fault(v187, type, &v247))
          goto LABEL_274;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v188 = objc_claimAutoreleasedReturnValue();
          v189 = type[0];
          if (os_log_type_enabled(v188, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
            _os_log_impl(&dword_182FBE000, v188, v189, "%{public}s called with null handler", buf, 0xCu);
          }
        }
        else if (v247)
        {
          v202 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v188 = objc_claimAutoreleasedReturnValue();
          v203 = type[0];
          v204 = os_log_type_enabled(v188, type[0]);
          if (v202)
          {
            if (v204)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v202;
              _os_log_impl(&dword_182FBE000, v188, v203, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v202);
LABEL_274:
            if (!v187)
              goto LABEL_108;
LABEL_275:
            free(v187);
            goto LABEL_108;
          }
          if (v204)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
            _os_log_impl(&dword_182FBE000, v188, v203, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v188 = objc_claimAutoreleasedReturnValue();
          v217 = type[0];
          if (os_log_type_enabled(v188, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_reinitialize";
            _os_log_impl(&dword_182FBE000, v188, v217, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
          }
        }
LABEL_273:

        goto LABEL_274;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v44 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        v179 = nw_endpoint_handler_get_id_string(v5);
        v180 = nw_endpoint_handler_dry_run_string(v5);
        v181 = nw_endpoint_handler_copy_endpoint(v5);
        v182 = nw_endpoint_get_logging_description(v181);
        v183 = nw_endpoint_handler_state_string(v5);
        v184 = nw_endpoint_handler_mode_string(v5);
        v185 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136448002;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v179;
        v250 = 2082;
        v251 = v180;
        v252 = 2082;
        v253 = v182;
        v254 = 2082;
        v255 = v183;
        v256 = 2082;
        v257 = v184;
        v258 = 2114;
        v259 = v185;
        v260 = 2082;
        v261 = (unint64_t)nw_endpoint_get_logging_description(endpoint);
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting child endpoint %{public}s", buf, 0x52u);

      }
    }
    else
    {
      v42 = v5;
      v43 = *((_BYTE *)v42 + 268);

      if ((v43 & 0x20) != 0)
        goto LABEL_101;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v44 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
      {
        v45 = v42;

        v46 = v45;
        v47 = *((_BYTE *)v42 + 268);

        if ((v47 & 1) != 0)
          v48 = "dry-run ";
        else
          v48 = "";
        log = nw_endpoint_handler_copy_endpoint(v46);
        v49 = nw_endpoint_get_logging_description(log);
        v50 = v46;
        v51 = v50;
        v52 = v5->state;
        if (v52 > 5)
          v53 = "unknown-state";
        else
          v53 = off_1E149FC48[v52];
        v233 = v53;

        v83 = v51;
        v84 = v83;
        v85 = v49;
        v86 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            v86 = "resolver";
            break;
          case 2:
            v86 = nw_endpoint_flow_mode_string(v83[31]);
            break;
          case 3:
            v86 = "proxy";
            break;
          case 4:
            v86 = "fallback";
            break;
          case 5:
            v86 = "transform";
            break;
          default:
            v86 = "unknown-mode";
            break;
        }

        v89 = v84;
        os_unfair_lock_lock((os_unfair_lock_t)v89 + 28);
        v90 = v89[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v89 + 28);

        v91 = v90;
        *(_DWORD *)buf = 136448002;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v45->id_str;
        v250 = 2082;
        v251 = v48;
        v252 = 2082;
        v253 = v85;
        v254 = 2082;
        v255 = v233;
        v256 = 2082;
        v257 = v86;
        v258 = 2114;
        v259 = v91;
        v260 = 2082;
        v261 = (unint64_t)nw_endpoint_get_logging_description(endpoint);
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting child endpoint %{public}s", buf, 0x52u);

      }
    }

    goto LABEL_101;
  }
  v152 = 0;
  __nwlog_obj();
  v153 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
  v154 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v247 = 0;
  if (__nwlog_fault(v154, type, &v247))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v155 = objc_claimAutoreleasedReturnValue();
      v156 = type[0];
      if (os_log_type_enabled(v155, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
        _os_log_impl(&dword_182FBE000, v155, v156, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v247)
    {
      v160 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v155 = objc_claimAutoreleasedReturnValue();
      v161 = type[0];
      v162 = os_log_type_enabled(v155, type[0]);
      if (v160)
      {
        if (v162)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v160;
          _os_log_impl(&dword_182FBE000, v155, v161, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v160);
        goto LABEL_202;
      }
      if (v162)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
        _os_log_impl(&dword_182FBE000, v155, v161, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v155 = objc_claimAutoreleasedReturnValue();
      v171 = type[0];
      if (os_log_type_enabled(v155, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_start_next_child";
        _os_log_impl(&dword_182FBE000, v155, v171, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_202:
  if (v154)
    free(v154);
LABEL_189:

}

void sub_183198F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_state(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[30];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_get_state";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_state";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_get_state";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_state";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_state";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_endpoint_resolver_check_desperate_ivan(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_mode_handler *v2;
  NWConcrete_nw_endpoint_mode_handler *v3;
  id v4;
  nw_endpoint_t v5;
  int minimize_logging;
  char logging_disabled;
  uint64_t v8;
  NSObject *v9;
  const char *id_string;
  const char *v11;
  nw_endpoint_t v12;
  const char *v13;
  const char *v14;
  const char *v15;
  id v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  dispatch_time_t v20;
  uint64_t v21;
  void *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  NSObject *v26;
  char *backtrace_string;
  NSObject *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  NSObject *v32;
  nw_endpoint_t v33;
  const char *logging_description;
  const char *v35;
  const char *v36;
  id v37;
  const char *v38;
  NSObject *log;
  const char *loga;
  NSObject *v41;
  NSObject *v42;
  id v43;
  char v44;
  os_log_type_t type;
  _QWORD v46[4];
  NWConcrete_nw_endpoint_handler *v47;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  void *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  id v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = nw_endpoint_handler_copy_resolver(v1);
  v3 = v2;
  if ((*((_BYTE *)v2 + 24) & 4) == 0)
  {
    if (*((_QWORD *)v2 + 4))
    {
      *((_BYTE *)v2 + 24) |= 4u;
      goto LABEL_8;
    }
    v4 = nw_endpoint_handler_copy_parameters(v1);
    if (nw_parameters_get_required_address_family(v4)
      || nw_parameters_get_desperate_ivan(v4))
    {
      *((_BYTE *)v3 + 24) |= 4u;
LABEL_7:

      goto LABEL_8;
    }
    v43 = nw_endpoint_handler_copy_current_path(v1);
    if ((nw_path_is_eligible_for_CrazyIvan46(v43) & 1) == 0)
    {
LABEL_42:

      goto LABEL_7;
    }
    v5 = nw_endpoint_handler_copy_endpoint(v1);
    if (nw_endpoint_get_type(v5) != nw_endpoint_type_host)
    {
LABEL_41:

      goto LABEL_42;
    }
    *((_BYTE *)v3 + 24) |= 0xCu;
    minimize_logging = nw_endpoint_handler_get_minimize_logging(v1);
    logging_disabled = nw_endpoint_handler_get_logging_disabled(v1);
    if (minimize_logging)
    {
      if ((logging_disabled & 1) != 0)
      {
LABEL_18:
        v17 = *((_QWORD *)v3 + 9);
        if (v17)
        {
          nw_queue_cancel_source(v17, v8);
          *((_QWORD *)v3 + 9) = 0;
        }
        v18 = nw_endpoint_handler_copy_context(v1);
        v46[0] = MEMORY[0x1E0C809B0];
        v46[1] = 3221225472;
        v46[2] = ___ZL41nw_endpoint_resolver_check_desperate_ivanP30NWConcrete_nw_endpoint_handler_block_invoke;
        v46[3] = &unk_1E14ACFD0;
        v47 = v1;
        *((_QWORD *)v3 + 9) = nw_queue_context_create_source(v18, 2, 3, 0, v46, 0);

        v19 = *((_QWORD *)v3 + 9);
        if (v19)
        {
          v20 = dispatch_time(0x8000000000000000, 2000000000);
          nw_queue_set_timer_values(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          nw_queue_activate_source(*((_QWORD *)v3 + 9), v21);
LABEL_40:

          goto LABEL_41;
        }
        __nwlog_obj();
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v49 = "nw_endpoint_resolver_check_desperate_ivan";
        v23 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v44 = 0;
        if (__nwlog_fault(v23, &type, &v44))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v49 = "nw_endpoint_resolver_check_desperate_ivan";
              _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s nw_queue_context_create_source(timer) failed", buf, 0xCu);
            }
          }
          else
          {
            if (v44)
            {
              v26 = v5;
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v28 = objc_claimAutoreleasedReturnValue();
              v29 = type;
              v30 = os_log_type_enabled(v28, type);
              if (backtrace_string)
              {
                if (v30)
                {
                  *(_DWORD *)buf = 136446466;
                  v49 = "nw_endpoint_resolver_check_desperate_ivan";
                  v50 = 2082;
                  v51 = backtrace_string;
                  _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s", buf, 0x16u);
                }

                v5 = v26;
                free(backtrace_string);
              }
              else
              {
                if (v30)
                {
                  *(_DWORD *)buf = 136446210;
                  v49 = "nw_endpoint_resolver_check_desperate_ivan";
                  _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s nw_queue_context_create_source(timer) failed, no backtrace", buf, 0xCu);
                }

                v5 = v26;
              }
              goto LABEL_38;
            }
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            v31 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v49 = "nw_endpoint_resolver_check_desperate_ivan";
              _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
LABEL_38:
        if (v23)
          free(v23);
        goto LABEL_40;
      }
      v42 = v5;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v32 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        loga = nw_endpoint_handler_get_id_string(v1);
        v38 = nw_endpoint_handler_dry_run_string(v1);
        v33 = nw_endpoint_handler_copy_endpoint(v1);
        logging_description = nw_endpoint_get_logging_description(v33);
        v35 = nw_endpoint_handler_state_string(v1);
        v36 = nw_endpoint_handler_mode_string(v1);
        v37 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        v49 = "nw_endpoint_resolver_check_desperate_ivan";
        v50 = 2082;
        v51 = (void *)loga;
        v52 = 2082;
        v53 = v38;
        v54 = 2082;
        v55 = logging_description;
        v56 = 2082;
        v57 = v35;
        v58 = 2082;
        v59 = v36;
        v60 = 2114;
        v61 = v37;
        v9 = v32;
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connectivity seems slow, starting DesperateIvan timer", buf, 0x48u);

        v5 = v42;
      }
      else
      {
        v9 = v32;
      }
    }
    else
    {
      if ((logging_disabled & 1) != 0)
        goto LABEL_18;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v9 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        v41 = v5;
        id_string = nw_endpoint_handler_get_id_string(v1);
        v11 = nw_endpoint_handler_dry_run_string(v1);
        log = v9;
        v12 = nw_endpoint_handler_copy_endpoint(v1);
        v13 = nw_endpoint_get_logging_description(v12);
        v14 = nw_endpoint_handler_state_string(v1);
        v15 = nw_endpoint_handler_mode_string(v1);
        v16 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        v49 = "nw_endpoint_resolver_check_desperate_ivan";
        v50 = 2082;
        v51 = (void *)id_string;
        v52 = 2082;
        v53 = v11;
        v54 = 2082;
        v55 = v13;
        v56 = 2082;
        v57 = v14;
        v58 = 2082;
        v59 = v15;
        v60 = 2114;
        v61 = v16;
        v9 = log;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connectivity seems slow, starting DesperateIvan timer", buf, 0x48u);

        v5 = v41;
      }
    }

    goto LABEL_18;
  }
LABEL_8:

}

void sub_183199A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

uint64_t nw_path_is_eligible_for_CrazyIvan46(void *a1)
{
  id v1;
  void *v2;
  id v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  void *v19;
  os_unfair_lock_s *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_path_is_eligible_for_CrazyIvan46";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_is_eligible_for_CrazyIvan46";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_path_is_eligible_for_CrazyIvan46";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_is_eligible_for_CrazyIvan46";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_is_eligible_for_CrazyIvan46";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_23:
    if (v8)
      free(v8);
    goto LABEL_25;
  }
  v3 = v1;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke;
  v19 = &unk_1E14ACFD0;
  v4 = (os_unfair_lock_s *)v3;
  v20 = v4;
  os_unfair_lock_lock(v4 + 2);
  ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v4 + 2);

  if ((BYTE1(v4[118]._os_unfair_lock_opaque) & 0xC0) != 0x80)
  {
LABEL_25:
    v6 = 0;
    goto LABEL_26;
  }
  v5 = *(_QWORD *)&v4[46]._os_unfair_lock_opaque;
  if (!v5 || *(_QWORD *)(v5 + 24) == *(_QWORD *)(v5 + 16))
    v6 = BYTE2(v4[118]._os_unfair_lock_opaque) & 1;
  else
    v6 = 1;
LABEL_26:

  return v6;
}

void sub_183199DDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_activity *nw_activity_create_from_xpc_object(void *a1)
{
  id v1;
  void *v2;
  NWConcrete_nw_activity *v3;
  id v4;
  NWConcrete_nw_activity *m_obj;
  NWConcrete_nw_activity *v6;
  NSString *v7;
  char v8;
  char v9;
  char v10;
  NSObject *v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t receiver;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  _BOOL4 v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  os_log_type_t v33;
  char v34;
  os_log_type_t type;
  objc_super v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (object_getClass(v1) == (Class)MEMORY[0x1E0C812F8])
    {
      v3 = [NWConcrete_nw_activity alloc];
      v4 = v2;
      if (!v3)
      {
LABEL_26:

        goto LABEL_27;
      }
      v36.receiver = v3;
      v36.super_class = (Class)NWConcrete_nw_activity;
      v3 = (NWConcrete_nw_activity *)objc_msgSendSuper2(&v36, sel_init);
      if (v3)
      {
        *(_OWORD *)v3->token = *(_OWORD *)xpc_dictionary_get_uuid(v4, "token");
        v3->investigation_identifier = xpc_dictionary_get_uint64(v4, "investigation_identifier");
        v3->start_time = xpc_dictionary_get_uint64(v4, "start_time");
        v3->end_time = xpc_dictionary_get_uint64(v4, "end_time");
        v3->fragments_quenched = xpc_dictionary_get_uint64(v4, "fragments_quenched");
        m_obj = v3->parent.m_obj;
        if ((*((_BYTE *)&v3->parent + 8) & 1) != 0 && m_obj)
        {
          v3->parent.m_obj = 0;

          m_obj = v3->parent.m_obj;
        }
        v3->parent.m_obj = 0;

        v6 = v3->parent.m_obj;
        v3->parent.m_obj = 0;

        *((_BYTE *)&v3->parent + 8) |= 1u;
        os_unfair_lock_lock(&v3->description_cache.mutex.m_mutex);
        v7 = v3->description_cache.description.m_obj;
        if ((*((_BYTE *)&v3->description_cache.description + 8) & 1) != 0 && v7)
        {
          v3->description_cache.description.m_obj = 0;

          v7 = v3->description_cache.description.m_obj;
        }
        v3->description_cache.description.m_obj = 0;

        os_unfair_lock_unlock(&v3->description_cache.mutex.m_mutex);
        v3->label = xpc_dictionary_get_uint64(v4, "label");
        v3->domain = xpc_dictionary_get_uint64(v4, "domain");
        v3->client_metric_count = 0;
        v3->underlying_error_domain = xpc_dictionary_get_int64(v4, "underlying_error_domain");
        v3->underlying_error_code = xpc_dictionary_get_int64(v4, "underlying_error_code");
        v3->reporting_strategy = xpc_dictionary_get_uint64(v4, "reporting_strategy");
        v3->completion_reason = xpc_dictionary_get_uint64(v4, "completion_reason");
        *((_BYTE *)v3 + 132) = *((_BYTE *)v3 + 132) & 0xFE | xpc_dictionary_get_BOOL(v4, "is_retry");
        if (xpc_dictionary_get_BOOL(v4, "is_lightweight"))
          v8 = 2;
        else
          v8 = 0;
        *((_BYTE *)v3 + 132) = *((_BYTE *)v3 + 132) & 0xFD | v8;
        if (xpc_dictionary_get_BOOL(v4, "activated"))
          v9 = 4;
        else
          v9 = 0;
        *((_BYTE *)v3 + 132) = *((_BYTE *)v3 + 132) & 0xFB | v9;
        if (xpc_dictionary_get_BOOL(v4, "completed"))
          v10 = 8;
        else
          v10 = 0;
        *((_BYTE *)v3 + 132) = *((_BYTE *)v3 + 132) & 0xF7 | v10;
        if (nw_activity_should_log(v3))
        {
          if (__nwlog_activity_log::onceToken != -1)
            dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
          v11 = (id)gactivityLogObj;
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            v38 = (const char *)v3;
            _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEFAULT, "Create activity from XPC object %{public}@", buf, 0xCu);
          }

        }
        goto LABEL_26;
      }
      __nwlog_obj();
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v38 = "-[NWConcrete_nw_activity initWithXPCObject:]";
      v20 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if ((__nwlog_fault(v20, &type, &v34) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v21 = objc_claimAutoreleasedReturnValue();
          v22 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v38 = "-[NWConcrete_nw_activity initWithXPCObject:]";
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v21 = objc_claimAutoreleasedReturnValue();
          v29 = type;
          v30 = os_log_type_enabled(v21, type);
          if (backtrace_string)
          {
            if (v30)
            {
              *(_DWORD *)buf = 136446466;
              v38 = "-[NWConcrete_nw_activity initWithXPCObject:]";
              v39 = 2082;
              v40 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_79;
          }
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            v38 = "-[NWConcrete_nw_activity initWithXPCObject:]";
            _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v21 = objc_claimAutoreleasedReturnValue();
          v33 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v38 = "-[NWConcrete_nw_activity initWithXPCObject:]";
            _os_log_impl(&dword_182FBE000, v21, v33, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_79:
      if (v20)
        free(v20);
      v3 = 0;
      goto LABEL_26;
    }
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_activity_create_from_xpc_object";
    v14 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v36.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v14, &v36, &type))
    {
      if (LOBYTE(v36.receiver) == 17)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        receiver = (os_log_type_t)v36.receiver;
        if (os_log_type_enabled(v15, (os_log_type_t)v36.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_activity_create_from_xpc_object";
          _os_log_impl(&dword_182FBE000, v15, receiver, "%{public}s called with null (xpc_get_type(object) == (&_xpc_type_dictionary))", buf, 0xCu);
        }
LABEL_72:

        goto LABEL_73;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v32 = (os_log_type_t)v36.receiver;
        if (os_log_type_enabled(v15, (os_log_type_t)v36.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_activity_create_from_xpc_object";
          _os_log_impl(&dword_182FBE000, v15, v32, "%{public}s called with null (xpc_get_type(object) == (&_xpc_type_dictionary)), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v26 = (os_log_type_t)v36.receiver;
      v27 = os_log_type_enabled(v15, (os_log_type_t)v36.receiver);
      if (!v23)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_activity_create_from_xpc_object";
          _os_log_impl(&dword_182FBE000, v15, v26, "%{public}s called with null (xpc_get_type(object) == (&_xpc_type_dictionary)), no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        v38 = "nw_activity_create_from_xpc_object";
        v39 = 2082;
        v40 = v23;
        _os_log_impl(&dword_182FBE000, v15, v26, "%{public}s called with null (xpc_get_type(object) == (&_xpc_type_dictionary)), dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_52;
    }
  }
  else
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_activity_create_from_xpc_object";
    v14 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v36.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v14, &v36, &type))
    {
      if (LOBYTE(v36.receiver) == 17)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = (os_log_type_t)v36.receiver;
        if (os_log_type_enabled(v15, (os_log_type_t)v36.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_activity_create_from_xpc_object";
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null object", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v31 = (os_log_type_t)v36.receiver;
        if (os_log_type_enabled(v15, (os_log_type_t)v36.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_activity_create_from_xpc_object";
          _os_log_impl(&dword_182FBE000, v15, v31, "%{public}s called with null object, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v24 = (os_log_type_t)v36.receiver;
      v25 = os_log_type_enabled(v15, (os_log_type_t)v36.receiver);
      if (!v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_activity_create_from_xpc_object";
          _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null object, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        v38 = "nw_activity_create_from_xpc_object";
        v39 = 2082;
        v40 = v23;
        _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null object, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_52:

      free(v23);
    }
  }
LABEL_73:
  if (v14)
    free(v14);
  v3 = 0;
LABEL_27:

  return v3;
}

void sub_18319A7B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *nw_activity_copy_xpc_object(void *a1)
{
  unsigned int *v1;
  xpc_object_t v2;
  void *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *v13;
  os_log_type_t v14;
  _BOOL4 v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type[8];
  char v23;
  os_log_type_t v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = xpc_dictionary_create(0, 0, 0);
    v3 = v2;
    *(_QWORD *)type = v2;
    v23 = -1;
    if (v2)
    {
      xpc_dictionary_set_uuid(v2, "token", (const unsigned __int8 *)v1 + 8);
      xpc_dictionary_set_uint64(v3, "investigation_identifier", *((_QWORD *)v1 + 3));
      xpc_dictionary_set_uint64(v3, "start_time", *((_QWORD *)v1 + 4));
      xpc_dictionary_set_uint64(v3, "end_time", *((_QWORD *)v1 + 5));
      xpc_dictionary_set_uint64(v3, "fragments_quenched", v1[12]);
      xpc_dictionary_set_uint64(v3, "label", v1[26]);
      xpc_dictionary_set_uint64(v3, "domain", v1[27]);
      xpc_dictionary_set_int64(v3, "underlying_error_domain", (int)v1[29]);
      xpc_dictionary_set_int64(v3, "underlying_error_code", (int)v1[30]);
      xpc_dictionary_set_uint64(v3, "reporting_strategy", v1[31]);
      xpc_dictionary_set_uint64(v3, "completion_reason", v1[32]);
      xpc_dictionary_set_BOOL(v3, "is_retry", v1[33] & 1);
      xpc_dictionary_set_BOOL(v3, "is_lightweight", (v1[33] & 2) != 0);
      xpc_dictionary_set_BOOL(v3, "activated", (v1[33] & 4) != 0);
      xpc_dictionary_set_BOOL(v3, "completed", (v1[33] & 8) != 0);
      goto LABEL_4;
    }
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_activity_copy_xpc_object";
    v10 = (char *)_os_log_send_and_compose_impl();

    v24 = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v10, &v24, &v21))
      goto LABEL_40;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = v24;
      if (os_log_type_enabled(v11, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s failed to allocate dictionary", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v17 = v24;
      v18 = os_log_type_enabled(v11, v24);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_activity_copy_xpc_object";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v17, "%{public}s failed to allocate dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_40;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_182FBE000, v11, v17, "%{public}s failed to allocate dictionary, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v20 = v24;
      if (os_log_type_enabled(v11, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s failed to allocate dictionary, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_40:
    if (v10)
      free(v10);
    goto LABEL_4;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_activity_copy_xpc_object";
  v6 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v24 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v6, type, &v24))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v24)
    {
      v13 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v14 = type[0];
      v15 = os_log_type_enabled(v7, type[0]);
      if (v13)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_activity_copy_xpc_object";
          v27 = 2082;
          v28 = v13;
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v13);
        goto LABEL_34;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_activity_copy_xpc_object";
        _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_34:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_4:

  return v3;
}

void sub_18319ADD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  va_list va;

  va_start(va, a6);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_sec_protocol_metadata(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_sec_protocol_metadata_block_invoke;
    v13[3] = &unk_1E14A9F20;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_sec_protocol_metadata";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_sec_protocol_metadata";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18319B114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_sec_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 16), *(id *)(a1 + 32));
  return 1;
}

void nw_protocol_instance_async_if_needed(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  os_log_type_t v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_instance_async_if_needed";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_protocol_instance_async_if_needed";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v7)
          goto LABEL_5;
LABEL_56:
        free(v7);
        goto LABEL_5;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v22, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  v5 = (void *)v3[15];
  if (!v5)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_instance_async_if_needed";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance->context", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v25)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v23, "%{public}s called with null instance->context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    v19 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null instance->context, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v28 = "nw_protocol_instance_async_if_needed";
      v29 = 2082;
      v30 = v17;
      _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null instance->context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v4)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_instance_async_if_needed";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v7, &type, &v25))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null block", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v25)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v24, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    v21 = os_log_type_enabled(v8, type);
    if (!v17)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_instance_async_if_needed";
        _os_log_impl(&dword_182FBE000, v8, v20, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v28 = "nw_protocol_instance_async_if_needed";
      v29 = 2082;
      v30 = v17;
      _os_log_impl(&dword_182FBE000, v8, v20, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v17);
    if (!v7)
      goto LABEL_5;
    goto LABEL_56;
  }
  nw_queue_context_async_if_needed(v5, v4);
LABEL_5:

}

void sub_18319B81C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_context_globals_allocator(void *a1, void *a2, void *a3)
{
  NWConcrete_nw_protocol_definition *v5;
  NWConcrete_nw_protocol_definition *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_context_globals_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_definition_set_context_globals_allocator";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8)
          goto LABEL_5;
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_context_globals_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_context_globals_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_context_globals_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_context_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_context_globals_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8)
      goto LABEL_5;
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_common_state(v5);
  v6->common_state->var1 = a2;
  v6->common_state->var2 = a3;
LABEL_5:

}

void sub_18319BEF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_globals_allocator(void *a1, void *a2, void *a3)
{
  NWConcrete_nw_protocol_definition *v5;
  NWConcrete_nw_protocol_definition *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_globals_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_definition_set_globals_allocator";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8)
          goto LABEL_5;
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_globals_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_globals_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_globals_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_globals_allocator";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_globals_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8)
      goto LABEL_5;
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_common_state(v5);
  v6->common_state->var0 = a2;
  v6->common_state->var2 = a3;
LABEL_5:

}

void sub_18319C5C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_should_flush_cache_entry(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_should_flush_cache_entry";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_should_flush_cache_entry";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_should_flush_cache_entry";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_common_state(v3);
    v4->common_state->var8 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_should_flush_cache_entry";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_should_flush_cache_entry";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null should_flush_cache_function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_should_flush_cache_entry";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null should_flush_cache_function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_should_flush_cache_entry";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null should_flush_cache_function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_should_flush_cache_entry";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null should_flush_cache_function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_18319CA8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_cache_entry_deallocator(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_cache_entry_deallocator";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_cache_entry_deallocator";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_cache_entry_deallocator";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_common_state(v3);
    v4->common_state->var7 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_cache_entry_deallocator";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_cache_entry_deallocator";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null deallocate_function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_cache_entry_deallocator";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_cache_entry_deallocator";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_cache_entry_deallocator";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_18319CF4C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sa_dst_compare_init_once(void)
{
  uint64_t result;
  mach_timebase_info info;

  info = 0;
  result = mach_timebase_info(&info);
  cache_timeout = 1000000000 * (unint64_t)info.denom / info.numer;
  return result;
}

uint64_t NWParameters.__allocating_init(tls:tcp:)(uint64_t a1, uint64_t a2)
{
  return sub_183307568(a1, a2, 2u);
}

void nw_quic_connection_execute_locked(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_execute_locked_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_execute_locked";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_execute_locked";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_execute_locked";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_execute_locked";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_execute_locked";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18319D2A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_execute_locked_block_invoke(uint64_t a1, os_unfair_lock_s *a2)
{
  os_unfair_lock_s *v3;

  v3 = a2 + 53;
  os_unfair_lock_lock(a2 + 53);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  os_unfair_lock_unlock(v3);
  return 1;
}

uint64_t nw_protocol_ipv4_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  void *handle;
  nw_protocol **p_output_handler;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v9;
  void (**v10)(_QWORD);
  const void *v11;
  nw_protocol *output_handler;
  nw_protocol_callbacks *v14;
  void (*remove_input_handler)(nw_protocol *, nw_protocol *, uint64_t);
  void *v16;
  nw_protocol_callbacks *v17;
  nw_protocol_callbacks *v18;
  nw_protocol *default_input_handler;
  nw_protocol *v20;
  nw_protocol *v21;
  _QWORD *v22;
  nw_protocol *v23;
  nw_protocol_identifier *identifier;
  nw_protocol *v25;
  nw_protocol *v26;
  nw_protocol_identifier *v27;
  nw_protocol *v28;
  nw_protocol_callbacks *v29;
  nw_protocol_callbacks *v30;
  void (**v31)(_QWORD);
  const void *v32;
  nw_protocol_callbacks *v33;
  nw_protocol_callbacks *v34;
  void (**v35)(_QWORD);
  const void *v36;
  nw_protocol_callbacks *v37;
  nw_protocol_callbacks *v38;
  void (**v39)(_QWORD);
  const void *v40;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  char *v44;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  char *backtrace_string;
  _BOOL4 v51;
  const char *v52;
  _BOOL4 v53;
  char *v54;
  _BOOL4 v55;
  char v56;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  char *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv4_remove_input_handler";
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (!__nwlog_fault(v44, &type, &v56))
      goto LABEL_117;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v56)
      {
        v41 = __nwlog_obj();
        v42 = type;
        if (!os_log_type_enabled(v41, type))
          goto LABEL_117;
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_ipv4_remove_input_handler";
        v43 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_116;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v41 = __nwlog_obj();
      v42 = type;
      v51 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v51)
          goto LABEL_117;
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_ipv4_remove_input_handler";
        v43 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_116;
      }
      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        v59 = "nw_protocol_ipv4_remove_input_handler";
        v60 = 2082;
        v61 = backtrace_string;
        v52 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_99:
        _os_log_impl(&dword_182FBE000, v41, v42, v52, buf, 0x16u);
      }
LABEL_100:
      free(backtrace_string);
      goto LABEL_117;
    }
    v41 = __nwlog_obj();
    v42 = type;
    if (!os_log_type_enabled(v41, type))
      goto LABEL_117;
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv4_remove_input_handler";
    v43 = "%{public}s called with null protocol";
LABEL_116:
    _os_log_impl(&dword_182FBE000, v41, v42, v43, buf, 0xCu);
LABEL_117:
    if (v44)
      free(v44);
    return 0;
  }
  handle = a1->handle;
  if (handle == &nw_protocol_ref_counted_handle)
    p_output_handler = &a1[1].output_handler;
  else
    p_output_handler = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv4_remove_input_handler";
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (!__nwlog_fault(v44, &type, &v56))
      goto LABEL_117;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v41 = __nwlog_obj();
      v42 = type;
      if (!os_log_type_enabled(v41, type))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v59 = "nw_protocol_ipv4_remove_input_handler";
      v43 = "%{public}s called with null ipv4";
      goto LABEL_116;
    }
    if (!v56)
    {
      v41 = __nwlog_obj();
      v42 = type;
      if (!os_log_type_enabled(v41, type))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v59 = "nw_protocol_ipv4_remove_input_handler";
      v43 = "%{public}s called with null ipv4, backtrace limit exceeded";
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v41 = __nwlog_obj();
    v42 = type;
    v53 = os_log_type_enabled(v41, type);
    if (backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)buf = 136446466;
        v59 = "nw_protocol_ipv4_remove_input_handler";
        v60 = 2082;
        v61 = backtrace_string;
        v52 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
        goto LABEL_99;
      }
      goto LABEL_100;
    }
    if (!v53)
      goto LABEL_117;
    *(_DWORD *)buf = 136446210;
    v59 = "nw_protocol_ipv4_remove_input_handler";
    v43 = "%{public}s called with null ipv4, no backtrace";
    goto LABEL_116;
  }
  if (a2)
  {
    if (a2->output_handler == a1)
    {
      callbacks = a1[1].callbacks;
      if (callbacks)
      {
        v9 = (nw_protocol_callbacks *)((char *)callbacks - 1);
        a1[1].callbacks = v9;
        if (!v9)
        {
          v10 = *(void (***)(_QWORD))a1[1].flow_id;
          if (v10)
          {
            *(_QWORD *)a1[1].flow_id = 0;
            v10[2](v10);
            _Block_release(v10);
          }
          if ((a1[1].flow_id[8] & 1) != 0)
          {
            v11 = *(const void **)a1[1].flow_id;
            if (v11)
              _Block_release(v11);
          }
          free(a1);
        }
      }
      a2->output_handler = 0;
    }
    goto LABEL_18;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v59 = "__nw_protocol_get_output_handler";
  v46 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v56 = 0;
  if (__nwlog_fault(v46, &type, &v56))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (!os_log_type_enabled(v47, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      v59 = "__nw_protocol_get_output_handler";
      v49 = "%{public}s called with null protocol";
      goto LABEL_121;
    }
    if (!v56)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (!os_log_type_enabled(v47, type))
        goto LABEL_122;
      *(_DWORD *)buf = 136446210;
      v59 = "__nw_protocol_get_output_handler";
      v49 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_121;
    }
    v54 = (char *)__nw_create_backtrace_string();
    v47 = __nwlog_obj();
    v48 = type;
    v55 = os_log_type_enabled(v47, type);
    if (v54)
    {
      if (v55)
      {
        *(_DWORD *)buf = 136446466;
        v59 = "__nw_protocol_get_output_handler";
        v60 = 2082;
        v61 = v54;
        _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v54);
      goto LABEL_122;
    }
    if (v55)
    {
      *(_DWORD *)buf = 136446210;
      v59 = "__nw_protocol_get_output_handler";
      v49 = "%{public}s called with null protocol, no backtrace";
LABEL_121:
      _os_log_impl(&dword_182FBE000, v47, v48, v49, buf, 0xCu);
    }
  }
LABEL_122:
  if (v46)
    free(v46);
LABEL_18:
  if (a1->default_input_handler != a2)
    return 0;
  output_handler = a1->output_handler;
  if (output_handler)
  {
    v14 = output_handler->callbacks;
    if (v14)
    {
      remove_input_handler = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v14->remove_input_handler;
      if (remove_input_handler)
      {
        v16 = output_handler->handle;
        if (v16 == &nw_protocol_ref_counted_handle)
        {
          v17 = output_handler[1].callbacks;
          if (v17)
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v17->add_input_handler + 1);
        }
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v18 = a1[1].callbacks;
          if (v18)
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
          remove_input_handler(output_handler, a1, a3);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v33 = a1[1].callbacks;
            if (v33)
            {
              v34 = (nw_protocol_callbacks *)((char *)v33 - 1);
              a1[1].callbacks = v34;
              if (!v34)
              {
                v35 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v35)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v35[2](v35);
                  _Block_release(v35);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v36 = *(const void **)a1[1].flow_id;
                  if (v36)
                    _Block_release(v36);
                }
                free(a1);
              }
            }
          }
        }
        else
        {
          remove_input_handler(output_handler, a1, a3);
        }
        if (v16 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v37 = output_handler[1].callbacks;
          if (v37)
          {
            v38 = (nw_protocol_callbacks *)((char *)v37 - 1);
            output_handler[1].callbacks = v38;
            if (!v38)
            {
              v39 = *(void (***)(_QWORD))output_handler[1].flow_id;
              if (v39)
              {
                *(_QWORD *)output_handler[1].flow_id = 0;
                v39[2](v39);
                _Block_release(v39);
              }
              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                v40 = *(const void **)output_handler[1].flow_id;
                if (v40)
                  _Block_release(v40);
              }
              free(output_handler);
            }
          }
        }
      }
    }
  }
  nw_protocol_ip_register_segmentation_offload_notification(a1, 0);
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v29 = default_input_handler[1].callbacks;
      if (v29)
      {
        v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
        default_input_handler[1].callbacks = v30;
        if (!v30)
        {
          v31 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v31)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v31[2](v31);
            _Block_release(v31);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v32 = *(const void **)default_input_handler[1].flow_id;
            if (v32)
              _Block_release(v32);
          }
          free(default_input_handler);
        }
      }
    }
    a1->default_input_handler = 0;
  }
  if ((_DWORD)a3)
  {
    while (1)
    {
      v20 = a1[2].output_handler;
      if (!v20)
        break;
      v21 = v20->output_handler;
      v22 = v20->handle;
      if (v21)
      {
        v21->handle = v22;
        v22 = v20->handle;
      }
      else
      {
        a1[2].handle = v22;
      }
      *v22 = v21;
      v20->output_handler = 0;
      v20->handle = 0;
      nw_frame_finalize((uint64_t)v20);
    }
    while (1)
    {
      v23 = p_output_handler[10];
      if (!v23)
        break;
      identifier = v23->identifier;
      v25 = (nw_protocol *)v23->callbacks;
      if (identifier)
      {
        *(_QWORD *)&identifier->name[24] = v25;
        v25 = (nw_protocol *)v23->callbacks;
      }
      else
      {
        p_output_handler[11] = v25;
      }
      *(_QWORD *)v25->flow_id = identifier;
      v23->identifier = 0;
      v23->callbacks = 0;
      nw_frame_free_buffer((uint64_t)v23);
      os_release(v23);
    }
    while (1)
    {
      v26 = p_output_handler[12];
      if (!v26)
        break;
      v27 = v26->identifier;
      v28 = (nw_protocol *)v26->callbacks;
      if (v27)
      {
        *(_QWORD *)&v27->name[24] = v28;
        v28 = (nw_protocol *)v26->callbacks;
      }
      else
      {
        p_output_handler[13] = v28;
      }
      *(_QWORD *)v28->flow_id = v27;
      v26->identifier = 0;
      v26->callbacks = 0;
      nw_frame_free_buffer((uint64_t)v26);
      os_release(v26);
    }
    nw_protocol_destroy((uint64_t)p_output_handler, 0);
  }
  return 1;
}

BOOL nw_channel_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v4;
  _QWORD *output_handler_context;
  void *v6;
  void *v7;
  nw_protocol *output_handler;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  uint64_t v18;
  _QWORD *v19;
  NSObject *v20;
  NSObject *v21;
  _BOOL8 result;
  char *backtrace_string;
  _BOOL4 v24;
  const char *v25;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v27;
  void (**v28)(_QWORD);
  const void *v29;
  void *v30;
  char v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  void (**v36)(_QWORD);
  const void *v37;
  void *v38;
  _BOOL8 source;
  uint64_t v40;
  nw_protocol_callbacks *v41;
  uint64_t (*get_parameters)(nw_protocol *);
  char v43;
  NSObject *v44;
  uint64_t v45;
  void *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  nw_protocol_callbacks *v51;
  void *v52;
  uint64_t channel_teardown_delay;
  int64_t v54;
  NSObject *v55;
  NSObject *v56;
  dispatch_time_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  _BOOL4 v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  const char *v67;
  _BOOL4 v68;
  _BOOL4 v69;
  char *v70;
  _BOOL4 v71;
  char v72;
  _QWORD v73[5];
  _QWORD v74[5];
  _QWORD v75[5];
  os_log_type_t v76;
  _BYTE v77[12];
  __int16 v78;
  int64_t v79;
  uint8_t buf[40];
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
    v14 = (char *)_os_log_send_and_compose_impl();
    v77[0] = 16;
    v76 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v14, v77, &v76))
      goto LABEL_77;
    if (v77[0] == 17)
    {
      v15 = __nwlog_obj();
      v16 = v77[0];
      if (!os_log_type_enabled(v15, (os_log_type_t)v77[0]))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
      v17 = "%{public}s called with null channel_protocol";
      goto LABEL_76;
    }
    if (v76 == OS_LOG_TYPE_DEFAULT)
    {
      v15 = __nwlog_obj();
      v16 = v77[0];
      if (!os_log_type_enabled(v15, (os_log_type_t)v77[0]))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
      v17 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
      goto LABEL_76;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = v77[0];
    v68 = os_log_type_enabled(v15, (os_log_type_t)v77[0]);
    if (!backtrace_string)
    {
      if (!v68)
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
      v17 = "%{public}s called with null channel_protocol, no backtrace";
      goto LABEL_76;
    }
    if (!v68)
      goto LABEL_43;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v25 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
    goto LABEL_42;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
    v14 = (char *)_os_log_send_and_compose_impl();
    v77[0] = 16;
    v76 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v14, v77, &v76))
      goto LABEL_77;
    if (v77[0] == 17)
    {
      v15 = __nwlog_obj();
      v16 = v77[0];
      if (!os_log_type_enabled(v15, (os_log_type_t)v77[0]))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
      v17 = "%{public}s called with null channel";
      goto LABEL_76;
    }
    if (v76 == OS_LOG_TYPE_DEFAULT)
    {
      v15 = __nwlog_obj();
      v16 = v77[0];
      if (!os_log_type_enabled(v15, (os_log_type_t)v77[0]))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
      v17 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_76;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = v77[0];
    v69 = os_log_type_enabled(v15, (os_log_type_t)v77[0]);
    if (!backtrace_string)
    {
      if (!v69)
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
      v17 = "%{public}s called with null channel, no backtrace";
      goto LABEL_76;
    }
    if (!v69)
      goto LABEL_43;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v25 = "%{public}s called with null channel, dumping backtrace:%{public}s";
    goto LABEL_42;
  }
  if (a2)
  {
    if ((nw_protocol *)handle[34] == a2)
      handle[34] = 0;
    v4 = handle[35];
    if (v4)
    {
      output_handler_context = a2->output_handler_context;
      if (output_handler_context)
      {
        if ((*((_BYTE *)output_handler_context + 153) & 1) != 0)
        {
          v18 = output_handler_context[9];
          v19 = (_QWORD *)output_handler_context[10];
          if (v18)
          {
            *(_QWORD *)(v18 + 48) = v19;
            v19 = (_QWORD *)output_handler_context[10];
          }
          else
          {
            handle[47] = v19;
          }
          *v19 = v18;
          v31 = *((_BYTE *)output_handler_context + 153) & 0xFE;
          *((_BYTE *)output_handler_context + 153) = v31;
          if ((v31 & 2) == 0)
          {
LABEL_10:
            v6 = (void *)output_handler_context[6];
            if (!v6)
            {
LABEL_12:
              v7 = (void *)output_handler_context[13];
              if (v7)
              {
                os_release(v7);
                output_handler_context[13] = 0;
              }
              a2->output_handler_context = 0;
              output_handler = a2->output_handler;
              if (output_handler)
              {
                if (output_handler->handle == &nw_protocol_ref_counted_handle)
                {
                  callbacks = output_handler[1].callbacks;
                  if (callbacks)
                  {
                    v27 = (nw_protocol_callbacks *)((char *)callbacks - 1);
                    output_handler[1].callbacks = v27;
                    if (!v27)
                    {
                      v28 = *(void (***)(_QWORD))output_handler[1].flow_id;
                      if (v28)
                      {
                        *(_QWORD *)output_handler[1].flow_id = 0;
                        v28[2](v28);
                        _Block_release(v28);
                      }
                      if ((output_handler[1].flow_id[8] & 1) != 0)
                      {
                        v29 = *(const void **)output_handler[1].flow_id;
                        if (v29)
                          _Block_release(v29);
                      }
                      free(output_handler);
                    }
                  }
                }
                a2->output_handler = 0;
              }
              v9 = output_handler_context[4];
              if (v9)
              {
                while (v9)
                {
                  v10 = *(_QWORD *)(v9 + 32);
                  nw_frame_finalize(v9);
                  v9 = v10;
                }
              }
              if ((output_handler_context[8] & 1) != 0)
              {
                v11 = output_handler_context[7];
                if (v11)
                {
                  if (*(_UNKNOWN **)(v11 + 40) == &nw_protocol_ref_counted_handle)
                  {
                    v34 = *(_QWORD *)(v11 + 88);
                    if (v34)
                    {
                      v35 = v34 - 1;
                      *(_QWORD *)(v11 + 88) = v35;
                      if (!v35)
                      {
                        v36 = *(void (***)(_QWORD))(v11 + 64);
                        if (v36)
                        {
                          *(_QWORD *)(v11 + 64) = 0;
                          v36[2](v36);
                          _Block_release(v36);
                        }
                        if ((*(_BYTE *)(v11 + 72) & 1) != 0)
                        {
                          v37 = *(const void **)(v11 + 64);
                          if (v37)
                            _Block_release(v37);
                        }
                        free((void *)v11);
                      }
                    }
                  }
                }
              }
              *((_BYTE *)output_handler_context + 64) |= 1u;
              output_handler_context[7] = 0;
              if (nw_hash_table_remove_node(v4, (uint64_t)output_handler_context))
              {
                if (handle[17])
                {
                  if (os_channel_packet_pool_purge())
                    v13 = nw_channel_check_defunct((uint64_t)handle);
                  else
                    v13 = 0;
                }
                else
                {
                  v13 = 1;
                }
                if ((*((_WORD *)handle + 222) & 0x20) == 0 || nw_hash_table_count(handle[35], v12))
                  return 1;
                *(_QWORD *)buf = 0;
                *(_QWORD *)&buf[8] = buf;
                *(_QWORD *)&buf[16] = 0x2000000000;
                *(_QWORD *)&buf[24] = 0;
                *(_QWORD *)&buf[24] = os_retain(handle);
                if (v13)
                {
                  v30 = (void *)handle[19];
                  v75[0] = MEMORY[0x1E0C809B0];
                  v75[1] = 0x40000000;
                  v75[2] = ___ZL31nw_channel_remove_input_handlerP11nw_protocolS0_b_block_invoke;
                  v75[3] = &unk_1E14ACCD0;
                  v75[4] = buf;
                  nw_queue_context_async(v30, v75);
LABEL_108:
                  _Block_object_dispose(buf, 8);
                  return 1;
                }
                if ((*((_WORD *)handle + 222) & 0x40) != 0)
                {
                  v44 = __nwlog_obj();
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                    _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Tearing down channel immediately", v77, 0xCu);
                  }
                  nw_channel_close(*(_QWORD *)(*(_QWORD *)&buf[8] + 24), v45);
                  goto LABEL_89;
                }
                v38 = (void *)handle[19];
                v74[0] = MEMORY[0x1E0C809B0];
                v74[1] = 0x40000000;
                v74[2] = ___ZL31nw_channel_remove_input_handlerP11nw_protocolS0_b_block_invoke_52;
                v74[3] = &unk_1E14ACCF8;
                v74[4] = buf;
                v73[0] = MEMORY[0x1E0C809B0];
                v73[1] = 0x40000000;
                v73[2] = ___ZL31nw_channel_remove_input_handlerP11nw_protocolS0_b_block_invoke_54;
                v73[3] = &unk_1E14ACD20;
                v73[4] = buf;
                source = nw_queue_context_create_source(v38, 2, 3, 0, v74, v73);
                if (source)
                {
                  v40 = source;
                  v41 = a2->callbacks;
                  if (!v41)
                    goto LABEL_102;
                  get_parameters = (uint64_t (*)(nw_protocol *))v41->get_parameters;
                  if (!get_parameters)
                    goto LABEL_102;
                  if (a2->handle == &nw_protocol_ref_counted_handle)
                  {
                    v51 = a2[1].callbacks;
                    if (v51)
                      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v51->add_input_handler + 1);
                    *(_QWORD *)v77 = a2;
                    v43 = v77[8] | 1;
                  }
                  else
                  {
                    *(_QWORD *)v77 = a2;
                    v43 = v77[8] & 0xFE;
                  }
                  v77[8] = v43;
                  v52 = (void *)get_parameters(a2);
                  nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v77);
                  if (v52 && (channel_teardown_delay = nw_parameters_get_channel_teardown_delay(v52)) != 0)
                  {
                    v54 = channel_teardown_delay;
                    v55 = __nwlog_obj();
                    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)v77 = 136446466;
                      *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                      v78 = 2048;
                      v79 = v54;
                      _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEBUG, "%{public}s Using overridden channel teardown delay: %llums", v77, 0x16u);
                    }
                  }
                  else
                  {
LABEL_102:
                    v54 = 1000
                        * networkd_settings_get_int64_with_default((const char *)nw_setting_channel_teardown_delay, 60);
                  }
                  v56 = __nwlog_obj();
                  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)v77 = 136446466;
                    *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                    v78 = 2048;
                    v79 = v54;
                    _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_DEBUG, "%{public}s Setting timer to tear down channel after %llums", v77, 0x16u);
                  }
                  v57 = dispatch_time(0x8000000000000000, 1000000 * v54);
                  nw_queue_set_timer_values(v40, v57, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
                  v59 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
                  v60 = *(_QWORD *)(v59 + 200);
                  if (v60)
                  {
                    nw_queue_cancel_source(v60, v58);
                    v61 = *(_QWORD *)&buf[8];
                    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)&buf[8] + 24) + 200) = 0;
                    v59 = *(_QWORD *)(v61 + 24);
                  }
                  *(_QWORD *)(v59 + 200) = v40;
                  nw_queue_activate_source(v40, v58);
                  goto LABEL_108;
                }
                __nwlog_obj();
                *(_DWORD *)v77 = 136446210;
                *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                v47 = (char *)_os_log_send_and_compose_impl();
                v76 = OS_LOG_TYPE_ERROR;
                v72 = 0;
                if (__nwlog_fault(v47, &v76, &v72))
                {
                  if (v76 == OS_LOG_TYPE_FAULT)
                  {
                    v48 = __nwlog_obj();
                    v49 = v76;
                    if (!os_log_type_enabled(v48, v76))
                      goto LABEL_129;
                    *(_DWORD *)v77 = 136446210;
                    *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                    v50 = "%{public}s nw_queue_context_create_source(timer) failed";
                    goto LABEL_128;
                  }
                  if (!v72)
                  {
                    v48 = __nwlog_obj();
                    v49 = v76;
                    if (!os_log_type_enabled(v48, v76))
                      goto LABEL_129;
                    *(_DWORD *)v77 = 136446210;
                    *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                    v50 = "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded";
                    goto LABEL_128;
                  }
                  v62 = (char *)__nw_create_backtrace_string();
                  v48 = __nwlog_obj();
                  v49 = v76;
                  v63 = os_log_type_enabled(v48, v76);
                  if (v62)
                  {
                    if (v63)
                    {
                      *(_DWORD *)v77 = 136446466;
                      *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                      v78 = 2082;
                      v79 = (int64_t)v62;
                      _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s", v77, 0x16u);
                    }
                    free(v62);
                    goto LABEL_129;
                  }
                  if (v63)
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(_QWORD *)&v77[4] = "nw_channel_remove_input_handler";
                    v50 = "%{public}s nw_queue_context_create_source(timer) failed, no backtrace";
LABEL_128:
                    _os_log_impl(&dword_182FBE000, v48, v49, v50, v77, 0xCu);
                  }
                }
LABEL_129:
                if (v47)
                  free(v47);
LABEL_89:
                v46 = *(void **)(*(_QWORD *)&buf[8] + 24);
                if (v46)
                {
                  os_release(v46);
                  *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = 0;
                }
                goto LABEL_108;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v20 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "remove_input_handler";
                _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s nw_hash_table_remove_node failed", buf, 0xCu);
              }
              goto LABEL_36;
            }
LABEL_11:
            os_release(v6);
            output_handler_context[6] = 0;
            goto LABEL_12;
          }
        }
        else if ((*((_BYTE *)output_handler_context + 153) & 2) == 0)
        {
          goto LABEL_10;
        }
        v32 = output_handler_context[11];
        v33 = (_QWORD *)output_handler_context[12];
        if (v32)
        {
          *(_QWORD *)(v32 + 64) = v33;
          v33 = (_QWORD *)output_handler_context[12];
        }
        else
        {
          handle[49] = v33;
        }
        *v33 = v32;
        *((_BYTE *)output_handler_context + 153) &= ~2u;
        v6 = (void *)output_handler_context[6];
        if (!v6)
          goto LABEL_12;
        goto LABEL_11;
      }
LABEL_36:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
        *(_WORD *)&buf[12] = 1042;
        *(_DWORD *)&buf[14] = 16;
        *(_WORD *)&buf[18] = 2098;
        *(_QWORD *)&buf[20] = a2;
        _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s Channel does not have input handler registered for %{public,uuid_t}.16P", buf, 0x1Cu);
        return 0;
      }
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "remove_input_handler";
    v64 = (char *)_os_log_send_and_compose_impl();
    v77[0] = 16;
    v76 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v64, v77, &v76))
    {
      if (v77[0] == 17)
      {
        v65 = __nwlog_obj();
        v66 = v77[0];
        if (!os_log_type_enabled(v65, (os_log_type_t)v77[0]))
          goto LABEL_162;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "remove_input_handler";
        v67 = "%{public}s called with null table";
        goto LABEL_161;
      }
      if (v76 == OS_LOG_TYPE_DEFAULT)
      {
        v65 = __nwlog_obj();
        v66 = v77[0];
        if (!os_log_type_enabled(v65, (os_log_type_t)v77[0]))
          goto LABEL_162;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "remove_input_handler";
        v67 = "%{public}s called with null table, backtrace limit exceeded";
        goto LABEL_161;
      }
      v70 = (char *)__nw_create_backtrace_string();
      v65 = __nwlog_obj();
      v66 = v77[0];
      v71 = os_log_type_enabled(v65, (os_log_type_t)v77[0]);
      if (v70)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "remove_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v70;
          _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v70);
        goto LABEL_162;
      }
      if (v71)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "remove_input_handler";
        v67 = "%{public}s called with null table, no backtrace";
LABEL_161:
        _os_log_impl(&dword_182FBE000, v65, v66, v67, buf, 0xCu);
      }
    }
LABEL_162:
    if (v64)
      free(v64);
    goto LABEL_36;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
  v14 = (char *)_os_log_send_and_compose_impl();
  v77[0] = 16;
  v76 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v14, v77, &v76))
    goto LABEL_77;
  if (v77[0] == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    v16 = v77[0];
    if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v77[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
      v17 = "%{public}s called with null input_protocol";
LABEL_76:
      _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
      goto LABEL_77;
    }
    goto LABEL_77;
  }
  if (v76)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    v16 = v77[0];
    v24 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v77[0]);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
        v17 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    if (!v24)
    {
LABEL_43:
      free(backtrace_string);
      goto LABEL_77;
    }
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_182FBE000, v15, v16, v25, buf, 0x16u);
    goto LABEL_43;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v15 = gLogObj;
  v16 = v77[0];
  if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v77[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_remove_input_handler";
    v17 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    goto LABEL_76;
  }
LABEL_77:
  if (v14)
    free(v14);
  return 0;
}

uint64_t nw_endpoint_is_active(void *a1, int a2)
{
  id v3;
  void *v4;
  os_unfair_lock_s *v5;
  char v6;
  int v7;
  NSObject *v8;
  Class isa;
  NSObject *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  Class v14;
  BOOL v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  Class v19;
  dispatch_queue_t *v20;
  dispatch_queue_t *v21;
  Class v22;
  uint64_t v23;
  os_unfair_lock_s *v24;
  os_unfair_lock_s *v25;
  uint64_t v26;
  BOOL v27;
  int v28;
  void *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  void *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  NSObject *v37;
  const char *v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  char *backtrace_string;
  os_log_type_t v43;
  _BOOL4 v44;
  const char *v45;
  NSObject *v46;
  const char *logging_description;
  NSObject *v48;
  const char *v49;
  NSObject *v50;
  const char *v51;
  os_log_type_t v52;
  os_log_type_t v53;
  uint64_t v54;
  os_log_type_t type[8];
  uint64_t v57;
  uint64_t v58;
  void *v59;
  os_unfair_lock_s *v60;
  char v61;
  os_log_type_t v62;
  _BYTE v63[24];
  char v64;
  _BYTE buf[24];
  void *v66;
  os_unfair_lock_s *v67;
  os_log_type_t *v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (!a2)
      goto LABEL_6;
    v5 = (os_unfair_lock_s *)v3;
    *(_QWORD *)v63 = 0;
    *(_QWORD *)&v63[8] = v63;
    *(_QWORD *)&v63[16] = 0x2020000000;
    v64 = 0;
    *(_QWORD *)type = 0;
    v57 = (uint64_t)type;
    v58 = 0x2020000000;
    LOBYTE(v59) = 0;
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke;
    v66 = &unk_1E14ACE40;
    v67 = v5;
    v68 = type;
    nw_endpoint_locked(v5, buf);
    v6 = *(_BYTE *)(v57 + 24);

    _Block_object_dispose(type, 8);
    *(_BYTE *)(*(_QWORD *)&v63[8] + 24) = v6;
    _Block_object_dispose(v63, 8);
    if (v6)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v46 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          logging_description = nw_endpoint_get_logging_description(v5);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = logging_description;
          _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s has active edges", buf, 0x16u);
        }

      }
      v7 = 1;
    }
    else
    {
LABEL_6:
      v7 = 0;
    }
    v8 = v4;
    isa = v8[26].isa;
    if (isa)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          v38 = nw_endpoint_get_logging_description(v8);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_cleanup_empty_registrars";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v38;
          _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s before cleanup, has registrar", buf, 0x16u);
        }

        isa = v8[26].isa;
      }
      if (!nw_protocol_instance_registrar_get_instance_count(isa))
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          v50 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            v51 = nw_endpoint_get_logging_description(v8);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_cleanup_empty_registrars";
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v51;
            _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s registrar empty, removing", buf, 0x16u);
          }

        }
        v10 = v8[26].isa;
        v8[26].isa = 0;
        goto LABEL_19;
      }
      if (!gLogDatapath)
        goto LABEL_20;
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        goto LABEL_19;
      v11 = nw_endpoint_get_logging_description(v8);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_cleanup_empty_registrars";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v11;
      v12 = "%{public}s endpoint %s registrar not empty, keeping";
    }
    else
    {
      if (!gLogDatapath)
        goto LABEL_20;
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
LABEL_19:

LABEL_20:
        v14 = v8[26].isa;
        if (v14)
        {
          v15 = nw_protocol_instance_registrar_get_instance_count(v14) == 0;

          if (v15)
          {
            v16 = 0;
LABEL_27:
            v18 = v8;
            v19 = v18[1].isa;
            if (v19)
            {
              v20 = v19;
              v21 = v20;
              if (((_BYTE)v20[17] & 8) == 0)
                dispatch_assert_queue_V2(v20[1]);

              v22 = v18[25].isa;
              if (v22 && *((_DWORD *)v22 + 10))
              {
                v23 = MEMORY[0x1E0C809B0];
                *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                *(_QWORD *)&buf[8] = 3221225472;
                *(_QWORD *)&buf[16] = __nw_endpoint_has_associations_block_invoke;
                v66 = &unk_1E14AC340;
                v24 = v18;
                v67 = v24;
                nw_hash_table_apply((char *)v22, (uint64_t)buf);
                *(_QWORD *)type = v23;
                v57 = 3221225472;
                v58 = (uint64_t)__nw_endpoint_has_associations_block_invoke_34;
                v59 = &unk_1E14ACFD0;
                v25 = v24;
                v60 = v25;
                os_unfair_lock_lock(v24 + 45);
                __nw_endpoint_has_associations_block_invoke_34((uint64_t)type);
                os_unfair_lock_unlock(v24 + 45);
                v27 = nw_hash_table_count((uint64_t)v18[25].isa, v26) == 0;

                if (!v27)
                {
                  if (gLogDatapath)
                  {
                    __nwlog_obj();
                    v48 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
                    {
                      v49 = nw_endpoint_get_logging_description(v25);
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = v49;
                      _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s has associations", buf, 0x16u);
                    }

                  }
                  v28 = 1;
                  goto LABEL_89;
                }
LABEL_88:
                v28 = 0;
LABEL_89:
                v54 = v7 | v16 | v28;
                goto LABEL_90;
              }
LABEL_87:

              goto LABEL_88;
            }
            __nwlog_obj();
            v33 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)v63 = 136446210;
            *(_QWORD *)&v63[4] = "nw_endpoint_has_associations";
            v34 = (char *)_os_log_send_and_compose_impl();

            v62 = OS_LOG_TYPE_ERROR;
            v61 = 0;
            if (__nwlog_fault(v34, &v62, &v61))
            {
              if (v62 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v35 = objc_claimAutoreleasedReturnValue();
                v36 = v62;
                if (os_log_type_enabled(v35, v62))
                {
                  *(_DWORD *)v63 = 136446210;
                  *(_QWORD *)&v63[4] = "nw_endpoint_has_associations";
                  _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s called with null endpoint->context", v63, 0xCu);
                }
              }
              else if (v61)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v35 = objc_claimAutoreleasedReturnValue();
                v43 = v62;
                v44 = os_log_type_enabled(v35, v62);
                if (backtrace_string)
                {
                  if (v44)
                  {
                    *(_DWORD *)v63 = 136446466;
                    *(_QWORD *)&v63[4] = "nw_endpoint_has_associations";
                    *(_WORD *)&v63[12] = 2082;
                    *(_QWORD *)&v63[14] = backtrace_string;
                    _os_log_impl(&dword_182FBE000, v35, v43, "%{public}s called with null endpoint->context, dumping backtrace:%{public}s", v63, 0x16u);
                  }

                  free(backtrace_string);
                  goto LABEL_85;
                }
                if (v44)
                {
                  *(_DWORD *)v63 = 136446210;
                  *(_QWORD *)&v63[4] = "nw_endpoint_has_associations";
                  _os_log_impl(&dword_182FBE000, v35, v43, "%{public}s called with null endpoint->context, no backtrace", v63, 0xCu);
                }
              }
              else
              {
                __nwlog_obj();
                v35 = objc_claimAutoreleasedReturnValue();
                v53 = v62;
                if (os_log_type_enabled(v35, v62))
                {
                  *(_DWORD *)v63 = 136446210;
                  *(_QWORD *)&v63[4] = "nw_endpoint_has_associations";
                  _os_log_impl(&dword_182FBE000, v35, v53, "%{public}s called with null endpoint->context, backtrace limit exceeded", v63, 0xCu);
                }
              }

            }
LABEL_85:
            if (v34)
              free(v34);
            goto LABEL_87;
          }
          if (!gLogDatapath)
          {
            v16 = 1;
            goto LABEL_27;
          }
          __nwlog_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            v45 = nw_endpoint_get_logging_description(v8);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v45;
            _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s has active protocol registrars", buf, 0x16u);
          }
          v16 = 1;
        }
        else
        {
          v16 = 0;
          v17 = v8;
        }

        goto LABEL_27;
      }
      v13 = nw_endpoint_get_logging_description(v8);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_cleanup_empty_registrars";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v13;
      v12 = "%{public}s endpoint %s has nothing to cleanup, no protocol instance registrars";
    }
    _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, v12, buf, 0x16u);
    goto LABEL_19;
  }
  __nwlog_obj();
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
  v30 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v63[0] = 0;
  if (__nwlog_fault(v30, type, v63))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v32 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v63[0])
    {
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v40 = type[0];
      v41 = os_log_type_enabled(v31, type[0]);
      if (v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v39;
          _os_log_impl(&dword_182FBE000, v31, v40, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v39);
        goto LABEL_79;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_182FBE000, v31, v40, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v52 = type[0];
      if (os_log_type_enabled(v31, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_182FBE000, v31, v52, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_79:
  if (v30)
    free(v30);
  v54 = 0;
LABEL_90:

  return v54;
}

void sub_18319F4B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_hash_table_count(uint64_t a1, uint64_t a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  uint64_t v10;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(unsigned int *)(a1 + 40);
  __nwlog_obj(0, a2);
  *(_DWORD *)buf = 136446210;
  v15 = "nw_hash_table_count";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  v4 = __nwlog_fault(v3, &type, &v12);
  if ((_DWORD)v4)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj(v4, v5);
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_hash_table_count";
        v8 = "%{public}s called with null table";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj(backtrace_string, v10);
      v7 = type;
      v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_hash_table_count";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_hash_table_count";
        v8 = "%{public}s called with null table, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v6 = __nwlog_obj(v4, v5);
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_hash_table_count";
        v8 = "%{public}s called with null table, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_protocol_default_unregister_notification(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t (*v3)(void);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_default_unregister_notification";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v5, &type, &v11))
      goto LABEL_20;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_unregister_notification";
      v8 = "%{public}s called with null protocol";
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_protocol_default_unregister_notification";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v10)
      {
LABEL_20:
        if (v5)
          free(v5);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_unregister_notification";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_unregister_notification";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_20;
  }
  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 24);
    if (v2)
    {
      v3 = *(uint64_t (**)(void))(v2 + 152);
      if (v3)
        return v3();
    }
  }
  return 0;
}

uint64_t nw_endpoint_flow_setup_channel(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  unsigned int mode;
  NWConcrete_nw_endpoint_mode_handler *v4;
  NWConcrete_nw_endpoint_handler *v5;
  char v6;
  NSObject *v7;
  NWConcrete_nw_endpoint_handler *v8;
  NWConcrete_nw_endpoint_handler *v9;
  char v10;
  const char *v11;
  nw_endpoint_t v12;
  const char *logging_description;
  char *id_str;
  unsigned int *v15;
  unsigned int *v16;
  uint64_t v17;
  const char *v18;
  NWConcrete_nw_endpoint_handler *v19;
  os_unfair_lock_s *p_lock;
  NWConcrete_nw_path *v21;
  NWConcrete_nw_path_flow_registration *v22;
  _BOOL4 nexus_instance;
  int can_use_nexus;
  NWConcrete_nw_endpoint_handler *v25;
  _BOOL4 v26;
  NSObject *v27;
  NWConcrete_nw_endpoint_handler *v28;
  char *v29;
  _BOOL4 v30;
  const char *v31;
  nw_endpoint_t v32;
  const char *v33;
  unsigned int *v34;
  unsigned int *v35;
  uint64_t v36;
  const char *v37;
  const char *v38;
  NWConcrete_nw_endpoint_handler *v39;
  _BOOL4 v40;
  NSObject *v41;
  NWConcrete_nw_endpoint_handler *v42;
  NWConcrete_nw_endpoint_handler *v43;
  _BOOL4 v44;
  const char *v45;
  nw_endpoint_t v46;
  const char *v47;
  unsigned int *v48;
  unsigned int *v49;
  uint64_t v50;
  const char *v51;
  void **v52;
  void **v53;
  const char *v54;
  NWConcrete_nw_endpoint_handler *v55;
  _BOOL4 v56;
  NSObject *v57;
  const char *v58;
  const char *v59;
  nw_endpoint_t v60;
  const char *v61;
  const char *v62;
  const char *v63;
  OS_nw_path *v64;
  NSObject *v65;
  const char *id_string;
  const char *v67;
  nw_endpoint_t v68;
  const char *v69;
  const char *v70;
  const char *v71;
  OS_nw_path *v72;
  id *v73;
  void **v74;
  NWConcrete_nw_path_flow_registration *v75;
  void *v76;
  id *v77;
  _BOOL4 v78;
  NSObject *v79;
  const char *v80;
  const char *v81;
  nw_endpoint_t v82;
  void **v83;
  const char *v84;
  const char *v85;
  const char *v86;
  OS_nw_path *v87;
  _DWORD *v88;
  NSObject *v89;
  const char *v90;
  const char *v91;
  nw_endpoint_t v92;
  const char *v93;
  const char *v94;
  const char *v95;
  OS_nw_path *v96;
  NWConcrete_nw_endpoint_handler *v97;
  BOOL v98;
  NSObject *v99;
  const char *v100;
  const char *v101;
  const char *v102;
  const char *v103;
  const char *v104;
  OS_nw_path *v105;
  void **v106;
  const char *v107;
  void **v108;
  OS_nw_path *v109;
  uint64_t v110;
  NSObject *v111;
  const char *v112;
  const char *v113;
  const char *v114;
  const char *v115;
  const char *v116;
  OS_nw_path *v117;
  _DWORD *posix_error;
  void *v119;
  void **v120;
  void **v121;
  const char *v122;
  int minimize_logging;
  char logging_disabled;
  NSObject *v125;
  const char *v126;
  const char *v127;
  nw_endpoint_t v128;
  const char *v129;
  const char *v130;
  const char *v131;
  OS_nw_path *v132;
  NWConcrete_nw_endpoint_handler *v133;
  NSObject *v134;
  nw_endpoint_t v135;
  const char *v136;
  const char *v137;
  void **v138;
  OS_nw_path *v139;
  const char *v140;
  nw_endpoint_t v141;
  _BYTE *v142;
  _QWORD *v143;
  void **v144;
  OS_nw_path *v145;
  NWConcrete_nw_endpoint_handler *v146;
  void *v147;
  char *v148;
  NSObject *v149;
  os_log_type_t v150;
  char *backtrace_string;
  os_log_type_t v152;
  _BOOL4 v153;
  os_log_type_t v154;
  id v155;
  const char *v156;
  char *v157;
  NSObject *v158;
  os_log_type_t v159;
  const char *v160;
  char *v161;
  os_log_type_t v162;
  _BOOL4 v163;
  const char *v164;
  os_log_type_t v165;
  const char *v166;
  const char *v167;
  const char *v169;
  const char *v170;
  nw_endpoint_t v171;
  const char *v172;
  const char *v173;
  const char *v174;
  OS_nw_path *v175;
  const char *v176;
  const char *v177;
  nw_endpoint_t v178;
  const char *v179;
  const char *v180;
  const char *v181;
  OS_nw_path *v182;
  const char *v183;
  const char *v184;
  nw_endpoint_t v185;
  const char *v186;
  const char *v187;
  const char *v188;
  OS_nw_path *v189;
  const char *v190;
  const char *v191;
  nw_endpoint_t v192;
  const char *v193;
  const char *v194;
  const char *v195;
  OS_nw_path *v196;
  const char *v197;
  const char *v198;
  const char *v199;
  _DWORD *v200;
  nw_endpoint_t v201;
  const char *v202;
  nw_endpoint_t v203;
  NWConcrete_nw_endpoint_mode_handler *v204;
  NWConcrete_nw_path *v205;
  NWConcrete_nw_endpoint_handler *v206;
  int v207;
  BOOL v208;
  int v209;
  __int128 v210;
  uint8_t buf[4];
  const char *v212;
  __int16 v213;
  char *v214;
  __int16 v215;
  const char *v216;
  __int16 v217;
  void *v218;
  __int16 v219;
  const char *v220;
  __int16 v221;
  const char *v222;
  __int16 v223;
  OS_nw_path *v224;
  __int16 v225;
  NSObject *v226;
  __int128 v227;
  uint64_t v228;

  v228 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v147 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v212 = "nw_endpoint_handler_get_mode";
    v148 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v227) = 16;
    LOBYTE(v210) = 0;
    if (__nwlog_fault(v148, &v227, &v210))
    {
      if (v227 == 17)
      {
        __nwlog_obj();
        v149 = objc_claimAutoreleasedReturnValue();
        v150 = v227;
        if (os_log_type_enabled(v149, (os_log_type_t)v227))
        {
          *(_DWORD *)buf = 136446210;
          v212 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v149, v150, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if ((_BYTE)v210)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v149 = objc_claimAutoreleasedReturnValue();
        v152 = v227;
        v153 = os_log_type_enabled(v149, (os_log_type_t)v227);
        if (backtrace_string)
        {
          if (v153)
          {
            *(_DWORD *)buf = 136446466;
            v212 = "nw_endpoint_handler_get_mode";
            v213 = 2082;
            v214 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v149, v152, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_176;
        }
        if (v153)
        {
          *(_DWORD *)buf = 136446210;
          v212 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v149, v152, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v149 = objc_claimAutoreleasedReturnValue();
        v154 = v227;
        if (os_log_type_enabled(v149, (os_log_type_t)v227))
        {
          *(_DWORD *)buf = 136446210;
          v212 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v149, v154, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_176:
    if (v148)
      free(v148);
    mode = 0;
    v2 = 0;
LABEL_179:
    v146 = v2;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v155 = (id)gLogObj;
    if (mode > 5)
      v156 = "unknown-mode";
    else
      v156 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v212 = "nw_endpoint_flow_setup_channel";
    v213 = 2082;
    v214 = (char *)v156;
    v215 = 2082;
    v216 = "flow";
    v157 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v227) = 16;
    LOBYTE(v210) = 0;
    if (__nwlog_fault(v157, &v227, &v210))
    {
      if (v227 == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v158 = (id)gLogObj;
        v159 = v227;
        if (os_log_type_enabled(v158, (os_log_type_t)v227))
        {
          if (mode > 5)
            v160 = "unknown-mode";
          else
            v160 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v160;
          v215 = 2082;
          v216 = "flow";
          _os_log_impl(&dword_182FBE000, v158, v159, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if ((_BYTE)v210)
      {
        v161 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v158 = (id)gLogObj;
        v162 = v227;
        v163 = os_log_type_enabled(v158, (os_log_type_t)v227);
        if (v161)
        {
          if (v163)
          {
            if (mode > 5)
              v164 = "unknown-mode";
            else
              v164 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446978;
            v212 = "nw_endpoint_flow_setup_channel";
            v213 = 2082;
            v214 = (char *)v164;
            v215 = 2082;
            v216 = "flow";
            v217 = 2082;
            v218 = v161;
            _os_log_impl(&dword_182FBE000, v158, v162, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v161);
          if (!v157)
            goto LABEL_213;
          goto LABEL_212;
        }
        if (v163)
        {
          if (mode > 5)
            v167 = "unknown-mode";
          else
            v167 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v167;
          v215 = 2082;
          v216 = "flow";
          _os_log_impl(&dword_182FBE000, v158, v162, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v158 = (id)gLogObj;
        v165 = v227;
        if (os_log_type_enabled(v158, (os_log_type_t)v227))
        {
          if (mode > 5)
            v166 = "unknown-mode";
          else
            v166 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v166;
          v215 = 2082;
          v216 = "flow";
          _os_log_impl(&dword_182FBE000, v158, v165, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
    if (!v157)
    {
LABEL_213:
      v110 = 0;
      goto LABEL_214;
    }
LABEL_212:
    free(v157);
    goto LABEL_213;
  }
  mode = v1->mode;

  if (mode != 2)
    goto LABEL_179;
  v206 = v2;
  v4 = nw_endpoint_handler_copy_flow(v2);
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_79826);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  if ((*((_BYTE *)v4 + 33) & 0x40) == 0)
  {
    v5 = v2;
    v6 = *((_BYTE *)v5 + 268);

    if ((v6 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v7 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v8 = v5;

        v9 = v8;
        v10 = *((_BYTE *)v5 + 268);

        if ((v10 & 1) != 0)
          v11 = "dry-run ";
        else
          v11 = "";
        v204 = v4;
        v12 = nw_endpoint_handler_copy_endpoint(v9);
        logging_description = nw_endpoint_get_logging_description(v12);
        id_str = v8->id_str;
        v15 = v9;
        v16 = v15;
        v17 = v15[30];
        if (v17 > 5)
          v18 = "unknown-state";
        else
          v18 = off_1E149FC48[v17];

        v52 = v16;
        v53 = v52;
        v54 = "path";
        switch(v206->mode)
        {
          case 0:
            break;
          case 1:
            v54 = "resolver";
            break;
          case 2:
            v54 = nw_endpoint_flow_mode_string(v52[31]);
            break;
          case 3:
            v54 = "proxy";
            break;
          case 4:
            v54 = "fallback";
            break;
          case 5:
            v54 = "transform";
            break;
          default:
            v54 = "unknown-mode";
            break;
        }

        v108 = v53;
        os_unfair_lock_lock((os_unfair_lock_t)v108 + 28);
        v109 = v108[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v108 + 28);

        *(_DWORD *)buf = 136447746;
        v212 = "nw_endpoint_flow_setup_channel";
        v213 = 2082;
        v214 = id_str;
        v215 = 2082;
        v216 = v11;
        v217 = 2082;
        v218 = (void *)logging_description;
        v219 = 2082;
        v220 = v18;
        v221 = 2082;
        v222 = v54;
        v223 = 2114;
        v224 = v109;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] is not a channel flow", buf, 0x48u);

        v4 = v204;
      }

    }
    v110 = 0;
    goto LABEL_157;
  }
  v227 = 0uLL;
  v209 = 0;
  v19 = v2;
  p_lock = &v19->lock;
  os_unfair_lock_lock(&v19->lock);
  v21 = v19->current_path;
  os_unfair_lock_unlock(&v19->lock);

  v22 = (NWConcrete_nw_path_flow_registration *)*((_QWORD *)v4 + 104);
  v205 = v21;
  if (!v22)
  {
    if (*((_QWORD *)v4 + 113))
      goto LABEL_31;
    v19->event = (nw_endpoint_handler_event_s)65539;
    nw_endpoint_handler_report(v19, 0, &v19->event.domain, 0);
    v208 = 0;
    v210 = 0uLL;
    nw_path_get_nexus_agent_uuid_check_assertion(v21, &v210, &v208);
    if (v208
      && !nw_path_agent_action(v21, (const unsigned __int8 *)&v210, 131)
      && (nw_endpoint_handler_get_logging_disabled(v19) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v65 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_endpoint_handler_get_id_string(v19);
        v67 = nw_endpoint_handler_dry_run_string(v19);
        v68 = nw_endpoint_handler_copy_endpoint(v19);
        v69 = nw_endpoint_get_logging_description(v68);
        v70 = nw_endpoint_handler_state_string(v19);
        v71 = nw_endpoint_handler_mode_string(v19);
        v72 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
        *(_DWORD *)buf = 136447746;
        v212 = "nw_endpoint_flow_setup_channel";
        v213 = 2082;
        v214 = (char *)id_string;
        v215 = 2082;
        v216 = v67;
        v217 = 2082;
        v218 = (void *)v69;
        v219 = 2082;
        v220 = v70;
        v221 = 2082;
        v222 = v71;
        v223 = 2114;
        v224 = v72;
        _os_log_impl(&dword_182FBE000, v65, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to assert nexus agent", buf, 0x48u);

      }
    }
    v73 = v19;
    v74 = (void **)v73[7];

    v207 = 0;
    if (v74)
    {
      v75 = nw_path_evaluator_create_flow_inner(v74[3], 1, 1, 0, 0, &v210, 0, 0, &v207);
      v76 = (void *)*((_QWORD *)v4 + 104);
      *((_QWORD *)v4 + 104) = v75;

    }
    if (!*((_QWORD *)v4 + 104))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v73) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v111 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
        {
          v112 = nw_endpoint_handler_get_id_string(v73);
          v113 = nw_endpoint_handler_dry_run_string(v73);
          v203 = nw_endpoint_handler_copy_endpoint(v73);
          v114 = nw_endpoint_get_logging_description(v203);
          v115 = nw_endpoint_handler_state_string(v73);
          v116 = nw_endpoint_handler_mode_string(v73);
          v117 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v73);
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v112;
          v215 = 2082;
          v216 = v113;
          v217 = 2082;
          v218 = (void *)v114;
          v219 = 2082;
          v220 = v115;
          v221 = 2082;
          v222 = v116;
          v223 = 2114;
          v224 = v117;
          _os_log_impl(&dword_182FBE000, v111, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to request add nexus flow", buf, 0x48u);

        }
      }
      if (v207 && !*((_QWORD *)v4 + 109))
      {
        posix_error = nw_error_create_posix_error(v207);
        v119 = (void *)*((_QWORD *)v4 + 109);
        *((_QWORD *)v4 + 109) = posix_error;

      }
      nw_endpoint_flow_failed_with_error(v73, 1, 0);

      goto LABEL_113;
    }
    if (nw_endpoint_handler_get_minimize_logging(v73))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v73) & 1) != 0)
        goto LABEL_71;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v79 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
      {
        v183 = nw_endpoint_handler_get_id_string(v73);
        v184 = nw_endpoint_handler_dry_run_string(v73);
        v185 = nw_endpoint_handler_copy_endpoint(v73);
        v186 = nw_endpoint_get_logging_description(v185);
        v187 = nw_endpoint_handler_state_string(v73);
        v188 = nw_endpoint_handler_mode_string(v73);
        v189 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v73);
        *(_DWORD *)buf = 136447746;
        v212 = "nw_endpoint_flow_setup_channel";
        v213 = 2082;
        v214 = (char *)v183;
        v215 = 2082;
        v216 = v184;
        v217 = 2082;
        v218 = (void *)v186;
        v219 = 2082;
        v220 = v187;
        v221 = 2082;
        v222 = v188;
        v223 = 2114;
        v224 = v189;
        _os_log_impl(&dword_182FBE000, v79, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] requested nexus flow", buf, 0x48u);

      }
    }
    else
    {
      v77 = v73;
      v78 = (*((_BYTE *)v77 + 268) & 0x20) == 0;

      if (!v78)
      {
LABEL_71:
        nw_association_force_update(v74, *((void **)v4 + 104));

        goto LABEL_124;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v79 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v79, OS_LOG_TYPE_INFO))
      {
        v80 = nw_endpoint_handler_get_id_string(v77);
        v81 = nw_endpoint_handler_dry_run_string(v77);
        v82 = nw_endpoint_handler_copy_endpoint(v77);
        v83 = v74;
        v84 = nw_endpoint_get_logging_description(v82);
        v85 = nw_endpoint_handler_state_string(v77);
        v86 = nw_endpoint_handler_mode_string(v77);
        v87 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v77);
        *(_DWORD *)buf = 136447746;
        v212 = "nw_endpoint_flow_setup_channel";
        v213 = 2082;
        v214 = (char *)v80;
        v215 = 2082;
        v216 = v81;
        v217 = 2082;
        v218 = (void *)v84;
        v219 = 2082;
        v220 = v85;
        v221 = 2082;
        v222 = v86;
        v223 = 2114;
        v224 = v87;
        _os_log_impl(&dword_182FBE000, v79, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] requested nexus flow", buf, 0x48u);

        v74 = v83;
      }
    }

    goto LABEL_71;
  }
  nexus_instance = nw_path_flow_registration_get_nexus_instance(v21, v22, &v227, &v209);
  can_use_nexus = nw_path_flow_registration_can_use_nexus(v21, *((NWConcrete_nw_path_flow_registration **)v4 + 104));
  if (*((_QWORD *)v4 + 113))
  {
    if ((nexus_instance & can_use_nexus & 1) != 0)
    {
      v25 = v19;
      v26 = (*((_BYTE *)v25 + 268) & 0x20) == 0;

      if (v26)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v27 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          v28 = v25;

          v29 = v28;
          v30 = (*((_BYTE *)v25 + 268) & 1) == 0;

          if (v30)
            v31 = "";
          else
            v31 = "dry-run ";
          v32 = nw_endpoint_handler_copy_endpoint(v29);
          v33 = nw_endpoint_get_logging_description(v32);
          v199 = v31;
          v34 = v29;
          v35 = v34;
          v36 = v34[30];
          v37 = v33;
          if (v36 > 5)
            v38 = "unknown-state";
          else
            v38 = off_1E149FC48[v36];
          v197 = v38;

          v120 = v35;
          v121 = v120;
          v122 = "path";
          switch(v206->mode)
          {
            case 0:
              break;
            case 1:
              v122 = "resolver";
              break;
            case 2:
              v122 = nw_endpoint_flow_mode_string(v120[31]);
              break;
            case 3:
              v122 = "proxy";
              break;
            case 4:
              v122 = "fallback";
              break;
            case 5:
              v122 = "transform";
              break;
            default:
              v122 = "unknown-mode";
              break;
          }

          v144 = v121;
          os_unfair_lock_lock(p_lock);
          v145 = v19->current_path;
          os_unfair_lock_unlock(p_lock);

          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = v28->id_str;
          v215 = 2082;
          v216 = v199;
          v217 = 2082;
          v218 = (void *)v37;
          v219 = 2082;
          v220 = v197;
          v221 = 2082;
          v222 = v122;
          v223 = 2114;
          v224 = v145;
          _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already set up", buf, 0x48u);

        }
      }
      v21 = v205;
      nw_endpoint_flow_setup_protocols(v25, 0, 0, (*((unsigned __int8 *)v4 + 32) >> 4) & 1, 0);
      v142 = &unk_1ECD85000;
      v143 = &unk_1ECD85000;
      goto LABEL_151;
    }
    if (nexus_instance)
    {
      if (nw_endpoint_handler_get_minimize_logging(v19))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v19) & 1) != 0)
        {
LABEL_139:
          v21 = v205;
          v142 = (_BYTE *)&unk_1ECD85000;
          v143 = (_QWORD *)&unk_1ECD85000;
          if ((nw_path_allows_multipath(v205) & 1) == 0 && (*((_BYTE *)v4 + 32) & 1) != 0
            || (*((_BYTE *)v4 + 33) & 8) == 0)
          {
            nw_endpoint_flow_failed_with_error(v19, 1, 0);
          }
LABEL_151:
          if (v143[25] == -1)
          {
            if (v142[144])
              goto LABEL_153;
          }
          else
          {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_79826);
            if (v142[144])
            {
LABEL_153:
              if (kdebug_is_enabled())
                kdebug_trace();
            }
          }
          v110 = 0;
          goto LABEL_156;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v57 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
        {
          v176 = nw_endpoint_handler_get_id_string(v19);
          v177 = nw_endpoint_handler_dry_run_string(v19);
          v178 = nw_endpoint_handler_copy_endpoint(v19);
          v179 = nw_endpoint_get_logging_description(v178);
          v180 = nw_endpoint_handler_state_string(v19);
          v181 = nw_endpoint_handler_mode_string(v19);
          v182 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v176;
          v215 = 2082;
          v216 = v177;
          v217 = 2082;
          v218 = (void *)v179;
          v219 = 2082;
          v220 = v180;
          v221 = 2082;
          v222 = v181;
          v223 = 2114;
          v224 = v182;
          _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nexus no longer supported", buf, 0x48u);

        }
      }
      else
      {
        v55 = v19;
        v56 = (*((_BYTE *)v55 + 268) & 0x20) == 0;

        if (!v56)
          goto LABEL_139;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v57 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
        {
          v58 = nw_endpoint_handler_get_id_string(v55);
          v59 = nw_endpoint_handler_dry_run_string(v55);
          v60 = nw_endpoint_handler_copy_endpoint(v55);
          v61 = nw_endpoint_get_logging_description(v60);
          v62 = nw_endpoint_handler_state_string(v55);
          v63 = nw_endpoint_handler_mode_string(v55);
          v64 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v55);
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v58;
          v215 = 2082;
          v216 = v59;
          v217 = 2082;
          v218 = (void *)v61;
          v219 = 2082;
          v220 = v62;
          v221 = 2082;
          v222 = v63;
          v223 = 2114;
          v224 = v64;
          _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nexus no longer supported", buf, 0x48u);

        }
      }
LABEL_138:

      goto LABEL_139;
    }
    if (v209)
    {
      v57 = nw_error_create_posix_error(v209);
      if (v57)
      {
        v97 = v19;
        v98 = (*((_BYTE *)v97 + 268) & 0x20) == 0;

        if (v98)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v99 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
          {
            v100 = nw_endpoint_handler_get_id_string(v97);
            v101 = nw_endpoint_handler_dry_run_string(v97);
            v201 = nw_endpoint_handler_copy_endpoint(v97);
            v102 = nw_endpoint_get_logging_description(v201);
            v103 = nw_endpoint_handler_state_string(v97);
            v104 = nw_endpoint_handler_mode_string(v97);
            v105 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v97);
            *(_DWORD *)buf = 136448002;
            v212 = "nw_endpoint_flow_setup_channel";
            v213 = 2082;
            v214 = (char *)v100;
            v215 = 2082;
            v216 = v101;
            v217 = 2082;
            v218 = (void *)v102;
            v219 = 2082;
            v220 = v103;
            v221 = 2082;
            v222 = v104;
            v223 = 2114;
            v224 = v105;
            v225 = 2112;
            v226 = v57;
            _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] lost nexus assignment, error %@", buf, 0x52u);

          }
        }
        if (*((_QWORD *)v4 + 109))
          goto LABEL_138;
        v57 = v57;
        v41 = *((_QWORD *)v4 + 109);
        *((_QWORD *)v4 + 109) = v57;
        goto LABEL_137;
      }
    }
LABEL_31:
    if (nw_endpoint_handler_get_minimize_logging(v19))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v19) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v41 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          v169 = nw_endpoint_handler_get_id_string(v19);
          v170 = nw_endpoint_handler_dry_run_string(v19);
          v171 = nw_endpoint_handler_copy_endpoint(v19);
          v172 = nw_endpoint_get_logging_description(v171);
          v173 = nw_endpoint_handler_state_string(v19);
          v174 = nw_endpoint_handler_mode_string(v19);
          v175 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = (char *)v169;
          v215 = 2082;
          v216 = v170;
          v217 = 2082;
          v218 = (void *)v172;
          v219 = 2082;
          v220 = v173;
          v221 = 2082;
          v222 = v174;
          v223 = 2114;
          v224 = v175;
          _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] lost nexus assignment", buf, 0x48u);

        }
        goto LABEL_136;
      }
    }
    else
    {
      v39 = v19;
      v40 = (*((_BYTE *)v39 + 268) & 0x20) == 0;

      if (v40)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v41 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
        {
          v42 = v39;

          v43 = v42;
          v44 = (*((_BYTE *)v39 + 268) & 1) == 0;

          if (v44)
            v45 = "";
          else
            v45 = "dry-run ";
          v46 = nw_endpoint_handler_copy_endpoint(v43);
          v47 = nw_endpoint_get_logging_description(v46);
          v48 = v43;
          v49 = v48;
          v50 = v48[30];
          if (v50 > 5)
            v51 = "unknown-state";
          else
            v51 = off_1E149FC48[v50];
          v202 = v51;

          v106 = v49;
          v107 = "path";
          switch(v206->mode)
          {
            case 0:
              break;
            case 1:
              v107 = "resolver";
              break;
            case 2:
              v107 = nw_endpoint_flow_mode_string(v106[31]);
              break;
            case 3:
              v107 = "proxy";
              break;
            case 4:
              v107 = "fallback";
              break;
            case 5:
              v107 = "transform";
              break;
            default:
              v107 = "unknown-mode";
              break;
          }
          v198 = v107;

          v133 = v42;
          v134 = v41;
          v135 = v46;
          v136 = v45;
          v137 = v47;
          v138 = v106;
          os_unfair_lock_lock(p_lock);
          v139 = v19->current_path;
          os_unfair_lock_unlock(p_lock);

          v140 = v137;
          v141 = v135;
          v41 = v134;
          *(_DWORD *)buf = 136447746;
          v212 = "nw_endpoint_flow_setup_channel";
          v213 = 2082;
          v214 = v133->id_str;
          v215 = 2082;
          v216 = v136;
          v217 = 2082;
          v218 = (void *)v140;
          v219 = 2082;
          v220 = v202;
          v221 = 2082;
          v222 = v198;
          v223 = 2114;
          v224 = v139;
          _os_log_impl(&dword_182FBE000, v134, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] lost nexus assignment", buf, 0x48u);

        }
LABEL_136:
        v57 = 0;
LABEL_137:

        goto LABEL_138;
      }
    }
    v57 = 0;
    goto LABEL_138;
  }
  if (nexus_instance)
  {
    v19->event = (nw_endpoint_handler_event_s)131075;
    nw_endpoint_handler_report(v19, 0, &v19->event.domain, 0);
    nw_endpoint_flow_setup_protocols(v19, 0, 0, (*((unsigned __int8 *)v4 + 32) >> 4) & 1, 0);
    goto LABEL_125;
  }
  if (!v209)
  {
    minimize_logging = nw_endpoint_handler_get_minimize_logging(v19);
    logging_disabled = nw_endpoint_handler_get_logging_disabled(v19);
    if (minimize_logging)
    {
      if ((logging_disabled & 1) != 0)
      {
LABEL_125:
        if (_nw_signposts_once == -1)
        {
          if (_nw_signposts_enabled)
            goto LABEL_127;
        }
        else
        {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_79826);
          if (_nw_signposts_enabled)
          {
LABEL_127:
            if (kdebug_is_enabled())
              kdebug_trace();
          }
        }
        v110 = 1;
        goto LABEL_156;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v125 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
      {
        v190 = nw_endpoint_handler_get_id_string(v19);
        v191 = nw_endpoint_handler_dry_run_string(v19);
        v192 = nw_endpoint_handler_copy_endpoint(v19);
        v193 = nw_endpoint_get_logging_description(v192);
        v194 = nw_endpoint_handler_state_string(v19);
        v195 = nw_endpoint_handler_mode_string(v19);
        v196 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
        *(_DWORD *)buf = 136447746;
        v212 = "nw_endpoint_flow_setup_channel";
        v213 = 2082;
        v214 = (char *)v190;
        v215 = 2082;
        v216 = v191;
        v217 = 2082;
        v218 = (void *)v193;
        v219 = 2082;
        v220 = v194;
        v221 = 2082;
        v222 = v195;
        v223 = 2114;
        v224 = v196;
        _os_log_impl(&dword_182FBE000, v125, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already requested nexus, wait", buf, 0x48u);

      }
    }
    else
    {
      if ((logging_disabled & 1) != 0)
        goto LABEL_125;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v125 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
      {
        v126 = nw_endpoint_handler_get_id_string(v19);
        v127 = nw_endpoint_handler_dry_run_string(v19);
        v128 = nw_endpoint_handler_copy_endpoint(v19);
        v129 = nw_endpoint_get_logging_description(v128);
        v130 = nw_endpoint_handler_state_string(v19);
        v131 = nw_endpoint_handler_mode_string(v19);
        v132 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
        *(_DWORD *)buf = 136447746;
        v212 = "nw_endpoint_flow_setup_channel";
        v213 = 2082;
        v214 = (char *)v126;
        v215 = 2082;
        v216 = v127;
        v217 = 2082;
        v218 = (void *)v129;
        v219 = 2082;
        v220 = v130;
        v221 = 2082;
        v222 = v131;
        v223 = 2114;
        v224 = v132;
        _os_log_impl(&dword_182FBE000, v125, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already requested nexus, wait", buf, 0x48u);

      }
    }

LABEL_124:
    v21 = v205;
    goto LABEL_125;
  }
  v88 = nw_error_create_posix_error(v209);
  if ((nw_endpoint_handler_get_logging_disabled(v19) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v89 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      v200 = v88;
      v90 = nw_endpoint_handler_get_id_string(v19);
      v91 = nw_endpoint_handler_dry_run_string(v19);
      v92 = nw_endpoint_handler_copy_endpoint(v19);
      v93 = nw_endpoint_get_logging_description(v92);
      v94 = nw_endpoint_handler_state_string(v19);
      v95 = nw_endpoint_handler_mode_string(v19);
      v96 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v19);
      *(_DWORD *)buf = 136448002;
      v212 = "nw_endpoint_flow_setup_channel";
      v213 = 2082;
      v214 = (char *)v90;
      v215 = 2082;
      v216 = v91;
      v217 = 2082;
      v218 = (void *)v93;
      v219 = 2082;
      v220 = v94;
      v221 = 2082;
      v222 = v95;
      v223 = 2114;
      v224 = v96;
      v225 = 2112;
      v88 = v200;
      v226 = v200;
      _os_log_impl(&dword_182FBE000, v89, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nexus assignment error %@", buf, 0x52u);

    }
  }
  if (!*((_QWORD *)v4 + 109))
    objc_storeStrong((id *)v4 + 109, v88);
  nw_endpoint_flow_failed_with_error(v19, 1, 0);

LABEL_113:
  v110 = 0;
  v21 = v205;
LABEL_156:

LABEL_157:
  v146 = v206;
LABEL_214:

  return v110;
}

void sub_1831A17CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_registration_can_use_nexus(NWConcrete_nw_path *a1, NWConcrete_nw_path_flow_registration *a2)
{
  id v2;
  void *v3;
  _QWORD *v4;
  void *v5;
  _DWORD *data;
  _DWORD *v7;
  BOOL v8;
  uint64_t v9;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  size_t length;

  v2 = nw_path_copy_flow_for_registration(a1, a2);
  v3 = v2;
  if (!v2)
  {
    v9 = 0;
    goto LABEL_15;
  }
  v4 = v2;
  v5 = (void *)v4[3];
  if (v5
    && (length = 0, (data = xpc_dictionary_get_data(v5, "data", &length)) != 0)
    && length >= 0xD8
    && (v7 = data, length == data[53] + 216)
    && ((data[52] & 0xE080) != 0 ? (v8 = (data[52] & 0x13) == 1) : (v8 = 1), !v8))
  {

    if (v7[53] >= 0xCCu)
    {
      v11 = v7[52];
      v12 = (v11 >> 7) & 1;
      v13 = (v11 >> 14) & 1;
      if ((*((_BYTE *)v4 + 186) & 8) != 0)
        v9 = v13;
      else
        v9 = v12;
      goto LABEL_13;
    }
  }
  else
  {

  }
  v9 = 0;
LABEL_13:

LABEL_15:
  return v9;
}

uint64_t nw_path_get_nexus_agent_uuid_check_assertion(void *a1, _OWORD *a2, BOOL *a3)
{
  NWConcrete_nw_path *v5;
  NWConcrete_nw_path *v6;
  uint64_t nexus_agent;
  _OWORD *v8;
  uint64_t v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_path_get_nexus_agent_uuid_check_assertion";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_path_get_nexus_agent_uuid_check_assertion";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_path_get_nexus_agent_uuid_check_assertion";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_path_get_nexus_agent_uuid_check_assertion";
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_path_get_nexus_agent_uuid_check_assertion";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v12)
      free(v12);
LABEL_6:
    v9 = 0;
    goto LABEL_10;
  }
  if (nw_path_uses_nexus_internal(v5, 0))
  {
    nexus_agent = nw_path_get_nexus_agent(v6, 0);
    v8 = (_OWORD *)nexus_agent;
    if (a3)
      *a3 = (*(_DWORD *)(nexus_agent + 208) & 2) == 0;
    if (!uuid_is_null((const unsigned __int8 *)nexus_agent))
    {
      *a2 = *v8;
      v9 = 1;
      goto LABEL_10;
    }
    goto LABEL_6;
  }
  v9 = 0;
  if (a3)
    *a3 = 0;
LABEL_10:

  return v9;
}

void sub_1831A1D88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1831A2444(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_resolver_cancel(void *a1)
{
  _BYTE *v1;
  _BYTE *v2;
  NSObject *v3;
  const char *v4;
  NSObject *v5;
  uint32_t v6;
  int v7;
  void *v8;
  const void *v9;
  void *v10;
  void *v11;
  NSObject *v12;
  void *v13;
  void *v14;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  _BYTE v29[18];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[346] & 0x20) != 0)
    {
LABEL_12:
      os_unfair_lock_lock((os_unfair_lock_t)v2 + 3);
      nw_resolver_cancel_delayed_reporting_timer((NWConcrete_nw_resolver *)v2);
      if (!*((_QWORD *)v2 + 16))
        nw_resolver_cancel_query_locked((NWConcrete_nw_resolver *)v2, 0);
      v8 = (void *)*((_QWORD *)v2 + 12);
      *((_QWORD *)v2 + 12) = 0;

      v9 = (const void *)*((_QWORD *)v2 + 13);
      if (v9)
      {
        v10 = _Block_copy(v9);
        v11 = (void *)*((_QWORD *)v2 + 13);
        *((_QWORD *)v2 + 13) = 0;

        v12 = *((_QWORD *)v2 + 14);
        if (v12)
          dispatch_async(v12, v10);
        else
          nw_queue_context_async(*((void **)v2 + 4), v10);

      }
      v13 = (void *)*((_QWORD *)v2 + 14);
      *((_QWORD *)v2 + 14) = 0;

      v14 = (void *)*((_QWORD *)v2 + 27);
      *((_QWORD *)v2 + 27) = 0;

      os_unfair_lock_unlock((os_unfair_lock_t)v2 + 3);
      goto LABEL_20;
    }
    if (v1[256])
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v3 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        goto LABEL_11;
      *(_DWORD *)buf = 136446722;
      v27 = "nw_resolver_cancel";
      v28 = 2082;
      *(_QWORD *)v29 = v2 + 256;
      *(_WORD *)&v29[8] = 2048;
      *(_QWORD *)&v29[10] = v2;
      v4 = "%{public}s [C%{public}s] %p";
      v5 = v3;
      v6 = 32;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = (id)gLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
LABEL_11:

        goto LABEL_12;
      }
      v7 = *((_DWORD *)v2 + 85);
      *(_DWORD *)buf = 136446722;
      v27 = "nw_resolver_cancel";
      v28 = 1024;
      *(_DWORD *)v29 = v7;
      *(_WORD *)&v29[4] = 2048;
      *(_QWORD *)&v29[6] = v2;
      v4 = "%{public}s [R%u] %p";
      v5 = v3;
      v6 = 28;
    }
    _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, v4, buf, v6);
    goto LABEL_11;
  }
  __nwlog_obj();
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_resolver_cancel";
  v17 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v17, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_resolver_cancel";
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_resolver_cancel";
          v28 = 2082;
          *(_QWORD *)v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v18, v21, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_37;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_resolver_cancel";
        _os_log_impl(&dword_182FBE000, v18, v21, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_resolver_cancel";
        _os_log_impl(&dword_182FBE000, v18, v23, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_37:
  if (v17)
    free(v17);
LABEL_20:

  return v2 != 0;
}

void sub_1831A28B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1831A3580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, objc_super a13)
{
  a13.super_class = (Class)NWConcrete_nw_resolver;
  -[_Unwind_Exception dealloc](&a13, sel_dealloc);
  _Unwind_Resume(a1);
}

char *tcp_connection_create(const char *a1, unsigned int a2, void *a3)
{
  id v5;
  void *v6;
  _BOOL8 host_with_numeric_port;
  void *v8;
  char *v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  void *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = v5;
  if (a1)
  {
    if (v5)
    {
      host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(a1, __rev16(a2));
      v8 = (void *)host_with_numeric_port;
      if (host_with_numeric_port)
        v9 = tcp_connection_create_with_endpoint_and_parameters((void *)host_with_numeric_port, 0, v6);
      else
        v9 = 0;

      goto LABEL_7;
    }
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "tcp_connection_create";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v12, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          v15 = "%{public}s called with null queue";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      if (!v21)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          v15 = "%{public}s called with null queue, backtrace limit exceeded";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v20 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          v15 = "%{public}s called with null queue, no backtrace";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      if (!v20)
        goto LABEL_25;
      *(_DWORD *)buf = 136446466;
      v24 = "tcp_connection_create";
      v25 = 2082;
      v26 = backtrace_string;
      v19 = "%{public}s called with null queue, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_182FBE000, v13, v14, v19, buf, 0x16u);
LABEL_25:

      free(backtrace_string);
    }
  }
  else
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "tcp_connection_create";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v12, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          v15 = "%{public}s called with null hostname";
LABEL_34:
          _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
        }
LABEL_35:

        goto LABEL_36;
      }
      if (!v21)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          v15 = "%{public}s called with null hostname, backtrace limit exceeded";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v18 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "tcp_connection_create";
          v15 = "%{public}s called with null hostname, no backtrace";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      if (!v18)
        goto LABEL_25;
      *(_DWORD *)buf = 136446466;
      v24 = "tcp_connection_create";
      v25 = 2082;
      v26 = backtrace_string;
      v19 = "%{public}s called with null hostname, dumping backtrace:%{public}s";
      goto LABEL_24;
    }
  }
LABEL_36:
  if (v12)
    free(v12);
  v9 = 0;
LABEL_7:

  return v9;
}

char *tcp_connection_create_with_endpoint_and_parameters(void *a1, void *a2, void *a3)
{
  id v6;
  id v7;
  id v8;
  char *v9;
  char *v10;
  char v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  unsigned int v19;
  id v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  char *v27;
  char *v28;
  NSObject *v29;
  char *v30;
  char *v31;
  os_log_type_t v32;
  void *v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  void *v38;
  os_log_type_t v39;
  char *v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  os_log_type_t v46;
  char v47;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  char *v52;
  __int16 v53;
  const char *logging_description;
  __int16 v55;
  const char *bonjour_service_type;
  __int16 v57;
  const char *bonjour_service_domain;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v6 = a1;
  v7 = a2;
  v8 = a3;
  nw_allow_use_of_dispatch_internal();
  if (v6)
  {
    if (v8)
    {
      v9 = -[NWConcrete_tcp_connection initWithParameters:]((char *)[NWConcrete_tcp_connection alloc], v7);
      v10 = v9;
      if (v9)
      {
        objc_storeStrong((id *)v9 + 7, a3);
        *((_QWORD *)v10 + 12) = nw_endpoint_handler_get_next_top_id();
        objc_storeStrong((id *)v10 + 5, a1);
        if (nw_parameters_get_allow_socket_access(*((void **)v10 + 6)))
          v11 = 0x80;
        else
          v11 = 0;
        v10[158] = v11 & 0x80 | v10[158] & 0x7F;
        v12 = v6;
        v13 = -[NSObject type](v12, "type");

        switch(v13)
        {
          case 1:
            v10[157] = 3;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = (id)gLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              v27 = (char *)*((_QWORD *)v10 + 12);
              *(_DWORD *)buf = 136446722;
              v50 = "tcp_connection_create_with_endpoint_and_parameters";
              v51 = 2048;
              v52 = v27;
              v53 = 2082;
              logging_description = nw_endpoint_get_logging_description(v12);
              _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %llu %{public}s", buf, 0x20u);
            }
            break;
          case 3:
            v10[157] = 1;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = (id)gLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              v28 = (char *)*((_QWORD *)v10 + 12);
              *(_DWORD *)buf = 136447234;
              v50 = "tcp_connection_create_with_endpoint_and_parameters";
              v51 = 2048;
              v52 = v28;
              v53 = 2082;
              logging_description = nw_endpoint_get_bonjour_service_name(v12);
              v55 = 2082;
              bonjour_service_type = nw_endpoint_get_bonjour_service_type(v12);
              v57 = 2082;
              bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(v12);
              _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %llu %{public}s %{public}s %{public}s", buf, 0x34u);
            }
            break;
          case 2:
            v10[157] = 2;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = (id)gLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              v15 = (char *)*((_QWORD *)v10 + 12);
              v16 = v12;
              v17 = -[NSObject hostname](v16, "hostname");

              v18 = v16;
              v19 = __rev16(-[NSObject port](v18, "port"));

              *(_DWORD *)buf = 136446978;
              v50 = "tcp_connection_create_with_endpoint_and_parameters";
              v51 = 2048;
              v52 = v15;
              v53 = 2082;
              logging_description = (const char *)v17;
              v55 = 1024;
              LODWORD(bonjour_service_type) = v19;
              _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %llu %{public}s %d", buf, 0x26u);
            }
            break;
          default:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v29 = (id)gLogObj;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
            {
              v30 = (char *)*((_QWORD *)v10 + 12);
              *(_DWORD *)buf = 136446722;
              v50 = "tcp_connection_create_with_endpoint_and_parameters";
              v51 = 2048;
              v52 = v30;
              v53 = 1024;
              LODWORD(logging_description) = v13;
              _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %llu Custom endpoint type: %u", buf, 0x1Cu);
            }

            v10[157] = 0;
            goto LABEL_33;
        }

LABEL_33:
        v31 = v10;
LABEL_42:

        goto LABEL_43;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v50 = "tcp_connection_create_with_endpoint_and_parameters";
      v21 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v47 = 0;
      if (__nwlog_fault(v21, &type, &v47))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v50 = "tcp_connection_create_with_endpoint_and_parameters";
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s [tcp_connection initWithParameters:] failed", buf, 0xCu);
          }
        }
        else if (v47)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v25 = type;
          v26 = os_log_type_enabled(v22, type);
          if (backtrace_string)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446466;
              v50 = "tcp_connection_create_with_endpoint_and_parameters";
              v51 = 2082;
              v52 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s [tcp_connection initWithParameters:] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v21)
              goto LABEL_42;
            goto LABEL_41;
          }
          if (v26)
          {
            *(_DWORD *)buf = 136446210;
            v50 = "tcp_connection_create_with_endpoint_and_parameters";
            _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s [tcp_connection initWithParameters:] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v32 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v50 = "tcp_connection_create_with_endpoint_and_parameters";
            _os_log_impl(&dword_182FBE000, v22, v32, "%{public}s [tcp_connection initWithParameters:] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v21)
        goto LABEL_42;
LABEL_41:
      free(v21);
      goto LABEL_42;
    }
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "tcp_connection_create_with_endpoint_and_parameters";
    v35 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (__nwlog_fault(v35, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v39 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_182FBE000, v36, v39, "%{public}s called with null queue", buf, 0xCu);
        }
LABEL_75:

        goto LABEL_76;
      }
      if (!v47)
      {
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_182FBE000, v36, v46, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_75;
      }
      v40 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      v44 = os_log_type_enabled(v36, type);
      if (!v40)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_182FBE000, v36, v43, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
        goto LABEL_75;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        v50 = "tcp_connection_create_with_endpoint_and_parameters";
        v51 = 2082;
        v52 = v40;
        _os_log_impl(&dword_182FBE000, v36, v43, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_63;
    }
  }
  else
  {
    __nwlog_obj();
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "tcp_connection_create_with_endpoint_and_parameters";
    v35 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (__nwlog_fault(v35, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_75;
      }
      if (!v47)
      {
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v45 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_182FBE000, v36, v45, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_75;
      }
      v40 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v41 = type;
      v42 = os_log_type_enabled(v36, type);
      if (!v40)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v50 = "tcp_connection_create_with_endpoint_and_parameters";
          _os_log_impl(&dword_182FBE000, v36, v41, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_75;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v50 = "tcp_connection_create_with_endpoint_and_parameters";
        v51 = 2082;
        v52 = v40;
        _os_log_impl(&dword_182FBE000, v36, v41, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_63:

      free(v40);
    }
  }
LABEL_76:
  if (v35)
    free(v35);
  v10 = 0;
LABEL_43:

  return v10;
}

void sub_1831A4488(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1831A4CFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_parameters_set_indefinite(void *a1, int a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = 128;
    if (a2)
      v5 = 192;
    *((_QWORD *)v3 + 12) = v5 | *((_QWORD *)v3 + 12) & 0xFFFFFFFFFFFFFF3FLL;
    goto LABEL_5;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_parameters_set_indefinite";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_indefinite";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_parameters_set_indefinite";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_indefinite";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_indefinite";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v7)
    free(v7);
LABEL_5:

}

NSObject *nw_parameters_create_legacy_tcp_socket(void *a1)
{
  void (**v1)(id, NWConcrete_nw_protocol_options *);
  void (**v2)(id, NWConcrete_nw_protocol_options *);
  nw_parameters_t v3;
  NWConcrete_nw_protocol_options *options;
  NSObject *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  void *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  void *v27;
  os_log_type_t v28;
  char *backtrace_string;
  os_log_type_t v30;
  _BOOL4 v31;
  char *v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  os_log_type_t v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_parameters_create_legacy_tcp_socket";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v24, &type, &v37))
      goto LABEL_87;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null configure_tcp", buf, 0xCu);
      }
    }
    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      v31 = os_log_type_enabled(v25, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_parameters_create_legacy_tcp_socket";
          v41 = 2082;
          v42 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v25, v30, "%{public}s called with null configure_tcp, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v24)
          goto LABEL_89;
        goto LABEL_88;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v25, v30, "%{public}s called with null configure_tcp, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v25, v35, "%{public}s called with null configure_tcp, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_86;
  }
  if (v1 == (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_18950)
  {
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_parameters_create_legacy_tcp_socket";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v24, &type, &v37))
      goto LABEL_87;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable))", buf, 0xCu);
      }
    }
    else if (v37)
    {
      v32 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      v34 = os_log_type_enabled(v25, type);
      if (v32)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_parameters_create_legacy_tcp_socket";
          v41 = 2082;
          v42 = v32;
          _os_log_impl(&dword_182FBE000, v25, v33, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v32);
LABEL_87:
        if (!v24)
        {
LABEL_89:
          v5 = 0;
          goto LABEL_53;
        }
LABEL_88:
        free(v24);
        goto LABEL_89;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v25, v33, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v25, v36, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_86:

    goto LABEL_87;
  }
  v3 = nw_parameters_create();
  if (v3)
  {
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
    options = nw_protocol_create_options((void *)g_tcp_definition);
    if (options)
    {
      if (nw_parameters_add_protocol_stack_member(v3, 3, 0, options))
      {
        if (v2 != (void (**)(id, NWConcrete_nw_protocol_options *))&__block_literal_global_86)
          v2[2](v2, options);
        BYTE4(v3[11].isa) = 2;
        *((_WORD *)v3[13].isa + 50) |= 0x10u;
        v5 = v3;
        goto LABEL_51;
      }
LABEL_50:
      v5 = 0;
LABEL_51:

      goto LABEL_52;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v40 = "nw_parameters_create_legacy_tcp_socket";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault(v11, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_parameters_create_legacy_tcp_socket";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s nw_tcp_create_options failed", buf, 0xCu);
        }
      }
      else if (v37)
      {
        v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v18 = type;
        v19 = os_log_type_enabled(v12, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_parameters_create_legacy_tcp_socket";
            v41 = 2082;
            v42 = v17;
            _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s nw_tcp_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v17);
          if (!v11)
            goto LABEL_50;
          goto LABEL_49;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_parameters_create_legacy_tcp_socket";
          _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s nw_tcp_create_options failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_parameters_create_legacy_tcp_socket";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s nw_tcp_create_options failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v11)
      goto LABEL_50;
LABEL_49:
    free(v11);
    goto LABEL_50;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v40 = "nw_parameters_create_legacy_tcp_socket";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v7, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
    }
    else if (v37)
    {
      v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (v14)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_parameters_create_legacy_tcp_socket";
          v41 = 2082;
          v42 = v14;
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v14);
        if (!v7)
          goto LABEL_41;
        goto LABEL_40;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v20 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_182FBE000, v8, v20, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
  if (v7)
LABEL_40:
    free(v7);
LABEL_41:
  v5 = 0;
LABEL_52:

LABEL_53:
  return v5;
}

void sub_1831A59E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

nw_parameters_t nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t configure_tls, nw_parameters_configure_protocol_block_t configure_tcp)
{
  void (**v3)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *);
  void (**v4)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *);
  void (**v5)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *);
  nw_parameters_t v6;
  void *v7;
  NWConcrete_nw_protocol_options *options;
  NWConcrete_nw_protocol_options *v9;
  NSObject *v10;
  id v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  id v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  os_log_type_t v30;
  const char *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  os_log_type_t v35;
  os_log_type_t v36;
  os_log_type_t v37;
  os_log_type_t v38;
  void *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  void *v44;
  os_log_type_t v45;
  void *v46;
  os_log_type_t v47;
  char *backtrace_string;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  _BOOL4 v52;
  char *v53;
  os_log_type_t v54;
  _BOOL4 v55;
  os_log_type_t v56;
  os_log_type_t v57;
  os_log_type_t v58;
  char v59;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v62;
  __int16 v63;
  char *v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v3 = configure_tls;
  v4 = configure_tcp;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_parameters_create_secure_tcp";
    v41 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59))
      goto LABEL_132;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s called with null configure_tls", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (!v59)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v56, "%{public}s called with null configure_tls, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_131;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v42 = objc_claimAutoreleasedReturnValue();
    v49 = type;
    v50 = os_log_type_enabled(v42, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v49, "%{public}s called with null configure_tls, no backtrace", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      v62 = "nw_parameters_create_secure_tcp";
      v63 = 2082;
      v64 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v42, v49, "%{public}s called with null configure_tls, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_107;
  }
  if (!v4)
  {
    __nwlog_obj();
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_parameters_create_secure_tcp";
    v41 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59))
      goto LABEL_132;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v45, "%{public}s called with null configure_tcp", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (!v59)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v57 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v57, "%{public}s called with null configure_tcp, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_131;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v42 = objc_claimAutoreleasedReturnValue();
    v51 = type;
    v52 = os_log_type_enabled(v42, type);
    if (!backtrace_string)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v51, "%{public}s called with null configure_tcp, no backtrace", buf, 0xCu);
      }
      goto LABEL_131;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      v62 = "nw_parameters_create_secure_tcp";
      v63 = 2082;
      v64 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v42, v51, "%{public}s called with null configure_tcp, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_107:

    free(backtrace_string);
    if (!v41)
      goto LABEL_134;
    goto LABEL_133;
  }
  if (v4 == (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_18950)
  {
    __nwlog_obj();
    v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_parameters_create_secure_tcp";
    v41 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (!__nwlog_fault(v41, &type, &v59))
      goto LABEL_132;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v47, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable))", buf, 0xCu);
      }
    }
    else if (v59)
    {
      v53 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v54 = type;
      v55 = os_log_type_enabled(v42, type);
      if (v53)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          v62 = "nw_parameters_create_secure_tcp";
          v63 = 2082;
          v64 = v53;
          _os_log_impl(&dword_182FBE000, v42, v54, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v53);
LABEL_132:
        if (!v41)
        {
LABEL_134:
          v10 = 0;
          goto LABEL_82;
        }
LABEL_133:
        free(v41);
        goto LABEL_134;
      }
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v54, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v42, v58, "%{public}s called with null (configure_tcp != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_131:

    goto LABEL_132;
  }
  v6 = nw_parameters_create();
  if (v6)
  {
    if (v3 == (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_18950)
      goto LABEL_11;
    v7 = (void *)nw_protocol_boringssl_copy_definition();
    options = nw_protocol_create_options(v7);

    if (options)
    {
      if (nw_parameters_add_protocol_stack_member(v6, 4, 0, options))
      {
        if (v3 != (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_86)
          v3[2](v3, options);

LABEL_11:
        if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
          dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
        v9 = nw_protocol_create_options((void *)g_tcp_definition);
        if (v9)
        {
          if (nw_parameters_add_protocol_stack_member(v6, 3, 0, v9))
          {
            if (networkd_settings_get_BOOL((const char *)nw_setting_tcp_enable_auto_tfo))
              nw_parameters_set_tfo(v6, 1);
            if (v5 != (void (**)(nw_parameters_configure_protocol_block_t, NWConcrete_nw_protocol_options *))&__block_literal_global_86)
              v5[2](v5, v9);
            BYTE4(v6[11].isa) = 2;
            v10 = v6;
            goto LABEL_80;
          }
LABEL_79:
          v10 = 0;
LABEL_80:

          goto LABEL_81;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        v23 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s nw_tcp_create_options failed", buf, 0xCu);
            }
          }
          else if (v59)
          {
            v31 = __nw_create_backtrace_string();
            if (v31)
            {
              v32 = (char *)v31;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v33 = (id)gLogObj;
              v34 = type;
              if (os_log_type_enabled(v33, type))
              {
                *(_DWORD *)buf = 136446466;
                v62 = "nw_parameters_create_secure_tcp";
                v63 = 2082;
                v64 = v32;
                _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s nw_tcp_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v32);
              if (!v23)
                goto LABEL_79;
              goto LABEL_78;
            }
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            v38 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl(&dword_182FBE000, v24, v38, "%{public}s nw_tcp_create_options failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v36 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v62 = "nw_parameters_create_secure_tcp";
              _os_log_impl(&dword_182FBE000, v24, v36, "%{public}s nw_tcp_create_options failed, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
        if (!v23)
          goto LABEL_79;
LABEL_78:
        free(v23);
        goto LABEL_79;
      }
      goto LABEL_72;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v62 = "nw_parameters_create_secure_tcp";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (__nwlog_fault(v19, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s nw_tls_create_options failed", buf, 0xCu);
        }
      }
      else if (v59)
      {
        v26 = __nw_create_backtrace_string();
        if (v26)
        {
          v27 = (char *)v26;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = (id)gLogObj;
          v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_parameters_create_secure_tcp";
            v63 = 2082;
            v64 = v27;
            _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s nw_tls_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v27);
          if (!v19)
            goto LABEL_72;
          goto LABEL_71;
        }
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_182FBE000, v20, v37, "%{public}s nw_tls_create_options failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = (id)gLogObj;
        v35 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_parameters_create_secure_tcp";
          _os_log_impl(&dword_182FBE000, v20, v35, "%{public}s nw_tls_create_options failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v19)
    {
LABEL_72:

      goto LABEL_73;
    }
LABEL_71:
    free(v19);
    goto LABEL_72;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v62 = "nw_parameters_create_secure_tcp";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v59 = 0;
  if (__nwlog_fault(v12, &type, &v59))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
    }
    else if (v59)
    {
      v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v62 = "nw_parameters_create_secure_tcp";
          v63 = 2082;
          v64 = v15;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        if (!v12)
          goto LABEL_73;
        goto LABEL_60;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_parameters_create_secure_tcp";
        _os_log_impl(&dword_182FBE000, v13, v30, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
  if (v12)
LABEL_60:
    free(v12);
LABEL_73:
  v10 = 0;
LABEL_81:

LABEL_82:
  return v10;
}

void sub_1831A6950(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_add_protocol_stack_member(void *a1, int a2, unsigned int a3, void *a4)
{
  id *v7;
  id v8;
  void *v9;
  id v10;
  _QWORD *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL8 v15;
  unsigned __int8 *v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  _BOOL8 v21;
  unsigned __int8 *v22;
  id v23;
  void *v24;
  uint64_t v25;
  _BOOL8 v26;
  void *v27;
  void *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  void *v33;
  os_log_type_t v34;
  void *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  _BOOL4 v43;
  char *backtrace_string;
  os_log_type_t v45;
  _BOOL4 v46;
  os_log_type_t v47;
  os_log_type_t v48;
  os_log_type_t v49;
  _QWORD v50[4];
  id v51;
  id v52;
  unsigned int v53;
  _QWORD v54[4];
  id v55;
  id v56;
  unsigned int v57;
  char v58;
  os_log_type_t v59;
  uint8_t buf[4];
  const char *v61;
  __int16 v62;
  char *v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  v9 = v8;
  if (v7)
  {
    if (v8)
    {
      v10 = v7[19];
      v11 = v10;
      if (v10)
      {
        switch(a2)
        {
          case 2:
            objc_storeStrong((id *)v10 + 6, a4);
            goto LABEL_26;
          case 3:
            objc_storeStrong((id *)v10 + 3, a4);
            goto LABEL_26;
          case 4:
            v14 = *((_QWORD *)v10 + 2);
            if (a3 == -1)
            {
              if (v14)
                goto LABEL_25;
            }
            else if (v14)
            {
              if (a3 >= (unint64_t)((uint64_t)(*(_QWORD *)(v14 + 24) - *(_QWORD *)(v14 + 16)) >> 3))
                goto LABEL_25;
              v15 = nw_array_create();
              v16 = (unsigned __int8 *)v11[2];
              v50[0] = MEMORY[0x1E0C809B0];
              v50[1] = 3221225472;
              v50[2] = __nw_parameters_add_protocol_stack_member_block_invoke_2;
              v50[3] = &unk_1E149D098;
              v53 = a3;
              v17 = (id)v15;
              v51 = v17;
              v52 = v9;
              nw_array_apply(v16, (uint64_t)v50);
              v18 = (void *)v11[2];
              v11[2] = v17;
              v19 = v17;

              v20 = v51;
LABEL_19:

LABEL_26:
              v13 = 1;
LABEL_27:

              goto LABEL_28;
            }
            v25 = 2;
            goto LABEL_24;
          case 5:
            v14 = *((_QWORD *)v10 + 1);
            if (a3 == -1)
            {
              if (v14)
                goto LABEL_25;
            }
            else if (v14)
            {
              if (a3 < (unint64_t)((uint64_t)(*(_QWORD *)(v14 + 24) - *(_QWORD *)(v14 + 16)) >> 3))
              {
                v21 = nw_array_create();
                v22 = (unsigned __int8 *)v11[1];
                v54[0] = MEMORY[0x1E0C809B0];
                v54[1] = 3221225472;
                v54[2] = __nw_parameters_add_protocol_stack_member_block_invoke;
                v54[3] = &unk_1E149D098;
                v57 = a3;
                v23 = (id)v21;
                v55 = v23;
                v56 = v9;
                nw_array_apply(v22, (uint64_t)v54);
                v24 = (void *)v11[1];
                v11[1] = v23;
                v19 = v23;

                v20 = v55;
                goto LABEL_19;
              }
LABEL_25:
              nw_array_append(v14, v9);
              goto LABEL_26;
            }
            v25 = 1;
LABEL_24:
            v26 = nw_array_create();
            v27 = (void *)v11[v25];
            v11[v25] = v26;

            v14 = v11[v25];
            goto LABEL_25;
          default:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v12 = (id)gLogObj;
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v61 = "nw_parameters_add_protocol_stack_member";
              v62 = 1024;
              LODWORD(v63) = a2;
              _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Unsupported protocol level %u", buf, 0x12u);
            }

            goto LABEL_9;
        }
      }
      __nwlog_obj();
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v61 = "nw_parameters_add_protocol_stack_member";
      v36 = (char *)_os_log_send_and_compose_impl();

      v59 = OS_LOG_TYPE_ERROR;
      v58 = 0;
      if (__nwlog_fault(v36, &v59, &v58))
      {
        if (v59 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v38 = v59;
          if (os_log_type_enabled(v37, v59))
          {
            *(_DWORD *)buf = 136446210;
            v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s called with null stack", buf, 0xCu);
          }
        }
        else if (v58)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v45 = v59;
          v46 = os_log_type_enabled(v37, v59);
          if (backtrace_string)
          {
            if (v46)
            {
              *(_DWORD *)buf = 136446466;
              v61 = "nw_parameters_add_protocol_stack_member";
              v62 = 2082;
              v63 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v37, v45, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_80;
          }
          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_182FBE000, v37, v45, "%{public}s called with null stack, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v49 = v59;
          if (os_log_type_enabled(v37, v59))
          {
            *(_DWORD *)buf = 136446210;
            v61 = "nw_parameters_add_protocol_stack_member";
            _os_log_impl(&dword_182FBE000, v37, v49, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_80:
      if (v36)
        free(v36);
LABEL_9:
      v13 = 0;
      goto LABEL_27;
    }
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v61 = "nw_parameters_add_protocol_stack_member";
    v30 = (char *)_os_log_send_and_compose_impl();

    v59 = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (__nwlog_fault(v30, &v59, &v58))
    {
      if (v59 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v34 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_182FBE000, v31, v34, "%{public}s called with null protocol_parameters", buf, 0xCu);
        }
LABEL_73:

        goto LABEL_74;
      }
      if (!v58)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v48 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_182FBE000, v31, v48, "%{public}s called with null protocol_parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_73;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v42 = v59;
      v43 = os_log_type_enabled(v31, v59);
      if (!v39)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_182FBE000, v31, v42, "%{public}s called with null protocol_parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        v61 = "nw_parameters_add_protocol_stack_member";
        v62 = 2082;
        v63 = v39;
        _os_log_impl(&dword_182FBE000, v31, v42, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_53;
    }
  }
  else
  {
    __nwlog_obj();
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v61 = "nw_parameters_add_protocol_stack_member";
    v30 = (char *)_os_log_send_and_compose_impl();

    v59 = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (__nwlog_fault(v30, &v59, &v58))
    {
      if (v59 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v32 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null parameters", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (!v58)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v47 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_182FBE000, v31, v47, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_73;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v40 = v59;
      v41 = os_log_type_enabled(v31, v59);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v61 = "nw_parameters_add_protocol_stack_member";
          _os_log_impl(&dword_182FBE000, v31, v40, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        v61 = "nw_parameters_add_protocol_stack_member";
        v62 = 2082;
        v63 = v39;
        _os_log_impl(&dword_182FBE000, v31, v40, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_53:

      free(v39);
    }
  }
LABEL_74:
  if (v30)
    free(v30);
  v13 = 0;
LABEL_28:

  return v13;
}

nw_protocol_options_t nw_tls_create_options(void)
{
  void *v0;
  NWConcrete_nw_protocol_options *options;

  v0 = (void *)nw_protocol_boringssl_copy_definition();
  options = nw_protocol_create_options(v0);

  return &options->super;
}

void sub_1831A72D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_parameters_set_data_mode(void *a1, unsigned int a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  NWConcrete_nw_protocol_options *options;
  uint64_t v7;
  void *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_parameters_set_data_mode";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_parameters_set_data_mode";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_48:
        if (!v10)
          goto LABEL_14;
        goto LABEL_49;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_47:

    goto LABEL_48;
  }
  if (a2 >= 0xFF)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_parameters_set_data_mode";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX)", buf, 0xCu);
      }
    }
    else if (v23)
    {
      v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_parameters_set_data_mode";
          v27 = 2082;
          v28 = v18;
          _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v10)
          goto LABEL_14;
LABEL_49:
        free(v10);
        goto LABEL_14;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_set_data_mode";
        _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_47;
  }
  *((_BYTE *)v3 + 92) = a2;
  v5 = v3[19];
  if (v5 && !*(_QWORD *)(v5 + 24))
  {
    if (a2 == 1)
    {
      if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1)
        dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45078);
      options = nw_protocol_create_options((void *)g_udp_definition);
      goto LABEL_13;
    }
    if (a2 == 2)
    {
      if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
        dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
      options = nw_protocol_create_options((void *)g_tcp_definition);
LABEL_13:
      v7 = v4[19];
      v8 = *(void **)(v7 + 24);
      *(_QWORD *)(v7 + 24) = options;

    }
  }
LABEL_14:

}

void sub_1831A7828(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_parameters_set_no_fullstack_fallback(void *a1, int a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = 0x20000;
    if (!a2)
      v5 = 0;
    *((_QWORD *)v3 + 12) = *((_QWORD *)v3 + 12) & 0xFFFFFFFFFFFDFFFFLL | v5;
    goto LABEL_5;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_parameters_set_no_fullstack_fallback";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_no_fullstack_fallback";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_parameters_set_no_fullstack_fallback";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_no_fullstack_fallback";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_no_fullstack_fallback";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v7)
    free(v7);
LABEL_5:

}

void nw_parameters_set_https_proxy_is_opaque(void *a1, int a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = 0x100000;
    if (!a2)
      v5 = 0;
    *((_QWORD *)v3 + 12) = *((_QWORD *)v3 + 12) & 0xFFFFFFFFFFEFFFFFLL | v5;
    goto LABEL_5;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_parameters_set_https_proxy_is_opaque";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_https_proxy_is_opaque";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_parameters_set_https_proxy_is_opaque";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_https_proxy_is_opaque";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_https_proxy_is_opaque";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v7)
    free(v7);
LABEL_5:

}

uint64_t nw_parameters_get_indefinite_set(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[96] >> 7;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_indefinite_set";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_indefinite_set";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_indefinite_set";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_indefinite_set";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_indefinite_set";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_endpoint_flow_join_protocol(void *a1, void *a2, void *a3, void *a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, _BYTE *a10)
{
  NWConcrete_nw_endpoint_handler *v17;
  id v18;
  uint64_t v19;
  void (*v20)(uint64_t);
  void *v21;
  char v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  NWConcrete_nw_endpoint_mode_handler *v26;
  id v27;
  uint64_t v28;
  uint64_t v29;
  int minimize_logging;
  char logging_disabled;
  NSObject *v32;
  const char *v33;
  const char *v34;
  nw_endpoint_t v35;
  const char *v36;
  const char *v37;
  const char *v38;
  uint64_t v39;
  id v40;
  void *v41;
  const char *v42;
  id v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  NSObject *v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  os_log_type_t v52;
  NSObject *v53;
  const char *v54;
  const char *v55;
  nw_endpoint_t v56;
  const char *v57;
  const char *v58;
  const char *v59;
  id v60;
  void *v61;
  const char *v62;
  void *v64;
  os_log_type_t v65;
  char *backtrace_string;
  os_log_type_t v67;
  _BOOL4 v68;
  const char *id_string;
  const char *v70;
  nw_endpoint_t v71;
  const char *logging_description;
  const char *v73;
  const char *v74;
  id v75;
  void *v76;
  const char *v77;
  os_log_type_t v78;
  uint64_t v79;
  NSObject *log;
  id v81;
  NWConcrete_nw_endpoint_mode_handler *v82;
  void *v83;
  id v84;
  _BOOL4 v85;
  id v86;
  id v87;
  char v88;
  os_log_type_t type[3];
  _BYTE buf[12];
  __int16 v91;
  uint64_t v92;
  __int16 v93;
  void *v94;
  __int16 v95;
  const char *v96;
  __int16 v97;
  const char *v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  id v102;
  __int16 v103;
  const char *v104;
  __int16 v105;
  int v106;
  __int16 v107;
  uint64_t v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v17 = a1;
  v86 = a2;
  v87 = a3;
  v18 = a4;
  v85 = nw_protocols_are_equal(*(_QWORD **)(a7 + 16), a5);
  if (!v85)
    goto LABEL_68;
  v84 = v18;
  nw_endpoint_handler_set_protocol_instance(v17, v87, v18, a7);
  v19 = *(_QWORD *)(a7 + 24);
  if (v19)
  {
    v20 = *(void (**)(uint64_t))(v19 + 112);
    if (v20)
    {
      v21 = *(void **)(a7 + 40);
      if (v21 == &nw_protocol_ref_counted_handle)
      {
        v23 = *(_QWORD *)(a7 + 88);
        if (v23)
          *(_QWORD *)(a7 + 88) = v23 + 1;
        v22 = -1;
      }
      else
      {
        v22 = 0;
      }
      *(_QWORD *)buf = a7;
      buf[8] = v22;
      v20(a7);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      if (v21 == &nw_protocol_ref_counted_handle)
        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      nw_parameters_inherit_protocol_instances(v86, a6, v24, a7, a9);

    }
  }
  if (!a8)
  {
    __nwlog_obj();
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
    v44 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v88 = 0;
    if (!__nwlog_fault(v44, type, &v88))
      goto LABEL_56;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v45 = objc_claimAutoreleasedReturnValue();
      v65 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_182FBE000, v45, v65, "%{public}s called with null input_protocol", buf, 0xCu);
      }
      goto LABEL_89;
    }
    if (!v88)
    {
      __nwlog_obj();
      v45 = objc_claimAutoreleasedReturnValue();
      v78 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_182FBE000, v45, v78, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_89;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v49 = objc_claimAutoreleasedReturnValue();
    v67 = type[0];
    v68 = os_log_type_enabled(v49, type[0]);
    if (backtrace_string)
    {
      if (v68)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        v91 = 2082;
        v92 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v49, v67, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
LABEL_56:
      if (!v44)
        goto LABEL_58;
LABEL_57:
      free(v44);
      goto LABEL_58;
    }
    if (v68)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
      _os_log_impl(&dword_182FBE000, v49, v67, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
    }
    goto LABEL_55;
  }
  if (a7 == a8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
    v91 = 2048;
    v92 = a7;
    v44 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v88 = 0;
    if (!__nwlog_fault(v44, type, &v88))
      goto LABEL_56;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v45 = (id)gLogObj;
      v46 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        v91 = 2048;
        v92 = a7;
        _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
      }
LABEL_89:

      goto LABEL_56;
    }
    if (!v88)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v45 = (id)gLogObj;
      v52 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        v91 = 2048;
        v92 = a7;
        _os_log_impl(&dword_182FBE000, v45, v52, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_89;
    }
    v48 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v49 = (id)gLogObj;
    v50 = type[0];
    v51 = os_log_type_enabled(v49, type[0]);
    if (v48)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
        v91 = 2048;
        v92 = a7;
        v93 = 2082;
        v94 = v48;
        _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(v48);
      if (!v44)
        goto LABEL_58;
      goto LABEL_57;
    }
    if (v51)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
      v91 = 2048;
      v92 = a7;
      _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
    }
LABEL_55:

    goto LABEL_56;
  }
  v25 = *(_QWORD **)(a7 + 24);
  if (v25 && *v25)
  {
    if ((nw_protocol_add_input_handler(a7, a8) & 1) != 0)
    {
      v26 = nw_endpoint_handler_copy_flow(v17);
      v27 = nw_parameters_copy_context(v86);
      v28 = 0;
      v82 = v26;
      v83 = v27;
      do
      {
        if (!uuid_is_null((const unsigned __int8 *)a8))
          v28 = a8;
        a8 = *(_QWORD *)(a8 + 32);
      }
      while (a8);
      if (v28)
        v29 = v28;
      else
        v29 = a7;
      v81 = nw_path_copy_flow_registration(v27, v29);
      objc_storeStrong((id *)v26 + 104, v81);
      minimize_logging = nw_endpoint_handler_get_minimize_logging(v17);
      logging_disabled = nw_endpoint_handler_get_logging_disabled(v17);
      if (minimize_logging)
      {
        if ((logging_disabled & 1) != 0)
          goto LABEL_35;
        v79 = v29;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        log = (id)gconnectionLogObj;
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v17);
          v70 = nw_endpoint_handler_dry_run_string(v17);
          v71 = nw_endpoint_handler_copy_endpoint(v17);
          logging_description = nw_endpoint_get_logging_description(v71);
          v73 = nw_endpoint_handler_state_string(v17);
          v74 = nw_endpoint_handler_mode_string(v17);
          v75 = nw_endpoint_handler_copy_current_path(v17);
          v76 = v75;
          v77 = "invalid";
          if (a7 && *(_QWORD *)(a7 + 16))
            v77 = *(const char **)(a7 + 16);
          *(_DWORD *)buf = 136448514;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_join_protocol";
          v91 = 2082;
          v92 = (uint64_t)id_string;
          v93 = 2082;
          v94 = (void *)v70;
          v95 = 2082;
          v96 = logging_description;
          v97 = 2082;
          v98 = v73;
          v99 = 2082;
          v100 = v74;
          v101 = 2114;
          v102 = v75;
          v103 = 2082;
          v104 = v77;
          v105 = 1042;
          v106 = 16;
          v107 = 2098;
          v108 = v79;
          _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Joined protocol %{public}s, using flow id %{public,uuid_t}.16P", buf, 0x62u);

        }
      }
      else
      {
        if ((logging_disabled & 1) != 0)
        {
LABEL_35:

          v18 = v84;
          goto LABEL_68;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v32 = (id)gconnectionLogObj;
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
LABEL_34:

          goto LABEL_35;
        }
        v33 = nw_endpoint_handler_get_id_string(v17);
        v34 = nw_endpoint_handler_dry_run_string(v17);
        log = v32;
        v35 = nw_endpoint_handler_copy_endpoint(v17);
        v36 = nw_endpoint_get_logging_description(v35);
        v37 = nw_endpoint_handler_state_string(v17);
        v38 = nw_endpoint_handler_mode_string(v17);
        v39 = v29;
        v40 = nw_endpoint_handler_copy_current_path(v17);
        v41 = v40;
        v42 = "invalid";
        if (a7 && *(_QWORD *)(a7 + 16))
          v42 = *(const char **)(a7 + 16);
        *(_DWORD *)buf = 136448514;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_join_protocol";
        v91 = 2082;
        v92 = (uint64_t)v33;
        v93 = 2082;
        v94 = (void *)v34;
        v95 = 2082;
        v96 = v36;
        v97 = 2082;
        v98 = v37;
        v99 = 2082;
        v100 = v38;
        v101 = 2114;
        v102 = v40;
        v103 = 2082;
        v104 = v42;
        v105 = 1042;
        v106 = 16;
        v107 = 2098;
        v108 = v39;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Joined protocol %{public}s, using flow id %{public,uuid_t}.16P", buf, 0x62u);

      }
      v32 = log;
      goto LABEL_34;
    }
    goto LABEL_59;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v47 = (id)gLogObj;
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
    v91 = 2048;
    v92 = a7;
    _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
  }

LABEL_58:
  v18 = v84;
LABEL_59:
  if ((nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v53 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      v54 = nw_endpoint_handler_get_id_string(v17);
      v55 = nw_endpoint_handler_dry_run_string(v17);
      v56 = nw_endpoint_handler_copy_endpoint(v17);
      v57 = nw_endpoint_get_logging_description(v56);
      v58 = nw_endpoint_handler_state_string(v17);
      v59 = nw_endpoint_handler_mode_string(v17);
      v60 = nw_endpoint_handler_copy_current_path(v17);
      v61 = v60;
      v62 = *(const char **)(a7 + 16);
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_join_protocol";
      *(_DWORD *)buf = 136448002;
      if (!v62)
        v62 = "invalid";
      v91 = 2082;
      v92 = (uint64_t)v54;
      v93 = 2082;
      v94 = (void *)v55;
      v95 = 2082;
      v96 = v57;
      v97 = 2082;
      v98 = v58;
      v99 = 2082;
      v100 = v59;
      v101 = 2114;
      v102 = v60;
      v103 = 2082;
      v104 = v62;
      _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to join protocol %{public}s", buf, 0x52u);

    }
    v18 = v84;
  }
  *a10 = 1;
LABEL_68:

  return v85;
}

void sub_1831A8BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,void *a21)
{
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void sub_1831A8CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_path_flow_registration;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_path_flow_registration_close(void *a1)
{
  _BYTE *v1;
  unsigned __int8 *v2;
  uint64_t v3;
  id v4;
  int v5;
  uint64_t v6;
  int v7;
  id v8;
  void *v9;
  NSObject *v10;
  os_log_type_t v11;
  int v12;
  id v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  NSObject *v20;
  uint64_t v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  id v26;
  uint64_t globals_for_path;
  uint64_t v28;
  _BOOL8 node;
  os_log_type_t v30;
  void *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  void *v35;
  os_log_type_t v36;
  char *backtrace_string;
  os_log_type_t v38;
  _BOOL4 v39;
  char *v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  os_log_type_t v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  _BYTE v50[14];
  __int16 v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_path_flow_registration_close";
    v32 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v32, &type, &v45))
      goto LABEL_88;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_path_flow_registration_close";
        _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null registration", buf, 0xCu);
      }
    }
    else if (v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v38 = type;
      v39 = os_log_type_enabled(v33, type);
      if (backtrace_string)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_path_flow_registration_close";
          v49 = 2082;
          *(_QWORD *)v50 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v33, v38, "%{public}s called with null registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_88:
        if (!v32)
          goto LABEL_46;
LABEL_89:
        free(v32);
        goto LABEL_46;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_path_flow_registration_close";
        _os_log_impl(&dword_182FBE000, v33, v38, "%{public}s called with null registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_path_flow_registration_close";
        _os_log_impl(&dword_182FBE000, v33, v43, "%{public}s called with null registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_87:

    goto LABEL_88;
  }
  if ((v1[148] & 1) == 0)
    goto LABEL_46;
  v3 = *((_QWORD *)v1 + 1);
  if (v3)
  {
    v4 = nw_parameters_copy_context(*(void **)(v3 + 8));
    v5 = nw_path_shared_necp_fd(v4);

    if (v5 < 0 || uuid_is_null(v2 + 32))
      goto LABEL_6;
    *((_QWORD *)v2 + 8) = 0;
    if (necp_client_action())
    {
      v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v48 = "nw_path_flow_registration_close";
      v49 = 1024;
      *(_DWORD *)v50 = v12;
      v14 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v45 = 0;
      if (!__nwlog_fault(v14, &type, &v45))
        goto LABEL_53;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = (id)gLogObj;
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_path_flow_registration_close";
          v49 = 1024;
          *(_DWORD *)v50 = v12;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s NECP_CLIENT_ACTION_REMOVE_FLOW error %{darwin.errno}d", buf, 0x12u);
        }
LABEL_52:

LABEL_53:
        if (!v14)
          goto LABEL_6;
        goto LABEL_54;
      }
      if (!v45)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_path_flow_registration_close";
          v49 = 1024;
          *(_DWORD *)v50 = v12;
          _os_log_impl(&dword_182FBE000, v15, v30, "%{public}s NECP_CLIENT_ACTION_REMOVE_FLOW error %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_52;
      }
      v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v15, type);
      if (!v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_path_flow_registration_close";
          v49 = 1024;
          *(_DWORD *)v50 = v12;
          _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s NECP_CLIENT_ACTION_REMOVE_FLOW error %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
        goto LABEL_52;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446722;
        v48 = "nw_path_flow_registration_close";
        v49 = 1024;
        *(_DWORD *)v50 = v12;
        *(_WORD *)&v50[4] = 2082;
        *(_QWORD *)&v50[6] = v22;
        _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s NECP_CLIENT_ACTION_REMOVE_FLOW error %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(v22);
      if (v14)
LABEL_54:
        free(v14);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = (id)gLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = *((_QWORD *)v2 + 1) + 80;
        *(_DWORD *)buf = 136447234;
        v48 = "nw_path_flow_registration_close";
        v49 = 1042;
        *(_DWORD *)v50 = 16;
        *(_WORD *)&v50[4] = 2098;
        *(_QWORD *)&v50[6] = v2 + 32;
        v51 = 1042;
        v52 = 16;
        v53 = 2098;
        v54 = v21;
        _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Removed flow %{public,uuid_t}.16P from %{public,uuid_t}.16P", buf, 0x2Cu);
      }

    }
LABEL_6:
    v2[148] &= ~1u;
    os_unfair_lock_lock((os_unfair_lock_t)(*((_QWORD *)v2 + 1) + 96));
    v6 = *((_QWORD *)v2 + 1);
    v7 = *(_DWORD *)(v6 + 100);
    if (v7)
    {
      *(_DWORD *)(v6 + 100) = v7 - 1;
      goto LABEL_42;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v48 = "nw_path_flow_registration_close";
    v9 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault((const char *)v9, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_path_flow_registration_close";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s Path evaluator flow count unexpectedly 0 when closing flow", buf, 0xCu);
        }
      }
      else if (v45)
      {
        v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v18 = type;
        v19 = os_log_type_enabled(v10, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v48 = "nw_path_flow_registration_close";
            v49 = 2082;
            *(_QWORD *)v50 = v17;
            _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s Path evaluator flow count unexpectedly 0 when closing flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v17);
          if (!v9)
            goto LABEL_42;
LABEL_41:
          free(v9);
LABEL_42:
          os_unfair_lock_unlock((os_unfair_lock_t)(*((_QWORD *)v2 + 1) + 96));
          v26 = nw_parameters_copy_context(*(void **)(*((_QWORD *)v2 + 1) + 8));
          globals_for_path = nw_context_get_globals_for_path(v26);

          os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
          v28 = *(_QWORD *)(globals_for_path + 40);
          if (v28)
          {
            node = nw_hash_table_get_node(v28, (uint64_t)(v2 + 32), 16);
            if (node)
              nw_hash_table_remove_node(*(_QWORD *)(globals_for_path + 40), node);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)(globals_for_path + 124));
          goto LABEL_46;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_path_flow_registration_close";
          _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s Path evaluator flow count unexpectedly 0 when closing flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v25 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_path_flow_registration_close";
          _os_log_impl(&dword_182FBE000, v10, v25, "%{public}s Path evaluator flow count unexpectedly 0 when closing flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
      goto LABEL_42;
    goto LABEL_41;
  }
  __nwlog_obj();
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v48 = "nw_path_flow_registration_close";
  v32 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if (!__nwlog_fault(v32, &type, &v45))
    goto LABEL_88;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v33 = objc_claimAutoreleasedReturnValue();
    v36 = type;
    if (os_log_type_enabled(v33, type))
    {
      *(_DWORD *)buf = 136446210;
      v48 = "nw_path_flow_registration_close";
      _os_log_impl(&dword_182FBE000, v33, v36, "%{public}s called with null registration->parent_evaluator", buf, 0xCu);
    }
    goto LABEL_87;
  }
  if (!v45)
  {
    __nwlog_obj();
    v33 = objc_claimAutoreleasedReturnValue();
    v44 = type;
    if (os_log_type_enabled(v33, type))
    {
      *(_DWORD *)buf = 136446210;
      v48 = "nw_path_flow_registration_close";
      _os_log_impl(&dword_182FBE000, v33, v44, "%{public}s called with null registration->parent_evaluator, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_87;
  }
  v40 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v33 = objc_claimAutoreleasedReturnValue();
  v41 = type;
  v42 = os_log_type_enabled(v33, type);
  if (!v40)
  {
    if (v42)
    {
      *(_DWORD *)buf = 136446210;
      v48 = "nw_path_flow_registration_close";
      _os_log_impl(&dword_182FBE000, v33, v41, "%{public}s called with null registration->parent_evaluator, no backtrace", buf, 0xCu);
    }
    goto LABEL_87;
  }
  if (v42)
  {
    *(_DWORD *)buf = 136446466;
    v48 = "nw_path_flow_registration_close";
    v49 = 2082;
    *(_QWORD *)v50 = v40;
    _os_log_impl(&dword_182FBE000, v33, v41, "%{public}s called with null registration->parent_evaluator, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v40);
  if (v32)
    goto LABEL_89;
LABEL_46:

}

void sub_1831A9808(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_parameters_inherit_protocol_instances(void *a1, uint64_t a2, void *a3, uint64_t a4, int a5)
{
  id *v9;
  id *v10;
  id *v11;
  void **v12;
  void **v13;
  id v14;
  int v15;
  _BYTE *v16;
  char v17;
  int v18;
  int v19;
  void *v20;
  id *v21;
  id v22;
  uint64_t protocol_handle;
  void *v24;
  id *v25;
  id v26;
  uint64_t v27;
  void *v28;
  id *v29;
  id v30;
  uint64_t v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  void *v36;
  os_log_type_t v37;
  void *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  void *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  char *backtrace_string;
  os_log_type_t v47;
  _BOOL4 v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  char *v52;
  os_log_type_t v53;
  _BOOL4 v54;
  char *v55;
  os_log_type_t v56;
  _BOOL4 v57;
  os_log_type_t v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  _QWORD v62[4];
  void **v63;
  uint64_t v64;
  uint64_t v65;
  os_log_type_t type[15];
  char v67;
  _BYTE buf[12];
  __int16 v69;
  char *v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a3;
  v11 = v10;
  if (!v9)
  {
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
    v33 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v33, type, &v67))
      goto LABEL_94;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
        _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null new_parameters", buf, 0xCu);
      }
    }
    else if (v67)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v47 = type[0];
      v48 = os_log_type_enabled(v34, type[0]);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
          v69 = 2082;
          v70 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v34, v47, "%{public}s called with null new_parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_94:
        if (!v33)
          goto LABEL_34;
LABEL_95:
        free(v33);
        goto LABEL_34;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
        _os_log_impl(&dword_182FBE000, v34, v47, "%{public}s called with null new_parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v58 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
        _os_log_impl(&dword_182FBE000, v34, v58, "%{public}s called with null new_parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_93:

    goto LABEL_94;
  }
  if (v10)
  {
    v12 = (void **)v9[19];
    if (v12)
    {
      v13 = (void **)v11[19];
      if (v13)
      {
        v14 = v9[23];
        v15 = 3;
        if (v14)
        {
          v16 = v14;
          v17 = v16[170];

          if ((v17 & 1) != 0)
            v15 = 4;
          else
            v15 = 3;
        }
        if (a4)
          v18 = 2;
        else
          v18 = 1;
        if (a5)
          v19 = v15;
        else
          v19 = v18;
        *(_QWORD *)buf = 0;
        *(_QWORD *)type = 0;
        if (nw_protocol_stack_application_protocols_are_equal_below(v12, a2, v13, a4, v19, buf, type))
        {
          v62[0] = MEMORY[0x1E0C809B0];
          v62[1] = 3221225472;
          v62[2] = __nw_parameters_inherit_protocol_instances_block_invoke;
          v62[3] = &unk_1E149D048;
          v64 = *(_QWORD *)buf;
          v65 = *(_QWORD *)type;
          v63 = v13;
          nw_protocol_stack_iterate_application_protocols_with_index(v12, v62);

        }
        v20 = v12[3];
        if (v20 && v13[3])
        {
          v21 = v20;
          v22 = v21[1];

          if (nw_protocol_options_matches_definition(v13[3], v22))
          {
            nw_protocol_options_inherit_log_id(v13[3], v12[3]);
            protocol_handle = nw_protocol_options_get_protocol_handle(v13[3]);
            nw_protocol_options_set_instance(v12[3], protocol_handle);
          }

        }
        v24 = v12[4];
        if (v24 && v13[4])
        {
          v25 = v24;
          v26 = v25[1];

          if (nw_protocol_options_matches_definition(v13[4], v26))
          {
            nw_protocol_options_inherit_log_id(v13[4], v12[4]);
            v27 = nw_protocol_options_get_protocol_handle(v13[4]);
            nw_protocol_options_set_instance(v12[4], v27);
          }

        }
        v28 = v12[6];
        if (v28 && v13[6])
        {
          v29 = v28;
          v30 = v29[1];

          if (nw_protocol_options_matches_definition(v13[6], v30))
          {
            nw_protocol_options_inherit_log_id(v13[6], v12[6]);
            v31 = nw_protocol_options_get_protocol_handle(v13[6]);
            nw_protocol_options_set_instance(v12[6], v31);
          }

        }
LABEL_32:

LABEL_33:
        goto LABEL_34;
      }
      __nwlog_obj();
      v42 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
      v43 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v67 = 0;
      if (__nwlog_fault(v43, type, &v67))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v44 = objc_claimAutoreleasedReturnValue();
          v45 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null join_stack", buf, 0xCu);
          }
        }
        else if (v67)
        {
          v55 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v44 = objc_claimAutoreleasedReturnValue();
          v56 = type[0];
          v57 = os_log_type_enabled(v44, type[0]);
          if (v55)
          {
            if (v57)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
              v69 = 2082;
              v70 = v55;
              _os_log_impl(&dword_182FBE000, v44, v56, "%{public}s called with null join_stack, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v55);
            goto LABEL_104;
          }
          if (v57)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_182FBE000, v44, v56, "%{public}s called with null join_stack, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v44 = objc_claimAutoreleasedReturnValue();
          v61 = type[0];
          if (os_log_type_enabled(v44, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
            _os_log_impl(&dword_182FBE000, v44, v61, "%{public}s called with null join_stack, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_104:
      if (v43)
        free(v43);
      goto LABEL_32;
    }
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
    v39 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (__nwlog_fault(v39, type, &v67))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v41 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
          _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s called with null stack", buf, 0xCu);
        }
      }
      else if (v67)
      {
        v52 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v53 = type[0];
        v54 = os_log_type_enabled(v40, type[0]);
        if (v52)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
            v69 = 2082;
            v70 = v52;
            _os_log_impl(&dword_182FBE000, v40, v53, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v52);
          goto LABEL_99;
        }
        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
          _os_log_impl(&dword_182FBE000, v40, v53, "%{public}s called with null stack, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v60 = type[0];
        if (os_log_type_enabled(v40, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
          _os_log_impl(&dword_182FBE000, v40, v60, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_99:
    if (v39)
      free(v39);
    goto LABEL_33;
  }
  __nwlog_obj();
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
  v33 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v67 = 0;
  if (!__nwlog_fault(v33, type, &v67))
    goto LABEL_94;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    v37 = type[0];
    if (os_log_type_enabled(v34, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null join_parameters", buf, 0xCu);
    }
    goto LABEL_93;
  }
  if (!v67)
  {
    __nwlog_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    v59 = type[0];
    if (os_log_type_enabled(v34, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_182FBE000, v34, v59, "%{public}s called with null join_parameters, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_93;
  }
  v49 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v34 = objc_claimAutoreleasedReturnValue();
  v50 = type[0];
  v51 = os_log_type_enabled(v34, type[0]);
  if (!v49)
  {
    if (v51)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
      _os_log_impl(&dword_182FBE000, v34, v50, "%{public}s called with null join_parameters, no backtrace", buf, 0xCu);
    }
    goto LABEL_93;
  }
  if (v51)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_parameters_inherit_protocol_instances";
    v69 = 2082;
    v70 = v49;
    _os_log_impl(&dword_182FBE000, v34, v50, "%{public}s called with null join_parameters, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v49);
  if (v33)
    goto LABEL_95;
LABEL_34:

}

void sub_1831AA2EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void nw_protocol_options_set_instance(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_QWORD *)v3 + 2) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_options_set_instance";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_options_set_instance";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_options_set_instance";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_protocol_options_inherit_log_id(void *a1, void *a2)
{
  char *v3;
  id v4;
  _WORD *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_options_inherit_log_id";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_protocol_options_inherit_log_id";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_options_inherit_log_id";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    snprintf((char *)v4 + 48, 0x54uLL, "%s", v3 + 48);
    v5[68] = *((_WORD *)v3 + 68);
    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_protocol_options_inherit_log_id";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_options_inherit_log_id";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null new_options", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_options_inherit_log_id";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null new_options, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_options_inherit_log_id";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null new_options, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_protocol_options_inherit_log_id";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null new_options, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

id nw_quic_connection_copy_sec_protocol_metadata(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_copy_sec_protocol_metadata_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(connection_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831AADB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_copy_sec_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 16));
  return 1;
}

uint64_t nw_quic_connection_get_peer_idle_timeout(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_peer_idle_timeout_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_peer_idle_timeout";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_peer_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_peer_idle_timeout";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_peer_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_peer_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831AB104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_peer_idle_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 152);
  if (v5)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))(v5 + 16))();
  os_unfair_lock_unlock(v4);
  return 1;
}

void __nw_settings_get_l4s_enabled_internal_block_invoke()
{
  const __CFString *v0;
  int AppBooleanValue;
  int v2;
  BOOL v3;
  char v4;
  Boolean keyExistsAndHasValidFormat;

  v0 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)"network_enable_l4s", 18, 0x8000100u, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  keyExistsAndHasValidFormat = 0;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(v0, CFSTR("Apple Global Domain"), &keyExistsAndHasValidFormat);
  v2 = keyExistsAndHasValidFormat;
  if (v0)
    CFRelease(v0);
  if (v2)
    v3 = AppBooleanValue == 0;
  else
    v3 = 1;
  v4 = !v3;
  nw_settings_get_l4s_enabled_internal::l4s_enabled = v4;
}

uint64_t nw_protocol_default_get_output_local(nw_protocol *a1)
{
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_output_local_endpoint)(void);
  uint64_t result;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_default_get_output_local";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12))
      goto LABEL_22;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_get_output_local";
      v9 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_default_get_output_local";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_22;
      }
      if (!v11)
      {
LABEL_22:
        if (v6)
          free(v6);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_get_output_local";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_default_get_output_local";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_22;
  }
  output_handler = a1->output_handler;
  if (!output_handler
    || (callbacks = output_handler->callbacks) == 0
    || (get_output_local_endpoint = (uint64_t (*)(void))callbacks->get_output_local_endpoint) == 0
    || (result = get_output_local_endpoint()) == 0)
  {
    if (a1->default_input_handler)
      return nw_protocol_default_get_local(a1);
    return 0;
  }
  return result;
}

uint64_t nw_protocol_udp_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *v5;
  nw_protocol_callbacks *v6;
  void *handle;
  nw_protocol_callbacks *v8;
  nw_protocol_callbacks *v9;
  uint64_t (*get_local_endpoint)(nw_protocol *);
  void *v11;
  BOOL v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v18;
  void (**v19)(_QWORD);
  const void *v20;
  nw_protocol_callbacks *v21;
  nw_protocol_callbacks *v22;
  void (**v23)(_QWORD);
  const void *v24;
  void *v25;
  nw_protocol_callbacks *v26;
  nw_protocol_callbacks *v27;
  uint64_t (*get_remote_endpoint)(nw_protocol *);
  void *v29;
  id v30;
  int v31;
  id v32;
  int v33;
  NSObject *v34;
  __int16 v35;
  NSObject *v36;
  __int16 v37;
  int address_family;
  const sockaddr *address;
  void *v40;
  nw_protocol_callbacks *v41;
  nw_protocol_callbacks *v42;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  unsigned __int8 *v47;
  uint64_t v48;
  nw_protocol *v49;
  unint64_t v50;
  int v51;
  unsigned __int8 *v52;
  __int16 v53;
  __int16 v54;
  unsigned __int8 *v55;
  _BOOL4 v56;
  __int16 v57;
  __int16 v58;
  nw_protocol *v59;
  nw_protocol_callbacks *v60;
  uint64_t (*get_path)(nw_protocol *);
  void *v62;
  nw_protocol_callbacks *v63;
  NWConcrete_nw_path *v64;
  int effective_traffic_class;
  nw_protocol_callbacks *v67;
  nw_protocol_callbacks *v68;
  void (**v69)(_QWORD);
  const void *v70;
  nw_protocol_callbacks *v71;
  nw_protocol_callbacks *v72;
  void (**v73)(_QWORD);
  const void *v74;
  char *v75;
  _BOOL4 v76;
  nw_protocol_callbacks *v77;
  nw_protocol_callbacks *v78;
  void (**v79)(_QWORD);
  const void *v80;
  char *v81;
  NSObject *v82;
  os_log_type_t v83;
  const char *v84;
  char *v85;
  _BOOL4 v86;
  char *v87;
  NSObject *v88;
  os_log_type_t v89;
  const char *v90;
  char *v91;
  _BOOL4 v92;
  char *v93;
  NSObject *v94;
  os_log_type_t v95;
  const char *v96;
  char *v97;
  _BOOL4 v98;
  char *v99;
  NSObject *v100;
  os_log_type_t v101;
  const char *v102;
  char *backtrace_string;
  _BOOL4 v104;
  const char *v105;
  nw_protocol_identifier *identifier;
  char *v107;
  NSObject *v108;
  os_log_type_t v109;
  nw_protocol_identifier *v110;
  const char *v111;
  nw_protocol_identifier *v112;
  char *v113;
  NSObject *v114;
  os_log_type_t v115;
  nw_protocol_identifier *v116;
  const char *v117;
  nw_protocol_identifier *v118;
  char *v119;
  NSObject *v120;
  os_log_type_t v121;
  nw_protocol_identifier *v122;
  const char *v123;
  char *v124;
  _BOOL4 v125;
  nw_protocol_identifier *v126;
  char *v127;
  _BOOL4 v128;
  nw_protocol_identifier *v129;
  _BOOL4 v130;
  char *v131;
  _BOOL4 v132;
  nw_protocol_identifier *v133;
  _BOOL4 v134;
  _BOOL4 v135;
  void *v136;
  char *v137;
  NSObject *v138;
  os_log_type_t v139;
  nw_protocol_identifier *v140;
  nw_protocol_identifier *v141;
  nw_protocol_identifier *v142;
  char *v143;
  os_log_type_t v144;
  _BOOL4 v145;
  nw_protocol_identifier *v146;
  nw_protocol_identifier *v147;
  nw_protocol_identifier *v148;
  os_log_type_t v149;
  char v150;
  os_log_type_t v151;
  _BYTE buf[24];
  nw_protocol *v153;
  _QWORD v154[2];
  _BYTE type[24];
  char v156;
  uint64_t v157;

  v157 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
    v99 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v151 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v99, type, &v151))
      goto LABEL_204;
    if (type[0] == 17)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (!os_log_type_enabled(v100, (os_log_type_t)type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null protocol";
      goto LABEL_203;
    }
    if (v151 == OS_LOG_TYPE_DEFAULT)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (!os_log_type_enabled(v100, (os_log_type_t)type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_203;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v100 = __nwlog_obj();
    v101 = type[0];
    v134 = os_log_type_enabled(v100, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (!v134)
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_203;
    }
    if (!v134)
      goto LABEL_198;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v105 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_197;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
    v99 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v151 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v99, type, &v151))
      goto LABEL_204;
    if (type[0] == 17)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (!os_log_type_enabled(v100, (os_log_type_t)type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null udp";
      goto LABEL_203;
    }
    if (v151 == OS_LOG_TYPE_DEFAULT)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (!os_log_type_enabled(v100, (os_log_type_t)type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null udp, backtrace limit exceeded";
      goto LABEL_203;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v100 = __nwlog_obj();
    v101 = type[0];
    v135 = os_log_type_enabled(v100, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (!v135)
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null udp, no backtrace";
      goto LABEL_203;
    }
    if (!v135)
      goto LABEL_198;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v105 = "%{public}s called with null udp, dumping backtrace:%{public}s";
    goto LABEL_197;
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler == a2)
  {
    nw_protocol_set_flow_id_from_protocol(a1, a2);
    if (a2)
      goto LABEL_12;
LABEL_25:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_output_handler";
    v13 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v151 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, type, &v151))
      goto LABEL_139;
    if (type[0] == 17)
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (!os_log_type_enabled(v14, (os_log_type_t)type[0]))
        goto LABEL_139;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_output_handler";
      v16 = "%{public}s called with null protocol";
    }
    else if (v151)
    {
      v75 = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type[0];
      v76 = os_log_type_enabled(v14, (os_log_type_t)type[0]);
      if (v75)
      {
        if (v76)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_output_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v75;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v75);
LABEL_139:
        if (v13)
          free(v13);
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_set_output_handler";
        v81 = (char *)_os_log_send_and_compose_impl();
        type[0] = 16;
        v151 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v81, type, &v151))
        {
          if (type[0] == 17)
          {
            v82 = __nwlog_obj();
            v83 = type[0];
            if (!os_log_type_enabled(v82, (os_log_type_t)type[0]))
              goto LABEL_155;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_set_output_handler";
            v84 = "%{public}s called with null protocol";
LABEL_154:
            _os_log_impl(&dword_182FBE000, v82, v83, v84, buf, 0xCu);
            goto LABEL_155;
          }
          if (v151 == OS_LOG_TYPE_DEFAULT)
          {
            v82 = __nwlog_obj();
            v83 = type[0];
            if (!os_log_type_enabled(v82, (os_log_type_t)type[0]))
              goto LABEL_155;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_set_output_handler";
            v84 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_154;
          }
          v85 = (char *)__nw_create_backtrace_string();
          v82 = __nwlog_obj();
          v83 = type[0];
          v86 = os_log_type_enabled(v82, (os_log_type_t)type[0]);
          if (!v85)
          {
            if (!v86)
              goto LABEL_155;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_set_output_handler";
            v84 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_154;
          }
          if (v86)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_set_output_handler";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v85;
            _os_log_impl(&dword_182FBE000, v82, v83, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v85);
        }
LABEL_155:
        if (v81)
          free(v81);
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
        v87 = (char *)_os_log_send_and_compose_impl();
        type[0] = 16;
        v151 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v87, type, &v151))
        {
          if (type[0] == 17)
          {
            v88 = __nwlog_obj();
            v89 = type[0];
            if (!os_log_type_enabled(v88, (os_log_type_t)type[0]))
              goto LABEL_171;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
            v90 = "%{public}s called with null protocol";
LABEL_170:
            _os_log_impl(&dword_182FBE000, v88, v89, v90, buf, 0xCu);
            goto LABEL_171;
          }
          if (v151 == OS_LOG_TYPE_DEFAULT)
          {
            v88 = __nwlog_obj();
            v89 = type[0];
            if (!os_log_type_enabled(v88, (os_log_type_t)type[0]))
              goto LABEL_171;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
            v90 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_170;
          }
          v91 = (char *)__nw_create_backtrace_string();
          v88 = __nwlog_obj();
          v89 = type[0];
          v92 = os_log_type_enabled(v88, (os_log_type_t)type[0]);
          if (!v91)
          {
            if (!v92)
              goto LABEL_171;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
            v90 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_170;
          }
          if (v92)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v91;
            _os_log_impl(&dword_182FBE000, v88, v89, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v91);
        }
LABEL_171:
        if (v87)
          free(v87);
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
        v93 = (char *)_os_log_send_and_compose_impl();
        type[0] = 16;
        v151 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v93, type, &v151))
          goto LABEL_187;
        if (type[0] == 17)
        {
          v94 = __nwlog_obj();
          v95 = type[0];
          if (!os_log_type_enabled(v94, (os_log_type_t)type[0]))
            goto LABEL_187;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
          v96 = "%{public}s called with null protocol";
        }
        else if (v151)
        {
          v97 = (char *)__nw_create_backtrace_string();
          v94 = __nwlog_obj();
          v95 = type[0];
          v98 = os_log_type_enabled(v94, (os_log_type_t)type[0]);
          if (v97)
          {
            if (v98)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v97;
              _os_log_impl(&dword_182FBE000, v94, v95, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v97);
            goto LABEL_187;
          }
          if (!v98)
          {
LABEL_187:
            if (v93)
              free(v93);
            goto LABEL_189;
          }
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
          v96 = "%{public}s called with null protocol, no backtrace";
        }
        else
        {
          v94 = __nwlog_obj();
          v95 = type[0];
          if (!os_log_type_enabled(v94, (os_log_type_t)type[0]))
            goto LABEL_187;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
          v96 = "%{public}s called with null protocol, backtrace limit exceeded";
        }
        _os_log_impl(&dword_182FBE000, v94, v95, v96, buf, 0xCu);
        goto LABEL_187;
      }
      if (!v76)
        goto LABEL_139;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_output_handler";
      v16 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (!os_log_type_enabled(v14, (os_log_type_t)type[0]))
        goto LABEL_139;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_output_handler";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_139;
  }
  if (default_input_handler)
  {
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      callbacks = default_input_handler[1].callbacks;
      if (callbacks)
      {
        v18 = (nw_protocol_callbacks *)((char *)callbacks - 1);
        default_input_handler[1].callbacks = v18;
        if (!v18)
        {
          v19 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v19)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v19[2](v19);
            _Block_release(v19);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v20 = *(const void **)default_input_handler[1].flow_id;
            if (v20)
              _Block_release(v20);
          }
          free(default_input_handler);
        }
      }
    }
  }
  a1->default_input_handler = a2;
  if (!a2)
  {
    nw_protocol_set_flow_id_from_protocol(a1, 0);
    goto LABEL_25;
  }
  if (a2->handle == &nw_protocol_ref_counted_handle)
  {
    v5 = a2[1].callbacks;
    if (v5)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v5->add_input_handler + 1);
  }
  nw_protocol_set_flow_id_from_protocol(a1, a2);
LABEL_12:
  if (!a2->output_handler)
  {
    a2->output_handler = a1;
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      v6 = a1[1].callbacks;
      if (v6)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v6->add_input_handler + 1);
    }
  }
  handle = a2->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    v8 = a2[1].callbacks;
    if (v8)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v8->add_input_handler + 1);
  }
  v9 = a2->callbacks;
  if (v9)
  {
    get_local_endpoint = (uint64_t (*)(nw_protocol *))v9->get_local_endpoint;
    if (get_local_endpoint)
    {
      v11 = (void *)get_local_endpoint(a2);
      if (handle != &nw_protocol_ref_counted_handle)
        goto LABEL_45;
      goto LABEL_22;
    }
  }
  __nwlog_obj();
  identifier = a2->identifier;
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
  if (!identifier)
    identifier = (nw_protocol_identifier *)"invalid";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = identifier;
  *(_WORD *)&buf[22] = 2048;
  v153 = a2;
  v107 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v151 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v107, type, &v151))
  {
    if (type[0] == 17)
    {
      v108 = __nwlog_obj();
      v109 = type[0];
      if (!os_log_type_enabled(v108, (os_log_type_t)type[0]))
        goto LABEL_309;
      v110 = a2->identifier;
      if (!v110)
        v110 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v110;
      *(_WORD *)&buf[22] = 2048;
      v153 = a2;
      v111 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback";
LABEL_308:
      _os_log_impl(&dword_182FBE000, v108, v109, v111, buf, 0x20u);
      goto LABEL_309;
    }
    if (v151 == OS_LOG_TYPE_DEFAULT)
    {
      v108 = __nwlog_obj();
      v109 = type[0];
      if (!os_log_type_enabled(v108, (os_log_type_t)type[0]))
        goto LABEL_309;
      v140 = a2->identifier;
      if (!v140)
        v140 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v140;
      *(_WORD *)&buf[22] = 2048;
      v153 = a2;
      v111 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded";
      goto LABEL_308;
    }
    v124 = (char *)__nw_create_backtrace_string();
    v108 = __nwlog_obj();
    v109 = type[0];
    v125 = os_log_type_enabled(v108, (os_log_type_t)type[0]);
    if (!v124)
    {
      if (!v125)
        goto LABEL_309;
      v146 = a2->identifier;
      if (!v146)
        v146 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v146;
      *(_WORD *)&buf[22] = 2048;
      v153 = a2;
      v111 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace";
      goto LABEL_308;
    }
    if (v125)
    {
      v126 = a2->identifier;
      if (!v126)
        v126 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_local_endpoint";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v126;
      *(_WORD *)&buf[22] = 2048;
      v153 = a2;
      LOWORD(v154[0]) = 2082;
      *(_QWORD *)((char *)v154 + 2) = v124;
      _os_log_impl(&dword_182FBE000, v108, v109, "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v124);
  }
LABEL_309:
  if (v107)
    free(v107);
  v11 = 0;
  if (handle != &nw_protocol_ref_counted_handle)
    goto LABEL_45;
LABEL_22:
  if (a2->handle != &nw_protocol_ref_counted_handle)
  {
    v12 = 1;
    goto LABEL_48;
  }
  v21 = a2[1].callbacks;
  if (v21)
  {
    v22 = (nw_protocol_callbacks *)((char *)v21 - 1);
    a2[1].callbacks = v22;
    if (!v22)
    {
      v23 = *(void (***)(_QWORD))a2[1].flow_id;
      if (v23)
      {
        *(_QWORD *)a2[1].flow_id = 0;
        v23[2](v23);
        _Block_release(v23);
      }
      if ((a2[1].flow_id[8] & 1) != 0)
      {
        v24 = *(const void **)a2[1].flow_id;
        if (v24)
          _Block_release(v24);
      }
      free(a2);
    }
  }
LABEL_45:
  v25 = a2->handle;
  v12 = v25 != &nw_protocol_ref_counted_handle;
  if (v25 == &nw_protocol_ref_counted_handle)
  {
    v26 = a2[1].callbacks;
    if (v26)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v26->add_input_handler + 1);
  }
LABEL_48:
  v27 = a2->callbacks;
  if (v27)
  {
    get_remote_endpoint = (uint64_t (*)(nw_protocol *))v27->get_remote_endpoint;
    if (get_remote_endpoint)
    {
      v29 = (void *)get_remote_endpoint(a2);
      goto LABEL_51;
    }
  }
  __nwlog_obj();
  v112 = a2->identifier;
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
  if (!v112)
    v112 = (nw_protocol_identifier *)"invalid";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = v112;
  *(_WORD *)&buf[22] = 2048;
  v153 = a2;
  v113 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v151 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v113, type, &v151))
  {
    if (type[0] == 17)
    {
      v114 = __nwlog_obj();
      v115 = type[0];
      if (os_log_type_enabled(v114, (os_log_type_t)type[0]))
      {
        v116 = a2->identifier;
        if (!v116)
          v116 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v116;
        *(_WORD *)&buf[22] = 2048;
        v153 = a2;
        v117 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback";
LABEL_317:
        _os_log_impl(&dword_182FBE000, v114, v115, v117, buf, 0x20u);
      }
    }
    else if (v151)
    {
      v127 = (char *)__nw_create_backtrace_string();
      v114 = __nwlog_obj();
      v115 = type[0];
      v128 = os_log_type_enabled(v114, (os_log_type_t)type[0]);
      if (v127)
      {
        if (v128)
        {
          v129 = a2->identifier;
          if (!v129)
            v129 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v129;
          *(_WORD *)&buf[22] = 2048;
          v153 = a2;
          LOWORD(v154[0]) = 2082;
          *(_QWORD *)((char *)v154 + 2) = v127;
          _os_log_impl(&dword_182FBE000, v114, v115, "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v127);
        goto LABEL_318;
      }
      if (v128)
      {
        v147 = a2->identifier;
        if (!v147)
          v147 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v147;
        *(_WORD *)&buf[22] = 2048;
        v153 = a2;
        v117 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace";
        goto LABEL_317;
      }
    }
    else
    {
      v114 = __nwlog_obj();
      v115 = type[0];
      if (os_log_type_enabled(v114, (os_log_type_t)type[0]))
      {
        v141 = a2->identifier;
        if (!v141)
          v141 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v141;
        *(_WORD *)&buf[22] = 2048;
        v153 = a2;
        v117 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded";
        goto LABEL_317;
      }
    }
  }
LABEL_318:
  if (v113)
    free(v113);
  v29 = 0;
LABEL_51:
  if (!v12 && a2->handle == &nw_protocol_ref_counted_handle)
  {
    v67 = a2[1].callbacks;
    if (v67)
    {
      v68 = (nw_protocol_callbacks *)((char *)v67 - 1);
      a2[1].callbacks = v68;
      if (!v68)
      {
        v69 = *(void (***)(_QWORD))a2[1].flow_id;
        if (v69)
        {
          *(_QWORD *)a2[1].flow_id = 0;
          v69[2](v69);
          _Block_release(v69);
        }
        if ((a2[1].flow_id[8] & 1) != 0)
        {
          v70 = *(const void **)a2[1].flow_id;
          if (v70)
            _Block_release(v70);
        }
        free(a2);
      }
    }
  }
  if (!v11 || (v30 = v11, v31 = objc_msgSend(v30, "type"), v30, v31 != 1))
  {
LABEL_189:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
    v99 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v151 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v99, type, &v151))
      goto LABEL_204;
    if (type[0] == 17)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (os_log_type_enabled(v100, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
        v102 = "%{public}s called with null (local_address && nw_endpoint_get_type(local_address) == nw_endpoint_type_address)";
        goto LABEL_203;
      }
      goto LABEL_204;
    }
    if (v151 == OS_LOG_TYPE_DEFAULT)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (!os_log_type_enabled(v100, (os_log_type_t)type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null (local_address && nw_endpoint_get_type(local_address) == nw_endpoint_type_addre"
             "ss), backtrace limit exceeded";
      goto LABEL_203;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v100 = __nwlog_obj();
    v101 = type[0];
    v104 = os_log_type_enabled(v100, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (!v104)
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null (local_address && nw_endpoint_get_type(local_address) == nw_endpoint_type_addre"
             "ss), no backtrace";
      goto LABEL_203;
    }
    if (!v104)
    {
LABEL_198:
      free(backtrace_string);
      goto LABEL_204;
    }
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v105 = "%{public}s called with null (local_address && nw_endpoint_get_type(local_address) == nw_endpoint_type_address"
           "), dumping backtrace:%{public}s";
LABEL_197:
    _os_log_impl(&dword_182FBE000, v100, v101, v105, buf, 0x16u);
    goto LABEL_198;
  }
  if (v29)
  {
    v32 = v29;
    v33 = objc_msgSend(v32, "type");

    if (v33 == 1)
    {
      v34 = v30;
      v35 = -[NSObject port](v34, "port");

      LOWORD(a1[2].output_handler_context) = v35;
      v36 = v32;
      v37 = -[NSObject port](v36, "port");

      WORD1(a1[2].output_handler_context) = v37;
      address_family = nw_endpoint_get_address_family(v34);
      HIWORD(a1[2].output_handler_context) = HIWORD(a1[2].output_handler_context) & 0xFFFB | (4 * (address_family == 2));
      address = nw_endpoint_get_address(v34);
      if (address_family == 2)
      {
        *(_DWORD *)a1[2].flow_id = *(_DWORD *)&address->sa_data[2];
        LODWORD(a1[2].identifier) = *(_DWORD *)&nw_endpoint_get_address(v36)->sa_data[2];
      }
      else
      {
        *(sockaddr *)a1[2].flow_id = *(sockaddr *)&address->sa_data[6];
        *(sockaddr *)&a1[2].identifier = *(sockaddr *)&nw_endpoint_get_address(v36)->sa_data[6];
      }
      v40 = a2->handle;
      if (v40 == &nw_protocol_ref_counted_handle)
      {
        v41 = a2[1].callbacks;
        if (v41)
          a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v41->add_input_handler + 1);
      }
      v42 = a2->callbacks;
      if (v42)
      {
        get_parameters = (uint64_t (*)(nw_protocol *))v42->get_parameters;
        if (get_parameters)
        {
          v44 = (void *)get_parameters(a2);
          if (v40 != &nw_protocol_ref_counted_handle)
            goto LABEL_67;
          goto LABEL_66;
        }
      }
      __nwlog_obj();
      v118 = a2->identifier;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
      if (!v118)
        v118 = (nw_protocol_identifier *)"invalid";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v118;
      *(_WORD *)&buf[22] = 2048;
      v153 = a2;
      v119 = (char *)_os_log_send_and_compose_impl();
      type[0] = 16;
      v151 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v119, type, &v151))
      {
        if (type[0] == 17)
        {
          v120 = __nwlog_obj();
          v121 = type[0];
          if (!os_log_type_enabled(v120, (os_log_type_t)type[0]))
            goto LABEL_328;
          v122 = a2->identifier;
          if (!v122)
            v122 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v122;
          *(_WORD *)&buf[22] = 2048;
          v153 = a2;
          v123 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_327:
          _os_log_impl(&dword_182FBE000, v120, v121, v123, buf, 0x20u);
          goto LABEL_328;
        }
        if (v151 == OS_LOG_TYPE_DEFAULT)
        {
          v120 = __nwlog_obj();
          v121 = type[0];
          if (!os_log_type_enabled(v120, (os_log_type_t)type[0]))
            goto LABEL_328;
          v142 = a2->identifier;
          if (!v142)
            v142 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v142;
          *(_WORD *)&buf[22] = 2048;
          v153 = a2;
          v123 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
          goto LABEL_327;
        }
        v131 = (char *)__nw_create_backtrace_string();
        v120 = __nwlog_obj();
        v121 = type[0];
        v132 = os_log_type_enabled(v120, (os_log_type_t)type[0]);
        if (!v131)
        {
          if (!v132)
            goto LABEL_328;
          v148 = a2->identifier;
          if (!v148)
            v148 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v148;
          *(_WORD *)&buf[22] = 2048;
          v153 = a2;
          v123 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
          goto LABEL_327;
        }
        if (v132)
        {
          v133 = a2->identifier;
          if (!v133)
            v133 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v133;
          *(_WORD *)&buf[22] = 2048;
          v153 = a2;
          LOWORD(v154[0]) = 2082;
          *(_QWORD *)((char *)v154 + 2) = v131;
          _os_log_impl(&dword_182FBE000, v120, v121, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v131);
      }
LABEL_328:
      if (v119)
        free(v119);
      v44 = 0;
      if (v40 != &nw_protocol_ref_counted_handle)
      {
LABEL_67:
        v45 = nw_parameters_copy_protocol_options_legacy(v44, a1);
        if (!v45)
        {
LABEL_83:
          if (nw_parameters_get_upper_transport_protocol(v44) == 253)
            HIWORD(a1[2].output_handler_context) |= 0x80u;
          v59 = a1->default_input_handler;
          if (v59)
          {
            v60 = v59->callbacks;
            if (v60)
            {
              get_path = (uint64_t (*)(nw_protocol *))v60->get_path;
              if (get_path)
              {
                if (v59->handle == &nw_protocol_ref_counted_handle)
                {
                  v63 = v59[1].callbacks;
                  if (v63)
                    v59[1].callbacks = (nw_protocol_callbacks *)((char *)&v63->add_input_handler + 1);
                  v62 = (void *)get_path(v59);
                  if (v59->handle == &nw_protocol_ref_counted_handle)
                  {
                    v77 = v59[1].callbacks;
                    if (v77)
                    {
                      v78 = (nw_protocol_callbacks *)((char *)v77 - 1);
                      v59[1].callbacks = v78;
                      if (!v78)
                      {
                        v79 = *(void (***)(_QWORD))v59[1].flow_id;
                        if (v79)
                        {
                          *(_QWORD *)v59[1].flow_id = 0;
                          v79[2](v79);
                          _Block_release(v79);
                        }
                        if ((v59[1].flow_id[8] & 1) != 0)
                        {
                          v80 = *(const void **)v59[1].flow_id;
                          if (v80)
                            _Block_release(v80);
                        }
                        free(v59);
                      }
                    }
                  }
                }
                else
                {
                  v62 = (void *)get_path(a1->default_input_handler);
                }
                if (v62)
                {
                  v64 = v62;
                  if (nw_path_network_is_satisfied_update_reason(v64, 0))
                  {
                    effective_traffic_class = v64->effective_traffic_class;
                    if (!effective_traffic_class)
                      effective_traffic_class = nw_parameters_get_traffic_class(v64->parameters);
                  }
                  else
                  {
                    effective_traffic_class = 0;
                  }

                  LODWORD(a1[2].default_input_handler) = effective_traffic_class;
                  HIDWORD(a1[2].default_input_handler) = nw_path_get_maximum_datagram_size(v64);
                }
              }
            }
          }
          if (_nw_signposts_once != -1)
            dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
          if (_nw_signposts_enabled)
          {
            if (kdebug_is_enabled())
              kdebug_trace();
          }
          return 1;
        }
        v46 = v45;
        v47 = v46;
        v48 = 0;
        a1[3].flow_id[0] = 0;
        v49 = a1 + 3;
        v50 = 84;
        while (1)
        {
          v51 = v46[v48 + 48];
          v49->flow_id[v48] = v51;
          if (!v51)
            break;
          --v50;
          ++v48;
          if (v50 <= 1)
          {
            v49->flow_id[v48] = 0;
            break;
          }
        }

        v52 = v47;
        v53 = *((_WORD *)v52 + 68);

        WORD2(a1[2].output_handler_context) = v53;
        if (nw_udp_options_get_prefer_no_checksum(v52))
          v54 = 16;
        else
          v54 = 0;
        HIWORD(a1[2].output_handler_context) = HIWORD(a1[2].output_handler_context) & 0xFFEF | v54;
        v55 = v52;
        if (nw_protocol_options_is_udp(v55))
        {
          *(_QWORD *)type = 0;
          *(_QWORD *)&type[8] = type;
          *(_QWORD *)&type[16] = 0x2020000000;
          v156 = 0;
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = __nw_udp_options_get_ignore_inbound_checksum_block_invoke;
          v153 = (nw_protocol *)&unk_1E14A9D68;
          v154[0] = type;
          nw_protocol_options_access_handle(v55, buf);
          v56 = *(_BYTE *)(*(_QWORD *)&type[8] + 24) == 0;
          _Block_object_dispose(type, 8);

          if (v56)
            v57 = 0;
          else
            v57 = 64;
LABEL_79:
          HIWORD(a1[2].output_handler_context) = HIWORD(a1[2].output_handler_context) & 0xFFBF | v57;
          if (nw_udp_options_get_no_metadata(v55))
            v58 = 32;
          else
            v58 = 0;
          HIWORD(a1[2].output_handler_context) = HIWORD(a1[2].output_handler_context) & 0xFFDF | v58;
          os_release(v55);
          goto LABEL_83;
        }
        __nwlog_obj();
        v136 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_udp_options_get_ignore_inbound_checksum";
        v137 = (char *)_os_log_send_and_compose_impl();

        v151 = OS_LOG_TYPE_ERROR;
        v150 = 0;
        if ((__nwlog_fault(v137, &v151, &v150) & 1) != 0)
        {
          if (v151 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v138 = objc_claimAutoreleasedReturnValue();
            v139 = v151;
            if (os_log_type_enabled(v138, v151))
            {
              *(_DWORD *)type = 136446210;
              *(_QWORD *)&type[4] = "nw_udp_options_get_ignore_inbound_checksum";
              _os_log_impl(&dword_182FBE000, v138, v139, "%{public}s called with null nw_protocol_options_is_udp(options)", type, 0xCu);
            }
          }
          else if (v150)
          {
            v143 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v138 = objc_claimAutoreleasedReturnValue();
            v144 = v151;
            v145 = os_log_type_enabled(v138, v151);
            if (v143)
            {
              if (v145)
              {
                *(_DWORD *)type = 136446466;
                *(_QWORD *)&type[4] = "nw_udp_options_get_ignore_inbound_checksum";
                *(_WORD *)&type[12] = 2082;
                *(_QWORD *)&type[14] = v143;
                _os_log_impl(&dword_182FBE000, v138, v144, "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s", type, 0x16u);
              }

              free(v143);
              goto LABEL_342;
            }
            if (v145)
            {
              *(_DWORD *)type = 136446210;
              *(_QWORD *)&type[4] = "nw_udp_options_get_ignore_inbound_checksum";
              _os_log_impl(&dword_182FBE000, v138, v144, "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace", type, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v138 = objc_claimAutoreleasedReturnValue();
            v149 = v151;
            if (os_log_type_enabled(v138, v151))
            {
              *(_DWORD *)type = 136446210;
              *(_QWORD *)&type[4] = "nw_udp_options_get_ignore_inbound_checksum";
              _os_log_impl(&dword_182FBE000, v138, v149, "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded", type, 0xCu);
            }
          }

        }
LABEL_342:
        if (v137)
          free(v137);

        v57 = 0;
        goto LABEL_79;
      }
LABEL_66:
      if (a2->handle == &nw_protocol_ref_counted_handle)
      {
        v71 = a2[1].callbacks;
        if (v71)
        {
          v72 = (nw_protocol_callbacks *)((char *)v71 - 1);
          a2[1].callbacks = v72;
          if (!v72)
          {
            v73 = *(void (***)(_QWORD))a2[1].flow_id;
            if (v73)
            {
              *(_QWORD *)a2[1].flow_id = 0;
              v73[2](v73);
              _Block_release(v73);
            }
            if ((a2[1].flow_id[8] & 1) != 0)
            {
              v74 = *(const void **)a2[1].flow_id;
              if (v74)
                _Block_release(v74);
            }
            free(a2);
          }
        }
      }
      goto LABEL_67;
    }
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
  v99 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v151 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v99, type, &v151))
  {
    if (type[0] == 17)
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (!os_log_type_enabled(v100, (os_log_type_t)type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null (remote_address && nw_endpoint_get_type(remote_address) == nw_endpoint_type_address)";
      goto LABEL_203;
    }
    if (v151)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v100 = __nwlog_obj();
      v101 = type[0];
      v130 = os_log_type_enabled(v100, (os_log_type_t)type[0]);
      if (backtrace_string)
      {
        if (!v130)
          goto LABEL_198;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v105 = "%{public}s called with null (remote_address && nw_endpoint_get_type(remote_address) == nw_endpoint_type_a"
               "ddress), dumping backtrace:%{public}s";
        goto LABEL_197;
      }
      if (!v130)
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null (remote_address && nw_endpoint_get_type(remote_address) == nw_endpoint_type_add"
             "ress), no backtrace";
    }
    else
    {
      v100 = __nwlog_obj();
      v101 = type[0];
      if (!os_log_type_enabled(v100, (os_log_type_t)type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_udp_add_input_handler";
      v102 = "%{public}s called with null (remote_address && nw_endpoint_get_type(remote_address) == nw_endpoint_type_add"
             "ress), backtrace limit exceeded";
    }
LABEL_203:
    _os_log_impl(&dword_182FBE000, v100, v101, v102, buf, 0xCu);
  }
LABEL_204:
  if (v99)
    free(v99);
  return 0;
}

void sub_1831AD204(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_udp_options_get_prefer_no_checksum(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_udp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_udp_options_get_prefer_no_checksum_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_udp_options_get_prefer_no_checksum";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_udp_options_get_prefer_no_checksum";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_udp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_udp_options_get_prefer_no_checksum";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_udp_options_get_prefer_no_checksum";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_udp_options_get_prefer_no_checksum";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831AD54C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_udp_options_get_no_metadata(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_udp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_udp_options_get_no_metadata_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_udp_options_get_no_metadata";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_udp_options_get_no_metadata";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_udp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_udp_options_get_no_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_udp_options_get_no_metadata";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_udp_options_get_no_metadata";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831AD878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_add_new_flow(void *a1, char a2, int a3, void *a4, void *a5, void *a6)
{
  char *v11;
  id v12;
  void (**v13)(id, void *);
  id v14;
  void *v15;
  dispatch_queue_t *v16;
  dispatch_queue_t *v17;
  id v18;
  _BOOL8 v19;
  _QWORD *v20;
  void *v21;
  unint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  id v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  char v30;
  _QWORD *v31;
  uint64_t (***v32)(void);
  uint64_t (*v33)(void);
  void *v34;
  char *v35;
  os_log_type_t v36;
  _BOOL4 v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  void *v41;
  os_log_type_t v42;
  void *v44;
  char *v45;
  NSObject *v46;
  os_log_type_t v47;
  char *backtrace_string;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  char v52;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  char *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  char *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  if (!v11)
  {
    __nwlog_obj();
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_instance_add_new_flow";
    v45 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (__nwlog_fault(v45, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v46 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if (v52)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v46 = objc_claimAutoreleasedReturnValue();
        v49 = type;
        v50 = os_log_type_enabled(v46, type);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            v55 = "nw_protocol_instance_add_new_flow";
            v56 = 2082;
            v57 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v46, v49, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_83;
        }
        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_182FBE000, v46, v49, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v46 = objc_claimAutoreleasedReturnValue();
        v51 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v55 = "nw_protocol_instance_add_new_flow";
          _os_log_impl(&dword_182FBE000, v46, v51, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_83:
    if (v45)
      free(v45);
    goto LABEL_14;
  }
  v15 = (void *)*((_QWORD *)v11 + 15);
  if (v15)
  {
    v16 = v15;
    v17 = v16;
    if (((_BYTE)v16[17] & 8) == 0)
      dispatch_assert_queue_V2(v16[1]);

  }
  if (nw_protocol_definition_get_variant(*((void **)v11 + 1)) == 3)
  {
    v18 = *((id *)v11 + 6);
    v19 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v18, 0, 0);

    if (v19)
    {
      v20 = (id)v19;
      v21 = v20;
      if ((a2 & 1) != 0)
      {
        *(_DWORD *)(v20[13] + 84) = 0;
        v22 = v20[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;
        v20[12] = v22;
        v23 = 0x8000;
      }
      else
      {
        v23 = 0;
        v22 = v20[12];
      }
      v20[12] = v22 & 0xFFFFFFFFFFFF7FFFLL | v23;

      if (v13)
        v13[2](v13, v21);
      if (a3)
        v30 = 3;
      else
        v30 = 1;
      v11[404] = v30 | v11[404] & 0xFC;
      *((_QWORD *)v11 + 31) = 0;
      objc_storeStrong((id *)v11 + 32, a4);
      if (v14)
      {
        v31 = nw_connection_create_from_protocol_on_nw_queue(*((void **)v11 + 5), v21, (nw_protocol *)(v11 - 96));
        if (v31)
        {
          (*((void (**)(id, _QWORD, _QWORD *))v14 + 2))(v14, *((_QWORD *)v11 + 31), v31);

LABEL_34:
          v11[404] &= 0xFCu;
          v34 = (void *)*((_QWORD *)v11 + 32);
          *((_QWORD *)v11 + 32) = 0;

          v25 = *((_QWORD *)v11 + 31);
LABEL_65:

          goto LABEL_66;
        }
        if ((v11[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = (id)gLogObj;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v55 = "nw_protocol_instance_add_new_flow";
            v56 = 2082;
            v57 = v11 + 407;
            v58 = 2080;
            v59 = " ";
            _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%snw_connection_create_from_protocol_on_nw_queue failed", buf, 0x20u);
          }

        }
      }
      else
      {
        v32 = (uint64_t (***)(void))*((_QWORD *)v11 + 3);
        if (v32)
        {
          if (*v32)
          {
            v33 = **v32;
            if (v33)
            {
              if ((v33() & 1) != 0)
                goto LABEL_34;
            }
          }
          if ((v11[405] & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v40 = (id)gLogObj;
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              v55 = "nw_protocol_instance_add_new_flow";
              v56 = 2082;
              v57 = v11 + 407;
              v58 = 2080;
              v59 = " ";
              _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sListener rejected new flow", buf, 0x20u);
            }

          }
        }
        else if ((v11[405] & 0x80000000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v39 = (id)gLogObj;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v55 = "nw_protocol_instance_add_new_flow";
            v56 = 2082;
            v57 = v11 + 407;
            v58 = 2080;
            v59 = " ";
            _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNo listener registered, cannot accept new flow", buf, 0x20u);
          }

        }
      }
      v11[404] &= 0xFCu;
      v41 = (void *)*((_QWORD *)v11 + 32);
      *((_QWORD *)v11 + 32) = 0;

LABEL_64:
      v25 = 0;
      goto LABEL_65;
    }
    if (v11[405] < 0)
      goto LABEL_64;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    v55 = "nw_protocol_instance_add_new_flow";
    v56 = 2082;
    v57 = v11 + 407;
    v58 = 2080;
    v59 = " ";
    v27 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (__nwlog_fault(v27, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          v55 = "nw_protocol_instance_add_new_flow";
          v56 = 2082;
          v57 = v11 + 407;
          v58 = 2080;
          v59 = " ";
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow", buf, 0x20u);
        }
      }
      else if (v52)
      {
        v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        v36 = type;
        v37 = os_log_type_enabled(v28, type);
        if (v35)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446978;
            v55 = "nw_protocol_instance_add_new_flow";
            v56 = 2082;
            v57 = v11 + 407;
            v58 = 2080;
            v59 = " ";
            v60 = 2082;
            v61 = v35;
            _os_log_impl(&dword_182FBE000, v28, v36, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v35);
          if (!v27)
            goto LABEL_64;
          goto LABEL_63;
        }
        if (v37)
        {
          *(_DWORD *)buf = 136446722;
          v55 = "nw_protocol_instance_add_new_flow";
          v56 = 2082;
          v57 = v11 + 407;
          v58 = 2080;
          v59 = " ";
          _os_log_impl(&dword_182FBE000, v28, v36, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        v42 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          v55 = "nw_protocol_instance_add_new_flow";
          v56 = 2082;
          v57 = v11 + 407;
          v58 = 2080;
          v59 = " ";
          _os_log_impl(&dword_182FBE000, v28, v42, "%{public}s %{public}s%sInstance parameters are NULL when opening inbound flow, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
    if (!v27)
      goto LABEL_64;
LABEL_63:
    free(v27);
    goto LABEL_64;
  }
  if ((v11[405] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = (id)gLogObj;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v55 = "nw_protocol_instance_add_new_flow";
      v56 = 2082;
      v57 = v11 + 407;
      v58 = 2080;
      v59 = " ";
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot add new flows to a non-multiplexing protocol", buf, 0x20u);
    }

  }
LABEL_14:
  v25 = 0;
LABEL_66:

  return v25;
}

void sub_1831AE2E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_instance_set_flow_for_key(void *a1, const void *a2, uint64_t a3)
{
  void **v5;
  void **v6;
  size_t v7;
  uint64_t internal;
  _DWORD *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint32_t v18;
  NSObject *v19;
  _BOOL8 result;
  id v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  void *v29;
  os_log_type_t v30;
  void *v31;
  os_log_type_t v32;
  void *v33;
  os_log_type_t v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  _BOOL4 v38;
  os_log_type_t v39;
  _BOOL4 v40;
  NSObject *v41;
  void *v42;
  os_log_type_t v43;
  os_log_type_t v44;
  os_log_type_t v45;
  char v46;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  const void *v55;
  __int16 v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_instance_set_flow_for_key";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v30, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (!v46)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v43 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v43, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      v36 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v35, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v49 = "nw_protocol_instance_set_flow_for_key";
        v50 = 2082;
        v51 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v23, v35, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_45;
    }
    goto LABEL_52;
  }
  if (!a2)
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_instance_set_flow_for_key";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v32, "%{public}s called with null key", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (!v46)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v44, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      v38 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v37, "%{public}s called with null key, no backtrace", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        v49 = "nw_protocol_instance_set_flow_for_key";
        v50 = 2082;
        v51 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v23, v37, "%{public}s called with null key, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_45;
    }
    goto LABEL_52;
  }
  if (!a3)
  {
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_instance_set_flow_for_key";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v22, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v34 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v34, "%{public}s called with null flow", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (!v46)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v45 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v45, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_51;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v23, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v49 = "nw_protocol_instance_set_flow_for_key";
          _os_log_impl(&dword_182FBE000, v23, v39, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
        goto LABEL_51;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v49 = "nw_protocol_instance_set_flow_for_key";
        v50 = 2082;
        v51 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v23, v39, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_45;
    }
LABEL_52:
    if (v22)
      free(v22);
    goto LABEL_29;
  }
  if (nw_protocol_definition_get_variant(v5[1]) != 3)
  {
    if (*((char *)v6 + 405) < 0)
      goto LABEL_29;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)v6 + 407;
      v52 = 2080;
      v53 = " ";
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot use custom flow mapping table on a non-multiplexing protocol", buf, 0x20u);
    }
LABEL_28:

    goto LABEL_29;
  }
  v7 = *(unsigned int *)(*((_QWORD *)v6[1] + 10) + 256);
  if (!(_DWORD)v7)
  {
    if (*((char *)v6 + 405) < 0)
      goto LABEL_29;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)v6 + 407;
      v52 = 2080;
      v53 = " ";
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sThe size of the key data in the protocol definition must be specified before using the custom flow map. See nw_protocol_definition_set_custom_flow_map_key_size.", buf, 0x20u);
    }
    goto LABEL_28;
  }
  if (v6[30])
    goto LABEL_9;
  internal = nw_hash_table_create_internal(0x1Fu, 8, (const void *(*)(const void *, unsigned int *))nw_protocol_custom_mapping_get_key, (unsigned int (*)(const void *, unsigned int))nw_protocol_custom_mapping_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_custom_mapping_matches_key, nw_protocol_custom_mapping_release_object);
  if (!internal)
  {
    v6[30] = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_instance_set_flow_for_key";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (id)gLogObj;
      v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s nw_hash_table_create_no_lock failed", buf, 0xCu);
      }
LABEL_51:

      goto LABEL_52;
    }
    if (!v46)
    {
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl(&dword_182FBE000, v23, v28, "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    v26 = type;
    v27 = os_log_type_enabled(v23, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_instance_set_flow_for_key";
        _os_log_impl(&dword_182FBE000, v23, v26, "%{public}s nw_hash_table_create_no_lock failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_51;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v23, v26, "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_45:

    free(backtrace_string);
    goto LABEL_52;
  }
  *(_DWORD *)(internal + 48) &= ~2u;
  v6[30] = (void *)internal;
LABEL_9:
  v9 = malloc_type_calloc(1uLL, v7 + 4, 0xEAFB8F1AuLL);
  if (v9)
  {
LABEL_10:
    *v9 = v7;
    memcpy(v9 + 1, a2, v7);
    type = OS_LOG_TYPE_DEFAULT;
    v10 = nw_hash_table_add_object((uint64_t)v6[30], (uint64_t)v9, (char *)&type);
    if (type)
      v11 = v10 == 0;
    else
      v11 = 1;
    v12 = !v11;
    if (!v11)
    {
      *(_QWORD *)(v10 + 32) = a3;
      v13 = 1;
      if (*((char *)v6 + 405) < 0 || !gLogDatapath)
        goto LABEL_30;
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        goto LABEL_35;
      *(_DWORD *)buf = 136447234;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)v6 + 407;
      v52 = 2080;
      v53 = " ";
      v54 = 2048;
      v55 = a2;
      v56 = 2048;
      v57 = a3;
      v15 = "%{public}s %{public}s%sAdded key %p to custom flow mapping table for flow id: %llx";
      v16 = v14;
      v17 = OS_LOG_TYPE_DEBUG;
      v18 = 52;
      goto LABEL_34;
    }
    if ((*((char *)v6 + 405) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (id)gLogObj;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
LABEL_35:

        v13 = v12;
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446978;
      v49 = "nw_protocol_instance_set_flow_for_key";
      v50 = 2082;
      v51 = (uint64_t)v6 + 407;
      v52 = 2080;
      v53 = " ";
      v54 = 2048;
      v55 = a2;
      v15 = "%{public}s %{public}s%sFailed to add key %p to custom flow mapping table";
      v16 = v14;
      v17 = OS_LOG_TYPE_ERROR;
      v18 = 42;
LABEL_34:
      _os_log_impl(&dword_182FBE000, v16, v17, v15, buf, v18);
      goto LABEL_35;
    }
LABEL_29:
    v13 = 0;
LABEL_30:

    return v13;
  }
  __nwlog_obj();
  v41 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v49 = "strict_calloc";
  v50 = 2048;
  v51 = 1;
  v52 = 2048;
  v53 = (const char *)(v7 + 4);
  v42 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v42);
  if (!result)
  {
    free(v42);
    goto LABEL_10;
  }
  __break(1u);
  return result;
}

void sub_1831AEFE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_definition_get_variant(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[16];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_get_variant";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_get_variant";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_get_variant";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

_QWORD *nw_connection_create_from_protocol_on_nw_queue(void *a1, void *a2, nw_protocol *a3)
{
  id v5;
  id v6;
  _QWORD *v7;
  id v8;
  _QWORD *v9;
  _BOOL8 v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t (*v17)(uint64_t, uint64_t);
  uint64_t v18;
  NSObject *v19;
  int v20;
  void *v21;
  unsigned int v22;
  id v23;
  id v24;
  id *v25;
  id *v26;
  id v27;
  NWConcrete_nw_endpoint_flow *v28;
  id v29;
  id *v30;
  id v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  id v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  id v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  NSObject *v46;
  const char *v47;
  nw_endpoint_t v48;
  const char *v49;
  uint64_t v50;
  const char *v51;
  char *v52;
  os_log_type_t v53;
  _BOOL4 v54;
  char *v55;
  os_log_type_t v56;
  _BOOL4 v57;
  os_log_type_t v58;
  _QWORD *v59;
  os_log_type_t v60;
  os_unfair_lock_s *v61;
  const char *v62;
  os_log_type_t v63;
  os_unfair_lock_s *v64;
  id *v65;
  id v66;
  void *v67;
  uint64_t v68;
  NSObject *v69;
  int v70;
  const char *logging_description;
  NSObject *v72;
  int v73;
  void *v74;
  void *v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  void *v80;
  os_log_type_t v81;
  char *v82;
  os_log_type_t v83;
  _BOOL4 v84;
  os_log_type_t v85;
  _BOOL4 v86;
  void *v87;
  char *v88;
  NSObject *v89;
  os_log_type_t v90;
  void *v91;
  os_log_type_t v92;
  char *backtrace_string;
  os_log_type_t v94;
  _BOOL4 v95;
  char *v96;
  os_log_type_t v97;
  _BOOL4 v98;
  os_log_type_t v99;
  os_log_type_t v100;
  os_log_type_t v101;
  os_log_type_t v102;
  const char *v103;
  const char *v104;
  const char *v105;
  const char *v106;
  nw_endpoint_t v107;
  void *v108;
  _QWORD *v109;
  id v110;
  void *v111;
  char v112;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v115;
  __int16 v116;
  _BYTE v117[18];
  __int16 v118;
  const char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  const char *v123;
  __int16 v124;
  id v125;
  uint64_t v126;

  v126 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  nw_allow_use_of_dispatch_internal();
  v111 = v5;
  if (v5)
  {
    if (v6)
    {
      v7 = v6;
      v8 = *(id *)(v7[13] + 136);

      nw_context_assert_queue(v8);
      v9 = v7;
      v10 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v9, 0, 0);
      v110 = v6;

      if (v10)
      {
        v11 = (id)v10;
        v11[12] = v11[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;

        v12 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]((void **)[NWConcrete_nw_connection alloc], v5, v11, 0);
        v13 = v12;
        if (v12)
        {
          v14 = *(_QWORD *)(v12 + 8);
          v15 = *(_QWORD *)(v12 + 16);
          nw_allow_use_of_dispatch_internal();
          if (has_modifiers == 1)
          {
            os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
            v16 = (_QWORD *)g_modifier_list;
            if (g_modifier_list)
            {
              while (1)
              {
                v17 = (uint64_t (*)(uint64_t, uint64_t))v16[2];
                if (v17)
                {
                  if ((v17(v14, v15) & 1) != 0)
                    break;
                }
                v16 = (_QWORD *)*v16;
                if (!v16)
                  goto LABEL_7;
              }
              os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
              v18 = *(_QWORD *)(v13 + 16);
              if (!v18)
              {
                v21 = 0;
LABEL_19:
                *(_BYTE *)(v13 + 109) |= 4u;
                v22 = *(_DWORD *)(v13 + 448);
                v23 = *(id *)(v13 + 8);
                v24 = v21;
                v108 = v24;
                v109 = (id)v13;
                if (!v23)
                {
                  __nwlog_obj();
                  v87 = (void *)objc_claimAutoreleasedReturnValue();
                  *(_DWORD *)buf = 136446210;
                  v115 = "nw_endpoint_handler_create_from_protocol_listener";
                  v88 = (char *)_os_log_send_and_compose_impl();

                  type = OS_LOG_TYPE_ERROR;
                  v112 = 0;
                  if (!__nwlog_fault(v88, &type, &v112))
                    goto LABEL_193;
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    v89 = objc_claimAutoreleasedReturnValue();
                    v90 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s called with null endpoint", buf, 0xCu);
                    }
                  }
                  else if (v112)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    v89 = objc_claimAutoreleasedReturnValue();
                    v94 = type;
                    v95 = os_log_type_enabled(v89, type);
                    if (backtrace_string)
                    {
                      if (v95)
                      {
                        *(_DWORD *)buf = 136446466;
                        v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        v116 = 2082;
                        *(_QWORD *)v117 = backtrace_string;
                        _os_log_impl(&dword_182FBE000, v89, v94, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
                      }

                      free(backtrace_string);
                      if (!v88)
                        goto LABEL_195;
                      goto LABEL_194;
                    }
                    if (v95)
                    {
                      *(_DWORD *)buf = 136446210;
                      v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_182FBE000, v89, v94, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
                    }
                  }
                  else
                  {
                    __nwlog_obj();
                    v89 = objc_claimAutoreleasedReturnValue();
                    v101 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_182FBE000, v89, v101, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
                    }
                  }
                  goto LABEL_192;
                }
                if (v24)
                {
                  v25 = -[NWConcrete_nw_endpoint_handler initWithEndpoint:parameters:reportCallback:context:parent:identifier:]((id *)[NWConcrete_nw_endpoint_handler alloc], v23, v24, nw_connection_endpoint_report_on_nw_queue, v109, 0, v22);
                  v26 = v25;
                  if (v25)
                  {
                    *((_DWORD *)v25 + 29) = 2;
                    v27 = v25[9];
                    v28 = objc_alloc_init(NWConcrete_nw_endpoint_flow);
                    *((_BYTE *)v28 + 32) = *((_BYTE *)v28 + 32) & 0xFC | (v27 == 0) | 2;
                    v29 = v26[31];
                    v26[31] = v28;

                    if (nw_endpoint_flow_pre_attach_protocols(v26, a3))
                    {
                      v30 = v26;
LABEL_103:

LABEL_104:
                      v67 = (void *)v109[18];
                      v109[18] = v30;

                      v68 = *(_QWORD *)(v13 + 16);
                      if (v109[18])
                      {
                        if (v68 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v68 + 104)))
                        {
                          if (__nwlog_connection_log::onceToken != -1)
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                          v69 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v69, OS_LOG_TYPE_INFO))
                          {
                            v70 = *(_DWORD *)(v13 + 448);
                            logging_description = nw_endpoint_get_logging_description(v111);
                            *(_DWORD *)buf = 136446722;
                            v115 = "nw_connection_create_from_protocol_on_nw_queue";
                            v116 = 1024;
                            *(_DWORD *)v117 = v70;
                            *(_WORD *)&v117[4] = 2082;
                            *(_QWORD *)&v117[6] = logging_description;
                            _os_log_impl(&dword_182FBE000, v69, OS_LOG_TYPE_INFO, "%{public}s [C%u] create connection to %{public}s", buf, 0x1Cu);
                          }

                        }
                        v59 = v109;
                        goto LABEL_121;
                      }
                      if (v68 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v68 + 104)))
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v72 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                        {
                          v73 = *(_DWORD *)(v13 + 448);
                          *(_DWORD *)buf = 136446466;
                          v115 = "nw_connection_create_from_protocol_on_nw_queue";
                          v116 = 1024;
                          *(_DWORD *)v117 = v73;
                          _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Failed to create connection from listener", buf, 0x12u);
                        }

                      }
LABEL_120:
                      v59 = 0;
LABEL_121:

                      goto LABEL_122;
                    }
                    if ((*((_BYTE *)v26 + 268) & 0x20) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v46 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                      {
                        if ((*((_BYTE *)v26 + 268) & 1) != 0)
                          v47 = "dry-run ";
                        else
                          v47 = "";
                        v48 = nw_endpoint_handler_copy_endpoint(v26);
                        v49 = nw_endpoint_get_logging_description(v48);
                        v50 = *((unsigned int *)v26 + 30);
                        v106 = v47;
                        v107 = v48;
                        v105 = v49;
                        if (v50 > 5)
                          v51 = "unknown-state";
                        else
                          v51 = off_1E149FC48[v50];
                        v103 = v51;
                        v61 = v26;
                        v62 = "path";
                        switch(*((_DWORD *)v26 + 29))
                        {
                          case 0:
                            break;
                          case 1:
                            v62 = "resolver";
                            break;
                          case 2:
                            v62 = nw_endpoint_flow_mode_string(v26[31]);
                            break;
                          case 3:
                            v62 = "proxy";
                            break;
                          case 4:
                            v62 = "fallback";
                            break;
                          case 5:
                            v62 = "transform";
                            break;
                          default:
                            v62 = "unknown-mode";
                            break;
                        }
                        v104 = v62;

                        v64 = v61 + 28;
                        v65 = v61;
                        os_unfair_lock_lock(v61 + 28);
                        v66 = v65[8];
                        os_unfair_lock_unlock(v64);

                        *(_DWORD *)buf = 136447746;
                        v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        v116 = 2082;
                        *(_QWORD *)v117 = v26 + 21;
                        *(_WORD *)&v117[8] = 2082;
                        *(_QWORD *)&v117[10] = v106;
                        v118 = 2082;
                        v119 = v105;
                        v120 = 2082;
                        v121 = v103;
                        v122 = 2082;
                        v123 = v104;
                        v124 = 2114;
                        v125 = v66;
                        _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nw_endpoint_flow_pre_attach_protocols", buf, 0x48u);

                      }
                    }
                    nw_endpoint_handler_cancel(v26, 1, 0);
LABEL_102:
                    v30 = 0;
                    goto LABEL_103;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v42 = (id)gLogObj;
                  *(_DWORD *)buf = 136446210;
                  v115 = "nw_endpoint_handler_create_from_protocol_listener";
                  v43 = (char *)_os_log_send_and_compose_impl();

                  type = OS_LOG_TYPE_ERROR;
                  v112 = 0;
                  if ((__nwlog_fault(v43, &type, &v112) & 1) != 0)
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v44 = (id)gLogObj;
                      v45 = type;
                      if (os_log_type_enabled(v44, type))
                      {
                        *(_DWORD *)buf = 136446210;
                        v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed", buf, 0xCu);
                      }
                    }
                    else if (v112)
                    {
                      v55 = (char *)__nw_create_backtrace_string();
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v44 = (id)gLogObj;
                      v56 = type;
                      v57 = os_log_type_enabled(v44, type);
                      if (v55)
                      {
                        if (v57)
                        {
                          *(_DWORD *)buf = 136446466;
                          v115 = "nw_endpoint_handler_create_from_protocol_listener";
                          v116 = 2082;
                          *(_QWORD *)v117 = v55;
                          _os_log_impl(&dword_182FBE000, v44, v56, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", buf, 0x16u);
                        }

                        free(v55);
                        if (!v43)
                          goto LABEL_102;
                        goto LABEL_93;
                      }
                      if (v57)
                      {
                        *(_DWORD *)buf = 136446210;
                        v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl(&dword_182FBE000, v44, v56, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, no backtrace", buf, 0xCu);
                      }
                    }
                    else
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v44 = (id)gLogObj;
                      v63 = type;
                      if (os_log_type_enabled(v44, type))
                      {
                        *(_DWORD *)buf = 136446210;
                        v115 = "nw_endpoint_handler_create_from_protocol_listener";
                        _os_log_impl(&dword_182FBE000, v44, v63, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, backtrace limit exceeded", buf, 0xCu);
                      }
                    }

                  }
                  if (!v43)
                    goto LABEL_102;
LABEL_93:
                  free(v43);
                  goto LABEL_102;
                }
                __nwlog_obj();
                v91 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136446210;
                v115 = "nw_endpoint_handler_create_from_protocol_listener";
                v88 = (char *)_os_log_send_and_compose_impl();

                type = OS_LOG_TYPE_ERROR;
                v112 = 0;
                if (__nwlog_fault(v88, &type, &v112))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    v89 = objc_claimAutoreleasedReturnValue();
                    v92 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_182FBE000, v89, v92, "%{public}s called with null parameters", buf, 0xCu);
                    }
LABEL_192:

                    goto LABEL_193;
                  }
                  if (!v112)
                  {
                    __nwlog_obj();
                    v89 = objc_claimAutoreleasedReturnValue();
                    v102 = type;
                    if (os_log_type_enabled(v89, type))
                    {
                      *(_DWORD *)buf = 136446210;
                      v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_182FBE000, v89, v102, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
                    }
                    goto LABEL_192;
                  }
                  v96 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v89 = objc_claimAutoreleasedReturnValue();
                  v97 = type;
                  v98 = os_log_type_enabled(v89, type);
                  if (!v96)
                  {
                    if (v98)
                    {
                      *(_DWORD *)buf = 136446210;
                      v115 = "nw_endpoint_handler_create_from_protocol_listener";
                      _os_log_impl(&dword_182FBE000, v89, v97, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
                    }
                    goto LABEL_192;
                  }
                  if (v98)
                  {
                    *(_DWORD *)buf = 136446466;
                    v115 = "nw_endpoint_handler_create_from_protocol_listener";
                    v116 = 2082;
                    *(_QWORD *)v117 = v96;
                    _os_log_impl(&dword_182FBE000, v89, v97, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v96);
                }
LABEL_193:
                if (!v88)
                {
LABEL_195:
                  v30 = 0;
                  goto LABEL_104;
                }
LABEL_194:
                free(v88);
                goto LABEL_195;
              }
              if (!nw_path_parameters_get_logging_disabled(*(_QWORD *)(v18 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v19 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
                {
                  v20 = *(_DWORD *)(v13 + 448);
                  *(_DWORD *)buf = 136446466;
                  v115 = "nw_connection_create_from_protocol_on_nw_queue";
                  v116 = 1024;
                  *(_DWORD *)v117 = v20;
                  _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Connection parameters were modified", buf, 0x12u);
                }

              }
            }
            else
            {
LABEL_7:
              os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
            }
          }
          v21 = *(void **)(v13 + 16);
          goto LABEL_19;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v115 = "nw_connection_create_from_protocol_on_nw_queue";
        v36 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v112 = 0;
        if (__nwlog_fault(v36, &type, &v112))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v37 = (id)gLogObj;
            v38 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s [nw_connection initWithEndpoint:parameters:] failed", buf, 0xCu);
            }
          }
          else if (v112)
          {
            v52 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v37 = (id)gLogObj;
            v53 = type;
            v54 = os_log_type_enabled(v37, type);
            if (v52)
            {
              if (v54)
              {
                *(_DWORD *)buf = 136446466;
                v115 = "nw_connection_create_from_protocol_on_nw_queue";
                v116 = 2082;
                *(_QWORD *)v117 = v52;
                _os_log_impl(&dword_182FBE000, v37, v53, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v52);
              if (!v36)
                goto LABEL_120;
              goto LABEL_85;
            }
            if (v54)
            {
              *(_DWORD *)buf = 136446210;
              v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl(&dword_182FBE000, v37, v53, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v37 = (id)gLogObj;
            v60 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              v115 = "nw_connection_create_from_protocol_on_nw_queue";
              _os_log_impl(&dword_182FBE000, v37, v60, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
        if (!v36)
          goto LABEL_120;
LABEL_85:
        free(v36);
        goto LABEL_120;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v115 = "nw_connection_create_from_protocol_on_nw_queue";
      v32 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v112 = 0;
      if (__nwlog_fault(v32, &type, &v112))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s nw_parameters_copy failed", buf, 0xCu);
          }
        }
        else if (v112)
        {
          v39 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          v40 = type;
          v41 = os_log_type_enabled(v33, type);
          if (v39)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              v115 = "nw_connection_create_from_protocol_on_nw_queue";
              v116 = 2082;
              *(_QWORD *)v117 = v39;
              _os_log_impl(&dword_182FBE000, v33, v40, "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v39);
            if (!v32)
              goto LABEL_74;
            goto LABEL_73;
          }
          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_182FBE000, v33, v40, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          v58 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v115 = "nw_connection_create_from_protocol_on_nw_queue";
            _os_log_impl(&dword_182FBE000, v33, v58, "%{public}s nw_parameters_copy failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v32)
      {
LABEL_74:
        v59 = 0;
LABEL_122:

        v74 = v110;
        goto LABEL_123;
      }
LABEL_73:
      free(v32);
      goto LABEL_74;
    }
    v74 = 0;
    __nwlog_obj();
    v80 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v115 = "nw_connection_create_from_protocol_on_nw_queue";
    v77 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v112 = 0;
    if (__nwlog_fault(v77, &type, &v112))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v78 = objc_claimAutoreleasedReturnValue();
        v81 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v78, v81, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_176:

        goto LABEL_177;
      }
      if (!v112)
      {
        __nwlog_obj();
        v78 = objc_claimAutoreleasedReturnValue();
        v100 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v78, v100, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_176;
      }
      v82 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v85 = type;
      v86 = os_log_type_enabled(v78, type);
      if (!v82)
      {
        if (v86)
        {
          *(_DWORD *)buf = 136446210;
          v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v78, v85, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_176;
      }
      if (v86)
      {
        *(_DWORD *)buf = 136446466;
        v115 = "nw_connection_create_from_protocol_on_nw_queue";
        v116 = 2082;
        *(_QWORD *)v117 = v82;
        _os_log_impl(&dword_182FBE000, v78, v85, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_143;
    }
  }
  else
  {
    v74 = v6;
    __nwlog_obj();
    v76 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v115 = "nw_connection_create_from_protocol_on_nw_queue";
    v77 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v112 = 0;
    if (__nwlog_fault(v77, &type, &v112))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v78 = objc_claimAutoreleasedReturnValue();
        v79 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_176;
      }
      if (!v112)
      {
        __nwlog_obj();
        v78 = objc_claimAutoreleasedReturnValue();
        v99 = type;
        if (os_log_type_enabled(v78, type))
        {
          *(_DWORD *)buf = 136446210;
          v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v78, v99, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_176;
      }
      v82 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v83 = type;
      v84 = os_log_type_enabled(v78, type);
      if (!v82)
      {
        if (v84)
        {
          *(_DWORD *)buf = 136446210;
          v115 = "nw_connection_create_from_protocol_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v78, v83, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_176;
      }
      if (v84)
      {
        *(_DWORD *)buf = 136446466;
        v115 = "nw_connection_create_from_protocol_on_nw_queue";
        v116 = 2082;
        *(_QWORD *)v117 = v82;
        _os_log_impl(&dword_182FBE000, v78, v83, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_143:

      free(v82);
    }
  }
LABEL_177:
  if (v77)
    free(v77);
  v59 = 0;
LABEL_123:

  return v59;
}

void sub_1831B0920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;

  _Unwind_Resume(a1);
}

void sub_1831B12D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_endpoint_transform_add_children(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  unsigned int mode;
  NWConcrete_nw_endpoint_mode_handler *v4;
  NWConcrete_nw_endpoint_handler *v5;
  OS_nw_path *v6;
  id *v7;
  id v8;
  unsigned __int8 *v9;
  id v10;
  NWConcrete_nw_endpoint_mode_handler *v11;
  id *v12;
  OS_nw_path *v13;
  id v14;
  id v15;
  NWConcrete_nw_parameters *v16;
  id *inner;
  uint64_t v18;
  _BOOL8 v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  void *combined_array;
  void *v26;
  xpc_object_t v27;
  void *v28;
  void *v29;
  void *v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  char *backtrace_string;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  id v38;
  const char *v39;
  void *v40;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  char *v44;
  os_log_type_t v45;
  _BOOL4 v46;
  const char *v47;
  os_log_type_t v48;
  const char *v49;
  const char *v50;
  _QWORD applier[4];
  NWConcrete_nw_endpoint_mode_handler *v52;
  _QWORD v53[4];
  id v54;
  NWConcrete_nw_endpoint_mode_handler *v55;
  id *v56;
  OS_nw_path *v57;
  uint64_t *v58;
  _BYTE *v59;
  os_log_type_t *v60;
  os_log_type_t type[8];
  os_log_type_t *v62;
  uint64_t v63;
  uint64_t (*v64)(uint64_t, uint64_t);
  void (*v65)(uint64_t);
  id v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  char v70;
  __int128 v71;
  _BYTE buf[24];
  uint64_t (*v73)(uint64_t, uint64_t);
  __int128 v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
    v31 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v67) = 0;
    if (__nwlog_fault(v31, type, &v67))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v32 = objc_claimAutoreleasedReturnValue();
        v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if ((_BYTE)v67)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v32 = objc_claimAutoreleasedReturnValue();
        v35 = type[0];
        v36 = os_log_type_enabled(v32, type[0]);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v32, v35, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v32, v35, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v32 = objc_claimAutoreleasedReturnValue();
        v37 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v32, v37, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_32:
    if (v31)
      free(v31);
    mode = 0;
    goto LABEL_35;
  }
  mode = v1->mode;

  if (mode == 5)
  {
    v4 = nw_endpoint_handler_copy_transform(v2);
    v5 = v2;
    os_unfair_lock_lock(&v5->lock);
    v6 = v5->current_path;
    os_unfair_lock_unlock(&v5->lock);

    v67 = 0;
    v68 = &v67;
    v69 = 0x2020000000;
    v70 = 1;
    v7 = v5;
    v8 = v7[4];

    v9 = (unsigned __int8 *)nw_parameters_copy_transform_array(v8);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v73 = __Block_byref_object_copy__77389;
    *(_QWORD *)&v74 = __Block_byref_object_dispose__77390;
    *((_QWORD *)&v74 + 1) = 0;
    *(_QWORD *)type = 0;
    v62 = type;
    v63 = 0x3032000000;
    v64 = __Block_byref_object_copy__77389;
    v65 = __Block_byref_object_dispose__77390;
    v66 = 0;
    v53[0] = MEMORY[0x1E0C809B0];
    v53[1] = 3221225472;
    v53[2] = ___ZL34nw_endpoint_transform_add_childrenP30NWConcrete_nw_endpoint_handler_block_invoke;
    v53[3] = &unk_1E14AA9A0;
    v10 = v8;
    v54 = v10;
    v11 = v4;
    v55 = v11;
    v12 = v7;
    v56 = v12;
    v58 = &v67;
    v13 = v6;
    v57 = v13;
    v59 = buf;
    v60 = type;
    nw_array_apply(v9, (uint64_t)v53);
    if (*((_BYTE *)v68 + 24))
    {
      v14 = *((id *)v11 + 7);
      v15 = v10;
      v16 = (NWConcrete_nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v15, 0, 0);

      nw_parameters_set_no_transform(v16, 1);
      v71 = 0uLL;
      if (nw_path_get_client_id(v13, &v71))
        nw_parameters_set_parent_id_inner(v16, (const unsigned __int8 *)&v71, 0);
      inner = nw_endpoint_handler_create_inner(v14, v16, nw_endpoint_transform_receive_report, v12, v12, 0, 0);
      v18 = *((_QWORD *)v11 + 1);
      if (!v18)
      {
        v19 = nw_array_create();
        v20 = (void *)*((_QWORD *)v11 + 1);
        *((_QWORD *)v11 + 1) = v19;

        v18 = *((_QWORD *)v11 + 1);
      }
      nw_array_append(v18, inner);

    }
    v21 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
    if (v21)
    {
      v22 = (void *)*((_QWORD *)v62 + 5);
      if (v22)
      {
        v24 = *(_QWORD *)(v21 + 16);
        v23 = *(_QWORD *)(v21 + 24);
        if (xpc_array_get_count(v22) == (v23 - v24) >> 3)
        {
          combined_array = nw_array_create_combined_array(*((void **)v11 + 1), *(void **)(*(_QWORD *)&buf[8] + 40));
          v26 = (void *)*((_QWORD *)v11 + 1);
          *((_QWORD *)v11 + 1) = combined_array;

          if (!*((_QWORD *)v11 + 3))
          {
            v27 = xpc_array_create(0, 0);
            v28 = (void *)*((_QWORD *)v11 + 3);
            *((_QWORD *)v11 + 3) = v27;

          }
          v29 = (void *)*((_QWORD *)v62 + 5);
          applier[0] = MEMORY[0x1E0C809B0];
          applier[1] = 3221225472;
          applier[2] = ___ZL34nw_endpoint_transform_add_childrenP30NWConcrete_nw_endpoint_handler_block_invoke_98;
          applier[3] = &unk_1E14AC908;
          v52 = v11;
          xpc_array_apply(v29, applier);

        }
      }
    }

    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);

    _Block_object_dispose(&v67, 8);
    goto LABEL_56;
  }
LABEL_35:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v38 = (id)gLogObj;
  if (mode > 5)
    v39 = "unknown-mode";
  else
    v39 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_endpoint_transform_add_children";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = v39;
  *(_WORD *)&buf[22] = 2082;
  v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
  v40 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v67) = 0;
  if (!__nwlog_fault((const char *)v40, type, &v67))
  {
LABEL_54:
    if (!v40)
      goto LABEL_56;
LABEL_55:
    free(v40);
    goto LABEL_56;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v41 = (id)gLogObj;
    v42 = type[0];
    if (os_log_type_enabled(v41, type[0]))
    {
      if (mode > 5)
        v43 = "unknown-mode";
      else
        v43 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_endpoint_transform_add_children";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v43;
      *(_WORD *)&buf[22] = 2082;
      v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
      _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_53:

    goto LABEL_54;
  }
  if (!(_BYTE)v67)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v41 = (id)gLogObj;
    v48 = type[0];
    if (os_log_type_enabled(v41, type[0]))
    {
      if (mode > 5)
        v49 = "unknown-mode";
      else
        v49 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_endpoint_transform_add_children";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v49;
      *(_WORD *)&buf[22] = 2082;
      v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
      _os_log_impl(&dword_182FBE000, v41, v48, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_53;
  }
  v44 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v41 = (id)gLogObj;
  v45 = type[0];
  v46 = os_log_type_enabled(v41, type[0]);
  if (!v44)
  {
    if (v46)
    {
      if (mode > 5)
        v50 = "unknown-mode";
      else
        v50 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_endpoint_transform_add_children";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v50;
      *(_WORD *)&buf[22] = 2082;
      v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
      _os_log_impl(&dword_182FBE000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_53;
  }
  if (v46)
  {
    if (mode > 5)
      v47 = "unknown-mode";
    else
      v47 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_endpoint_transform_add_children";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v47;
    *(_WORD *)&buf[22] = 2082;
    v73 = (uint64_t (*)(uint64_t, uint64_t))"transform";
    LOWORD(v74) = 2082;
    *(_QWORD *)((char *)&v74 + 2) = v44;
    _os_log_impl(&dword_182FBE000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v44);
  if (v40)
    goto LABEL_55;
LABEL_56:

}

void sub_1831B1C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34,char a35)
{
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;

  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v40 - 176), 8);

  _Block_object_dispose(&a35, 8);
  _Unwind_Resume(a1);
}

id nw_parameters_copy_transform_array(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[20];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_copy_transform_array";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_transform_array";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_copy_transform_array";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_transform_array";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_transform_array";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t tcp_connection_get_statistics(void *a1, uint64_t a2, int *a3)
{
  id v4;
  void *v5;
  void *v6;
  BOOL v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  id v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  const char *v22;
  const char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  char *v26;
  NSObject *v28;
  os_log_type_t v29;
  void *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  const char *v34;
  _BOOL4 v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  _BYTE v41[10];
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v39 = "tcp_connection_get_statistics";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v18, &type, &v36))
      goto LABEL_24;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v39 = "tcp_connection_get_statistics";
      v21 = "%{public}s called with null connection";
    }
    else
    {
      if (v36)
      {
        backtrace_string = __nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v24 = type;
        v25 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v39 = "tcp_connection_get_statistics";
            v40 = 2082;
            *(_QWORD *)v41 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v19, v24, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          v26 = (char *)backtrace_string;
          goto LABEL_23;
        }
        if (!v25)
        {
LABEL_32:

          if (!v18)
            goto LABEL_26;
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v39 = "tcp_connection_get_statistics";
        v21 = "%{public}s called with null connection, no backtrace";
        v28 = v19;
        v29 = v24;
LABEL_31:
        _os_log_impl(&dword_182FBE000, v28, v29, v21, buf, 0xCu);
        goto LABEL_32;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v39 = "tcp_connection_get_statistics";
      v21 = "%{public}s called with null connection, backtrace limit exceeded";
    }
    v28 = v19;
    v29 = v20;
    goto LABEL_31;
  }
  v6 = (void *)*((_QWORD *)v4 + 2);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v39 = "tcp_connection_get_statistics";
      v22 = "%{public}s API Misuse: Function must be called after tcp_connection_start";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
    }
LABEL_17:

LABEL_26:
    v16 = 0;
    goto LABEL_27;
  }
  if (!a3)
  {
    __nwlog_obj();
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v39 = "tcp_connection_get_statistics";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v18, &type, &v36))
      goto LABEL_24;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "tcp_connection_get_statistics";
        v33 = "%{public}s called with null statistics";
LABEL_49:
        _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0xCu);
        goto LABEL_50;
      }
      goto LABEL_50;
    }
    if (!v36)
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "tcp_connection_get_statistics";
        v33 = "%{public}s called with null statistics, backtrace limit exceeded";
        goto LABEL_49;
      }
LABEL_50:

LABEL_24:
      if (!v18)
        goto LABEL_26;
LABEL_25:
      free(v18);
      goto LABEL_26;
    }
    v34 = __nw_create_backtrace_string();
    __nwlog_obj();
    v31 = objc_claimAutoreleasedReturnValue();
    v32 = type;
    v35 = os_log_type_enabled(v31, type);
    if (!v34)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v39 = "tcp_connection_get_statistics";
        v33 = "%{public}s called with null statistics, no backtrace";
        goto LABEL_49;
      }
      goto LABEL_50;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v39 = "tcp_connection_get_statistics";
      v40 = 2082;
      *(_QWORD *)v41 = v34;
      _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null statistics, dumping backtrace:%{public}s", buf, 0x16u);
    }

    v26 = (char *)v34;
LABEL_23:
    free(v26);
    goto LABEL_24;
  }
  v7 = nw_connection_fillout_tcp_statistics(v6, (uint64_t)a3);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  v9 = v8;
  if (!v7)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v39 = "tcp_connection_get_statistics";
      v22 = "%{public}s Failed to get statistics from connection";
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v10 = *a3;
    v11 = a3[1];
    v12 = a3[2];
    v13 = a3[3];
    v14 = a3[4];
    v15 = a3[5];
    *(_DWORD *)buf = 136447746;
    v39 = "tcp_connection_get_statistics";
    v40 = 1024;
    *(_DWORD *)v41 = v10;
    *(_WORD *)&v41[4] = 1024;
    *(_DWORD *)&v41[6] = v11;
    v42 = 1024;
    v43 = v12;
    v44 = 1024;
    v45 = v13;
    v46 = 1024;
    v47 = v14;
    v48 = 1024;
    v49 = v15;
    _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s DNS: %ums/%ums since start, TCP: %ums/%ums since start, TLS: %ums/%ums since start", buf, 0x30u);
  }

  v16 = 1;
LABEL_27:

  return v16;
}

BOOL nw_connection_fillout_tcp_statistics(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  char *v8;
  id v9;
  _BOOL8 v10;
  _QWORD *v11;
  _QWORD *v12;
  unsigned __int8 *v13;
  void (*v14)(uint64_t);
  _QWORD *v15;
  uint64_t v16;
  id v17;
  _QWORD *v18;
  uint64_t v19;
  void *v20;
  double v21;
  double Helper_x8__nwswifttls_copy_definition;
  uint64_t v23;
  void *inited;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  int v28;
  _DWORD *v29;
  int v30;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  void *v36;
  os_log_type_t v37;
  char *backtrace_string;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  os_log_type_t v44;
  _QWORD v45[5];
  char v46;
  os_log_type_t type[8];
  uint64_t v48;
  void (*v49)(uint64_t);
  void *v50;
  char *v51;
  _BYTE *v52;
  _BYTE buf[24];
  uint64_t (*v54)(uint64_t, uint64_t);
  void (*v55)(uint64_t);
  id v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      v5 = (os_unfair_lock_s *)v3;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v54 = __Block_byref_object_copy__7754;
      v55 = __Block_byref_object_dispose__7755;
      v56 = 0;
      v6 = MEMORY[0x1E0C809B0];
      v7 = v5 + 34;
      *(_QWORD *)type = MEMORY[0x1E0C809B0];
      v48 = 3221225472;
      v49 = __nw_connection_copy_establishment_report_off_queue_block_invoke;
      v50 = &unk_1E14ACE40;
      v52 = buf;
      v8 = v5;
      v51 = v8;
      os_unfair_lock_lock(v7);
      __nw_connection_copy_establishment_report_off_queue_block_invoke((uint64_t)type);
      os_unfair_lock_unlock(v7);
      v9 = *(id *)(*(_QWORD *)&buf[8] + 40);

      _Block_object_dispose(buf, 8);
      v10 = v9 != 0;
      if (v9)
      {
        v45[0] = v6;
        v45[1] = 3221225472;
        v45[2] = __nw_connection_fillout_tcp_statistics_block_invoke;
        v45[3] = &__block_descriptor_40_e43_B16__0__NSObject_OS_nw_resolution_report__8l;
        v45[4] = a2;
        v11 = v9;
        v12 = v45;
        v13 = (unsigned __int8 *)v11[9];
        *(_QWORD *)buf = v6;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __nw_establishment_report_enumerate_resolution_reports_block_invoke;
        v54 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E14AC278;
        v14 = v12;
        v55 = v14;
        nw_array_apply(v13, (uint64_t)buf);

        v15 = v11;
        v16 = v15[3];

        *(_DWORD *)(a2 + 4) = *(_DWORD *)a2 + v16;
        if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
          dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
        v17 = (id)g_tcp_definition;
        *(_DWORD *)(a2 + 8) = nw_establishment_report_get_handshake_ms_for_protocol(v15, v17, 0);

        if (*(_DWORD *)(a2 + 8))
        {
          v18 = v15;
          v19 = v18[1];

          *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 8) + v19;
        }
        v20 = (void *)nw_protocol_boringssl_copy_definition();
        Helper_x8__nwswifttls_copy_definition = gotLoadHelper_x8__nwswifttls_copy_definition(v21);
        if (*(_QWORD *)(v23 + 2312))
        {
          inited = (void *)nwswifttls_copy_definition_delayInitStub(Helper_x8__nwswifttls_copy_definition);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v25 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_copy_swift_tls_definition_if_present";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = inited;
            _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s SwiftTLS protocol definition %p", buf, 0x16u);
          }
        }
        else
        {
          inited = 0;
        }
        *(_DWORD *)(a2 + 16) = nw_establishment_report_get_handshake_ms_for_protocol(v15, v20, inited);

        if (*(_DWORD *)(a2 + 16))
        {
          v29 = v15;
          v30 = v29[4];

          *(_DWORD *)(a2 + 20) = v30;
        }
      }
      else
      {
        v26 = *((_QWORD *)v8 + 2);
        if (v26 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v26 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v27 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            v28 = *((_DWORD *)v8 + 112);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v28;
            _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Establishment report is not ready", buf, 0x12u);
          }

        }
      }

      goto LABEL_22;
    }
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
    v33 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v33, type, &v46))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v37 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null statistics", buf, 0xCu);
        }
LABEL_54:

        goto LABEL_55;
      }
      if (!v46)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v44 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_182FBE000, v34, v44, "%{public}s called with null statistics, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_54;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v41 = type[0];
      v42 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_182FBE000, v34, v41, "%{public}s called with null statistics, no backtrace", buf, 0xCu);
        }
        goto LABEL_54;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v34, v41, "%{public}s called with null statistics, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_42;
    }
  }
  else
  {
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
    v33 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v33, type, &v46))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v35 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null connection", buf, 0xCu);
        }
        goto LABEL_54;
      }
      if (!v46)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v43 = type[0];
        if (os_log_type_enabled(v34, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_182FBE000, v34, v43, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_54;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v39 = type[0];
      v40 = os_log_type_enabled(v34, type[0]);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
        goto LABEL_54;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_connection_fillout_tcp_statistics";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_42:

      free(backtrace_string);
    }
  }
LABEL_55:
  if (v33)
    free(v33);
  v10 = 0;
LABEL_22:

  return v10;
}

void sub_1831B2DA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void nw_establishment_report_enumerate_protocols(nw_establishment_report_t report, nw_report_protocol_enumerator_t enumerate_block)
{
  nw_establishment_report_t v3;
  nw_report_protocol_enumerator_t v4;
  void *v5;
  unsigned __int8 *isa;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD v21[4];
  id v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = report;
  v4 = enumerate_block;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_establishment_report_enumerate_protocols";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_establishment_report_enumerate_protocols";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_establishment_report_enumerate_protocols";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_establishment_report_enumerate_protocols";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_establishment_report_enumerate_protocols";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    isa = (unsigned __int8 *)v3[8].isa;
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = __nw_establishment_report_enumerate_protocols_block_invoke;
    v21[3] = &unk_1E14AC278;
    v22 = v4;
    nw_array_apply(isa, (uint64_t)v21);

    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_establishment_report_enumerate_protocols";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_establishment_report_enumerate_protocols";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_establishment_report_enumerate_protocols";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_establishment_report_enumerate_protocols";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_establishment_report_enumerate_protocols";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

void __nw_connection_copy_establishment_report_off_queue_block_invoke(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(id *)(*(_QWORD *)(a1 + 32) + 416));
}

void nw_protocol_definition_set_initialize(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_initialize";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_initialize";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_initialize";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var5 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_initialize";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_initialize";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_initialize";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_initialize";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_initialize";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_1831B3804(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_outbound(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_handle_outbound";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_handle_outbound";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_outbound";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var8 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_handle_outbound";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_outbound";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_outbound";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_outbound";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_handle_outbound";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_1831B3CC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_inbound(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_handle_inbound";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_inbound";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_handle_inbound";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_inbound";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_inbound";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var7 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_handle_inbound";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_inbound";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_inbound";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_inbound";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_handle_inbound";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_1831B4184(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_destroy(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_destroy";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_destroy";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_destroy";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var6 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_destroy";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_destroy";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_destroy";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_destroy";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_destroy";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_1831B4644(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL34nw_socket_init_socket_event_sourceP9nw_socketj_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _WORD *v2;
  nw_protocol *v3;
  unsigned int v4;
  NSObject *v5;
  char v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *v14;
  _BOOL4 v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t);
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t);
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t);
  NSObject *v31;
  __int16 v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  NSObject *v37;
  uint64_t v38;
  int v39;
  NSObject *v40;
  int v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  int v46;
  uint64_t v47;
  const char *v48;
  NSObject *v49;
  os_log_type_t v50;
  uint32_t v51;
  char *backtrace_string;
  _BOOL4 v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  NSObject *v58;
  int v59;
  NSObject *v60;
  NSObject *v61;
  int v62;
  const char *v63;
  NSObject *v64;
  os_log_type_t v65;
  uint32_t v66;
  uint64_t v67;
  int v68;
  NSObject *v69;
  os_log_type_t v70;
  int v71;
  const char *v72;
  char *v73;
  NSObject *v74;
  _BOOL4 v75;
  int v76;
  int v77;
  NSObject *v78;
  os_log_type_t v79;
  int v80;
  os_log_type_t v81;
  int v82;
  char *v83;
  char v84;
  os_log_type_t v85;
  socklen_t v86;
  os_log_type_t v87[4];
  _BYTE buf[24];
  __int128 v89;
  uint64_t v90;
  _BYTE type[32];
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    v2 = (_WORD *)(v1 + 333);
    if ((*(_WORD *)(v1 + 333) & 0x4000) != 0)
      return;
    v4 = *(_DWORD *)(v1 + 204) & nw_queue_source_get_data(*(NSObject ***)(v1 + 104));
    if (!v4)
      return;
    if ((*v2 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v5 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v1 + 340;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v89) = v4;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Event mask: %#x", buf, 0x1Cu);
      }
    }
    v6 = v4 & 1;
    if ((v4 & 1) == 0)
    {
      v9 = 0;
      v8 = 60;
      if ((v4 & 8) == 0)
        goto LABEL_41;
      goto LABEL_31;
    }
    if ((*v2 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v7 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v1 + 340;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received CONNRESET event", buf, 0x16u);
      }
    }
    if (_nw_signposts_once == -1)
    {
      if (!_nw_signposts_enabled)
        goto LABEL_19;
    }
    else
    {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
      if (!_nw_signposts_enabled)
        goto LABEL_19;
    }
    if (kdebug_is_enabled())
      kdebug_trace();
LABEL_19:
    v8 = 54;
    v9 = 54;
    if ((v4 & 8) == 0)
    {
LABEL_41:
      if ((v4 & 0x800) == 0)
        goto LABEL_42;
      if ((*v2 & 0x40) != 0)
      {
        if ((*v2 & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v54 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v1 + 340;
            _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received CONNECTED event, but ignoring because disconnect has been requested", buf, 0x16u);
          }
        }
LABEL_42:
        if ((v4 & 0x1000) != 0)
        {
          if ((*v2 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v37 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)type = 136446466;
              *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
              *(_WORD *)&type[12] = 2082;
              *(_QWORD *)&type[14] = v1 + 340;
              _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received DISCONNECTED event", type, 0x16u);
            }
          }
          if (_nw_signposts_once == -1)
          {
            if (!_nw_signposts_enabled)
              goto LABEL_135;
          }
          else
          {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
            if (!_nw_signposts_enabled)
              goto LABEL_135;
          }
          if (kdebug_is_enabled())
            kdebug_trace();
        }
        else if ((v6 & 1) == 0)
        {
          if ((v4 & 2) == 0)
            goto LABEL_55;
          if ((*v2 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v17 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)type = 136446466;
              *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
              *(_WORD *)&type[12] = 2082;
              *(_QWORD *)&type[14] = v1 + 340;
              _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received READ_CLOSE event", type, 0x16u);
            }
          }
          if (_nw_signposts_once == -1)
          {
            if (_nw_signposts_enabled)
              goto LABEL_52;
          }
          else
          {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
            if (_nw_signposts_enabled)
            {
LABEL_52:
              if (kdebug_is_enabled())
                kdebug_trace();
            }
          }
          nw_socket_input_finished((nw_protocol *)(v1 - 96), v3);
LABEL_55:
          if ((v4 & 4) == 0)
            goto LABEL_65;
          if ((*v2 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v18 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)type = 136446466;
              *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
              *(_WORD *)&type[12] = 2082;
              *(_QWORD *)&type[14] = v1 + 340;
              _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received WRITE_CLOSE event", type, 0x16u);
            }
          }
          if (_nw_signposts_once == -1)
          {
            if (!_nw_signposts_enabled)
              goto LABEL_65;
          }
          else
          {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
            if (!_nw_signposts_enabled)
              goto LABEL_65;
          }
          if (kdebug_is_enabled())
            kdebug_trace();
LABEL_65:
          if ((~v4 & 6) != 0)
          {
            if ((v4 & 0x100) == 0)
              goto LABEL_80;
            if ((*v2 & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v19 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)type = 136446466;
                *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
                *(_WORD *)&type[12] = 2082;
                *(_QWORD *)&type[14] = v1 + 340;
                _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Socket received KEEPALIVE event", type, 0x16u);
              }
            }
            if (_nw_signposts_once == -1)
            {
              if (_nw_signposts_enabled)
                goto LABEL_74;
            }
            else
            {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
              if (_nw_signposts_enabled)
              {
LABEL_74:
                if (kdebug_is_enabled())
                  kdebug_trace();
              }
            }
            v20 = *(_QWORD *)(v1 + 48);
            if (v20)
            {
              v21 = *(_QWORD *)(v20 + 24);
              if (v21)
              {
                v22 = *(void (**)(uint64_t, uint64_t))(v21 + 160);
                if (v22)
                  v22(v20, v1 - 96);
              }
            }
LABEL_80:
            if ((v4 & 0x400) == 0)
              goto LABEL_94;
            if ((*v2 & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v23 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)type = 136446466;
                *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
                *(_WORD *)&type[12] = 2082;
                *(_QWORD *)&type[14] = v1 + 340;
                _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received ADAPTIVE_READ_TIMEOUT event", type, 0x16u);
              }
            }
            if (_nw_signposts_once == -1)
            {
              if (_nw_signposts_enabled)
                goto LABEL_88;
            }
            else
            {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
              if (_nw_signposts_enabled)
              {
LABEL_88:
                if (kdebug_is_enabled())
                  kdebug_trace();
              }
            }
            v24 = *(_QWORD *)(v1 + 48);
            if (v24)
            {
              v25 = *(_QWORD *)(v24 + 24);
              if (v25)
              {
                v26 = *(void (**)(uint64_t, uint64_t))(v25 + 160);
                if (v26)
                  v26(v24, v1 - 96);
              }
            }
LABEL_94:
            if ((v4 & 0x200) == 0)
              return;
            if ((*v2 & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v27 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)type = 136446466;
                *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
                *(_WORD *)&type[12] = 2082;
                *(_QWORD *)&type[14] = v1 + 340;
                _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received ADAPTIVE_WRITE_TIMEOUT event", type, 0x16u);
              }
            }
            if (_nw_signposts_once == -1)
            {
              if (_nw_signposts_enabled)
                goto LABEL_102;
            }
            else
            {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
              if (_nw_signposts_enabled)
              {
LABEL_102:
                if (kdebug_is_enabled())
                  kdebug_trace();
              }
            }
            v28 = *(_QWORD *)(v1 + 48);
            if (v28)
            {
              v29 = *(_QWORD *)(v28 + 24);
              if (v29)
              {
                v30 = *(void (**)(uint64_t, uint64_t))(v29 + 160);
                if (v30)
                  v30(v28, v1 - 96);
              }
            }
            return;
          }
          goto LABEL_136;
        }
LABEL_135:
        if ((~v4 & 6) != 0)
          goto LABEL_140;
LABEL_136:
        if (_nw_signposts_once == -1)
        {
          if (!_nw_signposts_enabled)
            goto LABEL_140;
        }
        else
        {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
          if (!_nw_signposts_enabled)
            goto LABEL_140;
        }
        if (kdebug_is_enabled())
          kdebug_trace();
LABEL_140:
        v38 = *(_QWORD *)(v1 + 104);
        if (v38)
        {
          nw_queue_cancel_source(v38, (uint64_t)v3);
          *(_QWORD *)(v1 + 104) = 0;
        }
        v86 = 4;
        *(_DWORD *)v87 = -1;
        if (!getsockopt(*(_DWORD *)(v1 + 196), 0xFFFF, 4103, v87, &v86))
        {
          v46 = *(_DWORD *)v87;
          if (*(_DWORD *)v87)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v47 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_186;
            *(_DWORD *)type = 136446722;
            *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
            *(_WORD *)&type[12] = 2080;
            *(_QWORD *)&type[14] = v1 + 340;
            *(_WORD *)&type[22] = 1024;
            *(_DWORD *)&type[24] = v46;
            v48 = "%{public}s %s Socket SO_ERROR %{darwin.errno}d";
            v49 = v47;
            v50 = OS_LOG_TYPE_ERROR;
            v51 = 28;
          }
          else
          {
            if ((*v2 & 0x80) != 0)
              goto LABEL_186;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v55 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
              goto LABEL_186;
            *(_DWORD *)type = 136446466;
            *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
            *(_WORD *)&type[12] = 2082;
            *(_QWORD *)&type[14] = v1 + 340;
            v48 = "%{public}s %{public}s Socket SO_ERROR: 0";
            v49 = v55;
            v50 = OS_LOG_TYPE_DEFAULT;
            v51 = 22;
          }
          _os_log_impl(&dword_182FBE000, v49, v50, v48, type, v51);
LABEL_186:
          v56 = *(unsigned int *)v87;
          if (*(_DWORD *)v87 || (v56 = v9, (_DWORD)v9))
            nw_socket_internal_error(v1, v56);
          nw_socket_internal_disconnect(v1);
          return;
        }
        v39 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        *(_DWORD *)v87 = v39;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v40 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)type = 136446722;
          *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
          *(_WORD *)&type[12] = 2080;
          *(_QWORD *)&type[14] = v1 + 340;
          *(_WORD *)&type[22] = 1024;
          *(_DWORD *)&type[24] = v39;
          _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_ERROR failed %{darwin.errno}d", type, 0x1Cu);
        }
        v41 = *(_DWORD *)v87;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)type = 136446466;
        *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
        *(_WORD *)&type[12] = 1024;
        *(_DWORD *)&type[14] = v41;
        v42 = (char *)_os_log_send_and_compose_impl();
        v85 = OS_LOG_TYPE_ERROR;
        v84 = 0;
        if (__nwlog_fault(v42, &v85, &v84))
        {
          if (v85 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = gLogObj;
            v44 = v85;
            if (!os_log_type_enabled((os_log_t)gLogObj, v85))
              goto LABEL_184;
            *(_DWORD *)type = 136446466;
            *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
            *(_WORD *)&type[12] = 1024;
            *(_DWORD *)&type[14] = v41;
            v45 = "%{public}s getsockopt SO_ERROR failed %{darwin.errno}d";
            goto LABEL_183;
          }
          if (!v84)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = gLogObj;
            v44 = v85;
            if (!os_log_type_enabled((os_log_t)gLogObj, v85))
              goto LABEL_184;
            *(_DWORD *)type = 136446466;
            *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
            *(_WORD *)&type[12] = 1024;
            *(_DWORD *)&type[14] = v41;
            v45 = "%{public}s getsockopt SO_ERROR failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_183;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v43 = gLogObj;
          v44 = v85;
          v53 = os_log_type_enabled((os_log_t)gLogObj, v85);
          if (backtrace_string)
          {
            if (v53)
            {
              *(_DWORD *)type = 136446722;
              *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
              *(_WORD *)&type[12] = 1024;
              *(_DWORD *)&type[14] = v41;
              *(_WORD *)&type[18] = 2082;
              *(_QWORD *)&type[20] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s getsockopt SO_ERROR failed %{darwin.errno}d, dumping backtrace:%{public}s", type, 0x1Cu);
            }
            free(backtrace_string);
            goto LABEL_184;
          }
          if (v53)
          {
            *(_DWORD *)type = 136446466;
            *(_QWORD *)&type[4] = "nw_socket_handle_socket_event";
            *(_WORD *)&type[12] = 1024;
            *(_DWORD *)&type[14] = v41;
            v45 = "%{public}s getsockopt SO_ERROR failed %{darwin.errno}d, no backtrace";
LABEL_183:
            _os_log_impl(&dword_182FBE000, v43, v44, v45, type, 0x12u);
          }
        }
LABEL_184:
        if (v42)
          free(v42);
        goto LABEL_186;
      }
      if ((*v2 & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v31 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v1 + 340;
          _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received CONNECTED event", buf, 0x16u);
        }
      }
      v32 = *(_WORD *)(v1 + 333);
      v33 = v32 & 0x7FFF | (*(unsigned __int8 *)(v1 + 335) << 16);
      *v2 = *v2 & 0x7FFB | 4;
      *(_BYTE *)(v1 + 335) = BYTE2(v33);
      if (_nw_signposts_once == -1)
      {
        if (!_nw_signposts_enabled)
          goto LABEL_118;
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
        if (!_nw_signposts_enabled)
          goto LABEL_118;
      }
      if (kdebug_is_enabled())
        kdebug_trace();
LABEL_118:
      if (*(_DWORD *)(v1 + 200) != 2 || (*v2 & 0x2000) == 0)
      {
LABEL_120:
        *(_DWORD *)(v1 + 204) &= ~0x800u;
        nw_socket_add_socket_events(v1, 1);
        nw_socket_fillout_socket_properties((nw_protocol *)(v1 - 96));
        nw_socket_internal_connect((_QWORD *)v1);
        if (v32 < 0)
        {
          v34 = 0;
          *(_QWORD *)type = 0;
          *(_QWORD *)&type[8] = type;
          *(_QWORD *)&type[16] = 0x2000000000;
          if (*(_UNKNOWN **)(v1 - 56) == &nw_protocol_ref_counted_handle)
          {
            v35 = *(_QWORD *)(v1 - 8);
            if (v35)
              *(_QWORD *)(v1 - 8) = v35 + 1;
            v34 = v1 - 96;
          }
          *(_QWORD *)&type[24] = v34;
          v36 = *(void **)(v1 + 160);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL29nw_socket_handle_socket_eventP9nw_socket_block_invoke;
          *(_QWORD *)&v89 = &unk_1E14A8C28;
          *((_QWORD *)&v89 + 1) = type;
          v90 = v1;
          nw_queue_context_async(v36, buf);
          _Block_object_dispose(type, 8);
        }
        goto LABEL_42;
      }
      *(_DWORD *)type = 0x4000;
      if (!setsockopt(*(_DWORD *)(v1 + 196), 6, 513, type, 4u))
      {
        if ((*v2 & 0x80) != 0)
          goto LABEL_120;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v67 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          goto LABEL_120;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v1 + 340;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v89) = *(_DWORD *)type;
        v63 = "%{public}s %{public}s Set TCP_NOTSENT_LOWAT(%u)";
        v64 = v67;
        v65 = OS_LOG_TYPE_DEBUG;
        v66 = 28;
LABEL_204:
        _os_log_impl(&dword_182FBE000, v64, v65, v63, buf, v66);
        goto LABEL_120;
      }
      v57 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v58 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v59 = *(_DWORD *)(v1 + 196);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v1 + 340;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v89) = *(_DWORD *)type;
        WORD2(v89) = 1024;
        *(_DWORD *)((char *)&v89 + 6) = v59;
        WORD5(v89) = 1024;
        HIDWORD(v89) = v57;
        _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_NOTSENT_LOWAT(%u) failed on fd %d %{darwin.errno}d", buf, 0x28u);
      }
      v60 = __nwlog_obj();
      v61 = v60;
      if (v57 == 22)
      {
        if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          goto LABEL_120;
        v62 = *(_DWORD *)(v1 + 196);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = *(_DWORD *)type;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v62;
        LOWORD(v89) = 1024;
        *(_DWORD *)((char *)&v89 + 2) = 22;
        v63 = "%{public}s setsockopt TCP_NOTSENT_LOWAT(%u) failed on fd %d %{darwin.errno}d";
        v64 = v61;
        v65 = OS_LOG_TYPE_ERROR;
        v66 = 30;
        goto LABEL_204;
      }
      v68 = *(_DWORD *)(v1 + 196);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = *(_DWORD *)type;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v68;
      LOWORD(v89) = 1024;
      v82 = v57;
      *(_DWORD *)((char *)&v89 + 2) = v57;
      v87[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v86) = 0;
      v83 = (char *)_os_log_send_and_compose_impl();
      if (__nwlog_fault(v83, v87, &v86))
      {
        if (v87[0] == OS_LOG_TYPE_FAULT)
        {
          v69 = __nwlog_obj();
          v70 = v87[0];
          if (!os_log_type_enabled(v69, v87[0]))
            goto LABEL_218;
          v71 = *(_DWORD *)(v1 + 196);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = *(_DWORD *)type;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v71;
          LOWORD(v89) = 1024;
          *(_DWORD *)((char *)&v89 + 2) = v82;
          v72 = "%{public}s setsockopt TCP_NOTSENT_LOWAT(%u) failed on fd %d %{darwin.errno}d";
LABEL_216:
          v78 = v69;
          v79 = v70;
LABEL_217:
          _os_log_impl(&dword_182FBE000, v78, v79, v72, buf, 0x1Eu);
          goto LABEL_218;
        }
        if (!(_BYTE)v86)
        {
          v69 = __nwlog_obj();
          v70 = v87[0];
          if (!os_log_type_enabled(v69, v87[0]))
            goto LABEL_218;
          v77 = *(_DWORD *)(v1 + 196);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = *(_DWORD *)type;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v77;
          LOWORD(v89) = 1024;
          *(_DWORD *)((char *)&v89 + 2) = v82;
          v72 = "%{public}s setsockopt TCP_NOTSENT_LOWAT(%u) failed on fd %d %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_216;
        }
        v73 = (char *)__nw_create_backtrace_string();
        v74 = __nwlog_obj();
        v81 = v87[0];
        v75 = os_log_type_enabled(v74, v87[0]);
        if (v73)
        {
          if (v75)
          {
            v76 = *(_DWORD *)(v1 + 196);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = *(_DWORD *)type;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v76;
            LOWORD(v89) = 1024;
            *(_DWORD *)((char *)&v89 + 2) = v82;
            WORD3(v89) = 2082;
            *((_QWORD *)&v89 + 1) = v73;
            _os_log_impl(&dword_182FBE000, v74, v81, "%{public}s setsockopt TCP_NOTSENT_LOWAT(%u) failed on fd %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x28u);
          }
          free(v73);
          goto LABEL_218;
        }
        if (v75)
        {
          v80 = *(_DWORD *)(v1 + 196);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_socket_setup_notsent_lowat";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = *(_DWORD *)type;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v80;
          LOWORD(v89) = 1024;
          *(_DWORD *)((char *)&v89 + 2) = v82;
          v72 = "%{public}s setsockopt TCP_NOTSENT_LOWAT(%u) failed on fd %d %{darwin.errno}d, no backtrace";
          v78 = v74;
          v79 = v81;
          goto LABEL_217;
        }
      }
LABEL_218:
      if (v83)
        free(v83);
      goto LABEL_120;
    }
LABEL_31:
    if ((*v2 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v1 + 340;
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Socket received TIMEOUT event", buf, 0x16u);
      }
    }
    if (_nw_signposts_once == -1)
    {
      if (_nw_signposts_enabled)
        goto LABEL_38;
    }
    else
    {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
      if (_nw_signposts_enabled)
      {
LABEL_38:
        if (kdebug_is_enabled())
          kdebug_trace();
      }
    }
    v6 = 1;
    v9 = v8;
    goto LABEL_41;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
  v10 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v87[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v10, type, v87))
  {
    if (type[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type[0]))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
      v13 = "%{public}s called with null socket_handler";
      goto LABEL_170;
    }
    if (v87[0] == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type[0]))
        goto LABEL_171;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
      v13 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_170;
    }
    v14 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    v12 = type[0];
    v15 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type[0]);
    if (v14)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v14;
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v14);
      goto LABEL_171;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_handle_socket_event";
      v13 = "%{public}s called with null socket_handler, no backtrace";
LABEL_170:
      _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    }
  }
LABEL_171:
  if (v10)
    free(v10);
}

NSObject *nw_queue_source_get_data(NSObject **a1)
{
  NSObject *result;
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    result = *a1;
    if (result)
      return dispatch_source_get_data(result);
    return result;
  }
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_queue_source_get_data";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_queue_source_get_data";
        v6 = "%{public}s called with null source";
LABEL_18:
        _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
      }
    }
    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v4 = objc_claimAutoreleasedReturnValue();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)buf = 136446466;
            v12 = "nw_queue_source_get_data";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (!v8)
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v12 = "nw_queue_source_get_data";
        v6 = "%{public}s called with null source, no backtrace";
        goto LABEL_18;
      }
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_queue_source_get_data";
        v6 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
LABEL_19:

  }
LABEL_20:
  if (v3)
    free(v3);
  return 0;
}

void nw_flow_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  nw_flow_protocol *handle;
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_handler *v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_flow *v7;
  NSObject *v8;
  const char *v9;
  id read_close_handler;
  void *v11;
  NSObject *client_queue;
  id v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _QWORD block[4];
  id v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  void *v29;
  __int16 v30;
  const char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  handle = (nw_flow_protocol *)a1->handle;
  v3 = handle->handler;
  v4 = v3;
  if (v3)
  {
    v5 = v3;
    mode = v5->mode;

    if ((_DWORD)mode == 2)
    {
      v7 = (NWConcrete_nw_endpoint_flow *)nw_endpoint_handler_copy_flow(v5);
      *((_WORD *)handle + 166) |= 0x10u;
      nw_flow_service_reads(v5, v7, handle, 0);
      if (&v7->shared_protocol == handle)
      {
        if (v7->client_queue)
        {
          read_close_handler = v7->read_close_handler;
          if (read_close_handler)
          {
            v11 = _Block_copy(read_close_handler);
            client_queue = v7->client_queue;
            block[0] = MEMORY[0x1E0C809B0];
            block[1] = 3221225472;
            block[2] = ___ZL22nw_flow_input_finishedP11nw_protocolS0__block_invoke;
            block[3] = &unk_1E14AC390;
            v23 = v11;
            v13 = v11;
            dispatch_async(client_queue, block);

          }
        }
      }

    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5)
          v9 = "unknown-mode";
        else
          v9 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v27 = "nw_flow_input_finished";
        v28 = 2082;
        v29 = (void *)v9;
        v30 = 2082;
        v31 = "flow";
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }

    }
    goto LABEL_14;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_flow_input_finished";
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v15, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_flow_input_finished";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_flow_input_finished";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_31;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_flow_input_finished";
        _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_flow_input_finished";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_31:
  if (v15)
    free(v15);
LABEL_14:

}

void sub_1831B6530(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_socket_fillout_socket_properties(nw_protocol *a1)
{
  int output_handler_high;
  void *remote;
  id v4;
  int v5;
  int address_family;
  int v7;
  _BOOL4 v8;
  uint64_t v9;
  unsigned __int8 *v10;
  size_t v11;
  int v12;
  NSObject *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  int v17;
  int v18;
  NSObject *v19;
  char *v20;
  _BOOL4 v21;
  char *v22;
  _BOOL4 v23;
  void *v24;
  void *v25;
  nw_protocol *default_input_handler;
  unsigned int v27;
  void *output_handler_context;
  id v29;
  NWConcrete_nw_interface *v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *backtrace_string;
  _BOOL4 v36;
  char *v37;
  _BOOL4 v38;
  char v39;
  os_log_type_t type;
  socklen_t v41;
  uint64_t v42;
  unsigned int v43;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  _BYTE v47[14];
  sockaddr __dst[8];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    v31 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    LOBYTE(v42) = 0;
    if (!__nwlog_fault(v31, buf, &v42))
      goto LABEL_106;
    if (buf[0] == 17)
    {
      v32 = __nwlog_obj();
      v33 = buf[0];
      if (!os_log_type_enabled(v32, (os_log_type_t)buf[0]))
        goto LABEL_106;
      *(_DWORD *)&__dst[0].sa_len = 136446210;
      *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
      v34 = "%{public}s called with null protocol";
    }
    else if ((_BYTE)v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v32 = __nwlog_obj();
      v33 = buf[0];
      v36 = os_log_type_enabled(v32, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)&__dst[0].sa_len = 136446466;
          *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
          *(_WORD *)&__dst[0].sa_data[10] = 2082;
          *(_QWORD *)&__dst[0].sa_data[12] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s called with null protocol, dumping backtrace:%{public}s", &__dst[0].sa_len, 0x16u);
        }
        free(backtrace_string);
LABEL_106:
        if (!v31)
          return;
LABEL_107:
        free(v31);
        return;
      }
      if (!v36)
        goto LABEL_106;
      *(_DWORD *)&__dst[0].sa_len = 136446210;
      *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
      v34 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v32 = __nwlog_obj();
      v33 = buf[0];
      if (!os_log_type_enabled(v32, (os_log_type_t)buf[0]))
        goto LABEL_106;
      *(_DWORD *)&__dst[0].sa_len = 136446210;
      *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
      v34 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_105:
    _os_log_impl(&dword_182FBE000, v32, v33, v34, &__dst[0].sa_len, 0xCu);
    goto LABEL_106;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    memset(__dst, 0, sizeof(__dst));
    v43 = 0;
    output_handler_high = HIDWORD(a1[4].output_handler);
    if (output_handler_high < 0)
      return;
    remote = (void *)nw_socket_get_remote(a1);
    if (remote && (v4 = remote, v5 = objc_msgSend(v4, "type"), v4, v5 == 1))
    {
      address_family = nw_endpoint_get_address_family(v4);
      v7 = address_family;
      v42 = 0;
      v8 = address_family == 2;
      if ((address_family == 30 || address_family == 2) && !copyconninfo(output_handler_high, 0, &v42))
      {
        v9 = v42;
        v10 = *(unsigned __int8 **)(v42 + 8);
        if (v10)
        {
          v11 = *v10;
          if (v11 >= 0x81)
          {
            v43 = *(_DWORD *)(v42 + 4);
          }
          else
          {
            memcpy(__dst, v10, v11);
            v10 = *(unsigned __int8 **)(v9 + 8);
            v43 = *(_DWORD *)(v9 + 4);
            if (!v10)
              goto LABEL_56;
          }
          free(v10);
          *(_QWORD *)(v9 + 8) = 0;
        }
        else
        {
          v43 = *(_DWORD *)(v42 + 4);
        }
LABEL_56:
        v24 = *(void **)(v9 + 16);
        if (v24)
        {
          free(v24);
          *(_QWORD *)(v9 + 16) = 0;
        }
        v25 = *(void **)(v9 + 32);
        if (v25)
          free(v25);
        goto LABEL_66;
      }
    }
    else
    {
      v8 = 0;
      v7 = 0;
      v42 = 0;
    }
    if (((*(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16)) & 0x20000) != 0)
    {
LABEL_67:
      if (__dst[0].sa_len)
      {
        default_input_handler = a1[2].default_input_handler;
        if (default_input_handler)
        {
          os_release(default_input_handler);
          a1[2].default_input_handler = 0;
        }
        a1[2].default_input_handler = (nw_protocol *)nw_endpoint_create_address(__dst);
      }
      v27 = v43;
      if (v43)
      {
        output_handler_context = a1[2].output_handler_context;
        if (output_handler_context)
        {
          os_release(output_handler_context);
          a1[2].output_handler_context = 0;
          v27 = v43;
        }
        if (nw_context_copy_implicit_context::onceToken[0] != -1)
          dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
        v29 = (id)nw_context_copy_implicit_context::implicit_context;
        v30 = nw_path_copy_interface_with_generation(v29, v27, 0);

        a1[2].output_handler_context = v30;
      }
      return;
    }
    v41 = 128;
    if (getsockname(output_handler_high, __dst, &v41))
    {
      v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v45 = "nw_socket_fillout_socket_properties";
        v46 = 2080;
        *(_QWORD *)v47 = (char *)a1 + 436;
        *(_WORD *)&v47[8] = 1024;
        *(_DWORD *)&v47[10] = v12;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s %s getsockname failed %{darwin.errno}d", buf, 0x1Cu);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v45 = "nw_socket_fillout_socket_properties";
      v46 = 1024;
      *(_DWORD *)v47 = v12;
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v39 = 0;
      if (__nwlog_fault((const char *)v9, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v15 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_65;
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v12;
          v16 = "%{public}s getsockname failed %{darwin.errno}d";
          goto LABEL_64;
        }
        if (!v39)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v15 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_65;
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v12;
          v16 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_64;
        }
        v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        v21 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v20)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446722;
            v45 = "nw_socket_fillout_socket_properties";
            v46 = 1024;
            *(_DWORD *)v47 = v12;
            *(_WORD *)&v47[4] = 2082;
            *(_QWORD *)&v47[6] = v20;
            _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v20);
          if (!v9)
            goto LABEL_67;
          goto LABEL_66;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v12;
          v16 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
LABEL_64:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0x12u);
        }
      }
    }
    else
    {
      if (v7 != 30 && v7 != 2)
        goto LABEL_67;
      v41 = 4;
      v17 = v8 ? 0 : 41;
      if (!getsockopt(output_handler_high, v17, 9696, &v43, &v41))
        goto LABEL_67;
      v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v19 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v45 = "nw_socket_fillout_socket_properties";
        v46 = 2080;
        *(_QWORD *)v47 = (char *)a1 + 436;
        *(_WORD *)&v47[8] = 1024;
        *(_DWORD *)&v47[10] = v18;
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt OUT_IF failed %{darwin.errno}d", buf, 0x1Cu);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v45 = "nw_socket_fillout_socket_properties";
      v46 = 1024;
      *(_DWORD *)v47 = v18;
      v9 = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v39 = 0;
      if (__nwlog_fault((const char *)v9, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          v15 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_65;
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          v16 = "%{public}s getsockopt OUT_IF failed %{darwin.errno}d";
          goto LABEL_64;
        }
        if (!v39)
        {
          v14 = __nwlog_obj();
          v15 = type;
          if (!os_log_type_enabled(v14, type))
            goto LABEL_65;
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          v16 = "%{public}s getsockopt OUT_IF failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_64;
        }
        v22 = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v23 = os_log_type_enabled(v14, type);
        if (!v22)
        {
          if (!v23)
            goto LABEL_65;
          *(_DWORD *)buf = 136446466;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          v16 = "%{public}s getsockopt OUT_IF failed %{darwin.errno}d, no backtrace";
          goto LABEL_64;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446722;
          v45 = "nw_socket_fillout_socket_properties";
          v46 = 1024;
          *(_DWORD *)v47 = v18;
          *(_WORD *)&v47[4] = 2082;
          *(_QWORD *)&v47[6] = v22;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s getsockopt OUT_IF failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v22);
      }
    }
LABEL_65:
    if (v9)
    {
LABEL_66:
      free((void *)v9);
      goto LABEL_67;
    }
    goto LABEL_67;
  }
  __nwlog_obj();
  *(_DWORD *)&__dst[0].sa_len = 136446210;
  *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
  v31 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  LOBYTE(v42) = 0;
  if (!__nwlog_fault(v31, buf, &v42))
    goto LABEL_106;
  if (buf[0] == 17)
  {
    v32 = __nwlog_obj();
    v33 = buf[0];
    if (!os_log_type_enabled(v32, (os_log_type_t)buf[0]))
      goto LABEL_106;
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    v34 = "%{public}s called with null socket_handler";
    goto LABEL_105;
  }
  if (!(_BYTE)v42)
  {
    v32 = __nwlog_obj();
    v33 = buf[0];
    if (!os_log_type_enabled(v32, (os_log_type_t)buf[0]))
      goto LABEL_106;
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    v34 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_105;
  }
  v37 = (char *)__nw_create_backtrace_string();
  v32 = __nwlog_obj();
  v33 = buf[0];
  v38 = os_log_type_enabled(v32, (os_log_type_t)buf[0]);
  if (!v37)
  {
    if (!v38)
      goto LABEL_106;
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    v34 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_105;
  }
  if (v38)
  {
    *(_DWORD *)&__dst[0].sa_len = 136446466;
    *(_QWORD *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    *(_WORD *)&__dst[0].sa_data[10] = 2082;
    *(_QWORD *)&__dst[0].sa_data[12] = v37;
    _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", &__dst[0].sa_len, 0x16u);
  }
  free(v37);
  if (v31)
    goto LABEL_107;
}

void sub_1831B70B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_socket_get_remote(nw_protocol *a1)
{
  nw_protocol_identifier *identifier;
  uint64_t v3;
  uint64_t (*v4)(nw_protocol_identifier *);
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (**v11)(_QWORD);
  const void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_remote";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_remote";
      v16 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v21)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_socket_get_remote";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_socket_get_remote";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v13)
          return 0;
        goto LABEL_55;
      }
      if (!v18)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_remote";
      v16 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_53:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_54;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_remote";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_remote";
      v16 = "%{public}s called with null socket_handler";
      goto LABEL_53;
    }
    if (!v21)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_remote";
      v16 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_53;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v20 = os_log_type_enabled(v14, type);
    if (!v19)
    {
      if (!v20)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_remote";
      v16 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_53;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_socket_get_remote";
      v25 = 2082;
      v26 = v19;
      _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v19);
LABEL_54:
    if (!v13)
      return 0;
LABEL_55:
    free(v13);
    return 0;
  }
  identifier = a1[2].identifier;
  if (!identifier)
  {
    if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_socket_get_remote";
        v25 = 2082;
        v26 = (char *)&a1[6].default_input_handler + 4;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
      }
    }
    return 0;
  }
  v3 = *(_QWORD *)&identifier->name[24];
  if (!v3)
    return 0;
  v4 = *(uint64_t (**)(nw_protocol_identifier *))(v3 + 136);
  if (!v4)
    return 0;
  if (*(_UNKNOWN **)identifier[1].name != &nw_protocol_ref_counted_handle)
    return v4(a1[2].identifier);
  v8 = *(_QWORD *)&identifier[2].name[8];
  if (v8)
    *(_QWORD *)&identifier[2].name[8] = v8 + 1;
  v7 = v4(identifier);
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    v9 = *(_QWORD *)&identifier[2].name[8];
    if (v9)
    {
      v10 = v9 - 1;
      *(_QWORD *)&identifier[2].name[8] = v10;
      if (!v10)
      {
        v11 = *(void (***)(_QWORD))&identifier[1].name[24];
        if (v11)
        {
          *(_QWORD *)&identifier[1].name[24] = 0;
          v11[2](v11);
          _Block_release(v11);
        }
        if ((identifier[1].level & 1) != 0)
        {
          v12 = *(const void **)&identifier[1].name[24];
          if (v12)
            _Block_release(v12);
        }
        free(identifier);
      }
    }
  }
  return v7;
}

uint64_t copyconninfo(int a1, int a2, _QWORD *a3)
{
  int v5;
  NSObject *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  size_t v17;
  void *v18;
  size_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  int v23;
  NSObject *v24;
  char *v25;
  _BOOL4 v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  _QWORD *v31;
  void *v32;
  int v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  int v37;
  const char *v38;
  char *v39;
  _BOOL4 v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  uint64_t result;
  void *v46;
  int v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  int v51;
  const char *v52;
  char *v53;
  _BOOL4 v54;
  char *v55;
  _BOOL4 v56;
  int v57;
  char *v58;
  _BOOL4 v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  NSObject *v65;
  void *v66;
  NSObject *v67;
  void *v68;
  NSObject *v69;
  void *v70;
  NSObject *v71;
  void *v72;
  int v73;
  char v74;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v77;
  __int16 v78;
  _BYTE v79[10];
  _QWORD v80[3];
  uint8_t v81[32];
  void *v82[2];
  size_t size[2];
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)v81 = 136446210;
    *(_QWORD *)&v81[4] = "copyconninfo";
    v7 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, buf, &type))
      goto LABEL_63;
    if (buf[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_63;
      *(_DWORD *)v81 = 136446210;
      *(_QWORD *)&v81[4] = "copyconninfo";
      v10 = "%{public}s called with null cfop";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = buf[0];
      v16 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)v81 = 136446466;
          *(_QWORD *)&v81[4] = "copyconninfo";
          *(_WORD *)&v81[12] = 2082;
          *(_QWORD *)&v81[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null cfop, dumping backtrace:%{public}s", v81, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_63;
      }
      if (!v16)
      {
LABEL_63:
        if (v7)
          free(v7);
        goto LABEL_82;
      }
      *(_DWORD *)v81 = 136446210;
      *(_QWORD *)&v81[4] = "copyconninfo";
      v10 = "%{public}s called with null cfop, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_63;
      *(_DWORD *)v81 = 136446210;
      *(_QWORD *)&v81[4] = "copyconninfo";
      v10 = "%{public}s called with null cfop, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v8, v9, v10, v81, 0xCu);
    goto LABEL_63;
  }
  if (a1 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)v81 = 136446466;
    *(_QWORD *)&v81[4] = "copyconninfo";
    *(_WORD *)&v81[12] = 1024;
    *(_DWORD *)&v81[14] = a1;
    v11 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v11, buf, &type))
      goto LABEL_80;
    if (buf[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_80;
      *(_DWORD *)v81 = 136446466;
      *(_QWORD *)&v81[4] = "copyconninfo";
      *(_WORD *)&v81[12] = 1024;
      *(_DWORD *)&v81[14] = a1;
      v14 = "%{public}s called with null s (%d)";
    }
    else if (type)
    {
      v25 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = buf[0];
      v26 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]);
      if (v25)
      {
        if (v26)
        {
          *(_DWORD *)v81 = 136446722;
          *(_QWORD *)&v81[4] = "copyconninfo";
          *(_WORD *)&v81[12] = 1024;
          *(_DWORD *)&v81[14] = a1;
          *(_WORD *)&v81[18] = 2082;
          *(_QWORD *)&v81[20] = v25;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null s (%d), dumping backtrace:%{public}s", v81, 0x1Cu);
        }
        free(v25);
        goto LABEL_80;
      }
      if (!v26)
      {
LABEL_80:
        if (v11)
          free(v11);
LABEL_82:
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)v81 = 136446466;
      *(_QWORD *)&v81[4] = "copyconninfo";
      *(_WORD *)&v81[12] = 1024;
      *(_DWORD *)&v81[14] = a1;
      v14 = "%{public}s called with null s (%d), no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_80;
      *(_DWORD *)v81 = 136446466;
      *(_QWORD *)&v81[4] = "copyconninfo";
      *(_WORD *)&v81[12] = 1024;
      *(_DWORD *)&v81[14] = a1;
      v14 = "%{public}s called with null s (%d), backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v12, v13, v14, v81, 0x12u);
    goto LABEL_80;
  }
  *(_OWORD *)v82 = 0u;
  *(_OWORD *)size = 0u;
  memset(v81, 0, sizeof(v81));
  *(_DWORD *)v81 = a2;
  if (ioctl(a1, 0xC0407398uLL, v81))
  {
    v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if ((v5 | 0x10) == 0x16)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v5;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d,SIOCGCONNINFO_1) %{darwin.errno}d", buf, 0x18u);
      }
      return 0xFFFFFFFFLL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v77 = "copyconninfo";
    v78 = 1024;
    *(_DWORD *)v79 = a1;
    *(_WORD *)&v79[4] = 1024;
    *(_DWORD *)&v79[6] = v5;
    v27 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v74 = 0;
    if ((__nwlog_fault(v27, &type, &v74) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        v29 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_105;
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v5;
        v30 = "%{public}s ioctl(%d,SIOCGCONNINFO_1) %{darwin.errno}d";
        goto LABEL_104;
      }
      if (!v74)
      {
        v28 = __nwlog_obj();
        v29 = type;
        if (!os_log_type_enabled(v28, type))
          goto LABEL_105;
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v5;
        v30 = "%{public}s ioctl(%d,SIOCGCONNINFO_1) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_104;
      }
      v39 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = gLogObj;
      v29 = type;
      v40 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v39)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446978;
          v77 = "copyconninfo";
          v78 = 1024;
          *(_DWORD *)v79 = a1;
          *(_WORD *)&v79[4] = 1024;
          *(_DWORD *)&v79[6] = v5;
          LOWORD(v80[0]) = 2082;
          *(_QWORD *)((char *)v80 + 2) = v39;
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s ioctl(%d,SIOCGCONNINFO_1) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v39);
        goto LABEL_105;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v5;
        v30 = "%{public}s ioctl(%d,SIOCGCONNINFO_1) %{darwin.errno}d, no backtrace";
LABEL_104:
        _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0x18u);
      }
    }
LABEL_105:
    if (v27)
      free(v27);
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)&v81[24])
  {
    if (*(_DWORD *)&v81[24] <= 0x1Cu)
      v17 = 28;
    else
      v17 = *(unsigned int *)&v81[24];
    *(_DWORD *)&v81[24] = v17;
    v18 = malloc_type_calloc(1uLL, v17, 0xEAFB8F1AuLL);
    if (!v18)
    {
      v65 = __nwlog_obj();
      os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v77 = "strict_calloc";
      v78 = 2048;
      *(_QWORD *)v79 = 1;
      *(_WORD *)&v79[8] = 2048;
      v80[0] = v17;
      v73 = 32;
      v66 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort((uint64_t)v66);
      if ((_DWORD)result)
        goto LABEL_158;
      free(v66);
    }
    *(_QWORD *)&v81[16] = v18;
  }
  if (LODWORD(v82[1]))
  {
    if (LODWORD(v82[1]) <= 0x1C)
      v19 = 28;
    else
      v19 = LODWORD(v82[1]);
    LODWORD(v82[1]) = v19;
    v20 = malloc_type_calloc(1uLL, v19, 0xEAFB8F1AuLL);
    if (!v20)
    {
      v67 = __nwlog_obj();
      os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v77 = "strict_calloc";
      v78 = 2048;
      *(_QWORD *)v79 = 1;
      *(_WORD *)&v79[8] = 2048;
      v80[0] = v19;
      v73 = 32;
      v68 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort((uint64_t)v68);
      if ((_DWORD)result)
        goto LABEL_158;
      free(v68);
    }
    v82[0] = v20;
  }
  v21 = LODWORD(size[1]);
  if (LODWORD(size[1]))
  {
    v22 = malloc_type_calloc(1uLL, LODWORD(size[1]), 0xEAFB8F1AuLL);
    if (!v22)
    {
      v69 = __nwlog_obj();
      os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v77 = "strict_calloc";
      v78 = 2048;
      *(_QWORD *)v79 = 1;
      *(_WORD *)&v79[8] = 2048;
      v80[0] = v21;
      v73 = 32;
      v70 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort((uint64_t)v70);
      if ((_DWORD)result)
        goto LABEL_158;
      free(v70);
    }
    size[0] = (size_t)v22;
  }
  if (ioctl(a1, 0xC0407398uLL, v81, v73))
  {
    v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if ((v23 | 0x10) == 0x16)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v23;
        _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d,SIOCGCONNINFO) %{darwin.errno}d", buf, 0x18u);
      }
LABEL_124:
      if (*(_QWORD *)&v81[16])
      {
        free(*(void **)&v81[16]);
        *(_QWORD *)&v81[16] = 0;
      }
      if (v82[0])
      {
        free(v82[0]);
        v82[0] = 0;
      }
      if (size[0])
        free((void *)size[0]);
      *a3 = 0;
      return 0xFFFFFFFFLL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v77 = "copyconninfo";
    v78 = 1024;
    *(_DWORD *)v79 = a1;
    *(_WORD *)&v79[4] = 1024;
    *(_DWORD *)&v79[6] = v23;
    v41 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v74 = 0;
    if ((__nwlog_fault(v41, &type, &v74) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v42 = __nwlog_obj();
        v43 = type;
        if (!os_log_type_enabled(v42, type))
          goto LABEL_122;
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v23;
        v44 = "%{public}s ioctl(%d,SIOCGCONNINFO) %{darwin.errno}d";
        goto LABEL_121;
      }
      if (!v74)
      {
        v42 = __nwlog_obj();
        v43 = type;
        if (!os_log_type_enabled(v42, type))
          goto LABEL_122;
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v23;
        v44 = "%{public}s ioctl(%d,SIOCGCONNINFO) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_121;
      }
      v53 = (char *)__nw_create_backtrace_string();
      v42 = __nwlog_obj();
      v43 = type;
      v54 = os_log_type_enabled(v42, type);
      if (v53)
      {
        if (v54)
        {
          *(_DWORD *)buf = 136446978;
          v77 = "copyconninfo";
          v78 = 1024;
          *(_DWORD *)v79 = a1;
          *(_WORD *)&v79[4] = 1024;
          *(_DWORD *)&v79[6] = v23;
          LOWORD(v80[0]) = 2082;
          *(_QWORD *)((char *)v80 + 2) = v53;
          _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s ioctl(%d,SIOCGCONNINFO) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v53);
        goto LABEL_122;
      }
      if (v54)
      {
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = a1;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = v23;
        v44 = "%{public}s ioctl(%d,SIOCGCONNINFO) %{darwin.errno}d, no backtrace";
LABEL_121:
        _os_log_impl(&dword_182FBE000, v42, v43, v44, buf, 0x18u);
      }
    }
LABEL_122:
    if (v41)
      free(v41);
    goto LABEL_124;
  }
  v31 = malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  if (v31)
  {
    if (LODWORD(size[1]))
      goto LABEL_54;
LABEL_52:
    if (size[0])
    {
      free((void *)size[0]);
      size[0] = 0;
    }
LABEL_54:
    v32 = *(void **)&v81[16];
    if (!*(_DWORD *)&v81[24])
    {
      if (!*(_QWORD *)&v81[16])
        goto LABEL_86;
      goto LABEL_85;
    }
    if (*(_DWORD *)&v81[24] >= **(_BYTE **)&v81[16])
      goto LABEL_86;
    __nwlog_obj();
    v33 = **(_BYTE **)&v81[16];
    *(_DWORD *)buf = 136446722;
    v77 = "copyconninfo";
    v78 = 1024;
    *(_DWORD *)v79 = v33;
    *(_WORD *)&v79[4] = 1024;
    *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
    v34 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v74 = 0;
    if (__nwlog_fault(v34, &type, &v74))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
          goto LABEL_138;
        v37 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v37;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        v38 = "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed";
LABEL_137:
        _os_log_impl(&dword_182FBE000, v35, v36, v38, buf, 0x18u);
        goto LABEL_138;
      }
      if (!v74)
      {
        v35 = __nwlog_obj();
        v36 = type;
        if (!os_log_type_enabled(v35, type))
          goto LABEL_138;
        v61 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v61;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        v38 = "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed, backtrace limit exceeded";
        goto LABEL_137;
      }
      v55 = (char *)__nw_create_backtrace_string();
      v35 = __nwlog_obj();
      v36 = type;
      v56 = os_log_type_enabled(v35, type);
      if (!v55)
      {
        if (!v56)
          goto LABEL_138;
        v63 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446722;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v63;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        v38 = "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed, no backtrace";
        goto LABEL_137;
      }
      if (v56)
      {
        v57 = **(_BYTE **)&v81[16];
        *(_DWORD *)buf = 136446978;
        v77 = "copyconninfo";
        v78 = 1024;
        *(_DWORD *)v79 = v57;
        *(_WORD *)&v79[4] = 1024;
        *(_DWORD *)&v79[6] = *(_DWORD *)&v81[24];
        LOWORD(v80[0]) = 2082;
        *(_QWORD *)((char *)v80 + 2) = v55;
        _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s ioctl SIOCGCONNINFO return invalid source (sa_len=%u > scir_src_len=%u) failed, dumping backtrace:%{public}s", buf, 0x22u);
      }
      free(v55);
    }
LABEL_138:
    if (v34)
      free(v34);
    v32 = *(void **)&v81[16];
    if (!*(_QWORD *)&v81[16])
    {
LABEL_86:
      v46 = v82[0];
      if (LODWORD(v82[1]))
      {
        if (LODWORD(v82[1]) < *(unsigned __int8 *)v82[0])
        {
          __nwlog_obj();
          v47 = *(unsigned __int8 *)v82[0];
          *(_DWORD *)buf = 136446722;
          v77 = "copyconninfo";
          v78 = 1024;
          *(_DWORD *)v79 = v47;
          *(_WORD *)&v79[4] = 1024;
          *(_DWORD *)&v79[6] = v82[1];
          v48 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v74 = 0;
          if (!__nwlog_fault(v48, &type, &v74))
            goto LABEL_145;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v49 = __nwlog_obj();
            v50 = type;
            if (!os_log_type_enabled(v49, type))
              goto LABEL_145;
            v51 = *(unsigned __int8 *)v82[0];
            *(_DWORD *)buf = 136446722;
            v77 = "copyconninfo";
            v78 = 1024;
            *(_DWORD *)v79 = v51;
            *(_WORD *)&v79[4] = 1024;
            *(_DWORD *)&v79[6] = v82[1];
            v52 = "%{public}s ioctl SIOCGCONNINFO return invalid destination (sa_len=%u > scir_dst_len=%u) failed";
          }
          else if (v74)
          {
            v58 = (char *)__nw_create_backtrace_string();
            v49 = __nwlog_obj();
            v50 = type;
            v59 = os_log_type_enabled(v49, type);
            if (v58)
            {
              if (v59)
              {
                v60 = *(unsigned __int8 *)v82[0];
                *(_DWORD *)buf = 136446978;
                v77 = "copyconninfo";
                v78 = 1024;
                *(_DWORD *)v79 = v60;
                *(_WORD *)&v79[4] = 1024;
                *(_DWORD *)&v79[6] = v82[1];
                LOWORD(v80[0]) = 2082;
                *(_QWORD *)((char *)v80 + 2) = v58;
                _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s ioctl SIOCGCONNINFO return invalid destination (sa_len=%u > scir_dst_len=%u) failed, dumping backtrace:%{public}s", buf, 0x22u);
              }
              free(v58);
LABEL_145:
              if (v48)
                free(v48);
              v46 = v82[0];
              if (!v82[0])
                goto LABEL_94;
              goto LABEL_93;
            }
            if (!v59)
              goto LABEL_145;
            v64 = *(unsigned __int8 *)v82[0];
            *(_DWORD *)buf = 136446722;
            v77 = "copyconninfo";
            v78 = 1024;
            *(_DWORD *)v79 = v64;
            *(_WORD *)&v79[4] = 1024;
            *(_DWORD *)&v79[6] = v82[1];
            v52 = "%{public}s ioctl SIOCGCONNINFO return invalid destination (sa_len=%u > scir_dst_len=%u) failed, no backtrace";
          }
          else
          {
            v49 = __nwlog_obj();
            v50 = type;
            if (!os_log_type_enabled(v49, type))
              goto LABEL_145;
            v62 = *(unsigned __int8 *)v82[0];
            *(_DWORD *)buf = 136446722;
            v77 = "copyconninfo";
            v78 = 1024;
            *(_DWORD *)v79 = v62;
            *(_WORD *)&v79[4] = 1024;
            *(_DWORD *)&v79[6] = v82[1];
            v52 = "%{public}s ioctl SIOCGCONNINFO return invalid destination (sa_len=%u > scir_dst_len=%u) failed, backtr"
                  "ace limit exceeded";
          }
          _os_log_impl(&dword_182FBE000, v49, v50, v52, buf, 0x18u);
          goto LABEL_145;
        }
      }
      else if (v82[0])
      {
LABEL_93:
        free(v46);
        v46 = 0;
      }
LABEL_94:
      result = 0;
      *v31 = *(_QWORD *)&v81[4];
      v31[1] = *(_QWORD *)&v81[16];
      v31[2] = v46;
      *((_DWORD *)v31 + 6) = *(_DWORD *)&v81[12];
      *((_DWORD *)v31 + 7) = HIDWORD(v82[1]);
      v31[4] = size[0];
      *a3 = v31;
      return result;
    }
LABEL_85:
    free(v32);
    *(_QWORD *)&v81[16] = 0;
    goto LABEL_86;
  }
  v71 = __nwlog_obj();
  os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v77 = "strict_calloc";
  v78 = 2048;
  *(_QWORD *)v79 = 1;
  *(_WORD *)&v79[8] = 2048;
  v80[0] = 40;
  v72 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v72);
  if (!(_DWORD)result)
  {
    free(v72);
    if (LODWORD(size[1]))
      goto LABEL_54;
    goto LABEL_52;
  }
LABEL_158:
  __break(1u);
  return result;
}

void nw_socket_internal_connect(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(_QWORD, _QWORD *);
  const char *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  const char *v18;
  const char *v19;
  const char *v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = a1[4];
  v3 = mach_continuous_time();
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = v3;
  v5 = nw_delta_nanos(v2, v4);
  v6 = (v5 / 0xF4240);
  if (v5 > 0xF423FFFFFFFFFLL)
    v6 = 0xFFFFFFFFLL;
  a1[5] = v6;
  v7 = a1[6];
  if (v7)
  {
    v8 = *(_QWORD *)(v7 + 24);
    if (v8)
    {
      v9 = *(void (**)(_QWORD, _QWORD *))(v8 + 40);
      if (v9)
      {
        v9(a1[6], a1 - 12);
        return;
      }
    }
    __nwlog_obj();
    v10 = *(const char **)(v7 + 16);
    if (!v10)
      v10 = "invalid";
  }
  else
  {
    __nwlog_obj();
    v10 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  v24 = "nw_socket_internal_connect";
  v25 = 2082;
  v26 = v10;
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v11, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_40;
      v14 = "invalid";
      if (v7 && *(_QWORD *)(v7 + 16))
        v14 = *(const char **)(v7 + 16);
      *(_DWORD *)buf = 136446466;
      v24 = "nw_socket_internal_connect";
      v25 = 2082;
      v26 = v14;
      v15 = "%{public}s protocol %{public}s has invalid connected callback";
      goto LABEL_39;
    }
    if (!v21)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_40;
      v19 = "invalid";
      if (v7 && *(_QWORD *)(v7 + 16))
        v19 = *(const char **)(v7 + 16);
      *(_DWORD *)buf = 136446466;
      v24 = "nw_socket_internal_connect";
      v25 = 2082;
      v26 = v19;
      v15 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v17 = os_log_type_enabled(v12, type);
    if (backtrace_string)
    {
      if (v17)
      {
        v18 = "invalid";
        if (v7 && *(_QWORD *)(v7 + 16))
          v18 = *(const char **)(v7 + 16);
        *(_DWORD *)buf = 136446722;
        v24 = "nw_socket_internal_connect";
        v25 = 2082;
        v26 = v18;
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_40;
    }
    if (v17)
    {
      v20 = "invalid";
      if (v7 && *(_QWORD *)(v7 + 16))
        v20 = *(const char **)(v7 + 16);
      *(_DWORD *)buf = 136446466;
      v24 = "nw_socket_internal_connect";
      v25 = 2082;
      v26 = v20;
      v15 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_39:
      _os_log_impl(&dword_182FBE000, v12, v13, v15, buf, 0x16u);
    }
  }
LABEL_40:
  if (v11)
    free(v11);
}

void nw_protocol_default_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*input_finished)(void);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_finished";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_default_input_finished";
      v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_default_input_finished";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v5)
          return;
        goto LABEL_35;
      }
      if (!v10)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_default_input_finished";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_default_input_finished";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_34;
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      input_finished = (void (*)(void))callbacks->input_finished;
      if (input_finished)
        input_finished();
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_default_input_finished";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_finished";
    v8 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_33;
  }
  if (!v13)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_finished";
    v8 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
    goto LABEL_33;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_default_input_finished";
    v8 = "%{public}s called with null protocol->default_input_handler, no backtrace";
    goto LABEL_33;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_protocol_default_input_finished";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5)
LABEL_35:
    free(v5);
}

void nw_socket_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol_identifier *identifier;
  int v4;
  uint64_t v5;
  void (*v6)(void);
  NSObject *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_socket_input_finished";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_socket_input_finished";
      v11 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_socket_input_finished";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_42:
        if (!v8)
          return;
LABEL_43:
        free(v8);
        return;
      }
      if (!v13)
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_socket_input_finished";
      v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_socket_input_finished";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_41:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_42;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    identifier = a1[2].identifier;
    v4 = *(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16);
    if (identifier)
    {
      if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x10) == 0)
      {
        HIBYTE(a1[6].handle) = BYTE2(v4);
        *(_WORD *)((char *)&a1[6].handle + 5) = v4 | 0x10;
        v5 = *(_QWORD *)&identifier->name[24];
        if (v5)
        {
          v6 = *(void (**)(void))(v5 + 184);
          if (v6)
            v6();
        }
      }
    }
    else if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v7 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_socket_input_finished";
        v20 = 2082;
        v21 = (char *)&a1[6].default_input_handler + 4;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_socket_input_finished";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v8, &type, &v16))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_socket_input_finished";
    v11 = "%{public}s called with null socket_handler";
    goto LABEL_41;
  }
  if (!v16)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_socket_input_finished";
    v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_41;
  }
  v14 = (char *)__nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v10 = type;
  v15 = os_log_type_enabled(v9, type);
  if (!v14)
  {
    if (!v15)
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_socket_input_finished";
    v11 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_41;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_socket_input_finished";
    v20 = 2082;
    v21 = v14;
    _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v14);
  if (v8)
    goto LABEL_43;
}

NWConcrete_nw_path_evaluator *nw_path_create_default_evaluator()
{
  return nw_path_create_evaluator_for_endpoint(0, 0);
}

uint64_t __nw_path_evaluator_call_update_handler_block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (__nwlog_path_log::onceToken[0] != -1)
    dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44205);
  v2 = (id)gpathLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    v3 = *(_QWORD *)(a1 + 32) + 80;
    v5 = 136446722;
    v6 = "nw_path_evaluator_call_update_handler_block_invoke";
    v7 = 1042;
    v8 = 16;
    v9 = 2098;
    v10 = v3;
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_INFO, "%{public}s [%{public,uuid_t}.16P] delivering update", (uint8_t *)&v5, 0x1Cu);
  }

  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
}

uint64_t sub_1831B9738()
{
  return sub_1831B9740();
}

uint64_t sub_1831B9740()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  uint64_t result;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;

  v0 = type metadata accessor for NWPath(0);
  MEMORY[0x1E0C80A78](v0);
  v2 = (char *)&v9 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  swift_beginAccess();
  result = swift_weakLoadStrong();
  if (result)
  {
    v4 = result;
    v5 = swift_unknownObjectRetain();
    sub_183062C08(v5, (uint64_t)v2);
    v6 = *(_QWORD *)(v4 + 16);
    v7 = v6 + *(_QWORD *)(*MEMORY[0x1E0DEC528] + *(_QWORD *)v6 + 16);
    v8 = (os_unfair_lock_s *)(v6 + ((*(unsigned int *)(*(_QWORD *)v6 + 48) + 3) & 0x1FFFFFFFCLL));
    os_unfair_lock_lock(v8);
    sub_183060DD0(v7, (uint64_t)v2);
    os_unfair_lock_unlock(v8);
    swift_release();
    return sub_183058AE0((uint64_t)v2, type metadata accessor for NWPath);
  }
  return result;
}

void nw_protocol_instance_set_is_datagram(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 0x80;
    else
      v5 = 0;
    *((_BYTE *)v3 + 402) = v5 & 0x80 | *((_BYTE *)v3 + 402) & 0x7F;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_instance_set_is_datagram";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_instance_set_is_datagram";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_instance_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

void nw_protocol_instance_set_limit_outbound_data(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 64;
    else
      v5 = 0;
    *((_BYTE *)v3 + 402) = *((_BYTE *)v3 + 402) & 0xBF | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_instance_set_limit_outbound_data";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_instance_set_limit_outbound_data";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_instance_set_limit_outbound_data";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

void nw_protocol_stack_set_original_proxied_transport_protocol(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 5, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_set_original_proxied_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

BOOL __nw_proxy_copy_http_connect_definition_block_invoke()
{
  NWConcrete_nw_protocol_definition *v0;
  void *v1;

  if (nw_protocol_http_connect_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_http_connect_identifier::onceToken, &__block_literal_global_35295);
  v0 = nw_protocol_definition_create_with_identifier(&g_http_connect_protocol_identifier);
  v1 = (void *)nw_proxy_copy_http_connect_definition::proxy_definition;
  nw_proxy_copy_http_connect_definition::proxy_definition = (uint64_t)v0;

  nw_protocol_definition_set_options_allocator((void *)nw_proxy_copy_http_connect_definition::proxy_definition, (uint64_t)nw_proxy_allocate_options, (uint64_t)nw_proxy_copy_options, (uint64_t)nw_proxy_deallocate_options);
  nw_protocol_definition_set_options_equality_check((void *)nw_proxy_copy_http_connect_definition::proxy_definition, (uint64_t)nw_proxy_option_is_equal);
  return nw_protocol_register_handle((uint64_t)&g_http_connect_protocol_identifier, (void *)nw_proxy_copy_http_connect_definition::proxy_definition, (uint64_t)nw_protocol_http_connect_create, 0);
}

uint64_t nw_protocol_instance_get_multipath_service(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_instance_get_multipath_service";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_protocol_instance_get_multipath_service";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_protocol_instance_get_multipath_service";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_protocol_instance_get_multipath_service";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_protocol_instance_get_multipath_service";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v7)
      free(v7);
    goto LABEL_22;
  }
  v3 = (void *)*((_QWORD *)v1 + 6);
  if (!v3)
  {
LABEL_22:
    v5 = 0;
    goto LABEL_23;
  }
  v4 = v3;
  v5 = *(unsigned int *)(v4[13] + 103);

LABEL_23:
  return v5;
}

uint64_t NWPathMonitor.pathUpdateHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  os_unfair_lock_s *v7;

  v5 = *(_QWORD *)(v2 + 16);
  v6 = v5 + *(_QWORD *)(*MEMORY[0x1E0DEC528] + *(_QWORD *)v5 + 16);
  v7 = (os_unfair_lock_s *)(v5 + ((*(unsigned int *)(*(_QWORD *)v5 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v7);
  sub_1831BA424(v6, a1, a2);
  os_unfair_lock_unlock(v7);
  return sub_1830630AC(a1);
}

uint64_t sub_1831BA424(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (uint64_t *)(a1 + *(int *)(type metadata accessor for NWPathMonitor.LockedState(0) + 20));
  v6 = *v5;
  sub_183061488(a2);
  result = sub_1830630AC(v6);
  *v5 = a2;
  v5[1] = a3;
  return result;
}

uint64_t on_frame_send_callback(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v5;
  int v7;
  uint64_t stream_from_id;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  uint32_t v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t);
  NSObject *v26;
  os_log_type_t v27;
  uint32_t v28;
  NSObject *v29;
  int v30;
  int v31;
  uint64_t v32;
  NSObject *v33;
  int v34;
  int v35;
  NSObject *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  NSObject *v39;
  _BOOL4 v40;
  int v41;
  const char *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  const char *v46;
  const char *v47;
  char *v48;
  _BOOL4 v49;
  const char *v50;
  NSObject *v51;
  const char *v52;
  const char *v53;
  char v54;
  os_log_type_t type[8];
  os_log_type_t v56;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  _BYTE v60[10];
  _BYTE v61[10];
  int v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v29 = __nwlog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      v30 = *((unsigned __int8 *)a2 + 12);
      v31 = *((_DWORD *)a2 + 2);
      v32 = *a2;
      *(_DWORD *)buf = 136446978;
      v58 = "on_frame_send_callback";
      v59 = 1024;
      *(_DWORD *)v60 = v30;
      *(_WORD *)&v60[4] = 1024;
      *(_DWORD *)&v60[6] = v31;
      *(_WORD *)v61 = 2048;
      *(_QWORD *)&v61[2] = v32;
      _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s called for frame type %u on stream %d length (no header) %zu", buf, 0x22u);
    }
  }
  v5 = *((unsigned __int8 *)a2 + 12);
  if (v5 == 8)
  {
    if (gLogDatapath)
    {
      v33 = __nwlog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        v34 = *((_DWORD *)a2 + 2);
        v35 = *((_DWORD *)a2 + 4);
        *(_DWORD *)buf = 136446722;
        v58 = "on_frame_send_callback";
        v59 = 1024;
        *(_DWORD *)v60 = v34;
        *(_WORD *)&v60[4] = 1024;
        *(_DWORD *)&v60[6] = v35;
        _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s sending window update frame for stream %d, window increment %d", buf, 0x18u);
      }
    }
    v5 = *((unsigned __int8 *)a2 + 12);
  }
  if (v5)
    return 0;
  v7 = *((_DWORD *)a2 + 2);
  if (!v7)
    return 0;
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v58 = "on_frame_send_callback";
    v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v56 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v12, type, &v56))
      goto LABEL_41;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v36 = __nwlog_obj();
      v37 = type[0];
      if (!os_log_type_enabled(v36, type[0]))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v58 = "on_frame_send_callback";
      v15 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }
    else if (v56)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v36 = __nwlog_obj();
      v37 = type[0];
      v38 = os_log_type_enabled(v36, type[0]);
      if (backtrace_string)
      {
        if (!v38)
          goto LABEL_24;
        *(_DWORD *)buf = 136446466;
        v58 = "on_frame_send_callback";
        v59 = 2082;
        *(_QWORD *)v60 = backtrace_string;
        v18 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
        v19 = v36;
        v20 = v37;
        v21 = 22;
        goto LABEL_23;
      }
      if (!v38)
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v58 = "on_frame_send_callback";
      v15 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }
    else
    {
      v36 = __nwlog_obj();
      v37 = type[0];
      if (!os_log_type_enabled(v36, type[0]))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v58 = "on_frame_send_callback";
      v15 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }
    v26 = v36;
    v27 = v37;
    v28 = 12;
    goto LABEL_40;
  }
  if (*(_QWORD *)(a3 + 120))
  {
    *(_QWORD *)type = 0;
    stream_from_id = nw_http2_transport_get_stream_from_id(a3, v7, type);
    if (stream_from_id)
    {
      v9 = stream_from_id;
      v10 = *(_QWORD *)type;
      if (*(_QWORD *)type)
      {
        if (*(_QWORD *)(stream_from_id + 16))
        {
          nw_http2_transport_drain_next_frame_for_stream(a3, *(uint64_t *)type, stream_from_id, 0);
          return 0;
        }
        if ((*(_BYTE *)(stream_from_id + 36) & 4) != 0)
        {
          if (gLogDatapath)
          {
            v51 = __nwlog_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              v58 = "on_frame_send_callback";
              v59 = 2082;
              *(_QWORD *)v60 = a3 + 205;
              _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sending deferred end stream", buf, 0x16u);
            }
          }
          nw_http2_transport_send_end_stream(a3, v9);
          return 0;
        }
        if (!gLogDatapath)
          goto LABEL_99;
        v39 = __nwlog_obj();
        v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG);
        v10 = *(_QWORD *)type;
        if (v40)
        {
          v41 = *(_DWORD *)(v9 + 32);
          *(_DWORD *)buf = 136446978;
          v58 = "on_frame_send_callback";
          v59 = 2082;
          *(_QWORD *)v60 = a3 + 205;
          *(_WORD *)&v60[8] = 2048;
          *(_QWORD *)v61 = *(_QWORD *)type;
          *(_WORD *)&v61[8] = 1024;
          v62 = v41;
          _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s no more pending output frames, delivering output available to protocol %p for stream %d", buf, 0x26u);
          v10 = *(_QWORD *)type;
        }
        if (v10)
        {
LABEL_99:
          v24 = *(_QWORD *)(v10 + 24);
          if (v24)
          {
            v25 = *(void (**)(uint64_t, uint64_t))(v24 + 72);
            if (v25)
            {
              v25(v10, a3);
              return 0;
            }
          }
        }
        __nwlog_obj();
        v42 = "invalid";
        if (*(_QWORD *)type && *(_QWORD *)(*(_QWORD *)type + 16))
          v42 = *(const char **)(*(_QWORD *)type + 16);
        *(_DWORD *)buf = 136446466;
        v58 = "on_frame_send_callback";
        v59 = 2082;
        *(_QWORD *)v60 = v42;
        v43 = (char *)_os_log_send_and_compose_impl();
        v56 = OS_LOG_TYPE_ERROR;
        v54 = 0;
        if (__nwlog_fault(v43, &v56, &v54))
        {
          if (v56 == OS_LOG_TYPE_FAULT)
          {
            v44 = __nwlog_obj();
            v45 = v56;
            if (!os_log_type_enabled(v44, v56))
              goto LABEL_95;
            v46 = "invalid";
            if (*(_QWORD *)type && *(_QWORD *)(*(_QWORD *)type + 16))
              v46 = *(const char **)(*(_QWORD *)type + 16);
            *(_DWORD *)buf = 136446466;
            v58 = "on_frame_send_callback";
            v59 = 2082;
            *(_QWORD *)v60 = v46;
            v47 = "%{public}s protocol %{public}s has invalid output_available callback";
            goto LABEL_94;
          }
          if (!v54)
          {
            v44 = __nwlog_obj();
            v45 = v56;
            if (!os_log_type_enabled(v44, v56))
              goto LABEL_95;
            v52 = "invalid";
            if (*(_QWORD *)type && *(_QWORD *)(*(_QWORD *)type + 16))
              v52 = *(const char **)(*(_QWORD *)type + 16);
            *(_DWORD *)buf = 136446466;
            v58 = "on_frame_send_callback";
            v59 = 2082;
            *(_QWORD *)v60 = v52;
            v47 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
            goto LABEL_94;
          }
          v48 = (char *)__nw_create_backtrace_string();
          v44 = __nwlog_obj();
          v45 = v56;
          v49 = os_log_type_enabled(v44, v56);
          if (v48)
          {
            if (v49)
            {
              v50 = "invalid";
              if (*(_QWORD *)type && *(_QWORD *)(*(_QWORD *)type + 16))
                v50 = *(const char **)(*(_QWORD *)type + 16);
              *(_DWORD *)buf = 136446722;
              v58 = "on_frame_send_callback";
              v59 = 2082;
              *(_QWORD *)v60 = v50;
              *(_WORD *)&v60[8] = 2082;
              *(_QWORD *)v61 = v48;
              _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v48);
            goto LABEL_95;
          }
          if (v49)
          {
            v53 = "invalid";
            if (*(_QWORD *)type && *(_QWORD *)(*(_QWORD *)type + 16))
              v53 = *(const char **)(*(_QWORD *)type + 16);
            *(_DWORD *)buf = 136446466;
            v58 = "on_frame_send_callback";
            v59 = 2082;
            *(_QWORD *)v60 = v53;
            v47 = "%{public}s protocol %{public}s has invalid output_available callback, no backtrace";
LABEL_94:
            _os_log_impl(&dword_182FBE000, v44, v45, v47, buf, 0x16u);
          }
        }
LABEL_95:
        if (v43)
          free(v43);
        return 0;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v23 = *(_DWORD *)(v9 + 32);
        *(_DWORD *)buf = 136446978;
        v58 = "on_frame_send_callback";
        v59 = 2082;
        *(_QWORD *)v60 = a3 + 205;
        *(_WORD *)&v60[8] = 2048;
        *(_QWORD *)v61 = v9;
        *(_WORD *)&v61[8] = 1024;
        v62 = v23;
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, "%{public}s %{public}s stream (%pm %u) did not have protocol extra", buf, 0x26u);
      }
    }
    return 4294966775;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v11 = a3 + 205;
  *(_DWORD *)buf = 136446466;
  v58 = "on_frame_send_callback";
  v59 = 2082;
  *(_QWORD *)v60 = a3 + 205;
  v12 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v56 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v12, type, &v56))
    goto LABEL_41;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    v14 = type[0];
    if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
    {
      *(_DWORD *)buf = 136446466;
      v58 = "on_frame_send_callback";
      v59 = 2082;
      *(_QWORD *)v60 = v11;
      v15 = "%{public}s %{public}s id based hash table has not yet been created, failing connection";
LABEL_39:
      v26 = v13;
      v27 = v14;
      v28 = 22;
LABEL_40:
      _os_log_impl(&dword_182FBE000, v26, v27, v15, buf, v28);
      goto LABEL_41;
    }
    goto LABEL_41;
  }
  if (v56)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    v14 = type[0];
    v17 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v58 = "on_frame_send_callback";
        v59 = 2082;
        *(_QWORD *)v60 = v11;
        v15 = "%{public}s %{public}s id based hash table has not yet been created, failing connection, no backtrace";
        goto LABEL_39;
      }
      goto LABEL_41;
    }
    if (!v17)
    {
LABEL_24:
      free(backtrace_string);
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446722;
    v58 = "on_frame_send_callback";
    v59 = 2082;
    *(_QWORD *)v60 = v11;
    *(_WORD *)&v60[8] = 2082;
    *(_QWORD *)v61 = backtrace_string;
    v18 = "%{public}s %{public}s id based hash table has not yet been created, failing connection, dumping backtrace:%{public}s";
    v19 = v13;
    v20 = v14;
    v21 = 32;
LABEL_23:
    _os_log_impl(&dword_182FBE000, v19, v20, v18, buf, v21);
    goto LABEL_24;
  }
  v13 = __nwlog_obj();
  v14 = type[0];
  if (os_log_type_enabled(v13, type[0]))
  {
    *(_DWORD *)buf = 136446466;
    v58 = "on_frame_send_callback";
    v59 = 2082;
    *(_QWORD *)v60 = v11;
    v15 = "%{public}s %{public}s id based hash table has not yet been created, failing connection, backtrace limit exceeded";
    goto LABEL_39;
  }
LABEL_41:
  if (v12)
    free(v12);
  return 4294966394;
}

{
  unsigned int v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  int v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  int v24;
  int v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  uint32_t v29;
  char *v30;
  _BOOL4 v31;
  int v32;
  NSObject *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  char *v38;
  unint64_t v39;
  int8x8_t v40;
  uint8x8_t v41;
  unint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  NSObject *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  NSObject *v57;
  int v58;
  int v59;
  uint64_t v60;
  NSObject *v61;
  int v62;
  int v63;
  const char *v64;
  NSObject *v65;
  os_log_type_t v66;
  const char *v67;
  char *backtrace_string;
  _BOOL4 v69;
  NSObject *v70;
  int v71;
  _BOOL4 v72;
  NSObject *v73;
  int v74;
  int v75;
  NSObject *v76;
  uint64_t v77;
  NSObject *v78;
  int v79;
  int v80;
  NSObject *v81;
  int v82;
  int v83;
  os_log_type_t type[15];
  char v85;
  uint8_t buf[4];
  const char *v87;
  __int16 v88;
  _BYTE v89[10];
  _BYTE v90[10];
  _BYTE v91[26];
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v57 = __nwlog_obj();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
    {
      v58 = *((unsigned __int8 *)a2 + 12);
      v59 = *((_DWORD *)a2 + 2);
      v60 = *a2;
      *(_DWORD *)buf = 136446978;
      v87 = "on_frame_send_callback";
      v88 = 1024;
      *(_DWORD *)v89 = v58;
      *(_WORD *)&v89[4] = 1024;
      *(_DWORD *)&v89[6] = v59;
      *(_WORD *)v90 = 2048;
      *(_QWORD *)&v90[2] = v60;
      _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_DEBUG, "%{public}s called for frame type %u on stream %d length (no header) %zu", buf, 0x22u);
    }
  }
  v5 = *((unsigned __int8 *)a2 + 12);
  if (v5 == 8)
  {
    if (gLogDatapath)
    {
      v61 = __nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
      {
        v62 = *((_DWORD *)a2 + 2);
        v63 = *((_DWORD *)a2 + 4);
        *(_DWORD *)buf = 136446722;
        v87 = "on_frame_send_callback";
        v88 = 1024;
        *(_DWORD *)v89 = v62;
        *(_WORD *)&v89[4] = 1024;
        *(_DWORD *)&v89[6] = v63;
        _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEBUG, "%{public}s sending window update frame for stream %d, window increment %d", buf, 0x18u);
      }
    }
    v5 = *((unsigned __int8 *)a2 + 12);
  }
  if (v5 > 1)
    goto LABEL_73;
  v6 = *((_DWORD *)a2 + 2);
  if (!v6)
    return 0;
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v87 = "on_frame_send_callback";
    v64 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v85 = 0;
    if (!__nwlog_fault(v64, type, &v85))
      goto LABEL_157;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v65 = __nwlog_obj();
      v66 = type[0];
      if (os_log_type_enabled(v65, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2";
LABEL_156:
        _os_log_impl(&dword_182FBE000, v65, v66, v67, buf, 0xCu);
      }
LABEL_157:
      if (!v64)
        return 4294966394;
      v38 = (char *)v64;
      goto LABEL_68;
    }
    if (!v85)
    {
      v65 = __nwlog_obj();
      v66 = type[0];
      if (os_log_type_enabled(v65, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
        goto LABEL_156;
      }
      goto LABEL_157;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v65 = __nwlog_obj();
    v66 = type[0];
    v69 = os_log_type_enabled(v65, type[0]);
    if (!backtrace_string)
    {
      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
        goto LABEL_156;
      }
      goto LABEL_157;
    }
    if (v69)
      goto LABEL_142;
    goto LABEL_143;
  }
  if (!*(_QWORD *)(a3 + 160))
  {
    if (*(__int16 *)(a3 + 376) < 0)
      return 4294966394;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v17 = *(_DWORD *)(a3 + 368);
    *(_DWORD *)buf = 136446978;
    v87 = "on_frame_send_callback";
    v88 = 2082;
    *(_QWORD *)v89 = a3 + 378;
    *(_WORD *)&v89[8] = 2080;
    *(_QWORD *)v90 = " ";
    *(_WORD *)&v90[8] = 1024;
    *(_DWORD *)v91 = v17;
    v18 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v85 = 0;
    if (__nwlog_fault(v18, type, &v85))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = gconnectionLogObj;
        v20 = type[0];
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
        {
          v21 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)buf = 136446978;
          v87 = "on_frame_send_callback";
          v88 = 2082;
          *(_QWORD *)v89 = a3 + 378;
          *(_WORD *)&v89[8] = 2080;
          *(_QWORD *)v90 = " ";
          *(_WORD *)&v90[8] = 1024;
          *(_DWORD *)v91 = v21;
          v22 = "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection";
LABEL_65:
          _os_log_impl(&dword_182FBE000, v19, v20, v22, buf, 0x26u);
        }
      }
      else if (v85)
      {
        v30 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = gconnectionLogObj;
        v20 = type[0];
        v31 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
        if (!v30)
        {
          if (!v31)
            goto LABEL_66;
          v37 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)buf = 136446978;
          v87 = "on_frame_send_callback";
          v88 = 2082;
          *(_QWORD *)v89 = a3 + 378;
          *(_WORD *)&v89[8] = 2080;
          *(_QWORD *)v90 = " ";
          *(_WORD *)&v90[8] = 1024;
          *(_DWORD *)v91 = v37;
          v22 = "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection, no backtrace";
          goto LABEL_65;
        }
        if (v31)
        {
          v32 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)buf = 136447234;
          v87 = "on_frame_send_callback";
          v88 = 2082;
          *(_QWORD *)v89 = a3 + 378;
          *(_WORD *)&v89[8] = 2080;
          *(_QWORD *)v90 = " ";
          *(_WORD *)&v90[8] = 1024;
          *(_DWORD *)v91 = v32;
          *(_WORD *)&v91[4] = 2082;
          *(_QWORD *)&v91[6] = v30;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v30);
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = gconnectionLogObj;
        v20 = type[0];
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
        {
          v36 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)buf = 136446978;
          v87 = "on_frame_send_callback";
          v88 = 2082;
          *(_QWORD *)v89 = a3 + 378;
          *(_WORD *)&v89[8] = 2080;
          *(_QWORD *)v90 = " ";
          *(_WORD *)&v90[8] = 1024;
          *(_DWORD *)v91 = v36;
          v22 = "%{public}s %{public}s%s<i%u> id based hash table has not yet been created, failing connection, backtrace limit exceeded";
          goto LABEL_65;
        }
      }
    }
LABEL_66:
    if (v18)
    {
      v38 = (char *)v18;
LABEL_68:
      free(v38);
    }
    return 4294966394;
  }
  *(_QWORD *)type = 0;
  result = nw_http2_get_stream_from_id(a3, v6, type);
  if (result)
  {
    v8 = result;
    if (!*(_QWORD *)type)
    {
      if (((*(unsigned __int16 *)(result + 188) | (*(unsigned __int8 *)(result + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v33 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v35 = *(_DWORD *)(v8 + 176);
          v34 = *(_DWORD *)(v8 + 180);
          *(_DWORD *)buf = 136447746;
          v87 = "on_frame_send_callback";
          v88 = 2082;
          *(_QWORD *)v89 = v8 + 191;
          *(_WORD *)&v89[8] = 2080;
          *(_QWORD *)v90 = " ";
          *(_WORD *)&v90[8] = 1024;
          *(_DWORD *)v91 = v34;
          *(_WORD *)&v91[4] = 1024;
          *(_DWORD *)&v91[6] = v35;
          *(_WORD *)&v91[10] = 2048;
          *(_QWORD *)&v91[12] = v8;
          *(_WORD *)&v91[20] = 1024;
          *(_DWORD *)&v91[22] = v35;
          _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> stream (%pm %d) did not have protocol extra", buf, 0x3Cu);
          return 4294966394;
        }
      }
      return 4294966394;
    }
    v9 = *((unsigned __int8 *)a2 + 12);
    if (v9 == 1)
    {
      *(_QWORD *)(result + 128) = *(_QWORD *)(result + 120);
      nw_http_transaction_metadata_increment_outbound_header_size(*(void **)(result + 96), 9 * ((unint64_t)(*a2 + 0x3FFF) >> 14) + *a2);
      v10 = *(unsigned __int16 *)(v8 + 188);
      v11 = v10 | (*(unsigned __int8 *)(v8 + 190) << 16);
      if ((v10 & 0x2000) != 0)
      {
        *(_BYTE *)(v8 + 190) = BYTE2(v11);
        *(_WORD *)(v8 + 188) = v11 & 0xDEFF;
        v12 = *(void **)(v8 + 104);
        if (v12)
        {
          os_release(v12);
          *(_QWORD *)(v8 + 104) = 0;
        }
      }
      v9 = *((unsigned __int8 *)a2 + 12);
    }
    if (!v9)
    {
      nw_http_transaction_metadata_increment_outbound_body_transfer_size(*(void **)(v8 + 96), *a2 + 9);
      v13 = *a2;
      v14 = *(_QWORD *)(v8 + 56);
      v15 = __CFADD__(v14, *a2);
      *(_QWORD *)(v8 + 56) = v14 + *a2;
      if (v15)
      {
        if (gLogDatapath)
        {
          v76 = __nwlog_obj();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
          {
            v77 = *(_QWORD *)(v8 + 56);
            *(_DWORD *)buf = 136446978;
            v87 = "increment_outbound_body_size";
            v88 = 2082;
            *(_QWORD *)v89 = "outbound_body_size";
            *(_WORD *)&v89[8] = 2048;
            *(_QWORD *)v90 = v13;
            *(_WORD *)&v90[8] = 2048;
            *(_QWORD *)v91 = v77;
            _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
          }
        }
        *(_QWORD *)(v8 + 56) = -1;
      }
    }
    if ((*((_BYTE *)a2 + 13) & 1) != 0)
    {
      if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v73 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v75 = *(_DWORD *)(v8 + 176);
          v74 = *(_DWORD *)(v8 + 180);
          *(_DWORD *)buf = 136447490;
          v87 = "on_frame_send_callback";
          v88 = 2082;
          *(_QWORD *)v89 = v8 + 191;
          *(_WORD *)&v89[8] = 2080;
          *(_QWORD *)v90 = " ";
          *(_WORD *)&v90[8] = 1024;
          *(_DWORD *)v91 = v74;
          *(_WORD *)&v91[4] = 1024;
          *(_DWORD *)&v91[6] = v75;
          *(_WORD *)&v91[10] = 1024;
          *(_DWORD *)&v91[12] = v75;
          _os_log_impl(&dword_182FBE000, v73, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream %d end stream flag set, marking outbound message complete", buf, 0x32u);
        }
      }
      *(_WORD *)(v8 + 188) |= 0x4000u;
      nw_http_transaction_metadata_mark_outbound_message_end(*(void **)(v8 + 96));
      if (*(_BYTE *)(v8 + 48))
      {
        if (*(_QWORD *)(v8 + 40) != *(_QWORD *)(v8 + 56))
        {
          v50 = *(unsigned __int16 *)(v8 + 188);
          v51 = v50 | (*(unsigned __int8 *)(v8 + 190) << 16);
          if ((v50 & 0x40) == 0)
          {
            *(_BYTE *)(v8 + 190) = BYTE2(v51);
            *(_WORD *)(v8 + 188) = v51 | 0x40;
            if ((*(__int16 *)(a3 + 376) & 0x80000000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v52 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
              {
                v53 = *(_DWORD *)(a3 + 368);
                if (*(_BYTE *)(v8 + 48))
                  v54 = *(_QWORD *)(v8 + 40);
                else
                  v54 = -1;
                v56 = *(_QWORD *)(v8 + 56);
                *(_DWORD *)buf = 136447490;
                v87 = "on_frame_send_callback";
                v88 = 2082;
                *(_QWORD *)v89 = a3 + 378;
                *(_WORD *)&v89[8] = 2080;
                *(_QWORD *)v90 = " ";
                *(_WORD *)&v90[8] = 1024;
                *(_DWORD *)v91 = v53;
                *(_WORD *)&v91[4] = 2048;
                *(_QWORD *)&v91[6] = v54;
                *(_WORD *)&v91[14] = 2048;
                *(_QWORD *)&v91[16] = v56;
                _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Content length header %llu does not equal body size %llu", buf, 0x3Au);
              }
            }
            nw_protocol_error(*(_QWORD **)type, a3);
            nw_protocol_disconnected(*(_QWORD **)type, a3);
          }
          return 0;
        }
      }
    }
    if (!*(_QWORD *)(v8 + 16))
    {
      v16 = (*(unsigned __int8 *)(v8 + 190) >> 3) & 1;
      if (!gLogDatapath)
        LOBYTE(v16) = 1;
      if ((*(_WORD *)(v8 + 188) & 0x10) != 0)
      {
        if ((v16 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v81 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v83 = *(_DWORD *)(v8 + 176);
            v82 = *(_DWORD *)(v8 + 180);
            *(_DWORD *)buf = 136447234;
            v87 = "on_frame_send_callback";
            v88 = 2082;
            *(_QWORD *)v89 = v8 + 191;
            *(_WORD *)&v89[8] = 2080;
            *(_QWORD *)v90 = " ";
            *(_WORD *)&v90[8] = 1024;
            *(_DWORD *)v91 = v82;
            *(_WORD *)&v91[4] = 1024;
            *(_DWORD *)&v91[6] = v83;
            _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> sending deferred end stream", buf, 0x2Cu);
          }
        }
        nw_http2_send_end_stream(a3, v8);
      }
      else
      {
        if ((v16 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v78 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            v80 = *(_DWORD *)(v8 + 176);
            v79 = *(_DWORD *)(v8 + 180);
            *(_DWORD *)buf = 136447746;
            v87 = "on_frame_send_callback";
            v88 = 2082;
            *(_QWORD *)v89 = v8 + 191;
            *(_WORD *)&v89[8] = 2080;
            *(_QWORD *)v90 = " ";
            *(_WORD *)&v90[8] = 1024;
            *(_DWORD *)v91 = v79;
            *(_WORD *)&v91[4] = 1024;
            *(_DWORD *)&v91[6] = v80;
            *(_WORD *)&v91[10] = 2048;
            *(_QWORD *)&v91[12] = *(_QWORD *)type;
            *(_WORD *)&v91[20] = 1024;
            *(_DWORD *)&v91[22] = v80;
            _os_log_impl(&dword_182FBE000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> no more written output frames, pending output available to protocol %p for stream %d", buf, 0x3Cu);
          }
        }
        nw_http2_set_stream_output_available_pending(a3, v8, 1);
      }
    }
    v5 = *((unsigned __int8 *)a2 + 12);
LABEL_73:
    if (v5 != 6 || (*((_BYTE *)a2 + 13) & 1) != 0)
      return 0;
    if (a3)
    {
      v39 = a2[2];
      if ((*(__int16 *)(a3 + 376) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v70 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v71 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)buf = 136447234;
          v87 = "nw_http2_sending_ping";
          v88 = 2082;
          *(_QWORD *)v89 = a3 + 378;
          *(_WORD *)&v89[8] = 2080;
          *(_QWORD *)v90 = " ";
          *(_WORD *)&v90[8] = 1024;
          *(_DWORD *)v91 = v71;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = v39;
          _os_log_impl(&dword_182FBE000, v70, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> seq %llu", buf, 0x30u);
        }
      }
      v40 = *(int8x8_t *)(a3 + 320);
      if (v40)
      {
        v41 = (uint8x8_t)vcnt_s8(v40);
        v41.i16[0] = vaddlv_u8(v41);
        if (v41.u32[0] > 1uLL)
        {
          v42 = v39;
          if (*(_QWORD *)&v40 <= v39)
            v42 = v39 % *(_QWORD *)&v40;
        }
        else
        {
          v42 = (*(_QWORD *)&v40 - 1) & v39;
        }
        v43 = *(_QWORD **)(*(_QWORD *)(a3 + 312) + 8 * v42);
        if (v43)
        {
          v44 = (_QWORD *)*v43;
          if (*v43)
          {
            if (v41.u32[0] < 2uLL)
            {
              v45 = *(_QWORD *)&v40 - 1;
              while (1)
              {
                v47 = v44[1];
                if (v47 == v39)
                {
                  if (v44[2] == v39)
                    goto LABEL_113;
                }
                else if ((v47 & v45) != v42)
                {
                  goto LABEL_98;
                }
                v44 = (_QWORD *)*v44;
                if (!v44)
                  goto LABEL_98;
              }
            }
            do
            {
              v46 = v44[1];
              if (v46 == v39)
              {
                if (v44[2] == v39)
                {
LABEL_113:
                  v55 = mach_continuous_time();
                  result = 0;
                  if (v55 <= 1)
                    v55 = 1;
                  v44[3] = v55;
                  return result;
                }
              }
              else
              {
                if (v46 >= *(_QWORD *)&v40)
                  v46 %= *(_QWORD *)&v40;
                if (v46 != v42)
                  break;
              }
              v44 = (_QWORD *)*v44;
            }
            while (v44);
          }
        }
      }
LABEL_98:
      if ((*(__int16 *)(a3 + 376) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v48 = gconnectionLogObj;
        result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        v49 = *(_DWORD *)(a3 + 368);
        *(_DWORD *)buf = 136447234;
        v87 = "nw_http2_sending_ping";
        v88 = 2082;
        *(_QWORD *)v89 = a3 + 378;
        *(_WORD *)&v89[8] = 2080;
        *(_QWORD *)v90 = " ";
        *(_WORD *)&v90[8] = 1024;
        *(_DWORD *)v91 = v49;
        *(_WORD *)&v91[4] = 2048;
        *(_QWORD *)&v91[6] = v39;
        v26 = "%{public}s %{public}s%s<i%u> unrecognized ping data %llu";
        v27 = v48;
        v28 = OS_LOG_TYPE_ERROR;
        v29 = 48;
        goto LABEL_103;
      }
      return 0;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v87 = "on_frame_send_callback";
    v64 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v85 = 0;
    if (!__nwlog_fault(v64, type, &v85))
      goto LABEL_157;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v65 = __nwlog_obj();
      v66 = type[0];
      if (os_log_type_enabled(v65, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2";
        goto LABEL_156;
      }
      goto LABEL_157;
    }
    if (!v85)
    {
      v65 = __nwlog_obj();
      v66 = type[0];
      if (os_log_type_enabled(v65, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
        goto LABEL_156;
      }
      goto LABEL_157;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v65 = __nwlog_obj();
    v66 = type[0];
    v72 = os_log_type_enabled(v65, type[0]);
    if (!backtrace_string)
    {
      if (v72)
      {
        *(_DWORD *)buf = 136446210;
        v87 = "on_frame_send_callback";
        v67 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
        goto LABEL_156;
      }
      goto LABEL_157;
    }
    if (v72)
    {
LABEL_142:
      *(_DWORD *)buf = 136446466;
      v87 = "on_frame_send_callback";
      v88 = 2082;
      *(_QWORD *)v89 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_143:
    free(backtrace_string);
    goto LABEL_157;
  }
  if ((*(__int16 *)(a3 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v23 = gconnectionLogObj;
    result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      v24 = *(_DWORD *)(a3 + 368);
      v25 = *((_DWORD *)a2 + 2);
      *(_DWORD *)buf = 136447234;
      v87 = "on_frame_send_callback";
      v88 = 2082;
      *(_QWORD *)v89 = a3 + 378;
      *(_WORD *)&v89[8] = 2080;
      *(_QWORD *)v90 = " ";
      *(_WORD *)&v90[8] = 1024;
      *(_DWORD *)v91 = v24;
      *(_WORD *)&v91[4] = 1024;
      *(_DWORD *)&v91[6] = v25;
      v26 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
      v27 = v23;
      v28 = OS_LOG_TYPE_DEBUG;
      v29 = 44;
LABEL_103:
      _os_log_impl(&dword_182FBE000, v27, v28, v26, buf, v29);
      return 0;
    }
  }
  return result;
}

void nw_flow_output_available(nw_protocol *a1, nw_protocol *a2)
{
  nw_flow_protocol *handle;
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_handler *v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v7;
  NSObject *v8;
  const char *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  char *v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  void *v31;
  __int16 v32;
  const char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  handle = (nw_flow_protocol *)a1->handle;
  v3 = handle->handler;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_flow_output_available";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v11, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_flow_output_available";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        v20 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_flow_output_available";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_flow_output_available";
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_flow_output_available";
          _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_39:
    if (v11)
      free(v11);
    goto LABEL_12;
  }
  v5 = v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    v7 = nw_endpoint_handler_copy_flow(v5);
    if (v7)
    {
      nw_flow_service_writes(v5, (NWConcrete_nw_endpoint_flow *)v7, handle);
LABEL_5:

      goto LABEL_12;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_flow_output_available";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v15, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_flow_output_available";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if (v26)
      {
        v21 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        v23 = os_log_type_enabled(v16, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_flow_output_available";
            v30 = 2082;
            v31 = v21;
            _os_log_impl(&dword_182FBE000, v16, v22, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v21);
          goto LABEL_47;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_flow_output_available";
          _os_log_impl(&dword_182FBE000, v16, v22, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_flow_output_available";
          _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_47:
    if (v15)
      free(v15);
    goto LABEL_5;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5)
      v9 = "unknown-mode";
    else
      v9 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v29 = "nw_flow_output_available";
    v30 = 2082;
    v31 = (void *)v9;
    v32 = 2082;
    v33 = "flow";
    _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_12:
}

void sub_1831BB408(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t on_data_chunk_recv_callback(uint64_t a1, uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t stream_from_id;
  uint64_t v11;
  uint64_t input_frame;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t result;
  uint64_t v18;
  int v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  int v23;
  const char *v24;
  void *v25;
  char *v26;
  _BOOL4 v27;
  int v28;
  uint64_t *v29;
  NSObject *v30;
  NSObject *v31;
  int v32;
  uint64_t v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  uint64_t v38;
  void (*v39)(void);
  char *v40;
  _BOOL4 v41;
  int v42;
  int v43;
  void *v44;
  char *v45;
  NSObject *v46;
  os_log_type_t v47;
  const char *v48;
  NSObject *v49;
  char *backtrace_string;
  _BOOL4 v51;
  const char *v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  const char *v57;
  char *v58;
  _BOOL4 v59;
  const char *v60;
  NSObject *v61;
  int v62;
  const char *v63;
  const char *v64;
  char v65;
  os_log_type_t v66[15];
  os_log_type_t type;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  _BYTE v73[14];
  __int16 v74;
  char *v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v69 = "on_data_chunk_recv_callback";
    v45 = (char *)_os_log_send_and_compose_impl();
    v66[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v45, v66, &type))
      goto LABEL_103;
    if (v66[0] == OS_LOG_TYPE_FAULT)
    {
      v46 = __nwlog_obj();
      v47 = v66[0];
      if (!os_log_type_enabled(v46, v66[0]))
        goto LABEL_103;
      *(_DWORD *)buf = 136446210;
      v69 = "on_data_chunk_recv_callback";
      v48 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v46 = __nwlog_obj();
      v47 = v66[0];
      v51 = os_log_type_enabled(v46, v66[0]);
      if (backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          v69 = "on_data_chunk_recv_callback";
          v70 = 2082;
          v71 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_103;
      }
      if (!v51)
      {
LABEL_103:
        if (v45)
          free(v45);
        return 4294966394;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "on_data_chunk_recv_callback";
      v48 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }
    else
    {
      v46 = __nwlog_obj();
      v47 = v66[0];
      if (!os_log_type_enabled(v46, v66[0]))
        goto LABEL_103;
      *(_DWORD *)buf = 136446210;
      v69 = "on_data_chunk_recv_callback";
      v48 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v46, v47, v48, buf, 0xCu);
    goto LABEL_103;
  }
  if (gLogDatapath)
  {
    v49 = __nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v69 = "on_data_chunk_recv_callback";
      v70 = 2082;
      v71 = a6 + 205;
      _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  *(_QWORD *)v66 = 0;
  stream_from_id = nw_http2_transport_get_stream_from_id(a6, a3, v66);
  if (!stream_from_id)
    return 4294966775;
  v11 = stream_from_id;
  input_frame = http2_transport_create_input_frame(a6, stream_from_id, a5);
  if (!input_frame)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = a6 + 205;
    v19 = *(_DWORD *)(v11 + 32);
    *(_DWORD *)buf = 136446978;
    v69 = "on_data_chunk_recv_callback";
    v70 = 2082;
    v71 = a6 + 205;
    v72 = 2048;
    *(_QWORD *)v73 = a5;
    *(_WORD *)&v73[8] = 1024;
    *(_DWORD *)&v73[10] = v19;
    v20 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (!__nwlog_fault(v20, &type, &v65))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_54;
      v23 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      v69 = "on_data_chunk_recv_callback";
      v70 = 2082;
      v71 = v18;
      v72 = 2048;
      *(_QWORD *)v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v23;
      v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d";
    }
    else if (v65)
    {
      v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      v22 = type;
      v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v26)
      {
        if (v27)
        {
          v28 = *(_DWORD *)(v11 + 32);
          *(_DWORD *)buf = 136447234;
          v69 = "on_data_chunk_recv_callback";
          v70 = 2082;
          v71 = v18;
          v72 = 2048;
          *(_QWORD *)v73 = a5;
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v28;
          v74 = 2082;
          v75 = v26;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v26);
        goto LABEL_54;
      }
      if (!v27)
      {
LABEL_54:
        if (v20)
          free(v20);
        return 4294966394;
      }
      v43 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      v69 = "on_data_chunk_recv_callback";
      v70 = 2082;
      v71 = v18;
      v72 = 2048;
      *(_QWORD *)v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v43;
      v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_54;
      v42 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      v69 = "on_data_chunk_recv_callback";
      v70 = 2082;
      v71 = v18;
      v72 = 2048;
      *(_QWORD *)v73 = a5;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v42;
      v24 = "%{public}s %{public}s failed to create/reuse input frame of length %zu for stream %d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x26u);
    goto LABEL_54;
  }
  v13 = input_frame;
  if (!*(_QWORD *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(_QWORD *)(input_frame + 88)))
  {
    v16 = 0;
    v25 = 0;
  }
  else
  {
    v15 = *(_DWORD *)(v13 + 52);
    v14 = *(unsigned int *)(v13 + 56);
    if (v15)
      v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    else
      v16 = 0;
    v25 = (void *)(*(_QWORD *)(v13 + 112) + v14);
  }
  if (v16 != a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v33 = a6 + 205;
    *(_DWORD *)buf = 136446978;
    v69 = "on_data_chunk_recv_callback";
    v70 = 2082;
    v71 = a6 + 205;
    v72 = 1024;
    *(_DWORD *)v73 = v16;
    *(_WORD *)&v73[4] = 2048;
    *(_QWORD *)&v73[6] = a5;
    v34 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (__nwlog_fault(v34, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          v69 = "on_data_chunk_recv_callback";
          v70 = 2082;
          v71 = v33;
          v72 = 1024;
          *(_DWORD *)v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(_QWORD *)&v73[6] = a5;
          v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame";
LABEL_58:
          _os_log_impl(&dword_182FBE000, v35, v36, v37, buf, 0x26u);
        }
      }
      else if (v65)
      {
        v40 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = type;
        v41 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v40)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136447234;
            v69 = "on_data_chunk_recv_callback";
            v70 = 2082;
            v71 = v33;
            v72 = 1024;
            *(_DWORD *)v73 = v16;
            *(_WORD *)&v73[4] = 2048;
            *(_QWORD *)&v73[6] = a5;
            v74 = 2082;
            v75 = v40;
            _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_create_input_frame, dumping backtrace:%{public}s", buf, 0x30u);
          }
          free(v40);
          goto LABEL_59;
        }
        if (v41)
        {
          *(_DWORD *)buf = 136446978;
          v69 = "on_data_chunk_recv_callback";
          v70 = 2082;
          v71 = v33;
          v72 = 1024;
          *(_DWORD *)v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(_QWORD *)&v73[6] = a5;
          v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame, no backtrace";
          goto LABEL_58;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          v69 = "on_data_chunk_recv_callback";
          v70 = 2082;
          v71 = v33;
          v72 = 1024;
          *(_DWORD *)v73 = v16;
          *(_WORD *)&v73[4] = 2048;
          *(_QWORD *)&v73[6] = a5;
          v37 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %zu) from http2_transport_c"
                "reate_input_frame, backtrace limit exceeded";
          goto LABEL_58;
        }
      }
    }
LABEL_59:
    if (v34)
      free(v34);
    if ((*(_WORD *)(v13 + 204) & 0x100) == 0
      || !g_channel_check_validity
      || g_channel_check_validity(v13, *(_QWORD *)(v13 + 88)))
    {
      v44 = *(void **)(v13 + 112);
      if (v44)
        free(v44);
    }
    nw_frame_reset(v13, 0, 0, 0, 0);
    os_release((void *)v13);
    return 4294966394;
  }
  memcpy(v25, a4, a5);
  *(_QWORD *)(v13 + 16) = 0;
  v29 = *(uint64_t **)(v11 + 8);
  *(_QWORD *)(v13 + 24) = v29;
  *v29 = v13;
  *(_QWORD *)(v11 + 8) = v13 + 16;
  if (!*(_QWORD *)v66)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v69 = "on_data_chunk_recv_callback";
      v70 = 2082;
      v71 = a6 + 205;
      v72 = 2048;
      *(_QWORD *)v73 = v11;
      _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}s stream (%p) did not have protocol extra", buf, 0x20u);
    }
  }
  if ((*(_BYTE *)(v11 + 36) & 1) != 0)
  {
    if (gLogDatapath)
    {
      v61 = __nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
      {
        v62 = *(_DWORD *)(v11 + 32);
        *(_DWORD *)buf = 136446978;
        v69 = "on_data_chunk_recv_callback";
        v70 = 2082;
        v71 = a6 + 205;
        v72 = 2048;
        *(_QWORD *)v73 = *(_QWORD *)v66;
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v62;
        _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s calling input_available on protocol %p for stream %d", buf, 0x26u);
      }
    }
    if (*(_QWORD *)v66)
    {
      v38 = *(_QWORD *)(*(_QWORD *)v66 + 24);
      if (v38)
      {
        v39 = *(void (**)(void))(v38 + 64);
        if (v39)
        {
          v39();
          return 0;
        }
      }
    }
    __nwlog_obj();
    v52 = "invalid";
    if (*(_QWORD *)v66 && *(_QWORD *)(*(_QWORD *)v66 + 16))
      v52 = *(const char **)(*(_QWORD *)v66 + 16);
    *(_DWORD *)buf = 136446466;
    v69 = "on_data_chunk_recv_callback";
    v70 = 2082;
    v71 = (uint64_t)v52;
    v53 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (__nwlog_fault(v53, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v54 = __nwlog_obj();
        v55 = type;
        if (!os_log_type_enabled(v54, type))
          goto LABEL_118;
        v56 = "invalid";
        if (*(_QWORD *)v66 && *(_QWORD *)(*(_QWORD *)v66 + 16))
          v56 = *(const char **)(*(_QWORD *)v66 + 16);
        *(_DWORD *)buf = 136446466;
        v69 = "on_data_chunk_recv_callback";
        v70 = 2082;
        v71 = (uint64_t)v56;
        v57 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_117;
      }
      if (!v65)
      {
        v54 = __nwlog_obj();
        v55 = type;
        if (!os_log_type_enabled(v54, type))
          goto LABEL_118;
        v63 = "invalid";
        if (*(_QWORD *)v66 && *(_QWORD *)(*(_QWORD *)v66 + 16))
          v63 = *(const char **)(*(_QWORD *)v66 + 16);
        *(_DWORD *)buf = 136446466;
        v69 = "on_data_chunk_recv_callback";
        v70 = 2082;
        v71 = (uint64_t)v63;
        v57 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_117;
      }
      v58 = (char *)__nw_create_backtrace_string();
      v54 = __nwlog_obj();
      v55 = type;
      v59 = os_log_type_enabled(v54, type);
      if (v58)
      {
        if (v59)
        {
          v60 = "invalid";
          if (*(_QWORD *)v66 && *(_QWORD *)(*(_QWORD *)v66 + 16))
            v60 = *(const char **)(*(_QWORD *)v66 + 16);
          *(_DWORD *)buf = 136446722;
          v69 = "on_data_chunk_recv_callback";
          v70 = 2082;
          v71 = (uint64_t)v60;
          v72 = 2082;
          *(_QWORD *)v73 = v58;
          _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v58);
        goto LABEL_118;
      }
      if (v59)
      {
        v64 = "invalid";
        if (*(_QWORD *)v66 && *(_QWORD *)(*(_QWORD *)v66 + 16))
          v64 = *(const char **)(*(_QWORD *)v66 + 16);
        *(_DWORD *)buf = 136446466;
        v69 = "on_data_chunk_recv_callback";
        v70 = 2082;
        v71 = (uint64_t)v64;
        v57 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_117:
        _os_log_impl(&dword_182FBE000, v54, v55, v57, buf, 0x16u);
      }
    }
LABEL_118:
    if (v53)
      free(v53);
    return 0;
  }
  if (!gLogDatapath)
    return 0;
  v31 = __nwlog_obj();
  result = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    v32 = *(_DWORD *)(v11 + 32);
    *(_DWORD *)buf = 136446978;
    v69 = "on_data_chunk_recv_callback";
    v70 = 2082;
    v71 = a6 + 205;
    v72 = 2048;
    *(_QWORD *)v73 = *(_QWORD *)v66;
    *(_WORD *)&v73[8] = 1024;
    *(_DWORD *)&v73[10] = v32;
    _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s suppressing input_available on protocol %p for stream %d that is not yet open", buf, 0x26u);
    return 0;
  }
  return result;
}

{
  uint64_t stream_from_id;
  uint64_t v11;
  uint64_t input_frame;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  int v21;
  const char *v22;
  int v23;
  int v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  int v28;
  int v29;
  const char *v30;
  char *v31;
  _BOOL4 v32;
  int v33;
  void *v34;
  char *v35;
  _BOOL4 v36;
  int v37;
  int v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  uint64_t result;
  int v44;
  int v45;
  int v46;
  int v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  int v51;
  int v52;
  const char *v53;
  uint64_t v54;
  void (*v55)(void);
  char *v56;
  _BOOL4 v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  NSObject *v74;
  int v75;
  char *backtrace_string;
  _BOOL4 v77;
  const char *v78;
  char *v79;
  NSObject *v80;
  os_log_type_t v81;
  const char *v82;
  const char *v83;
  char *v84;
  _BOOL4 v85;
  const char *v86;
  NSObject *v87;
  uint64_t v88;
  NSObject *v89;
  int v90;
  int v91;
  const char *v92;
  const char *v93;
  char v94;
  os_log_type_t v95[15];
  os_log_type_t type;
  uint8_t buf[4];
  const char *v98;
  __int16 v99;
  const char *v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  _BYTE v104[10];
  __int16 v105;
  _BYTE v106[14];
  __int16 v107;
  char *v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v98 = "on_data_chunk_recv_callback";
    v70 = (char *)_os_log_send_and_compose_impl();
    v95[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v70, v95, &type))
      goto LABEL_149;
    if (v95[0] == OS_LOG_TYPE_FAULT)
    {
      v71 = __nwlog_obj();
      v72 = v95[0];
      if (!os_log_type_enabled(v71, v95[0]))
        goto LABEL_149;
      *(_DWORD *)buf = 136446210;
      v98 = "on_data_chunk_recv_callback";
      v73 = "%{public}s nghttp2 user data is NULL, not http2";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v71 = __nwlog_obj();
      v72 = v95[0];
      v77 = os_log_type_enabled(v71, v95[0]);
      if (backtrace_string)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446466;
          v98 = "on_data_chunk_recv_callback";
          v99 = 2082;
          v100 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_149;
      }
      if (!v77)
      {
LABEL_149:
        if (v70)
          free(v70);
        return 4294966394;
      }
      *(_DWORD *)buf = 136446210;
      v98 = "on_data_chunk_recv_callback";
      v73 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }
    else
    {
      v71 = __nwlog_obj();
      v72 = v95[0];
      if (!os_log_type_enabled(v71, v95[0]))
        goto LABEL_149;
      *(_DWORD *)buf = 136446210;
      v98 = "on_data_chunk_recv_callback";
      v73 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v71, v72, v73, buf, 0xCu);
    goto LABEL_149;
  }
  if ((*(__int16 *)(a6 + 376) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v74 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v75 = *(_DWORD *)(a6 + 368);
      *(_DWORD *)buf = 136446978;
      v98 = "on_data_chunk_recv_callback";
      v99 = 2082;
      v100 = (const char *)(a6 + 378);
      v101 = 2080;
      v102 = " ";
      v103 = 1024;
      *(_DWORD *)v104 = v75;
      _os_log_impl(&dword_182FBE000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  *(_QWORD *)v95 = 0;
  stream_from_id = nw_http2_get_stream_from_id(a6, a3, v95);
  if (!stream_from_id)
  {
    if (*(__int16 *)(a6 + 376) < 0)
      return 4294966775;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v17 = *(_DWORD *)(a6 + 368);
    *(_DWORD *)buf = 136447234;
    v98 = "on_data_chunk_recv_callback";
    v99 = 2082;
    v100 = (const char *)(a6 + 378);
    v101 = 2080;
    v102 = " ";
    v103 = 1024;
    *(_DWORD *)v104 = v17;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = a3;
    v18 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault(v18, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = gconnectionLogObj;
        v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_89;
        v21 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(a6 + 378);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v21;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
        goto LABEL_88;
      }
      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = gconnectionLogObj;
        v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_89;
        v60 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(a6 + 378);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v60;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d, backtrace limit exceeded";
        goto LABEL_88;
      }
      v31 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v19 = gconnectionLogObj;
      v20 = type;
      v32 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v31)
      {
        if (v32)
        {
          v33 = *(_DWORD *)(a6 + 368);
          *(_DWORD *)buf = 136447490;
          v98 = "on_data_chunk_recv_callback";
          v99 = 2082;
          v100 = (const char *)(a6 + 378);
          v101 = 2080;
          v102 = " ";
          v103 = 1024;
          *(_DWORD *)v104 = v33;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = a3;
          v105 = 2082;
          *(_QWORD *)v106 = v31;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s %{public}s%s<i%u> failed to find stream %d, dumping backtrace:%{public}s", buf, 0x36u);
        }
        free(v31);
        goto LABEL_89;
      }
      if (v32)
      {
        v61 = *(_DWORD *)(a6 + 368);
        *(_DWORD *)buf = 136447234;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(a6 + 378);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v61;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = a3;
        v22 = "%{public}s %{public}s%s<i%u> failed to find stream %d, no backtrace";
LABEL_88:
        _os_log_impl(&dword_182FBE000, v19, v20, v22, buf, 0x2Cu);
      }
    }
LABEL_89:
    if (v18)
      free(v18);
    return 4294966775;
  }
  v11 = stream_from_id;
  input_frame = http2_create_input_frame(a6, stream_from_id, a5);
  if (!input_frame)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) != 0)
      return 4294966394;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v24 = *(_DWORD *)(v11 + 176);
    v23 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    v98 = "on_data_chunk_recv_callback";
    v99 = 2082;
    v100 = (const char *)(v11 + 191);
    v101 = 2080;
    v102 = " ";
    v103 = 1024;
    *(_DWORD *)v104 = v23;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v24;
    v105 = 2048;
    *(_QWORD *)v106 = a5;
    *(_WORD *)&v106[8] = 1024;
    *(_DWORD *)&v106[10] = v24;
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault(v25, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v26 = gconnectionLogObj;
        v27 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_103;
        v29 = *(_DWORD *)(v11 + 176);
        v28 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(v11 + 191);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v28;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v29;
        v105 = 2048;
        *(_QWORD *)v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v29;
        v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d";
        goto LABEL_102;
      }
      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v26 = gconnectionLogObj;
        v27 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_103;
        v63 = *(_DWORD *)(v11 + 176);
        v62 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(v11 + 191);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v62;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v63;
        v105 = 2048;
        *(_QWORD *)v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v63;
        v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, backtrace limit exceeded";
        goto LABEL_102;
      }
      v35 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v26 = gconnectionLogObj;
      v27 = type;
      v36 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v35)
      {
        if (v36)
        {
          v38 = *(_DWORD *)(v11 + 176);
          v37 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136448002;
          v98 = "on_data_chunk_recv_callback";
          v99 = 2082;
          v100 = (const char *)(v11 + 191);
          v101 = 2080;
          v102 = " ";
          v103 = 1024;
          *(_DWORD *)v104 = v37;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = v38;
          v105 = 2048;
          *(_QWORD *)v106 = a5;
          *(_WORD *)&v106[8] = 1024;
          *(_DWORD *)&v106[10] = v38;
          v107 = 2082;
          v108 = v35;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, dumping backtrace:%{public}s", buf, 0x46u);
        }
        free(v35);
        goto LABEL_103;
      }
      if (v36)
      {
        v67 = *(_DWORD *)(v11 + 176);
        v66 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(v11 + 191);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v66;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v67;
        v105 = 2048;
        *(_QWORD *)v106 = a5;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v67;
        v30 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse input frame of length %zu for stream %d, no backtrace";
LABEL_102:
        _os_log_impl(&dword_182FBE000, v26, v27, v30, buf, 0x3Cu);
      }
    }
LABEL_103:
    if (v25)
      free(v25);
    return 4294966394;
  }
  v13 = input_frame;
  if (!*(_QWORD *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(_QWORD *)(input_frame + 88)))
  {
    v16 = 0;
    v34 = 0;
  }
  else
  {
    v15 = *(_DWORD *)(v13 + 52);
    v14 = *(unsigned int *)(v13 + 56);
    if (v15)
      v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    else
      v16 = 0;
    v34 = (void *)(*(_QWORD *)(v13 + 112) + v14);
  }
  if (v16 != a5)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) != 0)
    {
LABEL_110:
      nw_frame_finalize(v13);
      return 4294966394;
    }
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v47 = *(_DWORD *)(v11 + 176);
    v46 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    v98 = "on_data_chunk_recv_callback";
    v99 = 2082;
    v100 = (const char *)(v11 + 191);
    v101 = 2080;
    v102 = " ";
    v103 = 1024;
    *(_DWORD *)v104 = v46;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v47;
    v105 = 1024;
    *(_DWORD *)v106 = v16;
    *(_WORD *)&v106[4] = 2048;
    *(_QWORD *)&v106[6] = a5;
    v48 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault(v48, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v49 = gconnectionLogObj;
        v50 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_108;
        v52 = *(_DWORD *)(v11 + 176);
        v51 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(v11 + 191);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v51;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v52;
        v105 = 1024;
        *(_DWORD *)v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(_QWORD *)&v106[6] = a5;
        v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame";
        goto LABEL_107;
      }
      if (!v94)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v49 = gconnectionLogObj;
        v50 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          goto LABEL_108;
        v65 = *(_DWORD *)(v11 + 176);
        v64 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(v11 + 191);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v64;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v65;
        v105 = 1024;
        *(_DWORD *)v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(_QWORD *)&v106[6] = a5;
        v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame, backtrace limit exceeded";
        goto LABEL_107;
      }
      v56 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v49 = gconnectionLogObj;
      v50 = type;
      v57 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v56)
      {
        if (v57)
        {
          v59 = *(_DWORD *)(v11 + 176);
          v58 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)buf = 136448002;
          v98 = "on_data_chunk_recv_callback";
          v99 = 2082;
          v100 = (const char *)(v11 + 191);
          v101 = 2080;
          v102 = " ";
          v103 = 1024;
          *(_DWORD *)v104 = v58;
          *(_WORD *)&v104[4] = 1024;
          *(_DWORD *)&v104[6] = v59;
          v105 = 1024;
          *(_DWORD *)v106 = v16;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2082;
          v108 = v56;
          _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_create_input_frame, dumping backtrace:%{public}s", buf, 0x46u);
        }
        free(v56);
        goto LABEL_108;
      }
      if (v57)
      {
        v69 = *(_DWORD *)(v11 + 176);
        v68 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(v11 + 191);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v68;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v69;
        v105 = 1024;
        *(_DWORD *)v106 = v16;
        *(_WORD *)&v106[4] = 2048;
        *(_QWORD *)&v106[6] = a5;
        v53 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %zu) from http2_cr"
              "eate_input_frame, no backtrace";
LABEL_107:
        _os_log_impl(&dword_182FBE000, v49, v50, v53, buf, 0x3Cu);
      }
    }
LABEL_108:
    if (v48)
      free(v48);
    goto LABEL_110;
  }
  memcpy(v34, a4, a5);
  *(_QWORD *)(v13 + 32) = 0;
  v39 = *(uint64_t **)(v11 + 8);
  *(_QWORD *)(v13 + 40) = v39;
  *v39 = v13;
  *(_QWORD *)(v11 + 8) = v13 + 32;
  v40 = *(_QWORD *)(v11 + 80);
  *(_QWORD *)(v11 + 80) = v40 + a5;
  if (__CFADD__(v40, a5))
  {
    if (gLogDatapath)
    {
      v87 = __nwlog_obj();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
      {
        v88 = *(_QWORD *)(v11 + 80);
        *(_DWORD *)buf = 136446978;
        v98 = "increment_inbound_body_size";
        v99 = 2082;
        v100 = "inbound_body_size";
        v101 = 2048;
        v102 = (const char *)a5;
        v103 = 2048;
        *(_QWORD *)v104 = v88;
        _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
      }
    }
    *(_QWORD *)(v11 + 80) = -1;
  }
  v41 = (*(unsigned __int8 *)(v11 + 190) >> 3) & 1;
  if (!gLogDatapath)
    LOBYTE(v41) = 1;
  if ((*(_WORD *)(v11 + 188) & 1) != 0)
  {
    if ((v41 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v89 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v91 = *(_DWORD *)(v11 + 176);
        v90 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)buf = 136447746;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = (const char *)(v11 + 191);
        v101 = 2080;
        v102 = " ";
        v103 = 1024;
        *(_DWORD *)v104 = v90;
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)&v104[6] = v91;
        v105 = 2048;
        *(_QWORD *)v106 = *(_QWORD *)v95;
        *(_WORD *)&v106[8] = 1024;
        *(_DWORD *)&v106[10] = v91;
        _os_log_impl(&dword_182FBE000, v89, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> calling input_available on protocol %p for stream %d", buf, 0x3Cu);
      }
    }
    if (*(_QWORD *)v95)
    {
      v54 = *(_QWORD *)(*(_QWORD *)v95 + 24);
      if (v54)
      {
        v55 = *(void (**)(void))(v54 + 64);
        if (v55)
        {
          v55();
          return 0;
        }
      }
    }
    __nwlog_obj();
    v78 = "invalid";
    if (*(_QWORD *)v95 && *(_QWORD *)(*(_QWORD *)v95 + 16))
      v78 = *(const char **)(*(_QWORD *)v95 + 16);
    *(_DWORD *)buf = 136446466;
    v98 = "on_data_chunk_recv_callback";
    v99 = 2082;
    v100 = v78;
    v79 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault(v79, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v80 = __nwlog_obj();
        v81 = type;
        if (!os_log_type_enabled(v80, type))
          goto LABEL_168;
        v82 = "invalid";
        if (*(_QWORD *)v95 && *(_QWORD *)(*(_QWORD *)v95 + 16))
          v82 = *(const char **)(*(_QWORD *)v95 + 16);
        *(_DWORD *)buf = 136446466;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = v82;
        v83 = "%{public}s protocol %{public}s has invalid input_available callback";
        goto LABEL_167;
      }
      if (!v94)
      {
        v80 = __nwlog_obj();
        v81 = type;
        if (!os_log_type_enabled(v80, type))
          goto LABEL_168;
        v92 = "invalid";
        if (*(_QWORD *)v95 && *(_QWORD *)(*(_QWORD *)v95 + 16))
          v92 = *(const char **)(*(_QWORD *)v95 + 16);
        *(_DWORD *)buf = 136446466;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = v92;
        v83 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
        goto LABEL_167;
      }
      v84 = (char *)__nw_create_backtrace_string();
      v80 = __nwlog_obj();
      v81 = type;
      v85 = os_log_type_enabled(v80, type);
      if (v84)
      {
        if (v85)
        {
          v86 = "invalid";
          if (*(_QWORD *)v95 && *(_QWORD *)(*(_QWORD *)v95 + 16))
            v86 = *(const char **)(*(_QWORD *)v95 + 16);
          *(_DWORD *)buf = 136446722;
          v98 = "on_data_chunk_recv_callback";
          v99 = 2082;
          v100 = v86;
          v101 = 2082;
          v102 = v84;
          _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v84);
        goto LABEL_168;
      }
      if (v85)
      {
        v93 = "invalid";
        if (*(_QWORD *)v95 && *(_QWORD *)(*(_QWORD *)v95 + 16))
          v93 = *(const char **)(*(_QWORD *)v95 + 16);
        *(_DWORD *)buf = 136446466;
        v98 = "on_data_chunk_recv_callback";
        v99 = 2082;
        v100 = v93;
        v83 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_167:
        _os_log_impl(&dword_182FBE000, v80, v81, v83, buf, 0x16u);
      }
    }
LABEL_168:
    if (v79)
      free(v79);
    return 0;
  }
  if ((v41 & 1) != 0)
    return 0;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v42 = gconnectionLogObj;
  result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    v45 = *(_DWORD *)(v11 + 176);
    v44 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)buf = 136447746;
    v98 = "on_data_chunk_recv_callback";
    v99 = 2082;
    v100 = (const char *)(v11 + 191);
    v101 = 2080;
    v102 = " ";
    v103 = 1024;
    *(_DWORD *)v104 = v44;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)&v104[6] = v45;
    v105 = 2048;
    *(_QWORD *)v106 = *(_QWORD *)v95;
    *(_WORD *)&v106[8] = 1024;
    *(_DWORD *)&v106[10] = v45;
    _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> suppressing input_available on protocol %p for stream %d that is not yet open", buf, 0x3Cu);
    return 0;
  }
  return result;
}

uint64_t nw_http2_transport_get_stream_from_id(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t stream_node_from_id;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  uint64_t v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a2 <= 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446722;
    v28 = "nw_http2_transport_get_stream_from_id";
    v29 = 2082;
    v30 = a1 + 205;
    v31 = 1024;
    LODWORD(v32) = a2;
    v11 = "%{public}s %{public}s requested stream id (%d) is not valid, returning NULL stream";
    v12 = v10;
    v13 = OS_LOG_TYPE_ERROR;
LABEL_9:
    _os_log_impl(&dword_182FBE000, v12, v13, v11, buf, 0x1Cu);
    return 0;
  }
  stream_node_from_id = nw_http2_transport_get_stream_node_from_id(a1, a2);
  if (!stream_node_from_id)
  {
    if (!gLogDatapath)
      return 0;
    v14 = __nwlog_obj();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      return 0;
    *(_DWORD *)buf = 136446722;
    v28 = "nw_http2_transport_get_stream_from_id";
    v29 = 2082;
    v30 = a1 + 205;
    v31 = 1024;
    LODWORD(v32) = a2;
    v11 = "%{public}s %{public}s stream %d not found in id based hash table";
    v12 = v14;
    v13 = OS_LOG_TYPE_DEBUG;
    goto LABEL_9;
  }
  v7 = stream_node_from_id;
  result = *(_QWORD *)(stream_node_from_id + 16);
  if (!result)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = a1 + 205;
    *(_DWORD *)buf = 136446722;
    v28 = "nw_http2_transport_get_stream_from_id";
    v29 = 2082;
    v30 = a1 + 205;
    v31 = 2048;
    v32 = v7;
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v16, &type, &v25))
      goto LABEL_31;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446722;
      v28 = "nw_http2_transport_get_stream_from_id";
      v29 = 2082;
      v30 = v15;
      v31 = 2048;
      v32 = v7;
      v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra";
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446978;
          v28 = "nw_http2_transport_get_stream_from_id";
          v29 = 2082;
          v30 = v15;
          v31 = 2048;
          v32 = v7;
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s %{public}s hash node %p didn't have a stream as extra, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(backtrace_string);
        goto LABEL_31;
      }
      if (!v21)
      {
LABEL_31:
        if (v16)
          free(v16);
        return 0;
      }
      *(_DWORD *)buf = 136446722;
      v28 = "nw_http2_transport_get_stream_from_id";
      v29 = 2082;
      v30 = v15;
      v31 = 2048;
      v32 = v7;
      v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446722;
      v28 = "nw_http2_transport_get_stream_from_id";
      v29 = 2082;
      v30 = v15;
      v31 = 2048;
      v32 = v7;
      v19 = "%{public}s %{public}s hash node %p didn't have a stream as extra, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0x20u);
    goto LABEL_31;
  }
  if (a3)
  {
    v9 = *(_QWORD *)(v7 + 32);
    if (v9)
    {
      *a3 = v9;
    }
    else if (gLogDatapath)
    {
      v22 = result;
      v23 = __nwlog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        v24 = *(_DWORD *)(v22 + 32);
        *(_DWORD *)buf = 136446722;
        v28 = "nw_http2_transport_get_stream_from_id";
        v29 = 2082;
        v30 = a1 + 205;
        v31 = 1024;
        LODWORD(v32) = v24;
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s no input handler attached to stream %d, ignoring", buf, 0x1Cu);
      }
      return v22;
    }
  }
  return result;
}

BOOL nw_http2_transport_get_stream_node_from_id(uint64_t a1, int a2)
{
  uint64_t v3;
  _BOOL8 result;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  os_log_type_t v9;
  uint64_t v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  int v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v19 = a2;
  v3 = *(_QWORD *)(a1 + 120);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http2_transport_get_stream_node_from_id";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v11, &type, &v17))
      goto LABEL_25;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http2_transport_get_stream_node_from_id";
      v14 = "%{public}s called with null http2_transport->http2_transport_streams_id";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_http2_transport_get_stream_node_from_id";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null http2_transport->http2_transport_streams_id, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_25;
      }
      if (!v16)
      {
LABEL_25:
        if (v11)
          free(v11);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http2_transport_get_stream_node_from_id";
      v14 = "%{public}s called with null http2_transport->http2_transport_streams_id, no backtrace";
    }
    else
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http2_transport_get_stream_node_from_id";
      v14 = "%{public}s called with null http2_transport->http2_transport_streams_id, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
    goto LABEL_25;
  }
  if (a2 <= 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v21 = "nw_http2_transport_get_stream_node_from_id";
      v22 = 2082;
      v23 = (char *)(a1 + 205);
      v24 = 1024;
      v25 = a2;
      v7 = "%{public}s %{public}s requested stream id (%d) is not valid, returning NULL hash node";
      v8 = v10;
      v9 = OS_LOG_TYPE_ERROR;
      goto LABEL_8;
    }
  }
  else
  {
    result = nw_hash_table_get_node(v3, (uint64_t)&v19, 4);
    if (result)
      return result;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v21 = "nw_http2_transport_get_stream_node_from_id";
      v22 = 2082;
      v23 = (char *)(a1 + 205);
      v24 = 1024;
      v25 = v19;
      v7 = "%{public}s %{public}s requested stream id (%d) not found, returning NULL";
      v8 = v6;
      v9 = OS_LOG_TYPE_DEBUG;
LABEL_8:
      _os_log_impl(&dword_182FBE000, v8, v9, v7, buf, 0x1Cu);
    }
  }
  return 0;
}

void nw_protocol_establishment_report_set_l4s_enabled(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 40) = *((_BYTE *)v3 + 40) & 0xFE | a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_establishment_report_set_l4s_enabled";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_establishment_report_set_l4s_enabled";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_establishment_report_set_l4s_enabled";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_establishment_report_set_l4s_enabled";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_establishment_report_set_l4s_enabled";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

BOOL nw_protocol_instance_get_sensitive_redacted(uint64_t a1)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  char *backtrace_string;
  os_log_type_t v7;
  _BOOL4 v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
    return nw_parameters_get_sensitive_redacted(*(void **)(a1 + 48));
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_protocol_instance_get_sensitive_redacted";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_protocol_instance_get_sensitive_redacted";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_protocol_instance_get_sensitive_redacted";
        _os_log_impl(&dword_182FBE000, v4, v9, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v3)
    free(v3);
  return 1;
}

BOOL nw_protocol_instance_get_logging_disabled(uint64_t a1)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  char *backtrace_string;
  os_log_type_t v7;
  _BOOL4 v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
    return nw_parameters_get_logging_disabled(*(_QWORD *)(a1 + 48));
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_protocol_instance_get_logging_disabled";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_protocol_instance_get_logging_disabled";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_protocol_instance_get_logging_disabled";
        _os_log_impl(&dword_182FBE000, v4, v9, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v3)
    free(v3);
  return 1;
}

os_unfair_lock_s *nw_path_evaluator_copy_path(os_unfair_lock_s *result)
{
  os_unfair_lock_s *v1;
  id *v2;
  id v3;

  if (result)
  {
    v1 = result + 24;
    v2 = result;
    os_unfair_lock_lock(v1);
    v3 = v2[6];
    os_unfair_lock_unlock(v1);

    return (os_unfair_lock_s *)v3;
  }
  return result;
}

NWConcrete_nw_path_evaluator *nw_path_create_evaluator_for_listener(void *a1, int *a2)
{
  id v4;
  NWConcrete_nw_path_evaluator *v5;
  NWConcrete_nw_path_evaluator *v6;
  id *v7;
  id v8;
  id *v9;
  id v10;
  NSObject *v11;
  NWConcrete_nw_path_evaluator *v12;
  id v13;
  void *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  void *v22;
  os_log_type_t v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  if (!v4)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_path_create_evaluator_for_listener";
    v14 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault((const char *)v14, &type, &v27))
    {
LABEL_30:
      if (!v14)
      {
LABEL_32:
        v12 = 0;
        goto LABEL_33;
      }
LABEL_31:
      free(v14);
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null parameters", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (!v27)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_182FBE000, v15, v26, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    v24 = type;
    v25 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "nw_path_create_evaluator_for_listener";
      v31 = 2082;
      v32 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_22;
  }
  v5 = objc_alloc_init(NWConcrete_nw_path_evaluator);
  v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v30 = "nw_path_create_evaluator_for_listener";
    v14 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault((const char *)v14, &type, &v27))
      goto LABEL_30;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = (id)gLogObj;
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed", buf, 0xCu);
      }
LABEL_29:

      goto LABEL_30;
    }
    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = (id)gLogObj;
      v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    v18 = type;
    v19 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_path_create_evaluator_for_listener";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_29;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "nw_path_create_evaluator_for_listener";
      v31 = 2082;
      v32 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_evaluator) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_22:

    free(backtrace_string);
    if (!v14)
      goto LABEL_32;
    goto LABEL_31;
  }
  objc_storeStrong((id *)v5 + 1, a1);
  *((_BYTE *)v6 + 107) |= 2u;
  v7 = (id *)v4;
  v8 = v7[19];

  if (v8)
  {
    v9 = (id *)v8;
    v10 = v9[3];

    if (v10 && nw_protocol_options_is_custom_ip(v10))
      *((_BYTE *)v6 + 106) = nw_custom_ip_options_get_protocol(v10);

  }
  if ((nw_path_evaluator_evaluate(v6, a2) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_path_create_evaluator_for_listener";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s nw_path_evaluator_evaluate failed", buf, 0xCu);
    }

    v6 = 0;
  }
  v12 = v6;

LABEL_33:
  return v12;
}

void sub_1831BD834(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void nw_connection_register_context(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  _QWORD v20[4];
  id v21;
  id v22;
  char v23;
  os_log_type_t v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_connection_register_context";
    v7 = (char *)_os_log_send_and_compose_impl();

    v24 = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &v24, &v23))
      goto LABEL_38;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_register_context";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v24;
      v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_connection_register_context";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_register_context";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_register_context";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __nw_connection_register_context_block_invoke;
    v20[3] = &unk_1E14ACE68;
    v21 = v3;
    v22 = v5;
    nw_connection_async_if_needed(v21, v20);

    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_connection_register_context";
  v7 = (char *)_os_log_send_and_compose_impl();

  v24 = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v7, &v24, &v23))
    goto LABEL_38;
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_connection_register_context";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null content_context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_connection_register_context";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null content_context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = v24;
  v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_connection_register_context";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null content_context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_connection_register_context";
    v27 = 2082;
    v28 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null content_context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

void sub_1831BDD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void __nw_connection_register_context_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  const char *v6;
  NSObject *v7;
  uint32_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    if ((nw_endpoint_handler_register_context(*(void **)(v2 + 144), *(void **)(a1 + 40)) & 1) == 0)
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
      if (v9)
      {
        if (!nw_path_parameters_get_logging_disabled(*(_QWORD *)(v9 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v4 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
            goto LABEL_16;
          v10 = *(_QWORD *)(a1 + 40);
          v11 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
          v12 = 136446722;
          v13 = "nw_connection_register_context_block_invoke";
          v14 = 1024;
          v15 = v11;
          v16 = 2112;
          v17 = v10;
          v6 = "%{public}s [C%u] Failed to register context %@";
          v7 = v4;
          v8 = 28;
          goto LABEL_15;
        }
      }
    }
  }
  else
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        goto LABEL_16;
      v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
      v12 = 136446466;
      v13 = "nw_connection_register_context_block_invoke";
      v14 = 1024;
      v15 = v5;
      v6 = "%{public}s [C%u] Cannot register a context on a connection that is not ready";
      v7 = v4;
      v8 = 18;
LABEL_15:
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v12, v8);
LABEL_16:

    }
  }
}

uint64_t nw_endpoint_handler_register_context(void *a1, void *a2)
{
  id v3;
  NSObject *v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v7;
  NWConcrete_nw_endpoint_mode_handler *v8;
  uint64_t v9;
  uint64_t node;
  uint64_t v11;
  NWConcrete_nw_endpoint_handler *v12;
  char v13;
  NSObject *v14;
  NWConcrete_nw_endpoint_handler *v15;
  NWConcrete_nw_endpoint_handler *v16;
  char v17;
  const char *v18;
  nw_endpoint_t v19;
  unsigned int *v20;
  unsigned int *v21;
  uint64_t v22;
  const char *v23;
  id v24;
  const char *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  os_log_type_t v33;
  _BOOL4 v34;
  const char *v35;
  NWConcrete_nw_endpoint_handler *v36;
  char v37;
  NSObject *v38;
  NWConcrete_nw_endpoint_handler *v39;
  NWConcrete_nw_endpoint_handler *v40;
  char v41;
  const char *v42;
  nw_endpoint_t v43;
  const char *logging_description;
  unsigned int *v45;
  unsigned int *v46;
  uint64_t v47;
  const char *v48;
  os_log_type_t v49;
  const char *v50;
  NWConcrete_nw_endpoint_handler *v51;
  char v52;
  NWConcrete_nw_endpoint_handler *v53;
  NWConcrete_nw_endpoint_handler *v54;
  char v55;
  const char *v56;
  nw_endpoint_t v57;
  const char *v58;
  unsigned int *v59;
  unsigned int *v60;
  uint64_t v61;
  const char *v62;
  const char *v63;
  void **v64;
  void **v65;
  int v66;
  const char *v67;
  void **v68;
  void **v69;
  const char *v70;
  void **v71;
  void **v72;
  int v73;
  const char *v74;
  void **v75;
  id v76;
  void **v77;
  id v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t (*v81)(void);
  NSObject *v82;
  void **v83;
  id v84;
  void *v86;
  os_log_type_t v87;
  void *v88;
  os_log_type_t v89;
  char *backtrace_string;
  os_log_type_t v91;
  _BOOL4 v92;
  os_log_type_t v93;
  _BOOL4 v94;
  os_log_type_t v95;
  os_log_type_t v96;
  const char *v97;
  char *v98;
  const char *v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  const char *v101;
  char *id_str;
  char *v103;
  const char *v104;
  _QWORD v105[4];
  NWConcrete_nw_endpoint_mode_handler *v106;
  _BYTE *v107;
  char v108;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v111)(uint64_t, uint64_t);
  _BYTE v112[20];
  __int16 v113;
  const char *v114;
  __int16 v115;
  id v116;
  __int16 v117;
  uint64_t v118;
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (!v4)
  {
    __nwlog_obj();
    v86 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v108 = 0;
    if (!__nwlog_fault(v26, &type, &v108))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v87 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_182FBE000, v27, v87, "%{public}s called with null content_context", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (!v108)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v95 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_182FBE000, v27, v95, "%{public}s called with null content_context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    v91 = type;
    v92 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_182FBE000, v27, v91, "%{public}s called with null content_context, no backtrace", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (v92)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v27, v91, "%{public}s called with null content_context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_132;
  }
  if (!v3)
  {
    __nwlog_obj();
    v88 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v108 = 0;
    if (!__nwlog_fault(v26, &type, &v108))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v89 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_182FBE000, v27, v89, "%{public}s called with null handler", buf, 0xCu);
      }
LABEL_75:

      goto LABEL_76;
    }
    if (!v108)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v96 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_182FBE000, v27, v96, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    v93 = type;
    v94 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v94)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        _os_log_impl(&dword_182FBE000, v27, v93, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (v94)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v27, v93, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_132:

    free(backtrace_string);
    if (!v26)
      goto LABEL_78;
    goto LABEL_77;
  }
  v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    v7 = nw_endpoint_handler_copy_flow(v5);
    v8 = v7;
    if ((*((_BYTE *)v7 + 35) & 2) != 0)
    {
      v30 = *((_QWORD *)v7 + 117);
      if (v30)
      {
        v31 = nw_endpoint_handler_register_context(v30, v4);
LABEL_111:

        goto LABEL_112;
      }
      v36 = v5;
      v37 = *((_BYTE *)v36 + 268);

      if ((v37 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v38 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          v39 = v36;

          v40 = v39;
          v41 = *((_BYTE *)v36 + 268);

          if ((v41 & 1) != 0)
            v42 = "dry-run ";
          else
            v42 = "";
          v43 = nw_endpoint_handler_copy_endpoint(v40);
          logging_description = nw_endpoint_get_logging_description(v43);
          id_str = v39->id_str;
          v45 = v40;
          v46 = v45;
          v47 = v45[30];
          if (v47 > 5)
            v48 = "unknown-state";
          else
            v48 = off_1E149FC48[v47];
          v99 = v48;

          v64 = v46;
          v65 = v64;
          v66 = v5->mode;
          v67 = "path";
          switch(v66)
          {
            case 0:
              break;
            case 1:
              v67 = "resolver";
              break;
            case 2:
              v67 = nw_endpoint_flow_mode_string(v64[31]);
              break;
            case 3:
              v67 = "proxy";
              break;
            case 4:
              v67 = "fallback";
              break;
            case 5:
              v67 = "transform";
              break;
            default:
              v67 = "unknown-mode";
              break;
          }

          v75 = v65;
          os_unfair_lock_lock((os_unfair_lock_t)v75 + 28);
          v76 = v75[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v75 + 28);

          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = id_str;
          *(_WORD *)&buf[22] = 2082;
          v111 = (uint64_t (*)(uint64_t, uint64_t))v42;
          *(_WORD *)v112 = 2082;
          *(_QWORD *)&v112[2] = logging_description;
          *(_WORD *)&v112[10] = 2082;
          *(_QWORD *)&v112[12] = v99;
          v113 = 2082;
          v114 = v67;
          v115 = 2114;
          v116 = v76;
          _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot register, no connected handler", buf, 0x48u);

        }
        goto LABEL_109;
      }
    }
    else if (*((_QWORD *)v7 + 96))
    {
      v9 = *((_QWORD *)v7 + 108);
      if (v9)
      {
        node = nw_hash_table_get_node(v9, (uint64_t)v4, 0);
        if (node)
        {
          v11 = *(_QWORD *)(node + 16);
          if (v11)
            goto LABEL_96;
        }
        v11 = nw_endpoint_handler_register_context_internal(v5, v8, v4);
        v12 = v5;
        v13 = *((_BYTE *)v12 + 268);

        if ((v13 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v14 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            v15 = v12;

            v16 = v15;
            v17 = *((_BYTE *)v12 + 268);

            if ((v17 & 1) != 0)
              v18 = "dry-run ";
            else
              v18 = "";
            v19 = nw_endpoint_handler_copy_endpoint(v16);
            v104 = nw_endpoint_get_logging_description(v19);
            v98 = v15->id_str;
            v20 = v16;
            v21 = v20;
            v22 = v20[30];
            if (v22 > 5)
              v23 = "unknown-state";
            else
              v23 = off_1E149FC48[v22];
            v97 = v23;

            v68 = v21;
            v69 = v68;
            v100 = (uint64_t (*)(uint64_t, uint64_t))v18;
            v70 = "path";
            switch(v5->mode)
            {
              case 0:
                break;
              case 1:
                v70 = "resolver";
                break;
              case 2:
                v70 = nw_endpoint_flow_mode_string(v68[31]);
                break;
              case 3:
                v70 = "proxy";
                break;
              case 4:
                v70 = "fallback";
                break;
              case 5:
                v70 = "transform";
                break;
              default:
                v70 = "unknown-mode";
                break;
            }

            v77 = v69;
            os_unfair_lock_lock((os_unfair_lock_t)v77 + 28);
            v78 = v77[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v77 + 28);

            *(_DWORD *)buf = 136448002;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v98;
            *(_WORD *)&buf[22] = 2082;
            v111 = v100;
            *(_WORD *)v112 = 2082;
            *(_QWORD *)&v112[2] = v104;
            *(_WORD *)&v112[10] = 2082;
            *(_QWORD *)&v112[12] = v97;
            v113 = 2082;
            v114 = v70;
            v115 = 2114;
            v116 = v78;
            v117 = 2048;
            v118 = v11;
            _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Registered protocol %p", buf, 0x52u);

          }
        }
        if (v11)
        {
LABEL_96:
          v79 = *(_QWORD *)(v11 + 32);
          if (!v79 || (v80 = *(_QWORD *)(v79 + 24)) == 0 || (v81 = *(uint64_t (**)(void))(v80 + 224)) == 0)
          {
            v31 = 1;
            goto LABEL_111;
          }
          v38 = v81();
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = buf;
          *(_QWORD *)&buf[16] = 0x3032000000;
          v111 = __Block_byref_object_copy__16456;
          *(_QWORD *)v112 = __Block_byref_object_dispose__16457;
          *(_QWORD *)&v112[8] = 0;
          v105[0] = MEMORY[0x1E0C809B0];
          v105[1] = 3221225472;
          v105[2] = __nw_endpoint_handler_register_context_block_invoke;
          v105[3] = &unk_1E14AB5F0;
          v106 = v8;
          v107 = buf;
          nw_array_apply((unsigned __int8 *)v38, (uint64_t)v105);
          v82 = *(NSObject **)(*(_QWORD *)&buf[8] + 40);
          if (v82)
            nw_content_context_set_metadata_for_protocol(v4, v82);

          _Block_object_dispose(buf, 8);
          v31 = 1;
          goto LABEL_110;
        }
        goto LABEL_102;
      }
      v51 = v5;
      v52 = *((_BYTE *)v51 + 268);

      if ((v52 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v38 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          v53 = v51;

          v54 = v53;
          v55 = *((_BYTE *)v51 + 268);

          if ((v55 & 1) != 0)
            v56 = "dry-run ";
          else
            v56 = "";
          v57 = nw_endpoint_handler_copy_endpoint(v54);
          v58 = nw_endpoint_get_logging_description(v57);
          v103 = v53->id_str;
          v59 = v54;
          v60 = v59;
          v61 = v59[30];
          if (v61 > 5)
            v62 = "unknown-state";
          else
            v62 = off_1E149FC48[v61];
          v101 = v62;

          v71 = v60;
          v72 = v71;
          v73 = v5->mode;
          v74 = "path";
          switch(v73)
          {
            case 0:
              break;
            case 1:
              v74 = "resolver";
              break;
            case 2:
              v74 = nw_endpoint_flow_mode_string(v71[31]);
              break;
            case 3:
              v74 = "proxy";
              break;
            case 4:
              v74 = "fallback";
              break;
            case 5:
              v74 = "transform";
              break;
            default:
              v74 = "unknown-mode";
              break;
          }

          v83 = v72;
          os_unfair_lock_lock((os_unfair_lock_t)v83 + 28);
          v84 = v83[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v83 + 28);

          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v103;
          *(_WORD *)&buf[22] = 2082;
          v111 = (uint64_t (*)(uint64_t, uint64_t))v56;
          *(_WORD *)v112 = 2082;
          *(_QWORD *)&v112[2] = v58;
          *(_WORD *)&v112[10] = 2082;
          *(_QWORD *)&v112[12] = v101;
          v113 = 2082;
          v114 = v74;
          v115 = 2114;
          v116 = v84;
          _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot register after flow table is released", buf, 0x48u);

        }
LABEL_109:
        v31 = 0;
LABEL_110:

        goto LABEL_111;
      }
    }
LABEL_102:
    v31 = 0;
    goto LABEL_111;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v24 = (id)gLogObj;
  if (mode > 5)
    v25 = "unknown-mode";
  else
    v25 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = v25;
  *(_WORD *)&buf[22] = 2082;
  v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
  v26 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v108 = 0;
  if (__nwlog_fault(v26, &type, &v108))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        if (mode > 5)
          v29 = "unknown-mode";
        else
          v29 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v29;
        *(_WORD *)&buf[22] = 2082;
        v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
        _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if (v108)
    {
      v32 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      v33 = type;
      v34 = os_log_type_enabled(v27, type);
      if (v32)
      {
        if (v34)
        {
          if (mode > 5)
            v35 = "unknown-mode";
          else
            v35 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v35;
          *(_WORD *)&buf[22] = 2082;
          v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
          *(_WORD *)v112 = 2082;
          *(_QWORD *)&v112[2] = v32;
          _os_log_impl(&dword_182FBE000, v27, v33, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v32);
        if (!v26)
          goto LABEL_78;
        goto LABEL_77;
      }
      if (v34)
      {
        if (mode > 5)
          v63 = "unknown-mode";
        else
          v63 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v63;
        *(_WORD *)&buf[22] = 2082;
        v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
        _os_log_impl(&dword_182FBE000, v27, v33, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      v49 = type;
      if (os_log_type_enabled(v27, type))
      {
        if (mode > 5)
          v50 = "unknown-mode";
        else
          v50 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_endpoint_handler_register_context";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v50;
        *(_WORD *)&buf[22] = 2082;
        v111 = (uint64_t (*)(uint64_t, uint64_t))"flow";
        _os_log_impl(&dword_182FBE000, v27, v49, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
    goto LABEL_75;
  }
LABEL_76:
  if (v26)
LABEL_77:
    free(v26);
LABEL_78:
  v31 = 0;
LABEL_112:

  return v31;
}

void sub_1831BEF34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void __nw_connection_remove_data_transfer_report_block_invoke(uint64_t a1)
{
  _BOOL8 v2;
  uint64_t v3;
  void *v4;

  v2 = nw_array_duplicate_array_without_object(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 424), *(void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 424);
  *(_QWORD *)(v3 + 424) = v2;

}

BOOL nw_array_duplicate_array_without_object(uint64_t a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  void **v6;
  void **v7;

  if (!a1 || *(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 24))
    return nw_array_create();
  v4 = nw_array_create();
  v5 = v4;
  if (a2)
  {
    std::vector<nw_object_wrapper_t>::reserve(v4 + 16, ((uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3) - 1);
    v7 = *(void ***)(a1 + 16);
    v6 = *(void ***)(a1 + 24);
    while (v7 != v6)
    {
      if (*v7 != a2)
        nw_array_append(v5, *v7);
      ++v7;
    }
  }
  else if (v4 == a1)
  {
    return a1;
  }
  else
  {
    std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v4 + 16, *(void ***)(a1 + 16), *(void ***)(a1 + 24), (uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 3);
  }
  return v5;
}

void std::vector<nw_object_wrapper_t>::reserve(uint64_t a1, unint64_t a2)
{
  char *v2;
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  char *v20;
  char *v21;
  void *v22;
  void *v23;

  v2 = *(char **)a1;
  if (a2 > (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3)
  {
    if (a2 >> 61)
      abort();
    v4 = *(char **)(a1 + 8);
    v5 = 8 * a2;
    v6 = (char *)operator new(8 * a2);
    v7 = &v6[v5];
    v8 = v4 - v2;
    v9 = (unint64_t)&v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
    if (v4 == v2)
    {
      *(_QWORD *)a1 = v9;
      *(_QWORD *)(a1 + 8) = v9;
      *(_QWORD *)(a1 + 16) = v7;
LABEL_21:
      if (v2)
        operator delete(v2);
      return;
    }
    v10 = v8 - 8;
    if ((unint64_t)(v8 - 8) > 0x77)
    {
      v12 = &v6[(v8 & 0xFFFFFFFFFFFFFFF8) - (v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v4
         || (unint64_t)&v4[-(v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v9;
      v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
      if (v12)
      {
        v13 = v8 >> 3;
        v14 = (v10 >> 3) + 1;
        v15 = &v6[8 * v13 - 16];
        v16 = v4 - 32;
        v17 = v14 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v18 = *((_OWORD *)v16 + 1);
          *((_OWORD *)v15 - 1) = *(_OWORD *)v16;
          *(_OWORD *)v15 = v18;
          *(_OWORD *)v16 = 0uLL;
          *((_OWORD *)v16 + 1) = 0uLL;
          v16 -= 32;
          v15 -= 32;
          v17 -= 4;
        }
        while (v17);
        v11 = (char *)(v9 - 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL));
        v4 -= 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
        if (v14 == (v14 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_16:
          v2 = *(char **)a1;
          v20 = *(char **)(a1 + 8);
          *(_QWORD *)a1 = v11;
          *(_QWORD *)(a1 + 8) = v9;
          *(_QWORD *)(a1 + 16) = v7;
          if (v20 != v2)
          {
            v21 = v20;
            do
            {
              v23 = (void *)*((_QWORD *)v21 - 1);
              v21 -= 8;
              v22 = v23;
              if (v23)
                os_release(v22);
              *((_QWORD *)v20 - 1) = 0;
              v20 = v21;
            }
            while (v21 != v2);
          }
          goto LABEL_21;
        }
      }
    }
    else
    {
      v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      v19 = *((_QWORD *)v4 - 1);
      v4 -= 8;
      *((_QWORD *)v11 - 1) = v19;
      v11 -= 8;
      *(_QWORD *)v4 = 0;
    }
    while (v4 != v2);
    goto LABEL_16;
  }
}

void nw_data_transfer_report_add_snapshot_on_nw_queue(void *a1)
{
  _QWORD *v1;
  id v2;
  uint64_t v3;
  void *v4;
  dispatch_queue_t *v5;
  dispatch_queue_t *v6;
  uint64_t v7;
  char *v8;
  void (**v9)(_QWORD);
  NSObject *v10;
  NSObject *v11;
  unint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  unint64_t v16;
  nw_data_transfer_path_report *v17;
  nw_data_transfer_snapshot *v18;
  unint64_t var0;
  unsigned int *v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  NWConcrete_nw_endpoint_handler *v28;
  id v29;
  id v30;
  NSObject *v31;
  int radio_type;
  const char *v33;
  uint64_t v34;
  int v35;
  const char *v36;
  id v37;
  void (**v38)(_QWORD);
  void *v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  void *v43;
  os_log_type_t v44;
  void *v45;
  os_log_type_t v46;
  char *backtrace_string;
  os_log_type_t v48;
  _BOOL4 v49;
  char *v50;
  os_log_type_t v51;
  _BOOL4 v52;
  os_log_type_t v53;
  _BOOL4 v54;
  os_log_type_t v55;
  os_log_type_t v56;
  os_log_type_t v57;
  _QWORD v58[4];
  char *v59;
  id v60;
  void *v61;
  unint64_t v62;
  char v63;
  void *v64;
  _QWORD aBlock[4];
  id v66;
  os_log_type_t *v67;
  os_log_type_t type[8];
  os_log_type_t *v69;
  uint64_t v70;
  char v71;
  uint8_t buf[4];
  const char *v73;
  __int16 v74;
  char *v75;
  __int16 v76;
  void *v77;
  __int16 v78;
  unint64_t v79;
  __int16 v80;
  uint64_t v81;
  __int16 v82;
  const char *v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    v40 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v64) = 0;
    if (!__nwlog_fault(v40, type, &v64))
      goto LABEL_103;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v42 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if ((_BYTE)v64)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v48 = type[0];
      v49 = os_log_type_enabled(v41, type[0]);
      if (backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
          v74 = 2082;
          v75 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v41, v48, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_103:
        if (!v40)
          goto LABEL_16;
LABEL_104:
        free(v40);
        goto LABEL_16;
      }
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v48, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v55 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v55, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_102:

    goto LABEL_103;
  }
  v3 = v1[3];
  if (!v3)
  {
    __nwlog_obj();
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    v40 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v64) = 0;
    if (!__nwlog_fault(v40, type, &v64))
      goto LABEL_103;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v44 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v44, "%{public}s called with null report->connection", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (!(_BYTE)v64)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v56 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v56, "%{public}s called with null report->connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_102;
    }
    v50 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v41 = objc_claimAutoreleasedReturnValue();
    v51 = type[0];
    v52 = os_log_type_enabled(v41, type[0]);
    if (!v50)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v51, "%{public}s called with null report->connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      v74 = 2082;
      v75 = v50;
      _os_log_impl(&dword_182FBE000, v41, v51, "%{public}s called with null report->connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_83;
  }
  v4 = *(void **)(v3 + 24);
  if (!v4)
  {
    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    v40 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v64) = 0;
    if (!__nwlog_fault(v40, type, &v64))
      goto LABEL_103;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v46 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v46, "%{public}s called with null report->connection->context", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (!(_BYTE)v64)
    {
      __nwlog_obj();
      v41 = objc_claimAutoreleasedReturnValue();
      v57 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v57, "%{public}s called with null report->connection->context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_102;
    }
    v50 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v41 = objc_claimAutoreleasedReturnValue();
    v53 = type[0];
    v54 = os_log_type_enabled(v41, type[0]);
    if (!v50)
    {
      if (v54)
      {
        *(_DWORD *)buf = 136446210;
        v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v41, v53, "%{public}s called with null report->connection->context, no backtrace", buf, 0xCu);
      }
      goto LABEL_102;
    }
    if (v54)
    {
      *(_DWORD *)buf = 136446466;
      v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      v74 = 2082;
      v75 = v50;
      _os_log_impl(&dword_182FBE000, v41, v53, "%{public}s called with null report->connection->context, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_83:

    free(v50);
    if (!v40)
      goto LABEL_16;
    goto LABEL_104;
  }
  v5 = v4;
  v6 = v5;
  if (((_BYTE)v5[17] & 8) == 0)
    dispatch_assert_queue_V2(v5[1]);

  *(_QWORD *)type = 0;
  v69 = type;
  v70 = 0x2020000000;
  v7 = MEMORY[0x1E0C809B0];
  v71 = 0;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke;
  aBlock[3] = &unk_1E14ACE40;
  v67 = type;
  v8 = (char *)v2;
  v66 = v8;
  v9 = (void (**)(_QWORD))_Block_copy(aBlock);
  os_unfair_lock_lock((os_unfair_lock_t)v2 + 10);
  v9[2](v9);
  os_unfair_lock_unlock((os_unfair_lock_t)v2 + 10);

  if (!*((_BYTE *)v69 + 24))
  {
    v64 = 0;
    v63 = 0;
    v62 = 0;
    nw_connection_fillout_data_transfer_snapshot_on_nw_queue(*((void **)v2 + 3), (uint64_t *)&v64, &v62, &v63, 0);
    if (!v64 || __ROR8__(0xD37A6F4DE9BD37A7 * v62, 3) > 0x1642C8590B21642uLL)
      goto LABEL_12;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      v74 = 2048;
      v75 = v8;
      v76 = 2048;
      v77 = v64;
      v78 = 2048;
      v79 = v62 / 0xB8;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s report %p adding snapshot %p with snapshot path count %lu", buf, 0x2Au);
    }

    v12 = v62;
    if (v62 - 184 <= 0xB7)
    {
      v13 = *((_QWORD *)v2 + 3);
      if ((*(_BYTE *)(v13 + 109) & 0x40) != 0)
      {
        v28 = nw_endpoint_handler_copy_connected_flow_handler(*(void **)(v13 + 144));
        v29 = nw_endpoint_handler_copy_current_path(v28);
        v30 = nw_path_copy_interface(v29);

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v31 = (id)gLogObj;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          if (v30)
          {
            radio_type = nw_interface_get_radio_type(v30);
            v33 = nw_interface_radio_type_to_string(radio_type);
          }
          else
          {
            v33 = "none";
          }
          v34 = *((_QWORD *)v8 + 4);
          if (v34)
          {
            v35 = nw_interface_get_radio_type(*((void **)v8 + 4));
            v36 = nw_interface_radio_type_to_string(v35);
          }
          else
          {
            v36 = "none";
          }
          *(_DWORD *)buf = 136447490;
          v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
          v74 = 2048;
          v75 = v8;
          v76 = 2112;
          v77 = v30;
          v78 = 2080;
          v79 = (unint64_t)v33;
          v80 = 2112;
          v81 = v34;
          v82 = 2080;
          v83 = v36;
          _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, "%{public}s report %p got snapshot for interface %@[%s] (currently collecting interface: %@[%s])", buf, 0x3Eu);
        }

        v58[0] = v7;
        v58[1] = 3221225472;
        v58[2] = __nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke_166;
        v58[3] = &unk_1E14AB278;
        v59 = v8;
        v61 = v64;
        v37 = v30;
        v60 = v37;
        v38 = (void (**)(_QWORD))_Block_copy(v58);
        os_unfair_lock_lock((os_unfair_lock_t)v2 + 10);
        v38[2](v38);
        os_unfair_lock_unlock((os_unfair_lock_t)v2 + 10);

        goto LABEL_12;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
      v74 = 2048;
      v75 = v8;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s report %p adding multipath snapshot", buf, 0x16u);
    }

    if (v12 < 0xB8)
    {
LABEL_12:
      if (v63 && v64)
        free(v64);
      goto LABEL_15;
    }
    v15 = 0;
    if (v12 / 0xB8 <= 1)
      v16 = 1;
    else
      v16 = v12 / 0xB8;
    while (1)
    {
      v18 = (nw_data_transfer_snapshot *)((char *)v64 + 184 * v15);
      var0 = v18->var0;
      v17 = (nw_data_transfer_path_report *)(v8 + 56);
      if (v18->var0)
      {
        v20 = (unsigned int *)*((_QWORD *)v8 + 51);
        v21 = v20 ? v20[2] : 0;
        v17 = (nw_data_transfer_path_report *)(v8 + 56);
        if (var0 != v21)
        {
          v22 = *((_DWORD *)v8 + 11);
          if (v22 < 2)
          {
LABEL_44:
            nw_data_transfer_add_initial_snapshot(v8, v20, (NWConcrete_nw_interface **)v64 + 23 * v15);
            goto LABEL_29;
          }
          v23 = 0;
          v24 = *((_QWORD *)v8 + 52);
          LODWORD(v25) = v22 - 1;
          if (v25 <= 1)
            v25 = 1;
          else
            v25 = v25;
          v26 = (uint64_t *)(v24 + 352);
          while (1)
          {
            v27 = *v26;
            if (*v26)
              v27 = *(unsigned int *)(v27 + 8);
            if (var0 == v27)
              break;
            ++v23;
            v26 += 45;
            if (v25 == v23)
              goto LABEL_44;
          }
          v17 = (nw_data_transfer_path_report *)(v24 + 360 * v23);
        }
      }
      nw_data_transfer_update_path_report_end(v17, (nw_data_transfer_snapshot *)v64 + v15);
      nw_data_transfer_update_path_report_begin(v17, v18);
LABEL_29:
      if (++v15 == v16)
        goto LABEL_12;
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (id)gLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    v73 = "nw_data_transfer_report_add_snapshot_on_nw_queue";
    v74 = 2048;
    v75 = v8;
    _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s skipping snapshot for collected report %p", buf, 0x16u);
  }

LABEL_15:
  _Block_object_dispose(type, 8);
LABEL_16:

}

void sub_1831BFE40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,char a29)
{
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void nw_connection_fillout_data_transfer_snapshot_on_nw_queue(void *a1, uint64_t *a2, _QWORD *a3, _BYTE *a4, int a5)
{
  void **v9;
  void **v10;
  void **v11;
  void *v12;
  id v13;
  void *v14;
  NWConcrete_nw_endpoint_handler *v15;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v17;
  uint64_t v18;
  id v19;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  const char *v28;
  os_log_type_t v29;
  const char *v30;
  const char *v31;
  id v32;
  void *v33;
  NWConcrete_nw_endpoint_handler *v34;
  uint64_t v35;
  NWConcrete_nw_endpoint_mode_handler *v36;
  uint64_t v37;
  id v38;
  const char *v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  char *v44;
  os_log_type_t v45;
  _BOOL4 v46;
  const char *v47;
  os_log_type_t v48;
  const char *v49;
  const char *v50;
  void *v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  void *v55;
  os_log_type_t v56;
  char *backtrace_string;
  os_log_type_t v58;
  _BOOL4 v59;
  char *v60;
  os_log_type_t v61;
  _BOOL4 v62;
  void *v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  void *v67;
  os_log_type_t v68;
  void *v69;
  os_log_type_t v70;
  void *v71;
  os_log_type_t v72;
  os_log_type_t v73;
  os_log_type_t v74;
  char *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  char *v78;
  os_log_type_t v79;
  _BOOL4 v80;
  char *v81;
  os_log_type_t v82;
  _BOOL4 v83;
  char *v84;
  os_log_type_t v85;
  _BOOL4 v86;
  NSObject *v87;
  void *v88;
  os_log_type_t v89;
  os_log_type_t v90;
  os_log_type_t v91;
  os_log_type_t v92;
  char v93;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v96;
  __int16 v97;
  uint64_t v98;
  __int16 v99;
  uint64_t v100;
  __int16 v101;
  char *v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = v9;
  if (!v9)
  {
    __nwlog_obj();
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
    v52 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v52, &type, &v93))
      goto LABEL_165;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v54 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v93)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      v59 = os_log_type_enabled(v53, type);
      if (backtrace_string)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
          v97 = 2082;
          v98 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v53, v58, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_165:
        if (!v52)
          goto LABEL_88;
LABEL_166:
        free(v52);
        goto LABEL_88;
      }
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v53, v58, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v73 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v53, v73, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_164:

    goto LABEL_165;
  }
  if (!a2)
  {
    __nwlog_obj();
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
    v52 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v52, &type, &v93))
      goto LABEL_165;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v53, v56, "%{public}s called with null snapshot", buf, 0xCu);
      }
    }
    else if (v93)
    {
      v60 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v53, type);
      if (v60)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446466;
          v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
          v97 = 2082;
          v98 = (uint64_t)v60;
          _os_log_impl(&dword_182FBE000, v53, v61, "%{public}s called with null snapshot, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v60);
        if (!v52)
          goto LABEL_88;
        goto LABEL_166;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v53, v61, "%{public}s called with null snapshot, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v74 = type;
      if (os_log_type_enabled(v53, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_fillout_data_transfer_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v53, v74, "%{public}s called with null snapshot, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_164;
  }
  nw_context_assert_queue(v9[3]);
  if ((*((_BYTE *)v10 + 109) & 0x40) == 0 || !v10[18])
    goto LABEL_88;
  v11 = v10;
  if (!a3)
  {
    __nwlog_obj();
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
    v64 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (!__nwlog_fault(v64, &type, &v93))
      goto LABEL_193;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v66 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s called with null snapshot_length", buf, 0xCu);
      }
      goto LABEL_192;
    }
    if (!v93)
    {
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v89 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v65, v89, "%{public}s called with null snapshot_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_192;
    }
    v75 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v65 = objc_claimAutoreleasedReturnValue();
    v76 = type;
    v77 = os_log_type_enabled(v65, type);
    if (!v75)
    {
      if (v77)
      {
        *(_DWORD *)buf = 136446210;
        v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s called with null snapshot_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_192;
    }
    if (v77)
    {
      *(_DWORD *)buf = 136446466;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      v97 = 2082;
      v98 = (uint64_t)v75;
      _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s called with null snapshot_length, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v75);
LABEL_193:
    if (!v64)
      goto LABEL_8;
    goto LABEL_194;
  }
  if (a4)
  {
    nw_context_assert_queue(v10[3]);
    nw_endpoint_handler_fillout_data_transfer_snapshot(v10[18], a2, a3, a4, a5 ^ 1);
    goto LABEL_8;
  }
  __nwlog_obj();
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
  v64 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v93 = 0;
  if (!__nwlog_fault(v64, &type, &v93))
    goto LABEL_193;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v65 = objc_claimAutoreleasedReturnValue();
    v72 = type;
    if (os_log_type_enabled(v65, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s called with null should_release_snapshot", buf, 0xCu);
    }
LABEL_192:

    goto LABEL_193;
  }
  if (!v93)
  {
    __nwlog_obj();
    v65 = objc_claimAutoreleasedReturnValue();
    v92 = type;
    if (os_log_type_enabled(v65, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl(&dword_182FBE000, v65, v92, "%{public}s called with null should_release_snapshot, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_192;
  }
  v84 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v65 = objc_claimAutoreleasedReturnValue();
  v85 = type;
  v86 = os_log_type_enabled(v65, type);
  if (!v84)
  {
    if (v86)
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
      _os_log_impl(&dword_182FBE000, v65, v85, "%{public}s called with null should_release_snapshot, no backtrace", buf, 0xCu);
    }
    goto LABEL_192;
  }
  if (v86)
  {
    *(_DWORD *)buf = 136446466;
    v96 = "nw_connection_get_data_transfer_snapshot_for_connected_endpoint_on_nw_queue";
    v97 = 2082;
    v98 = (uint64_t)v84;
    _os_log_impl(&dword_182FBE000, v65, v85, "%{public}s called with null should_release_snapshot, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v84);
  if (v64)
LABEL_194:
    free(v64);
LABEL_8:

  if (*a2)
    goto LABEL_11;
  v12 = malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
  if (v12)
  {
LABEL_10:
    *a2 = (uint64_t)v12;
    *a3 = 184;
    *a4 = 1;
LABEL_11:
    v13 = v10[18];
    v14 = v13;
    if (v13)
    {
      v15 = (NWConcrete_nw_endpoint_handler *)v13;
      mode = v15->mode;

      if ((_DWORD)mode == 2)
      {
        v17 = nw_endpoint_handler_copy_flow(v15);
        v18 = *((_QWORD *)v17 + 133);

        goto LABEL_49;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      if (mode > 5)
        v20 = "unknown-mode";
      else
        v20 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v96 = "nw_endpoint_handler_get_sent_application_byte_count";
      v97 = 2082;
      v98 = (uint64_t)v20;
      v99 = 2082;
      v100 = (uint64_t)"flow";
      v21 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v93 = 0;
      if (__nwlog_fault(v21, &type, &v93))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            if (mode > 5)
              v24 = "unknown-mode";
            else
              v24 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446722;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            v97 = 2082;
            v98 = (uint64_t)v24;
            v99 = 2082;
            v100 = (uint64_t)"flow";
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
          }
        }
        else if (v93)
        {
          v25 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v26 = type;
          v27 = os_log_type_enabled(v22, type);
          if (v25)
          {
            if (v27)
            {
              if (mode > 5)
                v28 = "unknown-mode";
              else
                v28 = off_1E149FC18[mode];
              *(_DWORD *)buf = 136446978;
              v96 = "nw_endpoint_handler_get_sent_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v28;
              v99 = 2082;
              v100 = (uint64_t)"flow";
              v101 = 2082;
              v102 = v25;
              _os_log_impl(&dword_182FBE000, v22, v26, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v25);
            if (!v21)
              goto LABEL_48;
            goto LABEL_47;
          }
          if (v27)
          {
            if (mode > 5)
              v31 = "unknown-mode";
            else
              v31 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446722;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            v97 = 2082;
            v98 = (uint64_t)v31;
            v99 = 2082;
            v100 = (uint64_t)"flow";
            _os_log_impl(&dword_182FBE000, v22, v26, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v29 = type;
          if (os_log_type_enabled(v22, type))
          {
            if (mode > 5)
              v30 = "unknown-mode";
            else
              v30 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446722;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            v97 = 2082;
            v98 = (uint64_t)v30;
            v99 = 2082;
            v100 = (uint64_t)"flow";
            _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
          }
        }
LABEL_45:

      }
    }
    else
    {
      __nwlog_obj();
      v67 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v96 = "nw_endpoint_handler_get_sent_application_byte_count";
      v21 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v93 = 0;
      if (__nwlog_fault(v21, &type, &v93))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          v68 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_182FBE000, v22, v68, "%{public}s called with null handler", buf, 0xCu);
          }
        }
        else if (v93)
        {
          v78 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          v79 = type;
          v80 = os_log_type_enabled(v22, type);
          if (v78)
          {
            if (v80)
            {
              *(_DWORD *)buf = 136446466;
              v96 = "nw_endpoint_handler_get_sent_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v78;
              _os_log_impl(&dword_182FBE000, v22, v79, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v78);
            if (!v21)
              goto LABEL_48;
            goto LABEL_47;
          }
          if (v80)
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_182FBE000, v22, v79, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          v90 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            v96 = "nw_endpoint_handler_get_sent_application_byte_count";
            _os_log_impl(&dword_182FBE000, v22, v90, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_45;
      }
    }
    if (!v21)
    {
LABEL_48:
      v18 = 0;
LABEL_49:

      *(_QWORD *)(*a2 + 176) = v18;
      v32 = v10[18];
      v33 = v32;
      if (v32)
      {
        v34 = (NWConcrete_nw_endpoint_handler *)v32;
        v35 = v34->mode;

        if ((_DWORD)v35 == 2)
        {
          v36 = nw_endpoint_handler_copy_flow(v34);
          v37 = *((_QWORD *)v36 + 134);

LABEL_87:
          *(_QWORD *)(*a2 + 168) = v37;
LABEL_88:

          return;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        if (v35 > 5)
          v39 = "unknown-mode";
        else
          v39 = off_1E149FC18[v35];
        *(_DWORD *)buf = 136446722;
        v96 = "nw_endpoint_handler_get_received_application_byte_count";
        v97 = 2082;
        v98 = (uint64_t)v39;
        v99 = 2082;
        v100 = (uint64_t)"flow";
        v40 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v93 = 0;
        if (__nwlog_fault(v40, &type, &v93))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v41 = (id)gLogObj;
            v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              if (v35 > 5)
                v43 = "unknown-mode";
              else
                v43 = off_1E149FC18[v35];
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v43;
              v99 = 2082;
              v100 = (uint64_t)"flow";
              _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
            }
          }
          else if (v93)
          {
            v44 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v41 = (id)gLogObj;
            v45 = type;
            v46 = os_log_type_enabled(v41, type);
            if (v44)
            {
              if (v46)
              {
                if (v35 > 5)
                  v47 = "unknown-mode";
                else
                  v47 = off_1E149FC18[v35];
                *(_DWORD *)buf = 136446978;
                v96 = "nw_endpoint_handler_get_received_application_byte_count";
                v97 = 2082;
                v98 = (uint64_t)v47;
                v99 = 2082;
                v100 = (uint64_t)"flow";
                v101 = 2082;
                v102 = v44;
                _os_log_impl(&dword_182FBE000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
              }

              free(v44);
              if (!v40)
                goto LABEL_86;
              goto LABEL_85;
            }
            if (v46)
            {
              if (v35 > 5)
                v50 = "unknown-mode";
              else
                v50 = off_1E149FC18[v35];
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v50;
              v99 = 2082;
              v100 = (uint64_t)"flow";
              _os_log_impl(&dword_182FBE000, v41, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v41 = (id)gLogObj;
            v48 = type;
            if (os_log_type_enabled(v41, type))
            {
              if (v35 > 5)
                v49 = "unknown-mode";
              else
                v49 = off_1E149FC18[v35];
              *(_DWORD *)buf = 136446722;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              v97 = 2082;
              v98 = (uint64_t)v49;
              v99 = 2082;
              v100 = (uint64_t)"flow";
              _os_log_impl(&dword_182FBE000, v41, v48, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
            }
          }
LABEL_83:

        }
      }
      else
      {
        __nwlog_obj();
        v69 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v96 = "nw_endpoint_handler_get_received_application_byte_count";
        v40 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v93 = 0;
        if (__nwlog_fault(v40, &type, &v93))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v41 = objc_claimAutoreleasedReturnValue();
            v70 = type;
            if (os_log_type_enabled(v41, type))
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              _os_log_impl(&dword_182FBE000, v41, v70, "%{public}s called with null handler", buf, 0xCu);
            }
          }
          else if (v93)
          {
            v81 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v41 = objc_claimAutoreleasedReturnValue();
            v82 = type;
            v83 = os_log_type_enabled(v41, type);
            if (v81)
            {
              if (v83)
              {
                *(_DWORD *)buf = 136446466;
                v96 = "nw_endpoint_handler_get_received_application_byte_count";
                v97 = 2082;
                v98 = (uint64_t)v81;
                _os_log_impl(&dword_182FBE000, v41, v82, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v81);
              if (!v40)
                goto LABEL_86;
              goto LABEL_85;
            }
            if (v83)
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              _os_log_impl(&dword_182FBE000, v41, v82, "%{public}s called with null handler, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v41 = objc_claimAutoreleasedReturnValue();
            v91 = type;
            if (os_log_type_enabled(v41, type))
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_endpoint_handler_get_received_application_byte_count";
              _os_log_impl(&dword_182FBE000, v41, v91, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
            }
          }
          goto LABEL_83;
        }
      }
      if (!v40)
      {
LABEL_86:
        v37 = 0;
        goto LABEL_87;
      }
LABEL_85:
      free(v40);
      goto LABEL_86;
    }
LABEL_47:
    free(v21);
    goto LABEL_48;
  }
  __nwlog_obj();
  v87 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v96 = "strict_calloc";
  v97 = 2048;
  v98 = 1;
  v99 = 2048;
  v100 = 184;
  v88 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v88))
  {
    free(v88);
    goto LABEL_10;
  }
  __break(1u);
}

void sub_1831C140C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_fillout_data_transfer_snapshot(void *a1, uint64_t *a2, _QWORD *a3, _BYTE *a4, int a5)
{
  os_unfair_lock_s *v9;
  os_unfair_lock_s *v10;
  void *v11;
  _QWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t (*v18)(void);
  void *v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  NSObject *v25;
  _BOOL8 v26;
  void *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  void *v32;
  void *v33;
  NSObject *v34;
  os_log_type_t v35;
  char *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  void *v39;
  os_log_type_t v40;
  void *v41;
  os_log_type_t v42;
  void *v43;
  os_log_type_t v44;
  char *backtrace_string;
  os_log_type_t v46;
  _BOOL4 v47;
  os_log_type_t v48;
  _BOOL4 v49;
  os_log_type_t v50;
  _BOOL4 v51;
  os_log_type_t v52;
  _BOOL4 v53;
  os_log_type_t v54;
  os_log_type_t v55;
  os_log_type_t v56;
  os_log_type_t v57;
  os_log_type_t v58;
  _QWORD v59[8];
  int v60;
  char v61;
  os_log_type_t type;
  _BYTE v63[24];
  char v64;
  _BYTE buf[12];
  __int16 v66;
  char *v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = v9;
  if (v9)
  {
    *(_QWORD *)v63 = 0;
    *(_QWORD *)&v63[8] = v63;
    *(_QWORD *)&v63[16] = 0x2020000000;
    v64 = 0;
    os_unfair_lock_lock(v9 + 28);
    v11 = *(void **)&v10[62]._os_unfair_lock_opaque;
    if (v10[29]._os_unfair_lock_opaque != 2)
    {
      v59[0] = MEMORY[0x1E0C809B0];
      v59[1] = 3221225472;
      v59[2] = __nw_endpoint_handler_fillout_data_transfer_snapshot_block_invoke;
      v59[3] = &unk_1E149FAB0;
      v59[6] = a3;
      v59[7] = a4;
      v60 = a5;
      v59[4] = v63;
      v59[5] = a2;
      objc_msgSend(v11, "applyWithHandler:toChildren:", v10, v59);
LABEL_33:
      os_unfair_lock_unlock(v10 + 28);
      v26 = *(_BYTE *)(*(_QWORD *)&v63[8] + 24) != 0;
      _Block_object_dispose(v63, 8);
      goto LABEL_34;
    }
    v12 = v11;
    v13 = v12;
    if (v12)
    {
      if (a2)
      {
        if (a3)
        {
          if (a4)
          {
            *a4 = 0;
            v14 = v12[101];
            if (v14)
            {
              *a2 = v14;
              *a3 = v12[102];
              if (a5 != 1)
                goto LABEL_9;
              goto LABEL_24;
            }
            v16 = (_QWORD *)v12[51];
            if (v16)
            {
              v17 = v16[3];
              if (v17)
              {
                v18 = *(uint64_t (**)(void))(v17 + 224);
                if (v18)
                {
                  v19 = (void *)v16[5];
                  if (v19 == &nw_protocol_ref_counted_handle)
                  {
                    v21 = v16[11];
                    if (v21)
                      v16[11] = v21 + 1;
                    v20 = -1;
                  }
                  else
                  {
                    v20 = 0;
                  }
                  *(_QWORD *)buf = v16;
                  buf[8] = v20;
                  v22 = v18();
                  if (v19 == &nw_protocol_ref_counted_handle)
                    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                  *a2 = v22;
                  if (v22)
                  {
                    *a4 = 1;
                    if (a5 != 1)
                    {
LABEL_9:
                      if (!a5)
                      {
                        v15 = v13[206] + 1;
LABEL_26:
                        v13[206] = v15;
                        goto LABEL_27;
                      }
                      goto LABEL_27;
                    }
LABEL_24:
                    v23 = v13[206];
                    if (v23)
                    {
                      v15 = v23 - 1;
                      goto LABEL_26;
                    }
LABEL_27:
                    v24 = 1;
LABEL_32:

                    *(_BYTE *)(*(_QWORD *)&v63[8] + 24) = v24;
                    goto LABEL_33;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v25 = (id)gLogObj;
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
                    _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s copy_info() returned NULL", buf, 0xCu);
                  }

                }
              }
            }
LABEL_31:
            v24 = 0;
            goto LABEL_32;
          }
          __nwlog_obj();
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          v33 = (void *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v61 = 0;
          if (!__nwlog_fault((const char *)v33, &type, &v61))
          {
LABEL_85:
            if (v33)
              free(v33);
            goto LABEL_31;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v34 = objc_claimAutoreleasedReturnValue();
            v44 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_182FBE000, v34, v44, "%{public}s called with null should_release_snapshot", buf, 0xCu);
            }
LABEL_119:

            goto LABEL_85;
          }
          if (!v61)
          {
            __nwlog_obj();
            v34 = objc_claimAutoreleasedReturnValue();
            v58 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_182FBE000, v34, v58, "%{public}s called with null should_release_snapshot, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_119;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v34 = objc_claimAutoreleasedReturnValue();
          v52 = type;
          v53 = os_log_type_enabled(v34, type);
          if (!backtrace_string)
          {
            if (v53)
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_182FBE000, v34, v52, "%{public}s called with null should_release_snapshot, no backtrace", buf, 0xCu);
            }
            goto LABEL_119;
          }
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            v66 = 2082;
            v67 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v34, v52, "%{public}s called with null should_release_snapshot, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
        else
        {
          __nwlog_obj();
          v41 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          v33 = (void *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v61 = 0;
          if (!__nwlog_fault((const char *)v33, &type, &v61))
            goto LABEL_85;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v34 = objc_claimAutoreleasedReturnValue();
            v42 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_182FBE000, v34, v42, "%{public}s called with null snapshot_length", buf, 0xCu);
            }
            goto LABEL_119;
          }
          if (!v61)
          {
            __nwlog_obj();
            v34 = objc_claimAutoreleasedReturnValue();
            v57 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_182FBE000, v34, v57, "%{public}s called with null snapshot_length, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_119;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v34 = objc_claimAutoreleasedReturnValue();
          v50 = type;
          v51 = os_log_type_enabled(v34, type);
          if (!backtrace_string)
          {
            if (v51)
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
              _os_log_impl(&dword_182FBE000, v34, v50, "%{public}s called with null snapshot_length, no backtrace", buf, 0xCu);
            }
            goto LABEL_119;
          }
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            v66 = 2082;
            v67 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v34, v50, "%{public}s called with null snapshot_length, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
      }
      else
      {
        __nwlog_obj();
        v39 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
        v33 = (void *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v61 = 0;
        if (!__nwlog_fault((const char *)v33, &type, &v61))
          goto LABEL_85;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v34 = objc_claimAutoreleasedReturnValue();
          v40 = type;
          if (os_log_type_enabled(v34, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            _os_log_impl(&dword_182FBE000, v34, v40, "%{public}s called with null snapshot", buf, 0xCu);
          }
          goto LABEL_119;
        }
        if (!v61)
        {
          __nwlog_obj();
          v34 = objc_claimAutoreleasedReturnValue();
          v56 = type;
          if (os_log_type_enabled(v34, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            _os_log_impl(&dword_182FBE000, v34, v56, "%{public}s called with null snapshot, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_119;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        v49 = os_log_type_enabled(v34, type);
        if (!backtrace_string)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
            _os_log_impl(&dword_182FBE000, v34, v48, "%{public}s called with null snapshot, no backtrace", buf, 0xCu);
          }
          goto LABEL_119;
        }
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          v66 = 2082;
          v67 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v34, v48, "%{public}s called with null snapshot, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
    }
    else
    {
      __nwlog_obj();
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
      v33 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (!__nwlog_fault((const char *)v33, &type, &v61))
        goto LABEL_85;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
        goto LABEL_119;
      }
      if (!v61)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v55 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          _os_log_impl(&dword_182FBE000, v34, v55, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_119;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v46 = type;
      v47 = os_log_type_enabled(v34, type);
      if (!backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
          _os_log_impl(&dword_182FBE000, v34, v46, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
        goto LABEL_119;
      }
      if (v47)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_data_transfer_snapshot";
        v66 = 2082;
        v67 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v34, v46, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_85;
  }
  __nwlog_obj();
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)v63 = 136446210;
  *(_QWORD *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
  v29 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v29, buf, &type))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v31 = buf[0];
      if (os_log_type_enabled(v30, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v63 = 136446210;
        *(_QWORD *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null handler", v63, 0xCu);
      }
    }
    else if (type)
    {
      v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v37 = buf[0];
      v38 = os_log_type_enabled(v30, (os_log_type_t)buf[0]);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)v63 = 136446466;
          *(_QWORD *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
          *(_WORD *)&v63[12] = 2082;
          *(_QWORD *)&v63[14] = v36;
          _os_log_impl(&dword_182FBE000, v30, v37, "%{public}s called with null handler, dumping backtrace:%{public}s", v63, 0x16u);
        }

        free(v36);
        goto LABEL_93;
      }
      if (v38)
      {
        *(_DWORD *)v63 = 136446210;
        *(_QWORD *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
        _os_log_impl(&dword_182FBE000, v30, v37, "%{public}s called with null handler, no backtrace", v63, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v54 = buf[0];
      if (os_log_type_enabled(v30, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v63 = 136446210;
        *(_QWORD *)&v63[4] = "nw_endpoint_handler_fillout_data_transfer_snapshot";
        _os_log_impl(&dword_182FBE000, v30, v54, "%{public}s called with null handler, backtrace limit exceeded", v63, 0xCu);
      }
    }

  }
LABEL_93:
  if (v29)
    free(v29);
  v26 = 0;
LABEL_34:

  return v26;
}

uint64_t __nw_data_transfer_report_add_snapshot_on_nw_queue_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(result + 32) + 52) == 2;
  return result;
}

uint64_t nw_endpoint_flow_add_one_protocol(void *a1, __int128 *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  id v13;
  id v14;
  NWConcrete_nw_protocol_definition *v15;
  id v16;
  uint64_t protocol_for_definition;
  NSObject *v18;
  const char *v19;
  const char *v20;
  nw_endpoint_t v21;
  __int128 *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  id v26;
  _QWORD *v27;
  id v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  NSObject *v32;
  const char *id_string;
  const char *v34;
  nw_endpoint_t v35;
  const char *logging_description;
  const char *v37;
  const char *v38;
  id v39;
  char *backtrace_string;
  NSObject *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  void *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  os_log_type_t v54;
  __int128 *v55;
  void *v56;
  void *v57;
  id v58;
  NWConcrete_nw_protocol_definition *v59;
  char v60;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v63;
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  void *v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  id v75;
  __int16 v76;
  __int128 *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v14 = a3;
  v15 = a4;
  v16 = a5;
  v58 = a6;
  v59 = v15;
  v56 = v14;
  v57 = v16;
  protocol_for_definition = nw_endpoint_handler_create_protocol_for_definition((uint64_t)a2, v15, v16, v58);
  if (protocol_for_definition)
  {
    if (v15)
    {
      if (!v14)
      {
LABEL_12:
        v55 = a2;
        if (a7)
        {
          if (protocol_for_definition != a7)
          {
            v27 = *(_QWORD **)(protocol_for_definition + 24);
            if (v27 && *v27)
            {
              if ((nw_protocol_add_input_handler(protocol_for_definition, a7) & 1) != 0)
                goto LABEL_35;
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v32 = (id)gLogObj;
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v63 = "nw_protocol_utilities_add_input_handler";
                v64 = 2048;
                v65 = protocol_for_definition;
                _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
              }

            }
LABEL_28:
            if ((nw_endpoint_handler_get_logging_disabled(v13) & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v18 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              {
                id_string = nw_endpoint_handler_get_id_string(v13);
                v34 = nw_endpoint_handler_dry_run_string(v13);
                v35 = nw_endpoint_handler_copy_endpoint(v13);
                logging_description = nw_endpoint_get_logging_description(v35);
                v37 = nw_endpoint_handler_state_string(v13);
                v38 = nw_endpoint_handler_mode_string(v13);
                v39 = nw_endpoint_handler_copy_current_path(v13);
                *(_DWORD *)buf = 136448002;
                v63 = "nw_endpoint_flow_add_one_protocol";
                v64 = 2082;
                v65 = (uint64_t)id_string;
                v66 = 2082;
                v67 = (void *)v34;
                v68 = 2082;
                v69 = logging_description;
                v70 = 2082;
                v71 = v37;
                v72 = 2082;
                v73 = v38;
                v74 = 2114;
                v75 = v39;
                v76 = 2082;
                v77 = v55;
                _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach protocol %{public}s", buf, 0x52u);

              }
LABEL_33:

              goto LABEL_34;
            }
            goto LABEL_34;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          v63 = "nw_protocol_utilities_add_input_handler";
          v64 = 2048;
          v65 = a7;
          v29 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v60 = 0;
          if (!__nwlog_fault(v29, &type, &v60))
            goto LABEL_23;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v30 = (id)gLogObj;
            v31 = type;
            if (os_log_type_enabled(v30, type))
            {
              *(_DWORD *)buf = 136446466;
              v63 = "nw_protocol_utilities_add_input_handler";
              v64 = 2048;
              v65 = a7;
              _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
            }
          }
          else
          {
            if (v60)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v42 = (id)gLogObj;
              v43 = type;
              v44 = os_log_type_enabled(v42, type);
              if (backtrace_string)
              {
                if (v44)
                {
                  *(_DWORD *)buf = 136446722;
                  v63 = "nw_protocol_utilities_add_input_handler";
                  v64 = 2048;
                  v65 = a7;
                  v66 = 2082;
                  v67 = backtrace_string;
                  _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                }

                free(backtrace_string);
                if (!v29)
                  goto LABEL_28;
LABEL_24:
                free(v29);
                goto LABEL_28;
              }
              if (v44)
              {
                *(_DWORD *)buf = 136446466;
                v63 = "nw_protocol_utilities_add_input_handler";
                v64 = 2048;
                v65 = a7;
                _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
              }

LABEL_23:
              if (!v29)
                goto LABEL_28;
              goto LABEL_24;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v30 = (id)gLogObj;
            v45 = type;
            if (os_log_type_enabled(v30, type))
            {
              *(_DWORD *)buf = 136446466;
              v63 = "nw_protocol_utilities_add_input_handler";
              v64 = 2048;
              v65 = a7;
              _os_log_impl(&dword_182FBE000, v30, v45, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
            }
          }

          goto LABEL_23;
        }
        __nwlog_obj();
        v46 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v63 = "nw_protocol_utilities_add_input_handler";
        v47 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v60 = 0;
        if (__nwlog_fault(v47, &type, &v60))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v48 = objc_claimAutoreleasedReturnValue();
            v49 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              v63 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null input_protocol", buf, 0xCu);
            }
          }
          else
          {
            if (v60)
            {
              v50 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v51 = objc_claimAutoreleasedReturnValue();
              v52 = type;
              v53 = os_log_type_enabled(v51, type);
              if (v50)
              {
                if (v53)
                {
                  *(_DWORD *)buf = 136446466;
                  v63 = "nw_protocol_utilities_add_input_handler";
                  v64 = 2082;
                  v65 = (uint64_t)v50;
                  _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v50);
              }
              else
              {
                if (v53)
                {
                  *(_DWORD *)buf = 136446210;
                  v63 = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
                }

              }
              goto LABEL_64;
            }
            __nwlog_obj();
            v48 = objc_claimAutoreleasedReturnValue();
            v54 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              v63 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_182FBE000, v48, v54, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
LABEL_64:
        if (v47)
          free(v47);
        goto LABEL_28;
      }
    }
    else
    {
      v59 = nw_protocol_definition_create_with_identifier(a2);
      if (!v14)
        goto LABEL_12;
    }
    nw_endpoint_handler_set_protocol_instance(v13, v14, v59, protocol_for_definition);
    goto LABEL_12;
  }
  if ((nw_endpoint_handler_get_logging_disabled(v13) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v18 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = nw_endpoint_handler_get_id_string(v13);
      v20 = nw_endpoint_handler_dry_run_string(v13);
      v21 = nw_endpoint_handler_copy_endpoint(v13);
      v22 = a2;
      v23 = nw_endpoint_get_logging_description(v21);
      v24 = nw_endpoint_handler_state_string(v13);
      v25 = nw_endpoint_handler_mode_string(v13);
      v26 = nw_endpoint_handler_copy_current_path(v13);
      *(_DWORD *)buf = 136448002;
      v63 = "nw_endpoint_flow_add_one_protocol";
      v64 = 2082;
      v65 = (uint64_t)v19;
      v66 = 2082;
      v67 = (void *)v20;
      v68 = 2082;
      v69 = v23;
      v70 = 2082;
      v71 = v24;
      v72 = 2082;
      v73 = v25;
      v74 = 2114;
      v75 = v26;
      v76 = 2082;
      v77 = v22;
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create protocol handler: %{public}s", buf, 0x52u);

    }
    goto LABEL_33;
  }
LABEL_34:
  protocol_for_definition = 0;
LABEL_35:

  return protocol_for_definition;
}

void sub_1831C2B88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

uint64_t sub_1831C2BF8()
{
  uint64_t v0;
  uint64_t v1;

  v1 = *(unsigned __int8 *)(*(_QWORD *)(type metadata accessor for NWPath(0) - 8) + 80);
  return (*(uint64_t (**)(uint64_t))(v0 + 16))(v0 + ((v1 + 32) & ~v1));
}

ValueMetadata *type metadata accessor for NWEndpoint.Port()
{
  return &type metadata for NWEndpoint.Port;
}

void nw_protocol_definition_set_instance_state_allocator(void *a1, void *a2, void *a3)
{
  NWConcrete_nw_protocol_definition *v5;
  NWConcrete_nw_protocol_definition *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_instance_state_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_definition_set_instance_state_allocator";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8)
          goto LABEL_5;
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_instance_state_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_instance_state_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_instance_state_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_instance_state_allocator";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_instance_state_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8)
      goto LABEL_5;
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_extended_state(v5);
  v6->extended_state->var0 = a2;
  v6->extended_state->var1 = a3;
LABEL_5:

}

void sub_1831C3308(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_inbound_events(void *a1, void *a2, void *a3)
{
  NWConcrete_nw_protocol_definition *v5;
  NWConcrete_nw_protocol_definition *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_inbound_events";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_definition_set_inbound_events";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8)
          goto LABEL_5;
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_inbound_events";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null inbound_starting", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null inbound_starting, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null inbound_starting, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_inbound_events";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null inbound_starting, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_inbound_events";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null inbound_stopping", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v25, "%{public}s called with null inbound_stopping, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_inbound_events";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null inbound_stopping, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_inbound_events";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null inbound_stopping, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8)
      goto LABEL_5;
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_extended_state(v5);
  v6->extended_state->var10 = a2;
  v6->extended_state->var11 = a3;
LABEL_5:

}

void sub_1831C39DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_stream_path_affinity(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_stream_path_affinity_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_stream_path_affinity";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_stream_path_affinity";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_stream_path_affinity";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_stream_path_affinity";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_stream_path_affinity";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C3CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_max_udp_payload_size(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_max_udp_payload_size_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_udp_payload_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_udp_payload_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_udp_payload_size";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_udp_payload_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_udp_payload_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C400C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_max_paths_per_interface(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_max_paths_per_interface_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_paths_per_interface";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_paths_per_interface";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_paths_per_interface";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_paths_per_interface";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_paths_per_interface";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C4330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_max_datagram_frame_size(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_max_datagram_frame_size_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_datagram_frame_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_datagram_frame_size";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_max_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C4654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_keepalive_count(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_keepalive_count_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive_count";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive_count";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C4978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_initial_max_streams_unidirectional(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_initial_max_streams_unidirectional_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_unidirectional";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C4C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_initial_max_streams_bidirectional(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_initial_max_streams_bidirectional_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_bidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_bidirectional";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C4FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_initial_max_stream_data_bidirectional_remote(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_initial_max_stream_data_bidirectional_remote_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_remote";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_remote";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C52E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_initial_max_stream_data_bidirectional_local(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_initial_max_stream_data_bidirectional_local_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_local";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_local";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C5608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_initial_max_data(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_initial_max_data_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_data";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_data";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_data";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_data";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_data";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C592C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_ack_delay_size(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_ack_delay_size_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_ack_delay_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_ack_delay_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_ack_delay_size";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_ack_delay_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_ack_delay_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C5C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_probe_simultaneously(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_probe_simultaneously_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_probe_simultaneously";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_probe_simultaneously";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_probe_simultaneously";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_probe_simultaneously";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_probe_simultaneously";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C5FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_disable_spin_bit(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_disable_spin_bit_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_spin_bit";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_spin_bit";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_spin_bit";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_spin_bit";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_spin_bit";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C62D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_datagram_quarter_stream_id(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_datagram_quarter_stream_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_quarter_stream_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_quarter_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_quarter_stream_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_quarter_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_quarter_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C6604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_datagram_context_id(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_datagram_context_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_context_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_context_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831C6930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_protocol_instance_ignore_future_path_changes(void *a1)
{
  _BYTE *v1;
  char *v2;
  char v3;
  NSObject *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[405];
    if ((v3 & 4) == 0)
    {
      if ((v1[405] & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = (id)gLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446722;
          v16 = "nw_protocol_instance_ignore_future_path_changes";
          v17 = 2082;
          v18 = v2 + 407;
          v19 = 2080;
          v20 = " ";
          _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%sIgnoring future path changes for protocol", buf, 0x20u);
        }

        v3 = v2[405];
      }
      v2[405] = v3 | 4;
    }
    goto LABEL_8;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_instance_ignore_future_path_changes";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_instance_ignore_future_path_changes";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_instance_ignore_future_path_changes";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_instance_ignore_future_path_changes";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_instance_ignore_future_path_changes";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_25:
  if (v6)
    free(v6);
LABEL_8:

}

uint64_t NWPath.availableInterfaces.getter()
{
  return swift_bridgeObjectRetain();
}

uint64_t nw_protocol_instance_copy_path(void *a1, uint64_t a2)
{
  _QWORD *v3;
  char *v4;
  void *v5;
  dispatch_queue_t *v6;
  dispatch_queue_t *v7;
  _QWORD *v8;
  uint64_t v9;
  void (*v10)(void);
  void *v11;
  char v12;
  uint64_t node;
  uint64_t v14;
  id v15;
  void *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  uint64_t v22;
  NSObject *v23;
  os_log_type_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v28;
  os_log_type_t v29;
  os_log_type_t v30;
  _BOOL4 v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  _BYTE buf[12];
  __int16 v36;
  char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (char *)v3;
  if (!v3)
  {
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
    v16 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault((const char *)v16, &type, &v33))
    {
LABEL_48:
      if (!v16)
        goto LABEL_50;
LABEL_49:
      free(v16);
      goto LABEL_50;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_182FBE000, v17, v29, "%{public}s called with null instance", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (!v33)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_182FBE000, v17, v32, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    v30 = type;
    v31 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_182FBE000, v17, v30, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
      v36 = 2082;
      v37 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v17, v30, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_28;
  }
  v5 = (void *)v3[15];
  if (v5)
  {
    v6 = v5;
    v7 = v6;
    if (((_BYTE)v6[17] & 8) == 0)
      dispatch_assert_queue_V2(v6[1]);

  }
  if (a2 != -1)
  {
    if (*(_DWORD *)(*((_QWORD *)v4 + 1) + 64) == 3)
    {
      node = nw_hash_table_get_node(*((_QWORD *)v4 + 29), a2, 8);
      if (node)
      {
        v8 = *(_QWORD **)(node + 16);
        if (v8)
        {
          v14 = v8[3];
          if (v14)
          {
            v10 = *(void (**)(void))(v14 + 120);
            if (v10)
            {
              v11 = (void *)v8[5];
              if (v11 == &nw_protocol_ref_counted_handle)
              {
                v25 = v8[11];
                if (v25)
                  v8[11] = v25 + 1;
                v12 = -1;
              }
              else
              {
                v12 = 0;
              }
              goto LABEL_43;
            }
          }
        }
      }
      else if ((v4[405] & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
          v36 = 2082;
          v37 = v4 + 407;
          v38 = 2080;
          v39 = " ";
          v40 = 2048;
          v41 = a2;
          _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot access path, flow %llx does not exist", buf, 0x2Au);
        }

      }
LABEL_50:
      v26 = 0;
      goto LABEL_51;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
    v16 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault((const char *)v16, &type, &v33))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null (flow == (_nw_protocol_default_flow))", buf, 0xCu);
      }
LABEL_47:

      goto LABEL_48;
    }
    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v24 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null (flow == (_nw_protocol_default_flow)), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    v20 = type;
    v21 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null (flow == (_nw_protocol_default_flow)), no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_copy_path";
      v36 = 2082;
      v37 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null (flow == (_nw_protocol_default_flow)), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_28:

    free(backtrace_string);
    if (!v16)
      goto LABEL_50;
    goto LABEL_49;
  }
  v8 = (_QWORD *)*((_QWORD *)v4 - 6);
  if (!v8)
    goto LABEL_50;
  v9 = v8[3];
  if (!v9)
    goto LABEL_50;
  v10 = *(void (**)(void))(v9 + 120);
  if (!v10)
    goto LABEL_50;
  v11 = (void *)v8[5];
  if (v11 == &nw_protocol_ref_counted_handle)
  {
    v22 = v8[11];
    if (v22)
      v8[11] = v22 + 1;
    v12 = -1;
  }
  else
  {
    v12 = 0;
  }
LABEL_43:
  *(_QWORD *)buf = v8;
  buf[8] = v12;
  v10();
  v26 = objc_claimAutoreleasedReturnValue();
  if (v11 == &nw_protocol_ref_counted_handle)
    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
LABEL_51:

  return v26;
}

void sub_1831C7394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;
  va_list va;

  va_start(va, a7);
  if (v8 == v9)
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);

  _Unwind_Resume(a1);
}

uint64_t nw_path_is_traffic_mgmt_background(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[474] >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_is_traffic_mgmt_background";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_is_traffic_mgmt_background";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_is_traffic_mgmt_background";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_is_traffic_mgmt_background";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_is_traffic_mgmt_background";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_protocol_remove_instance_block_invoke(uint64_t a1, void *a2)
{
  id v4;
  void *v5;
  _BOOL8 v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  const char *logging_description;
  uint64_t v13;
  uint64_t v14;
  char *backtrace_string;
  _BOOL4 v16;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  void *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_remove_instance_block_invoke";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v7, &type, &v18))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_remove_instance_block_invoke";
      v10 = "%{public}s called with null protocol->identifier";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v16 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_protocol_remove_instance_block_invoke";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (!v16)
      {
LABEL_21:
        if (v7)
          free(v7);
        return 1;
      }
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_remove_instance_block_invoke";
      v10 = "%{public}s called with null protocol->identifier, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_remove_instance_block_invoke";
      v10 = "%{public}s called with null protocol->identifier, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_21;
  }
  if (gLogDatapath)
  {
    v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      logging_description = nw_endpoint_get_logging_description(a2);
      v13 = *(_QWORD *)(a1 + 32);
      v14 = *(_QWORD *)(v13 + 16);
      *(_DWORD *)buf = 136447234;
      v21 = "nw_protocol_remove_instance_block_invoke";
      v22 = 2080;
      v23 = (void *)logging_description;
      v24 = 2048;
      v25 = a2;
      v26 = 2048;
      v27 = v13;
      v28 = 2080;
      v29 = v14;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s checking registered endpoint %s (%p) to remove instance %p of %s", buf, 0x34u);
    }
  }
  v4 = nw_endpoint_copy_registrar_for_identifier(a2, *(__int128 **)(*(_QWORD *)(a1 + 32) + 16), 0);
  if (!v4)
    return 1;
  v5 = v4;
  nw_protocol_instance_registrar_remove_instance(v4, *(_QWORD *)(a1 + 32));
  v6 = nw_protocol_instance_registrar_get_instance_count(v5) == 0;
  os_release(v5);
  return v6;
}

uint64_t nw_protocol_instance_registrar_search_for_instance_to_join(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, int a7)
{
  uint64_t *v13;
  uint64_t v18;
  _BYTE *v19;
  void *v20;
  char v21;
  id v22;
  uint64_t instance_to_join;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  id v30;
  id v31;
  id v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  void *v38;
  id v39;
  id v40;
  id v41;
  void *v42;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  const char *v47;
  NSObject *v48;
  char *backtrace_string;
  _BOOL4 v50;
  void *v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  NSObject *v55;
  char *v56;
  os_log_type_t v57;
  _BOOL4 v58;
  NSObject *v59;
  NSObject *v60;
  os_log_type_t v61;
  void *v62;
  char *v63;
  NSObject *v64;
  os_log_type_t v65;
  char *v66;
  os_log_type_t v67;
  _BOOL4 v68;
  os_log_type_t v69;
  id v70;
  void *v71;
  id v72;
  void *v73;
  id v74;
  id v75;
  id v76;
  id v77;
  char v78;
  os_log_type_t type[8];
  os_log_type_t *v80;
  uint64_t v81;
  uint64_t v82;
  _BYTE buf[24];
  void *v84;
  __int128 v85;
  id v86;
  os_log_type_t *v87;
  uint64_t v88;
  uint64_t v89;
  char v90;
  char v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v75 = a3;
  v74 = a4;
  v76 = a5;
  v77 = a6;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
    v44 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (__nwlog_fault(v44, type, &v78))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v45 = __nwlog_obj();
        v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          v47 = "%{public}s called with null identifier";
LABEL_64:
          _os_log_impl(&dword_182FBE000, v45, v46, v47, buf, 0xCu);
        }
      }
      else if (v78)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v45 = __nwlog_obj();
        v46 = type[0];
        v50 = os_log_type_enabled(v45, type[0]);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v50)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          v47 = "%{public}s called with null identifier, no backtrace";
          goto LABEL_64;
        }
      }
      else
      {
        v45 = __nwlog_obj();
        v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_registrar_get_accept_function_for_identifier";
          v47 = "%{public}s called with null identifier, backtrace limit exceeded";
          goto LABEL_64;
        }
      }
    }
    if (v44)
      free(v44);
LABEL_25:
    if (gLogDatapath)
    {
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = a1;
        *(_WORD *)&buf[22] = 2048;
        v84 = (void *)a1;
        _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_DEBUG, "%{public}s protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x20u);
      }

    }
    goto LABEL_26;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  v13 = &g_registration_list;
  do
  {
    v13 = (uint64_t *)*v13;
    if (!v13)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      goto LABEL_25;
    }
  }
  while (*(_QWORD *)a1 != v13[4]
       || *(_QWORD *)(a1 + 8) != v13[5]
       || *(_QWORD *)(a1 + 16) != v13[6]
       || *(_QWORD *)(a1 + 24) != v13[7]
       || *(_QWORD *)(a1 + 32) != v13[8]);
  v18 = v13[13];
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  if (!v18)
    goto LABEL_25;
  v19 = v74;
  if (!v19)
  {
    __nwlog_obj();
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_is_registered";
    v52 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (__nwlog_fault(v52, type, &v78))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v53 = objc_claimAutoreleasedReturnValue();
        v54 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v78)
      {
        v56 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v53 = objc_claimAutoreleasedReturnValue();
        v57 = type[0];
        v58 = os_log_type_enabled(v53, type[0]);
        if (v56)
        {
          if (v58)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_is_registered";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v56;
            _os_log_impl(&dword_182FBE000, v53, v57, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v56);
          goto LABEL_79;
        }
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_182FBE000, v53, v57, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v53 = objc_claimAutoreleasedReturnValue();
        v61 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_is_registered";
          _os_log_impl(&dword_182FBE000, v53, v61, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_79:
    if (v52)
      free(v52);
    goto LABEL_81;
  }
  v20 = v19;
  v21 = v19[231];

  if ((v21 & 4) != 0)
  {
    v22 = nw_endpoint_copy_registrar_for_identifier(v20, (__int128 *)a1, 0);
    v71 = v22;
    if (v22)
    {
      instance_to_join = nw_protocol_instance_registrar_find_instance_to_join(v22, (void *)a1, a2, a7, 0, 0, v75, v76, v77, v18);
      if (instance_to_join)
      {
LABEL_33:

        goto LABEL_34;
      }
    }
    else if (gLogDatapath)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v20;
        *(_WORD *)&buf[22] = 2080;
        v84 = (void *)a1;
        LOWORD(v85) = 2048;
        *(_QWORD *)((char *)&v85 + 2) = a1;
        _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %@ does not have registrar for protocol %s (%p), continuing", buf, 0x2Au);
      }

    }
    v24 = v75;
    v25 = v20;
    v26 = v76;
    v27 = v77;
    v28 = v24;
    v29 = v25;
    v30 = v26;
    v31 = v27;
    if (gLogDatapath)
    {
      __nwlog_obj();
      v55 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_edges_for_instance_to_join_inner";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "non-";
        *(_WORD *)&buf[22] = 2112;
        v84 = v29;
        LOWORD(v85) = 2112;
        *(_QWORD *)((char *)&v85 + 2) = v30;
        _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEBUG, "%{public}s checking %swildcard edges from %@ for destination %@", buf, 0x2Au);
      }

    }
    *(_QWORD *)type = 0;
    v80 = type;
    v81 = 0x2020000000;
    v82 = 0;
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZL70nw_protocol_instance_registrar_search_edges_for_instance_to_join_innerPK22nw_protocol_identifiermPU25objcproto14OS_nw_endpoint8NSObjectS4_S4_PU27objcproto16OS_nw_parametersS2_bb_block_invoke;
    v84 = &unk_1E149AB60;
    v90 = 0;
    v87 = type;
    v88 = a1;
    v89 = a2;
    v91 = a7;
    v72 = v28;
    *(_QWORD *)&v85 = v72;
    v32 = v30;
    *((_QWORD *)&v85 + 1) = v32;
    v33 = v31;
    v86 = v33;
    v73 = v29;
    nw_endpoint_enumerate_edges(v29, a1, buf);
    instance_to_join = *((_QWORD *)v80 + 3);

    _Block_object_dispose(type, 8);
    if (!instance_to_join)
    {
      v34 = v72;
      v35 = v29;
      v36 = v32;
      v37 = v33;
      v38 = v37;
      if (gLogDatapath)
      {
        v70 = v37;
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_edges_for_instance_to_join_inner";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "";
          *(_WORD *)&buf[22] = 2112;
          v84 = v35;
          LOWORD(v85) = 2112;
          *(_QWORD *)((char *)&v85 + 2) = v36;
          _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_DEBUG, "%{public}s checking %swildcard edges from %@ for destination %@", buf, 0x2Au);
        }

        v38 = v70;
      }
      *(_QWORD *)type = 0;
      v80 = type;
      v81 = 0x2020000000;
      v82 = 0;
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = ___ZL70nw_protocol_instance_registrar_search_edges_for_instance_to_join_innerPK22nw_protocol_identifiermPU25objcproto14OS_nw_endpoint8NSObjectS4_S4_PU27objcproto16OS_nw_parametersS2_bb_block_invoke;
      v84 = &unk_1E149AB60;
      v90 = 1;
      v87 = type;
      v88 = a1;
      v89 = a2;
      v91 = a7;
      v39 = v34;
      *(_QWORD *)&v85 = v39;
      v40 = v36;
      *((_QWORD *)&v85 + 1) = v40;
      v41 = v38;
      v86 = v41;
      v42 = v35;
      nw_endpoint_enumerate_edges(v35, a1, buf);
      instance_to_join = *((_QWORD *)v80 + 3);

      _Block_object_dispose(type, 8);
    }

    goto LABEL_33;
  }
LABEL_81:
  __nwlog_obj();
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
  v63 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v78 = 0;
  if (__nwlog_fault(v63, type, &v78))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v64 = objc_claimAutoreleasedReturnValue();
      v65 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s searching for a protocol to join requires a registered endpoint", buf, 0xCu);
      }
    }
    else if (v78)
    {
      v66 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v64 = objc_claimAutoreleasedReturnValue();
      v67 = type[0];
      v68 = os_log_type_enabled(v64, type[0]);
      if (v66)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v66;
          _os_log_impl(&dword_182FBE000, v64, v67, "%{public}s searching for a protocol to join requires a registered endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v66);
        goto LABEL_97;
      }
      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl(&dword_182FBE000, v64, v67, "%{public}s searching for a protocol to join requires a registered endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v64 = objc_claimAutoreleasedReturnValue();
      v69 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl(&dword_182FBE000, v64, v69, "%{public}s searching for a protocol to join requires a registered endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_97:
  if (v63)
    free(v63);
LABEL_26:
  instance_to_join = 0;
LABEL_34:

  return instance_to_join;
}

void sub_1831C8530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31,id a32,id a33)
{
  void *v33;
  void *v34;
  void *v35;

  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

id nw_endpoint_copy_registrar_for_identifier(void *a1, __int128 *a2, int a3)
{
  id *v5;
  id *v6;
  id v7;
  BOOL v8;
  __int128 *v9;
  NSObject *v10;
  const char *v11;
  NWConcrete_nw_protocol_instance_registrar *v12;
  _QWORD *v13;
  _QWORD *v14;
  id v15;
  id v16;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  void *v22;
  os_log_type_t receiver;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _BOOL4 v28;
  char *v29;
  const char *v30;
  id v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  char *backtrace_string;
  os_log_type_t v36;
  _BOOL4 v37;
  os_log_type_t v38;
  os_log_type_t v39;
  os_log_type_t v40;
  char v41;
  os_log_type_t type;
  objc_super v43;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  char *v47;
  __int16 v48;
  const char *logging_description;
  __int16 v50;
  id *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    if (a2)
    {
      v7 = v5[26];
      if (v7)
        v8 = 1;
      else
        v8 = a3 == 0;
      if (v8)
      {
        if (v7 || (a3 & 1) != 0 || !gLogDatapath)
          goto LABEL_17;
        v9 = a2;
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          goto LABEL_42;
        *(_DWORD *)buf = 136446978;
        v45 = "nw_endpoint_copy_registrar_for_identifier";
        v46 = 2080;
        v47 = (char *)v9;
        v48 = 2080;
        logging_description = nw_endpoint_get_logging_description(v6);
        v50 = 2048;
        v51 = v6;
        v11 = "%{public}s no %s registrar for endpoint %s (%p), asked not to create a new one, returning nil";
        goto LABEL_41;
      }
      v12 = [NWConcrete_nw_protocol_instance_registrar alloc];
      if (!v12)
        goto LABEL_76;
      v43.receiver = v12;
      v43.super_class = (Class)NWConcrete_nw_protocol_instance_registrar;
      v13 = objc_msgSendSuper2(&v43, sel_init);
      v14 = v13;
      if (v13)
      {
        v13[2] = 0;
        nw_protocol_identifier_copy((uint64_t)(v13 + 3), a2);
        v14[8] = 0;
LABEL_16:
        v15 = v6[26];
        v6[26] = v14;

        if (!gLogDatapath)
        {
LABEL_17:
          v16 = v6[26];
          goto LABEL_18;
        }
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
LABEL_42:

          goto LABEL_17;
        }
        v29 = (char *)v6[26];
        v30 = nw_endpoint_get_logging_description(v6);
        *(_DWORD *)buf = 136446978;
        v45 = "nw_endpoint_copy_registrar_for_identifier";
        v46 = 2112;
        v47 = v29;
        v48 = 2080;
        logging_description = v30;
        v50 = 2048;
        v51 = v6;
        v11 = "%{public}s created registrar %@ for endpoint %s (%p)";
LABEL_41:
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, v11, buf, 0x2Au);
        goto LABEL_42;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
      v32 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v41 = 0;
      if ((__nwlog_fault(v32, &type, &v41) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v41)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          v36 = type;
          v37 = os_log_type_enabled(v33, type);
          if (backtrace_string)
          {
            if (v37)
            {
              *(_DWORD *)buf = 136446466;
              v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
              v46 = 2082;
              v47 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v33, v36, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_74;
          }
          if (v37)
          {
            *(_DWORD *)buf = 136446210;
            v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_182FBE000, v33, v36, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          v40 = type;
          if (os_log_type_enabled(v33, type))
          {
            *(_DWORD *)buf = 136446210;
            v45 = "-[NWConcrete_nw_protocol_instance_registrar initWithIdentifier:]";
            _os_log_impl(&dword_182FBE000, v33, v40, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_74:
      if (v32)
        free(v32);
LABEL_76:
      v14 = 0;
      goto LABEL_16;
    }
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_endpoint_copy_registrar_for_identifier";
    v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v43.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v19, &v43, &type))
    {
      if (LOBYTE(v43.receiver) == 17)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        receiver = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_182FBE000, v20, receiver, "%{public}s called with null identifier", buf, 0xCu);
        }
LABEL_64:

        goto LABEL_65;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v39 = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_182FBE000, v20, v39, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_64;
      }
      v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v27 = (os_log_type_t)v43.receiver;
      v28 = os_log_type_enabled(v20, (os_log_type_t)v43.receiver);
      if (!v24)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_182FBE000, v20, v27, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        v45 = "nw_endpoint_copy_registrar_for_identifier";
        v46 = 2082;
        v47 = v24;
        _os_log_impl(&dword_182FBE000, v20, v27, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_38;
    }
  }
  else
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_endpoint_copy_registrar_for_identifier";
    v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v43.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v19, &v43, &type))
    {
      if (LOBYTE(v43.receiver) == 17)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v38 = (os_log_type_t)v43.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v43.receiver))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_182FBE000, v20, v38, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_64;
      }
      v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v25 = (os_log_type_t)v43.receiver;
      v26 = os_log_type_enabled(v20, (os_log_type_t)v43.receiver);
      if (!v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_copy_registrar_for_identifier";
          _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_64;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v45 = "nw_endpoint_copy_registrar_for_identifier";
        v46 = 2082;
        v47 = v24;
        _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_38:

      free(v24);
    }
  }
LABEL_65:
  if (v19)
    free(v19);
  v16 = 0;
LABEL_18:

  return v16;
}

void sub_1831C8EA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_endpoint_enumerate_edges(void *a1, uint64_t a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  id v8;
  unsigned __int8 *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _QWORD v18[4];
  id v19;
  id v20;
  uint64_t v21;
  _QWORD v22[4];
  id v23;
  _BYTE *v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  id v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  if (v6)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v28 = __Block_byref_object_copy__6403;
    v29 = __Block_byref_object_dispose__6404;
    v7 = MEMORY[0x1E0C809B0];
    v30 = 0;
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = __nw_endpoint_enumerate_edges_block_invoke;
    v22[3] = &unk_1E14ACE40;
    v24 = buf;
    v8 = v5;
    v23 = v8;
    nw_endpoint_locked(v8, v22);
    v9 = *(unsigned __int8 **)(*(_QWORD *)&buf[8] + 40);
    if (v9)
    {
      v18[0] = v7;
      v18[1] = 3221225472;
      v18[2] = __nw_endpoint_enumerate_edges_block_invoke_2;
      v18[3] = &unk_1E149B2B8;
      v19 = v8;
      v21 = a2;
      v20 = v6;
      nw_array_apply(v9, (uint64_t)v18);

    }
    _Block_object_dispose(buf, 8);

    goto LABEL_5;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_endpoint_enumerate_edges";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v11, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null enumerator", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_enumerate_edges";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null enumerator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_enumerate_edges";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null enumerator, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v11)
    free(v11);
LABEL_5:

}

void sub_1831C9268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  void *v32;
  void *v33;

  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

_BYTE *nw_protocol_instance_registrar_copy_next_registered_endpoint(void *a1, int a2)
{
  _BYTE *v3;
  _BYTE *v4;
  char v5;
  _BYTE *v6;
  int v7;
  id *v8;
  id v9;
  id v10;
  int v11;
  _BYTE *v12;
  char v13;
  id v14;
  _BYTE *v15;
  NSObject *v16;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  void *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  NSObject *v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  __int16 v41;
  id *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_endpoint_is_registered";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v19, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        v24 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            v38 = "nw_endpoint_is_registered";
            v39 = 2082;
            v40 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_37;
        }
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_is_registered";
          _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_37:
    if (v19)
      free(v19);
LABEL_39:
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
    v27 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s finding the next endpoint requires a registered endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        v30 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        v32 = os_log_type_enabled(v28, type);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
            v39 = 2082;
            v40 = v30;
            _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s finding the next endpoint requires a registered endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v30);
          goto LABEL_55;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s finding the next endpoint requires a registered endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          _os_log_impl(&dword_182FBE000, v28, v33, "%{public}s finding the next endpoint requires a registered endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_55:
    if (v27)
      free(v27);
LABEL_15:
    v12 = 0;
    goto LABEL_16;
  }
  v5 = v3[231];

  if ((v5 & 4) == 0)
    goto LABEL_39;
  v6 = v4;
  v7 = objc_msgSend(v6, "type");

  if (v7 != 1 || (v4[231] & 2) != 0)
    goto LABEL_14;
  v8 = v6;
  v9 = v8[14];

  if (!v9 || (v10 = v9, v11 = objc_msgSend(v10, "type"), v10, v11 != 2))
  {

    goto LABEL_14;
  }
  v12 = v10;
  v13 = v12[231];

  if ((v13 & 4) == 0)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
        v39 = 2112;
        v40 = v12;
        _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s next endpoint %@ is not registered, fetching registered copy", buf, 0x16u);
      }

    }
    v14 = v8[1];
    v15 = nw_context_copy_registered_endpoint_internal(v14, v12, a2);

    v12 = v15;
    if (!v15)
    {
LABEL_14:
      if (gLogDatapath)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
          v39 = 2112;
          v40 = v6;
          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s no next endpoint for endpoint %@", buf, 0x16u);
        }
        v12 = 0;
        goto LABEL_25;
      }
      goto LABEL_15;
    }
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v38 = "nw_protocol_instance_registrar_copy_next_registered_endpoint";
      v39 = 2112;
      v40 = v12;
      v41 = 2112;
      v42 = v8;
      _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s found next endpoint %@ for endpoint %@", buf, 0x20u);
    }
LABEL_25:

  }
LABEL_16:

  return v12;
}

void sub_1831C9940(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_registrar_get_instance_count(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void (**v3)(_QWORD);
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  os_unfair_lock_s *v15;
  _BYTE *v16;
  char v17;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v20 = 0;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_instance_registrar_get_instance_count_block_invoke;
    aBlock[3] = &unk_1E14ACE40;
    v16 = buf;
    v15 = v1;
    v3 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 2);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 2);

    v4 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_get_instance_count";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null registrar", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_get_instance_count";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null registrar, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null registrar, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null registrar, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_3:

  return v4;
}

void sub_1831C9CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_instance_registrar_get_instance_count_block_invoke(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(result + 32) + 64);
  return result;
}

void nw_protocol_instance_registrar_remove_instance(void *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  void (**v4)(_QWORD);
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  NSObject *v11;
  uint64_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD aBlock[4];
  os_unfair_lock_s *v22;
  uint64_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  void *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_instance_registrar_remove_instance";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_protocol_instance_registrar_remove_instance";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v6)
          goto LABEL_5;
LABEL_43:
        free(v6);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_instance_registrar_remove_instance";
        _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v12 = *(_QWORD *)(a2 + 16);
        *(_DWORD *)buf = 136446978;
        v27 = "nw_protocol_instance_registrar_remove_instance";
        v28 = 2112;
        v29 = v3;
        v30 = 2048;
        v31 = a2;
        v32 = 2080;
        v33 = v12;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %@ checking to remove instance %p of %s", buf, 0x2Au);
      }

    }
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_instance_registrar_remove_instance_block_invoke;
    aBlock[3] = &unk_1E14AA348;
    v22 = v3;
    v23 = a2;
    v4 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 2);
    v4[2](v4);
    os_unfair_lock_unlock(v3 + 2);

    goto LABEL_5;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_protocol_instance_registrar_remove_instance";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v6, &type, &v24))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_instance_registrar_remove_instance";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protocol->identifier", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v24)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_instance_registrar_remove_instance";
      _os_log_impl(&dword_182FBE000, v7, v20, "%{public}s called with null protocol->identifier, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v7, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_instance_registrar_remove_instance";
      _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null protocol->identifier, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_protocol_instance_registrar_remove_instance";
    v28 = 2082;
    v29 = v16;
    _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v6)
    goto LABEL_43;
LABEL_5:

}

void sub_1831CA28C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void nw_protocol_identifier_copy(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  void *v9;
  char *v10;
  _BOOL4 v11;
  char *backtrace_string;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      v2 = *a2;
      v3 = a2[1];
      *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
      *(_OWORD *)a1 = v2;
      *(_OWORD *)(a1 + 16) = v3;
      return;
    }
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_identifier_copy";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_protocol_identifier_copy";
          v8 = "%{public}s called with null source";
          goto LABEL_32;
        }
      }
      else
      {
        if (v14)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v6 = objc_claimAutoreleasedReturnValue();
          v7 = type;
          v13 = os_log_type_enabled(v6, type);
          if (backtrace_string)
          {
            if (v13)
            {
              *(_DWORD *)buf = 136446466;
              v17 = "nw_protocol_identifier_copy";
              v18 = 2082;
              v19 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (v5)
              goto LABEL_35;
            return;
          }
          if (!v13)
            goto LABEL_33;
          *(_DWORD *)buf = 136446210;
          v17 = "nw_protocol_identifier_copy";
          v8 = "%{public}s called with null source, no backtrace";
          goto LABEL_32;
        }
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_protocol_identifier_copy";
          v8 = "%{public}s called with null source, backtrace limit exceeded";
          goto LABEL_32;
        }
      }
      goto LABEL_33;
    }
  }
  else
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_identifier_copy";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_identifier_copy";
        v8 = "%{public}s called with null destination";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
LABEL_33:

      goto LABEL_34;
    }
    if (!v14)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_identifier_copy";
        v8 = "%{public}s called with null destination, backtrace limit exceeded";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    v10 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v7 = type;
    v11 = os_log_type_enabled(v6, type);
    if (!v10)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_identifier_copy";
        v8 = "%{public}s called with null destination, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_identifier_copy";
      v18 = 2082;
      v19 = v10;
      _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null destination, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v10);
  }
LABEL_34:
  if (v5)
LABEL_35:
    free(v5);
}

void __nw_protocol_instance_registrar_remove_instance_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  _BYTE *v3;
  pthread_once_t *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  const char *backtrace_string;
  pthread_once_t *v20;
  char *v21;
  pthread_once_t *v22;
  NSObject *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  uint64_t v26;
  os_log_type_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 16);
  if (v1)
  {
    v3 = &unk_1ECD84000;
    v4 = &nwlog_legacy_init(void)::init_once;
    while (1)
    {
      v5 = (_QWORD *)*v1;
      if (v1[2] != *(_QWORD *)(a1 + 40))
        goto LABEL_5;
      if (v3[1345])
      {
        __nwlog_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v31 = *(const char **)(a1 + 32);
          v32 = *(_QWORD *)(a1 + 40);
          v33 = *(_QWORD *)(v32 + 16);
          *(_DWORD *)buf = 136446978;
          v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
          v38 = 2112;
          v39 = v31;
          v40 = 2048;
          v41 = v32;
          v42 = 2080;
          v43 = v33;
          _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %@ found instance %p of %s, removing", buf, 0x2Au);
        }

      }
      v6 = (void *)v1[3];
      v1[3] = 0;

      v7 = (_QWORD *)*v1;
      if (*v1)
        v7[1] = v1[1];
      *(_QWORD *)v1[1] = v7;
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(v8 + 64);
      *(_QWORD *)(v8 + 64) = v9 - 1;
      if (!v9)
        break;
LABEL_4:
      free(v1);
LABEL_5:
      v1 = v5;
      if (!v5)
        return;
    }
    pthread_once(v4, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
    *(_DWORD *)buf = 136446978;
    v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
    v38 = 2082;
    v39 = "registrar->instance_count";
    v40 = 2048;
    v41 = 1;
    v42 = 2048;
    v43 = v11;
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v12, &type, &v34))
    {
LABEL_24:
      if (!v12)
        goto LABEL_3;
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(v4, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v14 = type;
      if (!os_log_type_enabled(v13, type))
      {
LABEL_23:

        goto LABEL_24;
      }
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
      *(_DWORD *)buf = 136446978;
      v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
      v38 = 2082;
      v39 = "registrar->instance_count";
      v40 = 2048;
      v41 = 1;
      v42 = 2048;
      v43 = v15;
      v16 = v13;
      v17 = v14;
      v18 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
    }
    else
    {
      if (v34)
      {
        backtrace_string = __nw_create_backtrace_string();
        v20 = v4;
        v21 = (char *)backtrace_string;
        v22 = v20;
        pthread_once(v20, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v24 = type;
        v25 = os_log_type_enabled(v23, type);
        if (v21)
        {
          if (v25)
          {
            v26 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
            *(_DWORD *)buf = 136447234;
            v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
            v38 = 2082;
            v39 = "registrar->instance_count";
            v40 = 2048;
            v41 = 1;
            v42 = 2048;
            v43 = v26;
            v44 = 2082;
            v45 = v21;
            _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(v21);
        }
        else
        {
          if (v25)
          {
            v29 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
            *(_DWORD *)buf = 136446978;
            v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
            v38 = 2082;
            v39 = "registrar->instance_count";
            v40 = 2048;
            v41 = 1;
            v42 = 2048;
            v43 = v29;
            _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace", buf, 0x2Au);
          }

        }
        v4 = v22;
        v3 = (_BYTE *)&unk_1ECD84000;
        if (!v12)
          goto LABEL_3;
LABEL_30:
        free(v12);
LABEL_3:
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) = 0;
        goto LABEL_4;
      }
      pthread_once(v4, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v27 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_23;
      v28 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
      *(_DWORD *)buf = 136446978;
      v37 = "nw_protocol_instance_registrar_remove_instance_block_invoke";
      v38 = 2082;
      v39 = "registrar->instance_count";
      v40 = 2048;
      v41 = 1;
      v42 = 2048;
      v43 = v28;
      v16 = v13;
      v17 = v27;
      v18 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0x2Au);
    goto LABEL_23;
  }
}

id nw_quic_connection_get_tls_state(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_tls_state_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_tls_state";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_tls_state";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_tls_state";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_tls_state";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_tls_state";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831CAEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

id nw_quic_connection_get_quic_state(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_quic_state_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_quic_state";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_quic_state";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_quic_state";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_quic_state";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_quic_state";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831CB240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

void ___ZL15nw_channel_initv_block_invoke()
{
  g_channel_check_validity = (uint64_t (*)(_QWORD, _QWORD))nw_channel_frame_check_validity;
  g_channel_reclassifier = nw_channel_reclassify_input;
  g_channel_set_flow_handler = nw_channel_set_flow_handler;
  g_channel_get_flow_handler = nw_channel_get_flow_handler;
  g_channel_set_internet_checksum_handler = nw_channel_set_internet_checksum_handler;
  g_channel_get_internet_checksum_handler = nw_channel_get_internet_checksum_handler;
  g_channel_protocol_callbacks = (uint64_t)nw_channel_add_input_handler;
  *(_QWORD *)algn_1ECD84BB8 = nw_channel_remove_input_handler;
  qword_1ECD84C00 = (uint64_t)nw_channel_get_input_frames;
  unk_1ECD84C08 = nw_channel_get_output_frames;
  qword_1ECD84C10 = (uint64_t)nw_channel_finalize_output_frames;
  qword_1ECD84BC0 = (uint64_t)nw_channel_replace_input_handler;
  unk_1ECD84BC8 = nw_channel_connect;
  qword_1ECD84BD0 = (uint64_t)nw_channel_disconnect;
  qword_1ECD84C58 = (uint64_t)nw_channel_updated_path;
  qword_1ECD84C70 = (uint64_t)nw_channel_output_finished;
  qword_1ECD84CA8 = (uint64_t)nw_channel_get_message_properties;
}

uint64_t __nwlog_get_private_redacted_block_invoke()
{
  char *v0;
  char *v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t result;
  NSObject *v12;
  void *v13;
  char __s1;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  char v23;
  char __s2[16];
  int v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  strcpy(__s2, "not redacted");
  __s1 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = 136380675;
  v26 = __s2;
  v0 = (char *)_os_log_send_and_compose_impl();
  if (v0 == &__s1)
  {
LABEL_14:
    result = strncmp(&__s1, __s2, 0xDuLL);
    nwlog_get_private_redacted::privateRedacted = (_DWORD)result != 0;
    return result;
  }
  v1 = v0;
  if (v0)
  {
LABEL_3:
    v2 = __s1;
    *v1 = __s1;
    if (v2)
    {
      v3 = v15;
      v1[1] = v15;
      if (v3)
      {
        v4 = v16;
        v1[2] = v16;
        if (v4)
        {
          v5 = v17;
          v1[3] = v17;
          if (v5)
          {
            v6 = v18;
            v1[4] = v18;
            if (v6)
            {
              v7 = v19;
              v1[5] = v19;
              if (v7)
              {
                v8 = v20;
                v1[6] = v20;
                if (v8)
                {
                  v9 = v21;
                  v1[7] = v21;
                  if (v9)
                  {
                    v10 = v22;
                    v1[8] = v22;
                    if (v10)
                      v1[9] = v23;
                  }
                }
              }
            }
          }
        }
      }
    }
    free(v1);
    goto LABEL_14;
  }
  v12 = __nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  v25 = 136446210;
  v26 = "_strict_strlcpy";
  v13 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v13);
  if (!(_DWORD)result)
  {
    free(v13);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void nw_quic_connection_close_with_error(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_close_with_error_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_close_with_error";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_close_with_error";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_close_with_error";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_close_with_error";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_close_with_error";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1831CB830(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_close_with_error_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 208));
  v5 = *(_QWORD *)(a2 + 144);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

BOOL nw_resolver_config_get_allow_failover(void *a1)
{
  id v1;
  void *v2;
  os_unfair_lock_s *v3;
  _BOOL8 v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[4];
  os_unfair_lock_s *v15;
  _BYTE *v16;
  char v17;
  os_log_type_t type;
  _BYTE buf[24];
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v20 = 0;
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_get_allow_failover_block_invoke;
    v14[3] = &unk_1E14ACE40;
    v16 = buf;
    v15 = (os_unfair_lock_s *)v1;
    v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_allow_failover_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    v4 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_resolver_config_get_allow_failover";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_resolver_config_get_allow_failover";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_resolver_config_get_allow_failover";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_resolver_config_get_allow_failover";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_resolver_config_get_allow_failover";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_3:

  return v4;
}

void sub_1831CBBB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_allow_failover_block_invoke(uint64_t a1)
{
  id v2;

  v2 = *(id *)(*(_QWORD *)(a1 + 32) + 8);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = xpc_dictionary_get_BOOL(v2, "AllowFailover");

}

void sub_1831CBC30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_pmtud_ignore_cost(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_pmtud_ignore_cost_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_ignore_cost";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_ignore_cost";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_ignore_cost";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_ignore_cost";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_ignore_cost";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831CBF44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_pmtud(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_pmtud_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831CC270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_flow_listener_disconnected(nw_listen_protocol *a1, nw_protocol *a2)
{
  id v4;
  void *v5;
  unsigned int *v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = *((id *)a1->handle + 20);
  v5 = v4;
  if (v4)
  {
    v6 = (unsigned int *)v4;
    v7 = v6[29];

    if ((_DWORD)v7 == 2)
    {
      ((void (*)(nw_protocol *, nw_listen_protocol *))a2->callbacks->remove_listen_handler)(a2, a1);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (v7 > 5)
          v9 = "unknown-mode";
        else
          v9 = off_1E149FC18[v7];
        v10 = 136446722;
        v11 = "nw_flow_listener_disconnected";
        v12 = 2082;
        v13 = v9;
        v14 = 2082;
        v15 = "flow";
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", (uint8_t *)&v10, 0x20u);
      }

    }
  }

}

void sub_1831CC3F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_instance_report_done(void *a1, unint64_t a2, void *a3)
{
  char *v5;
  id v6;
  void *v7;
  dispatch_queue_t *v8;
  dispatch_queue_t *v9;
  uint64_t v10;
  void (*v11)(void);
  char *v12;
  const char *v13;
  uint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  void *v17;
  char v18;
  uint64_t node;
  const char *v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  void *v24;
  char v25;
  NSObject *v26;
  NSObject *v27;
  uint64_t v28;
  void *v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(const char *, char *, uint64_t);
  _QWORD *v34;
  uint64_t v35;
  void (*v36)(_QWORD *, char *);
  void *v37;
  char v38;
  uint64_t v39;
  void *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(const char *, char *, uint64_t);
  uint64_t v49;
  void (*v50)(const char *);
  void *v51;
  char v52;
  uint64_t v53;
  void *v54;
  char v55;
  uint64_t v56;
  void *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  NSObject *v61;
  void *v62;
  os_log_type_t v63;
  char *backtrace_string;
  os_log_type_t v65;
  _BOOL4 v66;
  void *v67;
  const char *v68;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  char *v73;
  os_log_type_t v74;
  _BOOL4 v75;
  char *v76;
  os_log_type_t v77;
  _BOOL4 v78;
  const char *v79;
  os_log_type_t v80;
  os_log_type_t v81;
  void *v82;
  const char *v83;
  char *v84;
  NSObject *v85;
  os_log_type_t v86;
  const char *v87;
  os_log_type_t v88;
  const char *v89;
  const char *v90;
  char *v91;
  os_log_type_t v92;
  _BOOL4 v93;
  const char *v94;
  os_log_type_t v95;
  const char *v96;
  const char *v97;
  _QWORD v98[4];
  id v99;
  char *v100;
  char v101;
  os_log_type_t v102;
  char *v103;
  char v104;
  os_log_type_t type[8];
  char v106;
  _BYTE buf[12];
  __int16 v108;
  char *v109;
  __int16 v110;
  const char *v111;
  __int16 v112;
  unint64_t v113;
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  if (!v5)
  {
    __nwlog_obj();
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
    v58 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (!__nwlog_fault(v58, type, &v103))
      goto LABEL_171;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v60 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if ((_BYTE)v103)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v65 = type[0];
      v66 = os_log_type_enabled(v59, type[0]);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
          v108 = 2082;
          v109 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v59, v65, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_171:
        if (!v58)
          goto LABEL_104;
        goto LABEL_172;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_182FBE000, v59, v65, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v80 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_182FBE000, v59, v80, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_170:

    goto LABEL_171;
  }
  v7 = (void *)*((_QWORD *)v5 + 15);
  if (v7)
  {
    v8 = v7;
    v9 = v8;
    if (((_BYTE)v8[17] & 8) == 0)
      dispatch_assert_queue_V2(v8[1]);

  }
  if ((v5[405] & 0x80000000) == 0 && gLogDatapath)
  {
    __nwlog_obj();
    v61 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
      v108 = 2082;
      v109 = v5 + 407;
      v110 = 2080;
      v111 = " ";
      v112 = 2048;
      v113 = a2;
      _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sReporting flow %llx done", buf, 0x2Au);
    }

  }
  if (*(_DWORD *)(*((_QWORD *)v5 + 1) + 64) != 3)
  {
    if (a2 == -1)
    {
      if (!v6)
        goto LABEL_52;
      v13 = (const char *)*((_QWORD *)v5 - 6);
      if (!v13)
        goto LABEL_52;
      v14 = *((_QWORD *)v13 + 3);
      if (!v14 || !*(_QWORD *)(v14 + 56))
        goto LABEL_52;
      v15 = (unsigned int *)v6;
      v16 = v15[3];

      v17 = (void *)*((_QWORD *)v13 + 5);
      if (v17 == &nw_protocol_ref_counted_handle)
      {
        v28 = *((_QWORD *)v13 + 11);
        if (v28)
          *((_QWORD *)v13 + 11) = v28 + 1;
        v18 = -1;
      }
      else
      {
        v18 = 0;
      }
      *(_QWORD *)type = v13;
      v106 = v18;
      v29 = (void *)*((_QWORD *)v5 - 7);
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        v31 = *((_QWORD *)v5 - 1);
        if (v31)
          *((_QWORD *)v5 - 1) = v31 + 1;
        v30 = -1;
      }
      else
      {
        v30 = 0;
      }
      v103 = v5 - 96;
      v104 = v30;
      v32 = *((_QWORD *)v13 + 3);
      if (v32)
      {
        v33 = *(void (**)(const char *, char *, uint64_t))(v32 + 56);
        if (v33)
        {
          v33(v13, v5 - 96, v16);
LABEL_50:
          if (v29 != &nw_protocol_ref_counted_handle)
          {
            if (v17 != &nw_protocol_ref_counted_handle)
              goto LABEL_52;
LABEL_71:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            v34 = (_QWORD *)*((_QWORD *)v5 - 6);
            if (!v34)
              goto LABEL_104;
LABEL_53:
            v35 = v34[3];
            if (!v35)
              goto LABEL_104;
            v36 = *(void (**)(_QWORD *, char *))(v35 + 48);
            if (!v36)
              goto LABEL_104;
            v37 = (void *)v34[5];
            if (v37 == &nw_protocol_ref_counted_handle)
            {
              v39 = v34[11];
              if (v39)
                v34[11] = v39 + 1;
              v38 = -1;
            }
            else
            {
              v38 = 0;
            }
            *(_QWORD *)buf = v34;
            buf[8] = v38;
            v40 = (void *)*((_QWORD *)v5 - 7);
            if (v40 == &nw_protocol_ref_counted_handle)
            {
              v42 = *((_QWORD *)v5 - 1);
              if (v42)
                *((_QWORD *)v5 - 1) = v42 + 1;
              v41 = -1;
            }
            else
            {
              v41 = 0;
            }
            *(_QWORD *)type = v5 - 96;
            v106 = v41;
            v36(v34, v5 - 96);
            if (v40 == &nw_protocol_ref_counted_handle)
            {
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              if (v37 != &nw_protocol_ref_counted_handle)
                goto LABEL_104;
            }
            else if (v37 != &nw_protocol_ref_counted_handle)
            {
              goto LABEL_104;
            }
LABEL_103:
            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
            goto LABEL_104;
          }
          nw::release_if_needed<nw_protocol *>((uint64_t *)&v103);
          if (v17 == &nw_protocol_ref_counted_handle)
            goto LABEL_71;
LABEL_52:
          v34 = (_QWORD *)*((_QWORD *)v5 - 6);
          if (!v34)
            goto LABEL_104;
          goto LABEL_53;
        }
      }
      __nwlog_obj();
      v67 = (void *)objc_claimAutoreleasedReturnValue();
      v68 = (const char *)*((_QWORD *)v13 + 2);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_error";
      if (!v68)
        v68 = "invalid";
      v108 = 2082;
      v109 = (char *)v68;
      v110 = 2048;
      v111 = v13;
      v69 = (char *)_os_log_send_and_compose_impl();

      v102 = OS_LOG_TYPE_ERROR;
      v101 = 0;
      if (__nwlog_fault(v69, &v102, &v101))
      {
        if (v102 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v70 = objc_claimAutoreleasedReturnValue();
          v71 = v102;
          if (os_log_type_enabled(v70, v102))
          {
            v72 = (const char *)*((_QWORD *)v13 + 2);
            if (!v72)
              v72 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_error";
            v108 = 2082;
            v109 = (char *)v72;
            v110 = 2048;
            v111 = v13;
            _os_log_impl(&dword_182FBE000, v70, v71, "%{public}s protocol %{public}s (%p) has invalid error callback", buf, 0x20u);
          }
        }
        else if (v101)
        {
          v76 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v70 = objc_claimAutoreleasedReturnValue();
          v77 = v102;
          v78 = os_log_type_enabled(v70, v102);
          if (v76)
          {
            if (v78)
            {
              v79 = (const char *)*((_QWORD *)v13 + 2);
              if (!v79)
                v79 = "invalid";
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "__nw_protocol_error";
              v108 = 2082;
              v109 = (char *)v79;
              v110 = 2048;
              v111 = v13;
              v112 = 2082;
              v113 = (unint64_t)v76;
              _os_log_impl(&dword_182FBE000, v70, v77, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v76);
            goto LABEL_178;
          }
          if (v78)
          {
            v90 = (const char *)*((_QWORD *)v13 + 2);
            if (!v90)
              v90 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_error";
            v108 = 2082;
            v109 = (char *)v90;
            v110 = 2048;
            v111 = v13;
            _os_log_impl(&dword_182FBE000, v70, v77, "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          __nwlog_obj();
          v70 = objc_claimAutoreleasedReturnValue();
          v88 = v102;
          if (os_log_type_enabled(v70, v102))
          {
            v89 = (const char *)*((_QWORD *)v13 + 2);
            if (!v89)
              v89 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_error";
            v108 = 2082;
            v109 = (char *)v89;
            v110 = 2048;
            v111 = v13;
            _os_log_impl(&dword_182FBE000, v70, v88, "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded", buf, 0x20u);
          }
        }

      }
LABEL_178:
      if (v69)
        free(v69);
      goto LABEL_50;
    }
    __nwlog_obj();
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
    v58 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (!__nwlog_fault(v58, type, &v103))
      goto LABEL_171;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v63 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_182FBE000, v59, v63, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW)", buf, 0xCu);
      }
    }
    else if ((_BYTE)v103)
    {
      v73 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v74 = type[0];
      v75 = os_log_type_enabled(v59, type[0]);
      if (v73)
      {
        if (v75)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
          v108 = 2082;
          v109 = v73;
          _os_log_impl(&dword_182FBE000, v59, v74, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v73);
        if (!v58)
          goto LABEL_104;
LABEL_172:
        free(v58);
        goto LABEL_104;
      }
      if (v75)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_182FBE000, v59, v74, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v81 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl(&dword_182FBE000, v59, v81, "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_170;
  }
  if (a2 >= 0xFFFFFFFFFFFFFFFELL)
  {
    if ((v5[405] & 0x40) != 0)
    {
      if ((v5[405] & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = (id)gLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
          v108 = 2082;
          v109 = v5 + 407;
          v110 = 2080;
          v111 = " ";
          _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%salready in report done, skipping", buf, 0x20u);
        }

      }
    }
    else
    {
      v5[405] |= 0x40u;
      v5[404] |= 4u;
      nw_protocol_remove_instance((uint64_t)(v5 - 96));
      v10 = *((_QWORD *)v5 + 3);
      if (v10)
      {
        if (*(_QWORD *)v10)
        {
          v11 = *(void (**)(void))(*(_QWORD *)v10 + 8);
          if (v11)
            v11();
        }
        *((_QWORD *)v5 + 3) = 0;
      }
      v12 = (char *)*((_QWORD *)v5 + 29);
      v98[0] = MEMORY[0x1E0C809B0];
      v98[1] = 3221225472;
      v98[2] = __nw_protocol_instance_report_done_block_invoke;
      v98[3] = &unk_1E149B8F0;
      v99 = v6;
      v100 = v5;
      nw_hash_table_apply(v12, (uint64_t)v98);
      v5[405] &= ~0x40u;

    }
    goto LABEL_104;
  }
  node = nw_hash_table_get_node(*((_QWORD *)v5 + 29), a2, 8);
  if (!node)
  {
    if ((v5[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_report_done";
        v108 = 2082;
        v109 = v5 + 407;
        v110 = 2080;
        v111 = " ";
        v112 = 2048;
        v113 = a2;
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCannot report done, flow %llx does not exist", buf, 0x2Au);
      }

    }
    goto LABEL_104;
  }
  *(_WORD *)(node + 84) |= 0x200u;
  v20 = *(const char **)(node + 16);
  if (!v20)
    goto LABEL_104;
  if (!v6)
    goto LABEL_88;
  v21 = *((_QWORD *)v20 + 3);
  if (!v21 || !*(_QWORD *)(v21 + 56))
    goto LABEL_88;
  v22 = (unsigned int *)v6;
  v23 = v22[3];

  v24 = (void *)*((_QWORD *)v20 + 5);
  if (v24 == &nw_protocol_ref_counted_handle)
  {
    v43 = *((_QWORD *)v20 + 11);
    if (v43)
      *((_QWORD *)v20 + 11) = v43 + 1;
    v25 = -1;
  }
  else
  {
    v25 = 0;
  }
  *(_QWORD *)type = v20;
  v106 = v25;
  v44 = (void *)*((_QWORD *)v5 - 7);
  if (v44 == &nw_protocol_ref_counted_handle)
  {
    v46 = *((_QWORD *)v5 - 1);
    if (v46)
      *((_QWORD *)v5 - 1) = v46 + 1;
    v45 = -1;
  }
  else
  {
    v45 = 0;
  }
  v103 = v5 - 96;
  v104 = v45;
  v47 = *((_QWORD *)v20 + 3);
  if (!v47 || (v48 = *(void (**)(const char *, char *, uint64_t))(v47 + 56)) == 0)
  {
    __nwlog_obj();
    v82 = (void *)objc_claimAutoreleasedReturnValue();
    v83 = (const char *)*((_QWORD *)v20 + 2);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "__nw_protocol_error";
    if (!v83)
      v83 = "invalid";
    v108 = 2082;
    v109 = (char *)v83;
    v110 = 2048;
    v111 = v20;
    v84 = (char *)_os_log_send_and_compose_impl();

    v102 = OS_LOG_TYPE_ERROR;
    v101 = 0;
    if (!__nwlog_fault(v84, &v102, &v101))
      goto LABEL_197;
    if (v102 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v85 = objc_claimAutoreleasedReturnValue();
      v86 = v102;
      if (os_log_type_enabled(v85, v102))
      {
        v87 = (const char *)*((_QWORD *)v20 + 2);
        if (!v87)
          v87 = "invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_error";
        v108 = 2082;
        v109 = (char *)v87;
        v110 = 2048;
        v111 = v20;
        _os_log_impl(&dword_182FBE000, v85, v86, "%{public}s protocol %{public}s (%p) has invalid error callback", buf, 0x20u);
      }
    }
    else if (v101)
    {
      v91 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v85 = objc_claimAutoreleasedReturnValue();
      v92 = v102;
      v93 = os_log_type_enabled(v85, v102);
      if (v91)
      {
        if (v93)
        {
          v94 = (const char *)*((_QWORD *)v20 + 2);
          if (!v94)
            v94 = "invalid";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_error";
          v108 = 2082;
          v109 = (char *)v94;
          v110 = 2048;
          v111 = v20;
          v112 = 2082;
          v113 = (unint64_t)v91;
          _os_log_impl(&dword_182FBE000, v85, v92, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v91);
        goto LABEL_197;
      }
      if (v93)
      {
        v97 = (const char *)*((_QWORD *)v20 + 2);
        if (!v97)
          v97 = "invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_error";
        v108 = 2082;
        v109 = (char *)v97;
        v110 = 2048;
        v111 = v20;
        _os_log_impl(&dword_182FBE000, v85, v92, "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v85 = objc_claimAutoreleasedReturnValue();
      v95 = v102;
      if (os_log_type_enabled(v85, v102))
      {
        v96 = (const char *)*((_QWORD *)v20 + 2);
        if (!v96)
          v96 = "invalid";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_error";
        v108 = 2082;
        v109 = (char *)v96;
        v110 = 2048;
        v111 = v20;
        _os_log_impl(&dword_182FBE000, v85, v95, "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded", buf, 0x20u);
      }
    }

LABEL_197:
    if (v84)
      free(v84);
    goto LABEL_84;
  }
  v48(v20, v5 - 96, v23);
LABEL_84:
  if (v44 == &nw_protocol_ref_counted_handle)
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v103);
  if (v24 == &nw_protocol_ref_counted_handle)
    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
LABEL_88:
  v49 = *((_QWORD *)v20 + 3);
  if (v49)
  {
    v50 = *(void (**)(const char *))(v49 + 48);
    if (v50)
    {
      v51 = (void *)*((_QWORD *)v20 + 5);
      if (v51 == &nw_protocol_ref_counted_handle)
      {
        v53 = *((_QWORD *)v20 + 11);
        if (v53)
          *((_QWORD *)v20 + 11) = v53 + 1;
        v52 = -1;
      }
      else
      {
        v52 = 0;
      }
      *(_QWORD *)buf = v20;
      buf[8] = v52;
      v54 = (void *)*((_QWORD *)v5 - 7);
      if (v54 == &nw_protocol_ref_counted_handle)
      {
        v56 = *((_QWORD *)v5 - 1);
        if (v56)
          *((_QWORD *)v5 - 1) = v56 + 1;
        v55 = -1;
      }
      else
      {
        v55 = 0;
      }
      *(_QWORD *)type = v5 - 96;
      v106 = v55;
      v50(v20);
      if (v54 == &nw_protocol_ref_counted_handle)
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v51 == &nw_protocol_ref_counted_handle)
        goto LABEL_103;
    }
  }
LABEL_104:

}

void nw_protocol_remove_instance(uint64_t a1)
{
  _QWORD *v2;
  uint64_t *v3;
  uint64_t v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  NSObject *v13;
  uint64_t v14;
  char *backtrace_string;
  _BOOL4 v16;
  _QWORD v17[5];
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_remove_instance";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v9, &type, &v18))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_remove_instance";
      v12 = "%{public}s called with null protocol";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_protocol_remove_instance";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_38;
      }
      if (!v16)
      {
LABEL_38:
        if (v9)
          free(v9);
        return;
      }
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_remove_instance";
      v12 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_remove_instance";
      v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
    goto LABEL_38;
  }
  nw_allow_use_of_dispatch_internal();
  if (gLogDatapath)
  {
    v13 = __nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      v14 = *(_QWORD *)(a1 + 16);
      *(_DWORD *)buf = 136446722;
      v21 = "nw_protocol_remove_instance";
      v22 = 2048;
      v23 = (char *)a1;
      v24 = 2080;
      v25 = v14;
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s checking to remove instance %p of %s", buf, 0x20u);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  v2 = *(_QWORD **)(a1 + 16);
  v3 = &g_registration_list;
  while (1)
  {
    v3 = (uint64_t *)*v3;
    if (!v3)
      break;
    if (*v2 == v3[4] && v2[1] == v3[5] && v2[2] == v3[6] && v2[3] == v3[7] && v2[4] == v3[8])
    {
      v8 = v3[9];
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 0x40000000;
      v17[2] = __nw_protocol_remove_instance_block_invoke;
      v17[3] = &__block_descriptor_tmp_43676;
      v17[4] = a1;
      nw_array_remove_objects(v8, (uint64_t)v17);
      break;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
}

void nw_array_remove_objects(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v4;
  void **v5;
  void **v6;
  void **i;
  void **v8;
  void **v9;
  void *v10;
  void *v11;
  int v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  NSObject *v17;
  NSObject *v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  int v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v24 = 136446210;
    *(_DWORD *)buf = 136446210;
    v5 = (void **)"nw_array_remove_objects";
    v28 = "nw_array_remove_objects";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v13, &type, &v25))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_array_remove_objects";
      v16 = "%{public}s called with null array";
      goto LABEL_60;
    }
LABEL_41:
    if (!v25)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_61;
      *(_DWORD *)buf = v24;
      v28 = (const char *)v5;
      v16 = "%{public}s called with null array, backtrace limit exceeded";
      goto LABEL_60;
    }
    v19 = (const char *)v5;
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v21 = os_log_type_enabled(v14, type);
    if (backtrace_string)
    {
      if (!v21)
        goto LABEL_50;
      *(_DWORD *)buf = 136446466;
      v28 = v19;
      v29 = 2082;
      v30 = backtrace_string;
      v22 = "%{public}s called with null array, dumping backtrace:%{public}s";
      goto LABEL_49;
    }
    if (v21)
    {
      *(_DWORD *)buf = v24;
      v28 = v19;
      v16 = "%{public}s called with null array, no backtrace";
LABEL_60:
      _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
      goto LABEL_61;
    }
    goto LABEL_61;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_array_remove_objects";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v13, &type, &v25))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_array_remove_objects";
      v16 = "%{public}s called with null remove_block";
      goto LABEL_60;
    }
    if (!v25)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_array_remove_objects";
      v16 = "%{public}s called with null remove_block, backtrace limit exceeded";
      goto LABEL_60;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v23 = os_log_type_enabled(v14, type);
    if (backtrace_string)
    {
      if (!v23)
        goto LABEL_50;
      *(_DWORD *)buf = 136446466;
      v28 = "nw_array_remove_objects";
      v29 = 2082;
      v30 = backtrace_string;
      v22 = "%{public}s called with null remove_block, dumping backtrace:%{public}s";
LABEL_49:
      _os_log_impl(&dword_182FBE000, v14, v15, v22, buf, 0x16u);
LABEL_50:
      free(backtrace_string);
      if (!v13)
        return;
LABEL_62:
      free(v13);
      return;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_array_remove_objects";
      v16 = "%{public}s called with null remove_block, no backtrace";
      goto LABEL_60;
    }
LABEL_61:
    if (!v13)
      return;
    goto LABEL_62;
  }
  v4 = (unsigned __int8 *)(a1 + 40);
  do
    v5 = (void **)__ldxr(v4);
  while (__stxr(0xFFu, v4));
  if ((_DWORD)v5)
  {
    v17 = __nwlog_obj();
    os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v28 = "nw_array_remove_objects";
    v13 = (char *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v13))
    {
      free(v13);
      do
        __ldxr(v4);
      while (__stlxr(v5, v4));
      return;
    }
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  v5 = *(void ***)(a1 + 16);
  v6 = *(void ***)(a1 + 24);
  if (v5 != v6)
  {
    while (((*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, *v5) & 1) == 0)
    {
      if (++v5 == v6)
      {
        v5 = v6;
        goto LABEL_18;
      }
    }
    if (v5 != v6)
    {
      for (i = v5 + 1; i != v6; ++i)
      {
        if (((*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, *i) & 1) == 0)
        {
          if (*v5)
            os_release(*v5);
          *v5++ = *i;
          *i = 0;
        }
      }
    }
  }
LABEL_18:
  v8 = *(void ***)(a1 + 24);
  if (v5 != v8)
  {
    v9 = *(void ***)(a1 + 24);
    do
    {
      v11 = *--v9;
      v10 = v11;
      if (v11)
        os_release(v10);
      *(v8 - 1) = 0;
      v8 = v9;
    }
    while (v9 != v5);
    *(_QWORD *)(a1 + 24) = v5;
  }
  do
    v12 = __ldxr(v4);
  while (__stlxr(0, v4));
  if (v12 != 255)
  {
    v18 = __nwlog_obj();
    os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v28 = "nw_array_remove_objects";
    v13 = (char *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v13))
      goto LABEL_62;
    goto LABEL_40;
  }
}

void NWActivity.parentActivity.setter(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    nw_activity_set_parent_activity(*(void **)(v1 + 16), *(void **)(a1 + 16));
    swift_release();
  }
  else
  {
    nw_activity_set_parent_activity(*(void **)(v1 + 16), 0);
  }
}

void nw_activity_set_parent_activity(void *a1, void *a2)
{
  _BYTE *v3;
  id v4;
  void *v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_activity_set_parent_activity";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_activity_set_parent_activity";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v10)
          goto LABEL_8;
LABEL_59:
        free(v10);
        goto LABEL_8;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_57:

    goto LABEL_58;
  }
  if ((v3[132] & 4) != 0)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_activity_set_parent_activity";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v26, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_57;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, no backtrace", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_activity_set_parent_activity";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_38;
  }
  if ((v3[132] & 8) != 0)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_activity_set_parent_activity";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_57;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_activity_set_parent_activity";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", buf, 0xCu);
      }
      goto LABEL_57;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_activity_set_parent_activity";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_38:

    free(v20);
    if (!v10)
      goto LABEL_8;
    goto LABEL_59;
  }
  v6 = v4;
  v7 = (void *)*((_QWORD *)v3 + 7);
  if ((v3[64] & 1) != 0 && v7)
  {
    *((_QWORD *)v3 + 7) = 0;

    v7 = (void *)*((_QWORD *)v3 + 7);
  }
  *((_QWORD *)v3 + 7) = 0;

  v8 = (void *)*((_QWORD *)v3 + 7);
  *((_QWORD *)v3 + 7) = v6;

  v3[64] |= 1u;
LABEL_8:

}

BOOL sub_1831CE5DC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

void nw_activity_set_global_parent(void *a1)
{
  _BYTE *v1;
  void *v2;
  id v3;
  void *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  _QWORD aBlock[4];
  id v23;
  void *v24;
  char v25;
  os_log_type_t type;
  void *v27;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[132] & 8) != 0)
    {
      __nwlog_obj();
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v29 = "nw_activity_set_global_parent";
      v9 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v25 = 0;
      if (!__nwlog_fault(v9, &type, &v25))
        goto LABEL_53;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_activity_set_global_parent";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_activity_set_global_parent";
            v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_53:
          if (!v9)
            goto LABEL_19;
LABEL_54:
          free(v9);
          goto LABEL_19;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_activity_set_global_parent";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "nw_activity_set_global_parent";
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", buf, 0xCu);
        }
      }
LABEL_52:

      goto LABEL_53;
    }
    if (!global_parent || (nw_activity_is_equal(v1, (void *)global_parent) & 1) != 0)
    {
      aBlock[0] = MEMORY[0x1E0C809B0];
      aBlock[1] = 3221225472;
      aBlock[2] = __nw_activity_set_global_parent_block_invoke_56;
      aBlock[3] = &unk_1E14ACFD0;
      v3 = v2;
      v23 = v3;
      v4 = _Block_copy(aBlock);
      v24 = v4;
      nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>((os_unfair_lock_s *)&global_parent_lock, (uint64_t)&v24);

      if (__nwlog_activity_log::onceToken != -1)
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
      v5 = (id)gactivityLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        v29 = (const char *)v3;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEFAULT, "Set activity %{public}@ as the global parent.", buf, 0xCu);
      }

      goto LABEL_19;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    v29 = "nw_activity_set_global_parent";
    v30 = 2082;
    v31 = "Global parent activity is immutable and cannot be set to a different activity.";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v9, &type, &v25))
      goto LABEL_53;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_activity_set_global_parent";
        v30 = 2082;
        v31 = "Global parent activity is immutable and cannot be set to a different activity.";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
      goto LABEL_52;
    }
    if (!v25)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_activity_set_global_parent";
        v30 = 2082;
        v31 = "Global parent activity is immutable and cannot be set to a different activity.";
        _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_52;
    }
    v17 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    v19 = os_log_type_enabled(v10, type);
    if (!v17)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_activity_set_global_parent";
        v30 = 2082;
        v31 = "Global parent activity is immutable and cannot be set to a different activity.";
        _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
      goto LABEL_52;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446722;
      v29 = "nw_activity_set_global_parent";
      v30 = 2082;
      v31 = "Global parent activity is immutable and cannot be set to a different activity.";
      v32 = 2082;
      v33 = v17;
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
    }

    free(v17);
    if (v9)
      goto LABEL_54;
  }
  else
  {
    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v6 = (id)gactivityLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      v29 = (const char *)global_parent;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "Unsetting the global parent activity %{public}@.", buf, 0xCu);
    }

    v27 = &__block_literal_global_54_57594;
    nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>((os_unfair_lock_s *)&global_parent_lock, (uint64_t)&v27);

    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v7 = (id)gactivityLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "Unset the global parent activity.", buf, 2u);
    }

  }
LABEL_19:

}

void sub_1831CED5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_flow_state_allocator(void *a1, void *a2, void *a3, void *a4)
{
  NWConcrete_nw_protocol_definition *v7;
  NWConcrete_nw_protocol_definition *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  os_log_type_t v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_flow_state_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v36 = "nw_protocol_definition_set_flow_state_allocator";
          v37 = 2082;
          v38 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v10)
          goto LABEL_6;
LABEL_73:
        free(v10);
        goto LABEL_6;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v29, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_71:

    goto LABEL_72;
  }
  if (!a2)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_flow_state_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v30, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_definition_set_flow_state_allocator";
      v37 = 2082;
      v38 = v22;
      _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a3)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_flow_state_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v31, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_definition_set_flow_state_allocator";
      v37 = 2082;
      v38 = v22;
      _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a4)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_flow_state_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null replace_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v32, "%{public}s called with null replace_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_flow_state_allocator";
        _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null replace_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_definition_set_flow_state_allocator";
      v37 = 2082;
      v38 = v22;
      _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null replace_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_46:

    free(v22);
    if (!v10)
      goto LABEL_6;
    goto LABEL_73;
  }
  nw_protocol_definition_initialize_extended_state(v7);
  v8->extended_state->var2 = a2;
  v8->extended_state->var3 = a3;
  v8->extended_state->var4 = a4;
LABEL_6:

}

void sub_1831CF674(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_parameters_set_uid(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_DWORD *)(*((_QWORD *)v3 + 13) + 68) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_set_uid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_uid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_set_uid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_uid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_uid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_parameters_set_pid(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_DWORD *)(*((_QWORD *)v3 + 13) + 64) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_set_pid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_pid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_set_pid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_pid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_pid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_parameters_set_e_proc_uuid(void *a1, _OWORD *a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_OWORD *)(*((_QWORD *)v3 + 13) + 24) = *a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_set_e_proc_uuid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_e_proc_uuid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_set_e_proc_uuid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_e_proc_uuid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_e_proc_uuid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void __nw_resolver_can_use_dns_xpc_block_invoke()
{
  NSObject *v0;
  NSObject *v1;
  uint8_t buf[4];
  const char *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  nw_resolver_can_use_dns_xpc::can_use_dns_xpc = 1;
  if (!MEMORY[0x1E0DE5660])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v0 = (id)gLogObj;
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v3 = "nw_resolver_can_use_dns_xpc_block_invoke";
      _os_log_impl(&dword_182FBE000, v0, OS_LOG_TYPE_ERROR, "%{public}s libdns_services is not available", buf, 0xCu);
    }

  }
  getpid();
  if (sandbox_check())
  {
    nw_resolver_can_use_dns_xpc::can_use_dns_xpc = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = (id)gLogObj;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v3 = "nw_resolver_can_use_dns_xpc_block_invoke";
      _os_log_impl(&dword_182FBE000, v1, OS_LOG_TYPE_ERROR, "%{public}s Sandbox does not allow access to com.apple.dnssd.service", buf, 0xCu);
    }

  }
}

void nw_protocol_instance_set_wakeup_handler(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_instance_set_wakeup_handler";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_instance_set_wakeup_handler";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_instance_set_wakeup_handler";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9)
          goto LABEL_4;
LABEL_39:
        free(v9);
        goto LABEL_4;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_instance_set_wakeup_handler";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_instance_set_wakeup_handler";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v6 = _Block_copy(v4);
    v7 = (void *)v3[33];
    v3[33] = v6;

    goto LABEL_4;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_protocol_instance_set_wakeup_handler";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_instance_set_wakeup_handler";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null wakeup_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_instance_set_wakeup_handler";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null wakeup_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_instance_set_wakeup_handler";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null wakeup_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_protocol_instance_set_wakeup_handler";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null wakeup_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_39;
LABEL_4:

}

void nw_protocol_stack_prepend_application_protocol(nw_protocol_stack_t stack, nw_protocol_options_t protocol)
{
  nw_protocol_stack_t v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t isa;
  void **p_isa;
  _BOOL8 v8;
  void *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = stack;
  v4 = protocol;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_stack_prepend_application_protocol";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_stack_prepend_application_protocol";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_protocol_stack_prepend_application_protocol";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11)
          goto LABEL_8;
LABEL_43:
        free(v11);
        goto LABEL_8;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_stack_prepend_application_protocol";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_stack_prepend_application_protocol";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (v4)
  {
    p_isa = (void **)&v3[1].isa;
    isa = (uint64_t)v3[1].isa;
    if (!isa)
    {
      if (nw_protocol_options_are_persistent(v5) || (p_isa = (void **)&v3[2].isa, (isa = (uint64_t)v3[2].isa) == 0))
      {
        v8 = nw_array_create();
        v9 = *p_isa;
        *p_isa = (void *)v8;

        isa = (uint64_t)*p_isa;
      }
    }
    nw_array_prepend(isa, v5);
    goto LABEL_8;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_protocol_stack_prepend_application_protocol";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v11, &type, &v24))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_stack_prepend_application_protocol";
      _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null protocol", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v24)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_stack_prepend_application_protocol";
      _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  v19 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  v20 = type;
  v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_stack_prepend_application_protocol";
      _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_protocol_stack_prepend_application_protocol";
    v28 = 2082;
    v29 = v19;
    _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11)
    goto LABEL_43;
LABEL_8:

}

char *nw_path_flow_copy_description(void *a1)
{
  _QWORD *v1;
  id v2;
  uint64_t v3;
  char v4;
  const char *v5;
  const char *v6;
  char *v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char *v17;
  os_log_type_t out[48];
  char __str[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    if (v3)
      snprintf(__str, 0x28uLL, ", interface: %s", (const char *)(v3 + 104));
    else
      __str[0] = 0;
    v4 = *((_BYTE *)v2 + 185);
    memset(out, 0, 37);
    uuid_unparse((const unsigned __int8 *)v2 + 144, (char *)out);
    v5 = ", assigned";
    v6 = "";
    if ((v4 & 2) == 0)
      v5 = "";
    if ((v4 & 1) != 0)
      v6 = ", viable";
    v17 = 0;
    asprintf(&v17, "%s%s%s%s", (const char *)out, __str, v6, v5);
    v7 = v17;
    goto LABEL_10;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__str = 136446210;
  v20 = "nw_path_flow_copy_description";
  v10 = (char *)_os_log_send_and_compose_impl();

  out[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v17) = 0;
  if (__nwlog_fault(v10, out, &v17))
  {
    if (out[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = out[0];
      if (os_log_type_enabled(v11, out[0]))
      {
        *(_DWORD *)__str = 136446210;
        v20 = "nw_path_flow_copy_description";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null flow", (uint8_t *)__str, 0xCu);
      }
    }
    else if ((_BYTE)v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = out[0];
      v15 = os_log_type_enabled(v11, out[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__str = 136446466;
          v20 = "nw_path_flow_copy_description";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null flow, dumping backtrace:%{public}s", (uint8_t *)__str, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v15)
      {
        *(_DWORD *)__str = 136446210;
        v20 = "nw_path_flow_copy_description";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null flow, no backtrace", (uint8_t *)__str, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = out[0];
      if (os_log_type_enabled(v11, out[0]))
      {
        *(_DWORD *)__str = 136446210;
        v20 = "nw_path_flow_copy_description";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null flow, backtrace limit exceeded", (uint8_t *)__str, 0xCu);
      }
    }

  }
LABEL_27:
  if (v10)
    free(v10);
  v7 = 0;
LABEL_10:

  return v7;
}

void sub_1831D0CD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t NWEndpoint.Port.init(rawValue:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_WORD *)a2 = result;
  *(_BYTE *)(a2 + 2) = 0;
  return result;
}

BOOL nw_txt_record_set_key(nw_txt_record_t txt_record, const char *key, const uint8_t *value, size_t value_len)
{
  nw_txt_record_t v7;
  nw_txt_record_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  size_t v16;
  Class isa;
  size_t v18;
  NSObject *v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  objc_class *v23;
  objc_class *v24;
  Class v25;
  _BYTE *v26;
  char *v27;
  char *v28;
  char v29;
  os_log_type_t v30;
  _BOOL4 v31;
  void *v32;
  os_log_type_t v33;
  char *v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  NSObject *v38;
  void *v39;
  NSObject *v40;
  void *v41;
  NSObject *v42;
  void *v43;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  size_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v7 = txt_record;
  v8 = v7;
  if (v7)
  {
    if ((BYTE4(v7[4].isa) & 1) == 0)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if ((nw_txt_record_key_is_valid((uint64_t)key) & 1) == 0)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s invalid key", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (!value && value_len)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s value_len must be 0 if value is NULL", buf, 0xCu);
      }
      goto LABEL_58;
    }
    v9 = strlen(key);
    v10 = value_len + 2;
    if (!value)
      v10 = 1;
    v11 = v10 + v9;
    if (v10 + v9 >= 0x100)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_txt_record_set_key";
      v13 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v45 = 0;
      if (!__nwlog_fault(v13, &type, &v45))
        goto LABEL_41;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_set_key";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s Unable to set key-value pair. The length of the 'key=pair' must be less than or equal to UINT8_MAX.", buf, 0xCu);
        }
      }
      else if (v45)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v21 = type;
        v22 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            v48 = "nw_txt_record_set_key";
            v49 = 2082;
            v50 = (size_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s Unable to set key-value pair. The length of the 'key=pair' must be less than or equal to UINT8_MAX., dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v13)
            goto LABEL_43;
          goto LABEL_42;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_set_key";
          _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s Unable to set key-value pair. The length of the 'key=pair' must be less than or equal to UINT8_MAX., no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_set_key";
          _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s Unable to set key-value pair. The length of the 'key=pair' must be less than or equal to UINT8_MAX., backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_40;
    }
    v16 = v9;
    os_unfair_lock_lock((os_unfair_lock_t)&v8[4]);
    nw_txt_record_remove_key_locked(v8, key);
    isa = v8[2].isa;
    if ((Class)((unint64_t)isa + v11) <= v8[3].isa)
    {
LABEL_30:
      if (isa == (Class)1)
      {
        isa = 0;
        v8[2].isa = 0;
      }
      v26 = (char *)v8[1].isa + (unint64_t)isa;
      memcpy(v26 + 1, key, v16);
      v27 = &v26[v16 + 1];
      if (value)
      {
        *v27 = 61;
        v28 = v27 + 1;
        memcpy(v28, value, value_len);
        v27 = &v28[value_len];
      }
      *v26 = (_BYTE)v27 - (_BYTE)v26 - 1;
      v8[2].isa = (Class)((char *)v8[2].isa + v27 - v26);
      os_unfair_lock_unlock((os_unfair_lock_t)&v8[4]);
      v29 = 1;
      goto LABEL_44;
    }
    v18 = (size_t)isa + 256;
    if ((unint64_t)isa + 256 >= 0x22C5)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&v8[4]);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s nw_txt_record reallocate failed: max buffer length reached", buf, 0xCu);
      }
LABEL_58:

      goto LABEL_43;
    }
    if (isa == (Class)-256)
    {
      __nwlog_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v48 = "strict_malloc";
      v39 = (void *)_os_log_send_and_compose_impl();

      v31 = __nwlog_abort((uint64_t)v39);
      if (v31)
        goto LABEL_75;
      free(v39);
    }
    v23 = (objc_class *)malloc_type_malloc(v18, 0xF2B69DE5uLL);
    v24 = v23;
    if (v23)
    {
      v25 = v8[1].isa;
      memcpy(v23, v25, (size_t)v8[2].isa);
      if (v25)
      {
        free(v25);
        v8[1].isa = 0;
      }
      v8[1].isa = v24;
      v8[3].isa = (Class)v18;
      isa = v8[2].isa;
      goto LABEL_30;
    }
    __nwlog_obj();
    v40 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v48 = "strict_malloc";
    v49 = 2048;
    v50 = v18;
    v41 = (void *)_os_log_send_and_compose_impl();

    v31 = __nwlog_abort((uint64_t)v41);
    if (!v31)
    {
      free(v41);
      os_unfair_lock_unlock((os_unfair_lock_t)&v8[4]);
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v48 = "nw_txt_record_set_key";
      v43 = (void *)_os_log_send_and_compose_impl();

      v31 = __nwlog_abort((uint64_t)v43);
      if (!v31)
      {
        free(v43);
        v29 = 0;
        goto LABEL_44;
      }
    }
LABEL_75:
    __break(1u);
    return v31;
  }
  __nwlog_obj();
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v48 = "nw_txt_record_set_key";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if (__nwlog_fault(v13, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_182FBE000, v14, v33, "%{public}s called with null txt_record", buf, 0xCu);
      }
LABEL_40:

      goto LABEL_41;
    }
    if (!v45)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_182FBE000, v14, v37, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_40;
    }
    v34 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v35 = type;
    v36 = os_log_type_enabled(v14, type);
    if (!v34)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_set_key";
        _os_log_impl(&dword_182FBE000, v14, v35, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }
      goto LABEL_40;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v48 = "nw_txt_record_set_key";
      v49 = 2082;
      v50 = (size_t)v34;
      _os_log_impl(&dword_182FBE000, v14, v35, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v34);
  }
LABEL_41:
  if (v13)
LABEL_42:
    free(v13);
LABEL_43:
  v29 = 0;
LABEL_44:

  LOBYTE(v31) = v29;
  return v31;
}

void sub_1831D16C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_txt_record_remove_key_locked(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  int start_of_key_locked;
  _BOOL8 v6;
  uint64_t v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  NSObject *v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  _BYTE __dst[12];
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__dst = 136446210;
    *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key_locked";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__dst = 136446210;
          *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key_locked";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null txt_record", __dst, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)__dst = 136446466;
            *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key_locked";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s called with null txt_record, dumping backtrace:%{public}s", __dst, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v16)
        {
          *(_DWORD *)__dst = 136446210;
          *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key_locked";
          _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s called with null txt_record, no backtrace", __dst, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__dst = 136446210;
          *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key_locked";
          _os_log_impl(&dword_182FBE000, v11, v17, "%{public}s called with null txt_record, backtrace limit exceeded", __dst, 0xCu);
        }
      }

    }
LABEL_29:
    if (v10)
      free(v10);
    goto LABEL_31;
  }
  if ((*((_BYTE *)v3 + 36) & 1) == 0)
  {
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__dst = 136446210;
      *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key_locked";
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", __dst, 0xCu);
    }
    goto LABEL_14;
  }
  if ((nw_txt_record_key_is_valid((uint64_t)a2) & 1) == 0)
  {
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__dst = 136446210;
      *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key_locked";
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s invalid key", __dst, 0xCu);
    }
LABEL_14:

LABEL_31:
    v6 = 0;
    goto LABEL_6;
  }
  *(_QWORD *)__dst = 0;
  start_of_key_locked = nw_txt_record_find_start_of_key_locked(v4, a2, __dst, 0, 0, 0);
  v6 = start_of_key_locked != 1;
  if (start_of_key_locked != 1)
  {
    v7 = **(_BYTE **)__dst + 1;
    memmove(*(void **)__dst, (const void *)(*(_QWORD *)__dst + v7), v4[1] + v4[2] - (*(_QWORD *)__dst + v7));
    v4[2] -= v7;
  }
LABEL_6:

  return v6;
}

void sub_1831D1A94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_txt_record_key_is_valid(uint64_t result)
{
  _BYTE *v1;
  NSObject *v2;
  const char *v3;
  int v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = (_BYTE *)result;
    if (strnlen((const char *)result, 0x100uLL) - 256 >= 0xFFFFFFFFFFFFFF01)
    {
      v4 = *v1;
      if (!*v1)
        return 1;
      v5 = v1 + 1;
      while (v4 != 61 && (v4 - 32) < 0x5F)
      {
        v6 = *v5++;
        v4 = v6;
        if (!v6)
          return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = (id)gLogObj;
      if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        goto LABEL_14;
      v7 = 136446210;
      v8 = "nw_txt_record_key_is_valid";
      v3 = "%{public}s An invalid key was provided. The characters of \t\t\t\t\t  a key MUST be printable US-ASCII values"
           " (0x20-0x7E)\t\t\t\t\t  [RFC20], excluding '=' (0x3D).";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = (id)gLogObj;
      if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
LABEL_14:

        return 0;
      }
      v7 = 136446210;
      v8 = "nw_txt_record_key_is_valid";
      v3 = "%{public}s An invalid key was provided. An invalid key was provided. \t\t\t\t  The key must be a non-empty st"
           "ring of length less than or equal\t\t\t\t  to UINT8_MAX.";
    }
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, v3, (uint8_t *)&v7, 0xCu);
    goto LABEL_14;
  }
  return result;
}

uint64_t nw_txt_record_find_start_of_key_locked(void *a1, const char *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  id v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  _QWORD aBlock[11];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;

  v11 = a1;
  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  if (a6)
    *a6 = 0;
  v12 = strnlen(a2, 0xFFuLL);
  v17 = 0;
  v18 = &v17;
  v20 = 1;
  v19 = 0x2020000000;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_txt_record_find_start_of_key_locked_block_invoke;
  aBlock[3] = &unk_1E14A5430;
  aBlock[4] = &v17;
  aBlock[5] = v12;
  aBlock[6] = a2;
  aBlock[7] = a3;
  aBlock[8] = a4;
  aBlock[9] = a5;
  aBlock[10] = a6;
  v13 = _Block_copy(aBlock);
  nw_txt_record_apply_internal_locked(v11, v13, 0);
  v14 = *((unsigned int *)v18 + 6);

  _Block_object_dispose(&v17, 8);
  return v14;
}

void sub_1831D1D28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  _Block_object_dispose((const void *)(v3 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t nw_txt_record_apply_internal_locked(void *a1, void *a2, void *a3)
{
  id v5;
  uint64_t (**v6)(id, uint64_t);
  id v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  void *v21;
  os_log_type_t v22;
  NSObject *v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (!v5)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_txt_record_apply_internal_locked";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_txt_record_apply_internal_locked";
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null txt_record", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (!v31)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_txt_record_apply_internal_locked";
        _os_log_impl(&dword_182FBE000, v19, v29, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_txt_record_apply_internal_locked";
        _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_txt_record_apply_internal_locked";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_41;
  }
  if (!v6)
  {
    __nwlog_obj();
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_txt_record_apply_internal_locked";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_txt_record_apply_internal_locked";
        _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null applier_internal", buf, 0xCu);
      }
LABEL_53:

LABEL_54:
      if (v18)
        free(v18);
      goto LABEL_56;
    }
    if (!v31)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_txt_record_apply_internal_locked";
        _os_log_impl(&dword_182FBE000, v19, v30, "%{public}s called with null applier_internal, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_txt_record_apply_internal_locked";
        _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s called with null applier_internal, no backtrace", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_txt_record_apply_internal_locked";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s called with null applier_internal, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_41:

    free(backtrace_string);
    goto LABEL_54;
  }
  if ((*((_BYTE *)v5 + 36) & 1) == 0)
  {
    __nwlog_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_txt_record_apply_internal_locked";
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }

LABEL_56:
    v15 = 0;
    goto LABEL_17;
  }
  v8 = *((_QWORD *)v5 + 2);
  if (v8 < 2)
  {
    v15 = 1;
  }
  else
  {
    v9 = *((_QWORD *)v5 + 1);
    v10 = (unsigned __int8 *)(v9 + v8);
    do
    {
      v11 = *(unsigned __int8 *)v9;
      if (v9 + v11 > (unint64_t)v10)
        __assert_rtn("nw_txt_record_apply_internal_locked", "txt_record.cpp", 613, "pair_end <= end");
      v12 = memchr((void *)(v9 + 1), 61, *(unsigned __int8 *)v9);
      if (v12)
        v13 = (uint64_t)v12;
      else
        v13 = v9 + v11 + 1;
      if (v13 + ~v9 != v11)
      {
        v14 = v13 - v9;
        if (v14 != v11 && v14 >= v11)
          __assert_rtn("nw_txt_record_get_key_value_result", "txt_record.cpp", 758, "false");
      }
      v15 = v6[2](v6, v9 + 1);
      if (!(_DWORD)v15)
        break;
      v9 += *(unsigned __int8 *)v9 + 1;
    }
    while (v9 < (unint64_t)v10);
  }
LABEL_17:

  return v15;
}

void sub_1831D237C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t __nw_txt_record_find_start_of_key_locked_block_invoke(uint64_t a1, const char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t result;
  _QWORD *v14;
  const char **v15;
  _QWORD *v16;
  _QWORD *v17;

  if (*(_QWORD *)(a1 + 40) != a3 || strncasecmp(*(const char **)(a1 + 48), a2, a3))
    return 1;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a7;
  v14 = *(_QWORD **)(a1 + 56);
  if (v14)
    *v14 = a6;
  v15 = *(const char ***)(a1 + 64);
  if (v15)
    *v15 = a2;
  v16 = *(_QWORD **)(a1 + 72);
  if (v16)
    *v16 = a4;
  v17 = *(_QWORD **)(a1 + 80);
  result = 0;
  if (v17)
    *v17 = a5;
  return result;
}

BOOL nw_connection_failed_due_to_blocked_tracker(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v19 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_failed_due_to_blocked_tracker_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v15 = buf;
    v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_failed_due_to_blocked_tracker_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_failed_due_to_blocked_tracker";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_failed_due_to_blocked_tracker";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_failed_due_to_blocked_tracker";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_failed_due_to_blocked_tracker";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_failed_due_to_blocked_tracker";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_connection_failed_due_to_blocked_tracker_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_BYTE *)(*(_QWORD *)(result + 32) + 110) & 1;
  return result;
}

BOOL __nw_xpc_retain_array_with_validated_types_block_invoke(uint64_t a1, int a2, id a3)
{
  return object_getClass(a3) == *(Class *)(a1 + 32);
}

void nw_data_transfer_report_collect(nw_data_transfer_report_t report, dispatch_queue_t queue, nw_data_transfer_report_collect_block_t collect_block)
{
  NSObject *v5;
  NSObject *v6;
  nw_data_transfer_report_collect_block_t v7;
  void *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = report;
  v6 = queue;
  v7 = collect_block;
  v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_data_transfer_report_collect";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_data_transfer_report_collect";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_data_transfer_report_collect";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v10)
          goto LABEL_5;
LABEL_40:
        free(v10);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_data_transfer_report_collect";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_data_transfer_report_collect";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v6 || !v7)
  {
    nw_data_transfer_report_collect_inner(v5, v6, v7, 0);
    goto LABEL_5;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_data_transfer_report_collect";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v23)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v18 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  v19 = type;
  v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_data_transfer_report_collect";
      _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_data_transfer_report_collect";
    v27 = 2082;
    v28 = v18;
    _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10)
    goto LABEL_40;
LABEL_5:

}

void sub_1831D2C90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_data_transfer_report_collect_on_nw_queue(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  NSObject *v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (!v4 && gLogDatapath)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s called without collect_block", buf, 0xCu);
      }

    }
    nw_data_transfer_report_collect_inner(v3, 0, v5, 1);
    goto LABEL_5;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_data_transfer_report_collect_on_nw_queue";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_data_transfer_report_collect_on_nw_queue";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_data_transfer_report_collect_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_25:
  if (v7)
    free(v7);
LABEL_5:

}

void sub_1831D2FC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_quic_access_token_on_queue(void *a1, void *a2)
{
  id v3;
  void (**v4)(id, _QWORD);
  id v5;
  uint64_t *cached_content_for_protocol;
  uint64_t v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
    v5 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
    if (v5)
    {
      cached_content_for_protocol = (uint64_t *)nw_association_get_cached_content_for_protocol(v3, v5);
      if (cached_content_for_protocol)
        v7 = *cached_content_for_protocol;
      else
        v7 = 0;
      v4[2](v4, v7);
LABEL_9:

      goto LABEL_10;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_quic_access_token_on_queue";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_quic_access_token_on_queue";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null definition", buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        v21 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_quic_access_token_on_queue";
            v28 = 2082;
            v29 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_quic_access_token_on_queue";
          _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_quic_access_token_on_queue";
          _os_log_impl(&dword_182FBE000, v14, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_45:
    if (v13)
      free(v13);
    goto LABEL_9;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_quic_access_token_on_queue";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v9, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_quic_access_token_on_queue";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v24)
    {
      v16 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_quic_access_token_on_queue";
          v28 = 2082;
          v29 = v16;
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v16);
        goto LABEL_40;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_quic_access_token_on_queue";
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_quic_access_token_on_queue";
        _os_log_impl(&dword_182FBE000, v10, v22, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_40:
  if (v9)
    free(v9);
LABEL_10:

}

void sub_1831D34E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_quic_access_0rtt_state_on_queue(void *a1, void *a2)
{
  id v3;
  void (**v4)(id, uint64_t, uint64_t);
  id v5;
  uint64_t cached_content_for_protocol;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
    v5 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
    if (v5)
    {
      cached_content_for_protocol = nw_association_get_cached_content_for_protocol(v3, v5);
      if (cached_content_for_protocol)
      {
        v7 = *(_QWORD *)(cached_content_for_protocol + 8);
        v8 = *(_QWORD *)(cached_content_for_protocol + 16);
      }
      else
      {
        v7 = 0;
        v8 = 0;
      }
      v4[2](v4, v7, v8);
LABEL_9:

      goto LABEL_10;
    }
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_quic_access_0rtt_state_on_queue";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v14, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_quic_access_0rtt_state_on_queue";
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null definition", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        v22 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            v28 = "nw_quic_access_0rtt_state_on_queue";
            v29 = 2082;
            v30 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v15, v21, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_quic_access_0rtt_state_on_queue";
          _os_log_impl(&dword_182FBE000, v15, v21, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_quic_access_0rtt_state_on_queue";
          _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_45:
    if (v14)
      free(v14);
    goto LABEL_9;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_quic_access_0rtt_state_on_queue";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_quic_access_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v25)
    {
      v17 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_quic_access_0rtt_state_on_queue";
          v29 = 2082;
          v30 = v17;
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v17);
        goto LABEL_40;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_quic_access_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_quic_access_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_40:
  if (v10)
    free(v10);
LABEL_10:

}

void sub_1831D3A14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_access_globals(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  uint64_t (**v5)(_QWORD, _QWORD);
  void *v6;
  void *v7;
  uint64_t globals_for_protocol;
  uint64_t v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  void *v19;
  os_log_type_t v20;
  void *v21;
  os_log_type_t v22;
  char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  _BOOL4 v31;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  os_log_type_t v35;
  os_log_type_t v36;
  os_log_type_t v37;
  os_log_type_t v38;
  char v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  char *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = (uint64_t (**)(_QWORD, _QWORD))v4;
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_instance_access_globals";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v12, &type, &v39))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null instance", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (!v39)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v34, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v24 = type;
    v25 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_instance_access_globals";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_57:

    free(backtrace_string);
    goto LABEL_58;
  }
  if (!v4)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_instance_access_globals";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v12, &type, &v39))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null access_block", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (!v39)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v35, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v26 = type;
    v27 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v26, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_instance_access_globals";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v26, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
  v6 = (void *)v3[1];
  if (!v6)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_instance_access_globals";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v12, &type, &v39))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null instance->parent_definition", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (!v39)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v36, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v28 = type;
    v29 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v28, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_instance_access_globals";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v28, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
  if (!v3[6])
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_instance_access_globals";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v12, &type, &v39))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null instance->parameters", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (!v39)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v37, "%{public}s called with null instance->parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v30 = type;
    v31 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v30, "%{public}s called with null instance->parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_instance_access_globals";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v30, "%{public}s called with null instance->parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
  v7 = (void *)v3[15];
  if (v7)
  {
    globals_for_protocol = nw_context_get_globals_for_protocol(v7, v6);
    v9 = v5[2](v5, globals_for_protocol);
    goto LABEL_7;
  }
  __nwlog_obj();
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v42 = "nw_protocol_instance_access_globals";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v12, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s called with null instance->context", buf, 0xCu);
      }
LABEL_90:

      goto LABEL_58;
    }
    if (!v39)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v38 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v38, "%{public}s called with null instance->context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v32 = type;
    v33 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_instance_access_globals";
        _os_log_impl(&dword_182FBE000, v13, v32, "%{public}s called with null instance->context, no backtrace", buf, 0xCu);
      }
      goto LABEL_90;
    }
    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_instance_access_globals";
      v43 = 2082;
      v44 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v32, "%{public}s called with null instance->context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
LABEL_58:
  if (v12)
    free(v12);
  v9 = 0;
LABEL_7:

  return v9;
}

void sub_1831D4510(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_context_get_globals_for_protocol(void *a1, void *a2)
{
  os_unfair_lock_s **v3;
  id v4;
  void *v5;
  NWConcrete_nw_context *v6;
  NWConcrete_nw_context *v7;
  os_unfair_lock_s *v8;
  os_unfair_lock_s *v9;
  uint64_t node;
  uint64_t v11;
  _QWORD *v12;
  os_unfair_lock_s **v13;
  uint64_t v14;
  uint64_t (*v15)(_QWORD *, os_unfair_lock_s **);
  uint64_t (*v16)(_QWORD *);
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _BOOL8 v20;
  uint64_t v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  id v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  char *v33;
  os_log_type_t v34;
  _BOOL4 v35;
  os_log_type_t v36;
  os_log_type_t v37;
  void *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  void *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  void *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  char *backtrace_string;
  os_log_type_t v51;
  _BOOL4 v52;
  char *v53;
  os_log_type_t v54;
  _BOOL4 v55;
  char *v56;
  os_log_type_t v57;
  _BOOL4 v58;
  void *v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  os_log_type_t v63;
  os_log_type_t v64;
  os_log_type_t v65;
  char *v66;
  os_log_type_t v67;
  _BOOL4 v68;
  void *v69;
  os_log_type_t v70;
  os_log_type_t v71;
  char *v72;
  os_log_type_t v73;
  _BOOL4 v74;
  os_log_type_t v75;
  id v76;
  NSObject *v77;
  os_log_type_t v78;
  os_log_type_t v79;
  _BOOL4 v80;
  os_log_type_t v81;
  char v83;
  os_log_type_t type;
  os_log_type_t v85;
  uint8_t buf[4];
  const char *v87;
  __int16 v88;
  char *v89;
  __int16 v90;
  _QWORD *v91;
  __int16 v92;
  char *v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v87 = "nw_context_get_globals_for_protocol";
    v39 = (char *)_os_log_send_and_compose_impl();

    v85 = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v39, &v85, &type))
    {
      if (v85 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v41 = v85;
        if (os_log_type_enabled(v40, v85))
        {
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v51 = v85;
        v52 = os_log_type_enabled(v40, v85);
        if (backtrace_string)
        {
          if (v52)
          {
            *(_DWORD *)buf = 136446466;
            v87 = "nw_context_get_globals_for_protocol";
            v88 = 2082;
            v89 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v40, v51, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_100;
        }
        if (v52)
        {
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_182FBE000, v40, v51, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v63 = v85;
        if (os_log_type_enabled(v40, v85))
        {
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_182FBE000, v40, v63, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_100:
    if (v39)
      free(v39);
    goto LABEL_114;
  }
  if (!v4)
  {
    __nwlog_obj();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v87 = "nw_context_get_globals_for_protocol";
    v43 = (char *)_os_log_send_and_compose_impl();

    v85 = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v43, &v85, &type))
    {
      if (v85 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v45 = v85;
        if (os_log_type_enabled(v44, v85))
        {
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else if (type)
      {
        v53 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v54 = v85;
        v55 = os_log_type_enabled(v44, v85);
        if (v53)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            v87 = "nw_context_get_globals_for_protocol";
            v88 = 2082;
            v89 = v53;
            _os_log_impl(&dword_182FBE000, v44, v54, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v53);
          goto LABEL_105;
        }
        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_182FBE000, v44, v54, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v64 = v85;
        if (os_log_type_enabled(v44, v85))
        {
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          _os_log_impl(&dword_182FBE000, v44, v64, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_105:
    if (v43)
      free(v43);
    goto LABEL_113;
  }
  v6 = v3;
  v7 = v6;
  if ((*((_BYTE *)v6 + 136) & 8) == 0)
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v6 + 1));

  v3 = (os_unfair_lock_s **)nw_context_copy_globals_context(v7);
  v8 = v3[4];
  if (v8)
  {
    os_unfair_lock_lock(v8 + 12);
    v9 = v3[4];
    if (!v9)
      goto LABEL_166;
    node = nw_hash_table_get_node(*(_QWORD *)&v9[13]._os_unfair_lock_opaque, (uint64_t)v5, 0);
    if (node)
    {
      v11 = *(_QWORD *)(node + 32);
LABEL_167:
      os_unfair_lock_unlock(v3[4] + 12);

      goto LABEL_168;
    }
    v12 = v5;
    v13 = v3;
    v14 = v12[9];
    if (v14)
    {
      v16 = *(uint64_t (**)(_QWORD *))v14;
      v15 = *(uint64_t (**)(_QWORD *, os_unfair_lock_s **))(v14 + 8);
      if (v16)
      {
        if (!v15)
        {
          v17 = v16(v12);
          goto LABEL_15;
        }
LABEL_14:
        v17 = v15(v12, v13);
LABEL_15:
        v11 = v17;

        if (v11)
        {
          v85 = OS_LOG_TYPE_DEFAULT;
          v18 = *(_QWORD *)&v3[4][13]._os_unfair_lock_opaque;
          v19 = v12;
          v20 = nw_hash_table_add_object(v18, (uint64_t)v19, (char *)&v85);
          if (v20)
          {
            v21 = v20;
            if (v85)
            {
LABEL_52:
              *(_QWORD *)(v21 + 32) = v11;
              goto LABEL_167;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v22 = (id)gLogObj;
            *(_DWORD *)buf = 136446722;
            v87 = "nw_context_get_globals_for_protocol";
            v88 = 2114;
            v89 = (char *)v13;
            v90 = 2048;
            v91 = v19;
            v23 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v83 = 0;
            if (__nwlog_fault(v23, &type, &v83))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v24 = objc_claimAutoreleasedReturnValue();
                v25 = type;
                if (os_log_type_enabled(v24, type))
                {
                  *(_DWORD *)buf = 136446722;
                  v87 = "nw_context_get_globals_for_protocol";
                  v88 = 2114;
                  v89 = (char *)v13;
                  v90 = 2048;
                  v91 = v19;
                  _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s %{public}@ failed to add globals for protocol %p", buf, 0x20u);
                }
              }
              else if (v83)
              {
                v33 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v24 = objc_claimAutoreleasedReturnValue();
                v34 = type;
                v35 = os_log_type_enabled(v24, type);
                if (v33)
                {
                  if (v35)
                  {
                    *(_DWORD *)buf = 136446978;
                    v87 = "nw_context_get_globals_for_protocol";
                    v88 = 2114;
                    v89 = (char *)v13;
                    v90 = 2048;
                    v91 = v19;
                    v92 = 2082;
                    v93 = v33;
                    _os_log_impl(&dword_182FBE000, v24, v34, "%{public}s %{public}@ failed to add globals for protocol %p, dumping backtrace:%{public}s", buf, 0x2Au);
                  }

                  free(v33);
                  goto LABEL_50;
                }
                if (v35)
                {
                  *(_DWORD *)buf = 136446722;
                  v87 = "nw_context_get_globals_for_protocol";
                  v88 = 2114;
                  v89 = (char *)v13;
                  v90 = 2048;
                  v91 = v19;
                  _os_log_impl(&dword_182FBE000, v24, v34, "%{public}s %{public}@ failed to add globals for protocol %p, no backtrace", buf, 0x20u);
                }
              }
              else
              {
                __nwlog_obj();
                v24 = objc_claimAutoreleasedReturnValue();
                v37 = type;
                if (os_log_type_enabled(v24, type))
                {
                  *(_DWORD *)buf = 136446722;
                  v87 = "nw_context_get_globals_for_protocol";
                  v88 = 2114;
                  v89 = (char *)v13;
                  v90 = 2048;
                  v91 = v19;
                  _os_log_impl(&dword_182FBE000, v24, v37, "%{public}s %{public}@ failed to add globals for protocol %p, backtrace limit exceeded", buf, 0x20u);
                }
              }

            }
LABEL_50:
            if (v23)
              free(v23);
            goto LABEL_52;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          v27 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v83 = 0;
          if (__nwlog_fault(v27, &type, &v83))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v28 = (id)gLogObj;
              v29 = type;
              if (os_log_type_enabled(v28, type))
              {
                *(_DWORD *)buf = 136446210;
                v87 = "nw_context_get_globals_for_protocol";
                _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s nw_hash_table_add_object failed", buf, 0xCu);
              }
LABEL_43:

              goto LABEL_164;
            }
            if (!v83)
            {
              __nwlog_obj();
              v28 = objc_claimAutoreleasedReturnValue();
              v36 = type;
              if (os_log_type_enabled(v28, type))
              {
                *(_DWORD *)buf = 136446210;
                v87 = "nw_context_get_globals_for_protocol";
                _os_log_impl(&dword_182FBE000, v28, v36, "%{public}s nw_hash_table_add_object failed, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_43;
            }
            v30 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v28 = objc_claimAutoreleasedReturnValue();
            v31 = type;
            v32 = os_log_type_enabled(v28, type);
            if (!v30)
            {
              if (v32)
              {
                *(_DWORD *)buf = 136446210;
                v87 = "nw_context_get_globals_for_protocol";
                _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s nw_hash_table_add_object failed, no backtrace", buf, 0xCu);
              }
              goto LABEL_43;
            }
            if (v32)
            {
              *(_DWORD *)buf = 136446466;
              v87 = "nw_context_get_globals_for_protocol";
              v88 = 2082;
              v89 = v30;
              _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s nw_hash_table_add_object failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

LABEL_156:
            free(v30);
            if (!v27)
              goto LABEL_166;
            goto LABEL_165;
          }
          goto LABEL_164;
        }
LABEL_146:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v76 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v87 = "nw_context_get_globals_for_protocol";
        v27 = (char *)_os_log_send_and_compose_impl();

        v85 = OS_LOG_TYPE_ERROR;
        type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v27, &v85, &type))
        {
          if (v85 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v77 = (id)gLogObj;
            v78 = v85;
            if (os_log_type_enabled(v77, v85))
            {
              *(_DWORD *)buf = 136446210;
              v87 = "nw_context_get_globals_for_protocol";
              _os_log_impl(&dword_182FBE000, v77, v78, "%{public}s nw_protocol_definition_allocate_globals failed", buf, 0xCu);
            }
          }
          else if (type)
          {
            v30 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v77 = objc_claimAutoreleasedReturnValue();
            v79 = v85;
            v80 = os_log_type_enabled(v77, v85);
            if (v30)
            {
              if (v80)
              {
                *(_DWORD *)buf = 136446466;
                v87 = "nw_context_get_globals_for_protocol";
                v88 = 2082;
                v89 = v30;
                _os_log_impl(&dword_182FBE000, v77, v79, "%{public}s nw_protocol_definition_allocate_globals failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              goto LABEL_156;
            }
            if (v80)
            {
              *(_DWORD *)buf = 136446210;
              v87 = "nw_context_get_globals_for_protocol";
              _os_log_impl(&dword_182FBE000, v77, v79, "%{public}s nw_protocol_definition_allocate_globals failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v77 = objc_claimAutoreleasedReturnValue();
            v81 = v85;
            if (os_log_type_enabled(v77, v85))
            {
              *(_DWORD *)buf = 136446210;
              v87 = "nw_context_get_globals_for_protocol";
              _os_log_impl(&dword_182FBE000, v77, v81, "%{public}s nw_protocol_definition_allocate_globals failed, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
LABEL_164:
        if (v27)
LABEL_165:
          free(v27);
LABEL_166:
        v11 = 0;
        goto LABEL_167;
      }
      if (v15)
        goto LABEL_14;
      __nwlog_obj();
      v69 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v87 = "nw_protocol_definition_allocate_globals";
      v60 = (char *)_os_log_send_and_compose_impl();

      v85 = OS_LOG_TYPE_ERROR;
      type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v60, &v85, &type))
      {
        if (v85 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v61 = objc_claimAutoreleasedReturnValue();
          v70 = v85;
          if (os_log_type_enabled(v61, v85))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_protocol_definition_allocate_globals";
            _os_log_impl(&dword_182FBE000, v61, v70, "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_state->allocate_context_globals != __null)", buf, 0xCu);
          }
        }
        else if (type)
        {
          v72 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v61 = objc_claimAutoreleasedReturnValue();
          v73 = v85;
          v74 = os_log_type_enabled(v61, v85);
          if (v72)
          {
            if (v74)
            {
              *(_DWORD *)buf = 136446466;
              v87 = "nw_protocol_definition_allocate_globals";
              v88 = 2082;
              v89 = v72;
              _os_log_impl(&dword_182FBE000, v61, v73, "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_state->allocate_context_globals != __null), dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v72);
            if (!v60)
              goto LABEL_145;
            goto LABEL_144;
          }
          if (v74)
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_protocol_definition_allocate_globals";
            _os_log_impl(&dword_182FBE000, v61, v73, "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_state->allocate_context_globals != __null), no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v61 = objc_claimAutoreleasedReturnValue();
          v75 = v85;
          if (os_log_type_enabled(v61, v85))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_protocol_definition_allocate_globals";
            _os_log_impl(&dword_182FBE000, v61, v75, "%{public}s called with null (definition->common_state->allocate_globals != __null || definition->common_state->allocate_context_globals != __null), backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_142;
      }
LABEL_143:
      if (!v60)
      {
LABEL_145:

        goto LABEL_146;
      }
LABEL_144:
      free(v60);
      goto LABEL_145;
    }
    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v87 = "nw_protocol_definition_allocate_globals";
    v60 = (char *)_os_log_send_and_compose_impl();

    v85 = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v60, &v85, &type))
      goto LABEL_143;
    if (v85 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v61 = objc_claimAutoreleasedReturnValue();
      v62 = v85;
      if (os_log_type_enabled(v61, v85))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_protocol_definition_allocate_globals";
        _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s called with null definition->common_state", buf, 0xCu);
      }
    }
    else if (type)
    {
      v66 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v61 = objc_claimAutoreleasedReturnValue();
      v67 = v85;
      v68 = os_log_type_enabled(v61, v85);
      if (v66)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446466;
          v87 = "nw_protocol_definition_allocate_globals";
          v88 = 2082;
          v89 = v66;
          _os_log_impl(&dword_182FBE000, v61, v67, "%{public}s called with null definition->common_state, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v66);
        goto LABEL_143;
      }
      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_protocol_definition_allocate_globals";
        _os_log_impl(&dword_182FBE000, v61, v67, "%{public}s called with null definition->common_state, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v61 = objc_claimAutoreleasedReturnValue();
      v71 = v85;
      if (os_log_type_enabled(v61, v85))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_protocol_definition_allocate_globals";
        _os_log_impl(&dword_182FBE000, v61, v71, "%{public}s called with null definition->common_state, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_142:

    goto LABEL_143;
  }
  __nwlog_obj();
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v87 = "nw_context_get_globals_for_protocol";
  v47 = (char *)_os_log_send_and_compose_impl();

  v85 = OS_LOG_TYPE_ERROR;
  type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v47, &v85, &type))
    goto LABEL_111;
  if (v85 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v48 = objc_claimAutoreleasedReturnValue();
    v49 = v85;
    if (os_log_type_enabled(v48, v85))
    {
      *(_DWORD *)buf = 136446210;
      v87 = "nw_context_get_globals_for_protocol";
      _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null context->globals", buf, 0xCu);
    }
  }
  else if (type)
  {
    v56 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v48 = objc_claimAutoreleasedReturnValue();
    v57 = v85;
    v58 = os_log_type_enabled(v48, v85);
    if (v56)
    {
      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        v87 = "nw_context_get_globals_for_protocol";
        v88 = 2082;
        v89 = v56;
        _os_log_impl(&dword_182FBE000, v48, v57, "%{public}s called with null context->globals, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v56);
      goto LABEL_111;
    }
    if (v58)
    {
      *(_DWORD *)buf = 136446210;
      v87 = "nw_context_get_globals_for_protocol";
      _os_log_impl(&dword_182FBE000, v48, v57, "%{public}s called with null context->globals, no backtrace", buf, 0xCu);
    }
  }
  else
  {
    __nwlog_obj();
    v48 = objc_claimAutoreleasedReturnValue();
    v65 = v85;
    if (os_log_type_enabled(v48, v85))
    {
      *(_DWORD *)buf = 136446210;
      v87 = "nw_context_get_globals_for_protocol";
      _os_log_impl(&dword_182FBE000, v48, v65, "%{public}s called with null context->globals, backtrace limit exceeded", buf, 0xCu);
    }
  }

LABEL_111:
  if (v47)
    free(v47);
LABEL_113:

LABEL_114:
  v11 = 0;
LABEL_168:

  return v11;
}

void sub_1831D57F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id nw_connection_copy_failed_resolution_report(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v19)(uint64_t, uint64_t);
  void (*v20)(uint64_t);
  id v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v19 = __Block_byref_object_copy__7754;
    v20 = __Block_byref_object_dispose__7755;
    v21 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_failed_resolution_report_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v15 = buf;
    v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_failed_resolution_report_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(id *)(*(_QWORD *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_copy_failed_resolution_report";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_copy_failed_resolution_report";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_failed_resolution_report";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_failed_resolution_report_block_invoke(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(id *)(*(_QWORD *)(a1 + 32) + 432));
}

unsigned __int8 *nw_parameters_copy_protocol_options_for_definition(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 *v8;
  uint64_t v9;
  void *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  void *v13;
  unsigned __int8 *v14;
  id *v15;
  id v16;
  unsigned __int8 *v17;
  id *v18;
  id v19;
  unsigned __int8 *v20;
  id *v21;
  id v22;
  void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  void *v28;
  os_log_type_t v29;
  void *v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  char *v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  _BOOL4 v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  os_log_type_t v43;
  os_log_type_t v44;
  _QWORD v45[4];
  id v46;
  _BYTE *v47;
  _QWORD v48[4];
  id v49;
  _BYTE *v50;
  char v51;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v54)(uint64_t, uint64_t);
  void (*v55)(uint64_t);
  id v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      v6 = (unsigned __int8 **)v3[19];
      v7 = v6;
      if (v6)
      {
        v8 = v6[1];
        v9 = MEMORY[0x1E0C809B0];
        if (v8)
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = buf;
          *(_QWORD *)&buf[16] = 0x3032000000;
          v54 = __Block_byref_object_copy__19149;
          v55 = __Block_byref_object_dispose__19150;
          v56 = 0;
          v48[0] = MEMORY[0x1E0C809B0];
          v48[1] = 3221225472;
          v48[2] = __nw_parameters_copy_protocol_options_for_definition_block_invoke;
          v48[3] = &unk_1E14AB5F0;
          v49 = v5;
          v50 = buf;
          nw_array_apply(v8, (uint64_t)v48);
          v10 = *(void **)(*(_QWORD *)&buf[8] + 40);
          if (v10)
          {
            v11 = v10;

            _Block_object_dispose(buf, 8);
LABEL_25:

            goto LABEL_26;
          }

          _Block_object_dispose(buf, 8);
        }
        v12 = v7[2];
        if (v12)
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = buf;
          *(_QWORD *)&buf[16] = 0x3032000000;
          v54 = __Block_byref_object_copy__19149;
          v55 = __Block_byref_object_dispose__19150;
          v56 = 0;
          v45[0] = v9;
          v45[1] = 3221225472;
          v45[2] = __nw_parameters_copy_protocol_options_for_definition_block_invoke_2;
          v45[3] = &unk_1E14AB5F0;
          v46 = v5;
          v47 = buf;
          nw_array_apply(v12, (uint64_t)v45);
          v13 = *(void **)(*(_QWORD *)&buf[8] + 40);
          if (v13)
          {
            v11 = v13;

            _Block_object_dispose(buf, 8);
            goto LABEL_25;
          }

          _Block_object_dispose(buf, 8);
        }
        v14 = v7[3];
        if (v14)
        {
          v15 = v14;
          v16 = v15[1];

          if (nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v16))
          {
            v11 = v7[3];

            goto LABEL_25;
          }

        }
        v17 = v7[4];
        if (v17)
        {
          v18 = v17;
          v19 = v18[1];

          if (nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v19))
          {
            v11 = v7[4];

            goto LABEL_25;
          }

        }
        v20 = v7[6];
        if (v20)
        {
          v21 = v20;
          v22 = v21[1];

          if (nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v22))
          {
            v11 = v7[6];

            goto LABEL_25;
          }

        }
LABEL_24:
        v11 = 0;
        goto LABEL_25;
      }
      __nwlog_obj();
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
      v31 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (__nwlog_fault(v31, &type, &v51))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v32 = objc_claimAutoreleasedReturnValue();
          v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
            _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s called with null stack", buf, 0xCu);
          }
        }
        else if (v51)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v32 = objc_claimAutoreleasedReturnValue();
          v40 = type;
          v41 = os_log_type_enabled(v32, type);
          if (backtrace_string)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v32, v40, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_78;
          }
          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
            _os_log_impl(&dword_182FBE000, v32, v40, "%{public}s called with null stack, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v32 = objc_claimAutoreleasedReturnValue();
          v44 = type;
          if (os_log_type_enabled(v32, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
            _os_log_impl(&dword_182FBE000, v32, v44, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_78:
      if (v31)
        free(v31);
      goto LABEL_24;
    }
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v25, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
          _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null definition", buf, 0xCu);
        }
LABEL_71:

        goto LABEL_72;
      }
      if (!v51)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v43 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
          _os_log_impl(&dword_182FBE000, v26, v43, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_71;
      }
      v34 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      v38 = os_log_type_enabled(v26, type);
      if (!v34)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
          _os_log_impl(&dword_182FBE000, v26, v37, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v34;
        _os_log_impl(&dword_182FBE000, v26, v37, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_51;
    }
  }
  else
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v25, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null parameters", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (!v51)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
          _os_log_impl(&dword_182FBE000, v26, v42, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_71;
      }
      v34 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      v36 = os_log_type_enabled(v26, type);
      if (!v34)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
          _os_log_impl(&dword_182FBE000, v26, v35, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_parameters_copy_protocol_options_for_definition";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v34;
        _os_log_impl(&dword_182FBE000, v26, v35, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_51:

      free(v34);
    }
  }
LABEL_72:
  if (v25)
    free(v25);
  v11 = 0;
LABEL_26:

  return v11;
}

void sub_1831D6470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t nw_socket_set_common_sockopts(nw_protocol *a1)
{
  void *handle;
  nw_protocol **p_output_handler;
  nw_protocol **v3;
  nw_protocol_identifier *identifier;
  uint64_t v6;
  uint64_t (*v7)(_QWORD);
  void *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  uint64_t v12;
  nw_protocol_identifier *v13;
  uint64_t v14;
  uint64_t (*v15)(_QWORD);
  void *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  NSObject *v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t v26;
  void (**v27)(_QWORD);
  const void *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  _BOOL4 v33;
  uint64_t v34;
  uint64_t v35;
  void (**v36)(_QWORD);
  const void *v37;
  char *v38;
  _BOOL4 v39;
  char *v40;
  int v41;
  NSObject *v42;
  NSObject *v43;
  const char *v44;
  uint64_t v45;
  NSObject *v46;
  NSObject *v47;
  const char *v48;
  int v49;
  NSObject *v50;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  char *v55;
  _BOOL4 v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  const char *v60;
  nw_protocol **v61;
  char *v62;
  _BOOL4 v63;
  nw_protocol **v64;
  char *v65;
  _BOOL4 v66;
  char *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  NSObject *v72;
  int v73;
  int v74;
  NSObject *v75;
  NSObject *v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  const char *v80;
  nw_protocol **v81;
  char *v82;
  _BOOL4 v83;
  pid_t v84;
  char *v85;
  char *v86;
  int v87;
  _BOOL4 v89;
  char *v90;
  int v91;
  int v92;
  NSObject *v93;
  char *v94;
  char *v95;
  int v96;
  int v97;
  NSObject *v98;
  NSObject *v99;
  BOOL v100;
  char *v101;
  int v102;
  NSObject *v103;
  uint64_t v104;
  const char *v105;
  NSObject *v106;
  os_log_type_t v107;
  uint32_t v108;
  char *v109;
  NSObject *v110;
  os_log_type_t v111;
  const char *v112;
  uint64_t v113;
  NSObject *v114;
  char *v115;
  NSObject *v116;
  os_log_type_t v117;
  _BOOL4 v118;
  uint64_t v119;
  nw_protocol **v120;
  char *v121;
  NSObject *v122;
  os_log_type_t v123;
  const char *v124;
  NSObject *v125;
  os_log_type_t v126;
  char *v127;
  BOOL v128;
  char *v129;
  BOOL v130;
  NSObject *v131;
  char *v132;
  BOOL v133;
  int v134;
  NSObject *v135;
  NSObject *v136;
  NSObject *v137;
  char *v138;
  _BOOL4 v139;
  nw_protocol **v140;
  char *v141;
  NSObject *v142;
  os_log_type_t v143;
  const char *v144;
  char *v145;
  _BOOL4 v146;
  char *v147;
  _BOOL4 v148;
  char *v150;
  BOOL v151;
  int v152;
  NSObject *v153;
  NSObject *v154;
  NSObject *v155;
  NSObject *v156;
  _QWORD *v157;
  nw_protocol **v158;
  char *v159;
  NSObject *v160;
  os_log_type_t v161;
  const char *v162;
  char *v163;
  NSObject *v164;
  os_log_type_t v165;
  _BOOL4 v166;
  NSObject *v167;
  os_log_type_t v168;
  _QWORD *v169;
  BOOL v170;
  int v171;
  NSObject *v172;
  NSObject *v173;
  NSObject *v174;
  NSObject *v175;
  _QWORD *v176;
  nw_protocol **v177;
  char *v178;
  NSObject *v179;
  os_log_type_t v180;
  const char *v181;
  char *v182;
  NSObject *v183;
  os_log_type_t v184;
  _BOOL4 v185;
  NSObject *v186;
  os_log_type_t v187;
  NSObject *v188;
  NSObject *v189;
  nw_protocol_options_t v190;
  nw_protocol_options_t v191;
  int v192;
  int v193;
  NSObject *v194;
  NSObject *v195;
  NSObject *v196;
  _QWORD *v197;
  char *v198;
  NSObject *v199;
  os_log_type_t v200;
  const char *v201;
  char *v202;
  _BOOL4 v203;
  int v204;
  NSObject *v205;
  NSObject *v206;
  NSObject *v207;
  const char *v208;
  int v209;
  NSObject *v210;
  NSObject *v211;
  _QWORD *v212;
  char *v213;
  NSObject *v214;
  os_log_type_t v215;
  const char *v216;
  char *v217;
  _BOOL4 v218;
  char *v219;
  _BOOL4 v220;
  char *v221;
  _BOOL4 v223;
  int v224;
  NSObject *v225;
  NSObject *v226;
  NSObject *v227;
  const char *v228;
  int v229;
  NSObject *v230;
  NSObject *v231;
  _QWORD *v232;
  char *v233;
  NSObject *v234;
  os_log_type_t v235;
  const char *v236;
  char *v237;
  _BOOL4 v238;
  char *v239;
  _BOOL4 v240;
  NSObject *v241;
  int v242;
  NSObject *v243;
  NSObject *v244;
  NSObject *v245;
  int v246;
  int v247;
  NSObject *v248;
  NSObject *v249;
  NSObject *v250;
  char *v251;
  NSObject *v252;
  os_log_type_t v253;
  const char *v254;
  _QWORD *v255;
  char *v256;
  NSObject *v257;
  os_log_type_t v258;
  const char *v259;
  char *v260;
  _BOOL4 v261;
  char *v262;
  _BOOL4 v263;
  int v264;
  NSObject *v265;
  NSObject *v266;
  NSObject *v267;
  _QWORD *v268;
  char *v269;
  NSObject *v270;
  os_log_type_t v271;
  const char *v272;
  char *v273;
  _BOOL4 v274;
  int local_address_preference;
  int v276;
  NSObject *v277;
  NSObject *v278;
  NSObject *v279;
  _QWORD *v280;
  char *v281;
  NSObject *v282;
  os_log_type_t v283;
  const char *v284;
  char *v285;
  _BOOL4 v286;
  int is_multicast;
  _BOOL4 disable_multicast_loopback;
  int *v289;
  int v290;
  NSObject *v291;
  NSObject *v292;
  NSObject *v293;
  const char *v294;
  NSObject *v295;
  os_log_type_t v296;
  uint32_t v297;
  int v298;
  int *v299;
  int v300;
  NSObject *v301;
  NSObject *v302;
  NSObject *v303;
  _QWORD *v304;
  char *v305;
  NSObject *v306;
  os_log_type_t v307;
  const char *v308;
  _QWORD *v309;
  char *v310;
  NSObject *v311;
  os_log_type_t v312;
  const char *v313;
  char *v314;
  _BOOL4 v315;
  char *v316;
  char *v317;
  _BOOL4 v318;
  NSObject *v319;
  const char *v320;
  NSObject *v321;
  _BOOL4 v322;
  int ecn_mode;
  int v324;
  int v325;
  int v326;
  NSObject *v327;
  NSObject *v328;
  NSObject *v329;
  int v330;
  NSObject *v331;
  NSObject *v332;
  NSObject *v333;
  NSObject *v334;
  _QWORD *v335;
  char *v336;
  NSObject *v337;
  os_log_type_t v338;
  const char *v339;
  NSObject *v340;
  _QWORD *v341;
  char *v342;
  NSObject *v343;
  os_log_type_t v344;
  const char *v345;
  char *v346;
  _BOOL4 v347;
  char *v348;
  _BOOL4 v349;
  int enable_l4s;
  int v351;
  NSObject *v352;
  NSObject *v353;
  NSObject *v354;
  NSObject *v355;
  _QWORD *v356;
  char *v357;
  NSObject *v358;
  os_log_type_t v359;
  const char *v360;
  char *v361;
  _BOOL4 v362;
  int v363;
  NSObject *v364;
  NSObject *v365;
  const char *v366;
  int v367;
  NSObject *v368;
  _QWORD *v369;
  char *v370;
  NSObject *v371;
  os_log_type_t v372;
  const char *v373;
  char *v374;
  _BOOL4 v375;
  char *v376;
  _BOOL4 v377;
  int v378;
  NSObject *v379;
  NSObject *v380;
  NSObject *v381;
  NSObject *v382;
  _QWORD *v383;
  char *v384;
  NSObject *v385;
  os_log_type_t v386;
  const char *v387;
  char *v388;
  _BOOL4 v389;
  int v390;
  NSObject *v391;
  NSObject *v392;
  NSObject *v393;
  NSObject *v394;
  _QWORD *v395;
  char *v396;
  NSObject *v397;
  os_log_type_t v398;
  const char *v399;
  char *v400;
  _BOOL4 v401;
  nw_multipath_service_t multipath_service;
  int v403;
  nw_multipath_service_t v404;
  int v405;
  uint64_t v406;
  NSObject *v407;
  NSObject *v408;
  uint64_t v409;
  NSObject *v410;
  NSObject *v411;
  NSObject *v412;
  char *v413;
  NSObject *v414;
  os_log_type_t v415;
  const char *v416;
  char *v417;
  _BOOL4 v418;
  char *v419;
  char *v420;
  uint64_t v421;
  os_log_type_t v422;
  const char *v423;
  _QWORD *v424;
  NSObject *v425;
  char *v426;
  NSObject *v427;
  os_log_type_t v428;
  const char *v429;
  char *v430;
  NSObject *v431;
  _BOOL4 v432;
  uint64_t v433;
  char *v434;
  NSObject *v435;
  os_log_type_t v436;
  _BOOL4 v437;
  int v438;
  NSObject *v439;
  NSObject *v440;
  _QWORD *v441;
  char *v442;
  NSObject *v443;
  os_log_type_t v444;
  const char *v445;
  char *v446;
  _BOOL4 v447;
  NSObject *v448;
  uint64_t v449;
  NSObject *v450;
  NSObject *v451;
  NSObject *v452;
  _QWORD *v453;
  NSObject *v454;
  char *v455;
  NSObject *v456;
  os_log_type_t v457;
  const char *v458;
  char *v459;
  NSObject *v460;
  _BOOL4 v461;
  NSObject *v462;
  NSObject *v463;
  NSObject *v464;
  NSObject *v465;
  NWConcrete_nw_parameters *v466;
  BOOL v467;
  void *v468;
  int output_handler_high;
  const void *bytes_ptr;
  socklen_t length;
  NSObject *v472;
  NSObject *v473;
  NSObject *v474;
  const char *v475;
  id v476;
  int do_not_log_trackers;
  uint64_t v478;
  const char *v479;
  NSObject *v480;
  NSObject *v481;
  uint64_t v482;
  const char *v483;
  NSObject *v484;
  os_log_type_t v485;
  uint32_t v486;
  char *v487;
  NSObject *v488;
  os_log_type_t v489;
  const char *v490;
  NSObject *v491;
  NSObject *v492;
  int v493;
  NSObject *v494;
  char *v495;
  _BOOL4 v496;
  const char *v497;
  NSObject *v498;
  NSObject *v499;
  char *v500;
  _BOOL4 v501;
  int v502;
  NSObject *v503;
  _BOOL4 v504;
  char *v505;
  NSObject *v506;
  os_log_type_t v507;
  const char *v508;
  char *v509;
  NSObject *v510;
  os_log_type_t v511;
  const char *v512;
  _BOOL4 v513;
  char *v514;
  NSObject *v515;
  os_log_type_t v516;
  const char *v517;
  char *v518;
  _BOOL4 v519;
  char *v520;
  _BOOL4 v521;
  char *v522;
  _BOOL4 v523;
  NSObject *v524;
  os_log_type_t v525;
  uint32_t v526;
  int v527;
  char *v528;
  _BOOL4 v529;
  NSObject *v530;
  os_log_type_t v531;
  int v532;
  _QWORD *v533;
  NSObject *v534;
  NSObject *v535;
  NSObject *v536;
  NSObject *v537;
  nw_protocol **v538;
  nw_protocol **v539;
  uint64_t v540;
  uint64_t v541;
  void *path;
  int default_input_handler_low;
  char v544;
  os_log_type_t v545[4];
  os_log_type_t v546;
  os_log_type_t v547[4];
  os_log_type_t v548[4];
  os_log_type_t type[4];
  int v550;
  int v551;
  uint8_t buf[4];
  const char *v553;
  __int16 v554;
  _BYTE v555[24];
  __int128 v556;
  unsigned __int8 uu[16];
  uint64_t v558;

  v558 = *MEMORY[0x1E0C80C00];
  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle)
    v3 = &a1[1].output_handler;
  else
    v3 = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v553 = "nw_socket_set_common_sockopts";
    v221 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (!__nwlog_fault(v221, uu, &v556))
      goto LABEL_97;
    if (uu[0] == 17)
    {
      v9 = __nwlog_obj();
      v10 = uu[0];
      if (os_log_type_enabled(v9, (os_log_type_t)uu[0]))
      {
        *(_DWORD *)buf = 136446210;
        v553 = "nw_socket_set_common_sockopts";
        v11 = "%{public}s called with null socket_handler";
LABEL_96:
        _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
        goto LABEL_97;
      }
      goto LABEL_97;
    }
    if (!(_BYTE)v556)
    {
      v9 = __nwlog_obj();
      v10 = uu[0];
      if (os_log_type_enabled(v9, (os_log_type_t)uu[0]))
      {
        *(_DWORD *)buf = 136446210;
        v553 = "nw_socket_set_common_sockopts";
        v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_96;
      }
LABEL_97:
      if (v221)
        free(v221);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = uu[0];
    v223 = os_log_type_enabled(v9, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (v223)
      {
        *(_DWORD *)buf = 136446210;
        v553 = "nw_socket_set_common_sockopts";
        v11 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_96;
      }
      goto LABEL_97;
    }
    if (v223)
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2082;
      *(_QWORD *)v555 = backtrace_string;
      v19 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_69;
    }
LABEL_70:
    free(backtrace_string);
    goto LABEL_97;
  }
  if ((HIDWORD(a1[4].output_handler) & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v553 = "nw_socket_set_common_sockopts";
    v221 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (!__nwlog_fault(v221, uu, &v556))
      goto LABEL_97;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null socket_handler->fd";
      goto LABEL_96;
    }
    if (!(_BYTE)v556)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null socket_handler->fd, backtrace limit exceeded";
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = uu[0];
    v18 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null socket_handler->fd, no backtrace";
      goto LABEL_96;
    }
    if (!v18)
      goto LABEL_70;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2082;
    *(_QWORD *)v555 = backtrace_string;
    v19 = "%{public}s called with null socket_handler->fd, dumping backtrace:%{public}s";
LABEL_69:
    _os_log_impl(&dword_182FBE000, v9, v10, v19, buf, 0x16u);
    goto LABEL_70;
  }
  identifier = a1[2].identifier;
  if (!identifier)
    goto LABEL_25;
  v6 = *(_QWORD *)&identifier->name[24];
  if (!v6)
    goto LABEL_25;
  v7 = *(uint64_t (**)(_QWORD))(v6 + 136);
  if (!v7)
    goto LABEL_25;
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    v12 = *(_QWORD *)&identifier[2].name[8];
    if (v12)
      *(_QWORD *)&identifier[2].name[8] = v12 + 1;
    v8 = (void *)v7(identifier);
    if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
    {
      v25 = *(_QWORD *)&identifier[2].name[8];
      if (v25)
      {
        v26 = v25 - 1;
        *(_QWORD *)&identifier[2].name[8] = v26;
        if (!v26)
        {
          v27 = *(void (***)(_QWORD))&identifier[1].name[24];
          if (v27)
          {
            *(_QWORD *)&identifier[1].name[24] = 0;
            v27[2](v27);
            _Block_release(v27);
          }
          if ((identifier[1].level & 1) != 0)
          {
            v28 = *(const void **)&identifier[1].name[24];
            if (v28)
              _Block_release(v28);
          }
          free(identifier);
        }
      }
    }
  }
  else
  {
    v8 = (void *)v7(a1[2].identifier);
  }
  if (!v8)
  {
LABEL_25:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v553 = "nw_socket_set_common_sockopts";
    v221 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (!__nwlog_fault(v221, uu, &v556))
      goto LABEL_97;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null remote_endpoint";
      goto LABEL_96;
    }
    if (!(_BYTE)v556)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null remote_endpoint, backtrace limit exceeded";
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = uu[0];
    v24 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (!v24)
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null remote_endpoint, no backtrace";
      goto LABEL_96;
    }
    if (!v24)
      goto LABEL_70;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2082;
    *(_QWORD *)v555 = backtrace_string;
    v19 = "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s";
    goto LABEL_69;
  }
  v13 = a1[2].identifier;
  if (!v13)
    goto LABEL_45;
  v14 = *(_QWORD *)&v13->name[24];
  if (!v14)
    goto LABEL_45;
  v15 = *(uint64_t (**)(_QWORD))(v14 + 112);
  if (!v15)
    goto LABEL_45;
  if (*(_UNKNOWN **)v13[1].name == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)&v13[2].name[8];
    if (v20)
      *(_QWORD *)&v13[2].name[8] = v20 + 1;
    v16 = (void *)v15(v13);
    if (*(_UNKNOWN **)v13[1].name == &nw_protocol_ref_counted_handle)
    {
      v34 = *(_QWORD *)&v13[2].name[8];
      if (v34)
      {
        v35 = v34 - 1;
        *(_QWORD *)&v13[2].name[8] = v35;
        if (!v35)
        {
          v36 = *(void (***)(_QWORD))&v13[1].name[24];
          if (v36)
          {
            *(_QWORD *)&v13[1].name[24] = 0;
            v36[2](v36);
            _Block_release(v36);
          }
          if ((v13[1].level & 1) != 0)
          {
            v37 = *(const void **)&v13[1].name[24];
            if (v37)
              _Block_release(v37);
          }
          free(v13);
        }
      }
    }
  }
  else
  {
    v16 = (void *)v15(a1[2].identifier);
  }
  if (!v16)
  {
LABEL_45:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v553 = "nw_socket_set_common_sockopts";
    v221 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (!__nwlog_fault(v221, uu, &v556))
      goto LABEL_97;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null parameters";
      goto LABEL_96;
    }
    if (!(_BYTE)v556)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = uu[0];
    v33 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (!v33)
        goto LABEL_97;
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      v11 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_96;
    }
    if (!v33)
      goto LABEL_70;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2082;
    *(_QWORD *)v555 = backtrace_string;
    v19 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
    goto LABEL_69;
  }
  v541 = (uint64_t)v3;
  path = (void *)nw_socket_get_path(a1);
  v550 = 0;
  v551 = 1;
  default_input_handler_low = LOBYTE(a1[6].default_input_handler);
  if (!setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4130, &v551, 4u))
    goto LABEL_106;
  v21 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v22 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(_QWORD *)v555 = (char *)a1 + 436;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v21;
    _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v23 = gLogObj;
  if (v21 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_106;
  }
  *(_DWORD *)buf = 136446466;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v21;
  v532 = 18;
  v29 = (char *)_os_log_send_and_compose_impl();
  uu[0] = 16;
  LOBYTE(v556) = 0;
  if (__nwlog_fault(v29, uu, &v556))
  {
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = gLogObj;
      v31 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_104;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v21;
      v32 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d";
      goto LABEL_103;
    }
    if (!(_BYTE)v556)
    {
      v30 = __nwlog_obj();
      v31 = uu[0];
      if (!os_log_type_enabled(v30, (os_log_type_t)uu[0]))
        goto LABEL_104;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v21;
      v32 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_103;
    }
    v538 = p_output_handler;
    v38 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = gLogObj;
    v31 = uu[0];
    v39 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v21;
        *(_WORD *)&v555[4] = 2082;
        *(_QWORD *)&v555[6] = v38;
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v38);
      p_output_handler = v538;
      goto LABEL_104;
    }
    p_output_handler = v538;
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v21;
      v32 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, no backtrace";
LABEL_103:
      _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0x12u);
    }
  }
LABEL_104:
  if (v29)
    free(v29);
LABEL_106:
  if (ioctl(HIDWORD(a1[4].output_handler), 0x8004667EuLL, &v551, v532) < 0)
  {
    v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v46 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v45;
      _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_ERROR, "%{public}s %s FIONBIO failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v47 = gLogObj;
    if ((_DWORD)v45 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        v48 = "%{public}s FIONBIO failed %{darwin.errno}d";
LABEL_287:
        _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_ERROR, v48, buf, 0x12u);
      }
LABEL_327:
      v71 = (uint64_t)p_output_handler;
LABEL_328:
      v70 = v45;
      goto LABEL_329;
    }
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v45;
    v51 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (!__nwlog_fault(v51, uu, &v556))
      goto LABEL_325;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v52 = gLogObj;
      v53 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]))
        goto LABEL_325;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v54 = "%{public}s FIONBIO failed %{darwin.errno}d";
    }
    else if ((_BYTE)v556)
    {
      v55 = (char *)__nw_create_backtrace_string();
      v52 = __nwlog_obj();
      v53 = uu[0];
      v56 = os_log_type_enabled(v52, (os_log_type_t)uu[0]);
      if (v55)
      {
        if (v56)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v45;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v55;
          _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s FIONBIO failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v55);
        if (!v51)
          goto LABEL_327;
        goto LABEL_326;
      }
      if (!v56)
        goto LABEL_325;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v54 = "%{public}s FIONBIO failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v52 = __nwlog_obj();
      v53 = uu[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)uu[0]))
        goto LABEL_325;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v54 = "%{public}s FIONBIO failed %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_324:
    _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0x12u);
    goto LABEL_325;
  }
  memset(uu, 0, sizeof(uu));
  v40 = v16;
  *(_OWORD *)uu = *(_OWORD *)(v40 + 24);

  if (uuid_is_null(uu))
  {
    if (uuid_is_null(a1->flow_id) || !setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4369, a1, 0x10u))
      goto LABEL_179;
    v41 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v42 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v41;
      _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d", buf, 0x1Cu);
    }
    if (v41 == 2 || v41 == 22)
    {
      v43 = __nwlog_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v41;
        v44 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d";
LABEL_134:
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, v44, buf, 0x12u);
        goto LABEL_179;
      }
      goto LABEL_179;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v41;
    v57 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v556) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v57, &v556, type) & 1) == 0)
      goto LABEL_177;
    if (v556 == 17)
    {
      v58 = __nwlog_obj();
      v59 = v556;
      if (!os_log_type_enabled(v58, (os_log_type_t)v556))
        goto LABEL_177;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      v60 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d";
      goto LABEL_176;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v58 = __nwlog_obj();
      v59 = v556;
      if (!os_log_type_enabled(v58, (os_log_type_t)v556))
        goto LABEL_177;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      v60 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_176;
    }
    v64 = p_output_handler;
    v65 = (char *)__nw_create_backtrace_string();
    v58 = __nwlog_obj();
    v59 = v556;
    v66 = os_log_type_enabled(v58, (os_log_type_t)v556);
    if (!v65)
    {
      p_output_handler = v64;
      if (!v66)
        goto LABEL_177;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      v60 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, no backtrace";
      goto LABEL_176;
    }
    if (v66)
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v41;
      *(_WORD *)&v555[4] = 2082;
      *(_QWORD *)&v555[6] = v65;
      _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
    free(v65);
    p_output_handler = v64;
LABEL_177:
    if (!v57)
      goto LABEL_179;
    goto LABEL_178;
  }
  if (!setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4384, uu, 0x10u))
    goto LABEL_179;
  v49 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v50 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(_QWORD *)v555 = (char *)a1 + 436;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v49;
    _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d", buf, 0x1Cu);
  }
  if (v49 != 2 && v49 != 22)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v49;
    v57 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v556) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v57, &v556, type) & 1) == 0)
      goto LABEL_177;
    if (v556 == 17)
    {
      v58 = __nwlog_obj();
      v59 = v556;
      if (!os_log_type_enabled(v58, (os_log_type_t)v556))
        goto LABEL_177;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v49;
      v60 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d";
    }
    else
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v58 = __nwlog_obj();
        v59 = v556;
        if (!os_log_type_enabled(v58, (os_log_type_t)v556))
          goto LABEL_177;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v49;
        v60 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_176;
      }
      v61 = p_output_handler;
      v62 = (char *)__nw_create_backtrace_string();
      v58 = __nwlog_obj();
      v59 = v556;
      v63 = os_log_type_enabled(v58, (os_log_type_t)v556);
      if (v62)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v49;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v62;
          _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v62);
        p_output_handler = v61;
        if (!v57)
          goto LABEL_179;
LABEL_178:
        free(v57);
        goto LABEL_179;
      }
      p_output_handler = v61;
      if (!v63)
        goto LABEL_177;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v49;
      v60 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d, no backtrace";
    }
LABEL_176:
    _os_log_impl(&dword_182FBE000, v58, v59, v60, buf, 0x12u);
    goto LABEL_177;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v43 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v49;
    v44 = "%{public}s setsockopt SO_NECP_LISTENUUID failed %{darwin.errno}d";
    goto LABEL_134;
  }
LABEL_179:
  v67 = v40;
  v68 = *(_DWORD *)(*((_QWORD *)v67 + 13) + 72);

  if (v68)
  {
    v69 = nw_socket_set_traffic_class((uint64_t)p_output_handler, v68);
    if ((_DWORD)v69)
    {
      v70 = v69;
      v71 = (uint64_t)p_output_handler;
LABEL_329:
      nw_socket_internal_error(v71, v70);
      return 0;
    }
  }
  v72 = v8;
  v73 = -[NSObject type](v72, "type");

  if (v73 == 1
    && default_input_handler_low == 2
    && setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 0x20000, &v551, 4u))
  {
    v74 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v75 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v74;
      _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v76 = gLogObj;
    if (v74 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_208;
    }
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v74;
    v77 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v556) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v77, &v556, type))
      goto LABEL_206;
    if (v556 == 17)
    {
      v78 = __nwlog_obj();
      v79 = v556;
      if (!os_log_type_enabled(v78, (os_log_type_t)v556))
        goto LABEL_206;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v74;
      v80 = "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d";
    }
    else if (type[0])
    {
      v81 = p_output_handler;
      v82 = (char *)__nw_create_backtrace_string();
      v78 = __nwlog_obj();
      v79 = v556;
      v83 = os_log_type_enabled(v78, (os_log_type_t)v556);
      if (v82)
      {
        if (v83)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v74;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v82;
          _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v82);
        p_output_handler = v81;
        goto LABEL_206;
      }
      p_output_handler = v81;
      if (!v83)
      {
LABEL_206:
        if (v77)
          free(v77);
        goto LABEL_208;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v74;
      v80 = "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v78 = __nwlog_obj();
      v79 = v556;
      if (!os_log_type_enabled(v78, (os_log_type_t)v556))
        goto LABEL_206;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v74;
      v80 = "%{public}s setsockopt SO_NOAPNFALLBK failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v78, v79, v80, buf, 0x12u);
    goto LABEL_206;
  }
LABEL_208:
  v84 = getpid();
  v85 = v67;
  v86 = v85;
  v87 = *(_DWORD *)(*((_QWORD *)v67 + 13) + 64);
  v89 = v87 > 0 && v87 != v84;

  if (v89)
  {
    LODWORD(v556) = 0;
    v90 = v86;
    v91 = *(_DWORD *)(*((_QWORD *)v67 + 13) + 64);

    LODWORD(v556) = v91;
    if (!setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4359, &v556, 4u))
    {
      if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v113 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 2082;
          *(_QWORD *)v555 = (char *)a1 + 436;
          *(_WORD *)&v555[8] = 1024;
          *(_DWORD *)&v555[10] = v556;
          v105 = "%{public}s %{public}s successfully set source application pid to %d";
          v106 = v113;
          v107 = OS_LOG_TYPE_DEBUG;
          v108 = 28;
          goto LABEL_259;
        }
      }
      goto LABEL_222;
    }
    v92 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v93 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v556;
      *(_WORD *)&v555[14] = 1024;
      *(_DWORD *)&v555[16] = v92;
      _os_log_impl(&dword_182FBE000, v93, OS_LOG_TYPE_ERROR, "%{public}s %s set source pid to %d failed %{darwin.errno}d", buf, 0x22u);
    }
  }
  v94 = v86;
  if (uuid_is_null((const unsigned __int8 *)(*((_QWORD *)v67 + 13) + 24)))
  {

    goto LABEL_222;
  }
  v100 = uuid_compare((const unsigned __int8 *)(*((_QWORD *)v67 + 13) + 24), (const unsigned __int8 *)(*((_QWORD *)v67 + 13) + 8)) == 0;

  if (v100)
    goto LABEL_222;
  v556 = 0uLL;
  v101 = v94;
  v556 = *(_OWORD *)(*((_QWORD *)v67 + 13) + 24);

  if (setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4360, &v556, 0x10u))
  {
    v102 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v103 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v102;
      _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_ERROR, "%{public}s %s set source app uuid failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v104 = gLogObj;
    if (v102 == 22)
    {
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_222;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      v105 = "%{public}s set source app uuid failed %{darwin.errno}d";
      v106 = v104;
      v107 = OS_LOG_TYPE_ERROR;
      v108 = 18;
LABEL_259:
      _os_log_impl(&dword_182FBE000, v106, v107, v105, buf, v108);
      goto LABEL_222;
    }
    v120 = p_output_handler;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v102;
    v121 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v548[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v121, type, v548))
      goto LABEL_421;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v122 = __nwlog_obj();
      v123 = type[0];
      if (os_log_type_enabled(v122, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v102;
        v124 = "%{public}s set source app uuid failed %{darwin.errno}d";
LABEL_420:
        _os_log_impl(&dword_182FBE000, v122, v123, v124, buf, 0x12u);
      }
    }
    else if (v548[0])
    {
      v536 = v72;
      v147 = (char *)__nw_create_backtrace_string();
      v122 = __nwlog_obj();
      v123 = type[0];
      v148 = os_log_type_enabled(v122, type[0]);
      if (v147)
      {
        if (v148)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v102;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v147;
          _os_log_impl(&dword_182FBE000, v122, v123, "%{public}s set source app uuid failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v147);
        v72 = v536;
        goto LABEL_421;
      }
      v72 = v536;
      if (v148)
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v102;
        v124 = "%{public}s set source app uuid failed %{darwin.errno}d, no backtrace";
        goto LABEL_420;
      }
    }
    else
    {
      v122 = __nwlog_obj();
      v123 = type[0];
      if (os_log_type_enabled(v122, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v102;
        v124 = "%{public}s set source app uuid failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_420;
      }
    }
LABEL_421:
    if (v121)
      free(v121);
    p_output_handler = v120;
    goto LABEL_222;
  }
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v119 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2082;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1042;
      *(_DWORD *)&v555[10] = 16;
      *(_WORD *)&v555[14] = 2098;
      *(_QWORD *)&v555[16] = &v556;
      v105 = "%{public}s %{public}s successfully set source application uuid to %{public,uuid_t}.16P";
      v106 = v119;
      v107 = OS_LOG_TYPE_DEBUG;
      v108 = 38;
      goto LABEL_259;
    }
  }
LABEL_222:
  LODWORD(v556) = 0;
  v95 = v86;
  v96 = *(unsigned __int8 *)(*((_QWORD *)v67 + 13) + 107);

  LODWORD(v556) = v96;
  if (!v96 || !setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4400, &v556, 4u))
    goto LABEL_271;
  v97 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v98 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446978;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(_QWORD *)v555 = (char *)a1 + 436;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v556;
    *(_WORD *)&v555[14] = 1024;
    *(_DWORD *)&v555[16] = v97;
    _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d", buf, 0x22u);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v99 = gLogObj;
  if (v97 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v556;
      *(_WORD *)&v555[4] = 1024;
      *(_DWORD *)&v555[6] = 22;
      _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d", buf, 0x18u);
    }
    goto LABEL_271;
  }
  v539 = p_output_handler;
  *(_DWORD *)buf = 136446722;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v556;
  *(_WORD *)&v555[4] = 1024;
  *(_DWORD *)&v555[6] = v97;
  v109 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v548[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v109, type, v548))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v110 = __nwlog_obj();
      v111 = type[0];
      if (os_log_type_enabled(v110, type[0]))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v556;
        *(_WORD *)&v555[4] = 1024;
        *(_DWORD *)&v555[6] = v97;
        v112 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d";
LABEL_266:
        v125 = v110;
        v126 = v111;
LABEL_267:
        _os_log_impl(&dword_182FBE000, v125, v126, v112, buf, 0x18u);
      }
    }
    else if (v548[0])
    {
      v114 = v72;
      v115 = (char *)__nw_create_backtrace_string();
      v116 = __nwlog_obj();
      v117 = type[0];
      v118 = os_log_type_enabled(v116, type[0]);
      if (v115)
      {
        if (v118)
        {
          *(_DWORD *)buf = 136446978;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v556;
          *(_WORD *)&v555[4] = 1024;
          *(_DWORD *)&v555[6] = v97;
          *(_WORD *)&v555[10] = 2082;
          *(_QWORD *)&v555[12] = v115;
          _os_log_impl(&dword_182FBE000, v116, v117, "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v115);
        v72 = v114;
        goto LABEL_268;
      }
      v72 = v114;
      if (v118)
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v556;
        *(_WORD *)&v555[4] = 1024;
        *(_DWORD *)&v555[6] = v97;
        v112 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, no backtrace";
        v125 = v116;
        v126 = v117;
        goto LABEL_267;
      }
    }
    else
    {
      v110 = __nwlog_obj();
      v111 = type[0];
      if (os_log_type_enabled(v110, type[0]))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v556;
        *(_WORD *)&v555[4] = 1024;
        *(_DWORD *)&v555[6] = v97;
        v112 = "%{public}s setsockopt SO_FALLBACK_MODE %d failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_266;
      }
    }
  }
LABEL_268:
  if (v109)
    free(v109);
  p_output_handler = v539;
LABEL_271:
  *(_DWORD *)type = 0;
  if (nw_parameters_get_prohibit_cellular(v95))
    *(_DWORD *)type |= 4u;
  v127 = v95;
  v128 = (*(_WORD *)(*((_QWORD *)v67 + 13) + 100) & 1) == 0;

  if (!v128)
    *(_DWORD *)type |= 8u;
  v129 = v127;
  v130 = (*(_WORD *)(*((_QWORD *)v67 + 13) + 100) & 2) == 0;

  if (v130)
  {
    if (!*(_DWORD *)type)
      goto LABEL_288;
  }
  else
  {
    *(_DWORD *)type |= 0x10u;
  }
  if (setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4225, type, 4u))
  {
    v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v131 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v45;
      _os_log_impl(&dword_182FBE000, v131, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v47 = gLogObj;
    if ((_DWORD)v45 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        v48 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d";
        goto LABEL_287;
      }
      goto LABEL_327;
    }
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v45;
    v51 = (char *)_os_log_send_and_compose_impl();
    v548[0] = OS_LOG_TYPE_ERROR;
    v547[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v51, v548, v547))
      goto LABEL_325;
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v52 = __nwlog_obj();
      v53 = v548[0];
      if (!os_log_type_enabled(v52, v548[0]))
        goto LABEL_325;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v54 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d";
      goto LABEL_324;
    }
    if (v547[0] == OS_LOG_TYPE_DEFAULT)
    {
      v52 = __nwlog_obj();
      v53 = v548[0];
      if (!os_log_type_enabled(v52, v548[0]))
        goto LABEL_325;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v54 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_324;
    }
    v138 = (char *)__nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = v548[0];
    v139 = os_log_type_enabled(v52, v548[0]);
    if (!v138)
    {
      if (!v139)
        goto LABEL_325;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v54 = "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d, no backtrace";
      goto LABEL_324;
    }
    if (v139)
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      *(_WORD *)&v555[4] = 2082;
      *(_QWORD *)&v555[6] = v138;
      _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s setsockopt SO_RESTRICT_DENY_EXPENSIVE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
    free(v138);
LABEL_325:
    if (!v51)
      goto LABEL_327;
LABEL_326:
    free(v51);
    goto LABEL_327;
  }
LABEL_288:
  v132 = v129;
  v133 = (*(_WORD *)(*((_QWORD *)v67 + 13) + 108) & 0x80) == 0;

  if (v133 || !setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 0x10000, &v551, 4u))
    goto LABEL_343;
  v134 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v135 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(_QWORD *)v555 = (char *)a1 + 436;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v134;
    _os_log_impl(&dword_182FBE000, v135, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", buf, 0x1Cu);
  }
  v136 = __nwlog_obj();
  v137 = v136;
  if (v134 == 22)
  {
    if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      _os_log_impl(&dword_182FBE000, v137, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_343;
  }
  v140 = p_output_handler;
  *(_DWORD *)buf = 136446466;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v134;
  v141 = (char *)_os_log_send_and_compose_impl();
  v548[0] = OS_LOG_TYPE_ERROR;
  v547[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v141, v548, v547))
  {
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v142 = __nwlog_obj();
      v143 = v548[0];
      if (os_log_type_enabled(v142, v548[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v134;
        v144 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d";
LABEL_339:
        _os_log_impl(&dword_182FBE000, v142, v143, v144, buf, 0x12u);
      }
    }
    else if (v547[0])
    {
      v535 = v72;
      v145 = (char *)__nw_create_backtrace_string();
      v142 = __nwlog_obj();
      v143 = v548[0];
      v146 = os_log_type_enabled(v142, v548[0]);
      if (v145)
      {
        if (v146)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v134;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v145;
          _os_log_impl(&dword_182FBE000, v142, v143, "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v145);
        v72 = v535;
        goto LABEL_340;
      }
      v72 = v535;
      if (v146)
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v134;
        v144 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, no backtrace";
        goto LABEL_339;
      }
    }
    else
    {
      v142 = __nwlog_obj();
      v143 = v548[0];
      if (os_log_type_enabled(v142, v548[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v134;
        v144 = "%{public}s setsockopt SO_NOWAKEFROMSLEEP failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_339;
      }
    }
  }
LABEL_340:
  if (v141)
    free(v141);
  p_output_handler = v140;
LABEL_343:
  v150 = v132;
  v151 = (v150[12] & 0x200) == 0;

  if (v151 || !setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4356, &v551, 4u))
    goto LABEL_368;
  v152 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v153 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(_QWORD *)v555 = (char *)a1 + 436;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v152;
    _os_log_impl(&dword_182FBE000, v153, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d", buf, 0x1Cu);
  }
  v154 = __nwlog_obj();
  v155 = v154;
  if (v152 == 22)
  {
    if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      _os_log_impl(&dword_182FBE000, v155, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_368;
  }
  v156 = v72;
  v157 = v150;
  v158 = p_output_handler;
  *(_DWORD *)buf = 136446466;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v152;
  v159 = (char *)_os_log_send_and_compose_impl();
  v548[0] = OS_LOG_TYPE_ERROR;
  v547[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v159, v548, v547))
  {
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v160 = __nwlog_obj();
      v161 = v548[0];
      if (os_log_type_enabled(v160, v548[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v152;
        v162 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d";
LABEL_363:
        v167 = v160;
        v168 = v161;
LABEL_364:
        _os_log_impl(&dword_182FBE000, v167, v168, v162, buf, 0x12u);
      }
    }
    else if (v547[0])
    {
      v163 = (char *)__nw_create_backtrace_string();
      v164 = __nwlog_obj();
      v165 = v548[0];
      v166 = os_log_type_enabled(v164, v548[0]);
      if (v163)
      {
        if (v166)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v152;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v163;
          _os_log_impl(&dword_182FBE000, v164, v165, "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v163);
        goto LABEL_365;
      }
      if (v166)
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v152;
        v162 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace";
        v167 = v164;
        v168 = v165;
        goto LABEL_364;
      }
    }
    else
    {
      v160 = __nwlog_obj();
      v161 = v548[0];
      if (os_log_type_enabled(v160, v548[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v152;
        v162 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_363;
      }
    }
  }
LABEL_365:
  if (v159)
    free(v159);
  p_output_handler = v158;
  v150 = v157;
  v72 = v156;
LABEL_368:
  v169 = v150;
  v170 = ((*(unsigned __int16 *)(*((_QWORD *)v67 + 13) + 108) | (*(unsigned __int8 *)(*((_QWORD *)v67 + 13) + 110) << 16)) & 0x10000) == 0;

  if (v170 || (setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4393, &v551, 4u) & 0x80000000) == 0)
    goto LABEL_395;
  v171 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v172 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(_QWORD *)v555 = (char *)a1 + 436;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v171;
    _os_log_impl(&dword_182FBE000, v172, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d", buf, 0x1Cu);
  }
  v173 = __nwlog_obj();
  v174 = v173;
  if (v171 == 22)
  {
    if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      _os_log_impl(&dword_182FBE000, v174, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_395;
  }
  v175 = v72;
  v176 = v150;
  v177 = p_output_handler;
  *(_DWORD *)buf = 136446466;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v171;
  v178 = (char *)_os_log_send_and_compose_impl();
  v548[0] = OS_LOG_TYPE_ERROR;
  v547[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v178, v548, v547))
  {
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v179 = __nwlog_obj();
      v180 = v548[0];
      if (os_log_type_enabled(v179, v548[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v171;
        v181 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d";
LABEL_390:
        v186 = v179;
        v187 = v180;
LABEL_391:
        _os_log_impl(&dword_182FBE000, v186, v187, v181, buf, 0x12u);
      }
    }
    else if (v547[0])
    {
      v182 = (char *)__nw_create_backtrace_string();
      v183 = __nwlog_obj();
      v184 = v548[0];
      v185 = os_log_type_enabled(v183, v548[0]);
      if (v182)
      {
        if (v185)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v171;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v182;
          _os_log_impl(&dword_182FBE000, v183, v184, "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v182);
        goto LABEL_392;
      }
      if (v185)
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v171;
        v181 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, no backtrace";
        v186 = v183;
        v187 = v184;
        goto LABEL_391;
      }
    }
    else
    {
      v179 = __nwlog_obj();
      v180 = v548[0];
      if (os_log_type_enabled(v179, v548[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v171;
        v181 = "%{public}s setsockopt SO_MARK_APPROVED_APP_DOMAIN failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_390;
      }
    }
  }
LABEL_392:
  if (v178)
    free(v178);
  p_output_handler = v177;
  v150 = v176;
  v72 = v175;
LABEL_395:
  v188 = v169;
  v189 = v188[19].isa;

  v540 = (uint64_t)p_output_handler;
  v190 = nw_protocol_stack_copy_internet_protocol(v189);
  v191 = nw_protocol_stack_copy_transport_protocol(v189);
  if (v189)
    os_release(v189);
  v192 = default_input_handler_low;
  v534 = v188;
  if (v190)
  {
    v537 = v72;
    if (!nw_ip_options_get_calculate_receive_time(v190)
      || !setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 0x40000, &v551, 4u))
    {
      goto LABEL_430;
    }
    v193 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v194 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v193;
      _os_log_impl(&dword_182FBE000, v194, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d", buf, 0x1Cu);
    }
    v195 = __nwlog_obj();
    v196 = v195;
    if (v193 == 22)
    {
      if (os_log_type_enabled(v195, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        _os_log_impl(&dword_182FBE000, v196, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_430;
    }
    v197 = v150;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v193;
    v198 = (char *)_os_log_send_and_compose_impl();
    v548[0] = OS_LOG_TYPE_ERROR;
    v547[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v198, v548, v547))
    {
      if (v548[0] == OS_LOG_TYPE_FAULT)
      {
        v199 = __nwlog_obj();
        v200 = v548[0];
        if (os_log_type_enabled(v199, v548[0]))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v193;
          v201 = "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d";
LABEL_426:
          _os_log_impl(&dword_182FBE000, v199, v200, v201, buf, 0x12u);
        }
      }
      else if (v547[0])
      {
        v202 = (char *)__nw_create_backtrace_string();
        v199 = __nwlog_obj();
        v200 = v548[0];
        v203 = os_log_type_enabled(v199, v548[0]);
        if (v202)
        {
          if (v203)
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v193;
            *(_WORD *)&v555[4] = 2082;
            *(_QWORD *)&v555[6] = v202;
            _os_log_impl(&dword_182FBE000, v199, v200, "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v202);
          v192 = default_input_handler_low;
          goto LABEL_427;
        }
        v192 = default_input_handler_low;
        if (v203)
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v193;
          v201 = "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d, no backtrace";
          goto LABEL_426;
        }
      }
      else
      {
        v199 = __nwlog_obj();
        v200 = v548[0];
        if (os_log_type_enabled(v199, v548[0]))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v193;
          v201 = "%{public}s setsockopt SO_TIMESTAMP_CONTINUOUS failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_426;
        }
      }
    }
LABEL_427:
    if (v198)
      free(v198);
    v150 = v197;
    v188 = v534;
LABEL_430:
    *(_DWORD *)v548 = 0;
    *(_DWORD *)v548 = nw_ip_options_get_hop_limit(v190);
    if (!*(_DWORD *)v548)
      goto LABEL_493;
    if (v192 == 2)
    {
      if (!setsockopt(HIDWORD(a1[4].output_handler), 0, 4, v548, 4u))
      {
        if (!nw_ip_options_get_receive_hop_limit(v190))
          goto LABEL_544;
        goto LABEL_495;
      }
      v204 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v205 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v204;
        _os_log_impl(&dword_182FBE000, v205, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_TTL failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v206 = __nwlog_obj();
      v207 = v206;
      if (v204 == 22)
      {
        if (!os_log_type_enabled(v206, OS_LOG_TYPE_ERROR))
          goto LABEL_493;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        v208 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d";
LABEL_449:
        _os_log_impl(&dword_182FBE000, v207, OS_LOG_TYPE_ERROR, v208, buf, 0x12u);
        goto LABEL_493;
      }
      v212 = v150;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v204;
      v213 = (char *)_os_log_send_and_compose_impl();
      v547[0] = OS_LOG_TYPE_ERROR;
      v545[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v213, v547, v545))
      {
        if (v547[0] == OS_LOG_TYPE_FAULT)
        {
          v214 = __nwlog_obj();
          v215 = v547[0];
          if (!os_log_type_enabled(v214, v547[0]))
            goto LABEL_490;
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v204;
          v216 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d";
          goto LABEL_489;
        }
        if (v545[0] == OS_LOG_TYPE_DEFAULT)
        {
          v214 = __nwlog_obj();
          v215 = v547[0];
          if (!os_log_type_enabled(v214, v547[0]))
            goto LABEL_490;
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v204;
          v216 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_489;
        }
        v217 = (char *)__nw_create_backtrace_string();
        v214 = __nwlog_obj();
        v215 = v547[0];
        v218 = os_log_type_enabled(v214, v547[0]);
        if (v217)
        {
          if (v218)
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v204;
            *(_WORD *)&v555[4] = 2082;
            *(_QWORD *)&v555[6] = v217;
            _os_log_impl(&dword_182FBE000, v214, v215, "%{public}s setsockopt IP_TTL failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v217);
          v192 = default_input_handler_low;
          if (!v213)
            goto LABEL_492;
          goto LABEL_491;
        }
        v192 = default_input_handler_low;
        if (v218)
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v204;
          v216 = "%{public}s setsockopt IP_TTL failed %{darwin.errno}d, no backtrace";
LABEL_489:
          _os_log_impl(&dword_182FBE000, v214, v215, v216, buf, 0x12u);
        }
      }
    }
    else
    {
      if (v192 != 30 || !setsockopt(HIDWORD(a1[4].output_handler), 41, 47, v548, 4u))
      {
LABEL_493:
        if (!nw_ip_options_get_receive_hop_limit(v190))
          goto LABEL_544;
        if (v192 != 2)
        {
          if (v192 != 30 || !setsockopt(HIDWORD(a1[4].output_handler), 41, 37, &v551, 4u))
            goto LABEL_544;
          v229 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v230 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 2080;
            *(_QWORD *)v555 = (char *)a1 + 436;
            *(_WORD *)&v555[8] = 1024;
            *(_DWORD *)&v555[10] = v229;
            _os_log_impl(&dword_182FBE000, v230, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d", buf, 0x1Cu);
          }
          v231 = __nwlog_obj();
          v227 = v231;
          if (v229 == 22)
          {
            if (os_log_type_enabled(v231, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = 22;
              v228 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d";
              goto LABEL_512;
            }
LABEL_544:
            if (nw_ip_options_get_fragmentation_value(v190) == 1
              || nw_parameters_get_upper_transport_protocol(v188) == 253)
            {
              if (v192 == 2)
              {
                v241 = v537;
                if (!setsockopt(HIDWORD(a1[4].output_handler), 0, 28, &v551, 4u))
                {
LABEL_566:
                  v246 = 0;
                  goto LABEL_660;
                }
                v242 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v243 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 2080;
                  *(_QWORD *)v555 = (char *)a1 + 436;
                  *(_WORD *)&v555[8] = 1024;
                  *(_DWORD *)&v555[10] = v242;
                  _os_log_impl(&dword_182FBE000, v243, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_DONTFRAG failed %{darwin.errno}d", buf, 0x1Cu);
                }
                v244 = __nwlog_obj();
                v245 = v244;
                if (v242 == 22)
                {
                  if (os_log_type_enabled(v244, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = 22;
                    _os_log_impl(&dword_182FBE000, v245, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d", buf, 0x12u);
                    v246 = 0;
                    goto LABEL_660;
                  }
                  goto LABEL_566;
                }
                v533 = v150;
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v242;
                v251 = (char *)_os_log_send_and_compose_impl();
                v547[0] = OS_LOG_TYPE_ERROR;
                v545[0] = OS_LOG_TYPE_DEFAULT;
                if (!__nwlog_fault(v251, v547, v545))
                  goto LABEL_590;
                if (v547[0] == OS_LOG_TYPE_FAULT)
                {
                  v252 = __nwlog_obj();
                  v253 = v547[0];
                  if (os_log_type_enabled(v252, v547[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = v242;
                    v254 = "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d";
LABEL_589:
                    _os_log_impl(&dword_182FBE000, v252, v253, v254, buf, 0x12u);
                  }
                }
                else if (v545[0])
                {
                  v260 = (char *)__nw_create_backtrace_string();
                  v252 = __nwlog_obj();
                  v253 = v547[0];
                  v261 = os_log_type_enabled(v252, v547[0]);
                  if (v260)
                  {
                    if (v261)
                    {
                      *(_DWORD *)buf = 136446722;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v242;
                      *(_WORD *)&v555[4] = 2082;
                      *(_QWORD *)&v555[6] = v260;
                      _os_log_impl(&dword_182FBE000, v252, v253, "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                    }
                    free(v260);
                    v192 = default_input_handler_low;
                    goto LABEL_590;
                  }
                  v192 = default_input_handler_low;
                  if (v261)
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = v242;
                    v254 = "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d, no backtrace";
                    goto LABEL_589;
                  }
                }
                else
                {
                  v252 = __nwlog_obj();
                  v253 = v547[0];
                  if (os_log_type_enabled(v252, v547[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = v242;
                    v254 = "%{public}s setsockopt IP_DONTFRAG failed %{darwin.errno}d, backtrace limit exceeded";
                    goto LABEL_589;
                  }
                }
LABEL_590:
                if (v251)
                  free(v251);
                v246 = 0;
                v241 = v537;
                v150 = v533;
LABEL_660:
                is_multicast = nw_endpoint_is_multicast(v241);
                v188 = v534;
                if (!is_multicast)
                  goto LABEL_730;
                disable_multicast_loopback = nw_ip_options_get_disable_multicast_loopback(v190);
                if (v192 == 2 && v191 && nw_protocol_options_is_udp(v191))
                {
                  if (disable_multicast_loopback)
                    v289 = &v550;
                  else
                    v289 = &v551;
                  if (!setsockopt(HIDWORD(a1[4].output_handler), 0, 11, v289, 4u))
                    goto LABEL_730;
                  v290 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v291 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446722;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 2080;
                    *(_QWORD *)v555 = (char *)a1 + 436;
                    *(_WORD *)&v555[8] = 1024;
                    *(_DWORD *)&v555[10] = v290;
                    _os_log_impl(&dword_182FBE000, v291, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d", buf, 0x1Cu);
                  }
                  v292 = __nwlog_obj();
                  v293 = v292;
                  if (v290 == 22)
                  {
                    if (os_log_type_enabled(v292, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = 22;
                      v294 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d";
                      v295 = v293;
                      v296 = OS_LOG_TYPE_ERROR;
                      v297 = 18;
LABEL_729:
                      _os_log_impl(&dword_182FBE000, v295, v296, v294, buf, v297);
                      goto LABEL_730;
                    }
                    goto LABEL_730;
                  }
                  v304 = v150;
                  *(_DWORD *)buf = 136446466;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 1024;
                  *(_DWORD *)v555 = v290;
                  v305 = (char *)_os_log_send_and_compose_impl();
                  v547[0] = OS_LOG_TYPE_ERROR;
                  v545[0] = OS_LOG_TYPE_DEFAULT;
                  if (__nwlog_fault(v305, v547, v545))
                  {
                    if (v547[0] == OS_LOG_TYPE_FAULT)
                    {
                      v306 = __nwlog_obj();
                      v307 = v547[0];
                      if (os_log_type_enabled(v306, v547[0]))
                      {
                        *(_DWORD *)buf = 136446466;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v290;
                        v308 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d";
LABEL_715:
                        _os_log_impl(&dword_182FBE000, v306, v307, v308, buf, 0x12u);
                      }
                    }
                    else if (v545[0])
                    {
                      v314 = (char *)__nw_create_backtrace_string();
                      v306 = __nwlog_obj();
                      v307 = v547[0];
                      v315 = os_log_type_enabled(v306, v547[0]);
                      if (v314)
                      {
                        if (v315)
                        {
                          *(_DWORD *)buf = 136446722;
                          v553 = "nw_socket_set_common_sockopts";
                          v554 = 1024;
                          *(_DWORD *)v555 = v290;
                          *(_WORD *)&v555[4] = 2082;
                          *(_QWORD *)&v555[6] = v314;
                          _os_log_impl(&dword_182FBE000, v306, v307, "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                        }
                        free(v314);
                        goto LABEL_716;
                      }
                      if (v315)
                      {
                        *(_DWORD *)buf = 136446466;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v290;
                        v308 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d, no backtrace";
                        goto LABEL_715;
                      }
                    }
                    else
                    {
                      v306 = __nwlog_obj();
                      v307 = v547[0];
                      if (os_log_type_enabled(v306, v547[0]))
                      {
                        *(_DWORD *)buf = 136446466;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v290;
                        v308 = "%{public}s setsockopt IP_MULTICAST_LOOP failed %{darwin.errno}d, backtrace limit exceeded";
                        goto LABEL_715;
                      }
                    }
                  }
LABEL_716:
                  if (v305)
                    free(v305);
                  v150 = v304;
                  v188 = v534;
                  goto LABEL_730;
                }
                if (v191)
                  v298 = v246;
                else
                  v298 = 0;
                if (v298 != 1 || !nw_protocol_options_is_udp(v191))
                  goto LABEL_730;
                if (disable_multicast_loopback)
                  v299 = &v550;
                else
                  v299 = &v551;
                if (!setsockopt(HIDWORD(a1[4].output_handler), 41, 11, v299, 4u))
                {
LABEL_725:
                  v319 = __nwlog_obj();
                  if (os_log_type_enabled(v319, OS_LOG_TYPE_DEBUG))
                  {
                    v320 = "Enabled";
                    if (disable_multicast_loopback)
                      v320 = "Disabled";
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 2080;
                    *(_QWORD *)v555 = v320;
                    v294 = "%{public}s %s multicast loopback";
                    v295 = v319;
                    v296 = OS_LOG_TYPE_DEBUG;
                    v297 = 22;
                    goto LABEL_729;
                  }
LABEL_730:
                  os_release(v190);
                  v72 = v537;
                  goto LABEL_731;
                }
                v300 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v301 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 2080;
                  *(_QWORD *)v555 = (char *)a1 + 436;
                  *(_WORD *)&v555[8] = 1024;
                  *(_DWORD *)&v555[10] = v300;
                  _os_log_impl(&dword_182FBE000, v301, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d", buf, 0x1Cu);
                }
                v302 = __nwlog_obj();
                v303 = v302;
                if (v300 == 22)
                {
                  if (os_log_type_enabled(v302, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = 22;
                    _os_log_impl(&dword_182FBE000, v303, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d", buf, 0x12u);
                  }
                  goto LABEL_725;
                }
                v309 = v150;
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v300;
                v310 = (char *)_os_log_send_and_compose_impl();
                v547[0] = OS_LOG_TYPE_ERROR;
                v545[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v310, v547, v545))
                {
                  if (v547[0] == OS_LOG_TYPE_FAULT)
                  {
                    v311 = __nwlog_obj();
                    v312 = v547[0];
                    if (os_log_type_enabled(v311, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v300;
                      v313 = "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d";
LABEL_721:
                      _os_log_impl(&dword_182FBE000, v311, v312, v313, buf, 0x12u);
                    }
                  }
                  else if (v545[0])
                  {
                    v316 = v310;
                    v317 = (char *)__nw_create_backtrace_string();
                    v311 = __nwlog_obj();
                    v312 = v547[0];
                    v318 = os_log_type_enabled(v311, v547[0]);
                    if (v317)
                    {
                      if (v318)
                      {
                        *(_DWORD *)buf = 136446722;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v300;
                        *(_WORD *)&v555[4] = 2082;
                        *(_QWORD *)&v555[6] = v317;
                        _os_log_impl(&dword_182FBE000, v311, v312, "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v317);
                      v310 = v316;
                      goto LABEL_722;
                    }
                    v310 = v316;
                    if (v318)
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v300;
                      v313 = "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d, no backtrace";
                      goto LABEL_721;
                    }
                  }
                  else
                  {
                    v311 = __nwlog_obj();
                    v312 = v547[0];
                    if (os_log_type_enabled(v311, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v300;
                      v313 = "%{public}s setsockopt IPV6_MULTICAST_LOOP failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_721;
                    }
                  }
                }
LABEL_722:
                v188 = v534;
                if (v310)
                  free(v310);
                v150 = v309;
                goto LABEL_725;
              }
              if (v192 == 30)
              {
                if (!setsockopt(HIDWORD(a1[4].output_handler), 41, 62, &v551, 4u))
                  goto LABEL_601;
                v247 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v248 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 2080;
                  *(_QWORD *)v555 = (char *)a1 + 436;
                  *(_WORD *)&v555[8] = 1024;
                  *(_DWORD *)&v555[10] = v247;
                  _os_log_impl(&dword_182FBE000, v248, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d", buf, 0x1Cu);
                }
                v249 = __nwlog_obj();
                v250 = v249;
                if (v247 == 22)
                {
                  if (os_log_type_enabled(v249, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = 22;
                    _os_log_impl(&dword_182FBE000, v250, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d", buf, 0x12u);
                  }
                  goto LABEL_601;
                }
                v255 = v150;
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v247;
                v256 = (char *)_os_log_send_and_compose_impl();
                v547[0] = OS_LOG_TYPE_ERROR;
                v545[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v256, v547, v545))
                {
                  if (v547[0] == OS_LOG_TYPE_FAULT)
                  {
                    v257 = __nwlog_obj();
                    v258 = v547[0];
                    if (os_log_type_enabled(v257, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v247;
                      v259 = "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d";
LABEL_597:
                      _os_log_impl(&dword_182FBE000, v257, v258, v259, buf, 0x12u);
                    }
                  }
                  else if (v545[0])
                  {
                    v262 = (char *)__nw_create_backtrace_string();
                    v257 = __nwlog_obj();
                    v258 = v547[0];
                    v263 = os_log_type_enabled(v257, v547[0]);
                    if (v262)
                    {
                      if (v263)
                      {
                        *(_DWORD *)buf = 136446722;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v247;
                        *(_WORD *)&v555[4] = 2082;
                        *(_QWORD *)&v555[6] = v262;
                        _os_log_impl(&dword_182FBE000, v257, v258, "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v262);
                      v192 = default_input_handler_low;
                      goto LABEL_598;
                    }
                    v192 = default_input_handler_low;
                    if (v263)
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v247;
                      v259 = "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d, no backtrace";
                      goto LABEL_597;
                    }
                  }
                  else
                  {
                    v257 = __nwlog_obj();
                    v258 = v547[0];
                    if (os_log_type_enabled(v257, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v247;
                      v259 = "%{public}s setsockopt IPV6_DONTFRAG failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_597;
                    }
                  }
                }
LABEL_598:
                if (v256)
                  free(v256);
                v150 = v255;
LABEL_601:
                if (!nw_ip_options_get_use_minimum_mtu(v190)
                  || !setsockopt(HIDWORD(a1[4].output_handler), 41, 42, &v551, 4u))
                {
                  goto LABEL_627;
                }
                v264 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v265 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 2080;
                  *(_QWORD *)v555 = (char *)a1 + 436;
                  *(_WORD *)&v555[8] = 1024;
                  *(_DWORD *)&v555[10] = v264;
                  _os_log_impl(&dword_182FBE000, v265, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d", buf, 0x1Cu);
                }
                v266 = __nwlog_obj();
                v267 = v266;
                if (v264 == 22)
                {
                  if (os_log_type_enabled(v266, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = 22;
                    _os_log_impl(&dword_182FBE000, v267, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d", buf, 0x12u);
                  }
                  goto LABEL_627;
                }
                v268 = v150;
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v264;
                v269 = (char *)_os_log_send_and_compose_impl();
                v547[0] = OS_LOG_TYPE_ERROR;
                v545[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v269, v547, v545))
                {
                  if (v547[0] == OS_LOG_TYPE_FAULT)
                  {
                    v270 = __nwlog_obj();
                    v271 = v547[0];
                    if (os_log_type_enabled(v270, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v264;
                      v272 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d";
LABEL_623:
                      _os_log_impl(&dword_182FBE000, v270, v271, v272, buf, 0x12u);
                    }
                  }
                  else if (v545[0])
                  {
                    v273 = (char *)__nw_create_backtrace_string();
                    v270 = __nwlog_obj();
                    v271 = v547[0];
                    v274 = os_log_type_enabled(v270, v547[0]);
                    if (v273)
                    {
                      if (v274)
                      {
                        *(_DWORD *)buf = 136446722;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v264;
                        *(_WORD *)&v555[4] = 2082;
                        *(_QWORD *)&v555[6] = v273;
                        _os_log_impl(&dword_182FBE000, v270, v271, "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v273);
                      v192 = default_input_handler_low;
                      goto LABEL_624;
                    }
                    v192 = default_input_handler_low;
                    if (v274)
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v264;
                      v272 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, no backtrace";
                      goto LABEL_623;
                    }
                  }
                  else
                  {
                    v270 = __nwlog_obj();
                    v271 = v547[0];
                    if (os_log_type_enabled(v270, v547[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v264;
                      v272 = "%{public}s setsockopt IPV6_USE_MIN_MTU failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_623;
                    }
                  }
                }
LABEL_624:
                if (v269)
                  free(v269);
                v150 = v268;
LABEL_627:
                local_address_preference = nw_ip_options_get_local_address_preference(v190);
                v241 = v537;
                if (!local_address_preference)
                {
                  v246 = 1;
                  goto LABEL_660;
                }
                *(_DWORD *)v547 = -1;
                if (local_address_preference == 2)
                {
                  *(_DWORD *)v547 = 0;
                }
                else if (local_address_preference == 1)
                {
                  *(_DWORD *)v547 = 1;
                }
                if (!setsockopt(HIDWORD(a1[4].output_handler), 41, 63, v547, 4u))
                  goto LABEL_658;
                v276 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v277 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 2080;
                  *(_QWORD *)v555 = (char *)a1 + 436;
                  *(_WORD *)&v555[8] = 1024;
                  *(_DWORD *)&v555[10] = v276;
                  _os_log_impl(&dword_182FBE000, v277, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d", buf, 0x1Cu);
                }
                v278 = __nwlog_obj();
                v279 = v278;
                if (v276 == 22)
                {
                  if (os_log_type_enabled(v278, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446466;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = 22;
                    _os_log_impl(&dword_182FBE000, v279, OS_LOG_TYPE_ERROR, "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d", buf, 0x12u);
                  }
LABEL_658:
                  v246 = 1;
                  goto LABEL_659;
                }
                v280 = v150;
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v276;
                v281 = (char *)_os_log_send_and_compose_impl();
                v545[0] = OS_LOG_TYPE_ERROR;
                v546 = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v281, v545, &v546))
                {
                  if (v545[0] == OS_LOG_TYPE_FAULT)
                  {
                    v282 = __nwlog_obj();
                    v283 = v545[0];
                    if (os_log_type_enabled(v282, v545[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v276;
                      v284 = "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d";
LABEL_654:
                      _os_log_impl(&dword_182FBE000, v282, v283, v284, buf, 0x12u);
                    }
                  }
                  else if (v546)
                  {
                    v285 = (char *)__nw_create_backtrace_string();
                    v282 = __nwlog_obj();
                    v283 = v545[0];
                    v286 = os_log_type_enabled(v282, v545[0]);
                    if (v285)
                    {
                      if (v286)
                      {
                        *(_DWORD *)buf = 136446722;
                        v553 = "nw_socket_set_common_sockopts";
                        v554 = 1024;
                        *(_DWORD *)v555 = v276;
                        *(_WORD *)&v555[4] = 2082;
                        *(_QWORD *)&v555[6] = v285;
                        _os_log_impl(&dword_182FBE000, v282, v283, "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }
                      free(v285);
                      v192 = default_input_handler_low;
                      goto LABEL_655;
                    }
                    v192 = default_input_handler_low;
                    if (v286)
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v276;
                      v284 = "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d, no backtrace";
                      goto LABEL_654;
                    }
                  }
                  else
                  {
                    v282 = __nwlog_obj();
                    v283 = v545[0];
                    if (os_log_type_enabled(v282, v545[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      v553 = "nw_socket_set_common_sockopts";
                      v554 = 1024;
                      *(_DWORD *)v555 = v276;
                      v284 = "%{public}s setsockopt IPV6_PREFER_TEMPADDR failed %{darwin.errno}d, backtrace limit exceeded";
                      goto LABEL_654;
                    }
                  }
                }
LABEL_655:
                if (v281)
                  free(v281);
                v150 = v280;
                goto LABEL_658;
              }
            }
            else if (v192 == 30)
            {
              goto LABEL_601;
            }
            v246 = 0;
LABEL_659:
            v241 = v537;
            goto LABEL_660;
          }
          v232 = v150;
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v229;
          v233 = (char *)_os_log_send_and_compose_impl();
          v547[0] = OS_LOG_TYPE_ERROR;
          v545[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v233, v547, v545))
          {
            if (v547[0] == OS_LOG_TYPE_FAULT)
            {
              v234 = __nwlog_obj();
              v235 = v547[0];
              if (!os_log_type_enabled(v234, v547[0]))
                goto LABEL_541;
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v229;
              v236 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d";
              goto LABEL_540;
            }
            if (v545[0] == OS_LOG_TYPE_DEFAULT)
            {
              v234 = __nwlog_obj();
              v235 = v547[0];
              if (!os_log_type_enabled(v234, v547[0]))
                goto LABEL_541;
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v229;
              v236 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_540;
            }
            v239 = (char *)__nw_create_backtrace_string();
            v234 = __nwlog_obj();
            v235 = v547[0];
            v240 = os_log_type_enabled(v234, v547[0]);
            if (!v239)
            {
              v192 = default_input_handler_low;
              if (!v240)
                goto LABEL_541;
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v229;
              v236 = "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d, no backtrace";
              goto LABEL_540;
            }
            if (v240)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v229;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v239;
              _os_log_impl(&dword_182FBE000, v234, v235, "%{public}s setsockopt IPV6_RECVHOPLIMIT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v239);
            v192 = default_input_handler_low;
          }
          goto LABEL_541;
        }
LABEL_495:
        if (!setsockopt(HIDWORD(a1[4].output_handler), 0, 24, &v551, 4u))
          goto LABEL_544;
        v224 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v225 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 2080;
          *(_QWORD *)v555 = (char *)a1 + 436;
          *(_WORD *)&v555[8] = 1024;
          *(_DWORD *)&v555[10] = v224;
          _os_log_impl(&dword_182FBE000, v225, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IP_RECVTTL failed %{darwin.errno}d", buf, 0x1Cu);
        }
        v226 = __nwlog_obj();
        v227 = v226;
        if (v224 == 22)
        {
          if (os_log_type_enabled(v226, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = 22;
            v228 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d";
LABEL_512:
            _os_log_impl(&dword_182FBE000, v227, OS_LOG_TYPE_ERROR, v228, buf, 0x12u);
            goto LABEL_544;
          }
          goto LABEL_544;
        }
        v232 = v150;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v224;
        v233 = (char *)_os_log_send_and_compose_impl();
        v547[0] = OS_LOG_TYPE_ERROR;
        v545[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v233, v547, v545))
        {
          if (v547[0] == OS_LOG_TYPE_FAULT)
          {
            v234 = __nwlog_obj();
            v235 = v547[0];
            if (!os_log_type_enabled(v234, v547[0]))
              goto LABEL_541;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v224;
            v236 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d";
            goto LABEL_540;
          }
          if (v545[0] == OS_LOG_TYPE_DEFAULT)
          {
            v234 = __nwlog_obj();
            v235 = v547[0];
            if (!os_log_type_enabled(v234, v547[0]))
              goto LABEL_541;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v224;
            v236 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_540;
          }
          v237 = (char *)__nw_create_backtrace_string();
          v234 = __nwlog_obj();
          v235 = v547[0];
          v238 = os_log_type_enabled(v234, v547[0]);
          if (v237)
          {
            if (v238)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v224;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v237;
              _os_log_impl(&dword_182FBE000, v234, v235, "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v237);
            v192 = default_input_handler_low;
            if (!v233)
              goto LABEL_543;
            goto LABEL_542;
          }
          v192 = default_input_handler_low;
          if (v238)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v224;
            v236 = "%{public}s setsockopt IP_RECVTTL failed %{darwin.errno}d, no backtrace";
LABEL_540:
            _os_log_impl(&dword_182FBE000, v234, v235, v236, buf, 0x12u);
          }
        }
LABEL_541:
        if (!v233)
        {
LABEL_543:
          v150 = v232;
          v188 = v534;
          goto LABEL_544;
        }
LABEL_542:
        free(v233);
        goto LABEL_543;
      }
      v209 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v210 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v209;
        _os_log_impl(&dword_182FBE000, v210, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v211 = __nwlog_obj();
      v207 = v211;
      if (v209 == 22)
      {
        if (!os_log_type_enabled(v211, OS_LOG_TYPE_ERROR))
          goto LABEL_493;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        v208 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d";
        goto LABEL_449;
      }
      v212 = v150;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v209;
      v213 = (char *)_os_log_send_and_compose_impl();
      v547[0] = OS_LOG_TYPE_ERROR;
      v545[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v213, v547, v545))
      {
        if (v547[0] == OS_LOG_TYPE_FAULT)
        {
          v214 = __nwlog_obj();
          v215 = v547[0];
          if (!os_log_type_enabled(v214, v547[0]))
            goto LABEL_490;
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v209;
          v216 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d";
          goto LABEL_489;
        }
        if (v545[0] == OS_LOG_TYPE_DEFAULT)
        {
          v214 = __nwlog_obj();
          v215 = v547[0];
          if (!os_log_type_enabled(v214, v547[0]))
            goto LABEL_490;
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v209;
          v216 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_489;
        }
        v219 = (char *)__nw_create_backtrace_string();
        v214 = __nwlog_obj();
        v215 = v547[0];
        v220 = os_log_type_enabled(v214, v547[0]);
        if (!v219)
        {
          v192 = default_input_handler_low;
          if (!v220)
            goto LABEL_490;
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v209;
          v216 = "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d, no backtrace";
          goto LABEL_489;
        }
        if (v220)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v209;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v219;
          _os_log_impl(&dword_182FBE000, v214, v215, "%{public}s setsockopt IPV6_HOPLIMIT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v219);
        v192 = default_input_handler_low;
      }
    }
LABEL_490:
    if (!v213)
    {
LABEL_492:
      v150 = v212;
      v188 = v534;
      goto LABEL_493;
    }
LABEL_491:
    free(v213);
    goto LABEL_492;
  }
LABEL_731:
  if (v191)
  {
    v321 = v191;
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
    v322 = nw_protocol_options_matches_definition(v321, (void *)g_tcp_definition);

    if (v322)
    {
      if ((nw_socket_set_bidirectional_tcp_sockopts(v540, v321) & 1) == 0)
        goto LABEL_1219;
      ecn_mode = nw_parameters_get_ecn_mode(v188);
      if (ecn_mode)
      {
        if (ecn_mode == 1)
          v324 = 1;
        else
          v324 = 2;
      }
      else
      {
        if (!nw_tcp_options_get_disable_ecn(v321))
          goto LABEL_786;
        v324 = 2;
      }
      *(_DWORD *)v548 = v324;
      if (!setsockopt(HIDWORD(a1[4].output_handler), 6, 528, v548, 4u))
        goto LABEL_786;
      v330 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v331 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v330;
        _os_log_impl(&dword_182FBE000, v331, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_ECN_MODE failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v332 = __nwlog_obj();
      v333 = v332;
      if (v330 == 22)
      {
        if (os_log_type_enabled(v332, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          _os_log_impl(&dword_182FBE000, v333, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_786;
      }
      v334 = v72;
      v335 = v150;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v330;
      v336 = (char *)_os_log_send_and_compose_impl();
      v547[0] = OS_LOG_TYPE_ERROR;
      v545[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v336, v547, v545))
      {
        if (v547[0] == OS_LOG_TYPE_FAULT)
        {
          v337 = __nwlog_obj();
          v338 = v547[0];
          if (os_log_type_enabled(v337, v547[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v330;
            v339 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d";
LABEL_782:
            _os_log_impl(&dword_182FBE000, v337, v338, v339, buf, 0x12u);
          }
        }
        else if (v545[0])
        {
          v346 = (char *)__nw_create_backtrace_string();
          v337 = __nwlog_obj();
          v338 = v547[0];
          v347 = os_log_type_enabled(v337, v547[0]);
          if (v346)
          {
            if (v347)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v330;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v346;
              _os_log_impl(&dword_182FBE000, v337, v338, "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v346);
            goto LABEL_783;
          }
          if (v347)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v330;
            v339 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, no backtrace";
            goto LABEL_782;
          }
        }
        else
        {
          v337 = __nwlog_obj();
          v338 = v547[0];
          if (os_log_type_enabled(v337, v547[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v330;
            v339 = "%{public}s setsockopt TCP_ECN_MODE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_782;
          }
        }
      }
LABEL_783:
      v188 = v534;
      if (v336)
        free(v336);
      v150 = v335;
      v72 = v334;
LABEL_786:
      enable_l4s = nw_tcp_options_get_enable_l4s(v321);
      if (enable_l4s == 2)
        goto LABEL_850;
      *(_DWORD *)v548 = enable_l4s == 1;
      if (!setsockopt(HIDWORD(a1[4].output_handler), 6, 539, v548, 4u))
        goto LABEL_850;
      v351 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v352 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v351;
        _os_log_impl(&dword_182FBE000, v352, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v353 = __nwlog_obj();
      v354 = v353;
      if (v351 == 22)
      {
        if (os_log_type_enabled(v353, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          _os_log_impl(&dword_182FBE000, v354, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_850;
      }
      v355 = v72;
      v356 = v150;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v351;
      v357 = (char *)_os_log_send_and_compose_impl();
      v547[0] = OS_LOG_TYPE_ERROR;
      v545[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v357, v547, v545))
      {
        if (v547[0] == OS_LOG_TYPE_FAULT)
        {
          v358 = __nwlog_obj();
          v359 = v547[0];
          if (os_log_type_enabled(v358, v547[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v351;
            v360 = "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d";
LABEL_846:
            _os_log_impl(&dword_182FBE000, v358, v359, v360, buf, 0x12u);
          }
        }
        else if (v545[0])
        {
          v361 = (char *)__nw_create_backtrace_string();
          v358 = __nwlog_obj();
          v359 = v547[0];
          v362 = os_log_type_enabled(v358, v547[0]);
          if (v361)
          {
            if (v362)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v351;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v361;
              _os_log_impl(&dword_182FBE000, v358, v359, "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v361);
            goto LABEL_847;
          }
          if (v362)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v351;
            v360 = "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d, no backtrace";
            goto LABEL_846;
          }
        }
        else
        {
          v358 = __nwlog_obj();
          v359 = v547[0];
          if (os_log_type_enabled(v358, v547[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v351;
            v360 = "%{public}s setsockopt TCP_ENABLE_L4S failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_846;
          }
        }
      }
LABEL_847:
      v188 = v534;
      if (v357)
        free(v357);
      v150 = v356;
      v72 = v355;
LABEL_850:
      if (!nw_tcp_options_get_fast_open_force_enable(v321)
        || !setsockopt(HIDWORD(a1[4].output_handler), 6, 536, &v551, 4u))
      {
        goto LABEL_876;
      }
      v378 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v379 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v378;
        _os_log_impl(&dword_182FBE000, v379, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v380 = __nwlog_obj();
      v381 = v380;
      if (v378 == 22)
      {
        if (os_log_type_enabled(v380, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          _os_log_impl(&dword_182FBE000, v381, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_876;
      }
      v382 = v72;
      v383 = v150;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v378;
      v384 = (char *)_os_log_send_and_compose_impl();
      v548[0] = OS_LOG_TYPE_ERROR;
      v547[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v384, v548, v547))
      {
        if (v548[0] == OS_LOG_TYPE_FAULT)
        {
          v385 = __nwlog_obj();
          v386 = v548[0];
          if (os_log_type_enabled(v385, v548[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v378;
            v387 = "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d";
LABEL_872:
            _os_log_impl(&dword_182FBE000, v385, v386, v387, buf, 0x12u);
          }
        }
        else if (v547[0])
        {
          v388 = (char *)__nw_create_backtrace_string();
          v385 = __nwlog_obj();
          v386 = v548[0];
          v389 = os_log_type_enabled(v385, v548[0]);
          if (v388)
          {
            if (v389)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v378;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v388;
              _os_log_impl(&dword_182FBE000, v385, v386, "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v388);
            goto LABEL_873;
          }
          if (v389)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v378;
            v387 = "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d, no backtrace";
            goto LABEL_872;
          }
        }
        else
        {
          v385 = __nwlog_obj();
          v386 = v548[0];
          if (os_log_type_enabled(v385, v548[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v378;
            v387 = "%{public}s setsockopt TCP_FASTOPEN_FORCE_ENABLE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_872;
          }
        }
      }
LABEL_873:
      v188 = v534;
      if (v384)
        free(v384);
      v150 = v383;
      v72 = v382;
LABEL_876:
      *(_DWORD *)v548 = 0;
      *(_DWORD *)v548 = nw_tcp_options_get_connection_timeout(v321);
      if (!*(_DWORD *)v548 || !setsockopt(HIDWORD(a1[4].output_handler), 6, 32, v548, 4u))
        goto LABEL_902;
      v390 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v391 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v390;
        _os_log_impl(&dword_182FBE000, v391, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v392 = __nwlog_obj();
      v393 = v392;
      if (v390 == 22)
      {
        if (os_log_type_enabled(v392, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          _os_log_impl(&dword_182FBE000, v393, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d", buf, 0x12u);
        }
        goto LABEL_902;
      }
      v394 = v72;
      v395 = v150;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v390;
      v396 = (char *)_os_log_send_and_compose_impl();
      v547[0] = OS_LOG_TYPE_ERROR;
      v545[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v396, v547, v545))
      {
        if (v547[0] == OS_LOG_TYPE_FAULT)
        {
          v397 = __nwlog_obj();
          v398 = v547[0];
          if (os_log_type_enabled(v397, v547[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v390;
            v399 = "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d";
LABEL_898:
            _os_log_impl(&dword_182FBE000, v397, v398, v399, buf, 0x12u);
          }
        }
        else if (v545[0])
        {
          v400 = (char *)__nw_create_backtrace_string();
          v397 = __nwlog_obj();
          v398 = v547[0];
          v401 = os_log_type_enabled(v397, v547[0]);
          if (v400)
          {
            if (v401)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v390;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v400;
              _os_log_impl(&dword_182FBE000, v397, v398, "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v400);
            goto LABEL_899;
          }
          if (v401)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v390;
            v399 = "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, no backtrace";
            goto LABEL_898;
          }
        }
        else
        {
          v397 = __nwlog_obj();
          v398 = v547[0];
          if (os_log_type_enabled(v397, v547[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v390;
            v399 = "%{public}s setsockopt TCP_CONNECTIONTIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_898;
          }
        }
      }
LABEL_899:
      v188 = v534;
      if (v396)
        free(v396);
      v150 = v395;
      v72 = v394;
LABEL_902:
      multipath_service = nw_parameters_get_multipath_service(v188);
      v403 = *(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16);
      if ((v403 & 0x20000) == 0)
        goto LABEL_1048;
      v404 = multipath_service;
      if (multipath_service == nw_multipath_service_disabled)
        goto LABEL_1048;
      *(_DWORD *)v547 = -1;
      switch(multipath_service)
      {
        case nw_multipath_service_aggregate:
          v405 = 2;
          break;
        case nw_multipath_service_interactive:
          v405 = 1;
          break;
        case nw_multipath_service_handover:
          *(_DWORD *)v547 = 0;
          goto LABEL_915;
        default:
          if (multipath_service == 101)
          {
            v405 = 4;
            break;
          }
          if (multipath_service == 100)
          {
            v405 = 3;
            break;
          }
          if ((v403 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v419 = (char *)&a1[6].default_input_handler + 4;
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 2082;
            *(_QWORD *)v555 = (char *)a1 + 436;
            *(_WORD *)&v555[8] = 1024;
            *(_DWORD *)&v555[10] = v404;
            v420 = (char *)_os_log_send_and_compose_impl();
            v545[0] = OS_LOG_TYPE_ERROR;
            v546 = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v420, v545, &v546))
              goto LABEL_1264;
            if (v545[0] == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v421 = gconnectionLogObj;
              v422 = v545[0];
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v545[0]))
                goto LABEL_1264;
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 2082;
              *(_QWORD *)v555 = v419;
              *(_WORD *)&v555[8] = 1024;
              *(_DWORD *)&v555[10] = v404;
              v423 = "%{public}s %{public}s Multipath Service has not been set correctly: %u";
            }
            else
            {
              if (v546)
              {
                v434 = (char *)__nw_create_backtrace_string();
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v435 = gconnectionLogObj;
                v436 = v545[0];
                v437 = os_log_type_enabled((os_log_t)gconnectionLogObj, v545[0]);
                if (v434)
                {
                  if (v437)
                  {
                    *(_DWORD *)buf = 136446978;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 2082;
                    *(_QWORD *)v555 = v419;
                    *(_WORD *)&v555[8] = 1024;
                    *(_DWORD *)&v555[10] = v404;
                    *(_WORD *)&v555[14] = 2082;
                    *(_QWORD *)&v555[16] = v434;
                    _os_log_impl(&dword_182FBE000, v435, v436, "%{public}s %{public}s Multipath Service has not been set correctly: %u, dumping backtrace:%{public}s", buf, 0x26u);
                  }
                  free(v434);
                  goto LABEL_1264;
                }
                if (!v437)
                {
LABEL_1264:
                  if (v420)
                    free(v420);
                  goto LABEL_1219;
                }
                *(_DWORD *)buf = 136446722;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 2082;
                *(_QWORD *)v555 = v419;
                *(_WORD *)&v555[8] = 1024;
                *(_DWORD *)&v555[10] = v404;
                v423 = "%{public}s %{public}s Multipath Service has not been set correctly: %u, no backtrace";
                v530 = v435;
                v531 = v436;
LABEL_1263:
                _os_log_impl(&dword_182FBE000, v530, v531, v423, buf, 0x1Cu);
                goto LABEL_1264;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v421 = gconnectionLogObj;
              v422 = v545[0];
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v545[0]))
                goto LABEL_1264;
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 2082;
              *(_QWORD *)v555 = v419;
              *(_WORD *)&v555[8] = 1024;
              *(_DWORD *)&v555[10] = v404;
              v423 = "%{public}s %{public}s Multipath Service has not been set correctly: %u, backtrace limit exceeded";
            }
            v530 = v421;
            v531 = v422;
            goto LABEL_1263;
          }
LABEL_1219:
          os_release(v321);
          return 0;
      }
      *(_DWORD *)v547 = v405;
LABEL_915:
      if (setsockopt(HIDWORD(a1[4].output_handler), 6, 531, v547, 4u))
      {
        v406 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v407 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 2080;
          *(_QWORD *)v555 = (char *)a1 + 436;
          *(_WORD *)&v555[8] = 1024;
          *(_DWORD *)&v555[10] = v406;
          _os_log_impl(&dword_182FBE000, v407, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d", buf, 0x1Cu);
        }
        if ((_DWORD)v406 == 13 || (_DWORD)v406 == 22)
        {
          v408 = __nwlog_obj();
          if (os_log_type_enabled(v408, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v406;
            _os_log_impl(&dword_182FBE000, v408, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d", buf, 0x12u);
          }
LABEL_971:
          v433 = v540;
LABEL_1218:
          nw_socket_internal_error(v433, v406);
          goto LABEL_1219;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v406;
        v413 = (char *)_os_log_send_and_compose_impl();
        v545[0] = OS_LOG_TYPE_ERROR;
        v546 = OS_LOG_TYPE_DEFAULT;
        if ((__nwlog_fault(v413, v545, &v546) & 1) != 0)
        {
          if (v545[0] == OS_LOG_TYPE_FAULT)
          {
            v414 = __nwlog_obj();
            v415 = v545[0];
            if (!os_log_type_enabled(v414, v545[0]))
              goto LABEL_969;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v406;
            v416 = "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d";
            goto LABEL_968;
          }
          if (v546 == OS_LOG_TYPE_DEFAULT)
          {
            v414 = __nwlog_obj();
            v415 = v545[0];
            if (!os_log_type_enabled(v414, v545[0]))
              goto LABEL_969;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v406;
            v416 = "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_968;
          }
          v417 = (char *)__nw_create_backtrace_string();
          v414 = __nwlog_obj();
          v415 = v545[0];
          v418 = os_log_type_enabled(v414, v545[0]);
          if (v417)
          {
            if (v418)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v406;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v417;
              _os_log_impl(&dword_182FBE000, v414, v415, "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v417);
            goto LABEL_969;
          }
          if (v418)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v406;
            v416 = "%{public}s setsockopt MPTCP_SERVICE_TYPE failed %{darwin.errno}d, no backtrace";
LABEL_968:
            _os_log_impl(&dword_182FBE000, v414, v415, v416, buf, 0x12u);
          }
        }
LABEL_969:
        if (v413)
          free(v413);
        goto LABEL_971;
      }
      if (!nw_parameters_get_multipath_force_enable(v188)
        || !setsockopt(HIDWORD(a1[4].output_handler), 6, 535, &v551, 4u))
      {
LABEL_1022:
        *(_DWORD *)v545 = 0;
        *(_DWORD *)v545 = nw_tcp_options_get_multipath_force_version(v321);
        if (*(_DWORD *)v545 <= 1u && setsockopt(HIDWORD(a1[4].output_handler), 6, 538, v545, 4u))
        {
          v449 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v450 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 2080;
            *(_QWORD *)v555 = (char *)a1 + 436;
            *(_WORD *)&v555[8] = 1024;
            *(_DWORD *)&v555[10] = v449;
            _os_log_impl(&dword_182FBE000, v450, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d", buf, 0x1Cu);
          }
          v451 = __nwlog_obj();
          v452 = v451;
          if ((_DWORD)v449 == 22)
          {
            if (os_log_type_enabled(v451, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = 22;
              _os_log_impl(&dword_182FBE000, v452, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d", buf, 0x12u);
            }
LABEL_1047:
            nw_socket_internal_error(v540, v449);
            goto LABEL_1048;
          }
          v453 = v150;
          v454 = v72;
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v449;
          v455 = (char *)_os_log_send_and_compose_impl();
          v546 = OS_LOG_TYPE_ERROR;
          v544 = 0;
          if (__nwlog_fault(v455, &v546, &v544))
          {
            if (v546 == OS_LOG_TYPE_FAULT)
            {
              v456 = __nwlog_obj();
              v457 = v546;
              if (os_log_type_enabled(v456, v546))
              {
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v449;
                v458 = "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d";
LABEL_1042:
                v462 = v456;
LABEL_1043:
                _os_log_impl(&dword_182FBE000, v462, v457, v458, buf, 0x12u);
              }
            }
            else if (v544)
            {
              v459 = (char *)__nw_create_backtrace_string();
              v460 = __nwlog_obj();
              v457 = v546;
              v461 = os_log_type_enabled(v460, v546);
              if (v459)
              {
                if (v461)
                {
                  *(_DWORD *)buf = 136446722;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 1024;
                  *(_DWORD *)v555 = v449;
                  *(_WORD *)&v555[4] = 2082;
                  *(_QWORD *)&v555[6] = v459;
                  _os_log_impl(&dword_182FBE000, v460, v457, "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }
                free(v459);
                goto LABEL_1044;
              }
              if (v461)
              {
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v449;
                v458 = "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d, no backtrace";
                v462 = v460;
                goto LABEL_1043;
              }
            }
            else
            {
              v456 = __nwlog_obj();
              v457 = v546;
              if (os_log_type_enabled(v456, v546))
              {
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v449;
                v458 = "%{public}s setsockopt MPTCP_FORCE_VERSION failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_1042;
              }
            }
          }
LABEL_1044:
          if (v455)
            free(v455);
          v72 = v454;
          v150 = v453;
          v188 = v534;
          goto LABEL_1047;
        }
LABEL_1048:
        *(_DWORD *)v547 = 0;
        *(_DWORD *)v547 = nw_endpoint_get_alternate_port(v72);
        if (*(_DWORD *)v547
          && ((*(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16)) & 0x20000) != 0
          && setsockopt(HIDWORD(a1[4].output_handler), 6, 534, v547, 4u))
        {
          v406 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v463 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 2080;
            *(_QWORD *)v555 = (char *)a1 + 436;
            *(_WORD *)&v555[8] = 1024;
            *(_DWORD *)&v555[10] = v406;
            _os_log_impl(&dword_182FBE000, v463, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d", buf, 0x1Cu);
          }
          v464 = __nwlog_obj();
          v465 = v464;
          if ((_DWORD)v406 == 22)
          {
            if (os_log_type_enabled(v464, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = 22;
              _os_log_impl(&dword_182FBE000, v465, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d", buf, 0x12u);
            }
LABEL_1217:
            v433 = v540;
            goto LABEL_1218;
          }
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v406;
          v509 = (char *)_os_log_send_and_compose_impl();
          v545[0] = OS_LOG_TYPE_ERROR;
          v546 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v509, v545, &v546))
          {
            if (v545[0] == OS_LOG_TYPE_FAULT)
            {
              v510 = __nwlog_obj();
              v511 = v545[0];
              if (!os_log_type_enabled(v510, v545[0]))
                goto LABEL_1215;
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v406;
              v512 = "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d";
              goto LABEL_1214;
            }
            if (v546 == OS_LOG_TYPE_DEFAULT)
            {
              v510 = __nwlog_obj();
              v511 = v545[0];
              if (!os_log_type_enabled(v510, v545[0]))
                goto LABEL_1215;
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v406;
              v512 = "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_1214;
            }
            v520 = (char *)__nw_create_backtrace_string();
            v510 = __nwlog_obj();
            v511 = v545[0];
            v521 = os_log_type_enabled(v510, v545[0]);
            if (v520)
            {
              if (v521)
              {
                *(_DWORD *)buf = 136446722;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = v406;
                *(_WORD *)&v555[4] = 2082;
                *(_QWORD *)&v555[6] = v520;
                _os_log_impl(&dword_182FBE000, v510, v511, "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(v520);
              goto LABEL_1215;
            }
            if (v521)
            {
              *(_DWORD *)buf = 136446466;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v406;
              v512 = "%{public}s setsockopt MPTCP_ALTERNATE_PORT failed %{darwin.errno}d, no backtrace";
LABEL_1214:
              _os_log_impl(&dword_182FBE000, v510, v511, v512, buf, 0x12u);
            }
          }
LABEL_1215:
          if (v509)
            free(v509);
          goto LABEL_1217;
        }
        goto LABEL_1058;
      }
      v409 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v410 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v409;
        _os_log_impl(&dword_182FBE000, v410, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v411 = __nwlog_obj();
      v412 = v411;
      if ((_DWORD)v409 == 22)
      {
        if (os_log_type_enabled(v411, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          _os_log_impl(&dword_182FBE000, v412, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d", buf, 0x12u);
        }
LABEL_1021:
        nw_socket_internal_error(v540, v409);
        goto LABEL_1022;
      }
      v424 = v150;
      v425 = v72;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v409;
      v426 = (char *)_os_log_send_and_compose_impl();
      v545[0] = OS_LOG_TYPE_ERROR;
      v546 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v426, v545, &v546))
      {
        if (v545[0] == OS_LOG_TYPE_FAULT)
        {
          v427 = __nwlog_obj();
          v428 = v545[0];
          if (os_log_type_enabled(v427, v545[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v409;
            v429 = "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d";
LABEL_1016:
            v448 = v427;
LABEL_1017:
            _os_log_impl(&dword_182FBE000, v448, v428, v429, buf, 0x12u);
          }
        }
        else if (v546)
        {
          v430 = (char *)__nw_create_backtrace_string();
          v431 = __nwlog_obj();
          v428 = v545[0];
          v432 = os_log_type_enabled(v431, v545[0]);
          if (v430)
          {
            if (v432)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v409;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v430;
              _os_log_impl(&dword_182FBE000, v431, v428, "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v430);
            goto LABEL_1018;
          }
          if (v432)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v409;
            v429 = "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d, no backtrace";
            v448 = v431;
            goto LABEL_1017;
          }
        }
        else
        {
          v427 = __nwlog_obj();
          v428 = v545[0];
          if (os_log_type_enabled(v427, v545[0]))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v409;
            v429 = "%{public}s setsockopt MPTCP_FORCE_ENABLE failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_1016;
          }
        }
      }
LABEL_1018:
      if (v426)
        free(v426);
      v72 = v425;
      v150 = v424;
      v188 = v534;
      goto LABEL_1021;
    }
    if (!nw_protocol_options_is_udp(v321))
      goto LABEL_1058;
    v325 = default_input_handler_low;
    if (!nw_udp_options_get_prefer_no_checksum(v321) || !setsockopt(HIDWORD(a1[4].output_handler), 17, 1, &v551, 4u))
    {
LABEL_814:
      if (v325 == 2)
      {
        if ((setsockopt(HIDWORD(a1[4].output_handler), 0, 27, &v551, 4u) & 0x80000000) == 0)
          goto LABEL_991;
        v363 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        v364 = __nwlog_obj();
        v365 = v364;
        if (v363 == 22)
        {
          if (os_log_type_enabled(v364, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = 22;
            v366 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d";
LABEL_824:
            _os_log_impl(&dword_182FBE000, v365, OS_LOG_TYPE_ERROR, v366, buf, 0x12u);
            goto LABEL_991;
          }
          goto LABEL_991;
        }
        v369 = v150;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v363;
        v370 = (char *)_os_log_send_and_compose_impl();
        v548[0] = OS_LOG_TYPE_ERROR;
        v547[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v370, v548, v547))
        {
          if (v548[0] == OS_LOG_TYPE_FAULT)
          {
            v371 = __nwlog_obj();
            v372 = v548[0];
            if (!os_log_type_enabled(v371, v548[0]))
              goto LABEL_988;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v363;
            v373 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d";
            goto LABEL_987;
          }
          if (v547[0] == OS_LOG_TYPE_DEFAULT)
          {
            v371 = __nwlog_obj();
            v372 = v548[0];
            if (!os_log_type_enabled(v371, v548[0]))
              goto LABEL_988;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v363;
            v373 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_987;
          }
          v374 = (char *)__nw_create_backtrace_string();
          v371 = __nwlog_obj();
          v372 = v548[0];
          v375 = os_log_type_enabled(v371, v548[0]);
          if (v374)
          {
            if (v375)
            {
              *(_DWORD *)buf = 136446722;
              v553 = "nw_socket_set_common_sockopts";
              v554 = 1024;
              *(_DWORD *)v555 = v363;
              *(_WORD *)&v555[4] = 2082;
              *(_QWORD *)&v555[6] = v374;
              _os_log_impl(&dword_182FBE000, v371, v372, "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v374);
            if (!v370)
              goto LABEL_990;
            goto LABEL_989;
          }
          if (v375)
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v363;
            v373 = "%{public}s setsockopt IP_RECVTOS failed %{darwin.errno}d, no backtrace";
LABEL_987:
            _os_log_impl(&dword_182FBE000, v371, v372, v373, buf, 0x12u);
          }
        }
      }
      else
      {
        if (v325 != 30 || (setsockopt(HIDWORD(a1[4].output_handler), 41, 35, &v551, 4u) & 0x80000000) == 0)
          goto LABEL_991;
        v367 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        v368 = __nwlog_obj();
        v365 = v368;
        if (v367 == 22)
        {
          if (os_log_type_enabled(v368, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = 22;
            v366 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d";
            goto LABEL_824;
          }
LABEL_991:
          if (nw_endpoint_get_type(v72) == nw_endpoint_type_address
            && nw_endpoint_is_broadcast(v72, path)
            && setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 32, &v551, 4u) < 0)
          {
            v438 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            v439 = __nwlog_obj();
            v440 = v439;
            if (v438 == 22)
            {
              if (os_log_type_enabled(v439, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v553 = "nw_socket_set_common_sockopts";
                v554 = 1024;
                *(_DWORD *)v555 = 22;
                _os_log_impl(&dword_182FBE000, v440, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d", buf, 0x12u);
              }
              goto LABEL_1058;
            }
            v441 = v150;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v438;
            v442 = (char *)_os_log_send_and_compose_impl();
            v548[0] = OS_LOG_TYPE_ERROR;
            v547[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v442, v548, v547))
            {
              if (v548[0] == OS_LOG_TYPE_FAULT)
              {
                v443 = __nwlog_obj();
                v444 = v548[0];
                if (os_log_type_enabled(v443, v548[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 1024;
                  *(_DWORD *)v555 = v438;
                  v445 = "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d";
LABEL_1010:
                  _os_log_impl(&dword_182FBE000, v443, v444, v445, buf, 0x12u);
                }
              }
              else if (v547[0])
              {
                v446 = (char *)__nw_create_backtrace_string();
                v443 = __nwlog_obj();
                v444 = v548[0];
                v447 = os_log_type_enabled(v443, v548[0]);
                if (v446)
                {
                  if (v447)
                  {
                    *(_DWORD *)buf = 136446722;
                    v553 = "nw_socket_set_common_sockopts";
                    v554 = 1024;
                    *(_DWORD *)v555 = v438;
                    *(_WORD *)&v555[4] = 2082;
                    *(_QWORD *)&v555[6] = v446;
                    _os_log_impl(&dword_182FBE000, v443, v444, "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                  }
                  free(v446);
                  goto LABEL_1011;
                }
                if (v447)
                {
                  *(_DWORD *)buf = 136446466;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 1024;
                  *(_DWORD *)v555 = v438;
                  v445 = "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d, no backtrace";
                  goto LABEL_1010;
                }
              }
              else
              {
                v443 = __nwlog_obj();
                v444 = v548[0];
                if (os_log_type_enabled(v443, v548[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  v553 = "nw_socket_set_common_sockopts";
                  v554 = 1024;
                  *(_DWORD *)v555 = v438;
                  v445 = "%{public}s setsockopt SO_BROADCAST failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_1010;
                }
              }
            }
LABEL_1011:
            if (v442)
              free(v442);
            v150 = v441;
            v188 = v534;
          }
LABEL_1058:
          os_release(v321);
          goto LABEL_1059;
        }
        v369 = v150;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v367;
        v370 = (char *)_os_log_send_and_compose_impl();
        v548[0] = OS_LOG_TYPE_ERROR;
        v547[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v370, v548, v547))
        {
          if (v548[0] == OS_LOG_TYPE_FAULT)
          {
            v371 = __nwlog_obj();
            v372 = v548[0];
            if (!os_log_type_enabled(v371, v548[0]))
              goto LABEL_988;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v367;
            v373 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d";
            goto LABEL_987;
          }
          if (v547[0] == OS_LOG_TYPE_DEFAULT)
          {
            v371 = __nwlog_obj();
            v372 = v548[0];
            if (!os_log_type_enabled(v371, v548[0]))
              goto LABEL_988;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v367;
            v373 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_987;
          }
          v376 = (char *)__nw_create_backtrace_string();
          v371 = __nwlog_obj();
          v372 = v548[0];
          v377 = os_log_type_enabled(v371, v548[0]);
          if (!v376)
          {
            if (!v377)
              goto LABEL_988;
            *(_DWORD *)buf = 136446466;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v367;
            v373 = "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d, no backtrace";
            goto LABEL_987;
          }
          if (v377)
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v367;
            *(_WORD *)&v555[4] = 2082;
            *(_QWORD *)&v555[6] = v376;
            _os_log_impl(&dword_182FBE000, v371, v372, "%{public}s setsockopt IPV6_RECVTCLASS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v376);
        }
      }
LABEL_988:
      if (!v370)
      {
LABEL_990:
        v150 = v369;
        v188 = v534;
        goto LABEL_991;
      }
LABEL_989:
      free(v370);
      goto LABEL_990;
    }
    v326 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v327 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v326;
      _os_log_impl(&dword_182FBE000, v327, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt UDP_NOCKSUM failed %{darwin.errno}d", buf, 0x1Cu);
    }
    v328 = __nwlog_obj();
    v329 = v328;
    if (v326 == 22)
    {
      if (os_log_type_enabled(v328, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        _os_log_impl(&dword_182FBE000, v329, OS_LOG_TYPE_ERROR, "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_814;
    }
    v340 = v72;
    v341 = v150;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v326;
    v342 = (char *)_os_log_send_and_compose_impl();
    v548[0] = OS_LOG_TYPE_ERROR;
    v547[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v342, v548, v547))
    {
      if (v548[0] == OS_LOG_TYPE_FAULT)
      {
        v343 = __nwlog_obj();
        v344 = v548[0];
        if (os_log_type_enabled(v343, v548[0]))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v326;
          v345 = "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d";
LABEL_810:
          _os_log_impl(&dword_182FBE000, v343, v344, v345, buf, 0x12u);
        }
      }
      else if (v547[0])
      {
        v348 = (char *)__nw_create_backtrace_string();
        v343 = __nwlog_obj();
        v344 = v548[0];
        v349 = os_log_type_enabled(v343, v548[0]);
        if (v348)
        {
          if (v349)
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v326;
            *(_WORD *)&v555[4] = 2082;
            *(_QWORD *)&v555[6] = v348;
            _os_log_impl(&dword_182FBE000, v343, v344, "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v348);
          v325 = default_input_handler_low;
          goto LABEL_811;
        }
        v325 = default_input_handler_low;
        if (v349)
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v326;
          v345 = "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d, no backtrace";
          goto LABEL_810;
        }
      }
      else
      {
        v343 = __nwlog_obj();
        v344 = v548[0];
        if (os_log_type_enabled(v343, v548[0]))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v326;
          v345 = "%{public}s setsockopt UDP_NOCKSUM failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_810;
        }
      }
    }
LABEL_811:
    v188 = v534;
    if (v342)
      free(v342);
    v150 = v341;
    v72 = v340;
    goto LABEL_814;
  }
LABEL_1059:
  v466 = v188;
  v467 = (v150[12] & 0x100) == 0;

  if (!v467)
  {
    if (setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4, &v551, 4u) < 0)
    {
      v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v480 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v45;
        _os_log_impl(&dword_182FBE000, v480, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_REUSEADDR failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v481 = __nwlog_obj();
      v474 = v481;
      if ((_DWORD)v45 == 22)
      {
        if (os_log_type_enabled(v481, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          v475 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d";
          goto LABEL_1131;
        }
LABEL_1205:
        v71 = v540;
        goto LABEL_328;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v487 = (char *)_os_log_send_and_compose_impl();
      v548[0] = OS_LOG_TYPE_ERROR;
      v547[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v487, v548, v547))
        goto LABEL_1203;
      if (v548[0] == OS_LOG_TYPE_FAULT)
      {
        v488 = __nwlog_obj();
        v489 = v548[0];
        if (!os_log_type_enabled(v488, v548[0]))
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d";
      }
      else if (v547[0])
      {
        v500 = (char *)__nw_create_backtrace_string();
        v488 = __nwlog_obj();
        v489 = v548[0];
        v501 = os_log_type_enabled(v488, v548[0]);
        if (v500)
        {
          if (v501)
          {
            *(_DWORD *)buf = 136446722;
            v553 = "nw_socket_set_common_sockopts";
            v554 = 1024;
            *(_DWORD *)v555 = v45;
            *(_WORD *)&v555[4] = 2082;
            *(_QWORD *)&v555[6] = v500;
            _os_log_impl(&dword_182FBE000, v488, v489, "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v500);
LABEL_1203:
          if (!v487)
            goto LABEL_1205;
LABEL_1204:
          free(v487);
          goto LABEL_1205;
        }
        if (!v501)
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d, no backtrace";
      }
      else
      {
        v488 = __nwlog_obj();
        v489 = v548[0];
        if (!os_log_type_enabled(v488, v548[0]))
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_REUSEADDR failed %{darwin.errno}d, backtrace limit exceeded";
      }
LABEL_1202:
      _os_log_impl(&dword_182FBE000, v488, v489, v490, buf, 0x12u);
      goto LABEL_1203;
    }
    if (setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 512, &v551, 4u) < 0)
    {
      v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v491 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v45;
        _os_log_impl(&dword_182FBE000, v491, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_REUSEPORT failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v492 = __nwlog_obj();
      v474 = v492;
      if ((_DWORD)v45 == 22)
      {
        if (os_log_type_enabled(v492, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          v475 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d";
          goto LABEL_1131;
        }
        goto LABEL_1205;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v487 = (char *)_os_log_send_and_compose_impl();
      v548[0] = OS_LOG_TYPE_ERROR;
      v547[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v487, v548, v547))
        goto LABEL_1203;
      if (v548[0] == OS_LOG_TYPE_FAULT)
      {
        v488 = __nwlog_obj();
        v489 = v548[0];
        if (!os_log_type_enabled(v488, v548[0]))
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d";
        goto LABEL_1202;
      }
      if (v547[0] == OS_LOG_TYPE_DEFAULT)
      {
        v488 = __nwlog_obj();
        v489 = v548[0];
        if (!os_log_type_enabled(v488, v548[0]))
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_1202;
      }
      v495 = (char *)__nw_create_backtrace_string();
      v488 = __nwlog_obj();
      v489 = v548[0];
      v504 = os_log_type_enabled(v488, v548[0]);
      if (!v495)
      {
        if (!v504)
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d, no backtrace";
        goto LABEL_1202;
      }
      if (v504)
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        *(_WORD *)&v555[4] = 2082;
        *(_QWORD *)&v555[6] = v495;
        v497 = "%{public}s setsockopt SO_REUSEPORT failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_1168;
      }
LABEL_1169:
      free(v495);
      if (!v487)
        goto LABEL_1205;
      goto LABEL_1204;
    }
  }
  v468 = a1[3].handle;
  if (v468)
  {
    output_handler_high = HIDWORD(a1[4].output_handler);
    bytes_ptr = xpc_data_get_bytes_ptr(v468);
    length = xpc_data_get_length(a1[3].handle);
    if (setsockopt(output_handler_high, 0xFFFF, 4358, bytes_ptr, length))
    {
      v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v472 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 2080;
        *(_QWORD *)v555 = (char *)a1 + 436;
        *(_WORD *)&v555[8] = 1024;
        *(_DWORD *)&v555[10] = v45;
        _os_log_impl(&dword_182FBE000, v472, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d", buf, 0x1Cu);
      }
      v473 = __nwlog_obj();
      v474 = v473;
      if ((_DWORD)v45 == 22)
      {
        if (os_log_type_enabled(v473, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = 22;
          v475 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d";
LABEL_1131:
          _os_log_impl(&dword_182FBE000, v474, OS_LOG_TYPE_ERROR, v475, buf, 0x12u);
          v71 = v540;
          goto LABEL_328;
        }
        goto LABEL_1205;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v487 = (char *)_os_log_send_and_compose_impl();
      v548[0] = OS_LOG_TYPE_ERROR;
      v547[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v487, v548, v547))
        goto LABEL_1203;
      if (v548[0] == OS_LOG_TYPE_FAULT)
      {
        v488 = __nwlog_obj();
        v489 = v548[0];
        if (!os_log_type_enabled(v488, v548[0]))
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d";
        goto LABEL_1202;
      }
      if (v547[0] == OS_LOG_TYPE_DEFAULT)
      {
        v488 = __nwlog_obj();
        v489 = v548[0];
        if (!os_log_type_enabled(v488, v548[0]))
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_1202;
      }
      v495 = (char *)__nw_create_backtrace_string();
      v488 = __nwlog_obj();
      v489 = v548[0];
      v496 = os_log_type_enabled(v488, v548[0]);
      if (!v495)
      {
        if (!v496)
          goto LABEL_1203;
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        v490 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d, no backtrace";
        goto LABEL_1202;
      }
      if (v496)
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v45;
        *(_WORD *)&v555[4] = 2082;
        *(_QWORD *)&v555[6] = v495;
        v497 = "%{public}s setsockopt SO_FLOW_DIVERT_TOKEN failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_1168:
        _os_log_impl(&dword_182FBE000, v488, v489, v497, buf, 0x1Cu);
        goto LABEL_1169;
      }
      goto LABEL_1169;
    }
  }
  if (path
    && nw_path_uses_interface_subtype(path, 4001)
    && setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4376, &v551, 4u) < 0)
  {
    v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v498 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(_QWORD *)v555 = (char *)a1 + 436;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v45;
      _os_log_impl(&dword_182FBE000, v498, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d", buf, 0x1Cu);
    }
    v499 = __nwlog_obj();
    v474 = v499;
    if ((_DWORD)v45 == 22)
    {
      if (os_log_type_enabled(v499, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = 22;
        v475 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d";
        goto LABEL_1131;
      }
      goto LABEL_1205;
    }
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v45;
    v487 = (char *)_os_log_send_and_compose_impl();
    v548[0] = OS_LOG_TYPE_ERROR;
    v547[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v487, v548, v547))
      goto LABEL_1203;
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v488 = __nwlog_obj();
      v489 = v548[0];
      if (!os_log_type_enabled(v488, v548[0]))
        goto LABEL_1203;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v490 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d";
      goto LABEL_1202;
    }
    if (v547[0] == OS_LOG_TYPE_DEFAULT)
    {
      v488 = __nwlog_obj();
      v489 = v548[0];
      if (!os_log_type_enabled(v488, v548[0]))
        goto LABEL_1203;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v490 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_1202;
    }
    v495 = (char *)__nw_create_backtrace_string();
    v488 = __nwlog_obj();
    v489 = v548[0];
    v513 = os_log_type_enabled(v488, v548[0]);
    if (!v495)
    {
      if (!v513)
        goto LABEL_1203;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      v490 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d, no backtrace";
      goto LABEL_1202;
    }
    if (v513)
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v45;
      *(_WORD *)&v555[4] = 2082;
      *(_QWORD *)&v555[6] = v495;
      v497 = "%{public}s setsockopt SO_INTCOPROC_ALLOW failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_1168;
    }
    goto LABEL_1169;
  }
  v476 = nw_parameters_copy_context(v466);
  do_not_log_trackers = nw_context_get_do_not_log_trackers(v476);
  if (v476)
    os_release(v476);
  if (do_not_log_trackers)
  {
    if ((setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4405, &v551, 4u) & 0x80000000) == 0)
    {
      if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) != 0)
        goto LABEL_1240;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v478 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        goto LABEL_1240;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2082;
      *(_QWORD *)v555 = (char *)a1 + 436;
      v479 = "%{public}s %{public}s set SO_MARK_DOMAIN_INFO_SILENT on";
      goto LABEL_1232;
    }
    v493 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v493 == 22 || v493 == 42)
    {
      v494 = __nwlog_obj();
      if (os_log_type_enabled(v494, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v493;
        v479 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d";
LABEL_1238:
        v524 = v494;
        v525 = OS_LOG_TYPE_ERROR;
        v526 = 18;
        goto LABEL_1239;
      }
      goto LABEL_1240;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v493;
    v505 = (char *)_os_log_send_and_compose_impl();
    v548[0] = OS_LOG_TYPE_ERROR;
    v547[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v505, v548, v547) & 1) == 0)
      goto LABEL_1256;
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v506 = __nwlog_obj();
      v507 = v548[0];
      if (!os_log_type_enabled(v506, v548[0]))
        goto LABEL_1256;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v493;
      v508 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d";
      goto LABEL_1255;
    }
    if (v547[0] == OS_LOG_TYPE_DEFAULT)
    {
      v506 = __nwlog_obj();
      v507 = v548[0];
      if (!os_log_type_enabled(v506, v548[0]))
        goto LABEL_1256;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v493;
      v508 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_1255;
    }
    v518 = (char *)__nw_create_backtrace_string();
    v506 = __nwlog_obj();
    v507 = v548[0];
    v519 = os_log_type_enabled(v506, v548[0]);
    if (!v518)
    {
      if (!v519)
        goto LABEL_1256;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v493;
      v508 = "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d, no backtrace";
      goto LABEL_1255;
    }
    if (v519)
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v493;
      *(_WORD *)&v555[4] = 2082;
      *(_QWORD *)&v555[6] = v518;
      _os_log_impl(&dword_182FBE000, v506, v507, "%{public}s setsockopt SO_MARK_DOMAIN_INFO_SILENT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
    free(v518);
    goto LABEL_1256;
  }
  if (!nw_parameters_get_is_known_tracker(v466))
    goto LABEL_1225;
  if (setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4389, &v551, 4u) < 0)
  {
    v502 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v502 == 22 || v502 == 42)
    {
      v503 = __nwlog_obj();
      if (!os_log_type_enabled(v503, OS_LOG_TYPE_ERROR))
        goto LABEL_1225;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v502;
      v483 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d";
      v484 = v503;
      v485 = OS_LOG_TYPE_ERROR;
      v486 = 18;
      goto LABEL_1141;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v502;
    v514 = (char *)_os_log_send_and_compose_impl();
    v548[0] = OS_LOG_TYPE_ERROR;
    v547[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v514, v548, v547) & 1) == 0)
      goto LABEL_1223;
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v515 = __nwlog_obj();
      v516 = v548[0];
      if (!os_log_type_enabled(v515, v548[0]))
        goto LABEL_1223;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v502;
      v517 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d";
    }
    else if (v547[0])
    {
      v522 = (char *)__nw_create_backtrace_string();
      v515 = __nwlog_obj();
      v516 = v548[0];
      v523 = os_log_type_enabled(v515, v548[0]);
      if (v522)
      {
        if (v523)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v502;
          *(_WORD *)&v555[4] = 2082;
          *(_QWORD *)&v555[6] = v522;
          _os_log_impl(&dword_182FBE000, v515, v516, "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v522);
        goto LABEL_1223;
      }
      if (!v523)
      {
LABEL_1223:
        if (v514)
          free(v514);
        goto LABEL_1225;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v502;
      v517 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v515 = __nwlog_obj();
      v516 = v548[0];
      if (!os_log_type_enabled(v515, v548[0]))
        goto LABEL_1223;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v502;
      v517 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v515, v516, v517, buf, 0x12u);
    goto LABEL_1223;
  }
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v482 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2082;
      *(_QWORD *)v555 = v541 + 340;
      v483 = "%{public}s %{public}s set SO_MARK_KNOWN_TRACKER on";
      v484 = v482;
      v485 = OS_LOG_TYPE_DEBUG;
      v486 = 22;
LABEL_1141:
      _os_log_impl(&dword_182FBE000, v484, v485, v483, buf, v486);
    }
  }
LABEL_1225:
  if (nw_parameters_get_attribution(&v466->super) != nw_parameters_attribution_user)
    goto LABEL_1240;
  if ((setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4390, &v551, 4u) & 0x80000000) == 0)
  {
    if ((*(_WORD *)(v541 + 333) & 0x80) != 0)
      goto LABEL_1240;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v478 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      goto LABEL_1240;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2082;
    *(_QWORD *)v555 = v541 + 340;
    v479 = "%{public}s %{public}s set SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED on";
LABEL_1232:
    v524 = v478;
    v525 = OS_LOG_TYPE_DEBUG;
    v526 = 22;
LABEL_1239:
    _os_log_impl(&dword_182FBE000, v524, v525, v479, buf, v526);
    goto LABEL_1240;
  }
  v527 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v527 != 22 && v527 != 42 && v527 != 100)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v527;
    v505 = (char *)_os_log_send_and_compose_impl();
    v548[0] = OS_LOG_TYPE_ERROR;
    v547[0] = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v505, v548, v547) & 1) == 0)
      goto LABEL_1256;
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      v506 = __nwlog_obj();
      v507 = v548[0];
      if (!os_log_type_enabled(v506, v548[0]))
        goto LABEL_1256;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v527;
      v508 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d";
      goto LABEL_1255;
    }
    if (v547[0] == OS_LOG_TYPE_DEFAULT)
    {
      v506 = __nwlog_obj();
      v507 = v548[0];
      if (!os_log_type_enabled(v506, v548[0]))
        goto LABEL_1256;
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v527;
      v508 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_1255;
    }
    v528 = (char *)__nw_create_backtrace_string();
    v506 = __nwlog_obj();
    v507 = v548[0];
    v529 = os_log_type_enabled(v506, v548[0]);
    if (v528)
    {
      if (v529)
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v527;
        *(_WORD *)&v555[4] = 2082;
        *(_QWORD *)&v555[6] = v528;
        _os_log_impl(&dword_182FBE000, v506, v507, "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v528);
      if (!v505)
        goto LABEL_1240;
      goto LABEL_1257;
    }
    if (v529)
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v527;
      v508 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d, no backtrace";
LABEL_1255:
      _os_log_impl(&dword_182FBE000, v506, v507, v508, buf, 0x12u);
    }
LABEL_1256:
    if (!v505)
      goto LABEL_1240;
LABEL_1257:
    free(v505);
    goto LABEL_1240;
  }
  v494 = __nwlog_obj();
  if (os_log_type_enabled(v494, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v527;
    v479 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d";
    goto LABEL_1238;
  }
LABEL_1240:
  nw_protocol_socket_set_necp_attributes(v541, v466, (const char **)v72);
  return 1;
}

void sub_1831DFA34(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_fast_open_force_enable(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_fast_open_force_enable_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_fast_open_force_enable";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_fast_open_force_enable";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831DFD5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_enable_l4s(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_enable_l4s_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_l4s";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_l4s";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831E0080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_connection_timeout(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_connection_timeout_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_connection_timeout";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_connection_timeout";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_connection_timeout";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831E03A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_disable_ecn(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_disable_ecn_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ecn";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ecn";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831E06D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_context_get_do_not_log_trackers(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[34]._os_unfair_lock_opaque & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      os_unfair_lock_lock(v2 + 20);
      v3 = BYTE1(v2[34]._os_unfair_lock_opaque) & 1;
      os_unfair_lock_unlock(v2 + 20);
    }
    else
    {
      v3 = BYTE1(v2[34]._os_unfair_lock_opaque) & 1;
    }
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

BOOL nw_ip_options_get_use_minimum_mtu(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_use_minimum_mtu_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_ip_options_get_use_minimum_mtu";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_ip_options_get_use_minimum_mtu";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831E0A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_settings_register_quic_log_debug_updates(void *a1)
{
  const void *v2;
  const char *v3;
  void *v4;
  Class Class;
  _BOOL8 v6;
  xpc_object_t value;
  void *v8;

  nw_allow_use_of_dispatch_internal();
  pthread_mutex_lock(&sSettingsMutex);
  v2 = (const void *)sQUICUpdateBlock;
  if ((void *)sQUICUpdateBlock != a1)
  {
    if (a1)
    {
      a1 = _Block_copy(a1);
      v2 = (const void *)sQUICUpdateBlock;
    }
    if (v2)
      _Block_release(v2);
    sQUICUpdateBlock = (uint64_t)a1;
  }
  pthread_mutex_unlock(&sSettingsMutex);
  v3 = (const char *)nw_setting_libnetcore_datapath_debug;
  networkd_settings_init();
  if (!sCachedSettings)
    return 0;
  pthread_mutex_lock(&sSettingsMutex);
  v4 = (void *)sCachedSettings;
  if (!sCachedSettings)
    goto LABEL_13;
  Class = object_getClass((id)sCachedSettings);
  v6 = 0;
  if (!v3 || Class != (Class)MEMORY[0x1E0C812F8])
    goto LABEL_14;
  value = xpc_dictionary_get_value(v4, v3);
  if (value && (v8 = value, object_getClass(value) == (Class)MEMORY[0x1E0C812D0]))
    v6 = xpc_BOOL_get_value(v8);
  else
LABEL_13:
    v6 = 0;
LABEL_14:
  pthread_mutex_unlock(&sSettingsMutex);
  return v6;
}

uint64_t __nwlog_get_sensitive_redacted_block_invoke()
{
  char *v0;
  char *v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t result;
  NSObject *v12;
  void *v13;
  char __s1;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  char v23;
  char __s2[16];
  int v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  strcpy(__s2, "not redacted");
  __s1 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = 136642819;
  v26 = __s2;
  v0 = (char *)_os_log_send_and_compose_impl();
  if (v0 == &__s1)
  {
LABEL_14:
    result = strncmp(&__s1, __s2, 0xDuLL);
    nwlog_get_sensitive_redacted::sensitiveRedacted = (_DWORD)result != 0;
    return result;
  }
  v1 = v0;
  if (v0)
  {
LABEL_3:
    v2 = __s1;
    *v1 = __s1;
    if (v2)
    {
      v3 = v15;
      v1[1] = v15;
      if (v3)
      {
        v4 = v16;
        v1[2] = v16;
        if (v4)
        {
          v5 = v17;
          v1[3] = v17;
          if (v5)
          {
            v6 = v18;
            v1[4] = v18;
            if (v6)
            {
              v7 = v19;
              v1[5] = v19;
              if (v7)
              {
                v8 = v20;
                v1[6] = v20;
                if (v8)
                {
                  v9 = v21;
                  v1[7] = v21;
                  if (v9)
                  {
                    v10 = v22;
                    v1[8] = v22;
                    if (v10)
                      v1[9] = v23;
                  }
                }
              }
            }
          }
        }
      }
    }
    free(v1);
    goto LABEL_14;
  }
  v12 = __nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  v25 = 136446210;
  v26 = "_strict_strlcpy";
  v13 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v13);
  if (!(_DWORD)result)
  {
    free(v13);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void NWPathMonitor.start(queue:)(void *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  os_unfair_lock_s *v5;

  v3 = *(_QWORD *)(v1 + 16);
  v4 = v3 + *(_QWORD *)(*MEMORY[0x1E0DEC528] + *(_QWORD *)v3 + 16);
  v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(_QWORD *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v5);
  sub_1831E0E44(v4, v1, a1);
  os_unfair_lock_unlock(v5);
}

int *sub_1831E0E44(uint64_t a1, uint64_t a2, void *a3)
{
  int *result;
  uint64_t v7;
  uint64_t v8;
  id v9;

  result = (int *)type metadata accessor for NWPathMonitor.LockedState(0);
  v7 = result[7];
  if (!*(_QWORD *)(a1 + v7))
  {
    v8 = result[11];
    swift_retain();
    swift_release();
    *(_QWORD *)(a1 + v8) = a2;
    *(_QWORD *)(a1 + v7) = a3;
    v9 = a3;
    return sub_1831E0EC0(a1);
  }
  return result;
}

int *sub_1831E0EC0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  int *result;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  void *v30;
  _BOOL8 v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  id v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t aBlock;
  uint64_t v48;
  uint64_t (*v49)(uint64_t);
  void *v50;
  uint64_t (*v51)();
  uint64_t v52;

  v3 = sub_183B915FC();
  v44 = *(_QWORD *)(v3 - 8);
  v45 = v3;
  MEMORY[0x1E0C80A78](v3);
  v5 = (char *)&v39 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = sub_183B91614();
  v42 = *(_QWORD *)(v6 - 8);
  v43 = v6;
  MEMORY[0x1E0C80A78](v6);
  v8 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1ECD84148);
  MEMORY[0x1E0C80A78](v9);
  v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = type metadata accessor for NWPath(0);
  v13 = *(_QWORD *)(v12 - 8);
  v14 = *(_QWORD *)(v13 + 64);
  v15 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v15);
  v18 = (char *)&v39 - v17;
  result = (int *)type metadata accessor for NWPathMonitor.LockedState(0);
  v20 = result[9];
  if ((*(_BYTE *)(a1 + v20) & 1) != 0)
  {
    v21 = (uint64_t *)(a1 + result[5]);
    v22 = *v21;
    if (*v21 && *(_QWORD *)(a1 + result[7]))
    {
      v23 = v21[1];
      v40 = *(id *)(a1 + result[7]);
      v41 = v23;
      sub_183062090(a1, (uint64_t)v11, (uint64_t *)&unk_1ECD84148);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v13 + 48))(v11, 1, v12) == 1)
      {
        return (int *)sub_1830620D4((uint64_t)v11, (uint64_t *)&unk_1ECD84148);
      }
      else
      {
        sub_183058EC4((uint64_t)v11, (uint64_t)v18, type metadata accessor for NWPath);
        sub_183058C44((uint64_t)v18, (uint64_t)v16, type metadata accessor for NWPath);
        v32 = (*(unsigned __int8 *)(v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80);
        v33 = v22;
        v34 = swift_allocObject();
        v35 = v41;
        *(_QWORD *)(v34 + 16) = v33;
        *(_QWORD *)(v34 + 24) = v35;
        sub_183058EC4((uint64_t)v16, v34 + v32, type metadata accessor for NWPath);
        v51 = sub_1831C2BF4;
        v52 = v34;
        aBlock = MEMORY[0x1E0C809B0];
        v48 = 1107296256;
        v49 = sub_18305665C;
        v50 = &block_descriptor_57;
        v36 = _Block_copy(&aBlock);
        sub_183061488(v33);
        sub_183061488(v33);
        v37 = v40;
        sub_183B91608();
        v46 = MEMORY[0x1E0DEE9D8];
        sub_183064644((unint64_t *)&qword_1ECD840F0, (uint64_t (*)(uint64_t))MEMORY[0x1E0DEF4F8], MEMORY[0x1E0DEF510]);
        __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1ECD840D0);
        sub_1830622EC();
        v38 = v45;
        sub_183B91D58();
        MEMORY[0x186DB21BC](0, v8, v5, v36);

        _Block_release(v36);
        sub_1830630AC(v33);
        (*(void (**)(char *, uint64_t))(v44 + 8))(v5, v38);
        (*(void (**)(char *, uint64_t))(v42 + 8))(v8, v43);
        sub_183058AE0((uint64_t)v18, type metadata accessor for NWPath);
        return (int *)swift_release();
      }
    }
  }
  else
  {
    *(_BYTE *)(a1 + v20) = 1;
    v24 = *(NSObject **)(v1 + 24);
    v25 = swift_allocObject();
    swift_weakInit();
    v51 = sub_1831B9738;
    v52 = v25;
    v26 = MEMORY[0x1E0C809B0];
    aBlock = MEMORY[0x1E0C809B0];
    v48 = 1107296256;
    v49 = (uint64_t (*)(uint64_t))sub_182FC77FC;
    v50 = &block_descriptor_47;
    v27 = _Block_copy(&aBlock);
    swift_unknownObjectRetain();
    swift_release();
    nw_path_monitor_set_update_handler(v24, v27);
    _Block_release(v27);
    swift_unknownObjectRelease();
    v28 = swift_allocObject();
    swift_weakInit();
    v51 = sub_183056688;
    v52 = v28;
    aBlock = v26;
    v48 = 1107296256;
    v49 = sub_18305665C;
    v50 = &block_descriptor_51;
    v29 = _Block_copy(&aBlock);
    swift_unknownObjectRetain();
    swift_release();
    nw_path_monitor_set_cancel_handler(v24, v29);
    _Block_release(v29);
    swift_unknownObjectRelease();
    v30 = (void *)nw_path_monitor_copy_parameters(v24);
    swift_unknownObjectRetain();
    result = (int *)nw_parameters_copy_context(v30);
    if (result)
    {
      v31 = nw_context_copy_workloop(result);
      swift_unknownObjectRelease();
      nw_path_monitor_set_queue(v24, (dispatch_queue_t)v31);
      swift_unknownObjectRelease();

      nw_path_monitor_start(v24);
      return (int *)swift_unknownObjectRelease();
    }
    else
    {
      __break(1u);
    }
  }
  return result;
}

void nw_path_monitor_set_update_handler(nw_path_monitor_t monitor, nw_path_monitor_update_handler_t update_handler)
{
  NSObject *v3;
  nw_path_monitor_update_handler_t v4;
  void *v5;
  NSObject *v6;
  id v7;
  objc_class *v8;
  Class isa;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = monitor;
  v4 = update_handler;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_path_monitor_set_update_handler";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_path_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_path_monitor_set_update_handler";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v11)
          goto LABEL_4;
LABEL_39:
        free(v11);
        goto LABEL_4;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_path_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_path_monitor_set_update_handler";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v6 = v3;
    v7 = v5;
    os_unfair_lock_lock((os_unfair_lock_t)&v6[12]);
    v8 = (objc_class *)_Block_copy(v7);
    isa = v6[8].isa;
    v6[8].isa = v8;

    os_unfair_lock_unlock((os_unfair_lock_t)&v6[12]);
    goto LABEL_4;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_path_monitor_set_update_handler";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v11, &type, &v24))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_path_monitor_set_update_handler";
      _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null update_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_path_monitor_set_update_handler";
      _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null update_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v19 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  v20 = type;
  v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_path_monitor_set_update_handler";
      _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_path_monitor_set_update_handler";
    v28 = 2082;
    v29 = v19;
    _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null update_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11)
    goto LABEL_39;
LABEL_4:

}

void nw_path_monitor_set_queue(nw_path_monitor_t monitor, dispatch_queue_t queue)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = monitor;
  v4 = queue;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_path_monitor_set_queue";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_monitor_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_path_monitor_set_queue";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_monitor_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_path_monitor_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    nw_path_evaluator_set_queue(v3, v4);
    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_path_monitor_set_queue";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_path_monitor_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_path_monitor_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_path_monitor_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_path_monitor_set_queue";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

void nw_path_evaluator_set_queue(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *v10;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_evaluator_set_queue";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
      goto LABEL_58;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_evaluator_set_queue";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_evaluator_set_queue";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_58:
        if (!v15)
          goto LABEL_24;
LABEL_59:
        free(v15);
        goto LABEL_24;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_evaluator_set_queue";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_evaluator_set_queue";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_57:

    goto LABEL_58;
  }
  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 24);
    if ((*((_BYTE *)v3 + 107) & 0x10) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_path_evaluator_set_queue";
      v7 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v28 = 0;
      if (__nwlog_fault(v7, &type, &v28))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = (id)gLogObj;
          v9 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446210;
            v31 = "nw_path_evaluator_set_queue";
            _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s Client error: set queue after starting", buf, 0xCu);
          }
        }
        else if (v28)
        {
          v10 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = (id)gLogObj;
          v11 = type;
          v12 = os_log_type_enabled(v8, type);
          if (v10)
          {
            if (v12)
            {
              *(_DWORD *)buf = 136446466;
              v31 = "nw_path_evaluator_set_queue";
              v32 = 2082;
              v33 = v10;
              _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s Client error: set queue after starting, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v10);
            if (!v7)
              goto LABEL_23;
            goto LABEL_22;
          }
          if (v12)
          {
            *(_DWORD *)buf = 136446210;
            v31 = "nw_path_evaluator_set_queue";
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s Client error: set queue after starting, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = (id)gLogObj;
          v13 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446210;
            v31 = "nw_path_evaluator_set_queue";
            _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s Client error: set queue after starting, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (v7)
LABEL_22:
        free(v7);
    }
LABEL_23:
    objc_storeStrong((id *)v3 + 7, a2);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 24);
    goto LABEL_24;
  }
  __nwlog_obj();
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v31 = "nw_path_evaluator_set_queue";
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (!__nwlog_fault(v15, &type, &v28))
    goto LABEL_58;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_57;
  }
  if (!v28)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_57;
  }
  v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  v24 = type;
  v25 = os_log_type_enabled(v16, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_path_evaluator_set_queue";
      _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_57;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    v31 = "nw_path_evaluator_set_queue";
    v32 = 2082;
    v33 = v23;
    _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v15)
    goto LABEL_59;
LABEL_24:

}

void nw_path_monitor_start(nw_path_monitor_t monitor)
{
  NSObject *v1;
  NSObject *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = monitor;
  v2 = v1;
  if (v1)
  {
    nw_path_evaluator_start(v1);
    nw_path_evaluator_call_update_handler(v2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_path_monitor_start";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_monitor_start";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_path_monitor_start";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_monitor_start";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_monitor_start";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

void sub_1831E2728(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_path_evaluator_call_update_handler(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  const void *v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  _QWORD block[4];
  os_unfair_lock_s *v20;
  id v21;
  id v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  _BYTE v28[14];
  __int16 v29;
  id v30;
  __int16 v31;
  void *v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 24);
    v3 = *(id *)&v2[12]._os_unfair_lock_opaque;
    if (v3 && (v4 = *(const void **)&v2[16]._os_unfair_lock_opaque) != 0 && *(_QWORD *)&v2[14]._os_unfair_lock_opaque)
    {
      v5 = _Block_copy(v4);
      if (__nwlog_path_log::onceToken[0] != -1)
        dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44205);
      v6 = (id)gpathLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446722;
        v26 = "nw_path_evaluator_call_update_handler";
        v27 = 1042;
        *(_DWORD *)v28 = 16;
        *(_WORD *)&v28[4] = 2098;
        *(_QWORD *)&v28[6] = v2 + 20;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s [%{public,uuid_t}.16P] scheduling update", buf, 0x1Cu);
      }

      v7 = *(NSObject **)&v2[14]._os_unfair_lock_opaque;
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __nw_path_evaluator_call_update_handler_block_invoke;
      block[3] = &unk_1E14A8D98;
      v20 = v2;
      v22 = v5;
      v21 = v3;
      v8 = v5;
      dispatch_async(v7, block);

    }
    else
    {
      if (__nwlog_path_log::onceToken[0] != -1)
        dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44205);
      v8 = (id)gpathLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v9 = _Block_copy(*(const void **)&v2[16]._os_unfair_lock_opaque);
        v10 = *(_QWORD *)&v2[14]._os_unfair_lock_opaque;
        *(_DWORD *)buf = 136447490;
        v26 = "nw_path_evaluator_call_update_handler";
        v27 = 1042;
        *(_DWORD *)v28 = 16;
        *(_WORD *)&v28[4] = 2098;
        *(_QWORD *)&v28[6] = v2 + 20;
        v29 = 2048;
        v30 = v3;
        v31 = 2048;
        v32 = v9;
        v33 = 2048;
        v34 = v10;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s [%{public,uuid_t}.16P] not delivering update, path=%p, update_block=%p, client_queue=%p", buf, 0x3Au);

      }
    }

    os_unfair_lock_unlock(v2 + 24);
    goto LABEL_15;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_path_evaluator_call_update_handler";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v12, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_evaluator_call_update_handler";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_path_evaluator_call_update_handler";
          v27 = 2082;
          *(_QWORD *)v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_evaluator_call_update_handler";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_evaluator_call_update_handler";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_32:
  if (v12)
    free(v12);
LABEL_15:

}

void nw_path_monitor_set_cancel_handler(nw_path_monitor_t monitor, nw_path_monitor_cancel_handler_t cancel_handler)
{
  nw_path_monitor_t v3;
  nw_path_monitor_cancel_handler_t v4;
  void *v5;
  id v6;
  NSObject *v7;
  objc_class *v8;
  Class isa;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = monitor;
  v4 = cancel_handler;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_path_monitor_set_cancel_handler";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_path_monitor_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_path_monitor_set_cancel_handler";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v11)
          goto LABEL_4;
LABEL_39:
        free(v11);
        goto LABEL_4;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_path_monitor_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_path_monitor_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v6 = v4;
    v7 = v3;
    os_unfair_lock_lock((os_unfair_lock_t)&v3[12]);
    v8 = (objc_class *)_Block_copy(v6);

    isa = v7[9].isa;
    v7[9].isa = v8;

    os_unfair_lock_unlock((os_unfair_lock_t)&v3[12]);
    goto LABEL_4;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_path_monitor_set_cancel_handler";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v11, &type, &v24))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_path_monitor_set_cancel_handler";
      _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null cancel_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_path_monitor_set_cancel_handler";
      _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null cancel_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v19 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  v20 = type;
  v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_path_monitor_set_cancel_handler";
      _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null cancel_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_path_monitor_set_cancel_handler";
    v28 = 2082;
    v29 = v19;
    _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null cancel_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11)
    goto LABEL_39;
LABEL_4:

}

id nw_path_evaluator_copy_parameters(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 24);
    v3 = *(id *)&v2[2]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 24);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_evaluator_copy_parameters";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_evaluator_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_evaluator_copy_parameters";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_evaluator_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_evaluator_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void ___ZL36nw_endpoint_flow_validate_delegationP30NWConcrete_nw_endpoint_handler_block_invoke()
{
  uint64_t v0;
  void *v1;
  uint64_t v2;
  void *v3;

  v0 = nw_utilities_copy_local_entitlement_value("com.apple.private.network.delegation-allowlist");
  v1 = (void *)nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist;
  nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist = v0;

  if (!nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist)
  {
    v2 = nw_utilities_copy_local_entitlement_value("com.apple.private.network.delegation-whitelist");
    v3 = (void *)nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist;
    nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist = v2;

  }
}

uint64_t nw_utilities_copy_local_entitlement_value(char *cStr)
{
  const __CFAllocator *v2;
  CFStringRef v3;
  const __CFString *v4;
  __SecTask *v5;
  __SecTask *v6;
  CFTypeRef v7;
  id v8;
  void *v9;
  NSObject *v10;
  os_log_type_t v11;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  id v16;
  NSObject *v17;
  os_log_type_t v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  os_log_type_t v29;
  os_log_type_t v30;
  uint64_t v31;
  id v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  char *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  os_log_type_t v39;
  void *v41;
  os_log_type_t v42;
  char *backtrace_string;
  os_log_type_t v44;
  _BOOL4 v45;
  os_log_type_t v46;
  char v47;
  CFErrorRef error;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  CFErrorRef v53;
  __int16 v54;
  char *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (!cStr)
  {
    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_utilities_copy_local_entitlement_value";
    v13 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, &error, &type))
      goto LABEL_74;
    if (error == 17)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v42 = error;
      if (os_log_type_enabled(v17, (os_log_type_t)error))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_utilities_copy_local_entitlement_value";
        _os_log_impl(&dword_182FBE000, v17, v42, "%{public}s called with null entitlement", buf, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v44 = error;
      v45 = os_log_type_enabled(v17, (os_log_type_t)error);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_utilities_copy_local_entitlement_value";
          v52 = 2082;
          v53 = (CFErrorRef)backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v44, "%{public}s called with null entitlement, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_74;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_utilities_copy_local_entitlement_value";
        _os_log_impl(&dword_182FBE000, v17, v44, "%{public}s called with null entitlement, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v46 = error;
      if (os_log_type_enabled(v17, (os_log_type_t)error))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_utilities_copy_local_entitlement_value";
        _os_log_impl(&dword_182FBE000, v17, v46, "%{public}s called with null entitlement, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_73:

    goto LABEL_74;
  }
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
  if (v3)
  {
    v4 = v3;
    v5 = SecTaskCreateFromSelf(v2);
    if (v5)
    {
      v6 = v5;
      error = 0;
      v7 = SecTaskCopyValueForEntitlement(v5, v4, &error);
      if (!error)
        goto LABEL_57;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v51 = "nw_utilities_copy_local_entitlement_value";
      v52 = 2114;
      v53 = error;
      v9 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v47 = 0;
      if (__nwlog_fault((const char *)v9, &type, &v47))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v51 = "nw_utilities_copy_local_entitlement_value";
            v52 = 2114;
            v53 = error;
            _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s SecTaskCopyValueForEntitlement %{public}@ failed", buf, 0x16u);
          }
        }
        else if (v47)
        {
          v22 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          v23 = type;
          v24 = os_log_type_enabled(v10, type);
          if (v22)
          {
            if (v24)
            {
              *(_DWORD *)buf = 136446722;
              v51 = "nw_utilities_copy_local_entitlement_value";
              v52 = 2114;
              v53 = error;
              v54 = 2082;
              v55 = v22;
              _os_log_impl(&dword_182FBE000, v10, v23, "%{public}s SecTaskCopyValueForEntitlement %{public}@ failed, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v22);
            if (!v9)
              goto LABEL_55;
LABEL_54:
            free(v9);
LABEL_55:
            if (error)
            {
              CFRelease(error);
              error = 0;
            }
LABEL_57:
            if (!v7)
            {
              v31 = 0;
LABEL_86:
              CFRelease(v6);
              CFRelease(v4);
              return v31;
            }
            v31 = _CFXPCCreateXPCObjectFromCFObject();
            if (!v31)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v32 = (id)gLogObj;
              *(_DWORD *)buf = 136446210;
              v51 = "nw_utilities_copy_local_entitlement_value";
              v33 = (char *)_os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v47 = 0;
              if (__nwlog_fault(v33, &type, &v47))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v34 = (id)gLogObj;
                  v35 = type;
                  if (os_log_type_enabled(v34, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v51 = "nw_utilities_copy_local_entitlement_value";
                    _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s _CFXPCCreateXPCObjectFromCFObject failed", buf, 0xCu);
                  }
                }
                else if (v47)
                {
                  v36 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v34 = objc_claimAutoreleasedReturnValue();
                  v37 = type;
                  v38 = os_log_type_enabled(v34, type);
                  if (v36)
                  {
                    if (v38)
                    {
                      *(_DWORD *)buf = 136446466;
                      v51 = "nw_utilities_copy_local_entitlement_value";
                      v52 = 2082;
                      v53 = (CFErrorRef)v36;
                      _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s _CFXPCCreateXPCObjectFromCFObject failed, dumping backtrace:%{public}s", buf, 0x16u);
                    }

                    free(v36);
                    if (!v33)
                      goto LABEL_85;
                    goto LABEL_84;
                  }
                  if (v38)
                  {
                    *(_DWORD *)buf = 136446210;
                    v51 = "nw_utilities_copy_local_entitlement_value";
                    _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s _CFXPCCreateXPCObjectFromCFObject failed, no backtrace", buf, 0xCu);
                  }
                }
                else
                {
                  __nwlog_obj();
                  v34 = objc_claimAutoreleasedReturnValue();
                  v39 = type;
                  if (os_log_type_enabled(v34, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v51 = "nw_utilities_copy_local_entitlement_value";
                    _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s _CFXPCCreateXPCObjectFromCFObject failed, backtrace limit exceeded", buf, 0xCu);
                  }
                }

              }
              if (v33)
LABEL_84:
                free(v33);
            }
LABEL_85:
            CFRelease(v7);
            goto LABEL_86;
          }
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            v51 = "nw_utilities_copy_local_entitlement_value";
            v52 = 2114;
            v53 = error;
            _os_log_impl(&dword_182FBE000, v10, v23, "%{public}s SecTaskCopyValueForEntitlement %{public}@ failed, no backtrace", buf, 0x16u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          v29 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v51 = "nw_utilities_copy_local_entitlement_value";
            v52 = 2114;
            v53 = error;
            _os_log_impl(&dword_182FBE000, v10, v29, "%{public}s SecTaskCopyValueForEntitlement %{public}@ failed, backtrace limit exceeded", buf, 0x16u);
          }
        }

      }
      if (!v9)
        goto LABEL_55;
      goto LABEL_54;
    }
    CFRelease(v4);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v51 = "nw_utilities_copy_local_entitlement_value";
    v13 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v13, &error, &type))
    {
      if (error == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        v18 = error;
        if (os_log_type_enabled(v17, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_utilities_copy_local_entitlement_value";
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s SecTaskCreateFromSelf failed", buf, 0xCu);
        }
      }
      else if (type)
      {
        v25 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        v26 = error;
        v27 = os_log_type_enabled(v17, (os_log_type_t)error);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            v51 = "nw_utilities_copy_local_entitlement_value";
            v52 = 2082;
            v53 = (CFErrorRef)v25;
            _os_log_impl(&dword_182FBE000, v17, v26, "%{public}s SecTaskCreateFromSelf failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v25);
          if (!v13)
            return 0;
          goto LABEL_75;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_utilities_copy_local_entitlement_value";
          _os_log_impl(&dword_182FBE000, v17, v26, "%{public}s SecTaskCreateFromSelf failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        v30 = error;
        if (os_log_type_enabled(v17, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_utilities_copy_local_entitlement_value";
          _os_log_impl(&dword_182FBE000, v17, v30, "%{public}s SecTaskCreateFromSelf failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_73;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v51 = "nw_utilities_copy_local_entitlement_value";
    v52 = 2082;
    v53 = (CFErrorRef)cStr;
    v13 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v13, &error, &type))
    {
      if (error == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v15 = error;
        if (os_log_type_enabled(v14, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_utilities_copy_local_entitlement_value";
          v52 = 2082;
          v53 = (CFErrorRef)cStr;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s CFStringCreateWithCString(%{public}s) failed", buf, 0x16u);
        }
      }
      else if (type)
      {
        v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v20 = error;
        v21 = os_log_type_enabled(v14, (os_log_type_t)error);
        if (v19)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446722;
            v51 = "nw_utilities_copy_local_entitlement_value";
            v52 = 2082;
            v53 = (CFErrorRef)cStr;
            v54 = 2082;
            v55 = v19;
            _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s CFStringCreateWithCString(%{public}s) failed, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v19);
          if (!v13)
            return 0;
          goto LABEL_75;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_utilities_copy_local_entitlement_value";
          v52 = 2082;
          v53 = (CFErrorRef)cStr;
          _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s CFStringCreateWithCString(%{public}s) failed, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v28 = error;
        if (os_log_type_enabled(v14, (os_log_type_t)error))
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_utilities_copy_local_entitlement_value";
          v52 = 2082;
          v53 = (CFErrorRef)cStr;
          _os_log_impl(&dword_182FBE000, v14, v28, "%{public}s CFStringCreateWithCString(%{public}s) failed, backtrace limit exceeded", buf, 0x16u);
        }
      }

    }
  }
LABEL_74:
  if (v13)
LABEL_75:
    free(v13);
  return 0;
}

void sub_1831E4114(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_path_copy_parameters(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_copy_parameters";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_copy_parameters";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_path_copy_path_for_client_with_context(uint64_t a1)
{
  unsigned __int8 *v1;
  id v2;
  id v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  int v8;
  int v9;
  uint8_t *v10;
  NWConcrete_nw_path *v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  id v15;
  os_log_type_t v16;
  os_log_type_t v17;
  int v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  unint64_t StatusReg;
  int v26;
  NSObject *v27;
  NSObject *v28;
  os_log_type_t v29;
  os_log_type_t v30;
  char *v31;
  os_log_type_t v32;
  _BOOL4 v33;
  NSObject *v34;
  void *v35;
  NSObject *v36;
  os_log_type_t v37;
  os_log_type_t v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  int v42;
  NSObject *v43;
  NSObject *v44;
  char *v45;
  NSObject *v46;
  os_log_type_t v47;
  os_log_type_t v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  os_log_type_t v52;
  _BOOL8 result;
  NSObject *v54;
  void *v55;
  char v56;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  _QWORD v61[766];
  os_log_type_t v62[1024];
  int v63;
  const char *v64;
  __int16 v65;
  _BYTE v66[18];
  uint64_t v67;

  v1 = (unsigned __int8 *)MEMORY[0x1E0C80A78](a1);
  v67 = *MEMORY[0x1E0C80C00];
  v3 = v2;
  if (uuid_is_null(v1))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v59 = "nw_path_copy_path_for_client_with_context";
    v5 = (char *)_os_log_send_and_compose_impl();

    v62[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v63) = 0;
    if (!__nwlog_fault(v5, v62, &v63))
      goto LABEL_112;
    if (v62[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null client_id", buf, 0xCu);
      }
    }
    else if ((_BYTE)v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v13 = v62[0];
      v14 = os_log_type_enabled(v6, v62[0]);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_path_copy_path_for_client_with_context";
          v60 = 2082;
          v61[0] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v13, "%{public}s called with null client_id, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v5)
          goto LABEL_114;
        goto LABEL_113;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_182FBE000, v6, v13, "%{public}s called with null client_id, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v17 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_182FBE000, v6, v17, "%{public}s called with null client_id, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_70:

    goto LABEL_112;
  }
  if ((nw_path_shared_necp_observer_fd(v3) & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v59 = "nw_path_copy_path_for_client_with_context";
    v5 = (char *)_os_log_send_and_compose_impl();

    v62[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v63) = 0;
    if (!__nwlog_fault(v5, v62, &v63))
      goto LABEL_112;
    if (v62[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v16 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s nw_path_shared_necp_observer_fd failed", buf, 0xCu);
      }
    }
    else if ((_BYTE)v63)
    {
      v21 = __nw_create_backtrace_string();
      if (v21)
      {
        v22 = (char *)v21;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v24 = v62[0];
        if (os_log_type_enabled(v23, v62[0]))
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_path_copy_path_for_client_with_context";
          v60 = 2082;
          v61[0] = v22;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s nw_path_shared_necp_observer_fd failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        if (!v5)
          goto LABEL_114;
        goto LABEL_113;
      }
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v38 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_182FBE000, v6, v38, "%{public}s nw_path_shared_necp_observer_fd failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v30 = v62[0];
      if (os_log_type_enabled(v6, v62[0]))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_path_copy_path_for_client_with_context";
        _os_log_impl(&dword_182FBE000, v6, v30, "%{public}s nw_path_shared_necp_observer_fd failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_70;
  }
  bzero(v62, 0x400uLL);
  v8 = necp_client_action();
  if (v8 <= 0)
  {
    v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    v20 = v19;
    if (v18 == 2)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v59 = "nw_path_copy_path_for_client_with_context";
        v60 = 1024;
        LODWORD(v61[0]) = 2;
        _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d", buf, 0x12u);
      }

      goto LABEL_114;
    }
    *(_DWORD *)buf = 136446466;
    v59 = "nw_path_copy_path_for_client_with_context";
    v60 = 1024;
    LODWORD(v61[0]) = v18;
    v5 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v63) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v5, &v63, &type))
    {
      if (v63 == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        v29 = v63;
        if (os_log_type_enabled(v28, (os_log_type_t)v63))
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_path_copy_path_for_client_with_context";
          v60 = 1024;
          LODWORD(v61[0]) = v18;
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (type)
      {
        v31 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v32 = v63;
        v33 = os_log_type_enabled(v28, (os_log_type_t)v63);
        if (v31)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446722;
            v59 = "nw_path_copy_path_for_client_with_context";
            v60 = 1024;
            LODWORD(v61[0]) = v18;
            WORD2(v61[0]) = 2082;
            *(_QWORD *)((char *)v61 + 6) = v31;
            _os_log_impl(&dword_182FBE000, v28, v32, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          goto LABEL_76;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_path_copy_path_for_client_with_context";
          v60 = 1024;
          LODWORD(v61[0]) = v18;
          _os_log_impl(&dword_182FBE000, v28, v32, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v41 = v63;
        if (os_log_type_enabled(v28, (os_log_type_t)v63))
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_path_copy_path_for_client_with_context";
          v60 = 1024;
          LODWORD(v61[0]) = v18;
          _os_log_impl(&dword_182FBE000, v28, v41, "%{public}s NECP_CLIENT_ACTION_COPY_PARAMETERS failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
LABEL_112:
    if (!v5)
    {
LABEL_114:
      v11 = 0;
LABEL_115:

      return (BOOL)v11;
    }
LABEL_113:
    free(v5);
    goto LABEL_114;
  }
  bzero(buf, 0x1800uLL);
  v9 = necp_client_action();
  if (v9 > 0)
  {
    v5 = 0;
    v10 = buf;
    goto LABEL_11;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v26 = **(_DWORD **)(StatusReg + 8);
  if (v26 != 22)
  {
    if (v26 == 2)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        v63 = 136446466;
        v64 = "nw_path_copy_path_for_client_with_context";
        v65 = 1024;
        *(_DWORD *)v66 = 2;
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
      }

      goto LABEL_114;
    }
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    v63 = 136446466;
    v64 = "nw_path_copy_path_for_client_with_context";
    v65 = 1024;
    *(_DWORD *)v66 = v26;
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (__nwlog_fault(v5, &type, &v56))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          v63 = 136446466;
          v64 = "nw_path_copy_path_for_client_with_context";
          v65 = 1024;
          *(_DWORD *)v66 = v26;
          _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
        }
LABEL_98:

        goto LABEL_112;
      }
      if (!v56)
      {
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        if (os_log_type_enabled(v36, type))
        {
          v63 = 136446466;
          v64 = "nw_path_copy_path_for_client_with_context";
          v65 = 1024;
          *(_DWORD *)v66 = v26;
          _os_log_impl(&dword_182FBE000, v36, v48, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)&v63, 0x12u);
        }
        goto LABEL_98;
      }
      v31 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v36, type);
      if (!v31)
      {
        if (v40)
        {
          v63 = 136446466;
          v64 = "nw_path_copy_path_for_client_with_context";
          v65 = 1024;
          *(_DWORD *)v66 = v26;
          _os_log_impl(&dword_182FBE000, v36, v39, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, no backtrace", (uint8_t *)&v63, 0x12u);
        }
        goto LABEL_98;
      }
      if (v40)
      {
        v63 = 136446722;
        v64 = "nw_path_copy_path_for_client_with_context";
        v65 = 1024;
        *(_DWORD *)v66 = v26;
        *(_WORD *)&v66[4] = 2082;
        *(_QWORD *)&v66[6] = v31;
        _os_log_impl(&dword_182FBE000, v36, v39, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&v63, 0x1Cu);
      }

LABEL_76:
      free(v31);
      if (!v5)
        goto LABEL_114;
      goto LABEL_113;
    }
    goto LABEL_112;
  }
  __nwlog_obj();
  v34 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    v63 = 136446466;
    v64 = "nw_path_copy_path_for_client_with_context";
    v65 = 1024;
    *(_DWORD *)v66 = 48;
    _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s Trying to copy result again for %u flows", (uint8_t *)&v63, 0x12u);
  }

  v5 = (char *)malloc_type_calloc(1uLL, 0x6400uLL, 0xEAFB8F1AuLL);
  if (v5)
  {
LABEL_61:
    v9 = necp_client_action();
    if (v9 > 0)
    {
      v10 = (uint8_t *)v5;
LABEL_11:
      v11 = nw_path_copy_path_for_tlv(v1, v3, (uint64_t)v62, v8, (uint64_t)v10, v9);
      if (v5)
        free(v5);
      goto LABEL_115;
    }
    v42 = **(_DWORD **)(StatusReg + 8);
    __nwlog_obj();
    v43 = objc_claimAutoreleasedReturnValue();
    v44 = v43;
    if (v42 == 2)
    {
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        v63 = 136446466;
        v64 = "nw_path_copy_path_for_client_with_context";
        v65 = 1024;
        *(_DWORD *)v66 = 2;
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
      }

      goto LABEL_112;
    }
    v63 = 136446466;
    v64 = "nw_path_copy_path_for_client_with_context";
    v65 = 1024;
    *(_DWORD *)v66 = v42;
    v45 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (!__nwlog_fault(v45, &type, &v56))
      goto LABEL_110;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        v63 = 136446466;
        v64 = "nw_path_copy_path_for_client_with_context";
        v65 = 1024;
        *(_DWORD *)v66 = v42;
        _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d", (uint8_t *)&v63, 0x12u);
      }
    }
    else if (v56)
    {
      v49 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v46 = objc_claimAutoreleasedReturnValue();
      v50 = type;
      v51 = os_log_type_enabled(v46, type);
      if (v49)
      {
        if (v51)
        {
          v63 = 136446722;
          v64 = "nw_path_copy_path_for_client_with_context";
          v65 = 1024;
          *(_DWORD *)v66 = v42;
          *(_WORD *)&v66[4] = 2082;
          *(_QWORD *)&v66[6] = v49;
          _os_log_impl(&dword_182FBE000, v46, v50, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&v63, 0x1Cu);
        }

        free(v49);
        goto LABEL_110;
      }
      if (v51)
      {
        v63 = 136446466;
        v64 = "nw_path_copy_path_for_client_with_context";
        v65 = 1024;
        *(_DWORD *)v66 = v42;
        _os_log_impl(&dword_182FBE000, v46, v50, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, no backtrace", (uint8_t *)&v63, 0x12u);
      }
    }
    else
    {
      __nwlog_obj();
      v46 = objc_claimAutoreleasedReturnValue();
      v52 = type;
      if (os_log_type_enabled(v46, type))
      {
        v63 = 136446466;
        v64 = "nw_path_copy_path_for_client_with_context";
        v65 = 1024;
        *(_DWORD *)v66 = v42;
        _os_log_impl(&dword_182FBE000, v46, v52, "%{public}s NECP_CLIENT_ACTION_COPY_RESULT %{darwin.errno}d, backtrace limit exceeded", (uint8_t *)&v63, 0x12u);
      }
    }

LABEL_110:
    if (v45)
      free(v45);
    goto LABEL_112;
  }
  __nwlog_obj();
  v54 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
  v63 = 136446722;
  v64 = "strict_calloc";
  v65 = 2048;
  *(_QWORD *)v66 = 1;
  *(_WORD *)&v66[8] = 2048;
  *(_QWORD *)&v66[10] = 25600;
  v55 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v55);
  if (!result)
  {
    free(v55);
    goto LABEL_61;
  }
  __break(1u);
  return result;
}

void sub_1831E53E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_path_copy_group_descriptor(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[4];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_copy_group_descriptor";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_group_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_copy_group_descriptor";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_group_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_group_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_path_copy_browse_descriptor(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[5];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_copy_browse_descriptor";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_browse_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_copy_browse_descriptor";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_browse_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_browse_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_path_copy_advertise_descriptor(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[6];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_copy_advertise_descriptor";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_advertise_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_copy_advertise_descriptor";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_advertise_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_advertise_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_resolver_set_cancel_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_resolver_set_cancel_handler";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_resolver_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_resolver_set_cancel_handler";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9)
          goto LABEL_4;
LABEL_39:
        free(v9);
        goto LABEL_4;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_resolver_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_resolver_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    os_unfair_lock_lock(v3 + 3);
    v6 = _Block_copy(v5);
    v7 = *(void **)&v3[26]._os_unfair_lock_opaque;
    *(_QWORD *)&v3[26]._os_unfair_lock_opaque = v6;

    os_unfair_lock_unlock(v3 + 3);
    goto LABEL_4;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_resolver_set_cancel_handler";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_resolver_set_cancel_handler";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null cancel_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_resolver_set_cancel_handler";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null cancel_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_resolver_set_cancel_handler";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null cancel_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_resolver_set_cancel_handler";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null cancel_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_39;
LABEL_4:

}

uint64_t __nw_parameters_prohibit_interface_type_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;

  v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1E0C81398])
  {
    v5 = 1;
    if (xpc_uint64_get_value(v4) == *(_DWORD *)(a1 + 40))
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      v5 = 0;
    }
  }
  else
  {
    v5 = 1;
  }

  return v5;
}

void sub_1831E612C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1831E6E0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1831E7300(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1831E746C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

size_t nw_parameters_get_hash(void *a1)
{
  char *v1;
  const void *v2;
  CC_LONG v3;
  const void *v4;
  CC_LONG v5;
  uint64_t v6;
  const void *v7;
  CC_LONG v8;
  const void *v9;
  CC_LONG v10;
  const void *v11;
  CC_LONG v12;
  const void *v13;
  uint64_t v14;
  int8x16_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t shallow_hash;
  uint64_t hash;
  id v20;
  uint64_t v21;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned __int8 *v24;
  size_t v25;
  size_t v26;
  void *v27;
  size_t v28;
  void *v29;
  size_t v30;
  NSObject *v31;
  void *v32;
  size_t v33;
  size_t v34;
  _QWORD applier[5];
  _QWORD v37[5];
  _QWORD v38[5];
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  __n128 (*v42)(uint64_t, uint64_t);
  uint64_t (*v43)();
  void *v44;
  CC_SHA256_CTX v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int8 md[16];
  int8x16_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v46 = 0;
    v47 = &v46;
    v48 = 0x2020000000;
    v49 = 0;
    v39 = 0;
    v40 = &v39;
    v41 = 0x9812000000;
    v42 = __Block_byref_object_copy__105;
    v43 = __Block_byref_object_dispose__106;
    memset(&v45, 0, sizeof(v45));
    v44 = &unk_183EA1965;
    CC_SHA256_Init(&v45);
    CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), v1 + 8, 0x60u);
    CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), (const void *)(*((_QWORD *)v1 + 13) + 8), 0x40u);
    CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), (const void *)(*((_QWORD *)v1 + 13) + 72), 0x1Eu);
    CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), (const void *)(*((_QWORD *)v1 + 13) + 102), 9u);
    v2 = (const void *)*((_QWORD *)v1 + 14);
    if (v2)
    {
      v3 = strlen(*((const char **)v1 + 14));
      CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), v2, v3);
    }
    v4 = (const void *)*((_QWORD *)v1 + 15);
    if (v4)
    {
      v5 = strlen(*((const char **)v1 + 15));
      CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), v4, v5);
    }
    v6 = *((_QWORD *)v1 + 13);
    v7 = *(const void **)(v6 + 112);
    if (v7)
    {
      v8 = strlen(*(const char **)(v6 + 112));
      CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), v7, v8);
      v6 = *((_QWORD *)v1 + 13);
    }
    v9 = *(const void **)(v6 + 120);
    if (v9)
    {
      v10 = strlen(*(const char **)(v6 + 120));
      CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), v9, v10);
      v6 = *((_QWORD *)v1 + 13);
    }
    v11 = *(const void **)(v6 + 128);
    if (v11)
    {
      v12 = strlen(*(const char **)(v6 + 128));
      CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), v11, v12);
      v6 = *((_QWORD *)v1 + 13);
    }
    v14 = *(_QWORD *)(v6 + 136);
    v13 = (const void *)(v6 + 136);
    if (v14)
      CC_SHA256_Update((CC_SHA256_CTX *)(v40 + 6), v13, 8u);
    CC_SHA256_Final(md, (CC_SHA256_CTX *)(v40 + 6));
    v15 = veorq_s8(*(int8x16_t *)md, v51);
    v47[3] ^= *(_QWORD *)&veor_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
    v16 = objc_msgSend(*((id *)v1 + 25), "getHash");
    v47[3] ^= v16;
    v17 = objc_msgSend(*(id *)(*((_QWORD *)v1 + 13) + 160), "getHash");
    v47[3] ^= v17;
    shallow_hash = nw_interface_get_shallow_hash(*(void **)(*((_QWORD *)v1 + 13) + 168));
    v47[3] ^= shallow_hash;
    hash = nw_protocol_stack_get_hash(*((void **)v1 + 19));
    v47[3] ^= hash;
    v20 = nw_parameters_copy_path_parameters(v1, 0);
    v21 = nw_path_parameters_get_hash(v20);
    v47[3] ^= v21;

    v22 = (unsigned __int8 *)*((_QWORD *)v1 + 20);
    v23 = MEMORY[0x1E0C809B0];
    if (v22)
    {
      v38[0] = MEMORY[0x1E0C809B0];
      v38[1] = 3221225472;
      v38[2] = __nw_parameters_get_hash_block_invoke;
      v38[3] = &unk_1E14A8DC0;
      v38[4] = &v46;
      nw_array_apply(v22, (uint64_t)v38);
    }
    v24 = (unsigned __int8 *)*((_QWORD *)v1 + 22);
    v37[0] = v23;
    v37[1] = 3221225472;
    v37[2] = __nw_parameters_get_hash_block_invoke_2;
    v37[3] = &unk_1E14A8DC0;
    v37[4] = &v46;
    nw_array_apply(v24, (uint64_t)v37);
    v25 = nw_proxy_config_get_hash(*((void **)v1 + 23));
    v47[3] ^= v25;
    v26 = nw_proxy_config_get_hash(*((void **)v1 + 24));
    v47[3] ^= v26;
    v27 = (void *)*((_QWORD *)v1 + 16);
    if (v27)
    {
      v28 = xpc_hash(v27);
      v47[3] ^= v28;
    }
    v29 = (void *)*((_QWORD *)v1 + 17);
    if (v29)
    {
      v30 = xpc_hash(v29);
      v47[3] ^= v30;
    }
    v31 = *((_QWORD *)v1 + 18);
    if (v31)
    {
      applier[0] = v23;
      applier[1] = 3221225472;
      applier[2] = __nw_parameters_get_hash_block_invoke_3;
      applier[3] = &unk_1E149DE48;
      applier[4] = &v39;
      dispatch_data_apply(v31, applier);
    }
    v32 = (void *)*((_QWORD *)v1 + 27);
    if (v32)
    {
      v33 = xpc_hash(v32);
      v34 = v47[3] ^ v33;
      v47[3] = v34;
    }
    else
    {
      v34 = v47[3];
    }
    _Block_object_dispose(&v39, 8);
    _Block_object_dispose(&v46, 8);
  }
  else
  {
    v34 = 0;
  }

  return v34;
}

void sub_1831E7B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  void *v17;
  void *v18;
  uint64_t v19;
  void *v20;
  va_list va;

  va_start(va, a17);
  v20 = v18;

  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v19 - 136), 8);

  _Unwind_Resume(a1);
}

size_t nw_proxy_config_get_hash(void *a1)
{
  id v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  size_t v6;
  void *v7;
  size_t v8;
  void *v9;
  size_t v10;
  void *v11;
  size_t v12;
  void *v13;
  size_t v14;
  void *v15;
  size_t v16;
  void *v17;
  size_t v18;
  void *v19;
  size_t v20;
  size_t v21;
  _QWORD v23[5];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v24 = 0;
    v25 = &v24;
    v26 = 0x2020000000;
    v27 = 0;
    v3 = objc_msgSend(*((id *)v1 + 5), "getHash");
    v25[3] ^= v3;
    v4 = v2[1];
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = __nw_proxy_config_get_hash_block_invoke;
    v23[3] = &unk_1E14A1078;
    v23[4] = &v24;
    nw_dictionary_apply(v4, (uint64_t)v23);
    v5 = (void *)v2[2];
    if (v5)
    {
      v6 = xpc_hash(v5);
      v25[3] ^= v6;
    }
    v7 = (void *)v2[3];
    if (v7)
    {
      v8 = xpc_hash(v7);
      v25[3] ^= v8;
    }
    v9 = (void *)v2[4];
    if (v9)
    {
      v10 = xpc_hash(v9);
      v25[3] ^= v10;
    }
    v11 = (void *)v2[14];
    if (v11)
    {
      v12 = xpc_hash(v11);
      v25[3] ^= v12;
    }
    v13 = (void *)v2[15];
    if (v13)
    {
      v14 = xpc_hash(v13);
      v25[3] ^= v14;
    }
    v15 = (void *)v2[16];
    if (v15)
    {
      v16 = xpc_hash(v15);
      v25[3] ^= v16;
    }
    v17 = (void *)v2[17];
    if (v17)
    {
      v18 = xpc_hash(v17);
      v25[3] ^= v18;
    }
    v19 = (void *)v2[18];
    if (v19)
    {
      v20 = xpc_hash(v19);
      v21 = v25[3] ^ v20;
      v25[3] = v21;
    }
    else
    {
      v21 = v25[3];
    }
    _Block_object_dispose(&v24, 8);
  }
  else
  {
    v21 = 0;
  }

  return v21;
}

void sub_1831E7D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_stack_get_hash(void *a1)
{
  unsigned __int8 **v1;
  unsigned __int8 **v2;
  unsigned __int8 *v3;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t hash;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[5];
  _QWORD v11[5];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v12 = 0;
    v13 = &v12;
    v14 = 0x2020000000;
    v15 = 0;
    v3 = v1[1];
    v4 = MEMORY[0x1E0C809B0];
    if (v3)
    {
      v11[0] = MEMORY[0x1E0C809B0];
      v11[1] = 3221225472;
      v11[2] = __nw_protocol_stack_get_hash_block_invoke;
      v11[3] = &unk_1E14A8DC0;
      v11[4] = &v12;
      nw_array_apply(v3, (uint64_t)v11);
    }
    v5 = v2[2];
    if (v5)
    {
      v10[0] = v4;
      v10[1] = 3221225472;
      v10[2] = __nw_protocol_stack_get_hash_block_invoke_2;
      v10[3] = &unk_1E14A8DC0;
      v10[4] = &v12;
      nw_array_apply(v5, (uint64_t)v10);
    }
    hash = nw_protocol_options_get_hash(v2[3]);
    v13[3] ^= hash;
    v7 = nw_protocol_options_get_hash(v2[6]);
    v8 = v13[3] ^ v7;
    v13[3] = v8;
    _Block_object_dispose(&v12, 8);
  }
  else
  {
    v8 = 0;
  }

  return v8;
}

void sub_1831E7E68(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  _Block_object_dispose((const void *)(v2 - 64), 8);

  _Unwind_Resume(a1);
}

double ___ZL34nw_flow_initialize_replay_protocolv_block_invoke()
{
  double result;

  unk_1ECD84964 = 0;
  unk_1ECD8495C = 0;
  dword_1ECD8496C = 0;
  strcpy((char *)&g_replay_protocol_identifier, "flow_replay");
  *(_QWORD *)&result = 0x300000004;
  qword_1ECD84970 = 0x300000004;
  qword_1ECD848A8 = (uint64_t)nw_protocol_default_get_local;
  unk_1ECD848B0 = nw_protocol_default_get_remote;
  qword_1ECD84898 = (uint64_t)nw_protocol_default_get_parameters;
  unk_1ECD848A0 = nw_protocol_default_get_path;
  qword_1ECD84928 = (uint64_t)nw_protocol_default_reset;
  unk_1ECD84930 = nw_protocol_default_input_flush;
  qword_1ECD84908 = (uint64_t)nw_protocol_default_copy_info;
  unk_1ECD84910 = nw_protocol_default_add_listen_handler;
  g_replay_protocol_callbacks = (uint64_t)nw_flow_replay_add_input_handler;
  unk_1ECD84830 = nw_flow_replay_remove_input_handler;
  qword_1ECD84878 = (uint64_t)nw_flow_replay_get_input_frames;
  unk_1ECD84880 = nw_flow_replay_get_output_frames;
  qword_1ECD84888 = (uint64_t)nw_flow_replay_finalize_output_frames;
  unk_1ECD84890 = nw_protocol_default_link_state;
  qword_1ECD848E8 = (uint64_t)nw_flow_replay_output_finished;
  unk_1ECD848F0 = nw_protocol_default_get_output_local;
  qword_1ECD84868 = (uint64_t)nw_protocol_default_input_available;
  unk_1ECD84870 = nw_flow_replay_output_available;
  qword_1ECD848C8 = (uint64_t)nw_protocol_default_notify;
  unk_1ECD848D0 = nw_flow_replay_updated_path;
  qword_1ECD84838 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1ECD84840 = nw_flow_replay_connect;
  qword_1ECD84848 = (uint64_t)nw_flow_replay_disconnect;
  unk_1ECD84850 = nw_protocol_default_connected;
  qword_1ECD84918 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_1ECD84920 = nw_flow_replay_get_message_properties;
  qword_1ECD848F8 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1ECD84900 = nw_flow_replay_waiting_for_output;
  qword_1ECD848B8 = (uint64_t)nw_flow_replay_register_notification;
  unk_1ECD848C0 = nw_flow_replay_unregister_notification;
  qword_1ECD848D8 = (uint64_t)nw_flow_passthrough_supports_external_data;
  unk_1ECD848E0 = nw_protocol_default_input_finished;
  qword_1ECD84858 = (uint64_t)nw_flow_replay_disconnected;
  unk_1ECD84860 = nw_protocol_default_error;
  return result;
}

ValueMetadata *type metadata accessor for NWConnection.LockedState()
{
  return &type metadata for NWConnection.LockedState;
}

ValueMetadata *type metadata accessor for NWListener.State()
{
  return &type metadata for NWListener.State;
}

ValueMetadata *type metadata accessor for NWListener.LockedState()
{
  return &type metadata for NWListener.LockedState;
}

BOOL nw_content_context_get_is_wake_packet(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  char v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = 0;
    if (v1 != &__block_literal_global_5_41741
      && v1 != &__block_literal_global_4
      && v1 != &__block_literal_global_3_41726
      && v1 != &__block_literal_global_41718)
    {
      v4 = *((_BYTE *)v1 + 118);
      v3 = v4 < 0;
      *((_BYTE *)v1 + 118) = v4 & 0x7F;
    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_content_context_get_is_wake_packet";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_get_is_wake_packet";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_content_context_get_is_wake_packet";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_get_is_wake_packet";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_content_context_get_is_wake_packet";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v7)
    free(v7);
  v3 = 0;
LABEL_7:

  return v3;
}

void nw_connection_send_stats_report_on_nw_queue(void *a1)
{
  void **v1;
  void **v2;
  uint64_t v3;
  uint64_t *v4;
  pid_t v5;
  NWConcrete_nw_endpoint_handler *v6;
  NWConcrete_nw_connection *v7;
  unsigned int event_milliseconds;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  float v12;
  float v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  NSObject *v17;
  unsigned int top_id;
  NSObject *v19;
  id v20;
  int v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  int v25;
  BOOL v26;
  char *v27;
  char *v28;
  _QWORD *v29;
  NSObject *v30;
  unsigned int v31;
  void *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  int v39;
  char *v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  int v44;
  os_log_type_t v45;
  int v46;
  os_log_type_t v47;
  _QWORD *v48;
  NSObject *v49;
  unsigned int v50;
  _QWORD *v51;
  NSObject *v52;
  unsigned int v53;
  void *v54;
  pid_t v55;
  _QWORD *v56;
  NSObject *v57;
  int v58;
  void *v59;
  os_log_type_t v60;
  char *backtrace_string;
  os_log_type_t v62;
  _BOOL4 v63;
  os_log_type_t v64;
  NSObject *v65;
  char v66;
  os_log_type_t type[4];
  const char *v68;
  __int16 v69;
  int v70;
  netcore_stats_tcp_report buf;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
    *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats"
                                                                                                "_report_on_nw_queue";
    v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (__nwlog_fault(v22, type, &v66))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v60 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v23, v60, "%{public}s called with null connection", (uint8_t *)&buf, 0xCu);
        }
        goto LABEL_79;
      }
      if (!v66)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v64 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v23, v64, "%{public}s called with null connection, backtrace limit exceeded", (uint8_t *)&buf, 0xCu);
        }
        goto LABEL_79;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      v63 = os_log_type_enabled(v23, type[0]);
      if (!backtrace_string)
      {
        if (v63)
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v23, v62, "%{public}s called with null connection, no backtrace", (uint8_t *)&buf, 0xCu);
        }
        goto LABEL_79;
      }
      if (v63)
      {
        LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
        *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
        WORD2(buf.u.nw_connection_report.bytes_out) = 2082;
        *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = (unint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v23, v62, "%{public}s called with null connection, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_80:
    if (!v22)
      goto LABEL_123;
LABEL_81:
    free(v22);
    goto LABEL_123;
  }
  nw_context_assert_queue(v1[3]);
  if ((*((_BYTE *)v2 + 108) & 3) != 1
    || !*((_DWORD *)v2 + 26)
    || (*((_BYTE *)v2 + 109) & 0x40) == 0
    || nw_parameters_get_data_mode(v2[2]) != 2)
  {
LABEL_109:
    if (((*((_BYTE *)v2 + 108) & 0xE4) != 0 || (*((_BYTE *)v2 + 109) & 2) != 0) && (*((_BYTE *)v2 + 108) & 8) == 0)
    {
      bzero(&buf, 0xD60uLL);
      v54 = v2[2];
      v55 = getpid();
      if (nw_parameters_has_delegated_proc_pid(v54, v55) || nw_parameters_has_delegated_proc_uuid(v2[2]))
        buf.delegated = 1;
      buf.legacy = 0;
      nw_connection_stats_fill_in_nw_report_on_nw_queue((NWConcrete_nw_connection *)v2, (nw_connection_report_s *)&buf);
      nw_connection_send_report_to_symptoms((NWConcrete_nw_connection *)v2, &buf, 0);
      *((_BYTE *)v2 + 108) |= 8u;
      v56 = v2[2];
      if (v56 && !nw_path_parameters_get_logging_disabled(v56[13]))
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v57 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
        {
          v58 = *((_DWORD *)v2 + 112);
          *(_DWORD *)type = 136446466;
          v68 = "nw_connection_send_stats_report_on_nw_queue";
          v69 = 1024;
          v70 = v58;
          _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Sent generic statistics report to symptoms", (uint8_t *)type, 0x12u);
        }

      }
    }
    nw_connection_log_summary_on_nw_queue((NWConcrete_nw_connection *)v2);
    goto LABEL_123;
  }
  v3 = (uint64_t)v2[12];
  v4 = (uint64_t *)v2[2];
  if (v3)
  {
    v5 = getpid();
    if (nw_parameters_has_delegated_proc_pid(v4, v5) || nw_parameters_has_delegated_proc_uuid(v2[2]))
      *(_BYTE *)(v3 + 3416) = 1;
    *(_DWORD *)(v3 + 3408) = *((_DWORD *)v2 + 26);
    v6 = nw_endpoint_handler_copy_connected_flow_handler(v2[18]);
    if (v6)
      nw_connection_stats_fill_in_statistics_report_for_endpoint_on_nw_queue(v2, v6, v3);
    *(_BYTE *)(v3 + 1672) = (*(_BYTE *)(v3 + 208) & 4) != 0;
    v7 = v2;
    *(_WORD *)type = 0;
    event_milliseconds = nw_connection_get_event_milliseconds(v7, 5, 1, type, 0);
    v9 = nw_connection_get_event_milliseconds(v7, 5, 2, type, 0);
    LODWORD(v10) = 0;
    if (event_milliseconds != -1 && v9 != -1)
    {
      v10 = v9 - event_milliseconds;
      if (v9 < event_milliseconds)
      {
        if (gLogDatapath)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446978;
            *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_get_fallback_margin_start_milliseconds";
            WORD2(buf.u.nw_connection_report.bytes_out) = 2082;
            *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = (unint64_t)"fallback_start";
            HIWORD(buf.u.nw_connection_report.bytes_duplicate) = 2048;
            buf.u.legacy.statistics_report.bytes_ooo = event_milliseconds;
            LOWORD(buf.u.nw_connection_report.bytes_retransmitted) = 2048;
            *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_retransmitted + 2) = v10;
            _os_log_impl(&dword_182FBE000, v65, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", (uint8_t *)&buf, 0x2Au);
          }

        }
        LODWORD(v10) = 0;
      }
    }

    *(_DWORD *)(v3 + 1668) = v10;
    v11 = *(_QWORD *)(v3 + 32);
    v12 = 0.0;
    v13 = 0.0;
    if (v11)
    {
      v14 = *(_QWORD *)(v3 + 8);
      if (v14)
        v13 = (float)v11 / (float)(unint64_t)(100 * v14);
    }
    v15 = *(_QWORD *)(v3 + 16);
    if (v15 && *(_QWORD *)v3)
      v12 = (float)v15 / (float)(unint64_t)(100 * *(_QWORD *)v3);
    v16 = v2[2];
    if (v16 && !nw_path_parameters_get_logging_disabled(v16[13]))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v17 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        top_id = v7->top_id;
        LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446978;
        *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
        WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
        *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = top_id;
        WORD1(buf.u.nw_connection_report.bytes_duplicate) = 2048;
        *(double *)((char *)&buf.u.nw_connection_report.bytes_duplicate + 4) = v13;
        WORD2(buf.u.nw_connection_report.bytes_ooo) = 2048;
        *(double *)((char *)&buf.u.nw_connection_report.bytes_ooo + 6) = v12;
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Retransmission rate: %.2f%%, duplicate rate: %.2f%%", (uint8_t *)&buf, 0x26u);
      }

    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {

    }
    else
    {
      v26 = gLogFDOverride == -1;

      if (v26)
      {
LABEL_97:
        *(_BYTE *)(v3 + 3417) = 1;
        if (!*(_DWORD *)(v3 + 204) || *((_DWORD *)v2 + 26) != 2 || *(_QWORD *)(v3 + 88) || *(_QWORD *)(v3 + 80))
        {
          nw_connection_send_report_to_symptoms(v7, (netcore_stats_tcp_report *)v3, 1);
          *((_BYTE *)v2 + 108) |= 2u;
          v51 = v2[2];
          if (v51)
          {
            if (!nw_path_parameters_get_logging_disabled(v51[13]))
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v52 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
              {
                v53 = v7->top_id;
                LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
                *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
                WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
                *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v53;
                _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Sent statistics report to symptoms", (uint8_t *)&buf, 0x12u);
              }

            }
          }
        }

        goto LABEL_109;
      }
    }
    v27 = netcore_stats_tcp_report_copy_description(v3);
    if (v27)
    {
      v28 = v27;
      v29 = v2[2];
      if (v29 && !nw_path_parameters_get_logging_disabled(v29[13]))
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v30 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v31 = v7->top_id;
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446722;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
          *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v31;
          WORD1(buf.u.nw_connection_report.bytes_duplicate) = 2082;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_duplicate + 4) = (unint64_t)v28;
          _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Generated report: %{public}s", (uint8_t *)&buf, 0x1Cu);
        }

      }
      goto LABEL_89;
    }
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
    *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats"
                                                                                                "_report_on_nw_queue";
    v28 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (__nwlog_fault(v28, type, &v66))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v34 = type[0];
        if (os_log_type_enabled(v33, type[0]))
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s netcore_stats_tcp_report_copy_description failed", (uint8_t *)&buf, 0xCu);
        }
LABEL_87:

        goto LABEL_88;
      }
      if (!v66)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v47 = type[0];
        if (os_log_type_enabled(v33, type[0]))
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v33, v47, "%{public}s netcore_stats_tcp_report_copy_description failed, backtrace limit exceeded", (uint8_t *)&buf, 0xCu);
        }
        goto LABEL_87;
      }
      v40 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v41 = type[0];
      v42 = os_log_type_enabled(v33, type[0]);
      if (!v40)
      {
        if (v42)
        {
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446210;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          _os_log_impl(&dword_182FBE000, v33, v41, "%{public}s netcore_stats_tcp_report_copy_description failed, no backtrace", (uint8_t *)&buf, 0xCu);
        }
        goto LABEL_87;
      }
      if (v42)
      {
        LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
        *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
        WORD2(buf.u.nw_connection_report.bytes_out) = 2082;
        *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = (unint64_t)v40;
        _os_log_impl(&dword_182FBE000, v33, v41, "%{public}s netcore_stats_tcp_report_copy_description failed, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x16u);
      }

      free(v40);
    }
LABEL_88:
    if (!v28)
    {
LABEL_90:
      v48 = v2[2];
      if (v48 && !nw_path_parameters_get_logging_disabled(v48[13]))
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v49 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          v50 = v7->top_id;
          LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
          *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_report_on_nw_queue";
          WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
          *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v50;
          _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] End of report", (uint8_t *)&buf, 0x12u);
        }

      }
      goto LABEL_97;
    }
LABEL_89:
    free(v28);
    goto LABEL_90;
  }
  if (!v4 || nw_path_parameters_get_logging_disabled(v4[13]))
    goto LABEL_123;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v20 = (id)gconnectionLogObj;
  v21 = *((_DWORD *)v2 + 112);
  LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
  *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats_r"
                                                                                              "eport_on_nw_queue";
  WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
  *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v21;
  v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v66 = 0;
  if (!__nwlog_fault(v22, type, &v66))
    goto LABEL_80;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v23 = (id)gconnectionLogObj;
    v24 = type[0];
    if (os_log_type_enabled(v23, type[0]))
    {
      v25 = *((_DWORD *)v2 + 112);
      LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
      *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_sta"
                                                                                                  "ts_report_on_nw_queue";
      WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
      *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v25;
      _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s [C%u] Unexpected NULL stats report", (uint8_t *)&buf, 0x12u);
    }
LABEL_79:

    goto LABEL_80;
  }
  if (!v66)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v23 = (id)gconnectionLogObj;
    v43 = type[0];
    if (os_log_type_enabled(v23, type[0]))
    {
      v44 = *((_DWORD *)v2 + 112);
      LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
      *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_sta"
                                                                                                  "ts_report_on_nw_queue";
      WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
      *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v44;
      _os_log_impl(&dword_182FBE000, v23, v43, "%{public}s [C%u] Unexpected NULL stats report, backtrace limit exceeded", (uint8_t *)&buf, 0x12u);
    }
    goto LABEL_79;
  }
  v35 = __nw_create_backtrace_string();
  if (!v35)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v23 = (id)gconnectionLogObj;
    v45 = type[0];
    if (os_log_type_enabled(v23, type[0]))
    {
      v46 = *((_DWORD *)v2 + 112);
      LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446466;
      *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_sta"
                                                                                                  "ts_report_on_nw_queue";
      WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
      *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v46;
      _os_log_impl(&dword_182FBE000, v23, v45, "%{public}s [C%u] Unexpected NULL stats report, no backtrace", (uint8_t *)&buf, 0x12u);
    }
    goto LABEL_79;
  }
  v36 = (char *)v35;
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v37 = (id)gconnectionLogObj;
  v38 = type[0];
  if (os_log_type_enabled(v37, type[0]))
  {
    v39 = *((_DWORD *)v2 + 112);
    LODWORD(buf.u.legacy.statistics_report.bytes_in) = 136446722;
    *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_in + 4) = (unint64_t)"nw_connection_send_stats"
                                                                                                "_report_on_nw_queue";
    WORD2(buf.u.nw_connection_report.bytes_out) = 1024;
    *(_DWORD *)((char *)&buf.u.nw_connection_report.bytes_out + 6) = v39;
    WORD1(buf.u.nw_connection_report.bytes_duplicate) = 2082;
    *(unint64_t *)((char *)&buf.u.nw_connection_report.bytes_duplicate + 4) = (unint64_t)v36;
    _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s [C%u] Unexpected NULL stats report, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x1Cu);
  }

  free(v36);
  if (v22)
    goto LABEL_81;
LABEL_123:

}

void sub_1831E9190(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_parameters_create_from_dictionary(void *a1)
{
  id v1;
  nw_parameters_t v2;
  Class Class;
  objc_class *v4;
  void *v5;
  xpc_object_t value;
  xpc_object_t v7;
  id v8;
  NWConcrete_nw_interface *v9;
  Class isa;
  void *v11;
  __int16 v12;
  const char *string;
  const char *v14;
  const char *v15;
  const char *v16;
  nw_endpoint_t url;
  Class v18;
  const char *v19;
  nw_endpoint_t v20;
  Class v21;
  _BOOL4 v22;
  uint64_t v23;
  Class v24;
  xpc_object_t v25;
  Class v26;
  const uint8_t *uuid;
  const uint8_t *v28;
  const uint8_t *v29;
  const uint8_t *v30;
  __int16 v31;
  __int16 v32;
  __int16 v33;
  xpc_object_t v34;
  xpc_object_t v35;
  xpc_object_t v36;
  xpc_object_t v37;
  xpc_object_t v38;
  xpc_object_t v39;
  Class v40;
  _BOOL4 v41;
  uint64_t v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  _BOOL4 v46;
  Class v47;
  char *v48;
  int v49;
  int v50;
  __int16 v51;
  unsigned int v52;
  _BOOL4 v53;
  Class v54;
  char *v55;
  int v56;
  int v57;
  __int16 v58;
  unsigned int v59;
  _BOOL4 v60;
  uint64_t v61;
  void *v62;
  BOOL v63;
  _BOOL4 v64;
  NSObject *v65;
  uint64_t v66;
  _BOOL4 v67;
  Class v68;
  char *v69;
  int v70;
  int v71;
  __int16 v72;
  unsigned int v73;
  _BOOL4 v74;
  Class v75;
  char *v76;
  int v77;
  int v78;
  __int16 v79;
  unsigned int v80;
  _BOOL4 v81;
  Class v82;
  char *v83;
  int v84;
  int v85;
  __int16 v86;
  unsigned int v87;
  _BOOL4 v88;
  uint64_t v89;
  _BOOL4 v90;
  uint64_t v91;
  _BOOL4 v92;
  uint64_t v93;
  _BOOL4 v94;
  uint64_t v95;
  const void *data;
  dispatch_data_t v97;
  Class v98;
  xpc_object_t v99;
  _BOOL4 v100;
  uint64_t v101;
  _BOOL4 v102;
  Class v103;
  char *v104;
  int v105;
  int v106;
  __int16 v107;
  unsigned int v108;
  _BOOL4 v109;
  uint64_t v110;
  _BOOL4 v111;
  uint64_t v112;
  _BOOL4 v113;
  uint64_t v114;
  _BOOL4 v115;
  uint64_t v116;
  _BOOL4 v117;
  uint64_t v118;
  _BOOL4 v119;
  uint64_t v120;
  _BOOL4 v121;
  uint64_t v122;
  _BOOL4 v123;
  uint64_t v124;
  _BOOL4 v125;
  uint64_t v126;
  _BOOL4 v127;
  uint64_t v128;
  _BOOL4 v129;
  Class v130;
  char *v131;
  int v132;
  int v133;
  __int16 v134;
  unsigned int v135;
  _BOOL4 v136;
  uint64_t v137;
  _BOOL4 v138;
  uint64_t v139;
  _BOOL4 v140;
  uint64_t v141;
  _BOOL4 v142;
  uint64_t v143;
  NSObject *v144;
  _BOOL8 result;
  xpc_object_t v146;
  void *v147;
  xpc_object_t v148;
  void *v149;
  NSObject *v150;
  Class v151;
  void *v152;
  void *v153;
  xpc_object_t v154;
  void *v155;
  id *v156;
  void *v157;
  xpc_object_t v158;
  void *v159;
  uint64_t v160;
  void *v161;
  xpc_object_t v162;
  void *v163;
  uint64_t v164;
  void *v165;
  xpc_object_t v166;
  void *v167;
  uint64_t v168;
  void *v169;
  xpc_object_t v170;
  void *v171;
  uint64_t v172;
  void *v173;
  xpc_object_t v174;
  void *v175;
  uint64_t v176;
  void *v177;
  xpc_object_t v178;
  void *v179;
  uint64_t v180;
  void *v181;
  xpc_object_t v182;
  void *v183;
  uint64_t v184;
  void *v185;
  xpc_object_t v186;
  void *v187;
  uint64_t v188;
  void *v189;
  xpc_object_t v190;
  void *v191;
  uint64_t v192;
  void *v193;
  xpc_object_t v194;
  void *v195;
  uint64_t v196;
  void *v197;
  xpc_object_t v198;
  void *v199;
  uint64_t v200;
  void *v201;
  xpc_object_t v202;
  void *v203;
  uint64_t v204;
  void *v205;
  xpc_object_t v206;
  void *v207;
  uint64_t v208;
  void *v209;
  xpc_object_t v210;
  uint64_t v211;
  void *v212;
  xpc_object_t v213;
  uint64_t v214;
  void *v215;
  void *v216;
  xpc_object_t v217;
  void *v218;
  char *v219;
  NSObject *v220;
  char *backtrace_string;
  _BOOL4 v222;
  NSObject *v223;
  void *v224;
  NSObject *v225;
  void *v226;
  NSObject *v227;
  void *v228;
  NSObject *v229;
  void *v230;
  NSObject *v231;
  void *v232;
  NSObject *v233;
  void *v234;
  NSObject *v235;
  void *v236;
  NSObject *v237;
  void *v238;
  NSObject *v239;
  void *v240;
  NSObject *v241;
  void *v242;
  NSObject *v243;
  void *v244;
  NSObject *v245;
  void *v246;
  NSObject *v247;
  void *v248;
  NSObject *v249;
  void *v250;
  NSObject *v251;
  void *v252;
  NSObject *v253;
  os_log_type_t v254;
  os_log_type_t type;
  NSObject *typea;
  os_log_type_t typeb;
  const char *v258;
  void *v259;
  id v260;
  id v261;
  id obj;
  id v263;
  id v264;
  id v265;
  id v266;
  id v267;
  id v268;
  id v269;
  id v270;
  id v271;
  xpc_object_t v272;
  char v273;
  os_log_type_t v274;
  _BYTE length[12];
  __int16 v276;
  uint64_t v277;
  __int16 v278;
  uint64_t v279;
  uint64_t v280;

  v280 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (!v1)
  {
    v2 = 0;
LABEL_160:
    v144 = v2;

    return (BOOL)v144;
  }
  v2 = nw_parameters_create();
  Class = object_getClass(v1);
  v4 = (objc_class *)MEMORY[0x1E0C812F8];
  if (Class == (Class)MEMORY[0x1E0C812F8] && (value = xpc_dictionary_get_value(v1, "required_interface")) != 0)
  {
    v7 = value;
    if (object_getClass(value) == v4)
      v5 = v7;
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
  }
  v8 = v5;
  v9 = nw_interface_create_from_dictionary(v8);
  isa = v2[13].isa;
  v11 = (void *)*((_QWORD *)isa + 21);
  *((_QWORD *)isa + 21) = v9;

  *((_DWORD *)v2[13].isa + 19) = xpc_dictionary_get_uint64(v1, "required_interface_type");
  if (xpc_dictionary_get_BOOL(v1, "only_primary_requires_type"))
    v12 = 32;
  else
    v12 = 0;
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFDF | v12;
  *((_DWORD *)v2[13].isa + 20) = xpc_dictionary_get_uint64(v1, "required_interface_subtype");
  *((_DWORD *)v2[13].isa + 23) = xpc_dictionary_get_uint64(v1, "next_hop_required_interface_type");
  *((_DWORD *)v2[13].isa + 24) = xpc_dictionary_get_uint64(v1, "next_hop_required_interface_subtype");
  string = xpc_dictionary_get_string(v1, "effective_bundle_id");
  if (string)
    nw_parameters_set_effective_bundle_id(v2, string);
  v14 = xpc_dictionary_get_string(v1, "account_id");
  if (v14)
    nw_parameters_set_account_id(v2, v14);
  v15 = xpc_dictionary_get_string(v1, "attribution_context");
  if (v15)
    nw_parameters_set_attribution_context(v2, v15);
  v16 = xpc_dictionary_get_string(v1, "url");
  if (v16)
  {
    url = nw_endpoint_create_url(v16);
    v18 = v2[25].isa;
    v2[25].isa = (Class)url;

  }
  v19 = xpc_dictionary_get_string(v1, "main_document_url");
  if (v19)
  {
    v20 = nw_endpoint_create_url(v19);
    v21 = v2[26].isa;
    v2[26].isa = (Class)v20;

  }
  if (object_getClass(v1) == v4
    && (v146 = xpc_dictionary_get_value(v1, "effective_audit_token")) != 0
    && (v147 = v146, object_getClass(v146) == (Class)MEMORY[0x1E0C812E8]))
  {
    v260 = v147;
    xpc_data_get_bytes(v260, &v2[5], 0, 0x20uLL);
  }
  else
  {
    v260 = 0;
  }
  if (object_getClass(v1) == v4
    && (v148 = xpc_dictionary_get_value(v1, "local_address")) != 0
    && (v149 = v148, object_getClass(v148) == v4))
  {
    v261 = v149;
    v150 = nw_endpoint_create_from_dictionary(v261);
    v151 = v2[13].isa;
    v152 = (void *)*((_QWORD *)v151 + 20);
    *((_QWORD *)v151 + 20) = v150;

  }
  else
  {
    v261 = 0;
  }
  v22 = xpc_dictionary_get_BOOL(v1, "reuse_local_address");
  v23 = 256;
  if (!v22)
    v23 = 0;
  v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFEFFLL | v23);
  v24 = object_getClass(v1);
  v25 = 0;
  if (v24 == v4)
  {
    v25 = xpc_dictionary_get_value(v1, "tls_session_id");
    if (v25)
    {
      v153 = v25;
      if (object_getClass(v25) == (Class)MEMORY[0x1E0C812E8])
        v25 = xpc_retain(v153);
      else
        v25 = 0;
    }
  }
  v26 = v2[16].isa;
  v2[16].isa = (Class)v25;

  *((_DWORD *)v2[13].isa + 18) = xpc_dictionary_get_uint64(v1, "traffic_class");
  *((_DWORD *)v2[13].isa + 16) = xpc_dictionary_get_int64(v1, "pid");
  *((_DWORD *)v2[13].isa + 17) = xpc_dictionary_get_int64(v1, "uid");
  uuid = xpc_dictionary_get_uuid(v1, "proc_uuid");
  if (uuid)
    *(_OWORD *)((char *)v2[13].isa + 8) = *(_OWORD *)uuid;
  v28 = xpc_dictionary_get_uuid(v1, "e_proc_uuid");
  if (v28)
    *(_OWORD *)((char *)v2[13].isa + 24) = *(_OWORD *)v28;
  v29 = xpc_dictionary_get_uuid(v1, "persona_id");
  if (v29)
    *(_OWORD *)((char *)v2[13].isa + 40) = *(_OWORD *)v29;
  v30 = xpc_dictionary_get_uuid(v1, "parent_id");
  if (v30)
    *(_OWORD *)&v2[1].isa = *(_OWORD *)v30;
  v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFFFELL | xpc_dictionary_get_BOOL(v1, "dry_run"));
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFFE | xpc_dictionary_get_BOOL(v1, "prohibit_expensive");
  if (xpc_dictionary_get_BOOL(v1, "prohibit_constrained"))
    v31 = 2;
  else
    v31 = 0;
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFFD | v31;
  if (xpc_dictionary_get_BOOL(v1, "allow_ultra_constrained"))
    v32 = 4;
  else
    v32 = 0;
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFFB | v32;
  if (xpc_dictionary_get_BOOL(v1, "prohibit_roaming"))
    v33 = 8;
  else
    v33 = 0;
  *((_WORD *)v2[13].isa + 50) = *((_WORD *)v2[13].isa + 50) & 0xFFF7 | v33;
  if (object_getClass(v1) == v4
    && (v154 = xpc_dictionary_get_value(v1, "prohibited_interface_types")) != 0
    && (v155 = v154, object_getClass(v154) == (Class)MEMORY[0x1E0C812C8])
    && (obj = xpc_retain(v155)) != 0)
  {
    v156 = (id *)*((_QWORD *)v2[13].isa + 22);
    if (!v156)
    {
      v157 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v157)
      {
        __nwlog_obj();
        v223 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v223, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v224 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v224);
        if (result)
          goto LABEL_341;
        free(v224);
      }
      *((_QWORD *)v2[13].isa + 22) = v157;
      v156 = (id *)*((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong(v156, obj);
  }
  else
  {
    obj = 0;
  }
  if (object_getClass(v1) == v4
    && (v158 = xpc_dictionary_get_value(v1, "prohibited_interface_subtypes")) != 0
    && (v159 = v158, object_getClass(v158) == (Class)MEMORY[0x1E0C812C8])
    && (v263 = xpc_retain(v159)) != 0)
  {
    v160 = *((_QWORD *)v2[13].isa + 22);
    if (!v160)
    {
      v161 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v161)
      {
        __nwlog_obj();
        v225 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v225, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v226 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v226);
        if (result)
          goto LABEL_341;
        free(v226);
      }
      *((_QWORD *)v2[13].isa + 22) = v161;
      v160 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v160 + 8), v263);
  }
  else
  {
    v263 = 0;
  }
  if (object_getClass(v1) == v4
    && (v162 = xpc_dictionary_get_value(v1, "preferred_interface_subtypes")) != 0
    && (v163 = v162, object_getClass(v162) == (Class)MEMORY[0x1E0C812C8])
    && (v264 = xpc_retain(v163)) != 0)
  {
    v164 = *((_QWORD *)v2[13].isa + 22);
    if (!v164)
    {
      v165 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v165)
      {
        __nwlog_obj();
        v227 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v227, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v228 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v228);
        if (result)
          goto LABEL_341;
        free(v228);
      }
      *((_QWORD *)v2[13].isa + 22) = v165;
      v164 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v164 + 16), v264);
  }
  else
  {
    v264 = 0;
  }
  if (object_getClass(v1) == v4
    && (v166 = xpc_dictionary_get_value(v1, "prohibited_interfaces")) != 0
    && (v167 = v166, object_getClass(v166) == (Class)MEMORY[0x1E0C812C8])
    && (v265 = xpc_retain(v167)) != 0)
  {
    v168 = *((_QWORD *)v2[13].isa + 22);
    if (!v168)
    {
      v169 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v169)
      {
        __nwlog_obj();
        v229 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v229, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v230 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v230);
        if (result)
          goto LABEL_341;
        free(v230);
      }
      *((_QWORD *)v2[13].isa + 22) = v169;
      v168 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v168 + 24), v265);
  }
  else
  {
    v265 = 0;
  }
  if (object_getClass(v1) == v4
    && (v170 = xpc_dictionary_get_value(v1, "prohibited_netagent_domains")) != 0
    && (v171 = v170, object_getClass(v170) == (Class)MEMORY[0x1E0C812C8])
    && (v266 = xpc_retain(v171)) != 0)
  {
    v172 = *((_QWORD *)v2[13].isa + 22);
    if (!v172)
    {
      v173 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v173)
      {
        __nwlog_obj();
        v231 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v231, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v232 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v232);
        if (result)
          goto LABEL_341;
        free(v232);
      }
      *((_QWORD *)v2[13].isa + 22) = v173;
      v172 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v172 + 32), v266);
  }
  else
  {
    v266 = 0;
  }
  if (object_getClass(v1) == v4
    && (v174 = xpc_dictionary_get_value(v1, "prohibited_netagent_types")) != 0
    && (v175 = v174, object_getClass(v174) == (Class)MEMORY[0x1E0C812C8])
    && (v267 = xpc_retain(v175)) != 0)
  {
    v176 = *((_QWORD *)v2[13].isa + 22);
    if (!v176)
    {
      v177 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v177)
      {
        __nwlog_obj();
        v233 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v233, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v234 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v234);
        if (result)
          goto LABEL_341;
        free(v234);
      }
      *((_QWORD *)v2[13].isa + 22) = v177;
      v176 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v176 + 40), v267);
  }
  else
  {
    v267 = 0;
  }
  if (object_getClass(v1) == v4
    && (v178 = xpc_dictionary_get_value(v1, "prohibited_netagent_uuids")) != 0
    && (v179 = v178, object_getClass(v178) == (Class)MEMORY[0x1E0C812C8])
    && (v268 = xpc_retain(v179)) != 0)
  {
    v180 = *((_QWORD *)v2[13].isa + 22);
    if (!v180)
    {
      v181 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v181)
      {
        __nwlog_obj();
        v235 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v235, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v236 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v236);
        if (result)
          goto LABEL_341;
        free(v236);
      }
      *((_QWORD *)v2[13].isa + 22) = v181;
      v180 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v180 + 48), v268);
  }
  else
  {
    v268 = 0;
  }
  if (object_getClass(v1) == v4
    && (v182 = xpc_dictionary_get_value(v1, "required_netagent_domains")) != 0
    && (v183 = v182, object_getClass(v182) == (Class)MEMORY[0x1E0C812C8])
    && (v269 = xpc_retain(v183)) != 0)
  {
    v184 = *((_QWORD *)v2[13].isa + 22);
    if (!v184)
    {
      v185 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v185)
      {
        __nwlog_obj();
        v237 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v237, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v238 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v238);
        if (result)
          goto LABEL_341;
        free(v238);
      }
      *((_QWORD *)v2[13].isa + 22) = v185;
      v184 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v184 + 56), v269);
  }
  else
  {
    v269 = 0;
  }
  if (object_getClass(v1) == v4
    && (v186 = xpc_dictionary_get_value(v1, "required_netagent_types")) != 0
    && (v187 = v186, object_getClass(v186) == (Class)MEMORY[0x1E0C812C8])
    && (v270 = xpc_retain(v187)) != 0)
  {
    v188 = *((_QWORD *)v2[13].isa + 22);
    if (!v188)
    {
      v189 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v189)
      {
        __nwlog_obj();
        v239 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v239, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v240 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v240);
        if (result)
          goto LABEL_341;
        free(v240);
      }
      *((_QWORD *)v2[13].isa + 22) = v189;
      v188 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v188 + 64), v270);
  }
  else
  {
    v270 = 0;
  }
  if (object_getClass(v1) == v4
    && (v190 = xpc_dictionary_get_value(v1, "required_netagent_uuids")) != 0
    && (v191 = v190, object_getClass(v190) == (Class)MEMORY[0x1E0C812C8])
    && (v271 = xpc_retain(v191)) != 0)
  {
    v192 = *((_QWORD *)v2[13].isa + 22);
    if (!v192)
    {
      v193 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v193)
      {
        __nwlog_obj();
        v241 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v241, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v242 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v242);
        if (result)
          goto LABEL_341;
        free(v242);
      }
      *((_QWORD *)v2[13].isa + 22) = v193;
      v192 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v192 + 72), v271);
  }
  else
  {
    v271 = 0;
  }
  if (object_getClass(v1) == v4
    && (v194 = xpc_dictionary_get_value(v1, "preferred_netagent_domains")) != 0
    && (v195 = v194, object_getClass(v194) == (Class)MEMORY[0x1E0C812C8])
    && (v272 = xpc_retain(v195)) != 0)
  {
    v196 = *((_QWORD *)v2[13].isa + 22);
    if (!v196)
    {
      v197 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
      if (!v197)
      {
        __nwlog_obj();
        v243 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v243, OS_LOG_TYPE_ERROR);
        *(_DWORD *)length = 136446722;
        *(_QWORD *)&length[4] = "strict_calloc";
        v276 = 2048;
        v277 = 1;
        v278 = 2048;
        v279 = 144;
        v244 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v244);
        if (result)
          goto LABEL_341;
        free(v244);
      }
      *((_QWORD *)v2[13].isa + 22) = v197;
      v196 = *((_QWORD *)v2[13].isa + 22);
    }
    objc_storeStrong((id *)(v196 + 80), v272);
  }
  else
  {
    v272 = 0;
  }
  if (object_getClass(v1) == v4
    && (v198 = xpc_dictionary_get_value(v1, "preferred_netagent_types")) != 0
    && (v199 = v198, object_getClass(v198) == (Class)MEMORY[0x1E0C812C8]))
  {
    v34 = xpc_retain(v199);
    if (v34)
    {
      v200 = *((_QWORD *)v2[13].isa + 22);
      if (!v200)
      {
        v201 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
        if (!v201)
        {
          __nwlog_obj();
          v245 = objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v245, OS_LOG_TYPE_ERROR);
          *(_DWORD *)length = 136446722;
          *(_QWORD *)&length[4] = "strict_calloc";
          v276 = 2048;
          v277 = 1;
          v278 = 2048;
          v279 = 144;
          v246 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v246);
          if (result)
            goto LABEL_341;
          free(v246);
        }
        *((_QWORD *)v2[13].isa + 22) = v201;
        v200 = *((_QWORD *)v2[13].isa + 22);
      }
      objc_storeStrong((id *)(v200 + 88), v34);
    }
  }
  else
  {
    v34 = 0;
  }
  if (object_getClass(v1) == v4
    && (v202 = xpc_dictionary_get_value(v1, "preferred_netagent_uuids")) != 0
    && (v203 = v202, object_getClass(v202) == (Class)MEMORY[0x1E0C812C8]))
  {
    v35 = xpc_retain(v203);
    if (v35)
    {
      v204 = *((_QWORD *)v2[13].isa + 22);
      if (!v204)
      {
        v205 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
        if (!v205)
        {
          __nwlog_obj();
          v247 = objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v247, OS_LOG_TYPE_ERROR);
          *(_DWORD *)length = 136446722;
          *(_QWORD *)&length[4] = "strict_calloc";
          v276 = 2048;
          v277 = 1;
          v278 = 2048;
          v279 = 144;
          v248 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v248);
          if (result)
            goto LABEL_341;
          free(v248);
        }
        *((_QWORD *)v2[13].isa + 22) = v205;
        v204 = *((_QWORD *)v2[13].isa + 22);
      }
      objc_storeStrong((id *)(v204 + 96), v35);
    }
  }
  else
  {
    v35 = 0;
  }
  if (object_getClass(v1) == v4
    && (v206 = xpc_dictionary_get_value(v1, "avoided_netagent_domains")) != 0
    && (v207 = v206, object_getClass(v206) == (Class)MEMORY[0x1E0C812C8]))
  {
    v36 = xpc_retain(v207);
    if (v36)
    {
      v208 = *((_QWORD *)v2[13].isa + 22);
      if (!v208)
      {
        v209 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
        if (!v209)
        {
          __nwlog_obj();
          v249 = objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v249, OS_LOG_TYPE_ERROR);
          *(_DWORD *)length = 136446722;
          *(_QWORD *)&length[4] = "strict_calloc";
          v276 = 2048;
          v277 = 1;
          v278 = 2048;
          v279 = 144;
          v250 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v250);
          if (result)
            goto LABEL_341;
          free(v250);
        }
        *((_QWORD *)v2[13].isa + 22) = v209;
        v208 = *((_QWORD *)v2[13].isa + 22);
      }
      objc_storeStrong((id *)(v208 + 104), v36);
    }
  }
  else
  {
    v36 = 0;
  }
  if (object_getClass(v1) == v4)
  {
    v210 = xpc_dictionary_get_value(v1, "avoided_netagent_types");
    v37 = v210;
    if (!v210)
      goto LABEL_76;
    if (object_getClass(v210) == (Class)MEMORY[0x1E0C812C8])
    {
      v37 = xpc_retain(v37);
      if (v37)
      {
        v211 = *((_QWORD *)v2[13].isa + 22);
        if (!v211)
        {
          v212 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
          if (!v212)
          {
            __nwlog_obj();
            v251 = objc_claimAutoreleasedReturnValue();
            os_log_type_enabled(v251, OS_LOG_TYPE_ERROR);
            *(_DWORD *)length = 136446722;
            *(_QWORD *)&length[4] = "strict_calloc";
            v276 = 2048;
            v277 = 1;
            v278 = 2048;
            v279 = 144;
            v252 = (void *)_os_log_send_and_compose_impl();

            result = __nwlog_abort((uint64_t)v252);
            if (result)
              goto LABEL_341;
            free(v252);
          }
          *((_QWORD *)v2[13].isa + 22) = v212;
          v211 = *((_QWORD *)v2[13].isa + 22);
        }
        objc_storeStrong((id *)(v211 + 112), v37);
      }
      goto LABEL_76;
    }
  }
  v37 = 0;
LABEL_76:
  if (object_getClass(v1) != v4)
  {
LABEL_77:
    v38 = 0;
    goto LABEL_78;
  }
  v213 = xpc_dictionary_get_value(v1, "avoided_netagent_uuids");
  v38 = v213;
  if (!v213)
    goto LABEL_78;
  if (object_getClass(v213) != (Class)MEMORY[0x1E0C812C8])
    goto LABEL_77;
  v38 = xpc_retain(v38);
  if (!v38)
  {
LABEL_78:
    if (object_getClass(v1) != v4)
    {
LABEL_79:
      v39 = 0;
      goto LABEL_80;
    }
    v39 = xpc_dictionary_get_value(v1, "extra_parent_ids");
    if (v39)
    {
      v216 = v39;
      if (object_getClass(v39) != (Class)MEMORY[0x1E0C812C8])
        goto LABEL_79;
      v39 = xpc_retain(v216);
    }
LABEL_80:
    v40 = v2[17].isa;
    v2[17].isa = (Class)v39;

    v41 = xpc_dictionary_get_BOOL(v1, "trust_invalid_certs");
    v42 = 0x200000000000;
    if (!v41)
      v42 = 0;
    v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFDFFFFFFFFFFFLL | v42);
    v43 = xpc_dictionary_get_BOOL(v1, "should_skip_probe_sampling");
    v44 = 0x400000000000;
    if (!v43)
      v44 = 0;
    v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFBFFFFFFFFFFFLL | v44);
    if (xpc_dictionary_get_BOOL(v1, "use_long_outstanding_queries"))
      v45 = 8;
    else
      v45 = 0;
    v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFFF7 | v45);
    v46 = xpc_dictionary_get_BOOL(v1, "use_awdl");
    v47 = v2[13].isa;
    v49 = *((unsigned __int16 *)v47 + 54);
    v48 = (char *)v47 + 108;
    v50 = v49 | (v48[2] << 16);
    if (v46)
      v51 = 8;
    else
      v51 = 0;
    v52 = v50 & 0xFFFFFFF7;
    *(_WORD *)v48 = v52 | v51;
    v48[2] = BYTE2(v52);
    v53 = xpc_dictionary_get_BOOL(v1, "use_p2p");
    v54 = v2[13].isa;
    v56 = *((unsigned __int16 *)v54 + 54);
    v55 = (char *)v54 + 108;
    v57 = v56 | (v55[2] << 16);
    if (v53)
      v58 = 16;
    else
      v58 = 0;
    v59 = v57 & 0xFFFFFFEF;
    *(_WORD *)v55 = v59 | v58;
    v55[2] = BYTE2(v59);
    v60 = xpc_dictionary_get_BOOL(v1, "resolve_ptr");
    v61 = 32;
    if (!v60)
      v61 = 0;
    v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFFDFLL | v61);
    xpc_dictionary_get_value(v1, "indefinite");
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    v63 = v62 == 0;

    if (v63)
    {
LABEL_101:
      v67 = xpc_dictionary_get_BOOL(v1, "no_fallback");
      v68 = v2[13].isa;
      v70 = *((unsigned __int16 *)v68 + 54);
      v69 = (char *)v68 + 108;
      v71 = v70 | (v69[2] << 16);
      if (v67)
        v72 = 32;
      else
        v72 = 0;
      v73 = v71 & 0xFFFFFFDF;
      *(_WORD *)v69 = v73 | v72;
      v69[2] = BYTE2(v73);
      v74 = xpc_dictionary_get_BOOL(v1, "no_proxy");
      v75 = v2[13].isa;
      v77 = *((unsigned __int16 *)v75 + 54);
      v76 = (char *)v75 + 108;
      v78 = v77 | (v76[2] << 16);
      if (v74)
        v79 = 2;
      else
        v79 = 0;
      v80 = v78 & 0xFFFFFFFD;
      *(_WORD *)v76 = v80 | v79;
      v76[2] = BYTE2(v80);
      v81 = xpc_dictionary_get_BOOL(v1, "no_transform");
      v82 = v2[13].isa;
      v84 = *((unsigned __int16 *)v82 + 54);
      v83 = (char *)v82 + 108;
      v85 = v84 | (v83[2] << 16);
      if (v81)
        v86 = 4;
      else
        v86 = 0;
      v87 = v85 & 0xFFFFFFFB;
      *(_WORD *)v83 = v87 | v86;
      v83[2] = BYTE2(v87);
      v88 = xpc_dictionary_get_BOOL(v1, "server");
      v89 = 0x8000;
      if (!v88)
        v89 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFF7FFFLL | v89);
      *(_DWORD *)((char *)v2[13].isa + 103) = xpc_dictionary_get_uint64(v1, "multipath_service");
      BYTE4(v2[11].isa) = xpc_dictionary_get_uint64(v1, "data_mode");
      LODWORD(v2[11].isa) = xpc_dictionary_get_uint64(v1, "sleep_keepalive_interval");
      v90 = xpc_dictionary_get_BOOL(v1, "custom_protocols_only");
      v91 = 2048;
      if (!v90)
        v91 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFF7FFLL | v91);
      *((_WORD *)v2[13].isa + 54) = *((_WORD *)v2[13].isa + 54) & 0xFFFE | xpc_dictionary_get_BOOL(v1, "discretionary");
      v92 = xpc_dictionary_get_BOOL(v1, "local_only");
      v93 = 0x4000;
      if (!v92)
        v93 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFBFFFLL | v93);
      v94 = xpc_dictionary_get_BOOL(v1, "receive_any_interface");
      v95 = 512;
      if (!v94)
        v95 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFDFFLL | v95);
      BYTE5(v2[11].isa) = xpc_dictionary_get_uint64(v1, "ecn_mode");
      *((_DWORD *)v2[13].isa + 21) = xpc_dictionary_get_uint64(v1, "companion_preference");
      *(_QWORD *)length = 0;
      data = xpc_dictionary_get_data(v1, "initial_data_payload", (size_t *)length);
      if (*(_QWORD *)length && data)
      {
        v97 = dispatch_data_create(data, *(size_t *)length, 0, 0);
        v98 = v2[18].isa;
        v2[18].isa = (Class)v97;

      }
      if (object_getClass(v1) == v4)
      {
        v217 = xpc_dictionary_get_value(v1, "metadata");
        v99 = v217;
        if (!v217)
          goto LABEL_123;
        if (object_getClass(v217) == (Class)MEMORY[0x1E0C812E8])
        {
          v99 = xpc_retain(v99);
          if (v99)
            objc_storeStrong((id *)&v2[27].isa, v99);
          goto LABEL_123;
        }
      }
      v99 = 0;
LABEL_123:
      v100 = xpc_dictionary_get_BOOL(v1, "allow_unusable_addresses");
      v101 = 0x80000;
      if (!v100)
        v101 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFF7FFFFLL | v101);
      v102 = xpc_dictionary_get_BOOL(v1, "prefer_no_proxy");
      v103 = v2[13].isa;
      v105 = *((unsigned __int16 *)v103 + 54);
      v104 = (char *)v103 + 108;
      v106 = v105 | (v104[2] << 16);
      if (v102)
        v107 = 256;
      else
        v107 = 0;
      v108 = v106 & 0xFFFFFEFF;
      *(_WORD *)v104 = v108 | v107;
      v104[2] = BYTE2(v108);
      v109 = xpc_dictionary_get_BOOL(v1, "https_proxy_is_opaque");
      v110 = 0x100000;
      if (!v109)
        v110 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFEFFFFFLL | v110);
      v111 = xpc_dictionary_get_BOOL(v1, "https_proxy_over_tls");
      v112 = 0x200000;
      if (!v111)
        v112 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFDFFFFFLL | v112);
      v113 = xpc_dictionary_get_BOOL(v1, "attach_protocol_listener");
      v114 = 0x400000;
      if (!v113)
        v114 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFFBFFFFFLL | v114);
      v115 = xpc_dictionary_get_BOOL(v1, "prohibit_joining_protocols");
      v116 = 0x800000;
      if (!v115)
        v116 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFF7FFFFFLL | v116);
      v117 = xpc_dictionary_get_BOOL(v1, "allow_joining_connected_fd");
      v118 = 0x1000000;
      if (!v117)
        v118 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFEFFFFFFLL | v118);
      v119 = xpc_dictionary_get_BOOL(v1, "allow_duplicate_state_updates");
      v120 = 0x4000000;
      if (!v119)
        v120 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFFBFFFFFFLL | v120);
      v121 = xpc_dictionary_get_BOOL(v1, "always_open_listener_socket");
      v122 = 0x8000000;
      if (!v121)
        v122 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFF7FFFFFFLL | v122);
      v123 = xpc_dictionary_get_BOOL(v1, "never_open_listener_socket");
      v124 = 0x10000000;
      if (!v123)
        v124 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFEFFFFFFFLL | v124);
      v125 = xpc_dictionary_get_BOOL(v1, "disable_listener_datapath");
      v126 = 0x20000000;
      if (!v125)
        v126 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFDFFFFFFFLL | v126);
      v127 = xpc_dictionary_get_BOOL(v1, "requires_dnssec_validation");
      v128 = 0x40000000;
      if (!v127)
        v128 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFFFBFFFFFFFLL | v128);
      v129 = xpc_dictionary_get_BOOL(v1, "known_tracker");
      v130 = v2[13].isa;
      v132 = *((unsigned __int16 *)v130 + 54);
      v131 = (char *)v130 + 108;
      v133 = v132 | (v131[2] << 16);
      if (v129)
        v134 = 0x4000;
      else
        v134 = 0;
      v135 = v133 & 0xFFFFBFFF;
      *(_WORD *)v131 = v135 | v134;
      v131[2] = BYTE2(v135);
      *((_BYTE *)v2[13].isa + 102) = xpc_dictionary_get_uint64(v1, "attribution");
      v136 = xpc_dictionary_get_BOOL(v1, "include_ble");
      v137 = 0x800000000;
      if (!v136)
        v137 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFF7FFFFFFFFLL | v137);
      v138 = xpc_dictionary_get_BOOL(v1, "screen_off");
      v139 = 0x1000000000;
      if (!v138)
        v139 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFEFFFFFFFFFLL | v139);
      v140 = xpc_dictionary_get_BOOL(v1, "internet_fallback");
      v141 = 0x2000000000;
      if (!v140)
        v141 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFDFFFFFFFFFLL | v141);
      v142 = xpc_dictionary_get_BOOL(v1, "minimize_logging");
      v143 = 0x4000000000;
      if (!v142)
        v143 = 0;
      v2[12].isa = (Class)((unint64_t)v2[12].isa & 0xFFFFFFBFFFFFFFFFLL | v143);

      goto LABEL_160;
    }
    v64 = xpc_dictionary_get_BOOL(v1, "indefinite");
    v65 = v2;
    if (v65)
    {
      v66 = 128;
      if (v64)
        v66 = 192;
      v2[12].isa = (Class)(v66 | (unint64_t)v2[12].isa & 0xFFFFFFFFFFFFFF3FLL);
LABEL_100:

      goto LABEL_101;
    }
    __nwlog_obj();
    v218 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(_QWORD *)&length[4] = "nw_parameters_set_indefinite";
    v258 = (const char *)_os_log_send_and_compose_impl();

    v274 = OS_LOG_TYPE_ERROR;
    v273 = 0;
    v219 = (char *)v258;
    if (!__nwlog_fault(v258, &v274, &v273))
    {
LABEL_307:
      if (v219)
        free(v219);
      goto LABEL_100;
    }
    if (v274 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v220 = objc_claimAutoreleasedReturnValue();
      type = v274;
      if (os_log_type_enabled(v220, v274))
      {
        *(_DWORD *)length = 136446210;
        *(_QWORD *)&length[4] = "nw_parameters_set_indefinite";
        _os_log_impl(&dword_182FBE000, v220, type, "%{public}s called with null parameters", length, 0xCu);
      }
    }
    else
    {
      if (v273)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        typea = objc_claimAutoreleasedReturnValue();
        v254 = v274;
        v222 = os_log_type_enabled(typea, v274);
        if (backtrace_string)
        {
          if (v222)
          {
            *(_DWORD *)length = 136446466;
            *(_QWORD *)&length[4] = "nw_parameters_set_indefinite";
            v276 = 2082;
            v277 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, typea, v254, "%{public}s called with null parameters, dumping backtrace:%{public}s", length, 0x16u);
          }

          free(backtrace_string);
        }
        else
        {
          if (v222)
          {
            *(_DWORD *)length = 136446210;
            *(_QWORD *)&length[4] = "nw_parameters_set_indefinite";
            _os_log_impl(&dword_182FBE000, typea, v254, "%{public}s called with null parameters, no backtrace", length, 0xCu);
          }

        }
        goto LABEL_306;
      }
      __nwlog_obj();
      v220 = objc_claimAutoreleasedReturnValue();
      typeb = v274;
      if (os_log_type_enabled(v220, v274))
      {
        *(_DWORD *)length = 136446210;
        *(_QWORD *)&length[4] = "nw_parameters_set_indefinite";
        _os_log_impl(&dword_182FBE000, v220, typeb, "%{public}s called with null parameters, backtrace limit exceeded", length, 0xCu);
      }
    }

LABEL_306:
    v219 = (char *)v258;
    goto LABEL_307;
  }
  v214 = *((_QWORD *)v2[13].isa + 22);
  if (v214)
  {
LABEL_281:
    objc_storeStrong((id *)(v214 + 120), v38);
    goto LABEL_78;
  }
  v215 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
  if (v215)
  {
LABEL_280:
    *((_QWORD *)v2[13].isa + 22) = v215;
    v214 = *((_QWORD *)v2[13].isa + 22);
    goto LABEL_281;
  }
  __nwlog_obj();
  v253 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v253, OS_LOG_TYPE_ERROR);
  *(_DWORD *)length = 136446722;
  *(_QWORD *)&length[4] = "strict_calloc";
  v276 = 2048;
  v277 = 1;
  v278 = 2048;
  v279 = 144;
  v259 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v259);
  if (!result)
  {
    free(v259);
    goto LABEL_280;
  }
LABEL_341:
  __break(1u);
  return result;
}

void sub_1831EB5B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28)
{
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;

  _Unwind_Resume(a1);
}

void nw_parameters_set_source_application_by_bundle_id_internal(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  void *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_parameters_set_effective_bundle_id(v3, a2);
    v5 = (void *)NEHelperCacheCopyAppUUIDMappingExtended();
    v6 = v5;
    if (v5 && object_getClass(v5) == (Class)MEMORY[0x1E0C812C8] && xpc_array_get_count(v6))
    {
      v4[12] &= ~0x1000uLL;
      *(_OWORD *)(v4[13] + 24) = *(_OWORD *)xpc_array_get_uuid(v6, 0);
    }
    else
    {
      v4[12] |= 0x1000uLL;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        v20 = 2082;
        v21 = (void *)a2;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s Failed to convert from bundle ID (%{public}s) to UUID. This could lead to incorrect policies and accounting.", buf, 0x16u);
      }

    }
    goto LABEL_8;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_parameters_set_source_application_by_bundle_id_internal";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_27:
  if (v9)
    free(v9);
LABEL_8:

}

void sub_1831EBAC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_parameters_set_effective_bundle_id(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  NSObject *v14;
  void *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_parameters_set_effective_bundle_id";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_set_effective_bundle_id";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_parameters_set_effective_bundle_id";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_set_effective_bundle_id";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_set_effective_bundle_id";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v8)
      free(v8);
    goto LABEL_8;
  }
  v5 = (void *)v3[14];
  if (v5)
  {
    free(v5);
    v4[14] = 0;
  }
  if (!a2 || strlen(a2) - 1 > 0x3FE)
    goto LABEL_8;
  v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    v4[14] = v6;
LABEL_8:

    return;
  }
  __nwlog_obj();
  v14 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }
  __break(1u);
}

uint64_t __nw_channel_purge_idle_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int16 *v3;
  int v4;
  NSObject *v7;
  unsigned int v8;
  uint64_t v10;
  int v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = (unsigned __int16 *)(a3 + 444);
  v4 = *(unsigned __int16 *)(a3 + 444) | (*(unsigned __int8 *)(a3 + 446) << 16);
  if ((v4 & 0x60000) == 0 && *(_QWORD *)(a3 + 136))
  {
    *v3 = *(_WORD *)(a3 + 444);
    *(_BYTE *)(a3 + 446) = BYTE2(v4) | 4;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      v11 = 136446210;
      v12 = "nw_channel_purge_idle_block_invoke";
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s Purging channel packet pool after going idle", (uint8_t *)&v11, 0xCu);
    }
    if (os_channel_packet_pool_purge())
    {
      v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (!v10)
      {
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = nw_array_create();
        v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      }
      nw_array_append(v10, (void *)a3);
    }
  }
  v8 = (*v3 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0xFFFDFFFF;
  *v3 = *v3;
  *((_BYTE *)v3 + 2) = BYTE2(v8);
  return 1;
}

void nw_quic_save_0rtt_state_on_queue(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  uint64_t cached_content_for_protocol;
  int64_t int64_with_default;
  time_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  NSObject *v26;
  void *v27;
  void *v28;
  os_log_type_t v29;
  os_log_type_t v30;
  os_log_type_t v31;
  char *v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (!v5)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_quic_save_0rtt_state_on_queue";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v13, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_quic_save_0rtt_state_on_queue";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        v22 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_quic_save_0rtt_state_on_queue";
            v40 = 2082;
            v41 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_51;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_quic_save_0rtt_state_on_queue";
          _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_quic_save_0rtt_state_on_queue";
          _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_51:
    if (v13)
      free(v13);
    goto LABEL_9;
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  v8 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (!v8)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_quic_save_0rtt_state_on_queue";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v17, &type, &v36))
      goto LABEL_62;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v36)
    {
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v18, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "nw_quic_save_0rtt_state_on_queue";
          v40 = 2082;
          v41 = (uint64_t)v23;
          _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
LABEL_62:
        if (!v17)
          goto LABEL_8;
LABEL_63:
        free(v17);
        goto LABEL_8;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_61:

    goto LABEL_62;
  }
  cached_content_for_protocol = nw_association_get_cached_content_for_protocol(v5, v8);
  if (cached_content_for_protocol
    || (cached_content_for_protocol = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL)) != 0)
  {
    objc_storeStrong((id *)(cached_content_for_protocol + 8), a2);
    objc_storeStrong((id *)(cached_content_for_protocol + 16), a3);
    int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_quic_failure_cache_seconds, 1800);
    v11 = time(0);
    nw_association_set_cached_content_for_protocol(v5, v8, cached_content_for_protocol, v11 + int64_with_default);
LABEL_8:

LABEL_9:
    return;
  }
  __nwlog_obj();
  v26 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v39 = "strict_calloc";
  v40 = 2048;
  v41 = 1;
  v42 = 2048;
  v43 = 48;
  v27 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v27))
  {
    free(v27);
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_quic_save_0rtt_state_on_queue";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v17, &type, &v36))
      goto LABEL_62;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s called with null association_cache", buf, 0xCu);
      }
    }
    else if (v36)
    {
      v32 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      v34 = os_log_type_enabled(v18, type);
      if (v32)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "nw_quic_save_0rtt_state_on_queue";
          v40 = 2082;
          v41 = (uint64_t)v32;
          _os_log_impl(&dword_182FBE000, v18, v33, "%{public}s called with null association_cache, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v32);
        if (!v17)
          goto LABEL_8;
        goto LABEL_63;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v18, v33, "%{public}s called with null association_cache, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v39 = "nw_quic_save_0rtt_state_on_queue";
        _os_log_impl(&dword_182FBE000, v18, v35, "%{public}s called with null association_cache, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_61;
  }
  __break(1u);
}

void sub_1831EC7CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t nw_path_get_reason(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[95];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_get_reason";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_get_reason";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_get_reason";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_get_reason";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_get_reason";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

double __nw_protocol_udp_identifier_block_invoke()
{
  double result;

  unk_1ECD847CC = 0;
  unk_1ECD847C4 = 0;
  dword_1ECD847DC = 0;
  unk_1ECD847D4 = 0;
  nw_protocol_udp_identifier::identifier = 7365749;
  *(_QWORD *)&result = 0x100000003;
  qword_1ECD847E0 = 0x100000003;
  return result;
}

double __nw_protocol_http_connect_identifier_block_invoke()
{
  double result;

  unk_1ECD84B8D = 0;
  unk_1ECD84B85 = 0;
  dword_1ECD84B94 = 0;
  strcpy((char *)&g_http_connect_protocol_identifier, "http_connect");
  *(_QWORD *)&result = 0x100000004;
  qword_1ECD84B98 = 0x100000004;
  qword_1ECD84B20 = (uint64_t)nw_protocol_default_output_finished;
  unk_1ECD84B28 = nw_protocol_default_get_output_local;
  qword_1ECD84A70 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1ECD84A78 = nw_protocol_default_connect;
  qword_1ECD84B60 = (uint64_t)nw_protocol_default_reset;
  unk_1ECD84B68 = nw_protocol_default_input_flush;
  qword_1ECD84B30 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1ECD84B38 = nw_protocol_default_waiting_for_output;
  qword_1ECD84AF0 = (uint64_t)nw_protocol_default_register_notification;
  unk_1ECD84AF8 = nw_protocol_default_unregister_notification;
  qword_1ECD84B00 = (uint64_t)nw_protocol_default_notify;
  unk_1ECD84B08 = nw_protocol_default_updated_path;
  qword_1ECD84B50 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_1ECD84B58 = nw_protocol_default_get_message_properties;
  g_http_connect_protocol_callbacks = (uint64_t)nw_protocol_http_connect_add_input_handler;
  *(_QWORD *)algn_1ECD84A68 = nw_protocol_http_connect_remove_input_handler;
  qword_1ECD84AA0 = (uint64_t)nw_protocol_http_connect_input_available;
  unk_1ECD84AA8 = nw_protocol_default_output_available;
  qword_1ECD84B10 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1ECD84B18 = nw_protocol_http_connect_input_finished;
  qword_1ECD84AB0 = (uint64_t)nw_protocol_http_connect_get_input_frames;
  unk_1ECD84AB8 = nw_protocol_http_connect_get_output_frames;
  qword_1ECD84AC0 = (uint64_t)nw_protocol_http_connect_finalize_output_frames;
  unk_1ECD84AC8 = nw_protocol_default_link_state;
  qword_1ECD84A80 = (uint64_t)nw_protocol_default_disconnect;
  unk_1ECD84A88 = nw_protocol_http_connect_connected;
  qword_1ECD84A90 = (uint64_t)nw_protocol_http_connect_disconnected;
  unk_1ECD84A98 = nw_protocol_http_connect_error;
  qword_1ECD84B40 = (uint64_t)nw_protocol_http_connect_copy_info;
  unk_1ECD84B48 = nw_protocol_default_add_listen_handler;
  qword_1ECD84AD0 = (uint64_t)nw_protocol_http_connect_get_parameters;
  unk_1ECD84AD8 = nw_protocol_http_connect_get_path;
  qword_1ECD84AE0 = (uint64_t)nw_protocol_http_connect_get_local_endpoint;
  unk_1ECD84AE8 = nw_protocol_http_connect_get_remote_endpoint;
  return result;
}

void networkd_settings_update_from_token(int a1)
{
  uint32_t state;
  uint32_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  uint64_t v9;
  char *backtrace_string;
  uint64_t v11;
  _BOOL4 v12;
  void *v13;
  uint64_t v14;
  xpc_object_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  BOOL v20;
  BOOL v21;
  uint64_t v22;
  char v23;
  os_log_type_t type;
  _QWORD v25[5];
  BOOL v26;
  _QWORD v27[5];
  BOOL v28;
  uint64_t state64;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  uint32_t v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  state64 = 0;
  state = notify_get_state(a1, &state64);
  if (state)
  {
    v2 = state;
    v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v3);
    *(_DWORD *)buf = 136446466;
    v31 = "networkd_settings_update_from_token";
    v32 = 1024;
    v33 = v2;
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v4, &type, &v23))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v5);
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_23;
      *(_DWORD *)buf = 136446466;
      v31 = "networkd_settings_update_from_token";
      v32 = 1024;
      v33 = v2;
      v8 = "%{public}s notify_get_state(settings) failed: %u";
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v11);
      v6 = gLogObj;
      v7 = type;
      v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          v31 = "networkd_settings_update_from_token";
          v32 = 1024;
          v33 = v2;
          v34 = 2082;
          v35 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s notify_get_state(settings) failed: %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_23;
      }
      if (!v12)
      {
LABEL_23:
        if (v4)
          free(v4);
        return;
      }
      *(_DWORD *)buf = 136446466;
      v31 = "networkd_settings_update_from_token";
      v32 = 1024;
      v33 = v2;
      v8 = "%{public}s notify_get_state(settings) failed: %u, no backtrace";
    }
    else
    {
      v14 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v14);
      v6 = gLogObj;
      v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_23;
      *(_DWORD *)buf = 136446466;
      v31 = "networkd_settings_update_from_token";
      v32 = 1024;
      v33 = v2;
      v8 = "%{public}s notify_get_state(settings) failed: %u, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0x12u);
    goto LABEL_23;
  }
  pthread_mutex_lock(&sSettingsMutex);
  v9 = state64;
  if (state64 == sCachedHash)
  {
    if (state64)
    {
      pthread_mutex_unlock(&sSettingsMutex);
      sCachedHash = state64;
      return;
    }
    goto LABEL_19;
  }
  if ((state64 & 0xFFFFFFFFFFFE0000) == (sCachedHash & 0xFFFFFFFFFFFE0000))
  {
    v13 = (void *)sCachedSettings;
LABEL_28:
    v15 = nw_settings_add_settings_from_bitmask(v13, v9);
    sCachedSettings = (uint64_t)v15;
    goto LABEL_29;
  }
  if ((state64 & 0xFFFFFFFFFFFE0000) == 0)
  {
    if (sCachedSettings)
    {
      xpc_release((xpc_object_t)sCachedSettings);
      sCachedSettings = 0;
      v9 = state64;
    }
    v13 = 0;
    goto LABEL_28;
  }
LABEL_19:
  networkd_settings_read_from_file();
  v15 = (xpc_object_t)sCachedSettings;
LABEL_29:
  v16 = sBoringSSLUpdateBlock;
  v17 = MEMORY[0x1E0C809B0];
  if (sBoringSSLUpdateBlock)
  {
    if (v15)
    {
      v18 = xpc_dictionary_get_BOOL(v15, (const char *)nw_setting_boringssl_log_debug);
      v16 = sBoringSSLUpdateBlock;
    }
    else
    {
      v18 = 0;
    }
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    v27[0] = v17;
    v27[1] = 0x40000000;
    v27[2] = ___ZL35networkd_settings_update_from_tokeni_block_invoke;
    v27[3] = &unk_1E14AD100;
    v27[4] = v16;
    v28 = v18;
    nw_queue_context_async((id)nw_context_copy_implicit_context::implicit_context, v27);
    v15 = (xpc_object_t)sCachedSettings;
  }
  v19 = sQUICUpdateBlock;
  if (sQUICUpdateBlock)
  {
    if (v15)
    {
      v20 = xpc_dictionary_get_BOOL(v15, (const char *)nw_setting_libnetcore_datapath_debug);
      v19 = sQUICUpdateBlock;
    }
    else
    {
      v20 = 0;
    }
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    v25[0] = v17;
    v25[1] = 0x40000000;
    v25[2] = ___ZL35networkd_settings_update_from_tokeni_block_invoke_2;
    v25[3] = &unk_1E14AD128;
    v25[4] = v19;
    v26 = v20;
    nw_queue_context_async((id)nw_context_copy_implicit_context::implicit_context, v25);
    v15 = (xpc_object_t)sCachedSettings;
  }
  if (v15)
    v21 = xpc_dictionary_get_BOOL(v15, (const char *)nw_setting_libnetcore_datapath_debug);
  else
    v21 = 0;
  pthread_mutex_unlock(&sSettingsMutex);
  sCachedHash = state64;
  v22 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v22);
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  if (v21 || !gLogDatapathOverridden)
    gLogDatapath = v21;
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
}

void networkd_settings_read_from_file(void)
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  off_t st_size;
  void *v13;
  uint64_t v14;
  void *v15;
  ssize_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  char *backtrace_string;
  uint64_t v21;
  _BOOL4 v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  _BOOL4 v32;
  ssize_t v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  os_log_type_t v50;
  char *v51;
  uint64_t v52;
  _BOOL4 v53;
  char *v54;
  uint64_t v55;
  _BOOL4 v56;
  NSObject *v57;
  os_log_type_t v58;
  uint32_t v59;
  xpc_object_t dictionary;
  NSObject *v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  NSObject *v67;
  os_log_type_t v68;
  const char *v69;
  char *v70;
  uint64_t v71;
  _BOOL4 v72;
  char v73;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v76;
  __int16 v77;
  _BYTE v78[18];
  stat v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  if (sCachedSettings)
  {
    xpc_release((xpc_object_t)sCachedSettings);
    sCachedSettings = 0;
  }
  v0 = open((const char *)nw_file_path_settings, 0);
  if (v0 != -1)
  {
    v1 = v0;
    memset(&v79, 0, sizeof(v79));
    if (fstat(v0, &v79))
    {
      v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v3);
      *(_DWORD *)buf = 136446466;
      v76 = "networkd_settings_read_from_file";
      v77 = 1024;
      *(_DWORD *)v78 = v2;
      v4 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v73 = 0;
      if (__nwlog_fault(v4, &type, &v73))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v5);
          v6 = gLogObj;
          v7 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446466;
            v76 = "networkd_settings_read_from_file";
            v77 = 1024;
            *(_DWORD *)v78 = v2;
            v8 = "%{public}s networkd settings fstat failed %{darwin.errno}d";
LABEL_40:
            _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0x12u);
          }
        }
        else if (v73)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v21 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v21);
          v6 = gLogObj;
          v7 = type;
          v22 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v22)
            {
              *(_DWORD *)buf = 136446722;
              v76 = "networkd_settings_read_from_file";
              v77 = 1024;
              *(_DWORD *)v78 = v2;
              *(_WORD *)&v78[4] = 2082;
              *(_QWORD *)&v78[6] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s networkd settings fstat failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(backtrace_string);
            goto LABEL_41;
          }
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            v76 = "networkd_settings_read_from_file";
            v77 = 1024;
            *(_DWORD *)v78 = v2;
            v8 = "%{public}s networkd settings fstat failed %{darwin.errno}d, no backtrace";
            goto LABEL_40;
          }
        }
        else
        {
          v29 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v29);
          v6 = gLogObj;
          v7 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446466;
            v76 = "networkd_settings_read_from_file";
            v77 = 1024;
            *(_DWORD *)v78 = v2;
            v8 = "%{public}s networkd settings fstat failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_40;
          }
        }
      }
LABEL_41:
      if (v4)
        free(v4);
      st_size = 0;
      goto LABEL_44;
    }
    st_size = v79.st_size;
    if ((unint64_t)(v79.st_size - 1) > 0xFFFE)
    {
LABEL_44:
      v36 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v36);
      v37 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v76 = "networkd_settings_read_from_file";
        v77 = 2048;
        *(_QWORD *)v78 = st_size;
        _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_ERROR, "%{public}s networkd settings file length %lld is invalid", buf, 0x16u);
      }
      goto LABEL_86;
    }
    v13 = malloc_type_malloc(v79.st_size, 0xF2B69DE5uLL);
    if (v13)
    {
      v15 = v13;
      v16 = pread(v1, v13, st_size, 0);
      if (v16 == st_size)
      {
        v17 = xpc_create_from_plist();
        sCachedSettings = v17;
        v18 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v18);
        v19 = gLogObj;
        if (v17)
        {
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            v76 = "networkd_settings_read_from_file";
            _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEFAULT, "%{public}s initialized networkd settings by reading plist directly", buf, 0xCu);
          }
          goto LABEL_85;
        }
        *(_DWORD *)buf = 136446210;
        v76 = "networkd_settings_read_from_file";
        v39 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v73 = 0;
        v40 = __nwlog_fault(v39, &type, &v73);
        if ((_DWORD)v40)
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v42 = __nwlog_obj(v40, v41);
            v43 = type;
            if (!os_log_type_enabled(v42, type))
              goto LABEL_83;
            *(_DWORD *)buf = 136446210;
            v76 = "networkd_settings_read_from_file";
            v44 = "%{public}s xpc_create_from_plist failed";
          }
          else if (v73)
          {
            v51 = (char *)__nw_create_backtrace_string();
            v42 = __nwlog_obj(v51, v52);
            v43 = type;
            v53 = os_log_type_enabled(v42, type);
            if (v51)
            {
              if (v53)
              {
                *(_DWORD *)buf = 136446466;
                v76 = "networkd_settings_read_from_file";
                v77 = 2082;
                *(_QWORD *)v78 = v51;
                _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s xpc_create_from_plist failed, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v51);
              if (!v39)
                goto LABEL_85;
              goto LABEL_84;
            }
            if (!v53)
              goto LABEL_83;
            *(_DWORD *)buf = 136446210;
            v76 = "networkd_settings_read_from_file";
            v44 = "%{public}s xpc_create_from_plist failed, no backtrace";
          }
          else
          {
            v42 = __nwlog_obj(v40, v41);
            v43 = type;
            if (!os_log_type_enabled(v42, type))
              goto LABEL_83;
            *(_DWORD *)buf = 136446210;
            v76 = "networkd_settings_read_from_file";
            v44 = "%{public}s xpc_create_from_plist failed, backtrace limit exceeded";
          }
          v57 = v42;
          v58 = v43;
          v59 = 12;
          goto LABEL_82;
        }
      }
      else
      {
        v33 = v16;
        if ((v16 & 0x8000000000000000) == 0)
        {
          v34 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v34);
          v35 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v76 = "networkd_settings_read_from_file";
            v77 = 2048;
            *(_QWORD *)v78 = v33;
            *(_WORD *)&v78[8] = 2048;
            *(_QWORD *)&v78[10] = st_size;
            _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_ERROR, "%{public}s networkd settings file read invalid length %llu != fstat length %llu", buf, 0x20u);
          }
          goto LABEL_85;
        }
        v45 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        v46 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v46);
        *(_DWORD *)buf = 136446466;
        v76 = "networkd_settings_read_from_file";
        v77 = 1024;
        *(_DWORD *)v78 = v45;
        v39 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v73 = 0;
        v47 = __nwlog_fault(v39, &type, &v73);
        if ((_DWORD)v47)
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v49 = __nwlog_obj(v47, v48);
            v50 = type;
            if (!os_log_type_enabled(v49, type))
              goto LABEL_83;
            *(_DWORD *)buf = 136446466;
            v76 = "networkd_settings_read_from_file";
            v77 = 1024;
            *(_DWORD *)v78 = v45;
            v44 = "%{public}s networkd settings file pread failed %{darwin.errno}d";
          }
          else if (v73)
          {
            v54 = (char *)__nw_create_backtrace_string();
            v49 = __nwlog_obj(v54, v55);
            v50 = type;
            v56 = os_log_type_enabled(v49, type);
            if (v54)
            {
              if (v56)
              {
                *(_DWORD *)buf = 136446722;
                v76 = "networkd_settings_read_from_file";
                v77 = 1024;
                *(_DWORD *)v78 = v45;
                *(_WORD *)&v78[4] = 2082;
                *(_QWORD *)&v78[6] = v54;
                _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s networkd settings file pread failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(v54);
              goto LABEL_83;
            }
            if (!v56)
              goto LABEL_83;
            *(_DWORD *)buf = 136446466;
            v76 = "networkd_settings_read_from_file";
            v77 = 1024;
            *(_DWORD *)v78 = v45;
            v44 = "%{public}s networkd settings file pread failed %{darwin.errno}d, no backtrace";
          }
          else
          {
            v49 = __nwlog_obj(v47, v48);
            v50 = type;
            if (!os_log_type_enabled(v49, type))
              goto LABEL_83;
            *(_DWORD *)buf = 136446466;
            v76 = "networkd_settings_read_from_file";
            v77 = 1024;
            *(_DWORD *)v78 = v45;
            v44 = "%{public}s networkd settings file pread failed %{darwin.errno}d, backtrace limit exceeded";
          }
          v57 = v49;
          v58 = v50;
          v59 = 18;
LABEL_82:
          _os_log_impl(&dword_182FBE000, v57, v58, v44, buf, v59);
        }
      }
LABEL_83:
      if (v39)
LABEL_84:
        free(v39);
LABEL_85:
      free(v15);
      goto LABEL_86;
    }
    v61 = __nwlog_obj(0, v14);
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v76 = "strict_malloc";
    v77 = 2048;
    *(_QWORD *)v78 = st_size;
    v62 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v62))
    {
      __break(1u);
      return;
    }
    free(v62);
    __nwlog_obj(v63, v64);
    *(_DWORD *)buf = 136446466;
    v76 = "networkd_settings_read_from_file";
    v77 = 2048;
    *(_QWORD *)v78 = st_size;
    v15 = (void *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v73 = 0;
    v65 = __nwlog_fault((const char *)v15, &type, &v73);
    if ((_DWORD)v65)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v67 = __nwlog_obj(v65, v66);
        v68 = type;
        if (!os_log_type_enabled(v67, type))
          goto LABEL_105;
        *(_DWORD *)buf = 136446466;
        v76 = "networkd_settings_read_from_file";
        v77 = 2048;
        *(_QWORD *)v78 = st_size;
        v69 = "%{public}s malloc(%lld) failed";
LABEL_104:
        _os_log_impl(&dword_182FBE000, v67, v68, v69, buf, 0x16u);
        goto LABEL_105;
      }
      if (!v73)
      {
        v67 = __nwlog_obj(v65, v66);
        v68 = type;
        if (!os_log_type_enabled(v67, type))
          goto LABEL_105;
        *(_DWORD *)buf = 136446466;
        v76 = "networkd_settings_read_from_file";
        v77 = 2048;
        *(_QWORD *)v78 = st_size;
        v69 = "%{public}s malloc(%lld) failed, backtrace limit exceeded";
        goto LABEL_104;
      }
      v70 = (char *)__nw_create_backtrace_string();
      v67 = __nwlog_obj(v70, v71);
      v68 = type;
      v72 = os_log_type_enabled(v67, type);
      if (!v70)
      {
        if (!v72)
          goto LABEL_105;
        *(_DWORD *)buf = 136446466;
        v76 = "networkd_settings_read_from_file";
        v77 = 2048;
        *(_QWORD *)v78 = st_size;
        v69 = "%{public}s malloc(%lld) failed, no backtrace";
        goto LABEL_104;
      }
      if (v72)
      {
        *(_DWORD *)buf = 136446722;
        v76 = "networkd_settings_read_from_file";
        v77 = 2048;
        *(_QWORD *)v78 = st_size;
        *(_WORD *)&v78[8] = 2082;
        *(_QWORD *)&v78[10] = v70;
        _os_log_impl(&dword_182FBE000, v67, v68, "%{public}s malloc(%lld) failed, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v70);
    }
LABEL_105:
    if (!v15)
    {
LABEL_86:
      close(v1);
      if (sCachedSettings)
      {
        dictionary = xpc_dictionary_get_dictionary((xpc_object_t)sCachedSettings, (const char *)nw_settings_managed_settings);
        if (dictionary)
          xpc_dictionary_apply(dictionary, &__block_literal_global_13_88100);
      }
      return;
    }
    goto LABEL_85;
  }
  v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v9 == 2)
    return;
  if (v9 == 1)
  {
    v10 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v10);
    v11 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v79.st_dev = 136446466;
      *(_QWORD *)&v79.st_mode = "networkd_settings_read_from_file";
      WORD2(v79.st_ino) = 2082;
      *(__darwin_ino64_t *)((char *)&v79.st_ino + 6) = nw_file_path_settings;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s Sandbox is preventing this process from reading networkd settings file at \"%{public}s\", please add an exception.", (uint8_t *)&v79, 0x16u);
    }
    return;
  }
  v23 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v23);
  v79.st_dev = 136446466;
  *(_QWORD *)&v79.st_mode = "networkd_settings_read_from_file";
  WORD2(v79.st_ino) = 1024;
  *(_DWORD *)((char *)&v79.st_ino + 6) = v9;
  v24 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v24, buf, &type))
  {
    if (buf[0] == 17)
    {
      v25 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v25);
      v26 = gLogObj;
      v27 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_59;
      v79.st_dev = 136446466;
      *(_QWORD *)&v79.st_mode = "networkd_settings_read_from_file";
      WORD2(v79.st_ino) = 1024;
      *(_DWORD *)((char *)&v79.st_ino + 6) = v9;
      v28 = "%{public}s networkd settings file open failed %{darwin.errno}d";
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v38 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v38);
      v26 = gLogObj;
      v27 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_59;
      v79.st_dev = 136446466;
      *(_QWORD *)&v79.st_mode = "networkd_settings_read_from_file";
      WORD2(v79.st_ino) = 1024;
      *(_DWORD *)((char *)&v79.st_ino + 6) = v9;
      v28 = "%{public}s networkd settings file open failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_58;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v31 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v31);
    v26 = gLogObj;
    v27 = buf[0];
    v32 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]);
    if (v30)
    {
      if (v32)
      {
        v79.st_dev = 136446722;
        *(_QWORD *)&v79.st_mode = "networkd_settings_read_from_file";
        WORD2(v79.st_ino) = 1024;
        *(_DWORD *)((char *)&v79.st_ino + 6) = v9;
        HIWORD(v79.st_uid) = 2082;
        *(_QWORD *)&v79.st_gid = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s networkd settings file open failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&v79, 0x1Cu);
      }
      free(v30);
      goto LABEL_59;
    }
    if (v32)
    {
      v79.st_dev = 136446466;
      *(_QWORD *)&v79.st_mode = "networkd_settings_read_from_file";
      WORD2(v79.st_ino) = 1024;
      *(_DWORD *)((char *)&v79.st_ino + 6) = v9;
      v28 = "%{public}s networkd settings file open failed %{darwin.errno}d, no backtrace";
LABEL_58:
      _os_log_impl(&dword_182FBE000, v26, v27, v28, (uint8_t *)&v79, 0x12u);
    }
  }
LABEL_59:
  if (v24)
    free(v24);
}

nw_data_transfer_report_t nw_connection_create_new_data_transfer_report(nw_connection_t connection)
{
  NSObject *v2;
  NWConcrete_nw_data_transfer_report *v3;
  NSObject *v4;
  NSObject *v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  _BYTE buf[24];
  void *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = connection;
  v3 = objc_alloc_init(NWConcrete_nw_data_transfer_report);
  objc_storeStrong((id *)v3 + 3, connection);
  v4 = v2;
  v5 = v3;
  if (v4)
  {
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __nw_connection_add_data_transfer_report_block_invoke;
    v18 = &unk_1E14ACE68;
    v19 = v4;
    v20 = v5;
    nw_connection_async_if_needed(v19, buf);

    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_add_data_transfer_report";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_add_data_transfer_report";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_add_data_transfer_report";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_add_data_transfer_report";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_add_data_transfer_report";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

  return v5;
}

void sub_1831EE24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void __nw_connection_add_data_transfer_report_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  void *v9;
  _DWORD *v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(int *)(v2 + 80) < 4)
  {
    v6 = *(_QWORD *)(v2 + 424);
    if (!v6)
    {
      v7 = nw_array_create();
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(void **)(v8 + 424);
      *(_QWORD *)(v8 + 424) = v7;

      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 424);
    }
    nw_array_append(v6, *(void **)(a1 + 40));
    v10 = *(_DWORD **)(a1 + 32);
    if (v10[20] == 3)
      nw_connection_initial_data_transfer_report_snapshot_on_nw_queue(v10, *(void **)(a1 + 40));
  }
  else
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        v11 = 136446466;
        v12 = "nw_connection_add_data_transfer_report_block_invoke";
        v13 = 1024;
        v14 = v5;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Cannot add data transfer report to connection past the ready state", (uint8_t *)&v11, 0x12u);
      }

    }
  }
}

void nw_connection_initial_data_transfer_report_snapshot_on_nw_queue(void *a1, void *a2)
{
  void **v3;
  id v4;
  void *v5;
  NWConcrete_nw_endpoint_handler *v6;
  uint64_t v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  os_unfair_lock_s *v10;
  void (**v11)(_QWORD);
  NWConcrete_nw_endpoint_handler *v12;
  OS_nw_path *v13;
  id v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  os_log_type_t v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  char *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  void *v33;
  os_log_type_t type[15];
  char v35;
  _OWORD aBlock[2];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(aBlock[0]) = 136446210;
    *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
    v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (!__nwlog_fault(v20, type, &v33))
      goto LABEL_61;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null connection", (uint8_t *)aBlock, 0xCu);
      }
    }
    else if ((_BYTE)v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v26 = type[0];
      v27 = os_log_type_enabled(v21, type[0]);
      if (backtrace_string)
      {
        if (v27)
        {
          LODWORD(aBlock[0]) = 136446466;
          *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
          WORD6(aBlock[0]) = 2082;
          *(_QWORD *)((char *)aBlock + 14) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null connection, dumping backtrace:%{public}s", (uint8_t *)aBlock, 0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v20)
          goto LABEL_23;
        goto LABEL_62;
      }
      if (v27)
      {
        LODWORD(aBlock[0]) = 136446210;
        *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null connection, no backtrace", (uint8_t *)aBlock, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v31 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v21, v31, "%{public}s called with null connection, backtrace limit exceeded", (uint8_t *)aBlock, 0xCu);
      }
    }
LABEL_60:

    goto LABEL_61;
  }
  if (!v4)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(aBlock[0]) = 136446210;
    *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
    v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (!__nwlog_fault(v20, type, &v33))
      goto LABEL_61;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v24 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null report", (uint8_t *)aBlock, 0xCu);
      }
    }
    else if ((_BYTE)v33)
    {
      v28 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v29 = type[0];
      v30 = os_log_type_enabled(v21, type[0]);
      if (v28)
      {
        if (v30)
        {
          LODWORD(aBlock[0]) = 136446466;
          *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
          WORD6(aBlock[0]) = 2082;
          *(_QWORD *)((char *)aBlock + 14) = v28;
          _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s called with null report, dumping backtrace:%{public}s", (uint8_t *)aBlock, 0x16u);
        }

        free(v28);
        if (!v20)
          goto LABEL_23;
LABEL_62:
        free(v20);
        goto LABEL_23;
      }
      if (v30)
      {
        LODWORD(aBlock[0]) = 136446210;
        *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s called with null report, no backtrace", (uint8_t *)aBlock, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v32 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_182FBE000, v21, v32, "%{public}s called with null report, backtrace limit exceeded", (uint8_t *)aBlock, 0xCu);
      }
    }
    goto LABEL_60;
  }
  nw_context_assert_queue(v3[3]);
  if ((*((_BYTE *)v3 + 109) & 0x40) != 0)
  {
    v6 = nw_endpoint_handler_copy_connected_flow_handler(v3[18]);
    if (v6)
    {
      v7 = mach_continuous_time();
      if (v7 <= 1)
        v8 = 1;
      else
        v8 = v7;
      v9 = v5;
      *(_QWORD *)&aBlock[0] = MEMORY[0x1E0C809B0];
      *((_QWORD *)&aBlock[0] + 1) = 3221225472;
      *(_QWORD *)&aBlock[1] = __nw_data_transfer_set_initial_snapshot_time_block_invoke;
      *((_QWORD *)&aBlock[1] + 1) = &unk_1E14AA348;
      v10 = v9;
      *(_QWORD *)&v37 = v10;
      *((_QWORD *)&v37 + 1) = v8;
      v11 = (void (**)(_QWORD))_Block_copy(aBlock);
      v9 += 10;
      os_unfair_lock_lock(v9);
      v11[2](v11);
      os_unfair_lock_unlock(v9);

      v35 = 0;
      v33 = 0;
      *(_QWORD *)type = 0;
      nw_connection_fillout_data_transfer_snapshot_on_nw_queue(v3, (uint64_t *)&v33, type, &v35, 1);
      v12 = v6;
      os_unfair_lock_lock(&v12->lock);
      v13 = v12->current_path;
      os_unfair_lock_unlock(&v12->lock);

      v14 = nw_path_copy_interface(v13);
      if (v14)
      {
        if (v33 && __ROR8__(0xD37A6F4DE9BD37A7 * *(_QWORD *)type, 3) <= 0x1642C8590B21642uLL)
        {
          if (*(_QWORD *)type >= 0xB8uLL)
          {
            v17 = 0;
            v18 = 0;
            do
            {
              nw_data_transfer_add_initial_snapshot(v10, v14, (NWConcrete_nw_interface **)((char *)v33 + v17));
              ++v18;
              v17 += 184;
            }
            while (v18 < *(_QWORD *)type / 0xB8uLL);
          }
        }
        else
        {
          v46 = 0;
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v38 = 0u;
          v39 = 0u;
          v37 = 0u;
          memset(aBlock, 0, sizeof(aBlock));
          nw_data_transfer_add_initial_snapshot(v10, v14, (NWConcrete_nw_interface **)aBlock);
        }
      }
      if (v35 && v33)
      {
        free(v33);
        v33 = 0;
      }

LABEL_22:
      goto LABEL_23;
    }
  }
  v15 = v3[2];
  if (v15 && !nw_path_parameters_get_logging_disabled(v15[13]))
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v12 = (NWConcrete_nw_endpoint_handler *)(id)gconnectionLogObj;
    if (os_log_type_enabled(&v12->super, OS_LOG_TYPE_ERROR))
    {
      v16 = *((_DWORD *)v3 + 112);
      LODWORD(aBlock[0]) = 136446466;
      *(_QWORD *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
      WORD6(aBlock[0]) = 1024;
      *(_DWORD *)((char *)aBlock + 14) = v16;
      _os_log_impl(&dword_182FBE000, &v12->super, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Cannot snapshot data transfer report without a connected endpoint handler", (uint8_t *)aBlock, 0x12u);
    }
    goto LABEL_22;
  }
LABEL_23:

}

void sub_1831EEDD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t __nw_data_transfer_set_initial_snapshot_time_block_invoke(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 32) + 8) = *(_QWORD *)(result + 40);
  return result;
}

void nw_data_transfer_add_initial_snapshot(void *a1, void *a2, NWConcrete_nw_interface **a3)
{
  os_unfair_lock_s *v5;
  NWConcrete_nw_interface *v6;
  NWConcrete_nw_interface *v7;
  NWConcrete_nw_interface *v8;
  NSObject *v9;
  NWConcrete_nw_interface *v10;
  NSObject *v11;
  int radio_type;
  const char *v13;
  void (**v14)(_QWORD);
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _QWORD aBlock[4];
  os_unfair_lock_s *v24;
  NWConcrete_nw_interface *v25;
  NWConcrete_nw_interface **v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  void *v32;
  __int16 v33;
  NWConcrete_nw_interface *v34;
  __int16 v35;
  const char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  if (a3)
  {
    v7 = *a3;
    if (!*a3 || v6 && v7 == (NWConcrete_nw_interface *)v6->index)
    {
      v8 = v6;
    }
    else
    {
      v8 = nw_interface_create_with_index(v7);

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v10 = *a3;
        *(_DWORD *)buf = 136446722;
        v30 = "nw_data_transfer_add_initial_snapshot";
        v31 = 2112;
        v32 = v8;
        v33 = 2048;
        v34 = v10;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s created interface %@ from index %llu", buf, 0x20u);
      }

    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      radio_type = nw_interface_get_radio_type(v8);
      v13 = nw_interface_radio_type_to_string(radio_type);
      *(_DWORD *)buf = 136446978;
      v30 = "nw_data_transfer_add_initial_snapshot";
      v31 = 2048;
      v32 = v5;
      v33 = 2112;
      v34 = v8;
      v35 = 2080;
      v36 = v13;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s report %p adding initial snapshot for interface %@[%s]", buf, 0x2Au);
    }

    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_data_transfer_add_initial_snapshot_block_invoke;
    aBlock[3] = &unk_1E14AB278;
    v24 = v5;
    v6 = v8;
    v25 = v6;
    v26 = a3;
    v14 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v5 + 10);
    v14[2](v14);
    os_unfair_lock_unlock(v5 + 10);

    goto LABEL_12;
  }
  __nwlog_obj();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_data_transfer_add_initial_snapshot";
  v16 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v16, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_data_transfer_add_initial_snapshot";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null snapshot", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_data_transfer_add_initial_snapshot";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null snapshot, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_data_transfer_add_initial_snapshot";
        _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null snapshot, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_data_transfer_add_initial_snapshot";
        _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null snapshot, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_29:
  if (v16)
    free(v16);
LABEL_12:

}

void sub_1831EF2BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void __nw_data_transfer_add_initial_snapshot_block_invoke(uint64_t a1)
{
  _BOOL8 path_report_for_interface_locked;
  nw_data_transfer_path_report *v3;

  path_report_for_interface_locked = nw_data_transfer_report_get_path_report_for_interface_locked(*(void **)(a1 + 32), *(void **)(a1 + 40), 1);
  if (path_report_for_interface_locked)
  {
    v3 = (nw_data_transfer_path_report *)path_report_for_interface_locked;
    if (!*(_QWORD *)(path_report_for_interface_locked + 352))
      objc_storeStrong((id *)(path_report_for_interface_locked + 352), *(id *)(a1 + 40));
    nw_data_transfer_update_path_report_begin(v3, *(nw_data_transfer_snapshot **)(a1 + 48));
    objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 32), *(id *)(a1 + 40));
  }
}

uint64_t nw_interface_get_radio_type(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[84];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_get_radio_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_radio_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_get_radio_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_radio_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_get_radio_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_interface_get_loopback_index_block_invoke()
{
  NSObject *v0;
  int v1;
  const char *v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  nw_interface_get_loopback_index::index = if_nametoindex("lo0");
  if (!nw_interface_get_loopback_index::index)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v0 = (id)gLogObj;
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      v1 = 136446210;
      v2 = "nw_interface_get_loopback_index_block_invoke";
      _os_log_impl(&dword_182FBE000, v0, OS_LOG_TYPE_ERROR, "%{public}s Unable to determine interface index for lo0, using 1", (uint8_t *)&v1, 0xCu);
    }

    nw_interface_get_loopback_index::index = 1;
  }
}

uint64_t type metadata accessor for NWParameters()
{
  return objc_opt_self();
}

uint64_t sub_1831EF6F0@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_1831EF71C(a1, (uint64_t (*)(_QWORD))nw_parameters_copy_default_protocol_stack, (void (*)(void))type metadata accessor for NWParameters.ProtocolStack, (uint64_t *)&unk_1EDCDB630, a2);
}

uint64_t sub_1831EF71C@<X0>(_QWORD *a1@<X0>, uint64_t (*a2)(_QWORD)@<X1>, void (*a3)(void)@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v8 = a2(*a1);
  a3();
  v9 = swift_allocObject();
  __swift_instantiateConcreteTypeFromMangledName(a4);
  result = swift_allocObject();
  *(_DWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 16) = v8;
  *(_QWORD *)(v9 + 16) = result;
  *a5 = v9;
  return result;
}

uint64_t type metadata accessor for NWParameters.ProtocolStack()
{
  return objc_opt_self();
}

uint64_t sub_1831EF7BC(nw_protocol_stack_t *a1, unint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v3 = *a1;
  nw_protocol_stack_clear_application_protocols(*a1);
  if (a2 >> 62)
    goto LABEL_15;
  v4 = *(_QWORD *)((a2 & 0xFFFFFFFFFFFFF8) + 0x10);
  swift_bridgeObjectRetain();
  for (; v4; v4 = sub_183B91F68())
  {
    if ((a2 & 0xC000000000000001) != 0)
    {
      while (1)
      {
        v5 = __OFSUB__(v4--, 1);
        if (v5)
          break;
        v6 = MEMORY[0x186DB230C](v4, a2);
        nw_protocol_stack_prepend_application_protocol(v3, *(nw_protocol_options_t *)(v6 + 16));
        swift_unknownObjectRelease();
        if (!v4)
          return swift_bridgeObjectRelease();
      }
      __break(1u);
    }
    else
    {
      v7 = *(_QWORD *)((a2 & 0xFFFFFFFFFFFFF8) + 0x10);
      v8 = v4 - 1;
      while (1)
      {
        v5 = __OFSUB__(v4--, 1);
        if (v5)
          break;
        if (v8 >= v7)
          goto LABEL_14;
        nw_protocol_stack_prepend_application_protocol(v3, *(nw_protocol_options_t *)(*(_QWORD *)(a2 + 32 + 8 * v4) + 16));
        if (!v4)
          return swift_bridgeObjectRelease();
      }
    }
    __break(1u);
LABEL_14:
    __break(1u);
LABEL_15:
    swift_bridgeObjectRetain();
  }
  return swift_bridgeObjectRelease();
}

void nw_protocol_stack_clear_application_protocols(nw_protocol_stack_t stack)
{
  nw_protocol_stack_t v1;
  _QWORD *p_isa;
  Class isa;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = stack;
  p_isa = &v1->isa;
  if (v1)
  {
    isa = v1[1].isa;
    v1[1].isa = 0;

    v4 = (void *)p_isa[2];
    p_isa[2] = 0;

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_stack_clear_application_protocols";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_clear_application_protocols";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_stack_clear_application_protocols";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_clear_application_protocols";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_clear_application_protocols";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_parameters_clear_proxy_options(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)*((_QWORD *)v1 + 21);
    *((_QWORD *)v1 + 21) = 0;

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_parameters_clear_proxy_options";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_parameters_clear_proxy_options";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_parameters_clear_proxy_options";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_parameters_clear_proxy_options";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_parameters_clear_proxy_options";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void nw_flow_notify(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4, uint64_t a5)
{
  id v10;
  NWConcrete_nw_endpoint_handler *v11;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v13;
  NWConcrete_nw_endpoint_handler *v14;
  int state;
  NWConcrete_nw_endpoint_handler *v16;
  NWConcrete_nw_endpoint_handler *v17;
  char v18;
  NWConcrete_nw_endpoint_handler *v19;
  NSObject *v20;
  NWConcrete_nw_endpoint_handler *v21;
  NWConcrete_nw_endpoint_handler *v22;
  char v23;
  const char *v24;
  nw_endpoint_t v25;
  const char *logging_description;
  NWConcrete_nw_endpoint_handler *v27;
  NWConcrete_nw_endpoint_handler *v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  NWConcrete_nw_endpoint_handler *v32;
  char v33;
  NSObject *v34;
  NWConcrete_nw_endpoint_handler *v35;
  NWConcrete_nw_endpoint_handler *v36;
  char v37;
  const char *v38;
  nw_endpoint_t v39;
  NWConcrete_nw_endpoint_handler *v40;
  NWConcrete_nw_endpoint_handler *v41;
  uint64_t v42;
  const char *v43;
  char *id_str;
  void **v45;
  void **v46;
  const char *v47;
  char *v48;
  void **v49;
  void **v50;
  const char *v51;
  void **v52;
  id v53;
  id v54;
  void *v55;
  const char *v56;
  void **v57;
  id v58;
  id v59;
  void *v60;
  const char *v61;
  id v62;
  const char *v63;
  const char *v64;
  nw_endpoint_t v65;
  const char *v66;
  const char *v67;
  const char *v68;
  id v69;
  const char *v70;
  char *v71;
  NSObject *v72;
  os_log_type_t v73;
  const char *v74;
  const char *v75;
  nw_endpoint_t v76;
  const char *v77;
  const char *v78;
  const char *v79;
  id v80;
  NWConcrete_nw_protocol_definition *v81;
  id v82;
  NWConcrete_nw_endpoint_mode_handler *v83;
  int v84;
  __int16 v85;
  int int64;
  nw_endpoint_t v87;
  id v88;
  id v89;
  const void *v90;
  void *v91;
  NSObject *v92;
  id v93;
  nw_endpoint_t v94;
  id v95;
  id v96;
  const void *v97;
  void *v98;
  NSObject *v99;
  id v100;
  int minimize_logging;
  char logging_disabled;
  NSObject *v103;
  const char *v104;
  const char *v105;
  nw_endpoint_t v106;
  const char *v107;
  NWConcrete_nw_endpoint_handler *v108;
  const char *v109;
  const char *v110;
  id v111;
  int v112;
  int v113;
  char v114;
  NSObject *v115;
  const char *v116;
  const char *v117;
  nw_endpoint_t v118;
  const char *v119;
  NWConcrete_nw_endpoint_handler *v120;
  const char *v121;
  const char *v122;
  NWConcrete_nw_endpoint_handler *v123;
  id v124;
  int v125;
  char v126;
  id v127;
  const char *v128;
  const char *v129;
  nw_endpoint_t v130;
  const char *v131;
  NWConcrete_nw_endpoint_handler *v132;
  const char *v133;
  const char *v134;
  id v135;
  char *v136;
  NSObject *v137;
  os_log_type_t v138;
  const char *v139;
  const char *v140;
  nw_endpoint_t v141;
  const char *v142;
  const char *v143;
  const char *v144;
  id v145;
  id v146;
  const char *v147;
  const char *v148;
  nw_endpoint_t v149;
  const char *v150;
  const char *v151;
  const char *v152;
  id v153;
  os_log_type_t v154;
  const char *v155;
  const char *v156;
  nw_endpoint_t v157;
  const char *v158;
  const char *v159;
  const char *v160;
  id v161;
  id v162;
  const char *v163;
  const char *v164;
  nw_endpoint_t v165;
  const char *v166;
  const char *v167;
  const char *v168;
  id v169;
  os_log_type_t v170;
  const char *v171;
  const char *v172;
  nw_endpoint_t v173;
  const char *v174;
  const char *v175;
  const char *v176;
  id v177;
  const char *backtrace_string;
  char *v179;
  NSObject *v180;
  os_log_type_t v181;
  const char *v182;
  const char *v183;
  const char *v184;
  const char *v185;
  const char *v186;
  id v187;
  void *v188;
  _BOOL8 v189;
  const char *v190;
  char *v191;
  NSObject *v192;
  os_log_type_t v193;
  const char *v194;
  const char *v195;
  const char *v196;
  const char *v197;
  const char *v198;
  id v199;
  const char *v200;
  os_log_type_t v201;
  const char *v202;
  const char *v203;
  const char *v204;
  const char *v205;
  const char *v206;
  id v207;
  const char *v208;
  os_log_type_t v209;
  const char *v210;
  const char *v211;
  const char *v212;
  const char *v213;
  const char *v214;
  id v215;
  uint64_t v216;
  uint64_t v217;
  os_log_type_t v218;
  const char *v219;
  const char *v220;
  nw_endpoint_t v221;
  const char *v222;
  const char *v223;
  const char *v224;
  id v225;
  NWConcrete_nw_endpoint_handler *v226;
  unint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  BOOL v231;
  NWConcrete_nw_endpoint_handler *v232;
  NSObject *v233;
  const char *v234;
  const char *v235;
  nw_endpoint_t v236;
  const char *v237;
  const char *v238;
  const char *v239;
  id v240;
  int v241;
  const void *v242;
  void *v243;
  NSObject *v244;
  id v245;
  NSObject *v246;
  const char *v247;
  const char *v248;
  nw_endpoint_t v249;
  const char *v250;
  NWConcrete_nw_endpoint_handler *v251;
  const char *v252;
  const char *v253;
  id v254;
  int v255;
  os_log_type_t v256;
  const char *v257;
  const char *v258;
  nw_endpoint_t v259;
  const char *v260;
  const char *v261;
  const char *v262;
  id v263;
  os_log_type_t v264;
  const char *v265;
  const char *v266;
  nw_endpoint_t v267;
  const char *v268;
  const char *v269;
  const char *v270;
  id v271;
  os_log_type_t v272;
  const char *v273;
  const char *v274;
  nw_endpoint_t v275;
  const char *v276;
  const char *v277;
  const char *v278;
  id v279;
  os_log_type_t v280;
  const char *v281;
  const char *v282;
  nw_endpoint_t v283;
  const char *v284;
  const char *v285;
  const char *v286;
  id v287;
  os_log_type_t v288;
  const char *v289;
  const char *v290;
  nw_endpoint_t v291;
  const char *v292;
  const char *v293;
  const char *v294;
  id v295;
  os_log_type_t v296;
  const char *v297;
  const char *v298;
  nw_endpoint_t v299;
  const char *v300;
  const char *v301;
  const char *v302;
  id v303;
  os_log_type_t v304;
  const char *v305;
  const char *v306;
  nw_endpoint_t v307;
  const char *v308;
  const char *v309;
  const char *v310;
  id v311;
  nw_endpoint_t v312;
  const char *v313;
  id v314;
  void *v315;
  const char *v316;
  const char *v317;
  const char *v318;
  nw_endpoint_t v319;
  const char *v320;
  const char *v321;
  const char *v322;
  id v323;
  int v324;
  const char *v325;
  const char *v326;
  nw_endpoint_t v327;
  const char *v328;
  const char *v329;
  const char *v330;
  id v331;
  void *v332;
  char *v333;
  NSObject *v334;
  os_log_type_t v335;
  char *v336;
  os_log_type_t v337;
  _BOOL4 v338;
  os_log_type_t v339;
  nw_endpoint_t v340;
  NSObject *log;
  const char *loga;
  const char *v343;
  const char *v344;
  const char *v345;
  nw_endpoint_t v346;
  const char *v347;
  nw_endpoint_t v348;
  const char *v349;
  unsigned __int8 *v350;
  const char *v351;
  nw_endpoint_t v352;
  nw_endpoint_t v353;
  nw_endpoint_t v354;
  const char *id_string;
  unsigned int *v356;
  NWConcrete_nw_endpoint_handler *v357;
  NWConcrete_nw_endpoint_handler *v358;
  NWConcrete_nw_endpoint_mode_handler *v359;
  id v360;
  _QWORD v361[4];
  NWConcrete_nw_endpoint_handler *v362;
  uint64_t v363;
  char v364;
  os_log_type_t type;
  _QWORD v366[4];
  id v367;
  _QWORD block[4];
  id v369;
  _QWORD v370[4];
  id v371;
  uint8_t buf[4];
  const char *v373;
  __int16 v374;
  void *v375;
  __int16 v376;
  const char *v377;
  __int16 v378;
  const char *v379;
  __int16 v380;
  const char *v381;
  __int16 v382;
  const char *v383;
  __int16 v384;
  id v385;
  __int16 v386;
  const char *v387;
  __int16 v388;
  char *v389;
  uint64_t v390;

  v390 = *MEMORY[0x1E0C80C00];
  v10 = *(id *)(*(_QWORD *)(a1 + 40) + 160);
  if (v10)
  {
    v360 = v10;
    v11 = (NWConcrete_nw_endpoint_handler *)v10;
    mode = v11->mode;

    if ((_DWORD)mode != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (NWConcrete_nw_endpoint_mode_handler *)(id)gLogObj;
      if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5)
          v31 = "unknown-mode";
        else
          v31 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v373 = "nw_flow_notify";
        v374 = 2082;
        v375 = (void *)v31;
        v376 = 2082;
        v377 = "flow";
        _os_log_impl(&dword_182FBE000, (os_log_t)v13, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
      goto LABEL_45;
    }
    v13 = nw_endpoint_handler_copy_flow(v11);
    v14 = v11;
    state = v14->state;

    if (state == 5)
    {
      v16 = v14;
      v17 = v14;
      v18 = *((_BYTE *)v17 + 268);

      if ((v18 & 0x20) == 0)
      {
        v359 = v13;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = v16;
        v20 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          v357 = v11;
          v21 = v17;

          v22 = v21;
          v23 = *((_BYTE *)v17 + 268);

          if ((v23 & 1) != 0)
            v24 = "dry-run ";
          else
            v24 = "";
          v25 = nw_endpoint_handler_copy_endpoint(v22);
          logging_description = nw_endpoint_get_logging_description(v25);
          v348 = v25;
          v27 = v22;
          v28 = v27;
          v29 = v19->state;
          if (v29 > 5)
            v30 = "unknown-state";
          else
            v30 = off_1E149FC48[v29];
          id_str = v21->id_str;

          v45 = v28;
          v46 = v45;
          v47 = "path";
          switch(v357->mode)
          {
            case 0:
              break;
            case 1:
              v47 = "resolver";
              break;
            case 2:
              v47 = nw_endpoint_flow_mode_string(v45[31]);
              break;
            case 3:
              v47 = "proxy";
              break;
            case 4:
              v47 = "fallback";
              break;
            case 5:
              v47 = "transform";
              break;
            default:
              v47 = "unknown-mode";
              break;
          }

          v52 = v46;
          os_unfair_lock_lock((os_unfair_lock_t)v52 + 28);
          v53 = v52[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v52 + 28);

          v54 = v53;
          v55 = v54;
          if (a3 > 0x19)
            v56 = "unknown";
          else
            v56 = off_1E14A22C8[a3];
          *(_DWORD *)buf = 136448002;
          v373 = "nw_flow_notify";
          v374 = 2082;
          v375 = id_str;
          v376 = 2082;
          v377 = v24;
          v378 = 2082;
          v379 = logging_description;
          v380 = 2082;
          v381 = v30;
          v382 = 2082;
          v383 = v47;
          v384 = 2114;
          v385 = v54;
          v386 = 2082;
          v387 = v56;
          _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring notification %{public}s after cancellation", buf, 0x52u);

        }
LABEL_44:
        v13 = v359;
      }
LABEL_45:

      v10 = v360;
      goto LABEL_46;
    }
    if (a3 == 20)
      goto LABEL_45;
    v358 = v11;
    v359 = v13;
    v356 = (unsigned int *)v14;
    if (nw_endpoint_handler_get_minimize_logging(v14))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v14) & 1) != 0)
        goto LABEL_57;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v34 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v14);
        v347 = nw_endpoint_handler_dry_run_string(v14);
        v312 = nw_endpoint_handler_copy_endpoint(v14);
        v344 = nw_endpoint_get_logging_description(v312);
        loga = nw_endpoint_handler_state_string(v14);
        v313 = nw_endpoint_handler_mode_string(v14);
        v314 = nw_endpoint_handler_copy_current_path(v14);
        v315 = v314;
        if (a3 > 0x19)
          v316 = "unknown";
        else
          v316 = off_1E14A22C8[a3];
        *(_DWORD *)buf = 136448002;
        v373 = "nw_flow_notify";
        v374 = 2082;
        v375 = (void *)id_string;
        v376 = 2082;
        v377 = v347;
        v378 = 2082;
        v379 = v344;
        v380 = 2082;
        v381 = loga;
        v382 = 2082;
        v383 = v313;
        v384 = 2114;
        v385 = v314;
        v386 = 2082;
        v387 = v316;
        _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received notification %{public}s", buf, 0x52u);

      }
    }
    else
    {
      v32 = v14;
      v33 = *((_BYTE *)v32 + 268);

      if ((v33 & 0x20) != 0)
      {
LABEL_57:
        switch(a3)
        {
          case 0u:
            if ((nw_endpoint_handler_get_logging_disabled(v14) & 1) != 0)
              goto LABEL_45;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v62 = (id)gconnectionLogObj;
            v63 = nw_endpoint_handler_get_id_string(v14);
            v64 = nw_endpoint_handler_dry_run_string(v14);
            v65 = nw_endpoint_handler_copy_endpoint(v14);
            v66 = nw_endpoint_get_logging_description(v65);
            v67 = nw_endpoint_handler_state_string(v14);
            v68 = nw_endpoint_handler_mode_string(v14);
            v69 = nw_endpoint_handler_copy_current_path(v14);
            *(_DWORD *)buf = 136448002;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v63;
            v376 = 2082;
            v377 = v64;
            v378 = 2082;
            v379 = v66;
            v380 = 2082;
            v381 = v67;
            v382 = 2082;
            v383 = v68;
            v384 = 2114;
            v385 = v69;
            v386 = 2082;
            v387 = "undefined";
            v70 = (const char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v71 = (char *)v70;
            if ((__nwlog_fault(v70, &type, &v364) & 1) == 0)
              goto LABEL_252;
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v73 = type;
              if (os_log_type_enabled(v72, type))
              {
                v74 = nw_endpoint_handler_get_id_string(v356);
                v75 = nw_endpoint_handler_dry_run_string(v356);
                v76 = nw_endpoint_handler_copy_endpoint(v356);
                v77 = nw_endpoint_get_logging_description(v76);
                v78 = nw_endpoint_handler_state_string(v356);
                v79 = nw_endpoint_handler_mode_string(v356);
                v80 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v74;
                v376 = 2082;
                v377 = v75;
                v378 = 2082;
                v379 = v77;
                v380 = 2082;
                v381 = v78;
                v382 = 2082;
                v383 = v79;
                v384 = 2114;
                v385 = v80;
                v386 = 2082;
                v387 = "undefined";
                _os_log_impl(&dword_182FBE000, v72, v73, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s notification", buf, 0x52u);

              }
              goto LABEL_250;
            }
            if (v364)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v179 = (char *)backtrace_string;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v180 = (id)gconnectionLogObj;
                v181 = type;
                if (os_log_type_enabled(v180, type))
                {
                  v182 = nw_endpoint_handler_get_id_string(v356);
                  v183 = nw_endpoint_handler_dry_run_string(v356);
                  v352 = nw_endpoint_handler_copy_endpoint(v356);
                  v184 = nw_endpoint_get_logging_description(v352);
                  v185 = nw_endpoint_handler_state_string(v356);
                  v186 = nw_endpoint_handler_mode_string(v356);
                  v187 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448258;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v182;
                  v376 = 2082;
                  v377 = v183;
                  v378 = 2082;
                  v379 = v184;
                  v380 = 2082;
                  v381 = v185;
                  v382 = 2082;
                  v383 = v186;
                  v384 = 2114;
                  v385 = v187;
                  v386 = 2082;
                  v387 = "undefined";
                  v388 = 2082;
                  v389 = v179;
                  _os_log_impl(&dword_182FBE000, v180, v181, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s notification, dumping backtrace:%{public}s", buf, 0x5Cu);

                }
                goto LABEL_175;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v256 = type;
              if (os_log_type_enabled(v72, type))
              {
                v257 = nw_endpoint_handler_get_id_string(v356);
                v258 = nw_endpoint_handler_dry_run_string(v356);
                v259 = nw_endpoint_handler_copy_endpoint(v356);
                v260 = nw_endpoint_get_logging_description(v259);
                v261 = nw_endpoint_handler_state_string(v356);
                v262 = nw_endpoint_handler_mode_string(v356);
                v263 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v257;
                v376 = 2082;
                v377 = v258;
                v378 = 2082;
                v379 = v260;
                v380 = 2082;
                v381 = v261;
                v382 = 2082;
                v383 = v262;
                v384 = 2114;
                v385 = v263;
                v386 = 2082;
                v387 = "undefined";
                _os_log_impl(&dword_182FBE000, v72, v256, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s notification, no backtrace", buf, 0x52u);

              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v218 = type;
              if (os_log_type_enabled(v72, type))
              {
                v219 = nw_endpoint_handler_get_id_string(v356);
                v220 = nw_endpoint_handler_dry_run_string(v356);
                v221 = nw_endpoint_handler_copy_endpoint(v356);
                v222 = nw_endpoint_get_logging_description(v221);
                v223 = nw_endpoint_handler_state_string(v356);
                v224 = nw_endpoint_handler_mode_string(v356);
                v225 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v219;
                v376 = 2082;
                v377 = v220;
                v378 = 2082;
                v379 = v222;
                v380 = 2082;
                v381 = v223;
                v382 = 2082;
                v383 = v224;
                v384 = 2114;
                v385 = v225;
                v386 = 2082;
                v387 = "undefined";
                _os_log_impl(&dword_182FBE000, v72, v218, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] error %{public}s notification, backtrace limit exceeded", buf, 0x52u);

              }
            }
            goto LABEL_250;
          case 1u:
            v94 = nw_endpoint_handler_copy_endpoint(v14);
            v95 = nw_endpoint_handler_copy_parameters(v14);
            v96 = nw_endpoint_flow_copy_path(v14);
            nw_connection_report_symptom_internal_on_nw_queue(421892, v94, v95, v96, 0, 0, 0, 0, 0, 0);

            v13 = v359;
            if (!*((_QWORD *)v359 + 105))
              goto LABEL_45;
            v97 = (const void *)*((_QWORD *)v359 + 127);
            if (!v97)
              goto LABEL_45;
            v98 = _Block_copy(v97);
            v99 = *((_QWORD *)v359 + 105);
            v370[0] = MEMORY[0x1E0C809B0];
            v370[1] = 3221225472;
            v370[2] = ___ZL14nw_flow_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke;
            v370[3] = &unk_1E14AC390;
            v371 = v98;
            v100 = v98;
            dispatch_async(v99, v370);

            goto LABEL_44;
          case 2u:
            v87 = nw_endpoint_handler_copy_endpoint(v14);
            v88 = nw_endpoint_handler_copy_parameters(v14);
            v89 = nw_endpoint_flow_copy_path(v14);
            nw_connection_report_symptom_internal_on_nw_queue(421891, v87, v88, v89, 0, 0, 0, 0, 0, 0);

            v13 = v359;
            if (!*((_QWORD *)v359 + 105))
              goto LABEL_45;
            v90 = (const void *)*((_QWORD *)v359 + 128);
            if (!v90)
              goto LABEL_45;
            v91 = _Block_copy(v90);
            v92 = *((_QWORD *)v359 + 105);
            block[0] = MEMORY[0x1E0C809B0];
            block[1] = 3221225472;
            block[2] = ___ZL14nw_flow_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke_2;
            block[3] = &unk_1E14AC390;
            v369 = v91;
            v93 = v91;
            dispatch_async(v92, block);

            goto LABEL_44;
          case 3u:
            if (*((_QWORD *)v13 + 129))
            {
              if (*((_QWORD *)v13 + 123))
              {
                ++*((_DWORD *)v13 + 248);
                if (*((_DWORD *)v13 + 249))
                  int64 = networkd_settings_get_int64((const char *)nw_setting_tcpconn_keepalive_cnt);
                else
                  int64 = 0;
                v226 = v14;
                if (*((_DWORD *)v13 + 250)
                  && networkd_settings_get_int64((const char *)nw_setting_tcpconn_keepalive_time))
                {
                  v227 = 60000000000;
                }
                else
                {
                  v227 = 0;
                }
                if (!int64 || *((_DWORD *)v13 + 248) >= 0xAu)
                {
                  v228 = *((_QWORD *)v13 + 123);
                  v229 = mach_continuous_time();
                  if (v229 <= 1)
                    v230 = 1;
                  else
                    v230 = v229;
                  v231 = nw_delta_nanos(v228, v230) / (unint64_t)*((unsigned int *)v13 + 248) > v227;
                  v232 = v226;
                  if (!v231)
                  {
                    if ((nw_endpoint_handler_get_logging_disabled(v226) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v233 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v233, OS_LOG_TYPE_DEBUG))
                      {
                        v234 = nw_endpoint_handler_get_id_string(v226);
                        v235 = nw_endpoint_handler_dry_run_string(v226);
                        v236 = nw_endpoint_handler_copy_endpoint(v226);
                        v237 = nw_endpoint_get_logging_description(v236);
                        v238 = nw_endpoint_handler_state_string(v226);
                        v239 = nw_endpoint_handler_mode_string(v226);
                        v240 = nw_endpoint_handler_copy_current_path(v226);
                        v241 = *((_DWORD *)v359 + 248);
                        *(_DWORD *)buf = 136448002;
                        v373 = "nw_flow_notify";
                        v374 = 2082;
                        v375 = (void *)v234;
                        v376 = 2082;
                        v377 = v235;
                        v378 = 2082;
                        v379 = v237;
                        v380 = 2082;
                        v381 = v238;
                        v382 = 2082;
                        v383 = v239;
                        v384 = 2114;
                        v385 = v240;
                        v386 = 1024;
                        LODWORD(v387) = v241;
                        _os_log_impl(&dword_182FBE000, v233, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Keepalive notify (count = %u)", buf, 0x4Eu);

                      }
                      v13 = v359;
                      v232 = v226;
                    }
                    if (*((_QWORD *)v13 + 105))
                    {
                      v242 = (const void *)*((_QWORD *)v13 + 129);
                      if (v242)
                      {
                        v243 = _Block_copy(v242);
                        v244 = *((_QWORD *)v13 + 105);
                        v366[0] = MEMORY[0x1E0C809B0];
                        v366[1] = 3221225472;
                        v366[2] = ___ZL14nw_flow_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke_90;
                        v366[3] = &unk_1E14AC390;
                        v367 = v243;
                        v245 = v243;
                        dispatch_async(v244, v366);

                        v232 = v226;
                      }
                    }
                  }
                  if ((nw_endpoint_handler_get_logging_disabled(v232) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v246 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v246, OS_LOG_TYPE_DEBUG))
                    {
                      v247 = nw_endpoint_handler_get_id_string(v232);
                      v248 = nw_endpoint_handler_dry_run_string(v232);
                      v249 = nw_endpoint_handler_copy_endpoint(v232);
                      v250 = nw_endpoint_get_logging_description(v249);
                      v251 = v232;
                      v252 = nw_endpoint_handler_state_string(v232);
                      v253 = nw_endpoint_handler_mode_string(v251);
                      v254 = nw_endpoint_handler_copy_current_path(v251);
                      v255 = *((_DWORD *)v359 + 248);
                      *(_DWORD *)buf = 136448002;
                      v373 = "nw_flow_notify";
                      v374 = 2082;
                      v375 = (void *)v247;
                      v376 = 2082;
                      v377 = v248;
                      v378 = 2082;
                      v379 = v250;
                      v380 = 2082;
                      v381 = v252;
                      v382 = 2082;
                      v383 = v253;
                      v384 = 2114;
                      v385 = v254;
                      v386 = 1024;
                      LODWORD(v387) = v255;
                      _os_log_impl(&dword_182FBE000, v246, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Clear keepalive state (count = %u)", buf, 0x4Eu);

                    }
                    v13 = v359;
                  }
                  *((_QWORD *)v13 + 123) = 0;
                  *((_DWORD *)v13 + 248) = 0;
                }
              }
              else
              {
                *((_DWORD *)v13 + 248) = 1;
                v216 = mach_continuous_time();
                if (v216 <= 1)
                  v217 = 1;
                else
                  v217 = v216;
                *((_QWORD *)v13 + 123) = v217;
              }
            }
            goto LABEL_45;
          case 5u:
            if (!*((_QWORD *)v13 + 105) || !*((_QWORD *)v13 + 130))
              goto LABEL_45;
            v81 = nw_protocol_definition_create_with_identifier(*(__int128 **)(a2 + 16));
            if (v81)
            {
              v82 = nw_endpoint_flow_copy_protocol_metadata(v14, v13, v81, 1, 0);
              if (v82)
                (*(void (**)(void))(*((_QWORD *)v13 + 130) + 16))();
              v83 = v13;

              goto LABEL_75;
            }
            v83 = v13;
            __nwlog_obj();
            v332 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v373 = "nw_flow_notify";
            v333 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            if (!__nwlog_fault(v333, &type, &v364))
              goto LABEL_288;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v334 = objc_claimAutoreleasedReturnValue();
              v335 = type;
              if (os_log_type_enabled(v334, type))
              {
                *(_DWORD *)buf = 136446210;
                v373 = "nw_flow_notify";
                _os_log_impl(&dword_182FBE000, v334, v335, "%{public}s called with null definition", buf, 0xCu);
              }
            }
            else if (v364)
            {
              v336 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v334 = objc_claimAutoreleasedReturnValue();
              v337 = type;
              v338 = os_log_type_enabled(v334, type);
              if (v336)
              {
                if (v338)
                {
                  *(_DWORD *)buf = 136446466;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = v336;
                  _os_log_impl(&dword_182FBE000, v334, v337, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v336);
LABEL_288:
                if (v333)
                  free(v333);
LABEL_75:

                v13 = v83;
                goto LABEL_45;
              }
              if (v338)
              {
                *(_DWORD *)buf = 136446210;
                v373 = "nw_flow_notify";
                _os_log_impl(&dword_182FBE000, v334, v337, "%{public}s called with null definition, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              __nwlog_obj();
              v334 = objc_claimAutoreleasedReturnValue();
              v339 = type;
              if (os_log_type_enabled(v334, type))
              {
                *(_DWORD *)buf = 136446210;
                v373 = "nw_flow_notify";
                _os_log_impl(&dword_182FBE000, v334, v339, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
              }
            }

            goto LABEL_288;
          case 0xCu:
            v84 = *((char *)v13 + 34);
            if (v84 < 0)
              goto LABEL_45;
            *((_BYTE *)v13 + 34) = v84 | 0x80;
            v85 = 8;
            goto LABEL_98;
          case 0x13u:
            nw_endpoint_flow_rebuild_stack(v14, (nw_protocol *)a2);
            goto LABEL_45;
          case 0x16u:
            if (*((_DWORD *)v13 + 251) <= 0x13u)
            {
              minimize_logging = nw_endpoint_handler_get_minimize_logging(v14);
              logging_disabled = nw_endpoint_handler_get_logging_disabled(v14);
              if (minimize_logging)
              {
                if ((logging_disabled & 1) != 0)
                {
LABEL_97:
                  ++*((_DWORD *)v13 + 251);
                  nw_endpoint_flow_rebuild_stack(v14, (nw_protocol *)a1);
                  v85 = 4;
LABEL_98:
                  v14->event.domain = 3;
                  v14->event.event = v85;
                  nw_endpoint_handler_report(v14, 0, &v14->event.domain, 0);
                  goto LABEL_45;
                }
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v103 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
                {
                  v317 = nw_endpoint_handler_get_id_string(v356);
                  v318 = nw_endpoint_handler_dry_run_string(v356);
                  v319 = nw_endpoint_handler_copy_endpoint(v356);
                  v320 = nw_endpoint_get_logging_description(v319);
                  v321 = nw_endpoint_handler_state_string(v356);
                  v322 = nw_endpoint_handler_mode_string(v356);
                  v323 = nw_endpoint_handler_copy_current_path(v356);
                  v324 = *((_DWORD *)v359 + 251);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v317;
                  v376 = 2082;
                  v377 = v318;
                  v378 = 2082;
                  v379 = v320;
                  v380 = 2082;
                  v381 = v321;
                  v382 = 2082;
                  v383 = v322;
                  v384 = 2114;
                  v385 = v323;
                  v386 = 1024;
                  LODWORD(v387) = v324;
                  _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with count %u, rebuilding stack", buf, 0x4Eu);

                }
              }
              else
              {
                if ((logging_disabled & 1) != 0)
                  goto LABEL_97;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v103 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v103, OS_LOG_TYPE_INFO))
                {
                  v104 = nw_endpoint_handler_get_id_string(v14);
                  v105 = nw_endpoint_handler_dry_run_string(v14);
                  v106 = nw_endpoint_handler_copy_endpoint(v14);
                  v107 = nw_endpoint_get_logging_description(v106);
                  v108 = v14;
                  v109 = nw_endpoint_handler_state_string(v14);
                  v110 = nw_endpoint_handler_mode_string(v108);
                  v111 = nw_endpoint_handler_copy_current_path(v108);
                  v112 = *((_DWORD *)v359 + 251);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v104;
                  v376 = 2082;
                  v377 = v105;
                  v378 = 2082;
                  v379 = v107;
                  v380 = 2082;
                  v381 = v109;
                  v382 = 2082;
                  v383 = v110;
                  v384 = 2114;
                  v385 = v111;
                  v386 = 1024;
                  LODWORD(v387) = v112;
                  _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with count %u, rebuilding stack", buf, 0x4Eu);

                }
              }

              v13 = v359;
              v14 = (NWConcrete_nw_endpoint_handler *)v356;
              goto LABEL_97;
            }
            if ((nw_endpoint_handler_get_logging_disabled(v14) & 1) != 0)
              goto LABEL_240;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v127 = (id)gconnectionLogObj;
            v128 = nw_endpoint_handler_get_id_string(v14);
            v129 = nw_endpoint_handler_dry_run_string(v14);
            v130 = nw_endpoint_handler_copy_endpoint(v14);
            v131 = nw_endpoint_get_logging_description(v130);
            v132 = v14;
            v133 = nw_endpoint_handler_state_string(v14);
            v134 = nw_endpoint_handler_mode_string(v132);
            v135 = nw_endpoint_handler_copy_current_path(v132);
            *(_DWORD *)buf = 136447746;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v128;
            v376 = 2082;
            v377 = v129;
            v378 = 2082;
            v379 = v131;
            v380 = 2082;
            v381 = v133;
            v382 = 2082;
            v383 = v134;
            v384 = 2114;
            v385 = v135;
            v351 = (const char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v136 = (char *)v351;
            if ((__nwlog_fault(v351, &type, &v364) & 1) == 0)
              goto LABEL_238;
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v137 = (id)gconnectionLogObj;
              v138 = type;
              if (os_log_type_enabled(v137, type))
              {
                v139 = nw_endpoint_handler_get_id_string(v356);
                v140 = nw_endpoint_handler_dry_run_string(v356);
                v141 = nw_endpoint_handler_copy_endpoint(v356);
                v142 = nw_endpoint_get_logging_description(v141);
                v143 = nw_endpoint_handler_state_string(v356);
                v144 = nw_endpoint_handler_mode_string(v356);
                v145 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136447746;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v139;
                v376 = 2082;
                v377 = v140;
                v378 = 2082;
                v379 = v142;
                v380 = 2082;
                v381 = v143;
                v382 = 2082;
                v383 = v144;
                v384 = 2114;
                v385 = v145;
                _os_log_impl(&dword_182FBE000, v137, v138, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow", buf, 0x48u);

              }
            }
            else if (v364)
            {
              v190 = __nw_create_backtrace_string();
              if (v190)
              {
                v191 = (char *)v190;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v192 = (id)gconnectionLogObj;
                v193 = type;
                if (os_log_type_enabled(v192, type))
                {
                  v194 = nw_endpoint_handler_get_id_string(v356);
                  v195 = nw_endpoint_handler_dry_run_string(v356);
                  v346 = nw_endpoint_handler_copy_endpoint(v356);
                  v196 = nw_endpoint_get_logging_description(v346);
                  v197 = nw_endpoint_handler_state_string(v356);
                  v198 = nw_endpoint_handler_mode_string(v356);
                  v199 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v194;
                  v376 = 2082;
                  v377 = v195;
                  v378 = 2082;
                  v379 = v196;
                  v380 = 2082;
                  v381 = v197;
                  v382 = 2082;
                  v383 = v198;
                  v384 = 2114;
                  v385 = v199;
                  v386 = 2082;
                  v387 = v191;
                  _os_log_impl(&dword_182FBE000, v192, v193, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow, dumping backtrace:%{public}s", buf, 0x52u);

                }
                free(v191);
                goto LABEL_237;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v137 = (id)gconnectionLogObj;
              v288 = type;
              if (os_log_type_enabled(v137, type))
              {
                v289 = nw_endpoint_handler_get_id_string(v356);
                v290 = nw_endpoint_handler_dry_run_string(v356);
                v291 = nw_endpoint_handler_copy_endpoint(v356);
                v292 = nw_endpoint_get_logging_description(v291);
                v293 = nw_endpoint_handler_state_string(v356);
                v294 = nw_endpoint_handler_mode_string(v356);
                v295 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136447746;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v289;
                v376 = 2082;
                v377 = v290;
                v378 = 2082;
                v379 = v292;
                v380 = 2082;
                v381 = v293;
                v382 = 2082;
                v383 = v294;
                v384 = 2114;
                v385 = v295;
                _os_log_impl(&dword_182FBE000, v137, v288, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow, no backtrace", buf, 0x48u);

              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v137 = (id)gconnectionLogObj;
              v264 = type;
              if (os_log_type_enabled(v137, type))
              {
                v265 = nw_endpoint_handler_get_id_string(v356);
                v266 = nw_endpoint_handler_dry_run_string(v356);
                v267 = nw_endpoint_handler_copy_endpoint(v356);
                v268 = nw_endpoint_get_logging_description(v267);
                v269 = nw_endpoint_handler_state_string(v356);
                v270 = nw_endpoint_handler_mode_string(v356);
                v271 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136447746;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v265;
                v376 = 2082;
                v377 = v266;
                v378 = 2082;
                v379 = v268;
                v380 = 2082;
                v381 = v269;
                v382 = 2082;
                v383 = v270;
                v384 = 2114;
                v385 = v271;
                _os_log_impl(&dword_182FBE000, v137, v264, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow, backtrace limit exceeded", buf, 0x48u);

              }
            }

LABEL_237:
            v136 = (char *)v351;
LABEL_238:
            v13 = v359;
            if (v136)
              free(v136);
LABEL_240:
            nw_protocol_disconnected((_QWORD *)a1, *(_QWORD *)(a1 + 32));
            goto LABEL_45;
          case 0x17u:
            if (a4 && a5 == 1)
            {
              v125 = *a4;
              v126 = *((_BYTE *)v13 + 35);
              *((_BYTE *)v13 + 35) = v126 & 0xEF | (16 * v125);
              if (!v125 && (v126 & 8) != 0)
              {
                *((_BYTE *)v13 + 35) = v126 & 0xE7 | (16 * v125);
                nw_endpoint_flow_start_child(v14);
              }
              goto LABEL_45;
            }
            if ((nw_endpoint_handler_get_logging_disabled(v14) & 1) != 0)
              goto LABEL_45;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v162 = (id)gconnectionLogObj;
            v163 = nw_endpoint_handler_get_id_string(v14);
            v164 = nw_endpoint_handler_dry_run_string(v14);
            v165 = nw_endpoint_handler_copy_endpoint(v14);
            v166 = nw_endpoint_get_logging_description(v165);
            v167 = nw_endpoint_handler_state_string(v14);
            v168 = nw_endpoint_handler_mode_string(v14);
            v169 = nw_endpoint_handler_copy_current_path(v14);
            *(_DWORD *)buf = 136448002;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v163;
            v376 = 2082;
            v377 = v164;
            v378 = 2082;
            v379 = v166;
            v380 = 2082;
            v381 = v167;
            v382 = 2082;
            v383 = v168;
            v384 = 2114;
            v385 = v169;
            v386 = 2080;
            v387 = "delay_child";
            v70 = (const char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v71 = (char *)v70;
            if ((__nwlog_fault(v70, &type, &v364) & 1) == 0)
              goto LABEL_252;
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v170 = type;
              if (os_log_type_enabled(v72, type))
              {
                v171 = nw_endpoint_handler_get_id_string(v356);
                v172 = nw_endpoint_handler_dry_run_string(v356);
                v173 = nw_endpoint_handler_copy_endpoint(v356);
                v174 = nw_endpoint_get_logging_description(v173);
                v175 = nw_endpoint_handler_state_string(v356);
                v176 = nw_endpoint_handler_mode_string(v356);
                v177 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v171;
                v376 = 2082;
                v377 = v172;
                v378 = 2082;
                v379 = v174;
                v380 = 2082;
                v381 = v175;
                v382 = 2082;
                v383 = v176;
                v384 = 2114;
                v385 = v177;
                v386 = 2080;
                v387 = "delay_child";
                _os_log_impl(&dword_182FBE000, v72, v170, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification", buf, 0x52u);

              }
              goto LABEL_250;
            }
            if (v364)
            {
              v208 = __nw_create_backtrace_string();
              if (v208)
              {
                v179 = (char *)v208;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v180 = (id)gconnectionLogObj;
                v209 = type;
                if (os_log_type_enabled(v180, type))
                {
                  v210 = nw_endpoint_handler_get_id_string(v356);
                  v211 = nw_endpoint_handler_dry_run_string(v356);
                  v354 = nw_endpoint_handler_copy_endpoint(v356);
                  v212 = nw_endpoint_get_logging_description(v354);
                  v213 = nw_endpoint_handler_state_string(v356);
                  v214 = nw_endpoint_handler_mode_string(v356);
                  v215 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448258;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v210;
                  v376 = 2082;
                  v377 = v211;
                  v378 = 2082;
                  v379 = v212;
                  v380 = 2082;
                  v381 = v213;
                  v382 = 2082;
                  v383 = v214;
                  v384 = 2114;
                  v385 = v215;
                  v386 = 2080;
                  v387 = "delay_child";
                  v388 = 2082;
                  v389 = v179;
                  _os_log_impl(&dword_182FBE000, v180, v209, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification, dumping backtrace:%{public}s", buf, 0x5Cu);

                }
                goto LABEL_175;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v304 = type;
              if (os_log_type_enabled(v72, type))
              {
                v305 = nw_endpoint_handler_get_id_string(v356);
                v306 = nw_endpoint_handler_dry_run_string(v356);
                v307 = nw_endpoint_handler_copy_endpoint(v356);
                v308 = nw_endpoint_get_logging_description(v307);
                v309 = nw_endpoint_handler_state_string(v356);
                v310 = nw_endpoint_handler_mode_string(v356);
                v311 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v305;
                v376 = 2082;
                v377 = v306;
                v378 = 2082;
                v379 = v308;
                v380 = 2082;
                v381 = v309;
                v382 = 2082;
                v383 = v310;
                v384 = 2114;
                v385 = v311;
                v386 = 2080;
                v387 = "delay_child";
                _os_log_impl(&dword_182FBE000, v72, v304, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification, no backtrace", buf, 0x52u);

              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v280 = type;
              if (os_log_type_enabled(v72, type))
              {
                v281 = nw_endpoint_handler_get_id_string(v356);
                v282 = nw_endpoint_handler_dry_run_string(v356);
                v283 = nw_endpoint_handler_copy_endpoint(v356);
                v284 = nw_endpoint_get_logging_description(v283);
                v285 = nw_endpoint_handler_state_string(v356);
                v286 = nw_endpoint_handler_mode_string(v356);
                v287 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v281;
                v376 = 2082;
                v377 = v282;
                v378 = 2082;
                v379 = v284;
                v380 = 2082;
                v381 = v285;
                v382 = 2082;
                v383 = v286;
                v384 = 2114;
                v385 = v287;
                v386 = 2080;
                v387 = "delay_child";
                _os_log_impl(&dword_182FBE000, v72, v280, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification, backtrace limit exceeded", buf, 0x52u);

              }
            }
            goto LABEL_250;
          case 0x18u:
            if (a5 == 8)
            {
              v350 = a4;
              v113 = nw_endpoint_handler_get_minimize_logging(v14);
              v114 = nw_endpoint_handler_get_logging_disabled(v14);
              if (v113)
              {
                if ((v114 & 1) != 0)
                  goto LABEL_150;
                v123 = v14;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v115 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v115, OS_LOG_TYPE_DEBUG))
                {
                  v325 = nw_endpoint_handler_get_id_string(v14);
                  v326 = nw_endpoint_handler_dry_run_string(v14);
                  v327 = nw_endpoint_handler_copy_endpoint(v14);
                  v328 = nw_endpoint_get_logging_description(v327);
                  v329 = nw_endpoint_handler_state_string(v14);
                  v330 = nw_endpoint_handler_mode_string(v123);
                  v331 = nw_endpoint_handler_copy_current_path(v123);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v325;
                  v376 = 2082;
                  v377 = v326;
                  v378 = 2082;
                  v379 = v328;
                  v380 = 2082;
                  v381 = v329;
                  v382 = 2082;
                  v383 = v330;
                  v384 = 2114;
                  v385 = v331;
                  v386 = 2112;
                  v387 = (const char *)v350;
                  _os_log_impl(&dword_182FBE000, v115, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received migration interface %@", buf, 0x52u);

                }
              }
              else
              {
                if ((v114 & 1) != 0)
                {
LABEL_150:
                  v188 = (void *)*((_QWORD *)v13 + 104);
                  if (v188)
                  {
                    v189 = nw_path_flow_registration_copy_path(v188);
                    os_unfair_lock_lock((os_unfair_lock_t)v13 + 220);
                    objc_storeStrong((id *)v13 + 2, (id)v189);
                    if ((*((_BYTE *)v13 + 33) & 4) != 0)
                      objc_storeStrong((id *)v13 + 1, (id)v189);
                    os_unfair_lock_unlock((os_unfair_lock_t)v13 + 220);

                  }
                  nw_endpoint_handler_migration_callback(v14, v350);

                  goto LABEL_44;
                }
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v115 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v115, OS_LOG_TYPE_INFO))
                {
                  v116 = nw_endpoint_handler_get_id_string(v14);
                  v117 = nw_endpoint_handler_dry_run_string(v14);
                  v118 = nw_endpoint_handler_copy_endpoint(v14);
                  v119 = nw_endpoint_get_logging_description(v118);
                  v120 = v14;
                  v121 = nw_endpoint_handler_state_string(v14);
                  v122 = nw_endpoint_handler_mode_string(v120);
                  v123 = v120;
                  v124 = nw_endpoint_handler_copy_current_path(v120);
                  *(_DWORD *)buf = 136448002;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v116;
                  v376 = 2082;
                  v377 = v117;
                  v378 = 2082;
                  v379 = v119;
                  v380 = 2082;
                  v381 = v121;
                  v382 = 2082;
                  v383 = v122;
                  v384 = 2114;
                  v385 = v124;
                  v386 = 2112;
                  v387 = (const char *)v350;
                  _os_log_impl(&dword_182FBE000, v115, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received migration interface %@", buf, 0x52u);

                }
                else
                {
                  v123 = v14;
                }
              }

              v13 = v359;
              v14 = v123;
              goto LABEL_150;
            }
            if ((nw_endpoint_handler_get_logging_disabled(v14) & 1) != 0)
              goto LABEL_45;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v146 = (id)gconnectionLogObj;
            v147 = nw_endpoint_handler_get_id_string(v14);
            v148 = nw_endpoint_handler_dry_run_string(v14);
            v149 = nw_endpoint_handler_copy_endpoint(v14);
            v150 = nw_endpoint_get_logging_description(v149);
            v151 = nw_endpoint_handler_state_string(v14);
            v152 = nw_endpoint_handler_mode_string(v14);
            v153 = nw_endpoint_handler_copy_current_path(v14);
            *(_DWORD *)buf = 136448002;
            v373 = "nw_flow_notify";
            v374 = 2082;
            v375 = (void *)v147;
            v376 = 2082;
            v377 = v148;
            v378 = 2082;
            v379 = v150;
            v380 = 2082;
            v381 = v151;
            v382 = 2082;
            v383 = v152;
            v384 = 2114;
            v385 = v153;
            v386 = 2080;
            v387 = "migration";
            v70 = (const char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v364 = 0;
            v71 = (char *)v70;
            if ((__nwlog_fault(v70, &type, &v364) & 1) == 0)
              goto LABEL_252;
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v154 = type;
              if (os_log_type_enabled(v72, type))
              {
                v155 = nw_endpoint_handler_get_id_string(v356);
                v156 = nw_endpoint_handler_dry_run_string(v356);
                v157 = nw_endpoint_handler_copy_endpoint(v356);
                v158 = nw_endpoint_get_logging_description(v157);
                v159 = nw_endpoint_handler_state_string(v356);
                v160 = nw_endpoint_handler_mode_string(v356);
                v161 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v155;
                v376 = 2082;
                v377 = v156;
                v378 = 2082;
                v379 = v158;
                v380 = 2082;
                v381 = v159;
                v382 = 2082;
                v383 = v160;
                v384 = 2114;
                v385 = v161;
                v386 = 2080;
                v387 = "migration";
                _os_log_impl(&dword_182FBE000, v72, v154, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification", buf, 0x52u);

              }
            }
            else if (v364)
            {
              v200 = __nw_create_backtrace_string();
              if (v200)
              {
                v179 = (char *)v200;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v180 = (id)gconnectionLogObj;
                v201 = type;
                if (os_log_type_enabled(v180, type))
                {
                  v202 = nw_endpoint_handler_get_id_string(v356);
                  v203 = nw_endpoint_handler_dry_run_string(v356);
                  v353 = nw_endpoint_handler_copy_endpoint(v356);
                  v204 = nw_endpoint_get_logging_description(v353);
                  v205 = nw_endpoint_handler_state_string(v356);
                  v206 = nw_endpoint_handler_mode_string(v356);
                  v207 = nw_endpoint_handler_copy_current_path(v356);
                  *(_DWORD *)buf = 136448258;
                  v373 = "nw_flow_notify";
                  v374 = 2082;
                  v375 = (void *)v202;
                  v376 = 2082;
                  v377 = v203;
                  v378 = 2082;
                  v379 = v204;
                  v380 = 2082;
                  v381 = v205;
                  v382 = 2082;
                  v383 = v206;
                  v384 = 2114;
                  v385 = v207;
                  v386 = 2080;
                  v387 = "migration";
                  v388 = 2082;
                  v389 = v179;
                  _os_log_impl(&dword_182FBE000, v180, v201, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification, dumping backtrace:%{public}s", buf, 0x5Cu);

                }
LABEL_175:

                free(v179);
                goto LABEL_251;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v296 = type;
              if (os_log_type_enabled(v72, type))
              {
                v297 = nw_endpoint_handler_get_id_string(v356);
                v298 = nw_endpoint_handler_dry_run_string(v356);
                v299 = nw_endpoint_handler_copy_endpoint(v356);
                v300 = nw_endpoint_get_logging_description(v299);
                v301 = nw_endpoint_handler_state_string(v356);
                v302 = nw_endpoint_handler_mode_string(v356);
                v303 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v297;
                v376 = 2082;
                v377 = v298;
                v378 = 2082;
                v379 = v300;
                v380 = 2082;
                v381 = v301;
                v382 = 2082;
                v383 = v302;
                v384 = 2114;
                v385 = v303;
                v386 = 2080;
                v387 = "migration";
                _os_log_impl(&dword_182FBE000, v72, v296, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification, no backtrace", buf, 0x52u);

              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v72 = (id)gconnectionLogObj;
              v272 = type;
              if (os_log_type_enabled(v72, type))
              {
                v273 = nw_endpoint_handler_get_id_string(v356);
                v274 = nw_endpoint_handler_dry_run_string(v356);
                v275 = nw_endpoint_handler_copy_endpoint(v356);
                v276 = nw_endpoint_get_logging_description(v275);
                v277 = nw_endpoint_handler_state_string(v356);
                v278 = nw_endpoint_handler_mode_string(v356);
                v279 = nw_endpoint_handler_copy_current_path(v356);
                *(_DWORD *)buf = 136448002;
                v373 = "nw_flow_notify";
                v374 = 2082;
                v375 = (void *)v273;
                v376 = 2082;
                v377 = v274;
                v378 = 2082;
                v379 = v276;
                v380 = 2082;
                v381 = v277;
                v382 = 2082;
                v383 = v278;
                v384 = 2114;
                v385 = v279;
                v386 = 2080;
                v387 = "migration";
                _os_log_impl(&dword_182FBE000, v72, v272, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Invalid argument passed to %s notification, backtrace limit exceeded", buf, 0x52u);

              }
            }
LABEL_250:

LABEL_251:
            v71 = (char *)v70;
LABEL_252:
            v13 = v359;
            if (v71)
              free(v71);
            goto LABEL_45;
          case 0x19u:
            v361[0] = MEMORY[0x1E0C809B0];
            v361[1] = 3221225472;
            v361[2] = ___ZL14nw_flow_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke_91;
            v361[3] = &unk_1E149C8D8;
            v363 = a1;
            v362 = v14;
            nw_endpoint_handler_access_parent_flow_handler(v362, v361);

            goto LABEL_44;
          default:
            goto LABEL_45;
        }
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v34 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
      {
        v35 = v32;

        v36 = v35;
        v37 = *((_BYTE *)v32 + 268);

        v38 = "dry-run ";
        if ((v37 & 1) == 0)
          v38 = "";
        v349 = v38;
        v39 = nw_endpoint_handler_copy_endpoint(v36);
        v345 = nw_endpoint_get_logging_description(v39);
        v40 = v36;
        v41 = v40;
        v42 = v356[30];
        log = v34;
        if (v42 > 5)
          v43 = "unknown-state";
        else
          v43 = off_1E149FC48[v42];
        v343 = v43;
        v340 = v39;
        v48 = v35->id_str;

        v49 = v41;
        v50 = v49;
        v51 = "path";
        switch(v358->mode)
        {
          case 0:
            break;
          case 1:
            v51 = "resolver";
            break;
          case 2:
            v51 = nw_endpoint_flow_mode_string(v49[31]);
            break;
          case 3:
            v51 = "proxy";
            break;
          case 4:
            v51 = "fallback";
            break;
          case 5:
            v51 = "transform";
            break;
          default:
            v51 = "unknown-mode";
            break;
        }

        v57 = v50;
        os_unfair_lock_lock((os_unfair_lock_t)v57 + 28);
        v58 = v57[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v57 + 28);

        v59 = v58;
        v60 = v59;
        if (a3 > 0x19)
          v61 = "unknown";
        else
          v61 = off_1E14A22C8[a3];
        *(_DWORD *)buf = 136448002;
        v373 = "nw_flow_notify";
        v374 = 2082;
        v375 = v48;
        v376 = 2082;
        v377 = v349;
        v378 = 2082;
        v379 = v345;
        v380 = 2082;
        v381 = v343;
        v382 = 2082;
        v383 = v51;
        v384 = 2114;
        v385 = v59;
        v386 = 2082;
        v387 = v61;
        v34 = log;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received notification %{public}s", buf, 0x52u);

      }
    }

    v13 = v359;
    v14 = (NWConcrete_nw_endpoint_handler *)v356;
    goto LABEL_57;
  }
LABEL_46:

}

void sub_1831F2EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,void *a23)
{
  void *v23;
  void *v24;

  _Unwind_Resume(a1);
}

uint64_t sub_1831F31D8(uint64_t a1)
{
  return sub_183083E70(a1, (NSObject **)&_nw_content_context_default_message, &qword_1EDCD7B20);
}

void nw_path_flow_registration_set_ecn_cache(void *a1, void *a2, uint64_t a3)
{
  void **v5;
  id v6;
  void *v7;
  id v8;
  int v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  void *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  os_log_type_t v24;
  void *v25;
  os_log_type_t v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  os_log_type_t v34;
  os_log_type_t v35;
  char v36;
  os_log_type_t v37[8];
  uint64_t v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  _WORD v43[17];

  *(_QWORD *)&v43[13] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_path_flow_registration_set_ecn_cache";
    v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type))
      goto LABEL_28;
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v33 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v33, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    v27 = v37[0];
    v28 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_path_flow_registration_set_ecn_cache";
      v42 = 2082;
      *(_QWORD *)v43 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_60;
  }
  if (!v6)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_path_flow_registration_set_ecn_cache";
    v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type))
      goto LABEL_28;
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v24 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null flow_registration", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v34 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v34, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    v29 = v37[0];
    v30 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_path_flow_registration_set_ecn_cache";
      v42 = 2082;
      *(_QWORD *)v43 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_60;
  }
  if (!a3)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_path_flow_registration_set_ecn_cache";
    v13 = (char *)_os_log_send_and_compose_impl();

    v37[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v13, v37, &type))
      goto LABEL_28;
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v26 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null ecn_cache_buffer", buf, 0xCu);
      }
LABEL_78:

LABEL_28:
      if (!v13)
        goto LABEL_30;
LABEL_29:
      free(v13);
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v35 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v35, "%{public}s called with null ecn_cache_buffer, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    v31 = v37[0];
    v32 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl(&dword_182FBE000, v21, v31, "%{public}s called with null ecn_cache_buffer, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_path_flow_registration_set_ecn_cache";
      v42 = 2082;
      *(_QWORD *)v43 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v21, v31, "%{public}s called with null ecn_cache_buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_60:

    goto LABEL_20;
  }
  *(_QWORD *)v37 = 0;
  v8 = nw_parameters_copy_context(v5[2]);
  v9 = nw_path_shared_necp_fd(v8);

  if (v9 < 0)
    goto LABEL_30;
  *(_WORD *)v37 = 257;
  v38 = a3;
  *(_DWORD *)&v37[4] = 1;
  if (!necp_client_action())
    goto LABEL_30;
  v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v11 = (id)gLogObj;
  v12 = v11;
  if (v10 != 2)
  {
    *(_DWORD *)buf = 136446466;
    v41 = "nw_path_flow_registration_set_ecn_cache";
    v42 = 1024;
    *(_DWORD *)v43 = v10;
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36))
      goto LABEL_28;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (id)gLogObj;
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        v42 = 1024;
        *(_DWORD *)v43 = v10;
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s necp update cache failed for ecn %{darwin.errno}d", buf, 0x12u);
      }
LABEL_27:

      goto LABEL_28;
    }
    if (!v36)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (id)gLogObj;
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        v42 = 1024;
        *(_DWORD *)v43 = v10;
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s necp update cache failed for ecn %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_27;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    v17 = type;
    v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_path_flow_registration_set_ecn_cache";
        v42 = 1024;
        *(_DWORD *)v43 = v10;
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s necp update cache failed for ecn %{darwin.errno}d, no backtrace", buf, 0x12u);
      }
      goto LABEL_27;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446722;
      v41 = "nw_path_flow_registration_set_ecn_cache";
      v42 = 1024;
      *(_DWORD *)v43 = v10;
      v43[2] = 2082;
      *(_QWORD *)&v43[3] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s necp update cache failed for ecn %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

LABEL_20:
    free(backtrace_string);
    if (!v13)
      goto LABEL_30;
    goto LABEL_29;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v41 = "nw_path_flow_registration_set_ecn_cache";
    v42 = 1024;
    *(_DWORD *)v43 = 2;
    _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s necp update cache failed for ecn %{darwin.errno}d", buf, 0x12u);
  }

LABEL_30:
}

void sub_1831F3BCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_connection_unregister_context(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  _QWORD v20[4];
  id v21;
  id v22;
  char v23;
  os_log_type_t v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_connection_unregister_context";
    v7 = (char *)_os_log_send_and_compose_impl();

    v24 = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &v24, &v23))
      goto LABEL_38;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v24;
      v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_connection_unregister_context";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_unregister_context";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __nw_connection_unregister_context_block_invoke;
    v20[3] = &unk_1E14ACE68;
    v21 = v3;
    v22 = v5;
    nw_connection_async_if_needed(v21, v20);

    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_connection_unregister_context";
  v7 = (char *)_os_log_send_and_compose_impl();

  v24 = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v7, &v24, &v23))
    goto LABEL_38;
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_connection_unregister_context";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null content_context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_connection_unregister_context";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null content_context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = v24;
  v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_connection_unregister_context";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null content_context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_connection_unregister_context";
    v27 = 2082;
    v28 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null content_context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

void sub_1831F40FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void nw_endpoint_handler_unregister_context(void *a1, void *a2)
{
  id v3;
  id v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t node;
  uint64_t v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  NWConcrete_nw_endpoint_handler *v16;
  char v17;
  NSObject *v18;
  const char *id_string;
  const char *v20;
  const char *v21;
  id v22;
  id v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  uint64_t v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  const char *v33;
  NWConcrete_nw_endpoint_handler *v34;
  char v35;
  NSObject *v36;
  NWConcrete_nw_endpoint_handler *v37;
  NWConcrete_nw_endpoint_handler *v38;
  char v39;
  const char *v40;
  nw_endpoint_t v41;
  const char *logging_description;
  unsigned int *v43;
  unsigned int *v44;
  uint64_t v45;
  const char *v46;
  os_log_type_t v47;
  const char *v48;
  NWConcrete_nw_endpoint_handler *v49;
  char v50;
  NWConcrete_nw_endpoint_handler *v51;
  NWConcrete_nw_endpoint_handler *v52;
  char v53;
  const char *v54;
  nw_endpoint_t v55;
  const char *v56;
  unsigned int *v57;
  unsigned int *v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  NWConcrete_nw_endpoint_handler *v62;
  char v63;
  NSObject *v64;
  const char *v65;
  const char *v66;
  const char *v67;
  id v68;
  void **v69;
  void **v70;
  int v71;
  const char *v72;
  void **v73;
  void **v74;
  int v75;
  const char *v76;
  void **v77;
  id v78;
  void **v79;
  id v80;
  void *v81;
  os_log_type_t v82;
  char *backtrace_string;
  os_log_type_t v84;
  _BOOL4 v85;
  os_log_type_t v86;
  const char *v87;
  const char *v88;
  const char *v89;
  const char *v90;
  const char *v91;
  const char *v92;
  const char *v93;
  char *id_str;
  char *v95;
  const char *v96;
  nw_endpoint_t v97;
  nw_endpoint_t v98;
  char v99;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v102;
  __int16 v103;
  void *v104;
  __int16 v105;
  const char *v106;
  __int16 v107;
  void *v108;
  __int16 v109;
  const char *v110;
  __int16 v111;
  const char *v112;
  __int16 v113;
  id v114;
  __int16 v115;
  uint64_t v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    v81 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v102 = "nw_endpoint_handler_unregister_context";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (!__nwlog_fault(v25, &type, &v99))
      goto LABEL_80;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v82 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_endpoint_handler_unregister_context";
        _os_log_impl(&dword_182FBE000, v26, v82, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v99)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v84 = type;
      v85 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v85)
        {
          *(_DWORD *)buf = 136446466;
          v102 = "nw_endpoint_handler_unregister_context";
          v103 = 2082;
          v104 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v84, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_80;
      }
      if (v85)
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_endpoint_handler_unregister_context";
        _os_log_impl(&dword_182FBE000, v26, v84, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v86 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v102 = "nw_endpoint_handler_unregister_context";
        _os_log_impl(&dword_182FBE000, v26, v86, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_79:

    goto LABEL_80;
  }
  v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    v7 = nw_endpoint_handler_copy_flow(v5);
    v8 = (uint64_t *)v7;
    if ((*((_BYTE *)v7 + 35) & 2) != 0)
    {
      v29 = *((_QWORD *)v7 + 117);
      if (v29)
      {
        nw_endpoint_handler_unregister_context(v29, v4);
      }
      else
      {
        v34 = v5;
        v35 = *((_BYTE *)v34 + 268);

        if ((v35 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v36 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            v37 = v34;

            v38 = v37;
            v39 = *((_BYTE *)v34 + 268);

            if ((v39 & 1) != 0)
              v40 = "dry-run ";
            else
              v40 = "";
            v41 = nw_endpoint_handler_copy_endpoint(v38);
            logging_description = nw_endpoint_get_logging_description(v41);
            id_str = v37->id_str;
            v43 = v38;
            v44 = v43;
            v45 = v43[30];
            if (v45 > 5)
              v46 = "unknown-state";
            else
              v46 = off_1E149FC48[v45];
            v91 = v46;

            v69 = v44;
            v70 = v69;
            v71 = v5->mode;
            v72 = "path";
            switch(v71)
            {
              case 0:
                break;
              case 1:
                v72 = "resolver";
                break;
              case 2:
                v72 = nw_endpoint_flow_mode_string(v69[31]);
                break;
              case 3:
                v72 = "proxy";
                break;
              case 4:
                v72 = "fallback";
                break;
              case 5:
                v72 = "transform";
                break;
              default:
                v72 = "unknown-mode";
                break;
            }

            v77 = v70;
            os_unfair_lock_lock((os_unfair_lock_t)v77 + 28);
            v78 = v77[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v77 + 28);

            *(_DWORD *)buf = 136447746;
            v102 = "nw_endpoint_handler_unregister_context";
            v103 = 2082;
            v104 = id_str;
            v105 = 2082;
            v106 = v40;
            v107 = 2082;
            v108 = (void *)logging_description;
            v109 = 2082;
            v110 = v91;
            v111 = 2082;
            v112 = v72;
            v113 = 2114;
            v114 = v78;
            _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot unregister, no connected handler", buf, 0x48u);

          }
          goto LABEL_97;
        }
      }
    }
    else if (*((_QWORD *)v7 + 96))
    {
      v9 = *((_QWORD *)v7 + 108);
      if (v9)
      {
        node = nw_hash_table_get_node(v9, (uint64_t)v4, 0);
        if (node)
        {
          v11 = node;
          v12 = *(_QWORD *)(node + 16);
          v13 = *(_WORD *)(v12 + 332);
          *(_WORD *)(v12 + 332) = v13 | 0x100;
          if ((v13 & 0x200) == 0
            && (v14 = *(_QWORD *)(v12 + 32)) != 0
            && (v15 = *(_QWORD *)(v14 + 24)) != 0
            && *(_QWORD *)(v15 + 32))
          {
            v16 = v5;
            v17 = *((_BYTE *)v16 + 268);

            if ((v17 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v18 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
              {
                id_string = nw_endpoint_handler_get_id_string(v16);
                v89 = nw_endpoint_handler_dry_run_string(v16);
                v93 = id_string;
                v97 = nw_endpoint_handler_copy_endpoint(v16);
                v87 = nw_endpoint_get_logging_description(v97);
                v20 = nw_endpoint_handler_state_string(v16);
                v21 = nw_endpoint_handler_mode_string(v16);
                v22 = nw_endpoint_handler_copy_current_path(v16);
                *(_DWORD *)buf = 136448002;
                v102 = "nw_endpoint_handler_unregister_context";
                v103 = 2082;
                v104 = (void *)v93;
                v105 = 2082;
                v106 = v89;
                v107 = 2082;
                v108 = (void *)v87;
                v109 = 2082;
                v110 = v20;
                v111 = 2082;
                v112 = v21;
                v113 = 2114;
                v114 = v22;
                v115 = 2048;
                v116 = v12;
                _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Unregistering protocol %p by disconnecting", buf, 0x52u);

              }
            }
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v14 + 24) + 32))(v14, v12);
          }
          else
          {
            v62 = v5;
            v63 = *((_BYTE *)v62 + 268);

            if ((v63 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v64 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
              {
                v65 = nw_endpoint_handler_get_id_string(v62);
                v90 = nw_endpoint_handler_dry_run_string(v62);
                v96 = v65;
                v98 = nw_endpoint_handler_copy_endpoint(v62);
                v88 = nw_endpoint_get_logging_description(v98);
                v66 = nw_endpoint_handler_state_string(v62);
                v67 = nw_endpoint_handler_mode_string(v62);
                v68 = nw_endpoint_handler_copy_current_path(v62);
                *(_DWORD *)buf = 136448002;
                v102 = "nw_endpoint_handler_unregister_context";
                v103 = 2082;
                v104 = (void *)v96;
                v105 = 2082;
                v106 = v90;
                v107 = 2082;
                v108 = (void *)v88;
                v109 = 2082;
                v110 = v66;
                v111 = 2082;
                v112 = v67;
                v113 = 2114;
                v114 = v68;
                v115 = 2048;
                v116 = v12;
                _os_log_impl(&dword_182FBE000, v64, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Unregistering protocol %p immediately", buf, 0x52u);

              }
            }
            nw_hash_table_remove_node(v8[108], v11);
          }
        }
        goto LABEL_98;
      }
      v49 = v5;
      v50 = *((_BYTE *)v49 + 268);

      if ((v50 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v36 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          v51 = v49;

          v52 = v51;
          v53 = *((_BYTE *)v49 + 268);

          if ((v53 & 1) != 0)
            v54 = "dry-run ";
          else
            v54 = "";
          v55 = nw_endpoint_handler_copy_endpoint(v52);
          v56 = nw_endpoint_get_logging_description(v55);
          v95 = v51->id_str;
          v57 = v52;
          v58 = v57;
          v59 = v57[30];
          if (v59 > 5)
            v60 = "unknown-state";
          else
            v60 = off_1E149FC48[v59];
          v92 = v60;

          v73 = v58;
          v74 = v73;
          v75 = v5->mode;
          v76 = "path";
          switch(v75)
          {
            case 0:
              break;
            case 1:
              v76 = "resolver";
              break;
            case 2:
              v76 = nw_endpoint_flow_mode_string(v73[31]);
              break;
            case 3:
              v76 = "proxy";
              break;
            case 4:
              v76 = "fallback";
              break;
            case 5:
              v76 = "transform";
              break;
            default:
              v76 = "unknown-mode";
              break;
          }

          v79 = v74;
          os_unfair_lock_lock((os_unfair_lock_t)v79 + 28);
          v80 = v79[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v79 + 28);

          *(_DWORD *)buf = 136447746;
          v102 = "nw_endpoint_handler_unregister_context";
          v103 = 2082;
          v104 = v95;
          v105 = 2082;
          v106 = v54;
          v107 = 2082;
          v108 = (void *)v56;
          v109 = 2082;
          v110 = v92;
          v111 = 2082;
          v112 = v76;
          v113 = 2114;
          v114 = v80;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot unregister after flow table is released", buf, 0x48u);

        }
LABEL_97:

      }
    }
LABEL_98:

    goto LABEL_99;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v23 = (id)gLogObj;
  if (mode > 5)
    v24 = "unknown-mode";
  else
    v24 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  v102 = "nw_endpoint_handler_unregister_context";
  v103 = 2082;
  v104 = (void *)v24;
  v105 = 2082;
  v106 = "flow";
  v25 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v99 = 0;
  if (__nwlog_fault(v25, &type, &v99))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = (id)gLogObj;
      v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        if (mode > 5)
          v28 = "unknown-mode";
        else
          v28 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v102 = "nw_endpoint_handler_unregister_context";
        v103 = 2082;
        v104 = (void *)v28;
        v105 = 2082;
        v106 = "flow";
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if (v99)
    {
      v30 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = (id)gLogObj;
      v31 = type;
      v32 = os_log_type_enabled(v26, type);
      if (v30)
      {
        if (v32)
        {
          if (mode > 5)
            v33 = "unknown-mode";
          else
            v33 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446978;
          v102 = "nw_endpoint_handler_unregister_context";
          v103 = 2082;
          v104 = (void *)v33;
          v105 = 2082;
          v106 = "flow";
          v107 = 2082;
          v108 = v30;
          _os_log_impl(&dword_182FBE000, v26, v31, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v30);
        if (v25)
          goto LABEL_81;
        goto LABEL_99;
      }
      if (v32)
      {
        if (mode > 5)
          v61 = "unknown-mode";
        else
          v61 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v102 = "nw_endpoint_handler_unregister_context";
        v103 = 2082;
        v104 = (void *)v61;
        v105 = 2082;
        v106 = "flow";
        _os_log_impl(&dword_182FBE000, v26, v31, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = (id)gLogObj;
      v47 = type;
      if (os_log_type_enabled(v26, type))
      {
        if (mode > 5)
          v48 = "unknown-mode";
        else
          v48 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v102 = "nw_endpoint_handler_unregister_context";
        v103 = 2082;
        v104 = (void *)v48;
        v105 = 2082;
        v106 = "flow";
        _os_log_impl(&dword_182FBE000, v26, v47, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
    goto LABEL_79;
  }
LABEL_80:
  if (v25)
LABEL_81:
    free(v25);
LABEL_99:

}

void sub_1831F4EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void __nw_connection_unregister_context_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    nw_endpoint_handler_unregister_context(*(void **)(v2 + 144), *(void **)(a1 + 40));
  }
  else
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        v6 = 136446466;
        v7 = "nw_connection_unregister_context_block_invoke";
        v8 = 1024;
        v9 = v5;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Cannot unregister a context on a connection that is not ready", (uint8_t *)&v6, 0x12u);
      }

    }
  }
}

void ___ZL45nw_activity_should_use_elevated_sampling_ratev_block_invoke()
{
  int v0;
  int v1;
  int v2;
  id v3;
  void *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  NSObject *v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  _BYTE v19[10];
  __int16 v20;
  char *v21;
  utsname v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (os_variant_has_internal_diagnostics())
  {
    bzero(&v22, 0x500uLL);
    v0 = uname(&v22);
    if (v0)
    {
      v1 = v0;
      v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = (id)gLogObj;
      *(_DWORD *)buf = 136446722;
      v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
      v18 = 1024;
      *(_DWORD *)v19 = v1;
      *(_WORD *)&v19[4] = 1024;
      *(_DWORD *)&v19[6] = v2;
      v4 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v14 = 0;
      if (__nwlog_fault((const char *)v4, &type, &v14))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v5 = (id)gLogObj;
          v6 = type;
          if (!os_log_type_enabled(v5, type))
            goto LABEL_25;
          *(_DWORD *)buf = 136446722;
          v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          v18 = 1024;
          *(_DWORD *)v19 = v1;
          *(_WORD *)&v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          v7 = "%{public}s uname failed (%d) %{darwin.errno}d";
LABEL_23:
          v12 = v5;
          v13 = v6;
          goto LABEL_24;
        }
        if (!v14)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v5 = (id)gLogObj;
          v6 = type;
          if (!os_log_type_enabled(v5, type))
            goto LABEL_25;
          *(_DWORD *)buf = 136446722;
          v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          v18 = 1024;
          *(_DWORD *)v19 = v1;
          *(_WORD *)&v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          v7 = "%{public}s uname failed (%d) %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_23;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        v10 = type;
        v11 = os_log_type_enabled(v5, type);
        if (!backtrace_string)
        {
          if (!v11)
          {
LABEL_25:

            if (!v4)
              return;
LABEL_19:
            free(v4);
            return;
          }
          *(_DWORD *)buf = 136446722;
          v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          v18 = 1024;
          *(_DWORD *)v19 = v1;
          *(_WORD *)&v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          v7 = "%{public}s uname failed (%d) %{darwin.errno}d, no backtrace";
          v12 = v5;
          v13 = v10;
LABEL_24:
          _os_log_impl(&dword_182FBE000, v12, v13, v7, buf, 0x18u);
          goto LABEL_25;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446978;
          v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
          v18 = 1024;
          *(_DWORD *)v19 = v1;
          *(_WORD *)&v19[4] = 1024;
          *(_DWORD *)&v19[6] = v2;
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s uname failed (%d) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(backtrace_string);
      }
      if (!v4)
        return;
      goto LABEL_19;
    }
    if (gLogDatapath)
    {
      if (__nwlog_activity_log::onceToken != -1)
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
      v8 = (id)gactivityLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v17 = "nw_activity_should_use_elevated_sampling_rate_block_invoke";
        v18 = 2080;
        *(_QWORD *)v19 = v22.machine;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s Device: %s", buf, 0x16u);
      }

    }
  }
}

void ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_5(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t, _QWORD);
  uint64_t v9;
  _QWORD *v10;
  const char *v11;
  int v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  char *v18;
  _BOOL4 v19;
  const char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  const char *v28;
  const char *v29;
  NSObject *v30;
  os_log_type_t v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *backtrace_string;
  _BOOL4 v36;
  NSObject *v37;
  os_log_type_t v38;
  NSObject *v39;
  os_log_type_t v40;
  os_log_type_t v41;
  os_log_t log;
  NSObject *loga;
  os_log_t logb;
  os_log_t logc;
  os_log_t logd;
  char *v47;
  char *v48;
  char v49;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  _QWORD v56[5];

  v56[3] = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 136))
  {
    if (*(_QWORD *)(v1 + 216))
    {
      v2 = *(_QWORD *)(v1 + 384);
      if (v2)
      {
        while (1)
        {
          if (!*(_QWORD *)(v1 + 136) || !*(_QWORD *)(v1 + 216))
            return;
          v3 = v2;
          v2 = *(_QWORD *)(v2 + 56);
          v4 = *(_QWORD *)(v3 + 24);
          v5 = os_channel_flow_admissible();
          if (!v5)
            break;
          v12 = v5;
          if (v5 != 55)
          {
            if (v5 == 2)
            {
              if (gLogDatapath)
              {
                v13 = __nwlog_obj();
                if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446466;
                  v52 = "nw_channel_check_flows_allowed";
                  v53 = 2082;
                  v54 = (const char *)(v3 + 84);
                  _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s Flow(%{public}s) is no longer present", buf, 0x16u);
                }
              }
            }
            else
            {
              if (!*(_QWORD *)(v1 + 136))
              {
                if (_nw_signposts_once != -1)
                  dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
                if (_nw_signposts_enabled && kdebug_is_enabled())
                  kdebug_trace();
                goto LABEL_18;
              }
              if (((*(unsigned __int16 *)(v1 + 444) | (*(unsigned __int8 *)(v1 + 446) << 16)) & 0x80000) == 0)
              {
                if (!os_channel_is_defunct())
                {
                  __nwlog_obj();
                  *(_DWORD *)buf = 136446722;
                  v28 = (const char *)(v3 + 84);
                  v52 = "nw_channel_check_flows_allowed";
                  v53 = 2082;
                  v54 = v28;
                  v55 = 1024;
                  LODWORD(v56[0]) = v12;
                  v29 = (const char *)_os_log_send_and_compose_impl();
                  type = OS_LOG_TYPE_ERROR;
                  v49 = 0;
                  v48 = (char *)v29;
                  if (!__nwlog_fault(v29, &type, &v49))
                    goto LABEL_88;
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    v30 = __nwlog_obj();
                    v31 = type;
                    logc = v30;
                    if (os_log_type_enabled(v30, type))
                    {
                      *(_DWORD *)buf = 136446722;
                      v52 = "nw_channel_check_flows_allowed";
                      v53 = 2082;
                      v54 = v28;
                      v55 = 1024;
                      LODWORD(v56[0]) = v12;
                      v32 = logc;
                      v33 = v31;
                      v34 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d";
                      goto LABEL_87;
                    }
                    goto LABEL_88;
                  }
                  if (v49)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    v39 = __nwlog_obj();
                    v41 = type;
                    v36 = os_log_type_enabled(v39, type);
                    if (backtrace_string)
                    {
                      if (v36)
                      {
                        *(_DWORD *)buf = 136446978;
                        v52 = "nw_channel_check_flows_allowed";
                        v53 = 2082;
                        v54 = v28;
                        v55 = 1024;
                        LODWORD(v56[0]) = v12;
                        WORD2(v56[0]) = 2082;
                        *(_QWORD *)((char *)v56 + 6) = backtrace_string;
                        _os_log_impl(&dword_182FBE000, v39, v41, "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
                      }
                      free(backtrace_string);
                      goto LABEL_88;
                    }
                    if (!v36)
                    {
LABEL_88:
                      if (v48)
                        free(v48);
                      goto LABEL_18;
                    }
                    *(_DWORD *)buf = 136446722;
                    v52 = "nw_channel_check_flows_allowed";
                    v53 = 2082;
                    v54 = v28;
                    v55 = 1024;
                    LODWORD(v56[0]) = v12;
                    v32 = v39;
                    v33 = v41;
                    v34 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, no backtrace";
                  }
                  else
                  {
                    v37 = __nwlog_obj();
                    v38 = type;
                    logd = v37;
                    if (!os_log_type_enabled(v37, type))
                      goto LABEL_88;
                    *(_DWORD *)buf = 136446722;
                    v52 = "nw_channel_check_flows_allowed";
                    v53 = 2082;
                    v54 = v28;
                    v55 = 1024;
                    LODWORD(v56[0]) = v12;
                    v32 = logd;
                    v33 = v38;
                    v34 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, backtrace limit exceeded";
                  }
LABEL_87:
                  _os_log_impl(&dword_182FBE000, v32, v33, v34, buf, 0x1Cu);
                  goto LABEL_88;
                }
                nw_channel_handle_defunct(v1);
              }
            }
          }
LABEL_18:
          if (!v2)
            return;
        }
        if (nw_link_set_flow_control_status(*(void **)(v3 + 72), 0))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v6 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = (const char *)(v3 + 84);
            _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s Flow resumed for flow id %{public}s", buf, 0x16u);
          }
        }
        if (v4)
        {
          v7 = *(_QWORD *)(v4 + 24);
          if (v7)
          {
            v8 = *(void (**)(uint64_t, uint64_t, _QWORD))(v7 + 104);
            if (v8)
            {
              v8(v4, v1 + 24, *(_QWORD *)(v3 + 72));
LABEL_14:
              v9 = *(_QWORD *)(v3 + 56);
              v10 = *(_QWORD **)(v3 + 64);
              if (v9)
              {
                *(_QWORD *)(v9 + 64) = v10;
                v10 = *(_QWORD **)(v3 + 64);
              }
              else
              {
                *(_QWORD *)(v1 + 392) = v10;
              }
              *v10 = v9;
              *(_BYTE *)(v3 + 121) &= ~2u;
              goto LABEL_18;
            }
          }
          __nwlog_obj();
          v11 = *(const char **)(v4 + 16);
          if (!v11)
            v11 = "invalid";
        }
        else
        {
          __nwlog_obj();
          v11 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        v52 = "nw_channel_check_flows_allowed";
        v53 = 2082;
        v54 = v11;
        v14 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v49 = 0;
        v47 = (char *)v14;
        if (__nwlog_fault(v14, &type, &v49))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v15 = __nwlog_obj();
            v16 = type;
            log = v15;
            if (!os_log_type_enabled(v15, type))
              goto LABEL_63;
            if (v4)
            {
              v17 = *(const char **)(v4 + 16);
              if (!v17)
                v17 = "invalid";
            }
            else
            {
              v17 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = v17;
            v25 = log;
            v26 = v16;
            v27 = "%{public}s protocol %{public}s has invalid link_state callback";
            goto LABEL_62;
          }
          if (!v49)
          {
            v21 = __nwlog_obj();
            v22 = type;
            logb = v21;
            if (!os_log_type_enabled(v21, type))
              goto LABEL_63;
            if (v4)
            {
              v23 = *(const char **)(v4 + 16);
              if (!v23)
                v23 = "invalid";
            }
            else
            {
              v23 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = v23;
            v25 = logb;
            v26 = v22;
            v27 = "%{public}s protocol %{public}s has invalid link_state callback, backtrace limit exceeded";
            goto LABEL_62;
          }
          v18 = (char *)__nw_create_backtrace_string();
          loga = __nwlog_obj();
          v40 = type;
          v19 = os_log_type_enabled(loga, type);
          if (v18)
          {
            if (v19)
            {
              if (v4)
              {
                v20 = *(const char **)(v4 + 16);
                if (!v20)
                  v20 = "invalid";
              }
              else
              {
                v20 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v52 = "nw_channel_check_flows_allowed";
              v53 = 2082;
              v54 = v20;
              v55 = 2082;
              v56[0] = v18;
              _os_log_impl(&dword_182FBE000, loga, v40, "%{public}s protocol %{public}s has invalid link_state callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v18);
            goto LABEL_63;
          }
          if (v19)
          {
            if (v4)
            {
              v24 = *(const char **)(v4 + 16);
              if (!v24)
                v24 = "invalid";
            }
            else
            {
              v24 = "invalid";
            }
            v25 = loga;
            v26 = v40;
            *(_DWORD *)buf = 136446466;
            v52 = "nw_channel_check_flows_allowed";
            v53 = 2082;
            v54 = v24;
            v27 = "%{public}s protocol %{public}s has invalid link_state callback, no backtrace";
LABEL_62:
            _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0x16u);
          }
        }
LABEL_63:
        if (v47)
          free(v47);
        goto LABEL_14;
      }
    }
  }
}

BOOL nw_protocol_register_extended(_QWORD *a1, uint64_t a2)
{
  uint64_t *v4;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  _QWORD *v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  char *backtrace_string;
  _BOOL4 v18;
  _BOOL8 result;
  NSObject *v20;
  void *v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  v4 = &g_registration_list;
  while (1)
  {
    v4 = (uint64_t *)*v4;
    if (!v4)
      break;
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v25 = "nw_protocol_register_extended";
      v26 = 2082;
      v27 = (uint64_t)a1;
      v9 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v22 = 0;
      if (!__nwlog_fault(v9, &type, &v22))
        goto LABEL_35;
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v22)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = type;
          v18 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v18)
            {
              *(_DWORD *)buf = 136446722;
              v25 = "nw_protocol_register_extended";
              v26 = 2082;
              v27 = (uint64_t)a1;
              v28 = 2082;
              v29 = (uint64_t)backtrace_string;
              _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s Protocol identifier %{public}s is already registered, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_35;
          }
          if (!v18)
            goto LABEL_35;
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_register_extended";
          v26 = 2082;
          v27 = (uint64_t)a1;
          v12 = "%{public}s Protocol identifier %{public}s is already registered, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = gLogObj;
          v11 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_35;
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_register_extended";
          v26 = 2082;
          v27 = (uint64_t)a1;
          v12 = "%{public}s Protocol identifier %{public}s is already registered, backtrace limit exceeded";
        }
LABEL_34:
        _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0x16u);
        goto LABEL_35;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_protocol_register_extended";
        v26 = 2082;
        v27 = (uint64_t)a1;
        v12 = "%{public}s Protocol identifier %{public}s is already registered";
        goto LABEL_34;
      }
LABEL_35:
      if (v9)
        free(v9);
LABEL_37:
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      return v4 == 0;
    }
  }
  v13 = malloc_type_calloc(1uLL, 0x78uLL, 0xEAFB8F1AuLL);
  if (v13)
  {
LABEL_22:
    v14 = *(_OWORD *)a1;
    v15 = *((_OWORD *)a1 + 1);
    v13[8] = a1[4];
    *((_OWORD *)v13 + 2) = v14;
    *((_OWORD *)v13 + 3) = v15;
    v13[11] = a2;
    v16 = g_registration_list;
    *v13 = g_registration_list;
    if (v16)
      *(_QWORD *)(v16 + 8) = v13;
    g_registration_list = (uint64_t)v13;
    v13[1] = &g_registration_list;
    goto LABEL_37;
  }
  v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v25 = "strict_calloc";
  v26 = 2048;
  v27 = 1;
  v28 = 2048;
  v29 = 120;
  v21 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
    goto LABEL_22;
  }
  __break(1u);
  return result;
}

void sub_1831F60C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_parameters_set_attribution(nw_parameters_t parameters, nw_parameters_attribution_t attribution)
{
  int v2;
  nw_parameters_t v3;
  nw_parameters_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v2 = attribution;
  v19 = *MEMORY[0x1E0C80C00];
  v3 = parameters;
  v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3[13].isa + 102) = 2 * (v2 == 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_set_attribution";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_attribution";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_set_attribution";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_attribution";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_attribution";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void __nw_mem_cache_update_set_timer_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  _BOOL4 v7;
  char *v8;
  os_log_type_t v9;
  os_log_type_t log;
  NSObject *loga;
  os_log_type_t logb;
  NSObject *v13;
  const char *backtrace_string;
  NSObject *v15;
  char v16;
  os_log_type_t type;
  _BYTE block[24];
  void *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock(&nw_mem_cache_lock);
  v0 = nw_mem_cache_head;
  if (nw_mem_cache_head)
  {
    v1 = MEMORY[0x1E0C809B0];
    while (1)
    {
      v2 = *(_QWORD *)(v0 + 216);
      if (!v2)
        break;
      *(_QWORD *)block = v1;
      *(_QWORD *)&block[8] = 0x40000000;
      *(_QWORD *)&block[16] = ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke;
      v19 = &__block_descriptor_tmp_7_54782;
      v20 = v0;
      if (*(_QWORD *)(v2 + 272))
      {
        if (dispatch_workloop_is_current())
          (*(void (**)(_BYTE *))&block[16])(block);
        else
          dispatch_async(*(dispatch_queue_t *)(v2 + 272), block);
      }
      else
      {
        ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke((uint64_t)block);
      }
LABEL_4:
      v0 = *(_QWORD *)(v0 + 80);
      if (!v0)
        goto LABEL_26;
    }
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(_QWORD *)&block[4] = "nw_mem_cache_update";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v3, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v13 = __nwlog_obj();
        log = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_24;
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_mem_cache_update";
        v4 = v13;
        v5 = log;
        v6 = "%{public}s called with null nwm->nwm_region";
        goto LABEL_23;
      }
      if (!v16)
      {
        v15 = __nwlog_obj();
        logb = type;
        if (!os_log_type_enabled(v15, type))
          goto LABEL_24;
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_mem_cache_update";
        v4 = v15;
        v5 = logb;
        v6 = "%{public}s called with null nwm->nwm_region, backtrace limit exceeded";
        goto LABEL_23;
      }
      backtrace_string = __nw_create_backtrace_string();
      loga = __nwlog_obj();
      v9 = type;
      v7 = os_log_type_enabled(loga, type);
      v8 = (char *)backtrace_string;
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)block = 136446466;
          *(_QWORD *)&block[4] = "nw_mem_cache_update";
          *(_WORD *)&block[12] = 2082;
          *(_QWORD *)&block[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, loga, v9, "%{public}s called with null nwm->nwm_region, dumping backtrace:%{public}s", block, 0x16u);
          v8 = (char *)backtrace_string;
        }
        free(v8);
        goto LABEL_24;
      }
      if (v7)
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_mem_cache_update";
        v4 = loga;
        v5 = v9;
        v6 = "%{public}s called with null nwm->nwm_region, no backtrace";
LABEL_23:
        _os_log_impl(&dword_182FBE000, v4, v5, v6, block, 0xCu);
      }
    }
LABEL_24:
    if (v3)
      free(v3);
    goto LABEL_4;
  }
LABEL_26:
  os_unfair_lock_unlock(&nw_mem_cache_lock);
  nw_mem_cache_stats_dump();
  nw_mem_cache_update_set_timer::cache_update_timer_set = 0;
  if (nw_mem_cache_operations_during_interval == 1)
  {
    nw_mem_cache_operations_during_interval = 0;
    nw_mem_cache_update_set_timer();
  }
}

void ___ZL19nw_mem_cache_updateP12nw_mem_cache_block_invoke(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  size_t v8;
  size_t v9;
  unint64_t v10;
  _BOOL8 v12;
  BOOL v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD *v32;
  unint64_t v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  int v38;
  _BYTE v39[12];
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 8);
  v3 = *(_QWORD *)(v1 + 280);
  v4 = (v2 <= 2 * v3 || v3 + 1 >= *(_QWORD *)(v1 + 264)) && (v2 >= v3 >> 1 || v3 <= *(_QWORD *)(v1 + 256));
  *(_QWORD *)(v1 + 364) = *(_QWORD *)(v1 + 360);
  *(_QWORD *)(v1 + 396) = *(_QWORD *)(v1 + 392);
  v5 = *(_QWORD *)(v1 + 64);
  if (*(_QWORD *)(v1 + 232) >= *(_QWORD *)(*(_QWORD *)(v1 + 336) + 16))
  {
    v6 = 1;
    *(_QWORD *)(v1 + 72) = v5;
    if (v4)
      goto LABEL_36;
  }
  else
  {
    v6 = (int)v5 - *(_DWORD *)(v1 + 72) < 4;
    *(_QWORD *)(v1 + 72) = v5;
    if (v4)
      goto LABEL_36;
  }
  v7 = *(_QWORD *)(v1 + 256);
  if (v7 <= 1 << (flsll(3 * v2 + 4) - 2))
    v8 = 1 << (flsll(3 * *(_QWORD *)(v1 + 8) + 4) - 2);
  else
    v8 = *(_QWORD *)(v1 + 256);
  if (*(_QWORD *)(v1 + 264) >= v8)
    v9 = v8;
  else
    v9 = *(_QWORD *)(v1 + 264);
  v10 = *(_QWORD *)(v1 + 280) + 1;
  if (v9 < v10 >> 1 || v9 > 2 * v10)
  {
    v12 = nw_calloc_type<nw_mem_bufctl_bkt>(v9);
    if (v9)
    {
      if (v9 >= 0xE && ((_DWORD)v9 ? (v13 = (v9 - 1) >> 32 == 0) : (v13 = 0), v13))
      {
        v14 = v9 & 0xFFFFFFFFFFFFFFFCLL;
        v32 = (_OWORD *)v12;
        v33 = v9 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          *v32 = 0uLL;
          v32[1] = 0uLL;
          v32 += 2;
          v33 -= 4;
        }
        while (v33);
        v15 = v9 & 0xFFFFFFFC;
        if (v9 == v14)
          goto LABEL_31;
      }
      else
      {
        v14 = 0;
        v15 = 0;
      }
      v16 = v15 + 1;
      do
      {
        *(_QWORD *)(v12 + 8 * v14) = 0;
        v14 = v16++;
      }
      while (v9 > v14);
    }
LABEL_31:
    v17 = *(_QWORD *)(v1 + 280);
    v18 = *(_QWORD **)(v1 + 288);
    *(_QWORD *)(v1 + 280) = v9 - 1;
    *(_QWORD *)(v1 + 288) = v12;
    ++*(_QWORD *)(v1 + 24);
    v19 = v17 + 1;
    if (v17 == -1)
    {
      v20 = 0;
    }
    else
    {
      v28 = 0;
      v20 = 0;
      do
      {
        v29 = (_QWORD *)v18[v28];
        if (v29)
        {
          v30 = *(_QWORD *)(v1 + 272);
          do
          {
            v18[v28] = *v29;
            v31 = 8 * ((v29[1] >> v30) & (v9 - 1));
            *v29 = *(_QWORD *)(v12 + v31);
            *(_QWORD *)(v12 + v31) = v29;
            ++v20;
            v29 = (_QWORD *)v18[v28];
          }
          while (v29);
        }
        ++v28;
      }
      while (v19 > v28);
    }
    if (gLogDatapath)
    {
      v35 = __nwlog_obj();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v39 = 136447234;
        *(_QWORD *)&v39[4] = "nw_mem_cache_hash_rescale";
        v40 = 2048;
        v41 = v1;
        v42 = 1024;
        v43 = v19;
        v44 = 1024;
        v45 = v9;
        v46 = 1024;
        v47 = v20;
        _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p old_size %u new_size %u [%u moved]", v39, 0x28u);
      }
    }
    if (v18)
      free(v18);
  }
LABEL_36:
  if (!v6)
  {
    v21 = *(_QWORD *)(v1 + 336);
    if (*(_QWORD *)(v1 + 232) < *(_QWORD *)(v21 + 16))
    {
      nw_mem_cache_magazine_purge(v1);
      *(_QWORD *)(v1 + 336) = v21 + 88;
      *(_QWORD *)(v1 + 72) = *(_QWORD *)(v1 + 64) + 0x7FFFFFFFLL;
      if ((*(_BYTE *)(v1 + 176) & 1) == 0)
      {
        *(_DWORD *)(v1 + 560) = *(_DWORD *)(v21 + 88);
        if (gLogDatapath)
        {
          v36 = __nwlog_obj();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          {
            v37 = *(_QWORD *)(v1 + 232);
            v38 = *(_DWORD *)(v1 + 560);
            *(_DWORD *)v39 = 136446978;
            *(_QWORD *)&v39[4] = "nw_mem_cache_magazine_enable";
            v40 = 2048;
            v41 = v1;
            v42 = 1024;
            v43 = v37;
            v44 = 1024;
            v45 = v38;
            _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p chunksize %u magsize %d", v39, 0x22u);
          }
        }
      }
    }
  }
  nw_mem_depot_ws_reap(v1);
  *(_QWORD *)v39 = 0;
  if (!mach_timebase_info((mach_timebase_info_t)v39))
  {
    v22 = mach_absolute_time() * *(unsigned int *)v39 / *(unsigned int *)&v39[4];
    v23 = v22 / 0x3B9ACA00;
    *(_QWORD *)&nw_mem_get_current_time::current_time = v22 / 0x3B9ACA00;
    *((_QWORD *)&nw_mem_get_current_time::current_time + 1) = v22 % 0x3B9ACA00;
    v24 = *(_QWORD *)(v1 + 408);
    if (v24 >= 1 && (uint64_t)(v23 - v24) >= 7)
    {
      nw_mem_cache_magazine_purge(v1);
      if ((*(_BYTE *)(v1 + 176) & 1) == 0)
      {
        *(_DWORD *)(v1 + 560) = **(_DWORD **)(v1 + 336);
        if (gLogDatapath)
        {
          v25 = __nwlog_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            v26 = *(_QWORD *)(v1 + 232);
            v27 = *(_DWORD *)(v1 + 560);
            *(_DWORD *)v39 = 136446978;
            *(_QWORD *)&v39[4] = "nw_mem_cache_magazine_enable";
            v40 = 2048;
            v41 = v1;
            v42 = 1024;
            v43 = v26;
            v44 = 1024;
            v45 = v27;
            _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p chunksize %u magsize %d", v39, 0x22u);
          }
        }
      }
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_region_lock);
  if (g_process_transaction)
  {
    if ((g_transaction_touched & 1) == 0)
    {
      os_release((void *)g_process_transaction);
      g_process_transaction = 0;
      g_transaction_touched = 0;
      if (gLogDatapath)
      {
        v34 = __nwlog_obj();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v39 = 136446210;
          *(_QWORD *)&v39[4] = "nw_mem_region_reap_transaction";
          _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s os transaction disabled after idle", v39, 0xCu);
        }
      }
    }
  }
  g_transaction_touched = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_region_lock);
}

BOOL nw_mem_buffer_manager_initialize(NSObject *a1, const char *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v5;
  _QWORD *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  _BOOL4 v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  const char *v21;
  const char *v22;
  _BOOL4 v23;
  uint64_t v24;
  unint64_t v25;
  _BOOL4 v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int v38;
  unsigned int v39;
  _QWORD *v40;
  unint64_t v41;
  size_t v42;
  void *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  void *v47;
  unint64_t v48;
  void *v49;
  _BOOL8 result;
  uint64_t v51;
  char v52;
  unint64_t v53;
  unint64_t v54;
  void *v55;
  _BOOL8 v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  int v61;
  unsigned int v62;
  int *p_flags;
  unint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  _QWORD *v67;
  unint64_t v68;
  int v69;
  double *v70;
  __int128 v71;
  unint64_t v72;
  double *v73;
  double *v74;
  _OWORD *v75;
  unint64_t v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  const char *v80;
  NSObject *v81;
  void *v82;
  NSObject *v83;
  uint64_t v84;
  NSObject *v85;
  uint64_t v86;
  NSObject *v87;
  uint64_t v88;
  NSObject *v89;
  uint64_t v90;
  int v91;
  const char *v92;
  const char *v93;
  NSObject *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  NSObject *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  NSObject *v104;
  void *v105;
  NSObject *v106;
  void *v107;
  NSObject *v108;
  void *v109;
  NSObject *v110;
  void *v111;
  NSObject *v112;
  NSObject *v113;
  void *v114;
  NSObject *v115;
  void *v116;
  NSObject *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  NSObject *v123;
  void *v124;
  NSObject *v125;
  void *v126;
  NSObject *v127;
  int v128;
  NSObject *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  char *backtrace_string;
  _BOOL4 v136;
  char *v137;
  _BOOL4 v138;
  const char *v139;
  _BOOL4 v140;
  NSObject *v141;
  uint64_t v142;
  int v143;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  NSObject *logc;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  NSObject *v152;
  char v153;
  os_log_type_t type[32];
  uint8_t buf[4];
  const char *v156;
  __int16 v157;
  _BYTE v158[10];
  _BYTE v159[18];
  _BYTE v160[10];
  __int16 v161;
  unint64_t v162;
  __int16 v163;
  uint64_t v164;
  uint64_t v165;
  float64x2x2_t v166;

  v165 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v156 = "nw_mem_buffer_manager_initialize";
    v77 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v153 = 0;
    if (!__nwlog_fault(v77, type, &v153))
      goto LABEL_213;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      v156 = "nw_mem_buffer_manager_initialize";
      v80 = "%{public}s called with null name";
    }
    else if (v153)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v78 = __nwlog_obj();
      v79 = type[0];
      v136 = os_log_type_enabled(v78, type[0]);
      if (backtrace_string)
      {
        if (v136)
        {
          *(_DWORD *)buf = 136446466;
          v156 = "nw_mem_buffer_manager_initialize";
          v157 = 2082;
          *(_QWORD *)v158 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_213:
        if (!v77)
          return 0;
LABEL_214:
        free(v77);
        return 0;
      }
      if (!v136)
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      v156 = "nw_mem_buffer_manager_initialize";
      v80 = "%{public}s called with null name, no backtrace";
    }
    else
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      v156 = "nw_mem_buffer_manager_initialize";
      v80 = "%{public}s called with null name, backtrace limit exceeded";
    }
    goto LABEL_212;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v156 = "nw_mem_buffer_manager_initialize";
    v77 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v153 = 0;
    if (!__nwlog_fault(v77, type, &v153))
      goto LABEL_213;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v153)
      {
        v78 = __nwlog_obj();
        v79 = type[0];
        if (!os_log_type_enabled(v78, type[0]))
          goto LABEL_213;
        *(_DWORD *)buf = 136446210;
        v156 = "nw_mem_buffer_manager_initialize";
        v80 = "%{public}s called with null (obj_size > 0), backtrace limit exceeded";
        goto LABEL_212;
      }
      v137 = (char *)__nw_create_backtrace_string();
      v78 = __nwlog_obj();
      v79 = type[0];
      v138 = os_log_type_enabled(v78, type[0]);
      if (!v137)
      {
        if (!v138)
          goto LABEL_213;
        *(_DWORD *)buf = 136446210;
        v156 = "nw_mem_buffer_manager_initialize";
        v80 = "%{public}s called with null (obj_size > 0), no backtrace";
        goto LABEL_212;
      }
      if (v138)
      {
        *(_DWORD *)buf = 136446466;
        v156 = "nw_mem_buffer_manager_initialize";
        v157 = 2082;
        *(_QWORD *)v158 = v137;
        v139 = "%{public}s called with null (obj_size > 0), dumping backtrace:%{public}s";
LABEL_195:
        _os_log_impl(&dword_182FBE000, v78, v79, v139, buf, 0x16u);
      }
LABEL_196:
      free(v137);
      if (!v77)
        return 0;
      goto LABEL_214;
    }
    v78 = __nwlog_obj();
    v79 = type[0];
    if (!os_log_type_enabled(v78, type[0]))
      goto LABEL_213;
    *(_DWORD *)buf = 136446210;
    v156 = "nw_mem_buffer_manager_initialize";
    v80 = "%{public}s called with null (obj_size > 0)";
LABEL_212:
    _os_log_impl(&dword_182FBE000, v78, v79, v80, buf, 0xCu);
    goto LABEL_213;
  }
  v5 = a4;
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v156 = "nw_mem_buffer_manager_initialize";
    v77 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v153 = 0;
    if (!__nwlog_fault(v77, type, &v153))
      goto LABEL_213;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      v156 = "nw_mem_buffer_manager_initialize";
      v80 = "%{public}s called with null (obj_cnt > 0)";
      goto LABEL_212;
    }
    if (!v153)
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      v156 = "nw_mem_buffer_manager_initialize";
      v80 = "%{public}s called with null (obj_cnt > 0), backtrace limit exceeded";
      goto LABEL_212;
    }
    v137 = (char *)__nw_create_backtrace_string();
    v78 = __nwlog_obj();
    v79 = type[0];
    v140 = os_log_type_enabled(v78, type[0]);
    if (!v137)
    {
      if (!v140)
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      v156 = "nw_mem_buffer_manager_initialize";
      v80 = "%{public}s called with null (obj_cnt > 0), no backtrace";
      goto LABEL_212;
    }
    if (v140)
    {
      *(_DWORD *)buf = 136446466;
      v156 = "nw_mem_buffer_manager_initialize";
      v157 = 2082;
      *(_QWORD *)v158 = v137;
      v139 = "%{public}s called with null (obj_cnt > 0), dumping backtrace:%{public}s";
      goto LABEL_195;
    }
    goto LABEL_196;
  }
  if (nw_mem_buffer_manager_initialize::onceToken != -1)
    dispatch_once(&nw_mem_buffer_manager_initialize::onceToken, &__block_literal_global_63339);
  v8 = malloc_type_calloc(1uLL, 0xA0uLL, 0xEAFB8F1AuLL);
  if (!v8)
  {
    v81 = __nwlog_obj();
    os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v156 = "strict_calloc";
    v157 = 2048;
    *(_QWORD *)v158 = 1;
    *(_WORD *)&v158[8] = 2048;
    *(_QWORD *)v159 = 160;
    v82 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v82);
    if (result)
      goto LABEL_216;
    free(v82);
  }
  *((_OWORD *)v8 + 2) = xmmword_1E149D4A0;
  *((_OWORD *)v8 + 3) = unk_1E149D4B0;
  *(_OWORD *)v8 = nw_mem_regions;
  *((_OWORD *)v8 + 1) = *(_OWORD *)algn_1E149D490;
  *((_QWORD *)&v9 + 1) = 0;
  *((_OWORD *)v8 + 4) = xmmword_1E149D4C0;
  v8[5] = a3;
  v8[6] = v5;
  *((_DWORD *)v8 + 3) = 32 * (nw_mem_debug & 1);
  v10 = nw_mem_buf_seg_size;
  v8[2] = nw_mem_buf_seg_size;
  v11 = nw_mem_seg_min_buf_cnt;
  if (nw_mem_seg_min_buf_cnt < v5 && v10 / a3 < nw_mem_seg_min_buf_cnt)
  {
    v10 = -(uint64_t)(-(nw_mem_seg_min_buf_cnt * a3) & 0xFFFFFFFFFFFFC000);
    v8[2] = v10;
    v5 = v11 + v5 / v11 * v11;
  }
  if (!v10 || (v10 & 0x3FFF) != 0)
  {
    v125 = __nwlog_obj();
    os_log_type_enabled(v125, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v156 = "nw_mem_region_params_config";
    v157 = 2082;
    *(_QWORD *)v158 = "VERIFY seglim != 0 && (seglim % NW_MEM_PAGE_SIZE) == 0 failed";
    v126 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v126);
    if (result)
      goto LABEL_216;
    free(v126);
  }
  if (gLogDatapath)
  {
    v83 = __nwlog_obj();
    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
    {
      v84 = *v8;
      *(_DWORD *)buf = 136447234;
      v156 = "nw_mem_region_params_config";
      v157 = 2082;
      *(_QWORD *)v158 = v84;
      *(_WORD *)&v158[8] = 2048;
      *(_QWORD *)v159 = v10;
      *(_WORD *)&v159[8] = 2048;
      *(_QWORD *)&v159[10] = a3;
      *(_WORD *)v160 = 2048;
      *(_QWORD *)&v160[2] = v5;
      _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: seglim %zu objsize %zu objcnt %zu", buf, 0x34u);
    }
  }
  v152 = a1;
  v12 = -(uint64_t)(-a3 & 0xFFFFFFFFFFFFFF80);
  if (v10 > v12)
  {
    *(_QWORD *)&v9 = 136446978;
    do
    {
      if (!(v10 % v12))
        break;
      if (gLogDatapath)
      {
        v148 = v9;
        log = __nwlog_obj();
        v13 = os_log_type_enabled(log, OS_LOG_TYPE_DEBUG);
        v9 = v148;
        if (v13)
        {
          v14 = *v8;
          *(_DWORD *)buf = v148;
          v156 = "nw_mem_region_params_config";
          v157 = 2082;
          *(_QWORD *)v158 = v14;
          *(_WORD *)&v158[8] = 2048;
          *(_QWORD *)v159 = v12;
          *(_WORD *)&v159[8] = 2048;
          *(_QWORD *)&v159[10] = v12 + 128;
          _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: objsize %zu -> %zu", buf, 0x2Au);
          v9 = v148;
        }
      }
      v12 += 128;
    }
    while (v12 < v10);
  }
  if (v12 > v10)
  {
    *(_QWORD *)&v9 = 136446978;
    do
    {
      if (gLogDatapath)
      {
        v149 = v9;
        loga = __nwlog_obj();
        v15 = os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG);
        v9 = v149;
        if (v15)
        {
          v16 = *v8;
          *(_DWORD *)buf = v149;
          v156 = "nw_mem_region_params_config";
          v157 = 2082;
          *(_QWORD *)v158 = v16;
          *(_WORD *)&v158[8] = 2048;
          *(_QWORD *)v159 = v10;
          *(_WORD *)&v159[8] = 2048;
          *(_QWORD *)&v159[10] = v10 + 0x4000;
          _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: seglim %zu -> %zu", buf, 0x2Au);
          v9 = v149;
        }
      }
      v10 += 0x4000;
    }
    while (v12 > v10);
  }
  v17 = -(uint64_t)(v5 * v12) & 0xFFFFFFFFFFFFC000;
  v18 = -(uint64_t)v17;
  if (v10 <= -(uint64_t)v17)
  {
    if (v10 >= -(uint64_t)v17)
    {
      v20 = -(uint64_t)v17;
    }
    else
    {
      v25 = v10 + (v10 >> 1);
      *(_QWORD *)&v9 = 136447746;
      do
      {
        if (v10 >= v18 || !(v18 % v10))
          break;
        if (gLogDatapath)
        {
          v151 = v9;
          logc = __nwlog_obj();
          v26 = os_log_type_enabled(logc, OS_LOG_TYPE_DEBUG);
          v9 = v151;
          if (v26)
          {
            v27 = *v8;
            *(_DWORD *)buf = v151;
            v156 = "nw_mem_region_params_config";
            v157 = 2082;
            *(_QWORD *)v158 = v27;
            *(_WORD *)&v158[8] = 2048;
            *(_QWORD *)v159 = -(uint64_t)v17;
            *(_WORD *)&v159[8] = 2048;
            *(_QWORD *)&v159[10] = v12;
            *(_WORD *)v160 = 2048;
            *(_QWORD *)&v160[2] = v5;
            v161 = 2048;
            v162 = v10;
            v163 = 2048;
            v164 = v10 + 0x4000;
            _os_log_impl(&dword_182FBE000, logc, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: segsize %zu (%zu*%zu) seglim [+] %zu -> %zu", buf, 0x48u);
            v9 = v151;
          }
        }
        v10 += 0x4000;
      }
      while (v10 < v25);
      if (v18 % v10)
        v20 = v10 - v17 - v18 % v10;
      else
        v20 = -(uint64_t)v17;
    }
  }
  else
  {
    if (v18 <= 0x4000)
      v19 = 0x4000;
    else
      v19 = -(uint64_t)v17;
    if (v10 <= v19)
    {
      v20 = v10;
    }
    else
    {
      *(_QWORD *)&v9 = 136447746;
      v20 = v10;
      v21 = "%{public}s %{public}s: segsize %zu (%zu*%zu) seglim [-] %zu -> %zu";
      do
      {
        if (gLogDatapath)
        {
          v150 = v9;
          v22 = v21;
          logb = __nwlog_obj();
          v23 = os_log_type_enabled(logb, OS_LOG_TYPE_DEBUG);
          v21 = v22;
          v9 = v150;
          if (v23)
          {
            v24 = *v8;
            *(_DWORD *)buf = v150;
            v156 = "nw_mem_region_params_config";
            v157 = 2082;
            *(_QWORD *)v158 = v24;
            *(_WORD *)&v158[8] = 2048;
            *(_QWORD *)v159 = v18;
            *(_WORD *)&v159[8] = 2048;
            *(_QWORD *)&v159[10] = v12;
            *(_WORD *)v160 = 2048;
            *(_QWORD *)&v160[2] = v5;
            v161 = 2048;
            v162 = v20;
            v163 = 2048;
            v164 = -(uint64_t)((0x4000 - v20) & 0xFFFFFFFFFFFFC000);
            _os_log_impl(&dword_182FBE000, logb, OS_LOG_TYPE_DEBUG, v22, buf, 0x48u);
            v21 = v22;
            v9 = v150;
          }
        }
        v20 = -(uint64_t)((0x4000 - v20) & 0xFFFFFFFFFFFFC000);
        v10 = v20;
      }
      while (v19 < v20);
    }
  }
  if (gLogDatapath)
  {
    v85 = __nwlog_obj();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
    {
      v86 = *v8;
      *(_DWORD *)buf = 136446978;
      v156 = "nw_mem_region_params_config";
      v157 = 2082;
      *(_QWORD *)v158 = v86;
      *(_WORD *)&v158[8] = 2048;
      *(_QWORD *)v159 = v20;
      *(_WORD *)&v159[8] = 2048;
      *(_QWORD *)&v159[10] = v10;
      _os_log_impl(&dword_182FBE000, v85, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: segsize %zu seglim %zu", buf, 0x2Au);
    }
  }
  if ((*((_BYTE *)v8 + 12) & 0x10) != 0)
  {
    v28 = 1;
  }
  else
  {
    if (v10 <= v20)
      v28 = v20 / v10;
    else
      v28 = 1;
    v20 /= v28;
  }
  if (gLogDatapath)
  {
    v87 = __nwlog_obj();
    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
    {
      v88 = *v8;
      *(_DWORD *)buf = 136446978;
      v156 = "nw_mem_region_params_config";
      v157 = 2082;
      *(_QWORD *)v158 = v88;
      *(_WORD *)&v158[8] = 2048;
      *(_QWORD *)v159 = v28;
      *(_WORD *)&v159[8] = 2048;
      *(_QWORD *)&v159[10] = v20;
      _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: segcnt %zu segsize %zu", buf, 0x2Au);
    }
  }
  v8[7] = v12;
  v8[8] = v20 * v28 / v12;
  v8[3] = v20;
  v8[4] = v28;
  if (gLogDatapath)
  {
    v89 = __nwlog_obj();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
    {
      v90 = *v8;
      *(_DWORD *)buf = 136447490;
      v156 = "nw_mem_region_params_config";
      v157 = 2082;
      *(_QWORD *)v158 = v90;
      *(_WORD *)&v158[8] = 2048;
      *(_QWORD *)v159 = v12;
      *(_WORD *)&v159[8] = 2048;
      *(_QWORD *)&v159[10] = v20 * v28 / v12;
      *(_WORD *)v160 = 2048;
      *(_QWORD *)&v160[2] = v28;
      v161 = 2048;
      v162 = v20;
      _os_log_impl(&dword_182FBE000, v89, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s: objsize %zu objcnt %zu segcnt %zu segsize %zu", buf, 0x3Eu);
    }
    if (gLogDatapath)
    {
      v91 = *((_DWORD *)v8 + 2);
      v92 = "";
      if (v91 == 1)
        v92 = "REGIONS";
      if (v91)
        v93 = v92;
      else
        v93 = "BUF";
      snprintf((char *)type, 0x20uLL, "REGION_%s:", v93);
      if (gLogDatapath)
      {
        v94 = __nwlog_obj();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
        {
          v96 = v8[5];
          v95 = v8[6];
          v98 = v8[7];
          v97 = v8[8];
          *(_DWORD *)buf = 136447490;
          v156 = "nw_mem_region_params_config";
          v157 = 2080;
          *(_QWORD *)v158 = type;
          *(_WORD *)&v158[8] = 1024;
          *(_DWORD *)v159 = v95;
          *(_WORD *)&v159[4] = 1024;
          *(_DWORD *)&v159[6] = v96;
          *(_WORD *)&v159[10] = 1024;
          *(_DWORD *)&v159[12] = v97;
          *(_WORD *)&v159[16] = 1024;
          *(_DWORD *)v160 = v98;
          _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_DEBUG, "%{public}s %-16s o:[%4u x %6u -> %4u x %6u]", buf, 0x2Eu);
        }
        if (gLogDatapath)
        {
          v99 = __nwlog_obj();
          if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
          {
            v100 = v8[7];
            v101 = v8[8];
            v102 = v8[5];
            v103 = v8[6];
            *(_DWORD *)buf = 136447234;
            v156 = "nw_mem_buffer_manager_initialize";
            v157 = 2048;
            *(_QWORD *)v158 = v100;
            *(_WORD *)&v158[8] = 2048;
            *(_QWORD *)v159 = v102;
            *(_WORD *)&v159[8] = 2048;
            *(_QWORD *)&v159[10] = v101;
            *(_WORD *)v160 = 2048;
            *(_QWORD *)&v160[2] = v103;
            _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_DEBUG, "%{public}s   obj size %6zu (was %6zu) cnt %6zu (was %6zu) for REGION_BUF", buf, 0x34u);
          }
        }
      }
    }
  }
  if (v8[7])
  {
    v29 = *((_DWORD *)v8 + 3);
    if ((v29 & 0x20) == 0)
      goto LABEL_64;
    goto LABEL_157;
  }
  v104 = __nwlog_obj();
  os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v156 = "nw_mem_buffer_manager_initialize";
  v157 = 2082;
  *(_QWORD *)v158 = "VERIFY buffer_manager->nrp[NW_MEM_REGION_BUF].nrp_c_obj_size != 0 failed";
  v105 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v105);
  if (result)
    goto LABEL_216;
  free(v105);
  v29 = *((_DWORD *)v8 + 3);
  if ((v29 & 0x20) != 0)
  {
LABEL_157:
    v106 = __nwlog_obj();
    os_log_type_enabled(v106, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v156 = "nw_mem_buffer_manager_initialize";
    v157 = 2082;
    *(_QWORD *)v158 = "VERIFY !(buffer_manager->nrp[NW_MEM_REGION_BUF].nrp_cflags & NW_MEM_REGION_CR_NOCACHE) failed";
    v107 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v107);
    if (result)
      goto LABEL_216;
    free(v107);
    v29 = *((_DWORD *)v8 + 3);
  }
LABEL_64:
  v30 = (char *)malloc_type_zone_calloc((malloc_zone_t *)g_slab_zone, 1uLL, 0x190uLL, 0x61BC51D5uLL);
  if (v30)
  {
    if (!v152)
      goto LABEL_67;
    goto LABEL_66;
  }
  v108 = __nwlog_obj();
  os_log_type_enabled(v108, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v156 = "strict_malloc_zone_calloc";
  v157 = 2048;
  *(_QWORD *)v158 = 1;
  *(_WORD *)&v158[8] = 2048;
  *(_QWORD *)v159 = 400;
  v109 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v109);
  if (result)
    goto LABEL_216;
  free(v109);
  if (v152)
  {
LABEL_66:
    dispatch_retain(v152);
    *((_QWORD *)v30 + 34) = v152;
  }
LABEL_67:
  *((_QWORD *)v30 + 10) = v8[2];
  v31 = v8[3];
  *((_QWORD *)v30 + 11) = v31;
  v32 = v8[4];
  *((_QWORD *)v30 + 31) = v32 * v31;
  *((_QWORD *)v30 + 37) = v8[3] / v8[7];
  *((_QWORD *)v30 + 12) = v32;
  *((_QWORD *)v30 + 41) = 32;
  *((_QWORD *)v30 + 42) = 4096;
  v33 = malloc_type_calloc(1uLL, 0x200uLL, 0xEAFB8F1AuLL);
  if (!v33)
  {
    v110 = __nwlog_obj();
    os_log_type_enabled(v110, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v156 = "strict_calloc";
    v157 = 2048;
    *(_QWORD *)v158 = 1;
    *(_WORD *)&v158[8] = 2048;
    *(_QWORD *)v159 = 512;
    v111 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v111);
    if (result)
      goto LABEL_216;
    free(v111);
  }
  *((_QWORD *)v30 + 44) = *((_QWORD *)v30 + 41) - 1;
  *((_QWORD *)v30 + 45) = v33;
  *((_QWORD *)v30 + 43) = flsll(v8[3]) - 1;
  v34 = *((_QWORD *)v30 + 44);
  v35 = v34 + 1;
  if (v34 != -1)
  {
    v36 = *((_QWORD *)v30 + 45);
    if (v35 < 8)
    {
      v37 = 0;
      v38 = 0;
LABEL_71:
      v39 = v38 + 1;
      do
      {
        v40 = (_QWORD *)(v36 + 16 * v37);
        *v40 = 0;
        v40[1] = v40;
        v37 = v39++;
      }
      while (v35 > v37);
      goto LABEL_73;
    }
    v38 = 0;
    v37 = 0;
    if ((_DWORD)v34 == -1)
      goto LABEL_71;
    if (HIDWORD(v34))
      goto LABEL_71;
    v37 = v35 & 0xFFFFFFFFFFFFFFFCLL;
    v70 = (double *)(v36 + 32);
    v71 = 0uLL;
    v72 = v35 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      *(_QWORD *)&v166.val[1].f64[0] = v70 - 4;
      *(_QWORD *)&v166.val[1].f64[1] = v70 - 2;
      v73 = v70;
      v74 = v70 + 2;
      v166.val[0] = 0uLL;
      vst2q_f64(*(double **)&v166.val[1].f64[0], v166);
      vst2q_f64(v70, *(float64x2x2_t *)&v71);
      v70 += 8;
      v72 -= 4;
    }
    while (v72);
    v38 = v35 & 0xFFFFFFFC;
    if (v35 != v37)
      goto LABEL_71;
  }
LABEL_73:
  *(_OWORD *)(v30 + 104) = *(_OWORD *)(v8 + 5);
  *(_OWORD *)(v30 + 120) = *(_OWORD *)(v8 + 7);
  *((_QWORD *)v30 + 17) = v8[9];
  *((_QWORD *)v30 + 33) = 0;
  *(_DWORD *)v30 = 0;
  *((_QWORD *)v30 + 35) = 0;
  *((_QWORD *)v30 + 36) = 0;
  *((_QWORD *)v30 + 46) = 0;
  *((_QWORD *)v30 + 47) = v30 + 368;
  *((_DWORD *)v30 + 18) = *((_DWORD *)v8 + 2);
  uuid_generate_random((unsigned __int8 *)v30 + 224);
  snprintf(v30 + 160, 0x40uLL, "%s.region.%s.%s", "NWSlab", (const char *)*v8, a2);
  if (gLogDatapath)
  {
    v112 = __nwlog_obj();
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v156 = "nw_mem_region_create";
      v157 = 2082;
      *(_QWORD *)v158 = v30 + 160;
      *(_WORD *)&v158[8] = 2048;
      *(_QWORD *)v159 = v30;
      _os_log_impl(&dword_182FBE000, v112, OS_LOG_TYPE_DEBUG, "%{public}s \"%{public}s\": nwr %p ", buf, 0x20u);
    }
  }
  *((_DWORD *)v30 + 19) = v29;
  if ((v29 & 0x10) != 0)
    *((_DWORD *)v30 + 60) |= 0x10u;
  if ((v29 & 0x20) != 0)
    *((_DWORD *)v30 + 60) |= 0x20u;
  v41 = *((_QWORD *)v30 + 12) + 63;
  *((_QWORD *)v30 + 39) = v41 >> 6;
  v42 = (v41 >> 3) & 0x1FFFFFF8;
  if (!v42)
  {
    v113 = __nwlog_obj();
    os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v156 = "strict_calloc";
    v114 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v114);
    if (result)
      goto LABEL_216;
    free(v114);
  }
  v43 = malloc_type_calloc(1uLL, v42, 0xEAFB8F1AuLL);
  if (!v43)
  {
    v115 = __nwlog_obj();
    os_log_type_enabled(v115, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v156 = "strict_calloc";
    v157 = 2048;
    *(_QWORD *)v158 = 1;
    *(_WORD *)&v158[8] = 2048;
    *(_QWORD *)v159 = v42;
    v116 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v116);
    if (result)
      goto LABEL_216;
    free(v116);
  }
  *((_QWORD *)v30 + 38) = v43;
  memset(v43, 255, ((*((_DWORD *)v30 + 24) + 63) >> 3) & 0x1FFFFFF8);
  ++*((_DWORD *)v30 + 1);
  os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_region_lock);
  *((_QWORD *)v30 + 18) = 0;
  v44 = (_QWORD *)qword_1ECD84A48;
  *((_QWORD *)v30 + 19) = qword_1ECD84A48;
  *v44 = v30;
  qword_1ECD84A48 = (uint64_t)(v30 + 144);
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_region_lock);
  if (gLogDatapath)
  {
    v117 = __nwlog_obj();
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
    {
      v118 = *((_QWORD *)v30 + 11);
      v119 = *((_QWORD *)v30 + 12);
      v120 = *((_QWORD *)v30 + 15);
      v121 = *((_QWORD *)v30 + 16);
      v122 = *((_DWORD *)v30 + 19);
      *(_DWORD *)buf = 136447490;
      v156 = "nw_mem_region_create";
      v157 = 1024;
      *(_DWORD *)v158 = v118;
      *(_WORD *)&v158[4] = 1024;
      *(_DWORD *)&v158[6] = v119;
      *(_WORD *)v159 = 1024;
      *(_DWORD *)&v159[2] = v120;
      *(_WORD *)&v159[6] = 1024;
      *(_DWORD *)&v159[8] = v121;
      *(_WORD *)&v159[12] = 1024;
      *(_DWORD *)&v159[14] = v122;
      _os_log_impl(&dword_182FBE000, v117, OS_LOG_TYPE_DEBUG, "%{public}s   [TOTAL] seg (%u*%u) obj (%u*%u) cflags 0x%u", buf, 0x2Au);
    }
  }
  v8[10] = v30;
  v45 = v8[7];
  v46 = *((_QWORD *)v30 + 11);
  v47 = malloc_type_zone_calloc((malloc_zone_t *)g_slab_zone, 1uLL, 0x308uLL, 0x61BC51D5uLL);
  if (!v47)
  {
    v123 = __nwlog_obj();
    os_log_type_enabled(v123, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v156 = "strict_malloc_zone_calloc";
    v157 = 2048;
    *(_QWORD *)v158 = 1;
    *(_WORD *)&v158[8] = 2048;
    *(_QWORD *)v159 = 776;
    v124 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v124);
    if (result)
      goto LABEL_216;
    free(v124);
  }
  v48 = (-8 - (_QWORD)v47) & 0xFFFFFFFFFFFFFF80;
  *(_QWORD *)(v48 ^ 0xFFFFFFFFFFFFFFF8) = v47;
  if (v46 <= 7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v156 = "nw_mem_cache_create";
    v157 = 2082;
    *(_QWORD *)v158 = "nw_mem_cache_create";
    *(_WORD *)&v158[8] = 2048;
    *(_QWORD *)v159 = 8;
    v49 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v49);
    if (result)
      goto LABEL_216;
    free(v49);
  }
  v51 = -(uint64_t)v48;
  v52 = nw_mem_debug;
  if ((nw_mem_debug & 1) != 0)
    *(_DWORD *)(176 - v48) |= 1u;
  if ((v52 & 2) != 0)
    *(_DWORD *)(176 - v48) |= 2u;
  snprintf((char *)(96 - v48), 0x40uLL, "NWSlab.mem.%s", a2);
  *(_QWORD *)(160 - v48) = v45;
  *(_QWORD *)(168 - v48) = 8;
  *(_OWORD *)(184 - v48) = 0u;
  *(_OWORD *)(200 - v48) = 0u;
  *(_QWORD *)(248 - v48) = v46;
  *(_QWORD *)(216 - v48) = v30;
  ++*((_DWORD *)v30 + 1);
  v53 = *((_QWORD *)v30 + 15);
  *(_QWORD *)(240 - v48) = v53;
  v54 = -(uint64_t)(-v45 & 0xFFFFFFFFFFFFFFF8);
  if (v53 >= v54)
  {
LABEL_92:
    *(_QWORD *)(232 - v48) = v54;
    *(_DWORD *)(224 - v48) = 0;
    *(_QWORD *)(296 - v48) = 0;
    *(_QWORD *)(304 - v48) = 296 - v48;
    *(_QWORD *)(312 - v48) = 0;
    *(_QWORD *)(320 - v48) = 312 - v48;
    *(_OWORD *)(256 - v48) = xmmword_183C6F200;
    v56 = nw_calloc_type<nw_mem_bufctl_bkt>(0x40uLL);
    *(_QWORD *)(280 - v48) = *(_QWORD *)(256 - v48) - 1;
    *(_QWORD *)(288 - v48) = v56;
    *(_QWORD *)(272 - v48) = flsll(v54) - 1;
    v57 = *(_QWORD *)(280 - v48);
    v58 = v57 + 1;
    if (v57 != -1)
    {
      v59 = *(_QWORD *)(288 - v48);
      if (v58 >= 0xA)
      {
        v61 = 0;
        v60 = 0;
        if ((_DWORD)v57 != -1 && !HIDWORD(v57))
        {
          v60 = v58 & 0xFFFFFFFFFFFFFFFCLL;
          v75 = *(_OWORD **)(288 - v48);
          v76 = v58 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            *v75 = 0uLL;
            v75[1] = 0uLL;
            v75 += 2;
            v76 -= 4;
          }
          while (v76);
          v61 = v58 & 0xFFFFFFFC;
          if (v58 == v60)
            goto LABEL_97;
        }
      }
      else
      {
        v60 = 0;
        v61 = 0;
      }
      v62 = v61 + 1;
      do
      {
        *(_QWORD *)(v59 + 8 * v60) = 0;
        v60 = v62++;
      }
      while (v58 > v60);
    }
LABEL_97:
    *(_DWORD *)(328 - v48) = 0;
    p_flags = &value witness table for NWEndpoint.flags;
    do
    {
      v64 = *((_QWORD *)p_flags + 12);
      p_flags += 22;
    }
    while (v64 >= v54);
    *(_QWORD *)(336 - v48) = p_flags;
    *(_DWORD *)(512 - v48) = 0;
    *(_QWORD *)(552 - v48) = -1;
    os_unfair_lock_lock(&nw_mem_cache_lock);
    *(_QWORD *)(80 - v48) = 0;
    v65 = (uint64_t *)qword_1ECD84A28;
    *(_QWORD *)(88 - v48) = qword_1ECD84A28;
    *v65 = v51;
    qword_1ECD84A28 = 80 - v48;
    os_unfair_lock_unlock(&nw_mem_cache_lock);
    if (gLogDatapath)
    {
      v127 = __nwlog_obj();
      if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
      {
        v128 = *(_DWORD *)(176 - v48);
        *(_DWORD *)buf = 136446978;
        v156 = "nw_mem_cache_create";
        v157 = 2082;
        *(_QWORD *)v158 = 96 - v48;
        *(_WORD *)&v158[8] = 2048;
        *(_QWORD *)v159 = -(uint64_t)v48;
        *(_WORD *)&v159[8] = 1024;
        *(_DWORD *)&v159[10] = v128;
        _os_log_impl(&dword_182FBE000, v127, OS_LOG_TYPE_DEBUG, "%{public}s \"%{public}s\": nwm %p mode 0x%X", buf, 0x26u);
      }
      if (gLogDatapath)
      {
        v129 = __nwlog_obj();
        if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
        {
          v130 = *(_QWORD *)(160 - v48);
          v131 = *(_QWORD *)(168 - v48);
          v132 = *(_QWORD *)(232 - v48);
          v133 = *(_QWORD *)(240 - v48);
          v134 = *(_QWORD *)(248 - v48);
          *(_DWORD *)buf = 136447490;
          v156 = "nw_mem_cache_create";
          v157 = 1024;
          *(_DWORD *)v158 = v130;
          *(_WORD *)&v158[4] = 1024;
          *(_DWORD *)&v158[6] = v131;
          *(_WORD *)v159 = 1024;
          *(_DWORD *)&v159[2] = v132;
          *(_WORD *)&v159[6] = 1024;
          *(_DWORD *)&v159[8] = v133;
          *(_WORD *)&v159[12] = 1024;
          *(_DWORD *)&v159[14] = v134;
          _os_log_impl(&dword_182FBE000, v129, OS_LOG_TYPE_DEBUG, "%{public}s   bufsz %u align %u chunksz %u objsz %u slabsz %u", buf, 0x2Au);
        }
      }
    }
    if (nw_mem_cache_ready == 1 && (*(_BYTE *)(176 - v48) & 1) == 0)
    {
      *(_DWORD *)(560 - v48) = **(_DWORD **)(336 - v48);
      if (gLogDatapath)
      {
        v141 = __nwlog_obj();
        if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
        {
          v142 = *(_QWORD *)(232 - v48);
          v143 = *(_DWORD *)(560 - v48);
          *(_DWORD *)buf = 136446978;
          v156 = "nw_mem_cache_magazine_enable";
          v157 = 2048;
          *(_QWORD *)v158 = -(uint64_t)v48;
          *(_WORD *)&v158[8] = 1024;
          *(_DWORD *)v159 = v142;
          *(_WORD *)&v159[4] = 1024;
          *(_DWORD *)&v159[6] = v143;
          _os_log_impl(&dword_182FBE000, v141, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p chunksize %u magsize %d", buf, 0x22u);
        }
      }
    }
    v8[11] = v51;
    if (v48)
    {
      v66 = 0;
      v67 = v8 + 12;
      v68 = 64;
      while (1)
      {
        v69 = a2[v66];
        *((_BYTE *)v67 + v66) = v69;
        if (!v69)
          break;
        --v68;
        ++v66;
        if (v68 <= 1)
        {
          *((_BYTE *)v67 + v66) = 0;
          return (BOOL)v8;
        }
      }
      return (BOOL)v8;
    }
    nw_mem_buffer_manager_close(v8);
    return 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446978;
  v156 = "nw_mem_cache_create";
  v157 = 2048;
  *(_QWORD *)v158 = v45;
  *(_WORD *)&v158[8] = 2048;
  *(_QWORD *)v159 = -(uint64_t)(-v45 & 0xFFFFFFFFFFFFFFF8);
  *(_WORD *)&v159[8] = 2048;
  *(_QWORD *)&v159[10] = v53;
  v55 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v55);
  if (!result)
  {
    free(v55);
    goto LABEL_92;
  }
LABEL_216:
  __break(1u);
  return result;
}

BOOL nw_calloc_type<nw_mem_bufctl_bkt>(size_t count)
{
  void *v2;
  _BOOL8 result;
  NSObject *v4;
  void *v5;
  NSObject *v6;
  void *v7;

  if (!count || count >> 61)
  {
    v4 = __nwlog_obj();
    os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    v5 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v5);
    if (result)
      goto LABEL_9;
    free(v5);
  }
  v2 = malloc_type_calloc(count, 8uLL, 0xEAFB8F1AuLL);
  if (v2)
    return (BOOL)v2;
  v6 = __nwlog_obj();
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  v7 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    return (BOOL)v2;
  }
LABEL_9:
  __break(1u);
  return result;
}

void nw_mem_depot_ws_reap(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  _QWORD *v8;
  unsigned int v9;
  unsigned int *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  void (*v14)(unint64_t, _QWORD);
  _QWORD *v15;
  unsigned int v16;

  v2 = *(_DWORD *)(a1 + 368);
  v3 = *(_DWORD *)(a1 + 364);
  if (v2 >= v3)
    v4 = v3;
  else
    v4 = v2;
  if ((_DWORD)v4)
  {
    do
    {
      v8 = *(_QWORD **)(a1 + 352);
      if (!v8)
        break;
      *(_QWORD *)(a1 + 352) = *v8;
      v9 = *(_DWORD *)(a1 + 360) - 1;
      *(_DWORD *)(a1 + 360) = v9;
      if (v9 < *(_DWORD *)(a1 + 364))
        *(_DWORD *)(a1 + 364) = v9;
      v10 = *(unsigned int **)(a1 + 336);
      ++*(_QWORD *)(a1 + 344);
      v11 = *v10;
      if ((int)v11 >= 1)
      {
        v12 = v8 + 1;
        do
        {
          v13 = *v12;
          v14 = *(void (**)(unint64_t, _QWORD))(a1 + 192);
          if (v14)
            v14(*v12, *(_QWORD *)(a1 + 208));
          nw_mem_slab_free(a1, v13);
          ++v12;
          --v11;
        }
        while (v11);
      }
      --v4;
      malloc_zone_free((malloc_zone_t *)g_slab_zone, v8);
    }
    while (v4);
  }
  v5 = *(_DWORD *)(a1 + 400);
  v6 = *(_DWORD *)(a1 + 396);
  if (v5 >= v6)
    v7 = v6;
  else
    v7 = v5;
  if ((_DWORD)v7)
  {
    do
    {
      v15 = *(_QWORD **)(a1 + 384);
      if (!v15)
        break;
      *(_QWORD *)(a1 + 384) = *v15;
      v16 = *(_DWORD *)(a1 + 392) - 1;
      *(_DWORD *)(a1 + 392) = v16;
      if (v16 < *(_DWORD *)(a1 + 396))
        *(_DWORD *)(a1 + 396) = v16;
      --v7;
      ++*(_QWORD *)(a1 + 376);
      malloc_zone_free((malloc_zone_t *)g_slab_zone, v15);
    }
    while (v7);
  }
}

void nw_mem_cache_magazine_purge(uint64_t a1)
{
  unint64_t *v2;
  unint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  void (*v8)(unint64_t, _QWORD);
  unint64_t *v9;
  unint64_t v10;
  void (*v11)(unint64_t, _QWORD);
  int v12;
  int v13;
  NSObject *v14;
  int v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v14 = __nwlog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v15 = 136446466;
      v16 = "nw_mem_cache_magazine_purge";
      v17 = 2048;
      v18 = a1;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p", (uint8_t *)&v15, 0x16u);
    }
  }
  v2 = *(unint64_t **)(a1 + 520);
  v3 = *(unint64_t **)(a1 + 528);
  v4 = *(unsigned int *)(a1 + 552);
  v5 = *(unsigned int *)(a1 + 556);
  *(_QWORD *)(a1 + 528) = 0;
  *(_QWORD *)(a1 + 520) = 0;
  *(_DWORD *)(a1 + 560) = 0;
  *(_QWORD *)(a1 + 552) = -1;
  if (v2)
  {
    if ((int)v4 >= 1)
    {
      v6 = v2 + 1;
      do
      {
        v7 = *v6;
        v8 = *(void (**)(unint64_t, _QWORD))(a1 + 192);
        if (v8)
          v8(*v6, *(_QWORD *)(a1 + 208));
        nw_mem_slab_free(a1, v7);
        ++v6;
        --v4;
      }
      while (v4);
    }
    malloc_zone_free((malloc_zone_t *)g_slab_zone, v2);
  }
  if (v3)
  {
    if ((int)v5 >= 1)
    {
      v9 = v3 + 1;
      do
      {
        v10 = *v9;
        v11 = *(void (**)(unint64_t, _QWORD))(a1 + 192);
        if (v11)
          v11(*v9, *(_QWORD *)(a1 + 208));
        nw_mem_slab_free(a1, v10);
        ++v9;
        --v5;
      }
      while (v5);
    }
    malloc_zone_free((malloc_zone_t *)g_slab_zone, v3);
  }
  v12 = *(_DWORD *)(a1 + 360);
  *(_DWORD *)(a1 + 368) = v12;
  *(_DWORD *)(a1 + 364) = v12;
  v13 = *(_DWORD *)(a1 + 392);
  *(_DWORD *)(a1 + 400) = v13;
  *(_DWORD *)(a1 + 396) = v13;
  nw_mem_depot_ws_reap(a1);
}

void nw_mem_slab_free(uint64_t a1, unint64_t a2)
{
  _QWORD **v4;
  _QWORD **v5;
  _QWORD *i;
  char *v7;
  void *v8;
  _QWORD *v9;
  _QWORD **v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *j;
  NSObject *v25;
  void *v26;
  NSObject *v27;
  NSObject *v28;
  int v29;
  unint64_t v30;
  _BYTE v31[38];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  ++*(_QWORD *)(a1 + 56);
  v4 = (_QWORD **)(*(_QWORD *)(a1 + 288) + 8 * ((a2 >> *(_QWORD *)(a1 + 272)) & *(_QWORD *)(a1 + 280)));
  v5 = v4;
  do
  {
    v5 = (_QWORD **)*v5;
    if (!v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v31 = 136446722;
      *(_QWORD *)&v31[4] = "nw_mem_slab_free";
      *(_WORD *)&v31[12] = 2048;
      *(_QWORD *)&v31[14] = a2;
      *(_WORD *)&v31[22] = 2048;
      *(_QWORD *)&v31[24] = a1;
      v8 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort((uint64_t)v8))
      {
        free(v8);
        v5 = 0;
        v7 = 0;
        goto LABEL_9;
      }
      goto LABEL_42;
    }
  }
  while (v5[1] != (_QWORD *)a2);
  for (i = *v4; i != v5; i = (_QWORD *)*i)
    v4 = (_QWORD **)i;
  *v4 = *v5;
  v7 = (char *)v5[3];
LABEL_9:
  if (a2 - *((_QWORD *)v7 + 3) >= *(_QWORD *)(*((_QWORD *)v7 + 2) + 248))
  {
    v25 = __nwlog_obj();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v31 = 136446466;
    *(_QWORD *)&v31[4] = "nw_mem_slab_free";
    *(_WORD *)&v31[12] = 2082;
    *(_QWORD *)&v31[14] = "VERIFY NW_MEM_SLAB_MEMBER(sl, buf) failed";
    v26 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v26))
    {
      free(v26);
      if ((*(_BYTE *)(a1 + 176) & 2) != 0)
        goto LABEL_36;
      goto LABEL_11;
    }
LABEL_42:
    __break(1u);
    return;
  }
  if ((*(_BYTE *)(a1 + 176) & 2) == 0)
    goto LABEL_11;
LABEL_36:
  *(_QWORD *)v31 = 0;
  *(_QWORD *)&v31[8] = 0;
  gettimeofday((timeval *)v31, 0);
  v5[4] = (_QWORD *)(1000 * *(_QWORD *)v31 + *(_DWORD *)&v31[8] / 1000);
  *((_DWORD *)v5 + 11) = backtrace((void **)v5 + 6, 16);
LABEL_11:
  v10 = (_QWORD **)(v7 + 56);
  v9 = (_QWORD *)*((_QWORD *)v7 + 7);
  *v5 = v9;
  *((_QWORD *)v7 + 7) = v5;
  v11 = *((_DWORD *)v7 + 16) - 1;
  *((_DWORD *)v7 + 16) = v11;
  if (v11)
  {
    if (!v9)
    {
      v12 = *(_QWORD *)v7;
      v13 = (_QWORD *)*((_QWORD *)v7 + 1);
      if (*(_QWORD *)v7)
      {
        *(_QWORD *)(v12 + 8) = v13;
        v13 = (_QWORD *)*((_QWORD *)v7 + 1);
      }
      else
      {
        *(_QWORD *)(a1 + 320) = v13;
      }
      *v13 = v12;
      v17 = *(_QWORD *)(a1 + 296);
      *(_QWORD *)v7 = v17;
      if (v17)
        v18 = (_QWORD *)(v17 + 8);
      else
        v18 = (_QWORD *)(a1 + 304);
      *v18 = v7;
      *(_QWORD *)(a1 + 296) = v7;
      *((_QWORD *)v7 + 1) = a1 + 296;
    }
    return;
  }
  v14 = *((unsigned int *)v7 + 17);
  v15 = *(_QWORD *)v7;
  v16 = (_QWORD *)*((_QWORD *)v7 + 1);
  if ((_DWORD)v14 != 1)
  {
    if (!v15)
    {
      *(_QWORD *)(a1 + 304) = v16;
      goto LABEL_26;
    }
    goto LABEL_19;
  }
  if (v15)
  {
LABEL_19:
    *(_QWORD *)(v15 + 8) = v16;
    v16 = (_QWORD *)*((_QWORD *)v7 + 1);
    goto LABEL_26;
  }
  *(_QWORD *)(a1 + 320) = v16;
LABEL_26:
  *v16 = v15;
  *(_QWORD *)(a1 + 8) -= v14;
  ++*(_QWORD *)(a1 + 40);
  v19 = *((_QWORD *)v7 + 3);
  v20 = *((_QWORD *)v7 + 4);
  if (gLogDatapath)
  {
    v27 = __nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v31 = 136446722;
      *(_QWORD *)&v31[4] = "nw_mem_slab_destroy";
      *(_WORD *)&v31[12] = 2048;
      *(_QWORD *)&v31[14] = a1;
      *(_WORD *)&v31[22] = 2048;
      *(_QWORD *)&v31[24] = v7;
      _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p sl %p", v31, 0x20u);
    }
    if (gLogDatapath)
    {
      v28 = __nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        v29 = *(_DWORD *)(*((_QWORD *)v7 + 5) + 40);
        v30 = v19 + *(_QWORD *)(a1 + 240);
        *(_DWORD *)v31 = 136446978;
        *(_QWORD *)&v31[4] = "nw_mem_slab_destroy";
        *(_WORD *)&v31[12] = 1024;
        *(_DWORD *)&v31[14] = v29;
        *(_WORD *)&v31[18] = 2048;
        *(_QWORD *)&v31[20] = v19;
        *(_WORD *)&v31[28] = 2048;
        *(_QWORD *)&v31[30] = v30;
        _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s   [%u] [%p-%p)", v31, 0x26u);
      }
    }
  }
  v21 = *v10;
  if (*v10)
  {
    do
    {
      v23 = *v10;
      for (j = v7 + 56; v23 != v21; v23 = (_QWORD *)*v23)
        j = v23;
      v22 = (_QWORD *)*v21;
      *j = *v21;
      malloc_zone_free((malloc_zone_t *)g_slab_zone, v21);
      v21 = v22;
    }
    while (v22);
  }
  malloc_zone_free((malloc_zone_t *)g_slab_zone, v7);
  nw_mem_region_free(*(_QWORD *)(a1 + 216), v19, v20);
}

void nw_mem_cache_stats_dump(void)
{
  _QWORD *v0;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  _QWORD *v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (nw_mem_dump_slab_stats)
  {
    os_unfair_lock_lock(&nw_mem_cache_lock);
    v0 = (_QWORD *)nw_mem_cache_head;
    if (nw_mem_cache_head)
    {
      do
      {
        v1 = __nwlog_obj();
        if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
        {
          v2 = v0[4];
          v3 = v0[5];
          v4 = v0[67];
          v5 = v0[68];
          *(_DWORD *)buf = 136447490;
          v7 = "nw_mem_cache_stats_dump";
          v8 = 2082;
          v9 = v0 + 12;
          v10 = 2048;
          v11 = v2;
          v12 = 2048;
          v13 = v3;
          v14 = 2048;
          v15 = v4;
          v16 = 2048;
          v17 = v5;
          _os_log_impl(&dword_182FBE000, v1, OS_LOG_TYPE_INFO, "%{public}s \n\n%{public}s: \n\tNumber of Slabs created %llu\n\tNumber of Slabs destroyed %llu\n\tNumber of Cache Allocs %llu\n\tNumber of Cache Frees %llu", buf, 0x3Eu);
        }
        v0 = (_QWORD *)v0[10];
      }
      while (v0);
    }
    os_unfair_lock_unlock(&nw_mem_cache_lock);
    nw_mem_region_stats_dump();
  }
}

void nw_parameters_set_source_application(void *a1, __int128 *a2)
{
  char *v3;
  _QWORD *v4;
  __int128 v5;
  int v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  _OWORD buffer[3];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = *a2;
    *(_OWORD *)(v3 + 56) = a2[1];
    *(_OWORD *)(v3 + 40) = v5;
    v6 = *((_DWORD *)a2 + 5);
    *(_DWORD *)(*((_QWORD *)v3 + 13) + 64) = v6;
    *(_DWORD *)(*((_QWORD *)v3 + 13) + 68) = *((_DWORD *)a2 + 1);
    v24 = 0;
    memset(buffer, 0, sizeof(buffer));
    v7 = proc_pidinfo(v6, 17, 1uLL, buffer, 56);
    v8 = v4[12];
    if (v7 == 56)
    {
      v4[12] = v8 & 0xFFFFFFFFFFFFDFFFLL;
      *(_OWORD *)(v4[13] + 24) = buffer[0];
    }
    else
    {
      v4[12] = v8 | 0x2000;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_parameters_set_source_application";
        v21 = 1024;
        v22 = v6;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Failed to convert from PID (%d) to UUID. This could lead to incorrect policies and accounting.", buf, 0x12u);
      }

    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(buffer[0]) = 136446210;
  *(_QWORD *)((char *)buffer + 4) = "nw_parameters_set_source_application";
  v11 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  v18 = 0;
  if (__nwlog_fault(v11, buf, &v18))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = buf[0];
      if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
      {
        LODWORD(buffer[0]) = 136446210;
        *(_QWORD *)((char *)buffer + 4) = "nw_parameters_set_source_application";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null parameters", (uint8_t *)buffer, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = buf[0];
      v16 = os_log_type_enabled(v12, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v16)
        {
          LODWORD(buffer[0]) = 136446466;
          *(_QWORD *)((char *)buffer + 4) = "nw_parameters_set_source_application";
          WORD6(buffer[0]) = 2082;
          *(_QWORD *)((char *)buffer + 14) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null parameters, dumping backtrace:%{public}s", (uint8_t *)buffer, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v16)
      {
        LODWORD(buffer[0]) = 136446210;
        *(_QWORD *)((char *)buffer + 4) = "nw_parameters_set_source_application";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null parameters, no backtrace", (uint8_t *)buffer, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = buf[0];
      if (os_log_type_enabled(v12, (os_log_type_t)buf[0]))
      {
        LODWORD(buffer[0]) = 136446210;
        *(_QWORD *)((char *)buffer + 4) = "nw_parameters_set_source_application";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null parameters, backtrace limit exceeded", (uint8_t *)buffer, 0xCu);
      }
    }

  }
LABEL_24:
  if (v11)
    free(v11);
LABEL_7:

}

void sub_1831F9684(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL __nw_protocol_ip_identifier_block_invoke()
{
  *(_QWORD *)&algn_1ECD84D2B[8] = 0;
  *(_QWORD *)algn_1ECD84D2B = 0;
  qword_1ECD84D40 = 0;
  *(_QWORD *)&algn_1ECD84D2B[16] = 0;
  strcpy((char *)&nw_protocol_ip_identifier::identifier, "ip");
  qword_1ECD84D48 = 0x100000002;
  flowhash_seed = arc4random();
  return nw_protocol_register_extended(&nw_protocol_ip_identifier::identifier, (uint64_t)nw_protocol_ip_create);
}

_QWORD *initializeBufferWithCopyOfBuffer for NWInterface(_QWORD *a1, _QWORD *a2)
{
  *a1 = *a2;
  swift_unknownObjectRetain();
  return a1;
}

uint64_t sub_1831F9774()
{
  uint64_t result;
  unint64_t v1;

  result = sub_183B913A4();
  if (v1 <= 0x3F)
  {
    swift_initEnumMetadataMultiPayload();
    return 0;
  }
  return result;
}

void nw_protocol_definition_set_options_should_serialize(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_options_should_serialize";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_should_serialize";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_options_should_serialize";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_should_serialize";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_should_serialize";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    *(_QWORD *)(*((_QWORD *)v3 + 10) + 248) = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_options_should_serialize";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_should_serialize";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null should_serialize", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_should_serialize";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null should_serialize, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_should_serialize";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null should_serialize, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_options_should_serialize";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null should_serialize, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

NWConcrete_nw_interface *nw_interface_create_with_name(char *a1)
{
  unsigned int v2;
  NSObject *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_interface_create_with_name";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_interface_create_with_name";
        v9 = "%{public}s called with null interface_name";
LABEL_21:
        _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v15 = "nw_interface_create_with_name";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_name, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (!v11)
          goto LABEL_22;
        *(_DWORD *)buf = 136446210;
        v15 = "nw_interface_create_with_name";
        v9 = "%{public}s called with null interface_name, no backtrace";
        goto LABEL_21;
      }
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_interface_create_with_name";
        v9 = "%{public}s called with null interface_name, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_22:

LABEL_23:
    if (v6)
      free(v6);
    return 0;
  }
  v2 = if_nametoindex(a1);
  if (v2)
    return nw_interface_create_with_index_and_name(v2, (unsigned __int8 *)a1);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v15 = "nw_interface_create_with_name";
    v16 = 2082;
    v17 = a1;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s Failed to find interface index for %{public}s", buf, 0x16u);
  }

  return 0;
}

NWConcrete_nw_interface *nw_interface_create_with_index_and_name(unsigned int a1, unsigned __int8 *a2)
{
  NSObject *v4;
  NWConcrete_nw_interface *v5;
  NWConcrete_nw_interface *v6;
  NWConcrete_nw_interface *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  NWConcrete_nw_interface *v33;
  NWConcrete_nw_interface *v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  id v39;
  void *v40;
  NSObject *v41;
  os_log_type_t v42;
  int v43;
  id v44;
  os_log_type_t v45;
  char *v46;
  os_log_type_t v47;
  _BOOL4 v48;
  const char *v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  os_log_type_t v53;
  os_log_type_t v54;
  unsigned int v55;
  os_log_type_t v56;
  void *v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  void *v62;
  os_log_type_t v63;
  char *backtrace_string;
  os_log_type_t v65;
  _BOOL4 v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  os_log_type_t v71;
  char v72;
  os_log_type_t type;
  uint8_t buf[40];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
    v59 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v72 = 0;
    if (!__nwlog_fault(v59, &type, &v72))
      goto LABEL_145;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s called with null interface_index", buf, 0xCu);
      }
    }
    else if (v72)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v65 = type;
      v66 = os_log_type_enabled(v60, type);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v60, v65, "%{public}s called with null interface_index, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_145;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_182FBE000, v60, v65, "%{public}s called with null interface_index, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v70 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_182FBE000, v60, v70, "%{public}s called with null interface_index, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_144:

    goto LABEL_145;
  }
  if (a2)
  {
    if (a1 >= 0x7FFFFFFF)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a1;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = 0x7FFFFFFF;
        *(_WORD *)&buf[24] = 2082;
        *(_QWORD *)&buf[26] = a2;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s refusing to create an interface with index %u too high (>=%u) (name=\"%{public}s\")", buf, 0x22u);
      }

      return 0;
    }
    v6 = objc_alloc_init(NWConcrete_nw_interface);
    v7 = v6;
    if (v6)
    {
      v6->index = a1;
      v8 = *a2;
      v6->name[0] = v8;
      if (v8)
      {
        v9 = a2[1];
        v6->name[1] = v9;
        if (v9)
        {
          v10 = a2[2];
          v6->name[2] = v10;
          if (v10)
          {
            v11 = a2[3];
            v6->name[3] = v11;
            if (v11)
            {
              v12 = a2[4];
              v6->name[4] = v12;
              if (v12)
              {
                v13 = a2[5];
                v6->name[5] = v13;
                if (v13)
                {
                  v14 = a2[6];
                  v6->name[6] = v14;
                  if (v14)
                  {
                    v15 = a2[7];
                    v6->name[7] = v15;
                    if (v15)
                    {
                      v16 = a2[8];
                      v6->name[8] = v16;
                      if (v16)
                      {
                        v17 = a2[9];
                        v6->name[9] = v17;
                        if (v17)
                        {
                          v18 = a2[10];
                          v6->name[10] = v18;
                          if (v18)
                          {
                            v19 = a2[11];
                            v6->name[11] = v19;
                            if (v19)
                            {
                              v20 = a2[12];
                              v6->name[12] = v20;
                              if (v20)
                              {
                                v21 = a2[13];
                                v6->name[13] = v21;
                                if (v21)
                                {
                                  v22 = a2[14];
                                  v6->name[14] = v22;
                                  if (v22)
                                  {
                                    v23 = a2[15];
                                    v6->name[15] = v23;
                                    if (v23)
                                    {
                                      v24 = a2[16];
                                      v6->name[16] = v24;
                                      if (v24)
                                      {
                                        v25 = a2[17];
                                        v6->name[17] = v25;
                                        if (v25)
                                        {
                                          v26 = a2[18];
                                          v6->name[18] = v26;
                                          if (v26)
                                          {
                                            v27 = a2[19];
                                            v6->name[19] = v27;
                                            if (v27)
                                            {
                                              v28 = a2[20];
                                              v6->name[20] = v28;
                                              if (v28)
                                              {
                                                v29 = a2[21];
                                                v6->name[21] = v29;
                                                if (v29)
                                                {
                                                  v30 = a2[22];
                                                  v6->name[22] = v30;
                                                  if (v30)
                                                  {
                                                    v31 = a2[23];
                                                    v6->name[23] = v31;
                                                    if (v31)
                                                      v6->name[24] = 0;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v32 = socket(2, 2, 0);
      if ((v32 & 0x80000000) == 0)
      {
        v33 = v7;
        v34 = v33;
        memset(buf, 0, 32);
        buf[0] = v7->name[0];
        if (buf[0])
        {
          buf[1] = v33->name[1];
          if (buf[1])
          {
            buf[2] = v33->name[2];
            if (buf[2])
            {
              buf[3] = v33->name[3];
              if (buf[3])
              {
                buf[4] = v33->name[4];
                if (buf[4])
                {
                  buf[5] = v33->name[5];
                  if (buf[5])
                  {
                    buf[6] = v33->name[6];
                    if (buf[6])
                    {
                      buf[7] = v33->name[7];
                      if (buf[7])
                      {
                        buf[8] = v33->name[8];
                        if (buf[8])
                        {
                          buf[9] = v33->name[9];
                          if (buf[9])
                          {
                            buf[10] = v33->name[10];
                            if (buf[10])
                            {
                              buf[11] = v33->name[11];
                              if (buf[11])
                              {
                                buf[12] = v33->name[12];
                                if (buf[12])
                                {
                                  buf[13] = v33->name[13];
                                  if (buf[13])
                                    buf[14] = v33->name[14];
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (ioctl(v32, 0xC0206933uLL, buf) != -1)
          v34->details.mtu = *(_DWORD *)&buf[16];
        if (ioctl(v32, 0xC02069A0uLL, buf) != -1)
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFFFE | (*(_DWORD *)&buf[16] != 0);
        if (ioctl(v32, 0xC02069CCuLL, buf) != -1)
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFFFD | (2 * (*(_DWORD *)&buf[16] != 0));
        if (ioctl(v32, 0xC02069DAuLL, buf) != -1)
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFFFB | (4 * (*(_DWORD *)&buf[16] != 0));
        if (ioctl(v32, 0xC020699DuLL, buf) != -1)
          v34->delegate_index = *(_DWORD *)&buf[16];
        if (ioctl(v32, 0xC02069ADuLL, buf) != -1)
        {
          v35 = *(_DWORD *)&buf[16];
          v36 = 4;
          v37 = 2;
          switch(*(_DWORD *)&buf[16])
          {
            case 1:
            case 6:
              goto LABEL_95;
            case 2:
              v37 = 3;
              goto LABEL_99;
            case 3:
            case 4:
              v34->type = 1;
              v38 = v35 - 3;
              goto LABEL_96;
            case 5:
LABEL_99:
              v55 = 0;
              v34->type = v37;
              break;
            default:
              v36 = 0;
LABEL_95:
              v34->type = v36;
              v38 = v35 - 3;
              if (v38 > 4)
                v55 = 0;
              else
LABEL_96:
                v55 = dword_183C6F158[v38];
              break;
          }
          v34->subtype = v55;
        }
        if (ioctl(v32, 0xC0206911uLL, buf) != -1)
          *(_WORD *)((char *)&v34->details + 73) = *(_WORD *)((char *)&v34->details + 73) & 0xFDFF | (*(_WORD *)&buf[16] >> 6) & 0x200;

        close(v32);
        v5 = v34;
        goto LABEL_110;
      }
      v43 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v44 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v43;
      v40 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault((const char *)v40, &type, &v72))
      {
LABEL_107:
        if (!v40)
        {
LABEL_109:
          v5 = 0;
LABEL_110:

          return v5;
        }
LABEL_108:
        free(v40);
        goto LABEL_109;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        v45 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl(&dword_182FBE000, v41, v45, "%{public}s information socket creation failed %{darwin.errno}d", buf, 0x12u);
        }
      }
      else if (v72)
      {
        v49 = __nw_create_backtrace_string();
        if (v49)
        {
          v50 = (char *)v49;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v51 = (id)gLogObj;
          v52 = type;
          if (os_log_type_enabled(v51, type))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v43;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v50;
            _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s information socket creation failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v50);
          if (!v40)
            goto LABEL_109;
          goto LABEL_108;
        }
        __nwlog_obj();
        v41 = objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl(&dword_182FBE000, v41, v56, "%{public}s information socket creation failed %{darwin.errno}d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        v54 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v43;
          _os_log_impl(&dword_182FBE000, v41, v54, "%{public}s information socket creation failed %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
      v40 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault((const char *)v40, &type, &v72))
        goto LABEL_107;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s nw_interface_create failed", buf, 0xCu);
        }
      }
      else if (v72)
      {
        v46 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        v47 = type;
        v48 = os_log_type_enabled(v41, type);
        if (v46)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v46;
            _os_log_impl(&dword_182FBE000, v41, v47, "%{public}s nw_interface_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v46);
          if (!v40)
            goto LABEL_109;
          goto LABEL_108;
        }
        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_182FBE000, v41, v47, "%{public}s nw_interface_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        v53 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          _os_log_impl(&dword_182FBE000, v41, v53, "%{public}s nw_interface_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    goto LABEL_107;
  }
  __nwlog_obj();
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
  v59 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v72 = 0;
  if (__nwlog_fault(v59, &type, &v72))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v63 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_182FBE000, v60, v63, "%{public}s called with null interface_name", buf, 0xCu);
      }
    }
    else if (v72)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v68 = type;
      v69 = os_log_type_enabled(v60, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v67;
          _os_log_impl(&dword_182FBE000, v60, v68, "%{public}s called with null interface_name, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v67);
        if (!v59)
          return 0;
        goto LABEL_146;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_182FBE000, v60, v68, "%{public}s called with null interface_name, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v60 = objc_claimAutoreleasedReturnValue();
      v71 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_with_index_and_name";
        _os_log_impl(&dword_182FBE000, v60, v71, "%{public}s called with null interface_name, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_144;
  }
LABEL_145:
  if (v59)
LABEL_146:
    free(v59);
  return 0;
}

void sub_1831FB6F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_interface_create_from_necp(uint64_t a1, unsigned int a2)
{
  NSObject *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  NWConcrete_nw_interface *v7;
  NWConcrete_nw_interface *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  id v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  os_log_type_t v46;
  char *v47;
  os_log_type_t v48;
  _BOOL4 v49;
  unsigned int v51;
  unsigned int v52;
  __int16 v53;
  __int16 v54;
  __int16 v55;
  NWConcrete_nw_interface *v56;
  os_log_type_t v57;
  void *v58;
  NSObject *v59;
  os_log_type_t v60;
  char *backtrace_string;
  os_log_type_t v62;
  _BOOL4 v63;
  os_log_type_t v64;
  char v65;
  os_log_type_t type;
  unsigned int v67;
  uint8_t v68[4];
  const char *v69;
  __int16 v70;
  _QWORD v71[2];
  uint8_t buf[32];
  __int128 v73;
  __int128 v74;
  size_t __n[2];
  size_t v76[2];
  __int128 v77;
  int v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_interface_create_from_necp";
    v36 = (char *)_os_log_send_and_compose_impl();

    v68[0] = 16;
    LOBYTE(v67) = 0;
    if (!__nwlog_fault(v36, v68, &v67))
      goto LABEL_69;
    if (v68[0] == 17)
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v60 = v68[0];
      if (os_log_type_enabled(v59, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_from_necp";
        _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s called with null interface_index", buf, 0xCu);
      }
    }
    else if ((_BYTE)v67)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v62 = v68[0];
      v63 = os_log_type_enabled(v59, (os_log_type_t)v68[0]);
      if (backtrace_string)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_interface_create_from_necp";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v59, v62, "%{public}s called with null interface_index, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_69;
      }
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_from_necp";
        _os_log_impl(&dword_182FBE000, v59, v62, "%{public}s called with null interface_index, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v64 = v68[0];
      if (os_log_type_enabled(v59, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_interface_create_from_necp";
        _os_log_impl(&dword_182FBE000, v59, v64, "%{public}s called with null interface_index, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_69;
  }
  if (a2 >= 0x7FFFFFFF)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_interface_create_from_necp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = 0x7FFFFFFF;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s refusing to create an interface with index %u too high (>=%u)", buf, 0x18u);
    }

    return 0;
  }
  v67 = a2;
  v78 = 0;
  v77 = 0u;
  *(_OWORD *)__n = 0u;
  *(_OWORD *)v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  memset(buf, 0, sizeof(buf));
  if (!necp_client_action())
  {
    if (!*(_DWORD *)&buf[24])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v68 = 136446466;
        v69 = "nw_interface_create_from_necp";
        v70 = 1024;
        LODWORD(v71[0]) = a2;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s Copy interface failed to find valid interface for index %u", v68, 0x12u);
      }
      goto LABEL_10;
    }
    v7 = objc_alloc_init(NWConcrete_nw_interface);
    v8 = v7;
    if (v7)
    {
      v9 = buf[0];
      v7->name[0] = buf[0];
      if (v9)
      {
        v10 = buf[1];
        v7->name[1] = buf[1];
        if (v10)
        {
          v11 = buf[2];
          v7->name[2] = buf[2];
          if (v11)
          {
            v12 = buf[3];
            v7->name[3] = buf[3];
            if (v12)
            {
              v13 = buf[4];
              v7->name[4] = buf[4];
              if (v13)
              {
                v14 = buf[5];
                v7->name[5] = buf[5];
                if (v14)
                {
                  v15 = buf[6];
                  v7->name[6] = buf[6];
                  if (v15)
                  {
                    v16 = buf[7];
                    v7->name[7] = buf[7];
                    if (v16)
                    {
                      v17 = buf[8];
                      v7->name[8] = buf[8];
                      if (v17)
                      {
                        v18 = buf[9];
                        v7->name[9] = buf[9];
                        if (v18)
                        {
                          v19 = buf[10];
                          v7->name[10] = buf[10];
                          if (v19)
                          {
                            v20 = buf[11];
                            v7->name[11] = buf[11];
                            if (v20)
                            {
                              v21 = buf[12];
                              v7->name[12] = buf[12];
                              if (v21)
                              {
                                v22 = buf[13];
                                v7->name[13] = buf[13];
                                if (v22)
                                {
                                  v23 = buf[14];
                                  v7->name[14] = buf[14];
                                  if (v23)
                                  {
                                    v24 = buf[15];
                                    v7->name[15] = buf[15];
                                    if (v24)
                                    {
                                      v25 = buf[16];
                                      v7->name[16] = buf[16];
                                      if (v25)
                                      {
                                        v26 = buf[17];
                                        v7->name[17] = buf[17];
                                        if (v26)
                                        {
                                          v27 = buf[18];
                                          v7->name[18] = buf[18];
                                          if (v27)
                                          {
                                            v28 = buf[19];
                                            v7->name[19] = buf[19];
                                            if (v28)
                                            {
                                              v29 = buf[20];
                                              v7->name[20] = buf[20];
                                              if (v29)
                                              {
                                                v30 = buf[21];
                                                v7->name[21] = buf[21];
                                                if (v30)
                                                {
                                                  v31 = buf[22];
                                                  v7->name[22] = buf[22];
                                                  if (v31)
                                                    v7->name[23] = 0;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v7->index = *(_DWORD *)&buf[24];
      v32 = v73;
      v33 = 4;
      v34 = 2;
      switch((int)v73)
      {
        case 1:
        case 6:
          goto LABEL_74;
        case 2:
          v34 = 3;
          goto LABEL_78;
        case 3:
        case 4:
          v7->type = 1;
          v35 = v32 - 3;
          goto LABEL_75;
        case 5:
LABEL_78:
          v51 = 0;
          v7->type = v34;
          break;
        default:
          v33 = 0;
LABEL_74:
          v7->type = v33;
          v35 = v32 - 3;
          if (v35 > 4)
            v51 = 0;
          else
LABEL_75:
            v51 = dword_183C6F158[v35];
          break;
      }
      v7->subtype = v51;
      v52 = *(_DWORD *)&buf[28];
      v7->delegate_index = DWORD1(v73);
      v7->generation = v52;
      v7->details.mtu = HIDWORD(v73);
      *(_QWORD *)&v7->details.tso_max_segment_size_v4 = *(_QWORD *)((char *)&v77 + 4);
      v7->details.hwcsum_flags = HIDWORD(v77);
      *(_WORD *)((char *)&v7->details + 73) = (*(_WORD *)((char *)&v7->details + 73) & 0xFF80 | BYTE8(v73) & 1 | (WORD4(v73) >> 5) & 2 | (WORD4(v73) >> 12) & 4 | (8 * ((WORD4(v73) >> 1) & 7)) & 0xFFBF | (((WORD4(v73) >> 5) & 1) << 6)) ^ 0x10;
      memcpy(&v7->details, &v74, BYTE4(__n[0]));
      v8->details.ipv4_signature.signature_len = BYTE4(__n[0]);
      memcpy(&v8->details.ipv6_signature, (char *)__n + 5, BYTE1(v76[1]));
      v8->details.ipv6_signature.signature_len = BYTE1(v76[1]);
      v53 = WORD4(v73);
      v54 = *(_WORD *)((char *)&v8->details + 73) & 0xFF7F | BYTE8(v73) & 0x80;
      *(_WORD *)((char *)&v8->details + 73) = v54;
      if ((v53 & 0x80) != 0)
        v8->details.ipv4_netmask = HIDWORD(v76[1]);
      v55 = v54 & 0xFEFF | v53 & 0x100;
      *(_WORD *)((char *)&v8->details + 73) = v55;
      if ((v53 & 0x100) != 0)
        v8->details.ipv4_broadcast = v77;
      *(_WORD *)((char *)&v8->details + 73) = v55 & 0xC1FF | v53 & 0x3E00;
      v8->details.radio_type = v78;
      v56 = v8;
LABEL_92:

      return v8;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v42 = (id)gLogObj;
    *(_DWORD *)v68 = 136446210;
    v69 = "nw_interface_create_from_necp";
    v43 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (__nwlog_fault(v43, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v44 = (id)gLogObj;
        v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)v68 = 136446210;
          v69 = "nw_interface_create_from_necp";
          _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s nw_interface_create failed", v68, 0xCu);
        }
      }
      else if (v65)
      {
        v47 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        v49 = os_log_type_enabled(v44, type);
        if (v47)
        {
          if (v49)
          {
            *(_DWORD *)v68 = 136446466;
            v69 = "nw_interface_create_from_necp";
            v70 = 2082;
            v71[0] = v47;
            _os_log_impl(&dword_182FBE000, v44, v48, "%{public}s nw_interface_create failed, dumping backtrace:%{public}s", v68, 0x16u);
          }

          free(v47);
          goto LABEL_90;
        }
        if (v49)
        {
          *(_DWORD *)v68 = 136446210;
          v69 = "nw_interface_create_from_necp";
          _os_log_impl(&dword_182FBE000, v44, v48, "%{public}s nw_interface_create failed, no backtrace", v68, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v57 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)v68 = 136446210;
          v69 = "nw_interface_create_from_necp";
          _os_log_impl(&dword_182FBE000, v44, v57, "%{public}s nw_interface_create failed, backtrace limit exceeded", v68, 0xCu);
        }
      }

    }
LABEL_90:
    if (v43)
      free(v43);
    goto LABEL_92;
  }
  v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  v6 = v5;
  if (v4 != 2)
  {
    *(_DWORD *)v68 = 136446466;
    v69 = "nw_interface_create_from_necp";
    v70 = 1024;
    LODWORD(v71[0]) = v4;
    v36 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (__nwlog_fault(v36, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = (id)gLogObj;
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)v68 = 136446466;
          v69 = "nw_interface_create_from_necp";
          v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d", v68, 0x12u);
        }
      }
      else if (v65)
      {
        v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = (id)gLogObj;
        v40 = type;
        v41 = os_log_type_enabled(v37, type);
        if (v39)
        {
          if (v41)
          {
            *(_DWORD *)v68 = 136446722;
            v69 = "nw_interface_create_from_necp";
            v70 = 1024;
            LODWORD(v71[0]) = v4;
            WORD2(v71[0]) = 2082;
            *(_QWORD *)((char *)v71 + 6) = v39;
            _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, dumping backtrace:%{public}s", v68, 0x1Cu);
          }

          free(v39);
          if (!v36)
            return 0;
          goto LABEL_70;
        }
        if (v41)
        {
          *(_DWORD *)v68 = 136446466;
          v69 = "nw_interface_create_from_necp";
          v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, no backtrace", v68, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = (id)gLogObj;
        v46 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)v68 = 136446466;
          v69 = "nw_interface_create_from_necp";
          v70 = 1024;
          LODWORD(v71[0]) = v4;
          _os_log_impl(&dword_182FBE000, v37, v46, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d, backtrace limit exceeded", v68, 0x12u);
        }
      }

    }
LABEL_69:
    if (!v36)
      return 0;
LABEL_70:
    free(v36);
    return 0;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v68 = 136446466;
    v69 = "nw_interface_create_from_necp";
    v70 = 1024;
    LODWORD(v71[0]) = 2;
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_INTERFACE %{darwin.errno}d", v68, 0x12u);
  }
LABEL_10:

  return 0;
}

uint64_t ___ZL35http2_transport_create_output_frameP27nw_protocol_http2_transportP11nw_protocolj_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  char *v26;
  _BOOL4 v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  uint64_t v35;
  const char *v36;
  const char *v37;
  char *v38;
  _BOOL4 v39;
  uint64_t v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  const char *v49;
  uint64_t v50;
  const char *v51;
  uint64_t result;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  int v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  const char *v62;
  char *v63;
  _BOOL4 v64;
  uint64_t v65;
  int v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  const char *v74;
  uint64_t v75;
  _QWORD *v76;
  char *v77;
  _BOOL4 v78;
  char *backtrace_string;
  _BOOL4 v80;
  void *v81;
  int v82;
  NSObject *v83;
  uint64_t v84;
  BOOL v85;
  const char *v86;
  NSObject *v87;
  uint64_t v88;
  const char *v89;
  const char *v90;
  int v91;
  NSObject *v92;
  uint64_t v93;
  const char *v94;
  NSObject *v95;
  uint64_t v96;
  const char *v97;
  char v98;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v101;
  __int16 v102;
  void *v103;
  __int16 v104;
  _BYTE v105[10];
  unsigned int v106;
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
    {
      v4 = 0;
      v5 = 0;
    }
    else
    {
      v4 = *(_DWORD *)(a2 + 48);
      v5 = *(_QWORD *)(a2 + 112);
    }
    if (gLogDatapath)
    {
      v83 = __nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        v84 = *(_QWORD *)(a1 + 40);
        v85 = v84 == 0;
        *(_DWORD *)buf = 136446978;
        v86 = (const char *)(v84 + 205);
        v101 = "http2_transport_create_output_frame_block_invoke";
        if (v85)
          v86 = "";
        v102 = 2082;
        v103 = (void *)v86;
        v104 = 2048;
        *(_QWORD *)v105 = v5;
        *(_WORD *)&v105[8] = 1024;
        v106 = v4;
        _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s existing frame found, buffer %p, length %u", buf, 0x26u);
      }
    }
    v6 = *(_DWORD *)(a2 + 52);
    if (v6)
      v6 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
    if (v6 == v4)
    {
      if (v5 && v4)
      {
        if (http2_transport_candidate_frame_length_is_match(v4, *(_DWORD *)(a1 + 56)))
        {
          v8 = *(_QWORD *)(a2 + 16);
          v9 = *(_QWORD **)(a2 + 24);
          if (v8)
          {
            *(_QWORD *)(v8 + 24) = v9;
            v9 = *(_QWORD **)(a2 + 24);
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 40) + 184) = v9;
          }
          *v9 = v8;
          *(_QWORD *)(a2 + 16) = 0;
          *(_QWORD *)(a2 + 24) = 0;
          v65 = *(_QWORD *)(a1 + 40);
          v66 = *(_DWORD *)(v65 + 196);
          if (v66)
          {
            *(_DWORD *)(v65 + 196) = v66 - 1;
            goto LABEL_174;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v67 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v98 = 0;
          if (__nwlog_fault(v67, &type, &v98))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v68 = __nwlog_obj();
              v69 = type;
              if (!os_log_type_enabled(v68, type))
                goto LABEL_172;
              *(_DWORD *)buf = 136446210;
              v101 = "http2_transport_create_output_frame_block_invoke";
              v70 = "%{public}s http2_transport count attempted to decrement below zero";
              goto LABEL_171;
            }
            if (!v98)
            {
              v68 = __nwlog_obj();
              v69 = type;
              if (!os_log_type_enabled(v68, type))
                goto LABEL_172;
              *(_DWORD *)buf = 136446210;
              v101 = "http2_transport_create_output_frame_block_invoke";
              v70 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
              goto LABEL_171;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            v68 = __nwlog_obj();
            v69 = type;
            v80 = os_log_type_enabled(v68, type);
            if (backtrace_string)
            {
              if (v80)
              {
                *(_DWORD *)buf = 136446466;
                v101 = "http2_transport_create_output_frame_block_invoke";
                v102 = 2082;
                v103 = backtrace_string;
                _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(backtrace_string);
              goto LABEL_172;
            }
            if (v80)
            {
              *(_DWORD *)buf = 136446210;
              v101 = "http2_transport_create_output_frame_block_invoke";
              v70 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_171:
              _os_log_impl(&dword_182FBE000, v68, v69, v70, buf, 0xCu);
            }
          }
LABEL_172:
          if (v67)
            free(v67);
LABEL_174:
          if (gLogDatapath)
          {
            v87 = __nwlog_obj();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
            {
              v88 = *(_QWORD *)(a1 + 40);
              v89 = "";
              v90 = (const char *)(v88 + 205);
              v85 = v88 == 0;
              v91 = *(_DWORD *)(a1 + 56);
              if (!v85)
                v89 = v90;
              *(_DWORD *)buf = 136446978;
              v101 = "http2_transport_create_output_frame_block_invoke";
              v102 = 2082;
              v103 = (void *)v89;
              v104 = 1024;
              *(_DWORD *)v105 = v4;
              *(_WORD *)&v105[4] = 1024;
              *(_DWORD *)&v105[6] = v91;
              _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s reusing output frame of length %u, adjusting to %u", buf, 0x22u);
            }
            v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
              if (gLogDatapath)
              {
                v92 = __nwlog_obj();
                if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
                {
                  v93 = *(_QWORD *)(a1 + 40);
                  if (v93)
                    v94 = (const char *)(v93 + 205);
                  else
                    v94 = "";
                  *(_DWORD *)buf = 136446466;
                  v101 = "http2_transport_create_output_frame_block_invoke";
                  v102 = 2082;
                  v103 = (void *)v94;
                  _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s frame was exact match, not modifying", buf, 0x16u);
                }
              }
              goto LABEL_177;
            }
            if (gLogDatapath)
            {
              v95 = __nwlog_obj();
              if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
              {
                v96 = *(_QWORD *)(a1 + 40);
                *(_DWORD *)buf = 136446722;
                v101 = "http2_transport_create_output_frame_block_invoke";
                if (v96)
                  v97 = (const char *)(v96 + 205);
                else
                  v97 = "";
                v102 = 2082;
                v103 = (void *)v97;
                v104 = 1024;
                *(_DWORD *)v105 = v82;
                _os_log_impl(&dword_182FBE000, v95, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s claiming %u bytes off end of frame", buf, 0x1Cu);
              }
            }
          }
          else
          {
            v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
LABEL_177:
              http2_transport_output_frame_context_reset(a2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
              result = 0;
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
              return result;
            }
          }
          nw_frame_claim(a2, v7, 0, v82);
          goto LABEL_177;
        }
        return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = *(_QWORD *)(a1 + 40);
      if (v30)
        v31 = (const char *)(v30 + 205);
      else
        v31 = "";
      *(_DWORD *)buf = 136446466;
      v101 = "http2_transport_create_output_frame_block_invoke";
      v102 = 2082;
      v103 = (void *)v31;
      v32 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v98 = 0;
      if (__nwlog_fault(v32, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = gLogObj;
          v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_129;
          v35 = *(_QWORD *)(a1 + 40);
          if (v35)
            v36 = (const char *)(v35 + 205);
          else
            v36 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v36;
          v37 = "%{public}s %{public}s destroying frame with NULL buffer";
LABEL_128:
          _os_log_impl(&dword_182FBE000, v33, v34, v37, buf, 0x16u);
          goto LABEL_129;
        }
        if (!v98)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = gLogObj;
          v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_129;
          v71 = *(_QWORD *)(a1 + 40);
          if (v71)
            v72 = (const char *)(v71 + 205);
          else
            v72 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v72;
          v37 = "%{public}s %{public}s destroying frame with NULL buffer, backtrace limit exceeded";
          goto LABEL_128;
        }
        v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = gLogObj;
        v34 = type;
        v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!v42)
        {
          if (!v43)
            goto LABEL_129;
          v73 = *(_QWORD *)(a1 + 40);
          if (v73)
            v74 = (const char *)(v73 + 205);
          else
            v74 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v74;
          v37 = "%{public}s %{public}s destroying frame with NULL buffer, no backtrace";
          goto LABEL_128;
        }
        if (v43)
        {
          v44 = *(_QWORD *)(a1 + 40);
          if (v44)
            v45 = (const char *)(v44 + 205);
          else
            v45 = "";
          *(_DWORD *)buf = 136446722;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v45;
          v104 = 2082;
          *(_QWORD *)v105 = v42;
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s %{public}s destroying frame with NULL buffer, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v42);
      }
LABEL_129:
      if (v32)
        free(v32);
      v75 = *(_QWORD *)(a2 + 16);
      v76 = *(_QWORD **)(a2 + 24);
      if (v75)
      {
        *(_QWORD *)(v75 + 24) = v76;
        v76 = *(_QWORD **)(a2 + 24);
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 184) = v76;
      }
      *v76 = v75;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      v57 = *(_QWORD *)(a1 + 40);
      v58 = *(_DWORD *)(v57 + 196);
      if (v58)
      {
LABEL_135:
        *(_DWORD *)(v57 + 196) = v58 - 1;
LABEL_160:
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
        {
          v81 = *(void **)(a2 + 112);
          if (v81)
            free(v81);
        }
        nw_frame_reset(a2, 0, 0, 0, 0);
        os_release((void *)a2);
        return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_output_frame_block_invoke";
      v59 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v98 = 0;
      if (!__nwlog_fault(v59, &type, &v98))
        goto LABEL_158;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v60 = gLogObj;
        v61 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_158;
        *(_DWORD *)buf = 136446210;
        v101 = "http2_transport_create_output_frame_block_invoke";
        v62 = "%{public}s http2_transport count attempted to decrement below zero";
        goto LABEL_157;
      }
      if (!v98)
      {
        v60 = __nwlog_obj();
        v61 = type;
        if (!os_log_type_enabled(v60, type))
          goto LABEL_158;
        *(_DWORD *)buf = 136446210;
        v101 = "http2_transport_create_output_frame_block_invoke";
        v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
        goto LABEL_157;
      }
      v77 = (char *)__nw_create_backtrace_string();
      v60 = __nwlog_obj();
      v61 = type;
      v78 = os_log_type_enabled(v60, type);
      if (v77)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = v77;
          _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v77);
        if (!v59)
          goto LABEL_160;
        goto LABEL_159;
      }
      if (v78)
      {
        *(_DWORD *)buf = 136446210;
        v101 = "http2_transport_create_output_frame_block_invoke";
        v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_157:
        _os_log_impl(&dword_182FBE000, v60, v61, v62, buf, 0xCu);
        goto LABEL_158;
      }
      goto LABEL_158;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = *(_QWORD *)(a1 + 40);
    if (v18)
      v19 = (const char *)(v18 + 205);
    else
      v19 = "";
    *(_DWORD *)buf = 136446466;
    v101 = "http2_transport_create_output_frame_block_invoke";
    v102 = 2082;
    v103 = (void *)v19;
    v20 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (__nwlog_fault(v20, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v23 = *(_QWORD *)(a1 + 40);
          if (v23)
            v24 = (const char *)(v23 + 205);
          else
            v24 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v24;
          v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying";
LABEL_93:
          _os_log_impl(&dword_182FBE000, v21, v22, v25, buf, 0x16u);
        }
      }
      else if (v98)
      {
        v38 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        v39 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v38)
        {
          if (v39)
          {
            v40 = *(_QWORD *)(a1 + 40);
            if (v40)
              v41 = (const char *)(v40 + 205);
            else
              v41 = "";
            *(_DWORD *)buf = 136446722;
            v101 = "http2_transport_create_output_frame_block_invoke";
            v102 = 2082;
            v103 = (void *)v41;
            v104 = 2082;
            *(_QWORD *)v105 = v38;
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v38);
          goto LABEL_94;
        }
        if (v39)
        {
          v53 = *(_QWORD *)(a1 + 40);
          if (v53)
            v54 = (const char *)(v53 + 205);
          else
            v54 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v54;
          v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, no backtrace";
          goto LABEL_93;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v48 = *(_QWORD *)(a1 + 40);
          if (v48)
            v49 = (const char *)(v48 + 205);
          else
            v49 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v49;
          v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, backtrace limit exceeded";
          goto LABEL_93;
        }
      }
    }
LABEL_94:
    if (v20)
      free(v20);
    v55 = *(_QWORD *)(a2 + 16);
    v56 = *(_QWORD **)(a2 + 24);
    if (v55)
    {
      *(_QWORD *)(v55 + 24) = v56;
      v56 = *(_QWORD **)(a2 + 24);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 184) = v56;
    }
    *v56 = v55;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    v57 = *(_QWORD *)(a1 + 40);
    v58 = *(_DWORD *)(v57 + 196);
    if (v58)
      goto LABEL_135;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v101 = "http2_transport_create_output_frame_block_invoke";
    v59 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (!__nwlog_fault(v59, &type, &v98))
      goto LABEL_158;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v60 = gLogObj;
      v61 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_158;
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_output_frame_block_invoke";
      v62 = "%{public}s http2_transport count attempted to decrement below zero";
      goto LABEL_157;
    }
    if (!v98)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v60 = gLogObj;
      v61 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_158;
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_output_frame_block_invoke";
      v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
      goto LABEL_157;
    }
    v63 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v60 = gLogObj;
    v61 = type;
    v64 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v63)
    {
      if (!v64)
        goto LABEL_158;
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_output_frame_block_invoke";
      v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
      goto LABEL_157;
    }
    if (v64)
    {
      *(_DWORD *)buf = 136446466;
      v101 = "http2_transport_create_output_frame_block_invoke";
      v102 = 2082;
      v103 = v63;
      _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v63);
LABEL_158:
    if (!v59)
      goto LABEL_160;
LABEL_159:
    free(v59);
    goto LABEL_160;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = *(_QWORD *)(a1 + 40);
  if (v10)
    v11 = (const char *)(v10 + 205);
  else
    v11 = "";
  *(_DWORD *)buf = 136446466;
  v101 = "http2_transport_create_output_frame_block_invoke";
  v102 = 2082;
  v103 = (void *)v11;
  v12 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v98 = 0;
  if (__nwlog_fault(v12, &type, &v98))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v15 = *(_QWORD *)(a1 + 40);
        if (v15)
          v16 = (const char *)(v15 + 205);
        else
          v16 = "";
        *(_DWORD *)buf = 136446466;
        v101 = "http2_transport_create_output_frame_block_invoke";
        v102 = 2082;
        v103 = (void *)v16;
        v17 = "%{public}s %{public}s foreach gave null candidate_frame";
LABEL_84:
        _os_log_impl(&dword_182FBE000, v13, v14, v17, buf, 0x16u);
      }
    }
    else if (v98)
    {
      v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v26)
      {
        if (v27)
        {
          v28 = *(_QWORD *)(a1 + 40);
          if (v28)
            v29 = (const char *)(v28 + 205);
          else
            v29 = "";
          *(_DWORD *)buf = 136446722;
          v101 = "http2_transport_create_output_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v29;
          v104 = 2082;
          *(_QWORD *)v105 = v26;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s %{public}s foreach gave null candidate_frame, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v26);
        goto LABEL_85;
      }
      if (v27)
      {
        v50 = *(_QWORD *)(a1 + 40);
        if (v50)
          v51 = (const char *)(v50 + 205);
        else
          v51 = "";
        *(_DWORD *)buf = 136446466;
        v101 = "http2_transport_create_output_frame_block_invoke";
        v102 = 2082;
        v103 = (void *)v51;
        v17 = "%{public}s %{public}s foreach gave null candidate_frame, no backtrace";
        goto LABEL_84;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v46 = *(_QWORD *)(a1 + 40);
        if (v46)
          v47 = (const char *)(v46 + 205);
        else
          v47 = "";
        *(_DWORD *)buf = 136446466;
        v101 = "http2_transport_create_output_frame_block_invoke";
        v102 = 2082;
        v103 = (void *)v47;
        v17 = "%{public}s %{public}s foreach gave null candidate_frame, backtrace limit exceeded";
        goto LABEL_84;
      }
    }
  }
LABEL_85:
  if (v12)
    free(v12);
  return 0;
}

BOOL http2_transport_create_input_frame(uint64_t a1, uint64_t a2, size_t size)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  _BOOL8 result;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  NSObject *v19;
  void *buffer;
  void *v21;
  char *v22;
  _BOOL4 v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  char *backtrace_string;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  NSObject *v36;
  NSObject *v37;
  void *v38;
  char v39;
  _QWORD v40[2];
  uint64_t (*v41)(uint64_t, uint64_t);
  void *v42;
  os_log_type_t *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  os_log_type_t type[8];
  os_log_type_t *v48;
  uint64_t v49;
  uint64_t v50;
  os_log_type_t v51;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  unsigned int v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "http2_transport_create_input_frame";
    v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v51 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v24, type, &v51))
      goto LABEL_93;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type[0];
      if (!os_log_type_enabled(v25, type[0]))
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v53 = "http2_transport_create_input_frame";
      v27 = "%{public}s called with null http2_transport";
LABEL_92:
      _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
      goto LABEL_93;
    }
    if (v51 == OS_LOG_TYPE_DEFAULT)
    {
      v25 = __nwlog_obj();
      v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "http2_transport_create_input_frame";
        v27 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type[0];
    v32 = os_log_type_enabled(v25, type[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v53 = "http2_transport_create_input_frame";
        v27 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    if (!v32)
      goto LABEL_75;
    *(_DWORD *)buf = 136446466;
    v53 = "http2_transport_create_input_frame";
    v54 = 2082;
    v55 = (uint64_t)backtrace_string;
    v33 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_74:
    _os_log_impl(&dword_182FBE000, v25, v26, v33, buf, 0x16u);
    goto LABEL_75;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "http2_transport_create_input_frame";
    v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v51 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v24, type, &v51))
      goto LABEL_93;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type[0];
      if (!os_log_type_enabled(v25, type[0]))
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v53 = "http2_transport_create_input_frame";
      v27 = "%{public}s called with null stream";
      goto LABEL_92;
    }
    if (v51 == OS_LOG_TYPE_DEFAULT)
    {
      v25 = __nwlog_obj();
      v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "http2_transport_create_input_frame";
        v27 = "%{public}s called with null stream, backtrace limit exceeded";
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type[0];
    v34 = os_log_type_enabled(v25, type[0]);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v53 = "http2_transport_create_input_frame";
        v27 = "%{public}s called with null stream, no backtrace";
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    if (!v34)
      goto LABEL_75;
    *(_DWORD *)buf = 136446466;
    v53 = "http2_transport_create_input_frame";
    v54 = 2082;
    v55 = (uint64_t)backtrace_string;
    v33 = "%{public}s called with null stream, dumping backtrace:%{public}s";
    goto LABEL_74;
  }
  v4 = size;
  if (!(_DWORD)size)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "http2_transport_create_input_frame";
    v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v51 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v24, type, &v51))
      goto LABEL_93;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "http2_transport_create_input_frame";
        v27 = "%{public}s called with null length";
        goto LABEL_92;
      }
LABEL_93:
      if (v24)
        free(v24);
      return 0;
    }
    if (v51 == OS_LOG_TYPE_DEFAULT)
    {
      v25 = __nwlog_obj();
      v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "http2_transport_create_input_frame";
        v27 = "%{public}s called with null length, backtrace limit exceeded";
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type[0];
    v35 = os_log_type_enabled(v25, type[0]);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v53 = "http2_transport_create_input_frame";
        v27 = "%{public}s called with null length, no backtrace";
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      v53 = "http2_transport_create_input_frame";
      v54 = 2082;
      v55 = (uint64_t)backtrace_string;
      v33 = "%{public}s called with null length, dumping backtrace:%{public}s";
      goto LABEL_74;
    }
LABEL_75:
    free(backtrace_string);
    goto LABEL_93;
  }
  *(_QWORD *)type = 0;
  v48 = type;
  v49 = 0x2000000000;
  v50 = 0;
  if (gLogDatapath)
  {
    v28 = __nwlog_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v53 = "http2_transport_create_input_frame";
      v54 = 2082;
      v55 = a1 + 205;
      v56 = 1024;
      LODWORD(v57) = v4;
      _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s requested input frame of length %u", buf, 0x1Cu);
    }
  }
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v41 = ___ZL34http2_transport_create_input_frameP27nw_protocol_http2_transportP22http2_transport_streamj_block_invoke;
  v42 = &unk_1E14A0E10;
  v46 = v4;
  v44 = a1;
  v45 = a2;
  v43 = type;
  v6 = *(_QWORD *)(a1 + 160);
  do
  {
    if (!v6)
      break;
    v7 = *(_QWORD *)(v6 + 16);
    v8 = ((uint64_t (*)(_QWORD *))v41)(v40);
    v6 = v7;
  }
  while ((v8 & 1) != 0);
  if (*((_QWORD *)v48 + 3))
    goto LABEL_9;
  if (gLogDatapath)
  {
    v36 = __nwlog_obj();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v53 = "http2_transport_create_input_frame";
      v54 = 2082;
      v55 = a1 + 205;
      v56 = 1024;
      LODWORD(v57) = v4;
      _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s no input frame to reuse for length %u", buf, 0x1Cu);
    }
  }
  v11 = malloc_type_calloc(1uLL, v4, 0xEAFB8F1AuLL);
  if (v11)
  {
    v12 = (uint64_t)v11;
    goto LABEL_16;
  }
  v37 = __nwlog_obj();
  os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v53 = "strict_calloc";
  v54 = 2048;
  v55 = 1;
  v56 = 2048;
  v57 = v4;
  v38 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v38);
  if (!result)
  {
    free(v38);
    v12 = 0;
LABEL_16:
    v13 = nw_frame_create(16, v12, v4, (uint64_t)nw_protocol_http2_transport_frame_input_finalizer, 0);
    *((_QWORD *)v48 + 3) = v13;
    if (v13)
    {
      if ((http2_transport_input_frame_context_reset(v13, a1, a2) & 1) != 0)
      {
        if (!gLogDatapath)
        {
LABEL_10:
          v9 = *((_QWORD *)v48 + 3);
LABEL_11:
          _Block_object_dispose(type, 8);
          return v9;
        }
        v14 = __nwlog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v53 = "http2_transport_create_input_frame";
          v54 = 2082;
          v55 = a1 + 205;
          v56 = 1024;
          LODWORD(v57) = v4;
          _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s allocated new input frame of length %u", buf, 0x1Cu);
        }
LABEL_9:
        if (gLogDatapath)
        {
          v29 = __nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
          {
            v30 = *((_QWORD *)v48 + 3);
            *(_DWORD *)buf = 136446978;
            v53 = "http2_transport_create_input_frame";
            v54 = 2082;
            v55 = a1 + 205;
            v56 = 2048;
            v57 = v30;
            v58 = 1024;
            v59 = v4;
            _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s input_frame_create returning frame %p for requested length %u", buf, 0x26u);
          }
        }
        goto LABEL_10;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v53 = "http2_transport_create_input_frame";
        v54 = 2082;
        v55 = a1 + 205;
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s input frame has no metadata", buf, 0x16u);
      }
      buffer = (void *)nw_frame_get_buffer(*((_QWORD *)v48 + 3), 0);
      if (buffer)
        free(buffer);
      nw_frame_reset(*((_QWORD *)v48 + 3), 0, 0, 0, 0);
      v21 = (void *)*((_QWORD *)v48 + 3);
      if (v21)
      {
        os_release(v21);
        v9 = 0;
        *((_QWORD *)v48 + 3) = 0;
        goto LABEL_11;
      }
LABEL_45:
      v9 = 0;
      goto LABEL_11;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v53 = "http2_transport_create_input_frame";
    v15 = (char *)_os_log_send_and_compose_impl();
    v51 = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault(v15, &v51, &v39))
    {
      if (v51 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = v51;
        if (os_log_type_enabled((os_log_t)gLogObj, v51))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "http2_transport_create_input_frame";
          v18 = "%{public}s nw_frame_create new input frame failed";
LABEL_40:
          _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
        }
      }
      else if (v39)
      {
        v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = v51;
        v23 = os_log_type_enabled((os_log_t)gLogObj, v51);
        if (v22)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v53 = "http2_transport_create_input_frame";
            v54 = 2082;
            v55 = (uint64_t)v22;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s nw_frame_create new input frame failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v22);
          goto LABEL_41;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v53 = "http2_transport_create_input_frame";
          v18 = "%{public}s nw_frame_create new input frame failed, no backtrace";
          goto LABEL_40;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = gLogObj;
        v17 = v51;
        if (os_log_type_enabled((os_log_t)gLogObj, v51))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "http2_transport_create_input_frame";
          v18 = "%{public}s nw_frame_create new input frame failed, backtrace limit exceeded";
          goto LABEL_40;
        }
      }
    }
LABEL_41:
    if (v15)
      free(v15);
    if (v11)
      free(v11);
    goto LABEL_45;
  }
  __break(1u);
  return result;
}

uint64_t ___ZL34http2_transport_create_input_frameP27nw_protocol_http2_transportP22http2_transport_streamj_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  const char *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  char *v26;
  _BOOL4 v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  uint64_t v35;
  const char *v36;
  const char *v37;
  char *v38;
  _BOOL4 v39;
  uint64_t v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  const char *v49;
  uint64_t v50;
  const char *v51;
  uint64_t result;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  int v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  const char *v62;
  char *v63;
  _BOOL4 v64;
  uint64_t v65;
  int v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  const char *v74;
  uint64_t v75;
  _QWORD *v76;
  char *v77;
  _BOOL4 v78;
  char *backtrace_string;
  _BOOL4 v80;
  void *v81;
  int v82;
  NSObject *v83;
  uint64_t v84;
  BOOL v85;
  const char *v86;
  NSObject *v87;
  uint64_t v88;
  const char *v89;
  const char *v90;
  int v91;
  NSObject *v92;
  uint64_t v93;
  const char *v94;
  NSObject *v95;
  uint64_t v96;
  const char *v97;
  char v98;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v101;
  __int16 v102;
  void *v103;
  __int16 v104;
  _BYTE v105[10];
  unsigned int v106;
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
    {
      v4 = 0;
      v5 = 0;
    }
    else
    {
      v4 = *(_DWORD *)(a2 + 48);
      v5 = *(_QWORD *)(a2 + 112);
    }
    if (gLogDatapath)
    {
      v83 = __nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        v84 = *(_QWORD *)(a1 + 40);
        v85 = v84 == 0;
        *(_DWORD *)buf = 136446978;
        v86 = (const char *)(v84 + 205);
        v101 = "http2_transport_create_input_frame_block_invoke";
        if (v85)
          v86 = "";
        v102 = 2082;
        v103 = (void *)v86;
        v104 = 2048;
        *(_QWORD *)v105 = v5;
        *(_WORD *)&v105[8] = 1024;
        v106 = v4;
        _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s existing frame found, buffer %p, length %u", buf, 0x26u);
      }
    }
    v6 = *(_DWORD *)(a2 + 52);
    if (v6)
      v6 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
    if (v6 == v4)
    {
      if (v5 && v4)
      {
        if (http2_transport_candidate_frame_length_is_match(v4, *(_DWORD *)(a1 + 56)))
        {
          v8 = *(_QWORD *)(a2 + 16);
          v9 = *(_QWORD **)(a2 + 24);
          if (v8)
          {
            *(_QWORD *)(v8 + 24) = v9;
            v9 = *(_QWORD **)(a2 + 24);
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 40) + 168) = v9;
          }
          *v9 = v8;
          *(_QWORD *)(a2 + 16) = 0;
          *(_QWORD *)(a2 + 24) = 0;
          v65 = *(_QWORD *)(a1 + 40);
          v66 = *(_DWORD *)(v65 + 192);
          if (v66)
          {
            *(_DWORD *)(v65 + 192) = v66 - 1;
            goto LABEL_174;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v67 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v98 = 0;
          if (__nwlog_fault(v67, &type, &v98))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v68 = __nwlog_obj();
              v69 = type;
              if (!os_log_type_enabled(v68, type))
                goto LABEL_172;
              *(_DWORD *)buf = 136446210;
              v101 = "http2_transport_create_input_frame_block_invoke";
              v70 = "%{public}s http2_transport count attempted to decrement below zero";
              goto LABEL_171;
            }
            if (!v98)
            {
              v68 = __nwlog_obj();
              v69 = type;
              if (!os_log_type_enabled(v68, type))
                goto LABEL_172;
              *(_DWORD *)buf = 136446210;
              v101 = "http2_transport_create_input_frame_block_invoke";
              v70 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
              goto LABEL_171;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            v68 = __nwlog_obj();
            v69 = type;
            v80 = os_log_type_enabled(v68, type);
            if (backtrace_string)
            {
              if (v80)
              {
                *(_DWORD *)buf = 136446466;
                v101 = "http2_transport_create_input_frame_block_invoke";
                v102 = 2082;
                v103 = backtrace_string;
                _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(backtrace_string);
              goto LABEL_172;
            }
            if (v80)
            {
              *(_DWORD *)buf = 136446210;
              v101 = "http2_transport_create_input_frame_block_invoke";
              v70 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_171:
              _os_log_impl(&dword_182FBE000, v68, v69, v70, buf, 0xCu);
            }
          }
LABEL_172:
          if (v67)
            free(v67);
LABEL_174:
          if (gLogDatapath)
          {
            v87 = __nwlog_obj();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
            {
              v88 = *(_QWORD *)(a1 + 40);
              v89 = "";
              v90 = (const char *)(v88 + 205);
              v85 = v88 == 0;
              v91 = *(_DWORD *)(a1 + 56);
              if (!v85)
                v89 = v90;
              *(_DWORD *)buf = 136446978;
              v101 = "http2_transport_create_input_frame_block_invoke";
              v102 = 2082;
              v103 = (void *)v89;
              v104 = 1024;
              *(_DWORD *)v105 = v4;
              *(_WORD *)&v105[4] = 1024;
              *(_DWORD *)&v105[6] = v91;
              _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s reusing input frame of length %u, adjusting to %u", buf, 0x22u);
            }
            v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
              if (gLogDatapath)
              {
                v92 = __nwlog_obj();
                if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
                {
                  v93 = *(_QWORD *)(a1 + 40);
                  if (v93)
                    v94 = (const char *)(v93 + 205);
                  else
                    v94 = "";
                  *(_DWORD *)buf = 136446466;
                  v101 = "http2_transport_create_input_frame_block_invoke";
                  v102 = 2082;
                  v103 = (void *)v94;
                  _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s frame was exact match, not modifying", buf, 0x16u);
                }
              }
              goto LABEL_177;
            }
            if (gLogDatapath)
            {
              v95 = __nwlog_obj();
              if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
              {
                v96 = *(_QWORD *)(a1 + 40);
                *(_DWORD *)buf = 136446722;
                v101 = "http2_transport_create_input_frame_block_invoke";
                if (v96)
                  v97 = (const char *)(v96 + 205);
                else
                  v97 = "";
                v102 = 2082;
                v103 = (void *)v97;
                v104 = 1024;
                *(_DWORD *)v105 = v82;
                _os_log_impl(&dword_182FBE000, v95, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s claiming %u bytes off end of frame", buf, 0x1Cu);
              }
            }
          }
          else
          {
            v82 = v4 - *(_DWORD *)(a1 + 56);
            if (!v82)
            {
LABEL_177:
              http2_transport_input_frame_context_reset(a2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
              result = 0;
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
              return result;
            }
          }
          nw_frame_claim(a2, v7, 0, v82);
          goto LABEL_177;
        }
        return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = *(_QWORD *)(a1 + 40);
      if (v30)
        v31 = (const char *)(v30 + 205);
      else
        v31 = "";
      *(_DWORD *)buf = 136446466;
      v101 = "http2_transport_create_input_frame_block_invoke";
      v102 = 2082;
      v103 = (void *)v31;
      v32 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v98 = 0;
      if (__nwlog_fault(v32, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = gLogObj;
          v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_129;
          v35 = *(_QWORD *)(a1 + 40);
          if (v35)
            v36 = (const char *)(v35 + 205);
          else
            v36 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v36;
          v37 = "%{public}s %{public}s destroying frame with NULL buffer";
LABEL_128:
          _os_log_impl(&dword_182FBE000, v33, v34, v37, buf, 0x16u);
          goto LABEL_129;
        }
        if (!v98)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = gLogObj;
          v34 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_129;
          v71 = *(_QWORD *)(a1 + 40);
          if (v71)
            v72 = (const char *)(v71 + 205);
          else
            v72 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v72;
          v37 = "%{public}s %{public}s destroying frame with NULL buffer, backtrace limit exceeded";
          goto LABEL_128;
        }
        v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = gLogObj;
        v34 = type;
        v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!v42)
        {
          if (!v43)
            goto LABEL_129;
          v73 = *(_QWORD *)(a1 + 40);
          if (v73)
            v74 = (const char *)(v73 + 205);
          else
            v74 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v74;
          v37 = "%{public}s %{public}s destroying frame with NULL buffer, no backtrace";
          goto LABEL_128;
        }
        if (v43)
        {
          v44 = *(_QWORD *)(a1 + 40);
          if (v44)
            v45 = (const char *)(v44 + 205);
          else
            v45 = "";
          *(_DWORD *)buf = 136446722;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v45;
          v104 = 2082;
          *(_QWORD *)v105 = v42;
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s %{public}s destroying frame with NULL buffer, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v42);
      }
LABEL_129:
      if (v32)
        free(v32);
      v75 = *(_QWORD *)(a2 + 16);
      v76 = *(_QWORD **)(a2 + 24);
      if (v75)
      {
        *(_QWORD *)(v75 + 24) = v76;
        v76 = *(_QWORD **)(a2 + 24);
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 168) = v76;
      }
      *v76 = v75;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      v57 = *(_QWORD *)(a1 + 40);
      v58 = *(_DWORD *)(v57 + 192);
      if (v58)
      {
LABEL_135:
        *(_DWORD *)(v57 + 192) = v58 - 1;
LABEL_160:
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
        {
          v81 = *(void **)(a2 + 112);
          if (v81)
            free(v81);
        }
        nw_frame_reset(a2, 0, 0, 0, 0);
        os_release((void *)a2);
        return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_input_frame_block_invoke";
      v59 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v98 = 0;
      if (!__nwlog_fault(v59, &type, &v98))
        goto LABEL_158;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v60 = gLogObj;
        v61 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_158;
        *(_DWORD *)buf = 136446210;
        v101 = "http2_transport_create_input_frame_block_invoke";
        v62 = "%{public}s http2_transport count attempted to decrement below zero";
        goto LABEL_157;
      }
      if (!v98)
      {
        v60 = __nwlog_obj();
        v61 = type;
        if (!os_log_type_enabled(v60, type))
          goto LABEL_158;
        *(_DWORD *)buf = 136446210;
        v101 = "http2_transport_create_input_frame_block_invoke";
        v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
        goto LABEL_157;
      }
      v77 = (char *)__nw_create_backtrace_string();
      v60 = __nwlog_obj();
      v61 = type;
      v78 = os_log_type_enabled(v60, type);
      if (v77)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = v77;
          _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v77);
        if (!v59)
          goto LABEL_160;
        goto LABEL_159;
      }
      if (v78)
      {
        *(_DWORD *)buf = 136446210;
        v101 = "http2_transport_create_input_frame_block_invoke";
        v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
LABEL_157:
        _os_log_impl(&dword_182FBE000, v60, v61, v62, buf, 0xCu);
        goto LABEL_158;
      }
      goto LABEL_158;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = *(_QWORD *)(a1 + 40);
    if (v18)
      v19 = (const char *)(v18 + 205);
    else
      v19 = "";
    *(_DWORD *)buf = 136446466;
    v101 = "http2_transport_create_input_frame_block_invoke";
    v102 = 2082;
    v103 = (void *)v19;
    v20 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (__nwlog_fault(v20, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v23 = *(_QWORD *)(a1 + 40);
          if (v23)
            v24 = (const char *)(v23 + 205);
          else
            v24 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v24;
          v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying";
LABEL_93:
          _os_log_impl(&dword_182FBE000, v21, v22, v25, buf, 0x16u);
        }
      }
      else if (v98)
      {
        v38 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        v39 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v38)
        {
          if (v39)
          {
            v40 = *(_QWORD *)(a1 + 40);
            if (v40)
              v41 = (const char *)(v40 + 205);
            else
              v41 = "";
            *(_DWORD *)buf = 136446722;
            v101 = "http2_transport_create_input_frame_block_invoke";
            v102 = 2082;
            v103 = (void *)v41;
            v104 = 2082;
            *(_QWORD *)v105 = v38;
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v38);
          goto LABEL_94;
        }
        if (v39)
        {
          v53 = *(_QWORD *)(a1 + 40);
          if (v53)
            v54 = (const char *)(v53 + 205);
          else
            v54 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v54;
          v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, no backtrace";
          goto LABEL_93;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v48 = *(_QWORD *)(a1 + 40);
          if (v48)
            v49 = (const char *)(v48 + 205);
          else
            v49 = "";
          *(_DWORD *)buf = 136446466;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v49;
          v25 = "%{public}s %{public}s candidate frame is not fully unclaimed, destroying, backtrace limit exceeded";
          goto LABEL_93;
        }
      }
    }
LABEL_94:
    if (v20)
      free(v20);
    v55 = *(_QWORD *)(a2 + 16);
    v56 = *(_QWORD **)(a2 + 24);
    if (v55)
    {
      *(_QWORD *)(v55 + 24) = v56;
      v56 = *(_QWORD **)(a2 + 24);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 168) = v56;
    }
    *v56 = v55;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a2 + 24) = 0;
    v57 = *(_QWORD *)(a1 + 40);
    v58 = *(_DWORD *)(v57 + 192);
    if (v58)
      goto LABEL_135;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v101 = "http2_transport_create_input_frame_block_invoke";
    v59 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (!__nwlog_fault(v59, &type, &v98))
      goto LABEL_158;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v60 = gLogObj;
      v61 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_158;
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_input_frame_block_invoke";
      v62 = "%{public}s http2_transport count attempted to decrement below zero";
      goto LABEL_157;
    }
    if (!v98)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v60 = gLogObj;
      v61 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_158;
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_input_frame_block_invoke";
      v62 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
      goto LABEL_157;
    }
    v63 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v60 = gLogObj;
    v61 = type;
    v64 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v63)
    {
      if (!v64)
        goto LABEL_158;
      *(_DWORD *)buf = 136446210;
      v101 = "http2_transport_create_input_frame_block_invoke";
      v62 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
      goto LABEL_157;
    }
    if (v64)
    {
      *(_DWORD *)buf = 136446466;
      v101 = "http2_transport_create_input_frame_block_invoke";
      v102 = 2082;
      v103 = v63;
      _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v63);
LABEL_158:
    if (!v59)
      goto LABEL_160;
LABEL_159:
    free(v59);
    goto LABEL_160;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = *(_QWORD *)(a1 + 40);
  if (v10)
    v11 = (const char *)(v10 + 205);
  else
    v11 = "";
  *(_DWORD *)buf = 136446466;
  v101 = "http2_transport_create_input_frame_block_invoke";
  v102 = 2082;
  v103 = (void *)v11;
  v12 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v98 = 0;
  if (__nwlog_fault(v12, &type, &v98))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v15 = *(_QWORD *)(a1 + 40);
        if (v15)
          v16 = (const char *)(v15 + 205);
        else
          v16 = "";
        *(_DWORD *)buf = 136446466;
        v101 = "http2_transport_create_input_frame_block_invoke";
        v102 = 2082;
        v103 = (void *)v16;
        v17 = "%{public}s %{public}s foreach gave null candidate_frame";
LABEL_84:
        _os_log_impl(&dword_182FBE000, v13, v14, v17, buf, 0x16u);
      }
    }
    else if (v98)
    {
      v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v26)
      {
        if (v27)
        {
          v28 = *(_QWORD *)(a1 + 40);
          if (v28)
            v29 = (const char *)(v28 + 205);
          else
            v29 = "";
          *(_DWORD *)buf = 136446722;
          v101 = "http2_transport_create_input_frame_block_invoke";
          v102 = 2082;
          v103 = (void *)v29;
          v104 = 2082;
          *(_QWORD *)v105 = v26;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s %{public}s foreach gave null candidate_frame, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v26);
        goto LABEL_85;
      }
      if (v27)
      {
        v50 = *(_QWORD *)(a1 + 40);
        if (v50)
          v51 = (const char *)(v50 + 205);
        else
          v51 = "";
        *(_DWORD *)buf = 136446466;
        v101 = "http2_transport_create_input_frame_block_invoke";
        v102 = 2082;
        v103 = (void *)v51;
        v17 = "%{public}s %{public}s foreach gave null candidate_frame, no backtrace";
        goto LABEL_84;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v46 = *(_QWORD *)(a1 + 40);
        if (v46)
          v47 = (const char *)(v46 + 205);
        else
          v47 = "";
        *(_DWORD *)buf = 136446466;
        v101 = "http2_transport_create_input_frame_block_invoke";
        v102 = 2082;
        v103 = (void *)v47;
        v17 = "%{public}s %{public}s foreach gave null candidate_frame, backtrace limit exceeded";
        goto LABEL_84;
      }
    }
  }
LABEL_85:
  if (v12)
    free(v12);
  return 0;
}

uint64_t http2_transport_input_frame_context_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const char *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *v10;
  _BOOL4 v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "__nw_frame_get_metadata";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v12, &type, &v18))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v21 = "__nw_frame_get_metadata";
      v15 = "%{public}s called with null frame";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "__nw_frame_get_metadata";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_39;
      }
      if (!v17)
      {
LABEL_39:
        if (v12)
          free(v12);
        goto LABEL_3;
      }
      *(_DWORD *)buf = 136446210;
      v21 = "__nw_frame_get_metadata";
      v15 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v21 = "__nw_frame_get_metadata";
      v15 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
    goto LABEL_39;
  }
  if ((*(_WORD *)(a1 + 204) & 4) != 0)
  {
    *(_QWORD *)(a1 + 208) = a2;
    *(_QWORD *)(a1 + 216) = a3;
    return 1;
  }
LABEL_3:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
    v4 = (const char *)(a2 + 205);
  else
    v4 = "";
  *(_DWORD *)buf = 136446466;
  v21 = "http2_transport_input_frame_context_reset";
  v22 = 2082;
  v23 = (void *)v4;
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v5, &type, &v18))
    goto LABEL_21;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446466;
      v21 = "http2_transport_input_frame_context_reset";
      v22 = 2082;
      v23 = (void *)v4;
      v8 = "%{public}s %{public}s frame has no metadata";
LABEL_20:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0x16u);
    }
  }
  else if (v18)
  {
    v10 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = type;
    v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v10)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446722;
        v21 = "http2_transport_input_frame_context_reset";
        v22 = 2082;
        v23 = (void *)v4;
        v24 = 2082;
        v25 = v10;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s %{public}s frame has no metadata, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v10);
      goto LABEL_21;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v21 = "http2_transport_input_frame_context_reset";
      v22 = 2082;
      v23 = (void *)v4;
      v8 = "%{public}s %{public}s frame has no metadata, no backtrace";
      goto LABEL_20;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    v7 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446466;
      v21 = "http2_transport_input_frame_context_reset";
      v22 = 2082;
      v23 = (void *)v4;
      v8 = "%{public}s %{public}s frame has no metadata, backtrace limit exceeded";
      goto LABEL_20;
    }
  }
LABEL_21:
  if (v5)
    free(v5);
  return 0;
}

BOOL http2_transport_candidate_frame_length_is_match(unsigned int a1, unsigned int a2)
{
  _BOOL8 result;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  _WORD v17[9];

  *(_QWORD *)&v17[5] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "http2_transport_candidate_frame_length_is_match";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v5, &type, &v12))
      goto LABEL_23;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_23;
      *(_DWORD *)buf = 136446210;
      v15 = "http2_transport_candidate_frame_length_is_match";
      v8 = "%{public}s called with null length";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "http2_transport_candidate_frame_length_is_match";
          v16 = 2082;
          *(_QWORD *)v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null length, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_23;
      }
      if (!v11)
      {
LABEL_23:
        if (v5)
          free(v5);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v15 = "http2_transport_candidate_frame_length_is_match";
      v8 = "%{public}s called with null length, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_23;
      *(_DWORD *)buf = 136446210;
      v15 = "http2_transport_candidate_frame_length_is_match";
      v8 = "%{public}s called with null length, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_23;
  }
  if (*MEMORY[0x1E0C85AD8] + (unint64_t)a2 >= a1)
    return a1 >= a2;
  if (!gLogDatapath)
    return 0;
  v9 = __nwlog_obj();
  result = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    *(_DWORD *)buf = 136446722;
    v15 = "http2_transport_candidate_frame_length_is_match";
    v16 = 1024;
    *(_DWORD *)v17 = a1;
    v17[2] = 1024;
    *(_DWORD *)&v17[3] = a2;
    _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s candidate frame (%u bytes) is too much larger than requested (%u bytes), skipping", buf, 0x18u);
    return 0;
  }
  return result;
}

void http2_transport_cache_output_frame(uint64_t a1, _QWORD *a2)
{
  uint64_t buffer;
  unsigned int *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  void *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  _QWORD *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v10 = __nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v16 = "http2_transport_cache_output_frame";
      v17 = 2082;
      v18 = a1 + 205;
      v19 = 2048;
      v20 = a2;
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s caching output frame %p", buf, 0x20u);
    }
  }
  if (http2_transport_output_frame_context_reset((uint64_t)a2, 0, 0))
  {
    v14 = 0;
    buffer = nw_frame_get_buffer((uint64_t)a2, &v14);
    if (gLogDatapath)
    {
      v11 = __nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        v16 = "http2_transport_cache_output_frame";
        v17 = 2082;
        v18 = a1 + 205;
        v19 = 2048;
        v20 = a2;
        v21 = 2048;
        v22 = buffer;
        v23 = 1024;
        v24 = v14;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s resetting output frame %p to buffer %p, length %u", buf, 0x30u);
      }
    }
    nw_frame_reset((uint64_t)a2, buffer, v14, (uint64_t)nw_protocol_http2_transport_frame_output_finalizer, 0);
    v6 = *(_DWORD *)(a1 + 196);
    v7 = *(_QWORD *)(a1 + 176);
    a2[2] = v7;
    if (v7)
      v8 = (_QWORD *)(v7 + 24);
    else
      v8 = (_QWORD *)(a1 + 184);
    *v8 = a2 + 2;
    *(_QWORD *)(a1 + 176) = a2;
    a2[3] = a1 + 176;
    *(_DWORD *)(a1 + 196) = v6 + 1;
    if (gLogDatapath)
    {
      v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v16 = "http2_transport_cache_output_frame";
        v17 = 2082;
        v18 = a1 + 205;
        v19 = 1024;
        LODWORD(v20) = v14;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s reset output frame of length %u, eligible for reuse", buf, 0x1Cu);
      }
    }
    http2_transport_purge_frame_cache_if_necessary((nw_frame_array_s *)(a1 + 176), (_DWORD *)(a1 + 196), v5);
  }
  else
  {
    if (gLogDatapath)
    {
      v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v16 = "http2_transport_cache_output_frame";
        v17 = 2082;
        v18 = a1 + 205;
        v19 = 2048;
        v20 = a2;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ERROR: unable to clear metadata for output frame %p, freeing", buf, 0x20u);
      }
    }
    v9 = (void *)nw_frame_get_buffer((uint64_t)a2, 0);
    if (v9)
      free(v9);
    nw_frame_reset((uint64_t)a2, 0, 0, 0, 0);
    if (a2)
      os_release(a2);
  }
}

BOOL http2_transport_output_frame_context_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *metadata;
  _QWORD *v6;
  const char *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  metadata = (_QWORD *)nw_frame_get_metadata(a1);
  v6 = metadata;
  if (metadata)
  {
    *metadata = a2;
    metadata[1] = a3;
    return v6 != 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
    v7 = (const char *)(a2 + 205);
  else
    v7 = "";
  *(_DWORD *)buf = 136446466;
  v18 = "http2_transport_output_frame_context_reset";
  v19 = 2082;
  v20 = v7;
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446466;
      v18 = "http2_transport_output_frame_context_reset";
      v19 = 2082;
      v20 = v7;
      v11 = "%{public}s %{public}s frame has no metadata";
      goto LABEL_19;
    }
    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446466;
      v18 = "http2_transport_output_frame_context_reset";
      v19 = 2082;
      v20 = v7;
      v11 = "%{public}s %{public}s frame has no metadata, backtrace limit exceeded";
      goto LABEL_19;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type;
    v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446722;
        v18 = "http2_transport_output_frame_context_reset";
        v19 = 2082;
        v20 = v7;
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s %{public}s frame has no metadata, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_20;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v18 = "http2_transport_output_frame_context_reset";
      v19 = 2082;
      v20 = v7;
      v11 = "%{public}s %{public}s frame has no metadata, no backtrace";
LABEL_19:
      _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0x16u);
    }
  }
LABEL_20:
  if (v8)
    free(v8);
  return v6 != 0;
}

uint64_t data_source_read_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, _QWORD *a6, uint64_t a7)
{
  uint64_t v10;
  _DWORD *v11;
  int v12;
  unsigned int v13;
  NSObject *v14;
  BOOL v15;
  int v16;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  NSObject *v22;
  NSObject *v23;
  char *backtrace_string;
  _BOOL4 v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a7)
  {
    LODWORD(v10) = a4;
    if (gLogDatapath)
    {
      v22 = __nwlog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v29 = "data_source_read_callback";
        v30 = 2082;
        v31 = (char *)(a7 + 205);
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }
    v11 = (_DWORD *)*a6;
    if (*a6)
    {
      v12 = v11[13];
      if (v12)
        v13 = v12 - (v11[14] + v11[15]);
      else
        v13 = 0;
      v15 = v13 > v10;
      if (v13 >= v10)
        v10 = v10;
      else
        v10 = v13;
      if (v15)
        v16 = 6;
      else
        v16 = 7;
      *a5 |= v16;
      if (gLogDatapath)
      {
        v23 = __nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v29 = "data_source_read_callback";
          v30 = 2082;
          v31 = (char *)(a7 + 205);
          v32 = 1024;
          v33 = v10;
          _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s skipped copying %u bytes in data_source_read_callback", buf, 0x1Cu);
        }
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v29 = "data_source_read_callback";
        v30 = 2082;
        v31 = (char *)(a7 + 205);
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received unexpected NULL frame in data source", buf, 0x16u);
      }
      v10 = 0;
      *a5 |= 1u;
    }
    return v10;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v29 = "data_source_read_callback";
  v18 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v18, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "data_source_read_callback";
        v21 = "%{public}s nghttp2 user data is NULL, not http2_transport";
LABEL_35:
        _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v25 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "data_source_read_callback";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_36;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "data_source_read_callback";
        v21 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
        goto LABEL_35;
      }
    }
    else
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "data_source_read_callback";
        v21 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
  }
LABEL_36:
  if (v18)
    free(v18);
  return -902;
}

uint64_t nw_protocol_http2_transport_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  char *handle;
  nw_frame *tqh_first;
  nw_frame *v5;
  char v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  char *backtrace_string;
  _BOOL4 v14;
  char *v15;
  _BOOL4 v16;
  _QWORD v17[2];
  uint64_t (*v18)(uint64_t, uint64_t);
  void *v19;
  nw_frame_array_s *v20;
  char v21;
  os_log_type_t v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_transport_finalize_output_frames";
    v8 = (char *)_os_log_send_and_compose_impl();
    v22 = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &v22, &v21))
      goto LABEL_39;
    if (v22 == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = v22;
      if (!os_log_type_enabled(v9, v22))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_transport_finalize_output_frames";
      v11 = "%{public}s called with null protocol";
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = v22;
      v14 = os_log_type_enabled(v9, v22);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_protocol_http2_transport_finalize_output_frames";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_39:
        if (!v8)
          return 0;
LABEL_40:
        free(v8);
        return 0;
      }
      if (!v14)
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_transport_finalize_output_frames";
      v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = v22;
      if (!os_log_type_enabled(v9, v22))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http2_transport_finalize_output_frames";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_38:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_39;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if (gLogDatapath)
    {
      v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_http2_transport_finalize_output_frames";
        v25 = 2082;
        v26 = handle + 205;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 0x40000000;
    v18 = ___ZL50nw_protocol_http2_transport_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
    v19 = &__block_descriptor_tmp_41_37853;
    v20 = a2;
    tqh_first = a2->tqh_first;
    do
    {
      if (!tqh_first)
        break;
      v5 = (nw_frame *)*((_QWORD *)tqh_first + 4);
      v6 = ((uint64_t (*)(_QWORD *))v18)(v17);
      tqh_first = v5;
    }
    while ((v6 & 1) != 0);
    nw_http2_transport_session_send((uint64_t)handle);
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_protocol_http2_transport_finalize_output_frames";
  v8 = (char *)_os_log_send_and_compose_impl();
  v22 = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v8, &v22, &v21))
    goto LABEL_39;
  if (v22 == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v10 = v22;
    if (!os_log_type_enabled(v9, v22))
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_transport_finalize_output_frames";
    v11 = "%{public}s called with null http2_transport";
    goto LABEL_38;
  }
  if (!v21)
  {
    v9 = __nwlog_obj();
    v10 = v22;
    if (!os_log_type_enabled(v9, v22))
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_transport_finalize_output_frames";
    v11 = "%{public}s called with null http2_transport, backtrace limit exceeded";
    goto LABEL_38;
  }
  v15 = (char *)__nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v10 = v22;
  v16 = os_log_type_enabled(v9, v22);
  if (!v15)
  {
    if (!v16)
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http2_transport_finalize_output_frames";
    v11 = "%{public}s called with null http2_transport, no backtrace";
    goto LABEL_38;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_protocol_http2_transport_finalize_output_frames";
    v25 = 2082;
    v26 = v15;
    _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v15);
  if (v8)
    goto LABEL_40;
  return 0;
}

void nw_protocol_http2_transport_frame_input_finalizer(nw_frame *a1, int a2, void *a3)
{
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  _BOOL4 v16;
  const char *v17;
  int v18;
  int v19;
  void *v20;
  uint64_t v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  _BOOL4 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned int *v34;
  int v35;
  uint64_t v36;
  _QWORD *v37;
  NSObject *v38;
  void *v39;
  NSObject *v40;
  char *backtrace_string;
  _BOOL4 v42;
  NSObject *v43;
  _BOOL4 v44;
  NSObject *v45;
  NSObject *v46;
  int v47;
  NSObject *v48;
  _BOOL4 v49;
  _BOOL4 v50;
  NSObject *v51;
  NSObject *v52;
  int v53;
  char v54;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v57;
  __int16 v58;
  uint64_t v59;
  __int16 v60;
  _BYTE v61[10];
  uint64_t v62;
  __int16 v63;
  int v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v40 = __nwlog_obj();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v6, &type, &v54))
      goto LABEL_37;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v54)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v42 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446466;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v58 = 2082;
            v59 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_protocol_http2_transport_frame_input_finalizer";
          v9 = "%{public}s called with null frame, no backtrace";
          goto LABEL_36;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_protocol_http2_transport_frame_input_finalizer";
          v9 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_36;
        }
      }
      goto LABEL_37;
    }
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    v9 = "%{public}s called with null frame";
LABEL_36:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_37;
  }
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v6, &type, &v54))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      v9 = "%{public}s http2_transport input frames should no longer have nonnull context";
      goto LABEL_36;
    }
    if (!v54)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      v9 = "%{public}s http2_transport input frames should no longer have nonnull context, backtrace limit exceeded";
      goto LABEL_36;
    }
    v15 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v15)
    {
      if (!v16)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      v9 = "%{public}s http2_transport input frames should no longer have nonnull context, no backtrace";
      goto LABEL_36;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      v58 = 2082;
      v59 = (uint64_t)v15;
      v17 = "%{public}s http2_transport input frames should no longer have nonnull context, dumping backtrace:%{public}s";
LABEL_18:
      _os_log_impl(&dword_182FBE000, v7, v8, v17, buf, 0x16u);
      goto LABEL_19;
    }
    goto LABEL_19;
  }
  if ((*((_WORD *)a1 + 102) & 4) != 0)
  {
    v10 = *((_QWORD *)a1 + 26);
    if (v10)
    {
      v11 = *((_QWORD *)a1 + 27);
      if (v11)
      {
        if (gLogDatapath)
        {
          v43 = __nwlog_obj();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v58 = 2082;
            v59 = v10 + 205;
            _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s finalizing input frame", buf, 0x16u);
          }
        }
        v12 = *((_QWORD *)a1 + 2);
        v13 = (_QWORD *)*((_QWORD *)a1 + 3);
        v14 = (_QWORD *)((char *)a1 + 16);
        if (v12)
        {
          *(_QWORD *)(v12 + 24) = v13;
          v13 = (_QWORD *)*((_QWORD *)a1 + 3);
        }
        else
        {
          *(_QWORD *)(v10 + 152) = v13;
        }
        *v13 = v12;
        *v14 = 0;
        *((_QWORD *)a1 + 3) = 0;
        if (!a2)
        {
          if (gLogDatapath)
          {
            v45 = __nwlog_obj();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              v57 = "nw_protocol_http2_transport_frame_input_finalizer";
              v58 = 2082;
              v59 = v10 + 205;
              _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s disposing of input frame, finalizer called with success == false", buf, 0x16u);
            }
          }
          if ((*((_WORD *)a1 + 102) & 0x100) == 0
            || !g_channel_check_validity
            || g_channel_check_validity(a1, *((_QWORD *)a1 + 11)))
          {
            v20 = (void *)*((_QWORD *)a1 + 14);
            if (v20)
              free(v20);
          }
          nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
          os_release(a1);
          return;
        }
        v18 = *((_DWORD *)a1 + 13);
        if (v18)
          v19 = v18 - (*((_DWORD *)a1 + 14) + *((_DWORD *)a1 + 15));
        else
          v19 = 0;
        if (!nghttp2_session_consume_stream())
        {
LABEL_57:
          if (gLogDatapath)
          {
            v46 = __nwlog_obj();
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
            {
              v47 = *(_DWORD *)(v11 + 32);
              *(_DWORD *)buf = 136446978;
              v57 = "nw_protocol_http2_transport_frame_input_finalizer";
              v58 = 2082;
              v59 = v10 + 205;
              v60 = 1024;
              *(_DWORD *)v61 = v19;
              *(_WORD *)&v61[4] = 1024;
              *(_DWORD *)&v61[6] = v47;
              _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s consumed %u bytes on stream %d", buf, 0x22u);
            }
            if (gLogDatapath)
            {
              v48 = __nwlog_obj();
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                v57 = "http2_transport_cache_input_frame";
                v58 = 2082;
                v59 = v10 + 205;
                v60 = 2048;
                *(_QWORD *)v61 = a1;
                _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s caching input frame %p", buf, 0x20u);
              }
            }
          }
          if ((http2_transport_input_frame_context_reset((uint64_t)a1, 0, 0) & 1) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v38 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              v57 = "http2_transport_cache_input_frame";
              v58 = 2082;
              v59 = v10 + 205;
              v60 = 2048;
              *(_QWORD *)v61 = a1;
              _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_ERROR, "%{public}s %{public}s ERROR: unable to clear metadata for input frame %p, freeing", buf, 0x20u);
            }
            if ((*((_WORD *)a1 + 102) & 0x100) == 0
              || !g_channel_check_validity
              || g_channel_check_validity(a1, *((_QWORD *)a1 + 11)))
            {
              v39 = (void *)*((_QWORD *)a1 + 14);
              if (v39)
                free(v39);
            }
            nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
            os_release(a1);
            goto LABEL_76;
          }
          if ((*((_WORD *)a1 + 102) & 0x100) != 0
            && g_channel_check_validity
            && !g_channel_check_validity(a1, *((_QWORD *)a1 + 11)))
          {
            v32 = 0;
            v33 = 0;
            if (!gLogDatapath)
              goto LABEL_63;
          }
          else
          {
            v32 = *((_DWORD *)a1 + 12);
            v33 = *((_QWORD *)a1 + 14);
            if (!gLogDatapath)
            {
LABEL_63:
              nw_frame_reset((uint64_t)a1, v33, v32, (uint64_t)nw_protocol_http2_transport_frame_input_finalizer, 0);
              v35 = *(_DWORD *)(v10 + 192);
              v36 = *(_QWORD *)(v10 + 160);
              *((_QWORD *)a1 + 2) = v36;
              if (v36)
                v37 = (_QWORD *)(v36 + 24);
              else
                v37 = (_QWORD *)(v10 + 168);
              *v37 = v14;
              *(_QWORD *)(v10 + 160) = a1;
              *((_QWORD *)a1 + 3) = v10 + 160;
              *(_DWORD *)(v10 + 192) = v35 + 1;
              if (gLogDatapath)
              {
                v51 = __nwlog_obj();
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446722;
                  v57 = "http2_transport_cache_input_frame";
                  v58 = 2082;
                  v59 = v10 + 205;
                  v60 = 1024;
                  *(_DWORD *)v61 = v32;
                  _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s reset input frame of length %u, eligible for reuse", buf, 0x1Cu);
                }
              }
              http2_transport_purge_frame_cache_if_necessary((nw_frame_array_s *)(v10 + 160), (_DWORD *)(v10 + 192), v34);
LABEL_76:
              nw_http2_transport_session_send(v10);
              return;
            }
          }
          v52 = __nwlog_obj();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136447234;
            v57 = "http2_transport_cache_input_frame";
            v58 = 2082;
            v59 = v10 + 205;
            v60 = 2048;
            *(_QWORD *)v61 = a1;
            *(_WORD *)&v61[8] = 2048;
            v62 = v33;
            v63 = 1024;
            v64 = v32;
            _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s resetting input frame %p to buffer %p, length %u", buf, 0x30u);
          }
          goto LABEL_63;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v57 = "nw_protocol_http2_transport_frame_input_finalizer";
        v58 = 2082;
        v59 = v21;
        v22 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v54 = 0;
        if (__nwlog_fault(v22, &type, &v54))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v23 = gLogObj;
            v24 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type))
              goto LABEL_55;
            v25 = nghttp2_strerror();
            *(_DWORD *)buf = 136446466;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v58 = 2082;
            v59 = v25;
            v26 = "%{public}s nghttp2_session_consume_stream: %{public}s failed";
            goto LABEL_54;
          }
          if (!v54)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v23 = gLogObj;
            v24 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type))
              goto LABEL_55;
            v30 = nghttp2_strerror();
            *(_DWORD *)buf = 136446466;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v58 = 2082;
            v59 = v30;
            v26 = "%{public}s nghttp2_session_consume_stream: %{public}s failed, backtrace limit exceeded";
            goto LABEL_54;
          }
          v53 = v19;
          v27 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v23 = gLogObj;
          v24 = type;
          v28 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v27)
          {
            if (v28)
            {
              v29 = nghttp2_strerror();
              *(_DWORD *)buf = 136446722;
              v57 = "nw_protocol_http2_transport_frame_input_finalizer";
              v58 = 2082;
              v59 = v29;
              v60 = 2082;
              *(_QWORD *)v61 = v27;
              _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s nghttp2_session_consume_stream: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v27);
            v19 = v53;
            goto LABEL_55;
          }
          v19 = v53;
          if (v28)
          {
            v31 = nghttp2_strerror();
            *(_DWORD *)buf = 136446466;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v58 = 2082;
            v59 = v31;
            v26 = "%{public}s nghttp2_session_consume_stream: %{public}s failed, no backtrace";
LABEL_54:
            _os_log_impl(&dword_182FBE000, v23, v24, v26, buf, 0x16u);
          }
        }
LABEL_55:
        if (v22)
          free(v22);
        goto LABEL_57;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      v6 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v54 = 0;
      if (__nwlog_fault(v6, &type, &v54))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v9 = "%{public}s called with null stream";
            goto LABEL_36;
          }
        }
        else if (v54)
        {
          v15 = (char *)__nw_create_backtrace_string();
          v7 = __nwlog_obj();
          v8 = type;
          v50 = os_log_type_enabled(v7, type);
          if (v15)
          {
            if (v50)
            {
              *(_DWORD *)buf = 136446466;
              v57 = "nw_protocol_http2_transport_frame_input_finalizer";
              v58 = 2082;
              v59 = (uint64_t)v15;
              v17 = "%{public}s called with null stream, dumping backtrace:%{public}s";
              goto LABEL_18;
            }
            goto LABEL_19;
          }
          if (v50)
          {
            *(_DWORD *)buf = 136446210;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v9 = "%{public}s called with null stream, no backtrace";
            goto LABEL_36;
          }
        }
        else
        {
          v7 = __nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v9 = "%{public}s called with null stream, backtrace limit exceeded";
            goto LABEL_36;
          }
        }
      }
LABEL_37:
      if (v6)
        goto LABEL_38;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v6, &type, &v54))
      goto LABEL_37;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v54)
      {
        v15 = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v49 = os_log_type_enabled(v7, type);
        if (v15)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446466;
            v57 = "nw_protocol_http2_transport_frame_input_finalizer";
            v58 = 2082;
            v59 = (uint64_t)v15;
            v17 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
            goto LABEL_18;
          }
          goto LABEL_19;
        }
        if (v49)
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_protocol_http2_transport_frame_input_finalizer";
          v9 = "%{public}s called with null http2_transport, no backtrace";
          goto LABEL_36;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_protocol_http2_transport_frame_input_finalizer";
          v9 = "%{public}s called with null http2_transport, backtrace limit exceeded";
          goto LABEL_36;
        }
      }
      goto LABEL_37;
    }
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    v9 = "%{public}s called with null http2_transport";
    goto LABEL_36;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v57 = "nw_protocol_http2_transport_frame_input_finalizer";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v54 = 0;
  if (!__nwlog_fault(v6, &type, &v54))
    goto LABEL_37;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    v9 = "%{public}s called with null input_frame_context";
    goto LABEL_36;
  }
  if (!v54)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      v9 = "%{public}s called with null input_frame_context, backtrace limit exceeded";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v44 = os_log_type_enabled(v7, type);
  if (!v15)
  {
    if (v44)
    {
      *(_DWORD *)buf = 136446210;
      v57 = "nw_protocol_http2_transport_frame_input_finalizer";
      v9 = "%{public}s called with null input_frame_context, no backtrace";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if (v44)
  {
    *(_DWORD *)buf = 136446466;
    v57 = "nw_protocol_http2_transport_frame_input_finalizer";
    v58 = 2082;
    v59 = (uint64_t)v15;
    v17 = "%{public}s called with null input_frame_context, dumping backtrace:%{public}s";
    goto LABEL_18;
  }
LABEL_19:
  free(v15);
  if (v6)
LABEL_38:
    free(v6);
}

void nw_http2_transport_session_send(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  int stream_remote_window_size;
  int remote_window_size;
  NSObject *v6;
  int v7;
  int v8;
  int v9;
  char v10;
  NSObject *v11;
  uint64_t v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  uint64_t v16;
  const char *v17;
  char *backtrace_string;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  _BYTE v30[24];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v28 = "nw_http2_transport_session_send";
      v29 = 2082;
      *(_QWORD *)v30 = a1 + 205;
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  if (nghttp2_session_want_write())
  {
    if (gLogDatapath)
    {
      v2 = __nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v28 = "nw_http2_transport_session_send";
        v29 = 2082;
        *(_QWORD *)v30 = a1 + 205;
        v3 = "%{public}s %{public}s nghttp2 wants to write";
LABEL_45:
        _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, v3, buf, 0x16u);
      }
    }
  }
  else if (gLogDatapath)
  {
    v2 = __nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v28 = "nw_http2_transport_session_send";
      v29 = 2082;
      *(_QWORD *)v30 = a1 + 205;
      v3 = "%{public}s %{public}s nghttp2 does not want to write";
      goto LABEL_45;
    }
  }
  if ((*(_BYTE *)(a1 + 204) & 0x20) == 0)
  {
    stream_remote_window_size = nghttp2_session_get_stream_remote_window_size();
    if (stream_remote_window_size >= (int)nghttp2_session_get_remote_window_size())
      remote_window_size = nghttp2_session_get_remote_window_size();
    else
      remote_window_size = nghttp2_session_get_stream_remote_window_size();
    v7 = remote_window_size;
    if (gLogDatapath)
    {
      v24 = __nwlog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v28 = "nw_http2_transport_session_send";
        v29 = 2082;
        *(_QWORD *)v30 = a1 + 205;
        *(_WORD *)&v30[8] = 2048;
        *(_QWORD *)&v30[10] = v7;
        _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s window size that we can send is %llu bytes", buf, 0x20u);
      }
    }
    *(_BYTE *)(a1 + 204) |= 0x20u;
    v8 = nghttp2_session_send();
    if (!v8)
      goto LABEL_37;
    v9 = v8;
    v10 = *(_BYTE *)(a1 + 204);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    if (v9 == -902 && (v10 & 8) != 0)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v28 = "nw_http2_transport_session_send";
        v29 = 2082;
        *(_QWORD *)v30 = a1 + 205;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s tunnel error, send failed, closing", buf, 0x16u);
      }
LABEL_36:
      nw_http2_transport_connection_close(a1);
LABEL_37:
      *(_BYTE *)(a1 + 204) &= ~0x20u;
      return;
    }
    v12 = nghttp2_strerror();
    *(_DWORD *)buf = 136446722;
    v28 = "nw_http2_transport_session_send";
    v29 = 1024;
    *(_DWORD *)v30 = v9;
    *(_WORD *)&v30[4] = 2082;
    *(_QWORD *)&v30[6] = v12;
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v13, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_34;
        v16 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        v28 = "nw_http2_transport_session_send";
        v29 = 1024;
        *(_DWORD *)v30 = v9;
        *(_WORD *)&v30[4] = 2082;
        *(_QWORD *)&v30[6] = v16;
        v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed";
        goto LABEL_33;
      }
      if (!v25)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_34;
        v21 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        v28 = "nw_http2_transport_session_send";
        v29 = 1024;
        *(_DWORD *)v30 = v9;
        *(_WORD *)&v30[4] = 2082;
        *(_QWORD *)&v30[6] = v21;
        v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, backtrace limit exceeded";
        goto LABEL_33;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      v19 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v19)
        {
          v20 = nghttp2_strerror();
          *(_DWORD *)buf = 136446978;
          v28 = "nw_http2_transport_session_send";
          v29 = 1024;
          *(_DWORD *)v30 = v9;
          *(_WORD *)&v30[4] = 2082;
          *(_QWORD *)&v30[6] = v20;
          *(_WORD *)&v30[14] = 2082;
          *(_QWORD *)&v30[16] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, dumping backtrace:%{public}s", buf, 0x26u);
        }
        free(backtrace_string);
        goto LABEL_34;
      }
      if (v19)
      {
        v22 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        v28 = "nw_http2_transport_session_send";
        v29 = 1024;
        *(_DWORD *)v30 = v9;
        *(_WORD *)&v30[4] = 2082;
        *(_QWORD *)&v30[6] = v22;
        v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, no backtrace";
LABEL_33:
        _os_log_impl(&dword_182FBE000, v14, v15, v17, buf, 0x1Cu);
      }
    }
LABEL_34:
    if (v13)
      free(v13);
    goto LABEL_36;
  }
  if (gLogDatapath)
  {
    v6 = __nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v28 = "nw_http2_transport_session_send";
      v29 = 2082;
      *(_QWORD *)v30 = a1 + 205;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s already in session send, skipping", buf, 0x16u);
    }
  }
}

void http2_transport_purge_frame_cache_if_necessary(nw_frame_array_s *a1, _DWORD *a2, unsigned int *a3)
{
  _DWORD *v3;
  _BYTE *v5;
  pthread_once_t *v6;
  NSObject **v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  nw_frame **v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  NSObject **v18;
  pthread_once_t *v19;
  const char *v20;
  char *v21;
  pthread_once_t *v22;
  NSObject *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  NSObject *v26;
  os_log_type_t v27;
  void *v28;
  NSObject *v29;
  int v30;
  int v31;
  NSObject *v32;
  int v33;
  const char *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  nw_frame **v38;
  char *v39;
  uint64_t v40;
  os_log_type_t v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  const char *v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  _BOOL4 v49;
  uint64_t v50;
  os_log_type_t v51;
  unsigned int (*v52)(uint64_t, _QWORD);
  void *v53;
  NSObject *v54;
  int v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  int v59;
  const char *v60;
  int v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  int v65;
  const char *v66;
  char *v67;
  _BOOL4 v68;
  int v69;
  char *v70;
  _BOOL4 v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  const char *v80;
  NSObject *v81;
  int v82;
  char *backtrace_string;
  _BOOL4 v84;
  char *v85;
  _BOOL4 v86;
  _DWORD *v87;
  char v88;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v91;
  __int16 v92;
  _BYTE v93[20];
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v91 = "http2_transport_purge_frame_cache_if_necessary";
    v77 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v88 = 0;
    if (!__nwlog_fault(v77, &type, &v88))
      goto LABEL_140;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_140;
      *(_DWORD *)buf = 136446210;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v80 = "%{public}s called with null frame_cache";
      goto LABEL_139;
    }
    if (!v88)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_140;
      *(_DWORD *)buf = 136446210;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v80 = "%{public}s called with null frame_cache, backtrace limit exceeded";
      goto LABEL_139;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v78 = __nwlog_obj();
    v79 = type;
    v84 = os_log_type_enabled(v78, type);
    if (!backtrace_string)
    {
      if (!v84)
        goto LABEL_140;
      *(_DWORD *)buf = 136446210;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v80 = "%{public}s called with null frame_cache, no backtrace";
      goto LABEL_139;
    }
    if (v84)
    {
      *(_DWORD *)buf = 136446466;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v92 = 2082;
      *(_QWORD *)v93 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null frame_cache, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_140:
    if (!v77)
      return;
    goto LABEL_141;
  }
  v3 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v91 = "http2_transport_purge_frame_cache_if_necessary";
    v77 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v88 = 0;
    if (!__nwlog_fault(v77, &type, &v88))
      goto LABEL_140;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_140;
      *(_DWORD *)buf = 136446210;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v80 = "%{public}s called with null frame_cache_count";
      goto LABEL_139;
    }
    if (!v88)
    {
      v78 = __nwlog_obj();
      v79 = type;
      if (!os_log_type_enabled(v78, type))
        goto LABEL_140;
      *(_DWORD *)buf = 136446210;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v80 = "%{public}s called with null frame_cache_count, backtrace limit exceeded";
      goto LABEL_139;
    }
    v85 = (char *)__nw_create_backtrace_string();
    v78 = __nwlog_obj();
    v79 = type;
    v86 = os_log_type_enabled(v78, type);
    if (v85)
    {
      if (v86)
      {
        *(_DWORD *)buf = 136446466;
        v91 = "http2_transport_purge_frame_cache_if_necessary";
        v92 = 2082;
        *(_QWORD *)v93 = v85;
        _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null frame_cache_count, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v85);
      if (!v77)
        return;
LABEL_141:
      free(v77);
      return;
    }
    if (v86)
    {
      *(_DWORD *)buf = 136446210;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v80 = "%{public}s called with null frame_cache_count, no backtrace";
LABEL_139:
      _os_log_impl(&dword_182FBE000, v78, v79, v80, buf, 0xCu);
      goto LABEL_140;
    }
    goto LABEL_140;
  }
  v5 = &unk_1ECD84000;
  if (gLogDatapath)
  {
    v81 = __nwlog_obj();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
    {
      v82 = *v3;
      *(_DWORD *)buf = 136446466;
      v91 = "http2_transport_purge_frame_cache_if_necessary";
      v92 = 1024;
      *(_DWORD *)v93 = v82;
      _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_DEBUG, "%{public}s total %u empty frames in cache (initial)", buf, 0x12u);
    }
  }
  v87 = v3;
  if (*v3 >= 0x15u)
  {
    v6 = &nwlog_legacy_init(void)::init_once;
    v7 = (NSObject **)&unk_1ECD84000;
    v8 = "http2_transport_purge_frame_cache_if_necessary";
    while (1)
    {
      if (v5[1345])
      {
        v29 = __nwlog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          v30 = *v3;
          *(_DWORD *)buf = 136446722;
          v91 = v8;
          v92 = 1024;
          *(_DWORD *)v93 = v30;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = 20;
          _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s too many frames in frame cache (%u > %u), pruning", buf, 0x18u);
        }
      }
      v9 = **((_QWORD **)a1->tqh_last + 1);
      if (!v9)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = *v3;
        *(_DWORD *)buf = 136446466;
        v91 = v8;
        v92 = 1024;
        *(_DWORD *)v93 = v55;
        v56 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v88 = 0;
        if (!__nwlog_fault(v56, &type, &v88))
          goto LABEL_100;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = v7[463];
          v58 = type;
          if (os_log_type_enabled(v57, type))
          {
            v59 = *v3;
            *(_DWORD *)buf = 136446466;
            v91 = v8;
            v92 = 1024;
            *(_DWORD *)v93 = v59;
            v60 = "%{public}s no more frames in frame cache, we thought we had %u frames";
            goto LABEL_99;
          }
          goto LABEL_100;
        }
        if (v88)
        {
          v67 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = v7[463];
          v58 = type;
          v68 = os_log_type_enabled(v57, type);
          if (v67)
          {
            if (v68)
            {
              v69 = *v3;
              *(_DWORD *)buf = 136446722;
              v91 = v8;
              v92 = 1024;
              *(_DWORD *)v93 = v69;
              *(_WORD *)&v93[4] = 2082;
              *(_QWORD *)&v93[6] = v67;
              _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s no more frames in frame cache, we thought we had %u frames, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v67);
            goto LABEL_100;
          }
          if (!v68)
          {
LABEL_100:
            if (v56)
              free(v56);
            *v3 = 0;
            return;
          }
          v75 = *v3;
          *(_DWORD *)buf = 136446466;
          v91 = v8;
          v92 = 1024;
          *(_DWORD *)v93 = v75;
          v60 = "%{public}s no more frames in frame cache, we thought we had %u frames, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = v7[463];
          v58 = type;
          if (!os_log_type_enabled(v57, type))
            goto LABEL_100;
          v73 = *v3;
          *(_DWORD *)buf = 136446466;
          v91 = v8;
          v92 = 1024;
          *(_DWORD *)v93 = v73;
          v60 = "%{public}s no more frames in frame cache, we thought we had %u frames, backtrace limit exceeded";
        }
LABEL_99:
        _os_log_impl(&dword_182FBE000, v57, v58, v60, buf, 0x12u);
        goto LABEL_100;
      }
      v10 = *(_QWORD *)(v9 + 16);
      v11 = *(nw_frame ***)(v9 + 24);
      if (v10)
      {
        *(_QWORD *)(v10 + 24) = v11;
        v11 = *(nw_frame ***)(v9 + 24);
      }
      else
      {
        a1->tqh_last = v11;
      }
      *v11 = (nw_frame *)v10;
      *(_QWORD *)(v9 + 16) = 0;
      *(_QWORD *)(v9 + 24) = 0;
      if (!*v3)
        break;
      --*v3;
LABEL_31:
      if ((*(_WORD *)(v9 + 204) & 0x100) == 0
        || !g_channel_check_validity
        || ((uint64_t (*)(uint64_t, _QWORD, unsigned int *))g_channel_check_validity)(v9, *(_QWORD *)(v9 + 88), a3))
      {
        v28 = *(void **)(v9 + 112);
        if (v28)
          free(v28);
      }
      nw_frame_reset(v9, 0, 0, 0, 0);
      os_release((void *)v9);
      if (*v3 <= 0x14u)
        goto LABEL_38;
    }
    pthread_once(v6, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v91 = v8;
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v88 = 0;
    if (__nwlog_fault(v12, &type, &v88))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(v6, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = v7[463];
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v91 = v8;
          v15 = v13;
          v16 = v14;
          v17 = "%{public}s http2_transport count attempted to decrement below zero";
LABEL_27:
          _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
        }
      }
      else if (v88)
      {
        v18 = v7;
        v19 = v6;
        v20 = v8;
        v21 = (char *)__nw_create_backtrace_string();
        v22 = v19;
        pthread_once(v19, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = v18;
        v23 = v18[463];
        v24 = type;
        v25 = os_log_type_enabled(v23, type);
        if (v21)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v91 = v20;
            v92 = 2082;
            *(_QWORD *)v93 = v21;
            _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v21);
          v8 = v20;
          v6 = v22;
          v5 = (_BYTE *)&unk_1ECD84000;
          goto LABEL_28;
        }
        v8 = v20;
        v6 = v22;
        v5 = &unk_1ECD84000;
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v91 = v8;
          v15 = v23;
          v16 = v24;
          v17 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
          goto LABEL_27;
        }
      }
      else
      {
        pthread_once(v6, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = v7[463];
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v91 = v8;
          v15 = v26;
          v16 = v27;
          v17 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
          goto LABEL_27;
        }
      }
    }
LABEL_28:
    if (v12)
      free(v12);
    v3 = v87;
    goto LABEL_31;
  }
LABEL_38:
  *(_DWORD *)buf = 0;
  nw_frame_array_get_frame_count((uint64_t *)a1, 0, buf);
  v31 = *(_DWORD *)buf;
  if (*(_DWORD *)buf < 0x1000001u)
  {
LABEL_39:
    if (v5[1345])
    {
      v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        v33 = *v87;
        *(_DWORD *)buf = 136446466;
        v91 = "http2_transport_purge_frame_cache_if_necessary";
        v92 = 1024;
        *(_DWORD *)v93 = v33;
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s total %u empty frames in cache (final)", buf, 0x12u);
      }
    }
    return;
  }
  v34 = "http2_transport_purge_frame_cache_if_necessary";
  v35 = (_QWORD *)&unk_1ECD85000;
  while (1)
  {
    if (v5[1345])
    {
      v54 = __nwlog_obj();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v91 = v34;
        v92 = 1024;
        *(_DWORD *)v93 = v31;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = 0x1000000;
        _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_DEBUG, "%{public}s too many bytes in frame cache (%u > %u), pruning", buf, 0x18u);
      }
    }
    v36 = **((_QWORD **)a1->tqh_last + 1);
    if (!v36)
      break;
    v37 = *(_QWORD *)(v36 + 16);
    v38 = *(nw_frame ***)(v36 + 24);
    if (v37)
    {
      *(_QWORD *)(v37 + 24) = v38;
      v38 = *(nw_frame ***)(v36 + 24);
    }
    else
    {
      a1->tqh_last = v38;
    }
    *v38 = (nw_frame *)v37;
    *(_QWORD *)(v36 + 16) = 0;
    *(_QWORD *)(v36 + 24) = 0;
    if (!*v87)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v91 = v34;
      v39 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v88 = 0;
      if (!__nwlog_fault(v39, &type, &v88))
        goto LABEL_65;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = gLogObj;
        v41 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          v91 = v34;
          v42 = v40;
          v43 = v41;
          v44 = "%{public}s http2_transport count attempted to decrement below zero";
          goto LABEL_64;
        }
        goto LABEL_65;
      }
      if (v88)
      {
        v45 = v34;
        v46 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v47 = gLogObj;
        v48 = type;
        v49 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v46)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446466;
            v91 = v45;
            v92 = 2082;
            *(_QWORD *)v93 = v46;
            _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s http2_transport count attempted to decrement below zero, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v46);
          v34 = v45;
          goto LABEL_65;
        }
        v34 = v45;
        if (!v49)
        {
LABEL_65:
          if (v39)
            free(v39);
          v35 = &unk_1ECD85000;
          goto LABEL_68;
        }
        *(_DWORD *)buf = 136446210;
        v91 = v45;
        v42 = v47;
        v43 = v48;
        v44 = "%{public}s http2_transport count attempted to decrement below zero, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v50 = gLogObj;
        v51 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_65;
        *(_DWORD *)buf = 136446210;
        v91 = v34;
        v42 = v50;
        v43 = v51;
        v44 = "%{public}s http2_transport count attempted to decrement below zero, backtrace limit exceeded";
      }
LABEL_64:
      _os_log_impl(&dword_182FBE000, v42, v43, v44, buf, 0xCu);
      goto LABEL_65;
    }
    --*v87;
LABEL_68:
    if ((*(_WORD *)(v36 + 204) & 0x100) == 0
      || (v52 = (unsigned int (*)(uint64_t, _QWORD))v35[19]) == 0
      || v52(v36, *(_QWORD *)(v36 + 88)))
    {
      v53 = *(void **)(v36 + 112);
      if (v53)
        free(v53);
    }
    nw_frame_reset(v36, 0, 0, 0, 0);
    os_release((void *)v36);
    *(_DWORD *)buf = 0;
    nw_frame_array_get_frame_count((uint64_t *)a1, 0, buf);
    v31 = *(_DWORD *)buf;
    if (*(_DWORD *)buf < 0x1000001u)
      goto LABEL_39;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v61 = *v87;
  *(_DWORD *)buf = 136446722;
  v91 = v34;
  v92 = 1024;
  *(_DWORD *)v93 = v31;
  *(_WORD *)&v93[4] = 1024;
  *(_DWORD *)&v93[6] = v61;
  v62 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v88 = 0;
  if (!__nwlog_fault(v62, &type, &v88))
    goto LABEL_106;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v88)
    {
      v70 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v63 = gLogObj;
      v64 = type;
      v71 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v70)
      {
        if (v71)
        {
          v72 = *v87;
          *(_DWORD *)buf = 136446978;
          v91 = v34;
          v92 = 1024;
          *(_DWORD *)v93 = v31;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v72;
          *(_WORD *)&v93[10] = 2082;
          *(_QWORD *)&v93[12] = v70;
          _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v70);
        goto LABEL_106;
      }
      if (!v71)
        goto LABEL_106;
      v76 = *v87;
      *(_DWORD *)buf = 136446722;
      v91 = v34;
      v92 = 1024;
      *(_DWORD *)v93 = v31;
      *(_WORD *)&v93[4] = 1024;
      *(_DWORD *)&v93[6] = v76;
      v66 = "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v63 = gLogObj;
      v64 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_106;
      v74 = *v87;
      *(_DWORD *)buf = 136446722;
      v91 = v34;
      v92 = 1024;
      *(_DWORD *)v93 = v31;
      *(_WORD *)&v93[4] = 1024;
      *(_DWORD *)&v93[6] = v74;
      v66 = "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames, backtrace limit exceeded";
    }
LABEL_105:
    _os_log_impl(&dword_182FBE000, v63, v64, v66, buf, 0x18u);
    goto LABEL_106;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v63 = gLogObj;
  v64 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    v65 = *v87;
    *(_DWORD *)buf = 136446722;
    v91 = v34;
    v92 = 1024;
    *(_DWORD *)v93 = v31;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v65;
    v66 = "%{public}s no more frames in frame cache, we thought we had %u bytes in %u frames";
    goto LABEL_105;
  }
LABEL_106:
  if (v62)
    free(v62);
  *v87 = 0;
}

uint64_t nw_frame_array_get_frame_count(uint64_t *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  pthread_once_t *v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  pthread_once_t *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  os_log_type_t v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  _BOOL4 v23;
  uint64_t v24;
  os_log_type_t v25;
  char *v26;
  uint64_t v27;
  os_log_type_t v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  _BOOL4 v35;
  uint64_t v36;
  os_log_type_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  os_log_type_t v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  uint64_t v54;
  os_log_type_t v55;
  char *v56;
  uint64_t v57;
  os_log_type_t v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  _BOOL4 v65;
  uint64_t v66;
  os_log_type_t v67;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  char *backtrace_string;
  _BOOL4 v74;
  char v76;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  uint64_t v83;
  __int16 v84;
  uint64_t v85;
  __int16 v86;
  char *v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v79 = "nw_frame_array_get_frame_count";
    v69 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v76 = 0;
    if (__nwlog_fault(v69, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v70 = __nwlog_obj();
        v71 = type;
        if (os_log_type_enabled(v70, type))
        {
          *(_DWORD *)buf = 136446210;
          v79 = "nw_frame_array_get_frame_count";
          v72 = "%{public}s called with null array";
LABEL_112:
          _os_log_impl(&dword_182FBE000, v70, v71, v72, buf, 0xCu);
        }
      }
      else if (v76)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v70 = __nwlog_obj();
        v71 = type;
        v74 = os_log_type_enabled(v70, type);
        if (backtrace_string)
        {
          if (v74)
          {
            *(_DWORD *)buf = 136446466;
            v79 = "nw_frame_array_get_frame_count";
            v80 = 2082;
            v81 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v70, v71, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_113;
        }
        if (v74)
        {
          *(_DWORD *)buf = 136446210;
          v79 = "nw_frame_array_get_frame_count";
          v72 = "%{public}s called with null array, no backtrace";
          goto LABEL_112;
        }
      }
      else
      {
        v70 = __nwlog_obj();
        v71 = type;
        if (os_log_type_enabled(v70, type))
        {
          *(_DWORD *)buf = 136446210;
          v79 = "nw_frame_array_get_frame_count";
          v72 = "%{public}s called with null array, backtrace limit exceeded";
          goto LABEL_112;
        }
      }
    }
LABEL_113:
    if (v69)
      free(v69);
    return 0;
  }
  v3 = *a1;
  if (a2)
  {
    if (v3)
    {
      LODWORD(v4) = 0;
      v5 = 0;
      v6 = &nwlog_legacy_init(void)::init_once;
      while (1)
      {
        v7 = *(_DWORD *)(v3 + 52);
        v8 = v7 ? v7 - (*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60)) : 0;
        v3 = *(_QWORD *)(v3 + 32);
        v9 = (v5 << 31 >> 31) + 1;
        v10 = v9 << 31 >> 31;
        if (v10 != v9 || v10 < 0)
          break;
        v5 = (v5 << 31 >> 31) + 1;
        v11 = __CFADD__((_DWORD)v4, v8);
        v4 = v4 + v8;
        if (v11)
          goto LABEL_33;
LABEL_6:
        if (!v3)
          goto LABEL_96;
      }
      v12 = v6;
      pthread_once(v6, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = v10;
      *(_DWORD *)buf = 136446978;
      v79 = "nw_frame_array_get_frame_count";
      v80 = 2082;
      v81 = "frame_count";
      v82 = 2048;
      v83 = 1;
      v84 = 2048;
      v85 = v10;
      v14 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v76 = 0;
      if (__nwlog_fault(v14, &type, &v76))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(v12, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = gLogObj;
          v16 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_29;
          *(_DWORD *)buf = 136446978;
          v79 = "nw_frame_array_get_frame_count";
          v80 = 2082;
          v81 = "frame_count";
          v82 = 2048;
          v83 = 1;
          v84 = 2048;
          v85 = v13;
          v17 = v15;
          v18 = v16;
          v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_28:
          _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0x2Au);
          goto LABEL_29;
        }
        if (!v76)
        {
          pthread_once(v12, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = gLogObj;
          v25 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_29;
          *(_DWORD *)buf = 136446978;
          v79 = "nw_frame_array_get_frame_count";
          v80 = 2082;
          v81 = "frame_count";
          v82 = 2048;
          v83 = 1;
          v84 = 2048;
          v85 = v13;
          v17 = v24;
          v18 = v25;
          v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_28;
        }
        v20 = (char *)__nw_create_backtrace_string();
        pthread_once(v12, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        v23 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (!v20)
        {
          if (!v23)
            goto LABEL_29;
          *(_DWORD *)buf = 136446978;
          v79 = "nw_frame_array_get_frame_count";
          v80 = 2082;
          v81 = "frame_count";
          v82 = 2048;
          v83 = 1;
          v84 = 2048;
          v85 = v10;
          v17 = v21;
          v18 = v22;
          v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_28;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136447234;
          v79 = "nw_frame_array_get_frame_count";
          v80 = 2082;
          v81 = "frame_count";
          v82 = 2048;
          v83 = 1;
          v84 = 2048;
          v85 = v10;
          v86 = 2082;
          v87 = v20;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v20);
      }
LABEL_29:
      if (v14)
        free(v14);
      v5 = 0xFFFFFFFFLL;
      v6 = v12;
      v11 = __CFADD__((_DWORD)v4, v8);
      v4 = v4 + v8;
      if (!v11)
        goto LABEL_6;
LABEL_33:
      pthread_once(v6, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446978;
      v79 = "nw_frame_array_get_frame_count";
      v80 = 2082;
      v81 = "byte_count";
      v82 = 2048;
      v83 = v8;
      v84 = 2048;
      v85 = v4;
      v26 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v76 = 0;
      if (__nwlog_fault(v26, &type, &v76))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(v6, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = gLogObj;
          v28 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446978;
            v79 = "nw_frame_array_get_frame_count";
            v80 = 2082;
            v81 = "byte_count";
            v82 = 2048;
            v83 = v8;
            v84 = 2048;
            v85 = v4;
            v29 = v27;
            v30 = v28;
            v31 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_46:
            _os_log_impl(&dword_182FBE000, v29, v30, v31, buf, 0x2Au);
          }
        }
        else if (v76)
        {
          v32 = (char *)__nw_create_backtrace_string();
          pthread_once(v6, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = gLogObj;
          v34 = type;
          v35 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v32)
          {
            if (v35)
            {
              *(_DWORD *)buf = 136447234;
              v79 = "nw_frame_array_get_frame_count";
              v80 = 2082;
              v81 = "byte_count";
              v82 = 2048;
              v83 = v8;
              v84 = 2048;
              v85 = v4;
              v86 = 2082;
              v87 = v32;
              _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v32);
            goto LABEL_47;
          }
          if (v35)
          {
            *(_DWORD *)buf = 136446978;
            v79 = "nw_frame_array_get_frame_count";
            v80 = 2082;
            v81 = "byte_count";
            v82 = 2048;
            v83 = v8;
            v84 = 2048;
            v85 = v4;
            v29 = v33;
            v30 = v34;
            v31 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_46;
          }
        }
        else
        {
          pthread_once(v6, nwlog_legacy_init_once);
          networkd_settings_init();
          v36 = gLogObj;
          v37 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446978;
            v79 = "nw_frame_array_get_frame_count";
            v80 = 2082;
            v81 = "byte_count";
            v82 = 2048;
            v83 = v8;
            v84 = 2048;
            v85 = v4;
            v29 = v36;
            v30 = v37;
            v31 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_46;
          }
        }
      }
LABEL_47:
      if (v26)
        free(v26);
      LODWORD(v4) = -1;
      goto LABEL_6;
    }
    goto LABEL_95;
  }
  if (v3)
  {
    LODWORD(v38) = 0;
    v5 = 0;
    while (1)
    {
      v39 = *(_DWORD *)(v3 + 52);
      v40 = v39 ? v39 - (*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60)) : 0;
      v3 = *(_QWORD *)(v3 + 16);
      v41 = (v5 << 31 >> 31) + 1;
      v42 = v41 << 31 >> 31;
      if (v42 != v41 || v42 < 0)
        break;
      v5 = (v5 << 31 >> 31) + 1;
      v11 = __CFADD__((_DWORD)v38, v40);
      v38 = v38 + v40;
      if (v11)
        goto LABEL_79;
LABEL_52:
      LODWORD(v4) = v38;
      if (!v3)
        goto LABEL_96;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = v42;
    *(_DWORD *)buf = 136446978;
    v79 = "nw_frame_array_get_frame_count";
    v80 = 2082;
    v81 = "frame_count";
    v82 = 2048;
    v83 = 1;
    v84 = 2048;
    v85 = v42;
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v76 = 0;
    if (__nwlog_fault(v44, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v45 = gLogObj;
        v46 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446978;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1;
        v84 = 2048;
        v85 = v43;
        v47 = v45;
        v48 = v46;
        v49 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_74:
        _os_log_impl(&dword_182FBE000, v47, v48, v49, buf, 0x2Au);
        goto LABEL_75;
      }
      if (!v76)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v54 = gLogObj;
        v55 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_75;
        *(_DWORD *)buf = 136446978;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1;
        v84 = 2048;
        v85 = v43;
        v47 = v54;
        v48 = v55;
        v49 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_74;
      }
      v50 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = gLogObj;
      v52 = type;
      v53 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v50)
      {
        if (!v53)
          goto LABEL_75;
        *(_DWORD *)buf = 136446978;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1;
        v84 = 2048;
        v85 = v42;
        v47 = v51;
        v48 = v52;
        v49 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_74;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136447234;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1;
        v84 = 2048;
        v85 = v42;
        v86 = 2082;
        v87 = v50;
        _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
      }
      free(v50);
    }
LABEL_75:
    if (v44)
      free(v44);
    v5 = 0xFFFFFFFFLL;
    v11 = __CFADD__((_DWORD)v38, v40);
    v38 = v38 + v40;
    if (!v11)
      goto LABEL_52;
LABEL_79:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    v79 = "nw_frame_array_get_frame_count";
    v80 = 2082;
    v81 = "byte_count";
    v82 = 2048;
    v83 = v40;
    v84 = 2048;
    v85 = v38;
    v56 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v76 = 0;
    if (__nwlog_fault(v56, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v57 = gLogObj;
        v58 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          v79 = "nw_frame_array_get_frame_count";
          v80 = 2082;
          v81 = "byte_count";
          v82 = 2048;
          v83 = v40;
          v84 = 2048;
          v85 = v38;
          v59 = v57;
          v60 = v58;
          v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_92:
          _os_log_impl(&dword_182FBE000, v59, v60, v61, buf, 0x2Au);
        }
      }
      else if (v76)
      {
        v62 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v63 = gLogObj;
        v64 = type;
        v65 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v62)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136447234;
            v79 = "nw_frame_array_get_frame_count";
            v80 = 2082;
            v81 = "byte_count";
            v82 = 2048;
            v83 = v40;
            v84 = 2048;
            v85 = v38;
            v86 = 2082;
            v87 = v62;
            _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v62);
          goto LABEL_93;
        }
        if (v65)
        {
          *(_DWORD *)buf = 136446978;
          v79 = "nw_frame_array_get_frame_count";
          v80 = 2082;
          v81 = "byte_count";
          v82 = 2048;
          v83 = v40;
          v84 = 2048;
          v85 = v38;
          v59 = v63;
          v60 = v64;
          v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_92;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v66 = gLogObj;
        v67 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446978;
          v79 = "nw_frame_array_get_frame_count";
          v80 = 2082;
          v81 = "byte_count";
          v82 = 2048;
          v83 = v40;
          v84 = 2048;
          v85 = v38;
          v59 = v66;
          v60 = v67;
          v61 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_92;
        }
      }
    }
LABEL_93:
    if (v56)
      free(v56);
    LODWORD(v38) = -1;
    goto LABEL_52;
  }
LABEL_95:
  v5 = 0;
  LODWORD(v4) = 0;
LABEL_96:
  if (a3)
    *a3 = v4;
  return v5;
}

uint64_t ___ZL50nw_protocol_http2_transport_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

void nw_protocol_http2_transport_frame_output_finalizer(nw_frame *a1, int a2, void *a3)
{
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  __int16 v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  _BOOL4 v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  void *buffer;
  NSObject *v23;
  nw_frame *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  nw_frame *v29;
  char *v30;
  _BOOL4 v31;
  _QWORD *v32;
  nw_frame *v33;
  char *v34;
  _BOOL4 v35;
  const char *v36;
  _BOOL4 v37;
  _QWORD *v38;
  char *backtrace_string;
  _BOOL4 v40;
  NSObject *v41;
  _BOOL4 v42;
  _BOOL4 v43;
  NSObject *v44;
  int v45;
  _QWORD *v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  int v50;
  char v51;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v54;
  __int16 v55;
  nw_frame *v56;
  __int16 v57;
  _QWORD v58[3];

  v58[2] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v3, &type, &v51))
      goto LABEL_38;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v51)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v40 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446466;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = (nw_frame *)backtrace_string;
            _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_37;
        }
      }
      else
      {
        v4 = __nwlog_obj();
        v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_37;
        }
      }
      goto LABEL_38;
    }
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    v6 = "%{public}s called with null frame";
LABEL_37:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_38;
  }
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (!__nwlog_fault(v3, &type, &v51))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      v6 = "%{public}s http2_transport output frames should no longer have nonnull context";
      goto LABEL_37;
    }
    if (!v51)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      v6 = "%{public}s http2_transport output frames should no longer have nonnull context, backtrace limit exceeded";
      goto LABEL_37;
    }
    v15 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = gLogObj;
    v5 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v15)
    {
      if (!v16)
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      v6 = "%{public}s http2_transport output frames should no longer have nonnull context, no backtrace";
      goto LABEL_37;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      v55 = 2082;
      v56 = (nw_frame *)v15;
      v17 = "%{public}s http2_transport output frames should no longer have nonnull context, dumping backtrace:%{public}s";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v4, v5, v17, buf, 0x16u);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  if (gLogDatapath)
  {
    v41 = __nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      v55 = 2048;
      v56 = a1;
      v57 = 1024;
      LODWORD(v58[0]) = a2;
      WORD2(v58[0]) = 2048;
      *(_QWORD *)((char *)v58 + 6) = 0;
      _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s called with frame %p success %d context %p", buf, 0x26u);
    }
  }
  v9 = *((_WORD *)a1 + 102);
  v10 = (uint64_t *)((char *)a1 + 208);
  if ((v9 & 4) != 0)
  {
    v11 = *v10;
    if (*v10)
    {
      v12 = *((_QWORD *)a1 + 2);
      v13 = (_QWORD *)*((_QWORD *)a1 + 3);
      v14 = (_QWORD *)((char *)a1 + 16);
      if (v12)
      {
        *(_QWORD *)(v12 + 24) = v13;
        v13 = (_QWORD *)*((_QWORD *)a1 + 3);
      }
      else
      {
        *(_QWORD *)(v11 + 136) = v13;
      }
      *v13 = v12;
      *v14 = 0;
      *((_QWORD *)a1 + 3) = 0;
      if (!a2)
      {
        if (gLogDatapath)
        {
          v23 = __nwlog_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = (nw_frame *)(v11 + 205);
            _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s disposing of output frame, finalizer called with success == false", buf, 0x16u);
          }
        }
        goto LABEL_89;
      }
      v18 = *((_QWORD *)a1 + 27);
      if (v18)
      {
        v19 = *(_QWORD *)(v18 + 56);
        if (v19)
        {
          v20 = *(_QWORD *)(v19 + 32);
          if (v20)
          {
            if ((*(_BYTE *)(v20 + 36) & 1) != 0 || *(int *)(v20 + 32) < 1)
            {
              if (*(_QWORD *)(v20 + 16))
              {
                if (gLogDatapath)
                {
                  v44 = __nwlog_obj();
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446466;
                    v54 = "nw_protocol_http2_transport_frame_output_finalizer";
                    v55 = 2082;
                    v56 = (nw_frame *)(v11 + 205);
                    _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s stream already has pending data, simply pending for future send", buf, 0x16u);
                  }
                  v45 = gLogDatapath;
                  *((_QWORD *)a1 + 2) = 0;
                  v46 = *(_QWORD **)(v20 + 24);
                  *((_QWORD *)a1 + 3) = v46;
                  *v46 = a1;
                  *(_QWORD *)(v20 + 24) = v14;
                  if (v45)
                  {
                    v47 = __nwlog_obj();
                    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 0;
                      nw_frame_array_get_frame_count((uint64_t *)(v20 + 16), 0, buf);
                      v48 = *(_DWORD *)buf;
                      *(_DWORD *)buf = 136446722;
                      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
                      v55 = 2082;
                      v56 = (nw_frame *)(v11 + 205);
                      v57 = 1024;
                      LODWORD(v58[0]) = v48;
                      _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s stream now has %u bytes pending", buf, 0x1Cu);
                    }
                  }
                }
                else
                {
                  *((_QWORD *)a1 + 2) = 0;
                  v32 = *(_QWORD **)(v20 + 24);
                  *((_QWORD *)a1 + 3) = v32;
                  *v32 = a1;
                  *(_QWORD *)(v20 + 24) = v14;
                }
              }
              else
              {
                if (!nw_http2_transport_submit_data(v11, (uint64_t)a1))
                {
                  *((_QWORD *)a1 + 2) = 0;
                  v38 = *(_QWORD **)(v20 + 24);
                  *((_QWORD *)a1 + 3) = v38;
                  *v38 = a1;
                  *(_QWORD *)(v20 + 24) = v14;
                  if (gLogDatapath)
                  {
                    v49 = __nwlog_obj();
                    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 0;
                      nw_frame_array_get_frame_count((uint64_t *)(v20 + 16), 0, buf);
                      v50 = *(_DWORD *)buf;
                      *(_DWORD *)buf = 136446722;
                      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
                      v55 = 2082;
                      v56 = (nw_frame *)(v11 + 205);
                      v57 = 1024;
                      LODWORD(v58[0]) = v50;
                      _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s stream now has %u bytes pending", buf, 0x1Cu);
                    }
                  }
                }
                nw_http2_transport_session_send(v11);
              }
              return;
            }
            v21 = __nwlog_obj();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              v55 = 2082;
              v56 = (nw_frame *)(v11 + 205);
              _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Cannot send data on a stream that is not open but has a greater than zero stream id", buf, 0x16u);
            }
            buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0);
            if (!buffer)
            {
LABEL_94:
              nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
              os_release(a1);
              return;
            }
LABEL_93:
            free(buffer);
            goto LABEL_94;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (nw_frame *)(v11 + 205);
          *(_DWORD *)buf = 136446466;
          v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v55 = 2082;
          v56 = (nw_frame *)(v11 + 205);
          v25 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v51 = 0;
          if (__nwlog_fault(v25, &type, &v51))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v26 = __nwlog_obj();
              v27 = type;
              if (!os_log_type_enabled(v26, type))
                goto LABEL_87;
              *(_DWORD *)buf = 136446466;
              v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              v55 = 2082;
              v56 = v33;
              v28 = "%{public}s %{public}s stream not found";
              goto LABEL_86;
            }
            if (!v51)
            {
              v26 = __nwlog_obj();
              v27 = type;
              if (!os_log_type_enabled(v26, type))
                goto LABEL_87;
              *(_DWORD *)buf = 136446466;
              v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              v55 = 2082;
              v56 = v33;
              v28 = "%{public}s %{public}s stream not found, backtrace limit exceeded";
              goto LABEL_86;
            }
            v34 = (char *)__nw_create_backtrace_string();
            v26 = __nwlog_obj();
            v27 = type;
            v37 = os_log_type_enabled(v26, type);
            if (!v34)
            {
              if (!v37)
                goto LABEL_87;
              *(_DWORD *)buf = 136446466;
              v54 = "nw_protocol_http2_transport_frame_output_finalizer";
              v55 = 2082;
              v56 = v33;
              v28 = "%{public}s %{public}s stream not found, no backtrace";
              goto LABEL_86;
            }
            if (!v37)
              goto LABEL_69;
            *(_DWORD *)buf = 136446722;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v33;
            v57 = 2082;
            v58[0] = v34;
            v36 = "%{public}s %{public}s stream not found, dumping backtrace:%{public}s";
            goto LABEL_68;
          }
LABEL_87:
          if (!v25)
            goto LABEL_89;
          goto LABEL_88;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = (nw_frame *)(v11 + 205);
        *(_DWORD *)buf = 136446466;
        v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = (nw_frame *)(v11 + 205);
        v25 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v51 = 0;
        if (!__nwlog_fault(v25, &type, &v51))
          goto LABEL_87;
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v51)
          {
            v26 = __nwlog_obj();
            v27 = type;
            if (!os_log_type_enabled(v26, type))
              goto LABEL_87;
            *(_DWORD *)buf = 136446466;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v29;
            v28 = "%{public}s %{public}s node not found, backtrace limit exceeded";
            goto LABEL_86;
          }
          v34 = (char *)__nw_create_backtrace_string();
          v26 = __nwlog_obj();
          v27 = type;
          v35 = os_log_type_enabled(v26, type);
          if (!v34)
          {
            if (!v35)
              goto LABEL_87;
            *(_DWORD *)buf = 136446466;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v29;
            v28 = "%{public}s %{public}s node not found, no backtrace";
            goto LABEL_86;
          }
          if (!v35)
            goto LABEL_69;
          *(_DWORD *)buf = 136446722;
          v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v55 = 2082;
          v56 = v29;
          v57 = 2082;
          v58[0] = v34;
          v36 = "%{public}s %{public}s node not found, dumping backtrace:%{public}s";
LABEL_68:
          _os_log_impl(&dword_182FBE000, v26, v27, v36, buf, 0x20u);
LABEL_69:
          free(v34);
          if (v25)
LABEL_88:
            free(v25);
LABEL_89:
          if ((*((_WORD *)a1 + 102) & 0x100) != 0
            && g_channel_check_validity
            && !g_channel_check_validity(a1, *((_QWORD *)a1 + 11)))
          {
            goto LABEL_94;
          }
          buffer = (void *)*((_QWORD *)a1 + 14);
          if (!buffer)
            goto LABEL_94;
          goto LABEL_93;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = gLogObj;
        v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_87;
        *(_DWORD *)buf = 136446466;
        v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = v29;
        v28 = "%{public}s %{public}s node not found";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (nw_frame *)(v11 + 205);
        *(_DWORD *)buf = 136446466;
        v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = (nw_frame *)(v11 + 205);
        v25 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v51 = 0;
        if (!__nwlog_fault(v25, &type, &v51))
          goto LABEL_87;
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v51)
          {
            v26 = __nwlog_obj();
            v27 = type;
            if (!os_log_type_enabled(v26, type))
              goto LABEL_87;
            *(_DWORD *)buf = 136446466;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v24;
            v28 = "%{public}s %{public}s input_protocol not found, backtrace limit exceeded";
            goto LABEL_86;
          }
          v30 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = gLogObj;
          v27 = type;
          v31 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (!v30)
          {
            if (!v31)
              goto LABEL_87;
            *(_DWORD *)buf = 136446466;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v24;
            v28 = "%{public}s %{public}s input_protocol not found, no backtrace";
            goto LABEL_86;
          }
          if (v31)
          {
            *(_DWORD *)buf = 136446722;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = v24;
            v57 = 2082;
            v58[0] = v30;
            _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s %{public}s input_protocol not found, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v30);
          goto LABEL_87;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = gLogObj;
        v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_87;
        *(_DWORD *)buf = 136446466;
        v54 = "nw_protocol_http2_transport_frame_output_finalizer";
        v55 = 2082;
        v56 = v24;
        v28 = "%{public}s %{public}s input_protocol not found";
      }
LABEL_86:
      _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0x16u);
      goto LABEL_87;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v3, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v4 = __nwlog_obj();
        v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v6 = "%{public}s called with null http2_transport";
          goto LABEL_37;
        }
      }
      else if (v51)
      {
        v15 = (char *)__nw_create_backtrace_string();
        v4 = __nwlog_obj();
        v5 = type;
        v43 = os_log_type_enabled(v4, type);
        if (v15)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            v54 = "nw_protocol_http2_transport_frame_output_finalizer";
            v55 = 2082;
            v56 = (nw_frame *)v15;
            v17 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
            goto LABEL_16;
          }
          goto LABEL_17;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v6 = "%{public}s called with null http2_transport, no backtrace";
          goto LABEL_37;
        }
      }
      else
      {
        v4 = __nwlog_obj();
        v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          v54 = "nw_protocol_http2_transport_frame_output_finalizer";
          v6 = "%{public}s called with null http2_transport, backtrace limit exceeded";
          goto LABEL_37;
        }
      }
    }
LABEL_38:
    if (v3)
      goto LABEL_39;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v54 = "nw_protocol_http2_transport_frame_output_finalizer";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (!__nwlog_fault(v3, &type, &v51))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    v6 = "%{public}s called with null output_context";
    goto LABEL_37;
  }
  if (!v51)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (os_log_type_enabled(v4, type))
    {
      *(_DWORD *)buf = 136446210;
      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      v6 = "%{public}s called with null output_context, backtrace limit exceeded";
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  v15 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v42 = os_log_type_enabled(v4, type);
  if (!v15)
  {
    if (v42)
    {
      *(_DWORD *)buf = 136446210;
      v54 = "nw_protocol_http2_transport_frame_output_finalizer";
      v6 = "%{public}s called with null output_context, no backtrace";
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  if (v42)
  {
    *(_DWORD *)buf = 136446466;
    v54 = "nw_protocol_http2_transport_frame_output_finalizer";
    v55 = 2082;
    v56 = (nw_frame *)v15;
    v17 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
    goto LABEL_16;
  }
LABEL_17:
  free(v15);
  if (v3)
LABEL_39:
    free(v3);
}

BOOL nw_http2_transport_submit_data(uint64_t a1, uint64_t a2)
{
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v11;
  _QWORD *v12;
  int v13;
  NSObject *v14;
  _BOOL8 result;
  int v16;
  char *v17;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  char *v24;
  _BOOL4 v25;
  uint64_t v26;
  NSObject *v27;
  os_log_type_t v28;
  uint32_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *backtrace_string;
  _BOOL4 v37;
  NSObject *v38;
  void *v39;
  _BOOL4 v40;
  _BOOL4 v41;
  _BOOL4 v42;
  NSObject *v43;
  int v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  _QWORD v52[3];

  v52[2] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "__nw_frame_get_metadata";
    v32 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v32, &type, &v45))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "__nw_frame_get_metadata";
      v35 = "%{public}s called with null frame";
    }
    else if (v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v37 = os_log_type_enabled(v33, type);
      if (backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v48 = "__nw_frame_get_metadata";
          v49 = 2082;
          v50 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_94;
      }
      if (!v37)
      {
LABEL_94:
        if (v32)
          free(v32);
        goto LABEL_3;
      }
      *(_DWORD *)buf = 136446210;
      v48 = "__nw_frame_get_metadata";
      v35 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "__nw_frame_get_metadata";
      v35 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
    goto LABEL_94;
  }
  if ((*(_WORD *)(a2 + 204) & 4) == 0)
  {
LABEL_3:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_http2_transport_submit_data";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45))
      goto LABEL_46;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null output_context";
      goto LABEL_39;
    }
    if (!v45)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null output_context, backtrace limit exceeded";
      goto LABEL_39;
    }
    v17 = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v18 = os_log_type_enabled(v4, type);
    if (!v17)
    {
      if (!v18)
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null output_context, no backtrace";
      goto LABEL_39;
    }
    if (!v18)
    {
LABEL_23:
      free(v17);
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446466;
    v48 = "nw_http2_transport_submit_data";
    v49 = 2082;
    v50 = (uint64_t)v17;
    v19 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
LABEL_22:
    _os_log_impl(&dword_182FBE000, v4, v5, v19, buf, 0x16u);
    goto LABEL_23;
  }
  v7 = *(_QWORD *)(a2 + 216);
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_http2_transport_submit_data";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45))
      goto LABEL_46;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null input_protocol";
    }
    else if (v45)
    {
      v17 = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v40 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v40)
          goto LABEL_23;
        *(_DWORD *)buf = 136446466;
        v48 = "nw_http2_transport_submit_data";
        v49 = 2082;
        v50 = (uint64_t)v17;
        v19 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_22;
      }
      if (!v40)
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null input_protocol, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    }
    goto LABEL_39;
  }
  v8 = *(_QWORD *)(v7 + 56);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_http2_transport_submit_data";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45))
      goto LABEL_46;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null node";
    }
    else if (v45)
    {
      v17 = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v41 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v41)
          goto LABEL_23;
        *(_DWORD *)buf = 136446466;
        v48 = "nw_http2_transport_submit_data";
        v49 = 2082;
        v50 = (uint64_t)v17;
        v19 = "%{public}s called with null node, dumping backtrace:%{public}s";
        goto LABEL_22;
      }
      if (!v41)
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null node, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null node, backtrace limit exceeded";
    }
    goto LABEL_39;
  }
  v9 = *(_QWORD *)(v8 + 32);
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_http2_transport_submit_data";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v3, &type, &v45))
      goto LABEL_46;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null stream";
    }
    else if (v45)
    {
      v17 = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v42 = os_log_type_enabled(v4, type);
      if (v17)
      {
        if (!v42)
          goto LABEL_23;
        *(_DWORD *)buf = 136446466;
        v48 = "nw_http2_transport_submit_data";
        v49 = 2082;
        v50 = (uint64_t)v17;
        v19 = "%{public}s called with null stream, dumping backtrace:%{public}s";
        goto LABEL_22;
      }
      if (!v42)
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null stream, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_http2_transport_submit_data";
      v6 = "%{public}s called with null stream, backtrace limit exceeded";
    }
LABEL_39:
    v27 = v4;
    v28 = v5;
    v29 = 12;
LABEL_45:
    _os_log_impl(&dword_182FBE000, v27, v28, v6, buf, v29);
    goto LABEL_46;
  }
  v11 = *(_DWORD *)(v9 + 32);
  v12 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (!v12)
  {
    v38 = __nwlog_obj();
    os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v48 = "strict_calloc";
    v49 = 2048;
    v50 = 1;
    v51 = 2048;
    v52[0] = 16;
    v39 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v39);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v39);
  }
  *v12 = a2;
  v12[1] = data_source_read_callback;
  v13 = nghttp2_submit_data();
  free(v12);
  if (v13)
  {
    if (v13 == -529)
    {
      if (gLogDatapath)
      {
        v14 = __nwlog_obj();
        result = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
        if (!result)
          return result;
        v16 = *(_DWORD *)(a2 + 52);
        if (v16)
          v16 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
        *(_DWORD *)buf = 136446978;
        v48 = "nw_http2_transport_submit_data";
        v49 = 2082;
        v50 = a1 + 205;
        v51 = 1024;
        LODWORD(v52[0]) = v11;
        WORD2(v52[0]) = 1024;
        *(_DWORD *)((char *)v52 + 6) = v16;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s already have data outgoing on stream %d, cannot send %u bytes", buf, 0x22u);
      }
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = nghttp2_strerror();
    *(_DWORD *)buf = 136446466;
    v48 = "nw_http2_transport_submit_data";
    v49 = 2082;
    v50 = v20;
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v3, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_46;
        v23 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v48 = "nw_http2_transport_submit_data";
        v49 = 2082;
        v50 = v23;
        v6 = "%{public}s nghttp2_submit_data: %{public}s failed";
        goto LABEL_44;
      }
      if (!v45)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_46;
        v30 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v48 = "nw_http2_transport_submit_data";
        v49 = 2082;
        v50 = v30;
        v6 = "%{public}s nghttp2_submit_data: %{public}s failed, backtrace limit exceeded";
        goto LABEL_44;
      }
      v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      v22 = type;
      v25 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v24)
      {
        if (v25)
        {
          v26 = nghttp2_strerror();
          *(_DWORD *)buf = 136446722;
          v48 = "nw_http2_transport_submit_data";
          v49 = 2082;
          v50 = v26;
          v51 = 2082;
          v52[0] = v24;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s nghttp2_submit_data: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v24);
        goto LABEL_46;
      }
      if (v25)
      {
        v31 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v48 = "nw_http2_transport_submit_data";
        v49 = 2082;
        v50 = v31;
        v6 = "%{public}s nghttp2_submit_data: %{public}s failed, no backtrace";
LABEL_44:
        v27 = v21;
        v28 = v22;
        v29 = 22;
        goto LABEL_45;
      }
    }
LABEL_46:
    if (v3)
      free(v3);
    return 0;
  }
  if (gLogDatapath)
  {
    v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      v44 = *(_DWORD *)(a2 + 52);
      if (v44)
        v44 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
      *(_DWORD *)buf = 136446978;
      v48 = "nw_http2_transport_submit_data";
      v49 = 2082;
      v50 = a1 + 205;
      v51 = 1024;
      LODWORD(v52[0]) = v44;
      WORD2(v52[0]) = 1024;
      *(_DWORD *)((char *)v52 + 6) = v11;
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s submitted %u bytes on stream %d", buf, 0x22u);
    }
  }
  return 1;
}

void nw_quic_save_token_on_queue(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  id *cached_content_for_protocol;
  int64_t int64_with_default;
  time_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  NSObject *v23;
  void *v24;
  void *v25;
  os_log_type_t v26;
  os_log_type_t v27;
  os_log_type_t v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_quic_save_token_on_queue";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v10, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_quic_save_token_on_queue";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        v19 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v36 = "nw_quic_save_token_on_queue";
            v37 = 2082;
            v38 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_51;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_quic_save_token_on_queue";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_quic_save_token_on_queue";
          _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_51:
    if (v10)
      free(v10);
    goto LABEL_9;
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  v5 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (!v5)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_quic_save_token_on_queue";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33))
      goto LABEL_62;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v33)
    {
      v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v15, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v36 = "nw_quic_save_token_on_queue";
          v37 = 2082;
          v38 = (uint64_t)v20;
          _os_log_impl(&dword_182FBE000, v15, v21, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
LABEL_62:
        if (!v14)
          goto LABEL_8;
LABEL_63:
        free(v14);
        goto LABEL_8;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_182FBE000, v15, v21, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_182FBE000, v15, v28, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_61:

    goto LABEL_62;
  }
  cached_content_for_protocol = (id *)nw_association_get_cached_content_for_protocol(v3, v5);
  if (cached_content_for_protocol
    || (cached_content_for_protocol = (id *)malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL)) != 0)
  {
    objc_storeStrong(cached_content_for_protocol, a2);
    int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_quic_failure_cache_seconds, 1800);
    v8 = time(0);
    nw_association_set_cached_content_for_protocol(v3, v5, (uint64_t)cached_content_for_protocol, v8 + int64_with_default);
LABEL_8:

LABEL_9:
    return;
  }
  __nwlog_obj();
  v23 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v36 = "strict_calloc";
  v37 = 2048;
  v38 = 1;
  v39 = 2048;
  v40 = 48;
  v24 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v24))
  {
    free(v24);
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_quic_save_token_on_queue";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33))
      goto LABEL_62;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_182FBE000, v15, v26, "%{public}s called with null association_cache", buf, 0xCu);
      }
    }
    else if (v33)
    {
      v29 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      v31 = os_log_type_enabled(v15, type);
      if (v29)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v36 = "nw_quic_save_token_on_queue";
          v37 = 2082;
          v38 = (uint64_t)v29;
          _os_log_impl(&dword_182FBE000, v15, v30, "%{public}s called with null association_cache, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v29);
        if (!v14)
          goto LABEL_8;
        goto LABEL_63;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_182FBE000, v15, v30, "%{public}s called with null association_cache, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_quic_save_token_on_queue";
        _os_log_impl(&dword_182FBE000, v15, v32, "%{public}s called with null association_cache, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_61;
  }
  __break(1u);
}

void sub_183206920(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_ipv4_updated_path(nw_protocol *a1, nw_protocol *a2, nw_path *a3)
{
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_ipv4_updated_path";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_ipv4_updated_path";
      v9 = "%{public}s called with null protocol";
LABEL_44:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      goto LABEL_45;
    }
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv4_updated_path";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv4_updated_path";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v11)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    v18 = "nw_protocol_ipv4_updated_path";
    v19 = 2082;
    v20 = backtrace_string;
    v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_30:
    _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
    goto LABEL_31;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_ipv4_updated_path";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_ipv4_updated_path";
      v9 = "%{public}s called with null ipv4";
      goto LABEL_44;
    }
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv4_updated_path";
        v9 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv4_updated_path";
        v9 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v13)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    v18 = "nw_protocol_ipv4_updated_path";
    v19 = 2082;
    v20 = backtrace_string;
    v12 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
    goto LABEL_30;
  }
  if (a3)
  {
    LODWORD(a1[3].identifier) = nw_path_get_maximum_packet_size(a3);
    HIDWORD(a1[3].identifier) = nw_path_get_mtu(a3);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_ipv4_updated_path";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v6, &type, &v15))
    goto LABEL_45;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv4_updated_path";
        v9 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_ipv4_updated_path";
        v9 = "%{public}s called with null path, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v18 = "nw_protocol_ipv4_updated_path";
      v19 = 2082;
      v20 = backtrace_string;
      v12 = "%{public}s called with null path, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
LABEL_31:
    free(backtrace_string);
    goto LABEL_45;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_ipv4_updated_path";
    v9 = "%{public}s called with null path";
    goto LABEL_44;
  }
LABEL_45:
  if (v6)
    free(v6);
  return 0;
}

nw_path_t nw_connection_copy_current_path(nw_connection_t connection)
{
  NSObject *v1;
  os_unfair_lock_s *v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  NSObject *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v19)(uint64_t, uint64_t);
  void (*v20)(uint64_t);
  id v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = connection;
  v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v19 = __Block_byref_object_copy__24122;
    v20 = __Block_byref_object_dispose__24123;
    v21 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_current_path_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_current_path_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(id *)(*(_QWORD *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_copy_current_path";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_current_path";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_copy_current_path";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_current_path";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_current_path";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_current_path_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  char *v4;
  os_unfair_lock_s *v5;
  os_unfair_lock_s *v6;
  id *v7;
  os_unfair_lock_s *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  id v13;
  void *v14;
  id v15;
  id v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  const char *v20;
  nw_endpoint_t v21;
  const char *logging_description;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  void **v28;
  void **v29;
  const char *v30;
  id *v31;
  id v32;
  uint64_t v33;
  void *v34;
  void *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  const char *v43;
  const char *v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  const char *v56;
  __int16 v57;
  const char *v58;
  __int16 v59;
  id v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    v10 = nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v12 = *(void **)(v11 + 40);
    *(_QWORD *)(v11 + 40) = v10;

    return;
  }
  v3 = *(void **)(v2 + 152);
  if (v3)
  {
    v4 = v3;
    v5 = (os_unfair_lock_s *)(v4 + 112);
    os_unfair_lock_lock((os_unfair_lock_t)v4 + 28);
    if (*((_DWORD *)v4 + 29) != 2)
    {
      os_unfair_lock_unlock(v5);
      if ((v4[268] & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v19 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          if ((v4[268] & 1) != 0)
            v20 = "dry-run ";
          else
            v20 = "";
          v21 = nw_endpoint_handler_copy_endpoint(v4);
          logging_description = nw_endpoint_get_logging_description(v21);
          v23 = *((unsigned int *)v4 + 30);
          v44 = logging_description;
          if (v23 > 5)
            v24 = "unknown-state";
          else
            v24 = off_1E149FC48[v23];
          v43 = v24;
          v28 = v4;
          v29 = v28;
          v30 = "path";
          switch(*((_DWORD *)v4 + 29))
          {
            case 0:
              break;
            case 1:
              v30 = "resolver";
              break;
            case 2:
              v30 = nw_endpoint_flow_mode_string(v28[31]);
              break;
            case 3:
              v30 = "proxy";
              break;
            case 4:
              v30 = "fallback";
              break;
            case 5:
              v30 = "transform";
              break;
            default:
              v30 = "unknown-mode";
              break;
          }

          v31 = v29;
          os_unfair_lock_lock(v5);
          v32 = v31[8];
          os_unfair_lock_unlock(v5);

          *(_DWORD *)buf = 136447746;
          v48 = "nw_endpoint_handler_copy_flow_path";
          v49 = 2082;
          v50 = v4 + 168;
          v51 = 2082;
          v52 = v20;
          v53 = 2082;
          v54 = v44;
          v55 = 2082;
          v56 = v43;
          v57 = 2082;
          v58 = v30;
          v59 = 2114;
          v60 = v32;
          _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is not flow", buf, 0x48u);

        }
      }
      v9 = 0;
      goto LABEL_39;
    }
    v6 = (os_unfair_lock_s *)*((id *)v4 + 31);
    if (v6)
    {
      v7 = (id *)v6;
      v8 = v6 + 220;
      os_unfair_lock_lock(v6 + 220);
      v9 = v7[2];
      os_unfair_lock_unlock(v8);

      if (v9)
      {
LABEL_7:
        os_unfair_lock_unlock(v5);
LABEL_39:

        v33 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v34 = *(void **)(v33 + 40);
        *(_QWORD *)(v33 + 40) = v9;

        return;
      }
LABEL_6:
      v9 = *((id *)v4 + 8);
      goto LABEL_7;
    }
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_endpoint_flow_copy_flow_path";
    v36 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v36, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_endpoint_flow_copy_flow_path";
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if (v45)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v40 = type;
        v41 = os_log_type_enabled(v37, type);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            v48 = "nw_endpoint_flow_copy_flow_path";
            v49 = 2082;
            v50 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_endpoint_flow_copy_flow_path";
          _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_endpoint_flow_copy_flow_path";
          _os_log_impl(&dword_182FBE000, v37, v42, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_56:
    if (v36)
      free(v36);
    goto LABEL_6;
  }
  v13 = *(id *)(v2 + 144);
  v14 = v13;
  if (v13)
  {
    v15 = v13;
    os_unfair_lock_lock((os_unfair_lock_t)v15 + 28);
    v16 = *((id *)v15 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v15 + 28);

    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v18 = *(void **)(v17 + 40);
    *(_QWORD *)(v17 + 40) = v16;

  }
  else
  {
    v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
    if (v25 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v25 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v26 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        v27 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        *(_DWORD *)buf = 136446466;
        v48 = "nw_connection_copy_current_path_block_invoke";
        v49 = 1024;
        LODWORD(v50) = v27;
        _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Connection has no endpoint handler", buf, 0x12u);
      }

    }
  }

}

void sub_183207874(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

nw_interface_t nw_data_transfer_report_copy_path_interface(nw_data_transfer_report_t report, uint32_t path_index)
{
  NSObject *v3;
  NSObject *v4;
  uint32_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  void *v15;
  int isa_high;
  os_log_type_t v17;
  int v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  uint32_t v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  int v26;
  os_log_type_t v27;
  os_log_type_t v28;
  int v29;
  int v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  _BYTE v36[10];
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = report;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_data_transfer_report_copy_path_interface";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_copy_path_interface";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_data_transfer_report_copy_path_interface";
          v35 = 2082;
          *(_QWORD *)v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_copy_path_interface";
        _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_copy_path_interface";
        _os_log_impl(&dword_182FBE000, v12, v27, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_48;
  }
  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_data_transfer_report_copy_path_interface";
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s Cannot retrieve data report values until collected", buf, 0xCu);
    }

    goto LABEL_51;
  }
  if (path_index == -1)
    v5 = 0;
  else
    v5 = path_index;
  if (v5 >= HIDWORD(v4[5].isa))
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    isa_high = HIDWORD(v4[5].isa);
    *(_DWORD *)buf = 136446722;
    v34 = "nw_data_transfer_report_copy_path_interface";
    v35 = 1024;
    *(_DWORD *)v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = isa_high;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        v18 = HIDWORD(v4[5].isa);
        *(_DWORD *)buf = 136446722;
        v34 = "nw_data_transfer_report_copy_path_interface";
        v35 = 1024;
        *(_DWORD *)v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }
    else if (v31)
    {
      v22 = v5;
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          v26 = HIDWORD(v4[5].isa);
          *(_DWORD *)buf = 136446978;
          v34 = "nw_data_transfer_report_copy_path_interface";
          v35 = 1024;
          *(_DWORD *)v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          v37 = 2082;
          v38 = v23;
          _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(v23);
        goto LABEL_49;
      }
      if (v25)
      {
        v30 = HIDWORD(v4[5].isa);
        *(_DWORD *)buf = 136446722;
        v34 = "nw_data_transfer_report_copy_path_interface";
        v35 = 1024;
        *(_DWORD *)v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s path_index (%u) >= report->path_count (%u), no backtrace", buf, 0x18u);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        v29 = HIDWORD(v4[5].isa);
        *(_DWORD *)buf = 136446722;
        v34 = "nw_data_transfer_report_copy_path_interface";
        v35 = 1024;
        *(_DWORD *)v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl(&dword_182FBE000, v12, v28, "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded", buf, 0x18u);
      }
    }
LABEL_48:

LABEL_49:
    if (v11)
      free(v11);
LABEL_51:
    v8 = 0;
    goto LABEL_13;
  }
  v6 = v4;
  if (HIDWORD(v4[5].isa) <= v5)
  {
    v7 = 0;
  }
  else if (v5)
  {
    v7 = (uint64_t)v6[52].isa + 360 * v5 - 360;
  }
  else
  {
    v7 = (uint64_t)&v6[7];
  }

  v8 = *(id *)(v7 + 352);
LABEL_13:

  return v8;
}

void sub_183207E68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_sent_application_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t isa;
  uint64_t isa_high;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  Class v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  NSObject *v21;
  void *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = report;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_data_transfer_report_get_sent_application_byte_count";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31))
      goto LABEL_57;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v31)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v29, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_application_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_44;
  }
  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_data_transfer_report_get_sent_application_byte_count";
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s Cannot retrieve data report values until collected", buf, 0xCu);
    }

    goto LABEL_59;
  }
  if (path_index == -1)
  {
    isa = (uint64_t)v4[28].isa;
    isa_high = HIDWORD(v4[5].isa);
    if (isa_high < 2)
      goto LABEL_14;
    if ((_DWORD)isa_high == 2)
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = isa_high - 1;
      v13 = v4[52].isa;
      v14 = (isa_high - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        isa += *((_QWORD *)v13 + 21);
        v11 += *((_QWORD *)v13 + 66);
        v13 = (Class)((char *)v13 + 720);
        v14 -= 2;
      }
      while (v14);
      isa += v11;
      if (v12 == ((isa_high - 1) & 0xFFFFFFFFFFFFFFFELL))
        goto LABEL_14;
      v9 = v12 | 1;
    }
    v15 = isa_high - v9;
    v16 = (_QWORD *)((char *)v4[52].isa + 360 * v9 - 192);
    do
    {
      isa += *v16;
      v16 += 45;
      --v15;
    }
    while (v15);
    goto LABEL_14;
  }
  if (HIDWORD(v4[5].isa) <= path_index)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_data_transfer_report_get_sent_application_byte_count";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31))
      goto LABEL_57;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v23, "%{public}s called with null (path_index < report->path_count)", buf, 0xCu);
      }
LABEL_56:

LABEL_57:
      if (v18)
        free(v18);
LABEL_59:
      isa = 0;
      goto LABEL_14;
    }
    if (!v31)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v30, "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_sent_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s called with null (path_index < report->path_count), no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_sent_application_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_44:

    free(backtrace_string);
    goto LABEL_57;
  }
  v5 = v4;
  if (HIDWORD(v4[5].isa) <= path_index)
  {
    v6 = 0;
  }
  else if (path_index)
  {
    v6 = (uint64_t)v5[52].isa + 360 * path_index - 360;
  }
  else
  {
    v6 = (uint64_t)&v5[7];
  }

  isa = *(_QWORD *)(v6 + 168);
LABEL_14:

  return isa;
}

void sub_183208460(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_data_transfer_report_get_received_application_byte_count(nw_data_transfer_report_t report, uint32_t path_index)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t isa;
  uint64_t isa_high;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  Class v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  NSObject *v21;
  void *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = report;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_data_transfer_report_get_received_application_byte_count";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31))
      goto LABEL_57;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null report", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v31)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v29, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_received_application_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_44;
  }
  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_data_transfer_report_get_received_application_byte_count";
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s Cannot retrieve data report values until collected", buf, 0xCu);
    }

    goto LABEL_59;
  }
  if (path_index == -1)
  {
    isa = (uint64_t)v4[27].isa;
    isa_high = HIDWORD(v4[5].isa);
    if (isa_high < 2)
      goto LABEL_14;
    if ((_DWORD)isa_high == 2)
    {
      v9 = 1;
    }
    else
    {
      v11 = 0;
      v12 = isa_high - 1;
      v13 = v4[52].isa;
      v14 = (isa_high - 1) & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        isa += *((_QWORD *)v13 + 20);
        v11 += *((_QWORD *)v13 + 65);
        v13 = (Class)((char *)v13 + 720);
        v14 -= 2;
      }
      while (v14);
      isa += v11;
      if (v12 == ((isa_high - 1) & 0xFFFFFFFFFFFFFFFELL))
        goto LABEL_14;
      v9 = v12 | 1;
    }
    v15 = isa_high - v9;
    v16 = (_QWORD *)((char *)v4[52].isa + 360 * v9 - 200);
    do
    {
      isa += *v16;
      v16 += 45;
      --v15;
    }
    while (v15);
    goto LABEL_14;
  }
  if (HIDWORD(v4[5].isa) <= path_index)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_data_transfer_report_get_received_application_byte_count";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v18, &type, &v31))
      goto LABEL_57;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v23, "%{public}s called with null (path_index < report->path_count)", buf, 0xCu);
      }
LABEL_56:

LABEL_57:
      if (v18)
        free(v18);
LABEL_59:
      isa = 0;
      goto LABEL_14;
    }
    if (!v31)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v30, "%{public}s called with null (path_index < report->path_count), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_received_application_byte_count";
        _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s called with null (path_index < report->path_count), no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_data_transfer_report_get_received_application_byte_count";
      v35 = 2082;
      v36 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s called with null (path_index < report->path_count), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_44:

    free(backtrace_string);
    goto LABEL_57;
  }
  v5 = v4;
  if (HIDWORD(v4[5].isa) <= path_index)
  {
    v6 = 0;
  }
  else if (path_index)
  {
    v6 = (uint64_t)v5[52].isa + 360 * path_index - 360;
  }
  else
  {
    v6 = (uint64_t)&v5[7];
  }

  isa = *(_QWORD *)(v6 + 160);
LABEL_14:

  return isa;
}

void sub_183208A58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_interface_radio_type_t nw_data_transfer_report_get_path_radio_type(nw_data_transfer_report_t report, uint32_t path_index)
{
  NSObject *v3;
  NSObject *v4;
  uint32_t v5;
  NSObject *v6;
  uint64_t v7;
  nw_interface_radio_type_t radio_type;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  void *v15;
  int isa_high;
  os_log_type_t v17;
  int v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  uint32_t v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  int v26;
  os_log_type_t v27;
  os_log_type_t v28;
  int v29;
  int v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  _BYTE v36[10];
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v3 = report;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_data_transfer_report_get_path_radio_type";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_path_radio_type";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_data_transfer_report_get_path_radio_type";
          v35 = 2082;
          *(_QWORD *)v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_path_radio_type";
        _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_data_transfer_report_get_path_radio_type";
        _os_log_impl(&dword_182FBE000, v12, v27, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_48;
  }
  if (nw_data_transfer_report_get_state(v3) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_data_transfer_report_get_path_radio_type";
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s Cannot retrieve data report values until collected", buf, 0xCu);
    }

    goto LABEL_51;
  }
  if (path_index == -1)
    v5 = 0;
  else
    v5 = path_index;
  if (v5 >= HIDWORD(v4[5].isa))
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    isa_high = HIDWORD(v4[5].isa);
    *(_DWORD *)buf = 136446722;
    v34 = "nw_data_transfer_report_get_path_radio_type";
    v35 = 1024;
    *(_DWORD *)v36 = v5;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&v36[6] = isa_high;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        v18 = HIDWORD(v4[5].isa);
        *(_DWORD *)buf = 136446722;
        v34 = "nw_data_transfer_report_get_path_radio_type";
        v35 = 1024;
        *(_DWORD *)v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v18;
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s path_index (%u) >= report->path_count (%u)", buf, 0x18u);
      }
    }
    else if (v31)
    {
      v22 = v5;
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          v26 = HIDWORD(v4[5].isa);
          *(_DWORD *)buf = 136446978;
          v34 = "nw_data_transfer_report_get_path_radio_type";
          v35 = 1024;
          *(_DWORD *)v36 = v22;
          *(_WORD *)&v36[4] = 1024;
          *(_DWORD *)&v36[6] = v26;
          v37 = 2082;
          v38 = v23;
          _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s path_index (%u) >= report->path_count (%u), dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(v23);
        goto LABEL_49;
      }
      if (v25)
      {
        v30 = HIDWORD(v4[5].isa);
        *(_DWORD *)buf = 136446722;
        v34 = "nw_data_transfer_report_get_path_radio_type";
        v35 = 1024;
        *(_DWORD *)v36 = v22;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v30;
        _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s path_index (%u) >= report->path_count (%u), no backtrace", buf, 0x18u);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        v29 = HIDWORD(v4[5].isa);
        *(_DWORD *)buf = 136446722;
        v34 = "nw_data_transfer_report_get_path_radio_type";
        v35 = 1024;
        *(_DWORD *)v36 = v5;
        *(_WORD *)&v36[4] = 1024;
        *(_DWORD *)&v36[6] = v29;
        _os_log_impl(&dword_182FBE000, v12, v28, "%{public}s path_index (%u) >= report->path_count (%u), backtrace limit exceeded", buf, 0x18u);
      }
    }
LABEL_48:

LABEL_49:
    if (v11)
      free(v11);
LABEL_51:
    radio_type = nw_interface_radio_type_unknown;
    goto LABEL_13;
  }
  v6 = v4;
  if (HIDWORD(v4[5].isa) <= v5)
  {
    v7 = 0;
  }
  else if (v5)
  {
    v7 = (uint64_t)v6[52].isa + 360 * v5 - 360;
  }
  else
  {
    v7 = (uint64_t)&v6[7];
  }

  radio_type = nw_interface_get_radio_type(*(void **)(v7 + 352));
LABEL_13:

  return radio_type;
}

void sub_18320903C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint32_t nw_data_transfer_report_get_path_count(nw_data_transfer_report_t report)
{
  NSObject *v1;
  NSObject *v2;
  uint32_t isa_high;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  NSObject *v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = report;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_data_transfer_report_get_path_count";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_data_transfer_report_get_path_count";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null report", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_data_transfer_report_get_path_count";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v11, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_data_transfer_report_get_path_count";
          _os_log_impl(&dword_182FBE000, v7, v11, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_data_transfer_report_get_path_count";
          _os_log_impl(&dword_182FBE000, v7, v13, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_24:
    if (v6)
      free(v6);
    goto LABEL_26;
  }
  if (nw_data_transfer_report_get_state(v1) != nw_data_transfer_report_state_collected)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_data_transfer_report_get_path_count";
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Cannot retrieve data report values until collected", buf, 0xCu);
    }

LABEL_26:
    isa_high = 0;
    goto LABEL_4;
  }
  isa_high = HIDWORD(v2[5].isa);
LABEL_4:

  return isa_high;
}

void sub_18320934C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_data_transfer_report_state_t nw_data_transfer_report_get_state(nw_data_transfer_report_t report)
{
  NSObject *v1;
  os_unfair_lock_s *v2;
  void (**v3)(_QWORD);
  nw_data_transfer_report_state_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  NSObject *v15;
  _BYTE *v16;
  char v17;
  os_log_type_t type;
  _BYTE buf[24];
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = report;
  v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v20 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_data_transfer_report_get_state_block_invoke;
    aBlock[3] = &unk_1E14ACE40;
    v16 = buf;
    v15 = v1;
    v3 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 10);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 10);

    v4 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_data_transfer_report_get_state";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_data_transfer_report_get_state";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_data_transfer_report_get_state";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_data_transfer_report_get_state";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_data_transfer_report_get_state";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
  v4 = nw_data_transfer_report_state_collecting;
LABEL_3:

  return v4;
}

void sub_18320968C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_data_transfer_report_get_state_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(result + 32) + 52);
  return result;
}

uint64_t nw_path_flow_registration_get_ctl_command(void *a1, void *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  NWConcrete_nw_path *v9;
  NWConcrete_nw_path_flow_registration *v10;
  _DWORD *v11;
  uint64_t v12;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a2;
  if (a3)
  {
    if (a4)
    {
      v11 = nw_path_copy_flow_for_registration(v9, v10);
      if (v11 && (*((_BYTE *)v11 + 186) & 2) != 0)
      {
        *a3 = v11[43];
        *a4 = v11[44];
        if (a5)
          *a5 = v11[45];
        v12 = 1;
      }
      else
      {
        v12 = 0;
      }

      goto LABEL_10;
    }
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_path_flow_registration_get_ctl_command";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v15, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null value", buf, 0xCu);
        }
LABEL_42:

        goto LABEL_43;
      }
      if (!v27)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s called with null value, no backtrace", buf, 0xCu);
        }
        goto LABEL_42;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v30 = "nw_path_flow_registration_get_ctl_command";
        v31 = 2082;
        v32 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_30;
    }
  }
  else
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_path_flow_registration_get_ctl_command";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v15, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null code", buf, 0xCu);
        }
        goto LABEL_42;
      }
      if (!v27)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s called with null code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_path_flow_registration_get_ctl_command";
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null code, no backtrace", buf, 0xCu);
        }
        goto LABEL_42;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        v30 = "nw_path_flow_registration_get_ctl_command";
        v31 = 2082;
        v32 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null code, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_30:

      free(backtrace_string);
    }
  }
LABEL_43:
  if (v15)
    free(v15);
  v12 = 0;
LABEL_10:

  return v12;
}

void __nw_connection_set_path_changed_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 256);
  *(_QWORD *)(v3 + 256) = v2;

}

void __nw_connection_set_better_path_available_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 240);
  *(_QWORD *)(v3 + 240) = v2;

}

void nw_quic_report_application_result_on_queue(void *a1, int a2)
{
  id v3;
  id v4;
  uint64_t cached_content_for_protocol;
  uint64_t v6;
  uint64_t v7;
  id v8;
  uint64_t v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  uint64_t v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  uint64_t v25;
  char *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  uint64_t v29;
  os_log_type_t v30;
  uint64_t v31;
  os_log_type_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  const char *v37;
  int v38;
  int v39;
  int64_t int64_with_default;
  time_t v41;
  void *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  void *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  char *backtrace_string;
  os_log_type_t v51;
  _BOOL4 v52;
  char *v53;
  os_log_type_t v54;
  _BOOL4 v55;
  NSObject *v56;
  void *v57;
  void *v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  char *v62;
  os_log_type_t v63;
  _BOOL4 v64;
  os_log_type_t v65;
  char v66;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  char *v71;
  __int16 v72;
  uint64_t v73;
  __int16 v74;
  _BYTE v75[10];
  char *v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!v3)
  {
    __nwlog_obj();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_quic_report_application_result_on_queue";
    v43 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (__nwlog_fault(v43, &type, &v66))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_quic_report_application_result_on_queue";
          _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v66)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v51 = type;
        v52 = os_log_type_enabled(v44, type);
        if (backtrace_string)
        {
          if (v52)
          {
            *(_DWORD *)buf = 136446466;
            v69 = "nw_quic_report_application_result_on_queue";
            v70 = 2082;
            v71 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v44, v51, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_100;
        }
        if (v52)
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_quic_report_application_result_on_queue";
          _os_log_impl(&dword_182FBE000, v44, v51, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          v69 = "nw_quic_report_application_result_on_queue";
          _os_log_impl(&dword_182FBE000, v44, v60, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_100:
    if (v43)
      free(v43);
    goto LABEL_58;
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  v4 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (!v4)
  {
    __nwlog_obj();
    v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_quic_report_application_result_on_queue";
    v47 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (!__nwlog_fault(v47, &type, &v66))
      goto LABEL_111;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v66)
    {
      v53 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v54 = type;
      v55 = os_log_type_enabled(v48, type);
      if (v53)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          v69 = "nw_quic_report_application_result_on_queue";
          v70 = 2082;
          v71 = v53;
          _os_log_impl(&dword_182FBE000, v48, v54, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v53);
LABEL_111:
        if (!v47)
        {
LABEL_57:

LABEL_58:
          return;
        }
LABEL_112:
        free(v47);
        goto LABEL_57;
      }
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v48, v54, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v48, v61, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_110:

    goto LABEL_111;
  }
  cached_content_for_protocol = nw_association_get_cached_content_for_protocol(v3, v4);
  if (cached_content_for_protocol
    || (cached_content_for_protocol = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL)) != 0)
  {
    if (a2)
    {
      v6 = *(unsigned int *)(cached_content_for_protocol + 36) + 1;
      v7 = v6 << 31 >> 31;
      *(_DWORD *)(cached_content_for_protocol + 36) = v6;
      if (v7 == v6 && (v7 & 0x8000000000000000) == 0)
        goto LABEL_52;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v9 = *(unsigned int *)(cached_content_for_protocol + 36);
      *(_DWORD *)buf = 136446978;
      v69 = "nw_quic_report_application_result_on_queue";
      v70 = 2082;
      v71 = "association_cache->application_success_count";
      v72 = 2048;
      v73 = 1;
      v74 = 2048;
      *(_QWORD *)v75 = v9;
      v10 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v66 = 0;
      if (__nwlog_fault(v10, &type, &v66))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v11 = (id)gLogObj;
          v12 = type;
          if (os_log_type_enabled(v11, type))
          {
            v13 = *(unsigned int *)(cached_content_for_protocol + 36);
            *(_DWORD *)buf = 136446978;
            v69 = "nw_quic_report_application_result_on_queue";
            v70 = 2082;
            v71 = "association_cache->application_success_count";
            v72 = 2048;
            v73 = 1;
            v74 = 2048;
            *(_QWORD *)v75 = v13;
            _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
          }
        }
        else if (v66)
        {
          v22 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v11 = (id)gLogObj;
          v23 = type;
          v24 = os_log_type_enabled(v11, type);
          if (v22)
          {
            if (v24)
            {
              v25 = *(unsigned int *)(cached_content_for_protocol + 36);
              *(_DWORD *)buf = 136447234;
              v69 = "nw_quic_report_application_result_on_queue";
              v70 = 2082;
              v71 = "association_cache->application_success_count";
              v72 = 2048;
              v73 = 1;
              v74 = 2048;
              *(_QWORD *)v75 = v25;
              *(_WORD *)&v75[8] = 2082;
              v76 = v22;
              _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }

            free(v22);
            if (!v10)
              goto LABEL_45;
            goto LABEL_44;
          }
          if (v24)
          {
            v34 = *(unsigned int *)(cached_content_for_protocol + 36);
            *(_DWORD *)buf = 136446978;
            v69 = "nw_quic_report_application_result_on_queue";
            v70 = 2082;
            v71 = "association_cache->application_success_count";
            v72 = 2048;
            v73 = 1;
            v74 = 2048;
            *(_QWORD *)v75 = v34;
            _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace", buf, 0x2Au);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v11 = (id)gLogObj;
          v30 = type;
          if (os_log_type_enabled(v11, type))
          {
            v31 = *(unsigned int *)(cached_content_for_protocol + 36);
            *(_DWORD *)buf = 136446978;
            v69 = "nw_quic_report_application_result_on_queue";
            v70 = 2082;
            v71 = "association_cache->application_success_count";
            v72 = 2048;
            v73 = 1;
            v74 = 2048;
            *(_QWORD *)v75 = v31;
            _os_log_impl(&dword_182FBE000, v11, v30, "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
          }
        }

      }
      if (!v10)
      {
LABEL_45:
        *(_DWORD *)(cached_content_for_protocol + 36) = -1;
LABEL_52:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v36 = (id)gLogObj;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          v37 = "failure";
          v38 = *(_DWORD *)(cached_content_for_protocol + 36);
          v39 = *(_DWORD *)(cached_content_for_protocol + 40);
          if (a2)
            v37 = "success";
          *(_DWORD *)buf = 136447234;
          v69 = "nw_quic_report_application_result_on_queue";
          v70 = 2112;
          v71 = (char *)v3;
          v72 = 2080;
          v73 = (uint64_t)v37;
          v74 = 1024;
          *(_DWORD *)v75 = v38;
          *(_WORD *)&v75[4] = 1024;
          *(_DWORD *)&v75[6] = v39;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %@ recording %s for QUIC application result, total success: %u, total failure: %u", buf, 0x2Cu);
        }

        int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_quic_failure_cache_seconds, 1800);
        v41 = time(0);
        nw_association_set_cached_content_for_protocol(v3, v4, cached_content_for_protocol, v41 + int64_with_default);
        goto LABEL_57;
      }
LABEL_44:
      free(v10);
      goto LABEL_45;
    }
    v14 = *(unsigned int *)(cached_content_for_protocol + 40) + 1;
    v15 = v14 << 31 >> 31;
    *(_DWORD *)(cached_content_for_protocol + 40) = v14;
    if (v15 == v14 && (v15 & 0x8000000000000000) == 0)
      goto LABEL_52;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    v17 = *(unsigned int *)(cached_content_for_protocol + 40);
    *(_DWORD *)buf = 136446978;
    v69 = "nw_quic_report_application_result_on_queue";
    v70 = 2082;
    v71 = "association_cache->application_failure_count";
    v72 = 2048;
    v73 = 1;
    v74 = 2048;
    *(_QWORD *)v75 = v17;
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (__nwlog_fault(v18, &type, &v66))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          v21 = *(unsigned int *)(cached_content_for_protocol + 40);
          *(_DWORD *)buf = 136446978;
          v69 = "nw_quic_report_application_result_on_queue";
          v70 = 2082;
          v71 = "association_cache->application_failure_count";
          v72 = 2048;
          v73 = 1;
          v74 = 2048;
          *(_QWORD *)v75 = v21;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
        }
      }
      else if (v66)
      {
        v26 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v27 = type;
        v28 = os_log_type_enabled(v19, type);
        if (v26)
        {
          if (v28)
          {
            v29 = *(unsigned int *)(cached_content_for_protocol + 40);
            *(_DWORD *)buf = 136447234;
            v69 = "nw_quic_report_application_result_on_queue";
            v70 = 2082;
            v71 = "association_cache->application_failure_count";
            v72 = 2048;
            v73 = 1;
            v74 = 2048;
            *(_QWORD *)v75 = v29;
            *(_WORD *)&v75[8] = 2082;
            v76 = v26;
            _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(v26);
          if (!v18)
            goto LABEL_51;
          goto LABEL_50;
        }
        if (v28)
        {
          v35 = *(unsigned int *)(cached_content_for_protocol + 40);
          *(_DWORD *)buf = 136446978;
          v69 = "nw_quic_report_application_result_on_queue";
          v70 = 2082;
          v71 = "association_cache->application_failure_count";
          v72 = 2048;
          v73 = 1;
          v74 = 2048;
          *(_QWORD *)v75 = v35;
          _os_log_impl(&dword_182FBE000, v19, v27, "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace", buf, 0x2Au);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v32 = type;
        if (os_log_type_enabled(v19, type))
        {
          v33 = *(unsigned int *)(cached_content_for_protocol + 40);
          *(_DWORD *)buf = 136446978;
          v69 = "nw_quic_report_application_result_on_queue";
          v70 = 2082;
          v71 = "association_cache->application_failure_count";
          v72 = 2048;
          v73 = 1;
          v74 = 2048;
          *(_QWORD *)v75 = v33;
          _os_log_impl(&dword_182FBE000, v19, v32, "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
        }
      }

    }
    if (!v18)
    {
LABEL_51:
      *(_DWORD *)(cached_content_for_protocol + 40) = -1;
      goto LABEL_52;
    }
LABEL_50:
    free(v18);
    goto LABEL_51;
  }
  __nwlog_obj();
  v56 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v69 = "strict_calloc";
  v70 = 2048;
  v71 = (char *)1;
  v72 = 2048;
  v73 = 48;
  v57 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v57))
  {
    free(v57);
    __nwlog_obj();
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_quic_report_application_result_on_queue";
    v47 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (!__nwlog_fault(v47, &type, &v66))
      goto LABEL_111;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v59 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v48, v59, "%{public}s called with null association_cache", buf, 0xCu);
      }
    }
    else if (v66)
    {
      v62 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v63 = type;
      v64 = os_log_type_enabled(v48, type);
      if (v62)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446466;
          v69 = "nw_quic_report_application_result_on_queue";
          v70 = 2082;
          v71 = v62;
          _os_log_impl(&dword_182FBE000, v48, v63, "%{public}s called with null association_cache, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v62);
        if (!v47)
          goto LABEL_57;
        goto LABEL_112;
      }
      if (v64)
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v48, v63, "%{public}s called with null association_cache, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v65 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v48, v65, "%{public}s called with null association_cache, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_110;
  }
  __break(1u);
}

void sub_18320AB98(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t NWActivity.nw.getter@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 16);
  a1[3] = swift_getObjectType();
  *a1 = v3;
  return swift_unknownObjectRetain();
}

uint64_t type metadata accessor for NWProtocolTCP.Options()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for NWListener()
{
  return objc_opt_self();
}

__CFBundle *__tcp_connection_is_first_party_block_invoke()
{
  __CFBundle *result;

  result = CFBundleGetMainBundle();
  if (!result
    || (result = (__CFBundle *)CFBundleGetValueForInfoDictionaryKey(result, (CFStringRef)*MEMORY[0x1E0C9AE78])) == 0
    || (result = (__CFBundle *)CFStringHasPrefix((CFStringRef)result, CFSTR("com.apple.")), (_DWORD)result))
  {
    tcp_connection_is_first_party_is_first_party = 1;
  }
  return result;
}

void nw_parameters_set_traffic_class(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_DWORD *)(*((_QWORD *)v3 + 13) + 72) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_set_traffic_class";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_set_traffic_class";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t in_finalize_cksum(uint64_t a1, unsigned int a2, __int16 a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t result;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  _BOOL4 v23;
  NSObject *v24;
  os_log_type_t type[4];
  char v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "__nw_frame_unclaimed_length";
    v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v12, type, &v26))
      goto LABEL_30;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (!os_log_type_enabled(v13, type[0]))
        goto LABEL_30;
      *(_DWORD *)buf = 136446210;
      v28 = "__nw_frame_unclaimed_length";
      v15 = "%{public}s called with null frame";
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type[0];
      v17 = os_log_type_enabled(v13, type[0]);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "__nw_frame_unclaimed_length";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_30:
        if (v12)
          free(v12);
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v28 = "__nw_frame_unclaimed_bytes";
        v18 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v26 = 0;
        if (!__nwlog_fault(v18, type, &v26))
          goto LABEL_46;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v19 = __nwlog_obj();
          v20 = type[0];
          if (!os_log_type_enabled(v19, type[0]))
            goto LABEL_46;
          *(_DWORD *)buf = 136446210;
          v28 = "__nw_frame_unclaimed_bytes";
          v21 = "%{public}s called with null frame";
        }
        else if (v26)
        {
          v22 = (char *)__nw_create_backtrace_string();
          v19 = __nwlog_obj();
          v20 = type[0];
          v23 = os_log_type_enabled(v19, type[0]);
          if (v22)
          {
            if (v23)
            {
              *(_DWORD *)buf = 136446466;
              v28 = "__nw_frame_unclaimed_bytes";
              v29 = 2082;
              v30 = v22;
              _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v22);
            goto LABEL_46;
          }
          if (!v23)
          {
LABEL_46:
            if (v18)
              free(v18);
            goto LABEL_48;
          }
          *(_DWORD *)buf = 136446210;
          v28 = "__nw_frame_unclaimed_bytes";
          v21 = "%{public}s called with null frame, no backtrace";
        }
        else
        {
          v19 = __nwlog_obj();
          v20 = type[0];
          if (!os_log_type_enabled(v19, type[0]))
            goto LABEL_46;
          *(_DWORD *)buf = 136446210;
          v28 = "__nw_frame_unclaimed_bytes";
          v21 = "%{public}s called with null frame, backtrace limit exceeded";
        }
        _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
        goto LABEL_46;
      }
      if (!v17)
        goto LABEL_30;
      *(_DWORD *)buf = 136446210;
      v28 = "__nw_frame_unclaimed_length";
      v15 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (!os_log_type_enabled(v13, type[0]))
        goto LABEL_30;
      *(_DWORD *)buf = 136446210;
      v28 = "__nw_frame_unclaimed_length";
      v15 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
    goto LABEL_30;
  }
  v6 = *(_DWORD *)(a1 + 52);
  if (v6)
  {
    v7 = (v6 - (*(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60)));
    v8 = *(_QWORD *)(a1 + 112);
    if (!v8)
      goto LABEL_48;
  }
  else
  {
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 112);
    if (!v8)
      goto LABEL_48;
  }
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0 && g_channel_check_validity)
  {
    if (!g_channel_check_validity(a1, *(_QWORD *)(a1 + 88)))
      goto LABEL_48;
    v8 = *(_QWORD *)(a1 + 112);
  }
  v9 = *(unsigned int *)(a1 + 56);
  *(_DWORD *)type = 0;
  if (!(_DWORD)v7 || !v8)
  {
LABEL_48:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v28 = "in_finalize_cksum";
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_INFO, "%{public}s frame is no longer valid", buf, 0xCu);
    }
    return 6;
  }
  v10 = inet_cksum(a1, 0, v7, (int *)type);
  result = *(unsigned int *)type;
  if (!*(_DWORD *)type)
  {
    if (!v10)
      LOWORD(v10) = (__int16)(a3 << 15) >> 15;
    *(_WORD *)(v8 + v9 + a2) = v10;
  }
  return result;
}

uint64_t inet_cksum(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  const char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  char *v31;
  _BOOL4 v32;
  char *v33;
  _BOOL4 v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  char *v41;
  _BOOL4 v42;
  char *v43;
  NSObject *v44;
  int v45;
  char v47;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  _BYTE v52[10];
  __int16 v53;
  _WORD v54[11];

  *(_QWORD *)&v54[7] = *MEMORY[0x1E0C80C00];
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v50 = "m_sum16";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v13, &type, &v47))
      goto LABEL_60;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v50 = "m_sum16";
      v16 = "%{public}s called with null error";
    }
    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v30 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          v50 = "m_sum16";
          v51 = 2082;
          *(_QWORD *)v52 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null error, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_60;
      }
      if (!v30)
      {
LABEL_60:
        if (v13)
          free(v13);
        return 1;
      }
      *(_DWORD *)buf = 136446210;
      v50 = "m_sum16";
      v16 = "%{public}s called with null error, no backtrace";
    }
    else
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v50 = "m_sum16";
      v16 = "%{public}s called with null error, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_60;
  }
  *a4 = 0;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v50 = "__nw_frame_unclaimed_length";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v17, &type, &v47))
      goto LABEL_65;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446210;
      v50 = "__nw_frame_unclaimed_length";
      v20 = "%{public}s called with null frame";
    }
    else if (v47)
    {
      v31 = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v32 = os_log_type_enabled(v18, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v50 = "__nw_frame_unclaimed_length";
          v51 = 2082;
          *(_QWORD *)v52 = v31;
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v31);
        goto LABEL_65;
      }
      if (!v32)
      {
LABEL_65:
        if (v17)
          free(v17);
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v50 = "__nw_frame_unclaimed_length";
      v20 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446210;
      v50 = "__nw_frame_unclaimed_length";
      v20 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
    goto LABEL_65;
  }
  v8 = *(_DWORD *)(a1 + 52);
  if (v8)
  {
    v9 = v8 - (*(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60));
    v10 = v9 - a2;
    if (v9 >= a2)
      goto LABEL_5;
LABEL_68:
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    v50 = "m_sum16";
    v51 = 1024;
    *(_DWORD *)v52 = a2;
    *(_WORD *)&v52[4] = 1024;
    *(_DWORD *)&v52[6] = v9;
    v37 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v37, &type, &v47))
      goto LABEL_98;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type))
        goto LABEL_98;
      *(_DWORD *)buf = 136446722;
      v50 = "m_sum16";
      v51 = 1024;
      *(_DWORD *)v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      v40 = "%{public}s off %u > mlen %u in m_sum16";
    }
    else if (v47)
    {
      v41 = (char *)__nw_create_backtrace_string();
      v38 = __nwlog_obj();
      v39 = type;
      v42 = os_log_type_enabled(v38, type);
      if (v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446978;
          v50 = "m_sum16";
          v51 = 1024;
          *(_DWORD *)v52 = a2;
          *(_WORD *)&v52[4] = 1024;
          *(_DWORD *)&v52[6] = v9;
          v53 = 2082;
          *(_QWORD *)v54 = v41;
          _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s off %u > mlen %u in m_sum16, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v41);
LABEL_98:
        if (v37)
        {
          v43 = (char *)v37;
          goto LABEL_100;
        }
LABEL_101:
        v45 = 22;
LABEL_92:
        *a4 = v45;
        return 1;
      }
      if (!v42)
        goto LABEL_98;
      *(_DWORD *)buf = 136446722;
      v50 = "m_sum16";
      v51 = 1024;
      *(_DWORD *)v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      v40 = "%{public}s off %u > mlen %u in m_sum16, no backtrace";
    }
    else
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type))
        goto LABEL_98;
      *(_DWORD *)buf = 136446722;
      v50 = "m_sum16";
      v51 = 1024;
      *(_DWORD *)v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      v40 = "%{public}s off %u > mlen %u in m_sum16, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v38, v39, v40, buf, 0x18u);
    goto LABEL_98;
  }
LABEL_67:
  v9 = 0;
  v10 = -a2;
  if (a2)
    goto LABEL_68;
LABEL_5:
  if (v10 < a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    v50 = "m_sum16";
    v51 = 1024;
    *(_DWORD *)v52 = v10;
    *(_WORD *)&v52[4] = 1024;
    *(_DWORD *)&v52[6] = a3;
    v53 = 1024;
    *(_DWORD *)v54 = a2;
    v21 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v21, &type, &v47))
      goto LABEL_82;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_82;
      *(_DWORD *)buf = 136446978;
      v50 = "m_sum16";
      v51 = 1024;
      *(_DWORD *)v52 = v10;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = a3;
      v53 = 1024;
      *(_DWORD *)v54 = a2;
      v24 = "%{public}s mlen %u < len %u (off %u) in m_sum16";
    }
    else if (v47)
    {
      v33 = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v34 = os_log_type_enabled(v22, type);
      if (v33)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136447234;
          v50 = "m_sum16";
          v51 = 1024;
          *(_DWORD *)v52 = v10;
          *(_WORD *)&v52[4] = 1024;
          *(_DWORD *)&v52[6] = a3;
          v53 = 1024;
          *(_DWORD *)v54 = a2;
          v54[2] = 2082;
          *(_QWORD *)&v54[3] = v33;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s mlen %u < len %u (off %u) in m_sum16, dumping backtrace:%{public}s", buf, 0x28u);
        }
        free(v33);
LABEL_82:
        if (v21)
        {
          v43 = (char *)v21;
LABEL_100:
          free(v43);
          goto LABEL_101;
        }
        goto LABEL_101;
      }
      if (!v34)
        goto LABEL_82;
      *(_DWORD *)buf = 136446978;
      v50 = "m_sum16";
      v51 = 1024;
      *(_DWORD *)v52 = v10;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = a3;
      v53 = 1024;
      *(_DWORD *)v54 = a2;
      v24 = "%{public}s mlen %u < len %u (off %u) in m_sum16, no backtrace";
    }
    else
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_82;
      *(_DWORD *)buf = 136446978;
      v50 = "m_sum16";
      v51 = 1024;
      *(_DWORD *)v52 = v10;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = a3;
      v53 = 1024;
      *(_DWORD *)v54 = a2;
      v24 = "%{public}s mlen %u < len %u (off %u) in m_sum16, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0x1Eu);
    goto LABEL_82;
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v50 = "__nw_frame_unclaimed_bytes";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v25, &type, &v47))
      goto LABEL_87;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v50 = "__nw_frame_unclaimed_bytes";
      v28 = "%{public}s called with null frame";
    }
    else if (v47)
    {
      v35 = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v36 = os_log_type_enabled(v26, type);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          v50 = "__nw_frame_unclaimed_bytes";
          v51 = 2082;
          *(_QWORD *)v52 = v35;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v35);
        goto LABEL_87;
      }
      if (!v36)
      {
LABEL_87:
        if (v25)
          free(v25);
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      v50 = "__nw_frame_unclaimed_bytes";
      v28 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v50 = "__nw_frame_unclaimed_bytes";
      v28 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
    goto LABEL_87;
  }
  v11 = *(_QWORD *)(a1 + 112);
  if (!v11
    || (*(_WORD *)(a1 + 204) & 0x100) != 0
    && g_channel_check_validity
    && (!g_channel_check_validity(a1, *(_QWORD *)(a1 + 88)) || (v11 = *(_QWORD *)(a1 + 112)) == 0))
  {
LABEL_89:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v50 = "m_sum16";
      _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_INFO, "%{public}s frame is no longer valid", buf, 0xCu);
    }
    v45 = 6;
    goto LABEL_92;
  }
  return (unsigned __int16)~(unsigned __int16)MEMORY[0x186DB4AE4](v11 + *(unsigned int *)(a1 + 56) + a2, a3, 0);
}

void ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_3(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  _WORD *v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  char *v15;
  _QWORD v16[5];

  if (*(_BYTE *)(a1 + 40) && *(_QWORD *)(*(_QWORD *)(a1 + 32) + 136))
    os_channel_sync();
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(unsigned __int16 *)(v2 + 444);
  v4 = v3 | (*(unsigned __int8 *)(v2 + 446) << 16);
  if ((v3 & 2) == 0 && *(_QWORD *)(v2 + 176))
  {
    v5 = (_WORD *)(v2 + 444);
    *(_BYTE *)(v2 + 446) = BYTE2(v4);
    *(_WORD *)(v2 + 444) = v4 | 2;
    v7 = os_channel_available_slot_count();
    if (v7 || (nw_channel_check_defunct(v2) & 1) == 0)
    {
      if (*(_DWORD *)(v2 + 420) - 1 >= v7)
        v8 = 0;
      else
        v8 = *(_DWORD *)(v2 + 420);
      v9 = *(unsigned __int16 *)(v2 + 444) | (*(unsigned __int8 *)(v2 + 446) << 16);
      if (v7 == v8)
      {
        if ((*(_WORD *)(v2 + 444) & 0x10) != 0)
        {
          v10 = *(_WORD *)(v2 + 444) & 0xFFEF | (*(unsigned __int8 *)(v2 + 446) << 16);
          *v5 = *(_WORD *)(v2 + 444) & 0xFFEF;
          *(_BYTE *)(v2 + 446) = BYTE2(v10);
          nw_queue_resume_source(*(_QWORD *)(v2 + 176), v6);
        }
      }
      else if ((*(_WORD *)(v2 + 444) & 0x10) == 0)
      {
        *(_BYTE *)(v2 + 446) = BYTE2(v9);
        *v5 = v9 | 0x10;
        nw_queue_suspend_source(*(_QWORD *)(v2 + 176));
      }
    }
    v11 = (unsigned __int16)*v5;
    v12 = v11 & 0xFFFFFFFD | (*(unsigned __int8 *)(v2 + 446) << 16);
    *v5 = v11 & 0xFFFD;
    *(_BYTE *)(v2 + 446) = BYTE2(v12);
    v2 = *(_QWORD *)(a1 + 32);
  }
  if (*(_QWORD *)(v2 + 136) && *(_QWORD *)(v2 + 216))
  {
    v13 = os_channel_available_slot_count();
    v14 = *(_DWORD *)(v2 + 420);
    if (v14 - 1 >= v13)
      v14 = 0;
    if (v13 != v14)
    {
      v15 = *(char **)(v2 + 280);
      if (v15)
      {
        v16[0] = MEMORY[0x1E0C809B0];
        v16[1] = 0x40000000;
        v16[2] = ___ZL34nw_channel_notify_output_availableP10nw_channel_block_invoke;
        v16[3] = &__block_descriptor_tmp_62_86533;
        v16[4] = v2;
        nw_hash_table_apply(v15, (uint64_t)v16);
      }
    }
  }
}

uint64_t NWProtocolTCP.Options.init()()
{
  uint64_t v0;

  *(_QWORD *)(v0 + 16) = nw_tcp_create_options();
  return v0;
}

nw_protocol_options_t nw_tcp_create_options(void)
{
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
  return (nw_protocol_options_t)nw_protocol_create_options((void *)g_tcp_definition);
}

void *nw_establishment_report_copy_dictionary(void *a1)
{
  unsigned int *v1;
  xpc_object_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  xpc_object_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  id v11;
  xpc_object_t v12;
  unsigned __int8 *v13;
  id v14;
  uint64_t v15;
  char v16;
  xpc_object_t v17;
  unsigned __int8 *v18;
  id v19;
  xpc_object_t v20;
  unsigned __int8 *v21;
  id v22;
  void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  _QWORD v32[4];
  id v33;
  _QWORD v34[4];
  id v35;
  _QWORD v36[4];
  id v37;
  _QWORD v38[4];
  id v39;
  char v40;
  os_log_type_t v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = xpc_dictionary_create(0, 0, 0);
    v3 = v2;
    v4 = *((_QWORD *)v1 + 1);
    if (v4)
      xpc_dictionary_set_uint64(v2, "attempt_started_after_milliseconds", v4);
    v5 = *((_QWORD *)v1 + 2);
    if (v5)
      xpc_dictionary_set_uint64(v3, "duration_milliseconds", v5);
    v6 = *((_QWORD *)v1 + 3);
    if (v6)
      xpc_dictionary_set_uint64(v3, "resolution_started_after_milliseconds", v6);
    v7 = *((_QWORD *)v1 + 4);
    if (v7)
      xpc_dictionary_set_uint64(v3, "flow_started_after_milliseconds", v7);
    v8 = xpc_array_create(0, 0);
    v9 = (unsigned __int8 *)*((_QWORD *)v1 + 5);
    v10 = MEMORY[0x1E0C809B0];
    v38[0] = MEMORY[0x1E0C809B0];
    v38[1] = 3221225472;
    v38[2] = __nw_establishment_report_copy_dictionary_block_invoke;
    v38[3] = &unk_1E14AC200;
    v11 = v8;
    v39 = v11;
    nw_array_apply(v9, (uint64_t)v38);
    xpc_dictionary_set_value(v3, "proxy_endpoints", v11);
    v12 = xpc_array_create(0, 0);
    v13 = (unsigned __int8 *)*((_QWORD *)v1 + 6);
    v36[0] = v10;
    v36[1] = 3221225472;
    v36[2] = __nw_establishment_report_copy_dictionary_block_invoke_2;
    v36[3] = &unk_1E14AC200;
    v14 = v12;
    v37 = v14;
    nw_array_apply(v13, (uint64_t)v36);
    xpc_dictionary_set_value(v3, "proxied_next_hop_endpoints", v14);
    v15 = v1[20];
    if ((_DWORD)v15)
      xpc_dictionary_set_uint64(v3, "previous_attempt_count", v15);
    v16 = *((_BYTE *)v1 + 84);
    if ((v16 & 1) != 0)
    {
      xpc_dictionary_set_BOOL(v3, "proxy_configured", 1);
      v16 = *((_BYTE *)v1 + 84);
    }
    if ((v16 & 2) != 0)
      xpc_dictionary_set_BOOL(v3, "used_proxy", 1);
    v17 = xpc_array_create(0, 0);
    v18 = (unsigned __int8 *)*((_QWORD *)v1 + 8);
    v34[0] = v10;
    v34[1] = 3221225472;
    v34[2] = __nw_establishment_report_copy_dictionary_block_invoke_3;
    v34[3] = &unk_1E14AC200;
    v19 = v17;
    v35 = v19;
    nw_array_apply(v18, (uint64_t)v34);
    xpc_dictionary_set_value(v3, "protocol_reports", v19);
    v20 = xpc_array_create(0, 0);
    v21 = (unsigned __int8 *)*((_QWORD *)v1 + 9);
    v32[0] = v10;
    v32[1] = 3221225472;
    v32[2] = __nw_establishment_report_copy_dictionary_block_invoke_4;
    v32[3] = &unk_1E14AC200;
    v22 = v20;
    v33 = v22;
    nw_array_apply(v21, (uint64_t)v32);
    xpc_dictionary_set_value(v3, "resolution_reports", v22);

    goto LABEL_17;
  }
  __nwlog_obj();
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v43 = "nw_establishment_report_copy_dictionary";
  v25 = (char *)_os_log_send_and_compose_impl();

  v41 = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (__nwlog_fault(v25, &v41, &v40))
  {
    if (v41 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v27 = v41;
      if (os_log_type_enabled(v26, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_establishment_report_copy_dictionary";
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v29 = v41;
      v30 = os_log_type_enabled(v26, v41);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          v43 = "nw_establishment_report_copy_dictionary";
          v44 = 2082;
          v45 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_34;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_establishment_report_copy_dictionary";
        _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v31 = v41;
      if (os_log_type_enabled(v26, v41))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_establishment_report_copy_dictionary";
        _os_log_impl(&dword_182FBE000, v26, v31, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_34:
  if (v25)
    free(v25);
  v3 = 0;
LABEL_17:

  return v3;
}

void sub_18320C5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;

  v39 = v38;

  _Unwind_Resume(a1);
}

void sub_18320C62C()
{
  JUMPOUT(0x18320C610);
}

void sub_18320C634()
{
  JUMPOUT(0x18320C610);
}

void sub_18320C63C()
{
  JUMPOUT(0x18320C61CLL);
}

void sub_18320C644()
{
  JUMPOUT(0x18320C620);
}

uint64_t nw_path_flow_is_defunct(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[186] >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_flow_is_defunct";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_is_defunct";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_flow_is_defunct";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_is_defunct";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_is_defunct";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_flow_is_assigned(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[185] >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_flow_is_assigned";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_is_assigned";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null flow", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_flow_is_assigned";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_is_assigned";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_is_assigned";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_mem_buffer_manager_initialize_block_invoke()
{
  unsigned int int64_with_default;
  int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  _BOOL8 source;
  uint64_t v7;
  dispatch_time_t v8;
  void *v9;
  uint8x8_t v10;
  void *v11;
  __int128 v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  int v16;
  malloc_zone_t *zone;
  void *v18;
  NSObject *v19;
  void *v20;
  NSObject *log;
  __int128 v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  _BYTE v26[10];
  _BYTE v27[6];
  _DWORD v28[2];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_slab_allocator_segment_size, 0x4000);
  if (int64_with_default <= 0x4000)
    v1 = 0x4000;
  else
    v1 = int64_with_default;
  v2 = -v1 & 0xFFFFC000;
  v3 = -v2;
  nw_mem_seg_size = -v2;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v24 = "nw_mem_region_init";
    v25 = 2082;
    *(_QWORD *)v26 = "VERIFY nw_mem_seg_size != 0 && (nw_mem_seg_size % NW_MEM_PAGE_SIZE) == 0 failed";
    v18 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v18))
      goto LABEL_42;
    free(v18);
    v3 = nw_mem_seg_size;
  }
  v4 = networkd_settings_get_int64_with_default((const char *)nw_setting_slab_allocator_buffer_segment_size, v3);
  v5 = nw_mem_seg_size;
  if (nw_mem_seg_size <= v4)
    v5 = v4;
  nw_mem_buf_seg_size = -(-v5 & 0xFFFFC000);
  nw_mem_seg_min_buf_cnt = networkd_settings_get_int64_with_default((const char *)nw_setting_slab_allocator_buffer_count, 8);
  nw_mem_batch_seg_count = networkd_settings_get_int64_with_default((const char *)nw_setting_slab_allocator_batch_seg_count, 8);
  if (gLogDatapath)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136447234;
      v24 = "nw_mem_region_init";
      v25 = 1024;
      *(_DWORD *)v26 = nw_mem_seg_size;
      *(_WORD *)&v26[4] = 1024;
      *(_DWORD *)&v26[6] = nw_mem_buf_seg_size;
      *(_WORD *)v27 = 1024;
      *(_DWORD *)&v27[2] = nw_mem_seg_min_buf_cnt;
      LOWORD(v28[0]) = 1024;
      *(_DWORD *)((char *)v28 + 2) = nw_mem_batch_seg_count;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s seg_size %u, buf_seg_size %u buf count %u batch seg count %u", buf, 0x24u);
    }
  }
  nw_mem_region_head = 0;
  qword_1ECD84A48 = (uint64_t)&nw_mem_region_head;
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  source = nw_queue_context_create_source((id)nw_context_copy_implicit_context::implicit_context, 2, 3, 0, &__block_literal_global_22940, 0);
  nw_mem_region_update_source = source;
  if (source)
  {
    v7 = source;
    v8 = dispatch_time(0x8000000000000000, 13000000000);
    if (*(_QWORD *)v7)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }
    else
    {
      *(_QWORD *)(v7 + 32) = v8;
      *(_QWORD *)(v7 + 40) = -1;
      if (*(_BYTE *)(v7 + 48) && *(_BYTE *)(v7 + 49))
        nw_queue_source_run_timer(v7, v8);
    }
    nw_queue_activate_source(nw_mem_region_update_source, v8);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v24 = "nw_mem_region_init";
    v9 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v9))
      goto LABEL_42;
    free(v9);
  }
  LOBYTE(nw_mem_debug) = networkd_settings_get_int64_with_default((const char *)nw_setting_slab_allocator_debug, nw_mem_debug) & 3;
  nw_mem_debug = nw_mem_debug;
  nw_mem_dump_slab_stats = networkd_settings_get_BOOL((const char *)nw_setting_slab_allocator_dump_stats_enable);
  nw_mem_cache_head = 0;
  qword_1ECD84A28 = (uint64_t)&nw_mem_cache_head;
  if (dword_1ECD84344 < 128
    || (v10 = (uint8x8_t)vcnt_s8((int8x8_t)dword_1ECD84344), v10.i16[0] = vaddlv_u8(v10), v10.i32[0] >= 2u))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v24 = "nw_mem_cache_init";
    v25 = 1024;
    *(_DWORD *)v26 = dword_1ECD84344;
    v11 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v11))
      goto LABEL_42;
    free(v11);
  }
  snprintf(byte_1ECD84358, 0x40uLL, "%s_mem_mg_%d", "NWSlab", nw_mem_magtype);
  if (nw_mem_magtype > nw_mem_cache_magsize_max)
    nw_mem_cache_magsize_max = nw_mem_magtype;
  os_unfair_lock_lock(&nw_mem_cache_lock);
  v13 = nw_mem_cache_head;
  if (nw_mem_cache_head)
  {
    *(_QWORD *)&v12 = 136446978;
    do
    {
      if ((*(_BYTE *)(v13 + 176) & 1) == 0)
      {
        *(_DWORD *)(v13 + 560) = **(_DWORD **)(v13 + 336);
        if (gLogDatapath)
        {
          v22 = v12;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          log = gLogObj;
          v14 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
          v12 = v22;
          if (v14)
          {
            v15 = *(_QWORD *)(v13 + 232);
            v16 = *(_DWORD *)(v13 + 560);
            *(_DWORD *)buf = v22;
            v24 = "nw_mem_cache_magazine_enable";
            v25 = 2048;
            *(_QWORD *)v26 = v13;
            *(_WORD *)&v26[8] = 1024;
            *(_DWORD *)v27 = v15;
            *(_WORD *)&v27[4] = 1024;
            v28[0] = v16;
            _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p chunksize %u magsize %d", buf, 0x22u);
            v12 = v22;
          }
        }
      }
      v13 = *(_QWORD *)(v13 + 80);
    }
    while (v13);
  }
  os_unfair_lock_unlock(&nw_mem_cache_lock);
  nw_mem_cache_ready = 1;
  if (nw_mem_dump_slab_stats)
    atexit(nw_mem_cache_stats_dump);
  zone = malloc_create_zone((((dword_1ECD84344 + 8 * nw_mem_magtype) << 9) + 556288), 0);
  g_slab_zone = (uint64_t)zone;
  if (zone)
    goto LABEL_32;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v24 = "nw_mem_allocate_zone";
  v20 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v20))
  {
    free(v20);
    zone = (malloc_zone_t *)g_slab_zone;
LABEL_32:
    malloc_set_zone_name(zone, "NWMallocZone");
    return;
  }
LABEL_42:
  __break(1u);
}

unsigned int *sub_18320D2A8(unsigned int *result, uint64_t a2)
{
  unint64_t v2;

  if (a2 < 2)
    v2 = (*result | ((unint64_t)*((unsigned __int8 *)result + 4) << 32)) & 0x3FFFFFFFFLL | (a2 << 38);
  else
    v2 = (a2 - 2) | 0xFFFFFF8000000000;
  *result = v2;
  *((_BYTE *)result + 4) = BYTE4(v2);
  return result;
}

void nw_parameters_set_tracker_context(void *a1, const char *a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_parameters_set_attribution_context(v3, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_set_tracker_context";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_tracker_context";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_set_tracker_context";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_tracker_context";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_tracker_context";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t _s7Network12NWParametersC13ProtocolStackCfD_0()
{
  swift_release();
  return swift_deallocClassInstance();
}

uint64_t nw_endpoint_handler_trigger_agents(void *a1, int a2)
{
  void **v3;
  id v4;
  void *v5;
  void **v6;
  char v7;
  NSObject *v8;
  char *v9;
  char *v10;
  char v11;
  const char *v12;
  nw_endpoint_t v13;
  const char *logging_description;
  char *v15;
  unsigned int *v16;
  unsigned int *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  void **v21;
  char v22;
  char *v23;
  char *v24;
  char v25;
  const char *v26;
  nw_endpoint_t v27;
  const char *v28;
  char *v29;
  unsigned int *v30;
  unsigned int *v31;
  uint64_t v32;
  const char *v33;
  void *v34;
  void *v35;
  void **v36;
  void **v37;
  const char *v38;
  void **v39;
  void **v40;
  const char *v41;
  void **v42;
  void *v43;
  void *v44;
  xpc_object_t v45;
  void *v46;
  _QWORD *v47;
  NSObject *v48;
  NSObject *v49;
  void *v50;
  NSObject *v51;
  int v52;
  _QWORD *v53;
  void *v54;
  id v55;
  id v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  os_unfair_lock_s *v60;
  id v61;
  void **v62;
  char v63;
  NSObject *v64;
  const char *id_string;
  const char *v66;
  nw_endpoint_t v67;
  const char *v68;
  const char *v69;
  const char *v70;
  id v71;
  os_unfair_lock_s *v72;
  id v73;
  char *v74;
  os_log_type_t v75;
  _BOOL4 v76;
  void *v77;
  char v78;
  NSObject *v79;
  const char *v80;
  const char *v81;
  nw_endpoint_t v82;
  const char *v83;
  const char *v84;
  const char *v85;
  id v86;
  size_t count;
  void **v88;
  _BOOL4 v89;
  NSObject *v90;
  const char *v91;
  const char *v92;
  nw_endpoint_t v93;
  const char *v94;
  const char *v95;
  const char *v96;
  id v97;
  char *v98;
  os_log_type_t v99;
  void *v101;
  NSObject *v102;
  os_log_type_t v103;
  char *backtrace_string;
  os_log_type_t v105;
  _BOOL4 v106;
  os_log_type_t v107;
  char *v108;
  NSObject *log;
  xpc_object_t xarray;
  char v111;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v114;
  __int16 v115;
  void *v116;
  __int16 v117;
  const char *v118;
  __int16 v119;
  const char *v120;
  __int16 v121;
  const char *v122;
  __int16 v123;
  const char *v124;
  __int16 v125;
  id v126;
  __int16 v127;
  _QWORD v128[4];

  *(_QWORD *)((char *)&v128[2] + 6) = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = nw_path_copy_inactive_agent_uuids(v3[8], a2);
  v5 = v4;
  if (v4 && xpc_array_get_count(v4))
  {
    *((_DWORD *)v3 + 20) = 131073;
    nw_endpoint_handler_report(v3, 0, (_WORD *)v3 + 40, 0);
    xarray = v5;
    if (v3[13])
    {
LABEL_4:
      v6 = v3;
      v7 = *((_BYTE *)v6 + 268);

      if ((v7 & 0x20) != 0)
      {
        v20 = 1;
        goto LABEL_101;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v8 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        log = v8;
        v9 = v6;

        v10 = v9;
        v11 = *((_BYTE *)v6 + 268);

        if ((v11 & 1) != 0)
          v12 = "dry-run ";
        else
          v12 = "";
        v13 = nw_endpoint_handler_copy_endpoint(v10);
        logging_description = nw_endpoint_get_logging_description(v13);
        v15 = v9 + 168;
        v16 = v10;
        v17 = v16;
        v18 = v16[30];
        if (v18 > 5)
          v19 = "unknown-state";
        else
          v19 = off_1E149FC48[v18];

        v39 = v17;
        v40 = v39;
        v41 = "path";
        switch(*((_DWORD *)v39 + 29))
        {
          case 0:
            break;
          case 1:
            v41 = "resolver";
            break;
          case 2:
            v41 = nw_endpoint_flow_mode_string(v39[31]);
            break;
          case 3:
            v41 = "proxy";
            break;
          case 4:
            v41 = "fallback";
            break;
          case 5:
            v41 = "transform";
            break;
          default:
            v41 = "unknown-mode";
            break;
        }

        v72 = v40;
        os_unfair_lock_lock(v72 + 28);
        v73 = v3[8];
        os_unfair_lock_unlock(v72 + 28);

        *(_DWORD *)buf = 136447746;
        v114 = "nw_endpoint_handler_trigger_agents";
        v115 = 2082;
        v116 = v15;
        v117 = 2082;
        v118 = v12;
        v119 = 2082;
        v120 = logging_description;
        v121 = 2082;
        v122 = v19;
        v123 = 2082;
        v124 = v41;
        v125 = 2114;
        v126 = v73;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Already triggered agents", buf, 0x48u);

LABEL_67:
        v20 = 1;
        v8 = log;
        goto LABEL_100;
      }
      v20 = 1;
LABEL_100:

      v5 = xarray;
      goto LABEL_101;
    }
    v34 = v3[11];
    if (v34)
    {
      if (xpc_equal(v34, v5))
        goto LABEL_4;
      v35 = v3[11];
    }
    else
    {
      v35 = 0;
    }
    *((_BYTE *)v3 + 268) &= ~2u;
    v3[11] = 0;
    v42 = v3;

    v43 = v42[12];
    v42[12] = 0;

    v44 = v3[13];
    v3[13] = 0;

    v45 = xpc_array_create(0, 0);
    v46 = v45;
    if (v45)
    {
      v47 = v42[7];
      v48 = v45;
      log = v48;
      if (v47)
      {
        v49 = v48;
        v50 = (void *)v47[3];
        v51 = v49;
        v52 = nw_path_evaluator_trigger_agents(v50, a2, 0, v49);

        if (v52 == 1)
        {
          v62 = v42;
          v63 = *((_BYTE *)v3 + 268);

          if ((v63 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v64 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
            {
              id_string = nw_endpoint_handler_get_id_string(v62);
              v66 = nw_endpoint_handler_dry_run_string(v62);
              v67 = nw_endpoint_handler_copy_endpoint(v62);
              v68 = nw_endpoint_get_logging_description(v67);
              v69 = nw_endpoint_handler_state_string(v62);
              v70 = nw_endpoint_handler_mode_string(v62);
              v71 = nw_endpoint_handler_copy_current_path(v62);
              *(_DWORD *)buf = 136448258;
              v114 = "nw_endpoint_handler_trigger_agents";
              v115 = 2082;
              v116 = (void *)id_string;
              v117 = 2082;
              v118 = v66;
              v119 = 2082;
              v120 = v68;
              v121 = 2082;
              v122 = v69;
              v123 = 2082;
              v124 = v70;
              v125 = 2114;
              v126 = v71;
              v127 = 1024;
              LODWORD(v128[0]) = 1;
              WORD2(v128[0]) = 2082;
              *(_QWORD *)((char *)v128 + 6) = "cannot satisfy";
              _os_log_impl(&dword_182FBE000, v64, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Trigger failed: [%d] %{public}s", buf, 0x58u);

            }
          }
          goto LABEL_54;
        }
        if (v52)
        {
LABEL_84:
          v88 = v42;
          v89 = (*((_BYTE *)v3 + 268) & 0x20) == 0;

          if (v89)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v90 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
            {
              v91 = nw_endpoint_handler_get_id_string(v88);
              v92 = nw_endpoint_handler_dry_run_string(v88);
              v93 = nw_endpoint_handler_copy_endpoint(v88);
              v94 = nw_endpoint_get_logging_description(v93);
              v95 = nw_endpoint_handler_state_string(v88);
              v96 = nw_endpoint_handler_mode_string(v88);
              v97 = nw_endpoint_handler_copy_current_path(v88);
              v98 = off_1E14A9360[v52];
              *(_DWORD *)buf = 136448258;
              v114 = "nw_endpoint_handler_trigger_agents";
              v115 = 2082;
              v116 = (void *)v91;
              v117 = 2082;
              v118 = v92;
              v119 = 2082;
              v120 = v94;
              v121 = 2082;
              v122 = v95;
              v123 = 2082;
              v124 = v96;
              v125 = 2114;
              v126 = v97;
              v127 = 1024;
              LODWORD(v128[0]) = v52;
              WORD2(v128[0]) = 2082;
              *(_QWORD *)((char *)v128 + 6) = v98;
              _os_log_impl(&dword_182FBE000, v90, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Trigger failed: [%d] %{public}s", buf, 0x58u);

            }
          }
LABEL_54:
          v20 = 0;
          v8 = log;
          goto LABEL_100;
        }
LABEL_39:
        if (xpc_array_get_count(v51))
        {
          objc_storeStrong(v3 + 11, v5);
          v53 = v3[8];
          if (v53 && (v54 = (void *)v53[28]) != 0)
            v55 = v54;
          else
            v55 = 0;
          v77 = v42[12];
          v42[12] = v55;

          objc_storeStrong(v3 + 13, v46);
          if (a2)
            v78 = 2;
          else
            v78 = 0;
          *((_BYTE *)v3 + 268) = *((_BYTE *)v3 + 268) & 0xFD | v78;
          if ((nw_endpoint_handler_get_logging_disabled(v42) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v79 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
            {
              v80 = nw_endpoint_handler_get_id_string(v42);
              v81 = nw_endpoint_handler_dry_run_string(v42);
              v82 = nw_endpoint_handler_copy_endpoint(v42);
              v83 = nw_endpoint_get_logging_description(v82);
              v84 = nw_endpoint_handler_state_string(v42);
              v85 = nw_endpoint_handler_mode_string(v42);
              v86 = nw_endpoint_handler_copy_current_path(v42);
              count = xpc_array_get_count(xarray);
              *(_DWORD *)buf = 136448002;
              v114 = "nw_endpoint_handler_trigger_agents";
              v115 = 2082;
              v116 = (void *)v80;
              v117 = 2082;
              v118 = v81;
              v119 = 2082;
              v120 = v83;
              v121 = 2082;
              v122 = v84;
              v123 = 2082;
              v124 = v85;
              v125 = 2114;
              v126 = v86;
              v127 = 2048;
              v128[0] = count;
              _os_log_impl(&dword_182FBE000, v79, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Triggered %zu agents", buf, 0x52u);

            }
          }
          goto LABEL_67;
        }
        v52 = 0;
        goto LABEL_84;
      }
      __nwlog_obj();
      v101 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v114 = "nw_association_trigger_agents";
      v108 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v111 = 0;
      if (__nwlog_fault(v108, &type, &v111))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v102 = objc_claimAutoreleasedReturnValue();
          v103 = type;
          if (os_log_type_enabled(v102, type))
          {
            *(_DWORD *)buf = 136446210;
            v114 = "nw_association_trigger_agents";
            _os_log_impl(&dword_182FBE000, v102, v103, "%{public}s called with null association", buf, 0xCu);
          }
        }
        else if (v111)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v102 = objc_claimAutoreleasedReturnValue();
          v105 = type;
          v106 = os_log_type_enabled(v102, type);
          if (backtrace_string)
          {
            if (v106)
            {
              *(_DWORD *)buf = 136446466;
              v114 = "nw_association_trigger_agents";
              v115 = 2082;
              v116 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v102, v105, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_119;
          }
          if (v106)
          {
            *(_DWORD *)buf = 136446210;
            v114 = "nw_association_trigger_agents";
            _os_log_impl(&dword_182FBE000, v102, v105, "%{public}s called with null association, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v102 = objc_claimAutoreleasedReturnValue();
          v107 = type;
          if (os_log_type_enabled(v102, type))
          {
            *(_DWORD *)buf = 136446210;
            v114 = "nw_association_trigger_agents";
            _os_log_impl(&dword_182FBE000, v102, v107, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_119:
      if (v108)
        free(v108);

      v51 = log;
      goto LABEL_39;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v56 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v114 = "nw_endpoint_handler_trigger_agents";
    v57 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v111 = 0;
    if (!__nwlog_fault(v57, &type, &v111))
      goto LABEL_96;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v58 = objc_claimAutoreleasedReturnValue();
      v59 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446210;
        v114 = "nw_endpoint_handler_trigger_agents";
        _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s xpc_array_create failed", buf, 0xCu);
      }
    }
    else if (v111)
    {
      v74 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v58 = objc_claimAutoreleasedReturnValue();
      v75 = type;
      v76 = os_log_type_enabled(v58, type);
      if (v74)
      {
        if (v76)
        {
          *(_DWORD *)buf = 136446466;
          v114 = "nw_endpoint_handler_trigger_agents";
          v115 = 2082;
          v116 = v74;
          _os_log_impl(&dword_182FBE000, v58, v75, "%{public}s xpc_array_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v74);
        goto LABEL_96;
      }
      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        v114 = "nw_endpoint_handler_trigger_agents";
        _os_log_impl(&dword_182FBE000, v58, v75, "%{public}s xpc_array_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v58 = objc_claimAutoreleasedReturnValue();
      v99 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446210;
        v114 = "nw_endpoint_handler_trigger_agents";
        _os_log_impl(&dword_182FBE000, v58, v99, "%{public}s xpc_array_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_96:
    if (v57)
      free(v57);
    v8 = 0;
    goto LABEL_99;
  }
  if ((a2 & 1) == 0)
  {
    v21 = v3;
    v22 = *((_BYTE *)v21 + 268);

    if ((v22 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      xarray = v5;
      v8 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        log = v8;
        v23 = v21;

        v24 = v23;
        v25 = *((_BYTE *)v21 + 268);

        if ((v25 & 1) != 0)
          v26 = "dry-run ";
        else
          v26 = "";
        v27 = nw_endpoint_handler_copy_endpoint(v24);
        v28 = nw_endpoint_get_logging_description(v27);
        v29 = v23 + 168;
        v30 = v24;
        v31 = v30;
        v32 = v30[30];
        if (v32 > 5)
          v33 = "unknown-state";
        else
          v33 = off_1E149FC48[v32];

        v36 = v31;
        v37 = v36;
        v38 = "path";
        switch(*((_DWORD *)v36 + 29))
        {
          case 0:
            break;
          case 1:
            v38 = "resolver";
            break;
          case 2:
            v38 = nw_endpoint_flow_mode_string(v36[31]);
            break;
          case 3:
            v38 = "proxy";
            break;
          case 4:
            v38 = "fallback";
            break;
          case 5:
            v38 = "transform";
            break;
          default:
            v38 = "unknown-mode";
            break;
        }

        v60 = v37;
        os_unfair_lock_lock(v60 + 28);
        v61 = v3[8];
        os_unfair_lock_unlock(v60 + 28);

        *(_DWORD *)buf = 136447746;
        v114 = "nw_endpoint_handler_trigger_agents";
        v115 = 2082;
        v116 = v29;
        v117 = 2082;
        v118 = v26;
        v119 = 2082;
        v120 = v28;
        v121 = 2082;
        v122 = v33;
        v123 = 2082;
        v124 = v38;
        v125 = 2114;
        v126 = v61;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No inactive agents to trigger", buf, 0x48u);

        goto LABEL_54;
      }
LABEL_99:
      v20 = 0;
      goto LABEL_100;
    }
  }
  v20 = 0;
LABEL_101:

  return v20;
}

void sub_18320E420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

uint64_t nw_path_evaluator_trigger_agents(void *a1, char a2, char a3, void *a4)
{
  _QWORD *v7;
  id v8;
  void *v9;
  id v10;
  void *v11;
  void *v12;
  uint64_t v13;
  _QWORD v15[5];
  _QWORD *v16;
  id v17;
  uint64_t *v18;
  uint64_t *v19;
  char v20;
  char v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;

  v7 = a1;
  v8 = a4;
  v26 = 0;
  v27 = &v26;
  v28 = 0x2020000000;
  v29 = 0;
  v22 = 0;
  v23 = &v22;
  v24 = 0x2020000000;
  v25 = 0;
  if (v7 && (v9 = (void *)v7[6]) != 0)
  {
    v10 = v9;
    v11 = v10;
    v12 = (void *)*((_QWORD *)v10 + 28);
    if (!v12)
      goto LABEL_14;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __nw_path_evaluator_trigger_agents_block_invoke;
    v15[3] = &unk_1E14A8E88;
    v20 = a2;
    v21 = a3;
    v15[4] = v10;
    v18 = &v26;
    v19 = &v22;
    v16 = v7;
    v17 = v8;
    xpc_dictionary_apply(v12, v15);

    if (*((_BYTE *)v23 + 24))
    {
      v13 = 0;
    }
    else
    {
LABEL_14:
      if (*((_BYTE *)v27 + 24))
        v13 = 1;
      else
        v13 = 2;
    }

  }
  else
  {
    v13 = 0;
  }
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);

  return v13;
}

void sub_18320E640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  va_list va;

  va_start(va, a11);

  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 80), 8);

  _Unwind_Resume(a1);
}

id nw_path_copy_inactive_agent_uuids(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _QWORD applier[5];
  char v18;
  char v19;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v22)(uint64_t, uint64_t);
  void (*v23)(uint64_t);
  id v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v22 = __Block_byref_object_copy__67271;
    v23 = __Block_byref_object_dispose__67272;
    v24 = 0;
    v5 = (void *)*((_QWORD *)v3 + 28);
    if (v5)
    {
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = __nw_path_copy_inactive_agent_uuids_block_invoke;
      applier[3] = &unk_1E14A8E60;
      v18 = a2;
      applier[4] = buf;
      xpc_dictionary_apply(v5, applier);
      v6 = *(void **)(*(_QWORD *)&buf[8] + 40);
    }
    else
    {
      v6 = 0;
    }
    v7 = v6;
    _Block_object_dispose(buf, 8);

    goto LABEL_6;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_path_copy_inactive_agent_uuids";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v10, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_copy_inactive_agent_uuids";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_copy_inactive_agent_uuids";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_copy_inactive_agent_uuids";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_copy_inactive_agent_uuids";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v10)
    free(v10);
  v7 = 0;
LABEL_6:

  return v7;
}

void sub_18320E9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

void ____nwlog_listener_log_block_invoke()
{
  if ((gHasForked & 1) == 0)
    glistenerLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "listener");
}

void nw_settings_parent_has_forked(void)
{
  pthread_mutex_unlock(&sSettingsMutex);
  nw_path_parent_has_forked();
}

uint64_t nw_settings_prepare_fork(void)
{
  nw_path_prepare_fork();
  return pthread_mutex_lock(&sSettingsMutex);
}

uint64_t _s7Network13NWProtocolTCPC7OptionsCfD_0()
{
  swift_unknownObjectRelease();
  return swift_deallocClassInstance();
}

uint64_t sub_18320EC10()
{
  return sub_183B92088();
}

uint64_t nw_parameters_get_resolve_ptr(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[96] >> 5) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_resolve_ptr";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_resolve_ptr";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_resolve_ptr";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_resolve_ptr";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_resolve_ptr";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void tcp_connection_set_traffic_class(void *a1, int a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  void *v5;
  id v6;
  void *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  NSObject *v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_connection_set_traffic_class";
    v7 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault((const char *)v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (!os_log_type_enabled(v8, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_set_traffic_class";
        v10 = "%{public}s called with null connection";
LABEL_21:
        v14 = v8;
        v15 = v9;
        goto LABEL_22;
      }
      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (!os_log_type_enabled(v8, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_set_traffic_class";
        v10 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_23:

          if (!v7)
            goto LABEL_25;
LABEL_24:
          free(v7);
          goto LABEL_25;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_set_traffic_class";
        v10 = "%{public}s called with null connection, no backtrace";
        v14 = v8;
        v15 = v12;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v14, v15, v10, buf, 0xCu);
        goto LABEL_23;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "tcp_connection_set_traffic_class";
        v20 = 2082;
        v21 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v7)
      goto LABEL_25;
    goto LABEL_24;
  }
  os_unfair_lock_lock(v3 + 30);
  if (nw_parameters_get_traffic_class(*(void **)&v4[12]._os_unfair_lock_opaque) != a2)
  {
    v5 = *(void **)&v4[4]._os_unfair_lock_opaque;
    if (v5)
    {
      nw_connection_reset_traffic_class(v5, a2);
    }
    else if (LOBYTE(v4[39]._os_unfair_lock_opaque) - 1 >= 2)
    {
      nw_parameters_set_traffic_class(*(void **)&v4[12]._os_unfair_lock_opaque, a2);
    }
  }
  os_unfair_lock_unlock(v4 + 30);
LABEL_25:

}

void nw_parameters_set_attribution_context(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  NSObject *v14;
  void *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_parameters_set_attribution_context";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_set_attribution_context";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_parameters_set_attribution_context";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_set_attribution_context";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_set_attribution_context";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v8)
      free(v8);
    goto LABEL_8;
  }
  v5 = *(void **)(v3[13] + 120);
  if (v5)
  {
    free(v5);
    *(_QWORD *)(v4[13] + 120) = 0;
  }
  if (!a2 || strlen(a2) - 1 > 0x3FE)
    goto LABEL_8;
  v6 = strdup(a2);
  if (v6)
  {
LABEL_7:
    *(_QWORD *)(v4[13] + 120) = v6;
LABEL_8:

    return;
  }
  __nwlog_obj();
  v14 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v15 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v15))
  {
    free(v15);
    goto LABEL_7;
  }
  __break(1u);
}

uint64_t nw_parameters_get_should_trust_invalid_certificates(void *a1)
{
  unsigned __int8 *v1;
  uint64_t v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (!v1)
  {
    __nwlog_obj();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_parameters_get_should_trust_invalid_certificates";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (__nwlog_fault(v4, &type, &v12))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v15 = "nw_parameters_get_should_trust_invalid_certificates";
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            v15 = "nw_parameters_get_should_trust_invalid_certificates";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v9)
        {
          *(_DWORD *)buf = 136446210;
          v15 = "nw_parameters_get_should_trust_invalid_certificates";
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v15 = "nw_parameters_get_should_trust_invalid_certificates";
          _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v4)
      free(v4);
    goto LABEL_22;
  }
  if (!os_variant_allows_internal_security_policies())
  {
LABEL_22:
    v2 = 0;
    goto LABEL_23;
  }
  v2 = (v1[101] >> 5) & 1;
LABEL_23:

  return v2;
}

void sub_18320F86C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_no_delay(void *a1)
{
  NWConcrete_nw_parameters *v1;
  NWConcrete_nw_parameters *v2;
  OS_nw_protocol_options *v3;
  OS_nw_protocol_options *v4;
  _BOOL8 no_delay;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_parameters_copy_tcp_options(v1, 0);
    v4 = v3;
    if (v3)
      no_delay = nw_tcp_options_get_no_delay(v3);
    else
      no_delay = 0;

    goto LABEL_6;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_parameters_get_no_delay";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_no_delay";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_parameters_get_no_delay";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_no_delay";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_no_delay";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v8)
    free(v8);
  no_delay = 0;
LABEL_6:

  return no_delay;
}

void sub_18320FB6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t tcp_connection_get_error(uint64_t a1)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(unsigned int *)(a1 + 112);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_get_error";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v3, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_connection_get_error";
      v6 = "%{public}s called with null connection";
LABEL_17:
      v10 = v4;
      v11 = v5;
      goto LABEL_18;
    }
    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_connection_get_error";
      v6 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v8 = type;
    v9 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (!v9)
      {
LABEL_19:

        if (!v3)
          return 0xFFFFFFFFLL;
        goto LABEL_13;
      }
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_connection_get_error";
      v6 = "%{public}s called with null connection, no backtrace";
      v10 = v4;
      v11 = v8;
LABEL_18:
      _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
      goto LABEL_19;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_get_error";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
  }
  if (v3)
LABEL_13:
    free(v3);
  return 0xFFFFFFFFLL;
}

void __34__nw_ip_channel_inbox_description__block_invoke(uint64_t a1)
{
  void *v2;
  id v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  CFStringRef v67;
  uint64_t v68;
  void *v69;
  NSObject *v70;
  void *v71;
  unsigned __int8 v72;
  unsigned __int8 v73;
  unsigned __int8 v74;
  unsigned __int8 v75;
  unsigned __int8 v76;
  unsigned __int8 v77;
  unsigned __int8 v78;
  unsigned __int8 v79;
  unsigned __int8 v80;
  unsigned __int8 v81;
  unsigned __int8 v82;
  unsigned __int8 v83;
  unsigned __int8 v84;
  unsigned __int8 v85;
  unsigned __int8 v86;
  unsigned __int8 v87;
  unsigned __int8 v88;
  unsigned __int8 v89;
  unsigned __int8 v90;
  unsigned __int8 v91;
  unsigned __int8 v92;
  unsigned __int8 v93;
  unsigned __int8 v94;
  unsigned __int8 v95;
  unsigned __int8 v96;
  unsigned __int8 v97;
  unsigned __int8 v98;
  unsigned __int8 v99;
  unsigned __int8 v100;
  unsigned __int8 v101;
  unsigned __int8 v102;
  unsigned __int8 v103;
  unsigned __int8 v104;
  unsigned __int8 v105;
  unsigned __int8 v106;
  unsigned __int8 v107;
  unsigned __int8 v108;
  unsigned __int8 v109;
  unsigned __int8 v110;
  unsigned __int8 v111;
  unsigned __int8 v112;
  unsigned __int8 v113;
  unsigned __int8 v114;
  unsigned __int8 v115;
  unsigned __int8 v116;
  unsigned __int8 v117;
  unsigned __int8 v118;
  unsigned __int8 v119;
  unsigned __int8 v120;
  unsigned __int8 v121;
  unsigned __int8 v122;
  unsigned __int8 v123;
  unsigned __int8 v124;
  unsigned __int8 v125;
  unsigned __int8 v126;
  unsigned __int8 v127;
  unsigned __int8 v128;
  unsigned __int8 v129;
  unsigned __int8 v130;
  unsigned __int8 v131;
  unsigned __int8 v132;
  unsigned __int8 v133;
  uint64_t v134;

  v134 = *MEMORY[0x1E0C80C00];
  v2 = *(void **)(*(_QWORD *)(a1 + 32) + 24);
  if (v2)
    goto LABEL_69;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  v4 = (unsigned __int8 *)_os_log_send_and_compose_impl();

  if (v4 == &v72)
  {
LABEL_68:
    v67 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("flow: %@, local: %s, scope: %u, protocol: %u"), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72), &v72, *(unsigned int *)(*(_QWORD *)(a1 + 32) + 160), *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 166));
    v68 = *(_QWORD *)(a1 + 32);
    v69 = *(void **)(v68 + 24);
    *(_QWORD *)(v68 + 24) = v67;

    v2 = *(void **)(*(_QWORD *)(a1 + 32) + 24);
LABEL_69:
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v2);
    return;
  }
  if (v4)
  {
LABEL_4:
    v5 = v72;
    *v4 = v72;
    if (v5)
    {
      v6 = v73;
      v4[1] = v73;
      if (v6)
      {
        v7 = v74;
        v4[2] = v74;
        if (v7)
        {
          v8 = v75;
          v4[3] = v75;
          if (v8)
          {
            v9 = v76;
            v4[4] = v76;
            if (v9)
            {
              v10 = v77;
              v4[5] = v77;
              if (v10)
              {
                v11 = v78;
                v4[6] = v78;
                if (v11)
                {
                  v12 = v79;
                  v4[7] = v79;
                  if (v12)
                  {
                    v13 = v80;
                    v4[8] = v80;
                    if (v13)
                    {
                      v14 = v81;
                      v4[9] = v81;
                      if (v14)
                      {
                        v15 = v82;
                        v4[10] = v82;
                        if (v15)
                        {
                          v16 = v83;
                          v4[11] = v83;
                          if (v16)
                          {
                            v17 = v84;
                            v4[12] = v84;
                            if (v17)
                            {
                              v18 = v85;
                              v4[13] = v85;
                              if (v18)
                              {
                                v19 = v86;
                                v4[14] = v86;
                                if (v19)
                                {
                                  v20 = v87;
                                  v4[15] = v87;
                                  if (v20)
                                  {
                                    v21 = v88;
                                    v4[16] = v88;
                                    if (v21)
                                    {
                                      v22 = v89;
                                      v4[17] = v89;
                                      if (v22)
                                      {
                                        v23 = v90;
                                        v4[18] = v90;
                                        if (v23)
                                        {
                                          v24 = v91;
                                          v4[19] = v91;
                                          if (v24)
                                          {
                                            v25 = v92;
                                            v4[20] = v92;
                                            if (v25)
                                            {
                                              v26 = v93;
                                              v4[21] = v93;
                                              if (v26)
                                              {
                                                v27 = v94;
                                                v4[22] = v94;
                                                if (v27)
                                                {
                                                  v28 = v95;
                                                  v4[23] = v95;
                                                  if (v28)
                                                  {
                                                    v29 = v96;
                                                    v4[24] = v96;
                                                    if (v29)
                                                    {
                                                      v30 = v97;
                                                      v4[25] = v97;
                                                      if (v30)
                                                      {
                                                        v31 = v98;
                                                        v4[26] = v98;
                                                        if (v31)
                                                        {
                                                          v32 = v99;
                                                          v4[27] = v99;
                                                          if (v32)
                                                          {
                                                            v33 = v100;
                                                            v4[28] = v100;
                                                            if (v33)
                                                            {
                                                              v34 = v101;
                                                              v4[29] = v101;
                                                              if (v34)
                                                              {
                                                                v35 = v102;
                                                                v4[30] = v102;
                                                                if (v35)
                                                                {
                                                                  v36 = v103;
                                                                  v4[31] = v103;
                                                                  if (v36)
                                                                  {
                                                                    v37 = v104;
                                                                    v4[32] = v104;
                                                                    if (v37)
                                                                    {
                                                                      v38 = v105;
                                                                      v4[33] = v105;
                                                                      if (v38)
                                                                      {
                                                                        v39 = v106;
                                                                        v4[34] = v106;
                                                                        if (v39)
                                                                        {
                                                                          v40 = v107;
                                                                          v4[35] = v107;
                                                                          if (v40)
                                                                          {
                                                                            v41 = v108;
                                                                            v4[36] = v108;
                                                                            if (v41)
                                                                            {
                                                                              v42 = v109;
                                                                              v4[37] = v109;
                                                                              if (v42)
                                                                              {
                                                                                v43 = v110;
                                                                                v4[38] = v110;
                                                                                if (v43)
                                                                                {
                                                                                  v44 = v111;
                                                                                  v4[39] = v111;
                                                                                  if (v44)
                                                                                  {
                                                                                    v45 = v112;
                                                                                    v4[40] = v112;
                                                                                    if (v45)
                                                                                    {
                                                                                      v46 = v113;
                                                                                      v4[41] = v113;
                                                                                      if (v46)
                                                                                      {
                                                                                        v47 = v114;
                                                                                        v4[42] = v114;
                                                                                        if (v47)
                                                                                        {
                                                                                          v48 = v115;
                                                                                          v4[43] = v115;
                                                                                          if (v48)
                                                                                          {
                                                                                            v49 = v116;
                                                                                            v4[44] = v116;
                                                                                            if (v49)
                                                                                            {
                                                                                              v50 = v117;
                                                                                              v4[45] = v117;
                                                                                              if (v50)
                                                                                              {
                                                                                                v51 = v118;
                                                                                                v4[46] = v118;
                                                                                                if (v51)
                                                                                                {
                                                                                                  v52 = v119;
                                                                                                  v4[47] = v119;
                                                                                                  if (v52)
                                                                                                  {
                                                                                                    v53 = v120;
                                                                                                    v4[48] = v120;
                                                                                                    if (v53)
                                                                                                    {
                                                                                                      v54 = v121;
                                                                                                      v4[49] = v121;
                                                                                                      if (v54)
                                                                                                      {
                                                                                                        v55 = v122;
                                                                                                        v4[50] = v122;
                                                                                                        if (v55)
                                                                                                        {
                                                                                                          v56 = v123;
                                                                                                          v4[51] = v123;
                                                                                                          if (v56)
                                                                                                          {
                                                                                                            v57 = v124;
                                                                                                            v4[52] = v124;
                                                                                                            if (v57)
                                                                                                            {
                                                                                                              v58 = v125;
                                                                                                              v4[53] = v125;
                                                                                                              if (v58)
                                                                                                              {
                                                                                                                v59 = v126;
                                                                                                                v4[54] = v126;
                                                                                                                if (v59)
                                                                                                                {
                                                                                                                  v60 = v127;
                                                                                                                  v4[55] = v127;
                                                                                                                  if (v60)
                                                                                                                  {
                                                                                                                    v61 = v128;
                                                                                                                    v4[56] = v128;
                                                                                                                    if (v61)
                                                                                                                    {
                                                                                                                      v62 = v129;
                                                                                                                      v4[57] = v129;
                                                                                                                      if (v62)
                                                                                                                      {
                                                                                                                        v63 = v130;
                                                                                                                        v4[58] = v130;
                                                                                                                        if (v63)
                                                                                                                        {
                                                                                                                          v64 = v131;
                                                                                                                          v4[59] = v131;
                                                                                                                          if (v64)
                                                                                                                          {
                                                                                                                            v65 = v132;
                                                                                                                            v4[60] = v132;
                                                                                                                            if (v65)
                                                                                                                            {
                                                                                                                              v66 = v133;
                                                                                                                              v4[61] = v133;
                                                                                                                              if (v66)
                                                                                                                                v4[62] = 0;
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    free(v4);
    goto LABEL_68;
  }
  __nwlog_obj();
  v70 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
  v71 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v71))
  {
    free(v71);
    goto LABEL_4;
  }
  __break(1u);
}

void ___ZL32nw_flow_passthrough_disconnectedP11nw_protocolS0__block_invoke(uint64_t a1)
{
  void *v1;
  unsigned int *v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  void *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = *(void **)(a1 + 32);
  if (v1)
  {
    v3 = v1;
    v4 = v3[29];

    if ((_DWORD)v4 == 2)
    {
      if (*(_QWORD *)(a1 + 56) == *(_QWORD *)(a1 + 40) + 376)
        nw_endpoint_flow_failed_with_error(*(void **)(a1 + 32), 1, *(void **)(a1 + 48));
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (v4 > 5)
          v6 = "unknown-mode";
        else
          v6 = off_1E149FC18[v4];
        *(_DWORD *)buf = 136446722;
        v18 = "nw_flow_passthrough_disconnected_block_invoke";
        v19 = 2082;
        v20 = (void *)v6;
        v21 = 2082;
        v22 = "flow";
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }

    }
    return;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_flow_passthrough_disconnected_block_invoke";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_flow_passthrough_disconnected_block_invoke";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_flow_passthrough_disconnected_block_invoke";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_flow_passthrough_disconnected_block_invoke";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_flow_passthrough_disconnected_block_invoke";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_28:
  if (v8)
    free(v8);
}

uint64_t storeEnumTagSinglePayload for NWInterface(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(_QWORD *)result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 8) = 1;
  }
  else
  {
    if (a3 >= 0x7FFFFFFF)
      *(_BYTE *)(result + 8) = 0;
    if (a2)
      *(_QWORD *)result = a2;
  }
  return result;
}

uint64_t tcp_connection_id(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  unsigned int *v4;
  uint64_t v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_connection_id";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "tcp_connection_id";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "tcp_connection_id";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v7)
            goto LABEL_11;
          goto LABEL_10;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "tcp_connection_id";
          _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "tcp_connection_id";
          _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v7)
    {
LABEL_11:
      v5 = 0;
      goto LABEL_13;
    }
LABEL_10:
    free(v7);
    goto LABEL_11;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (v3)
  {
    v4 = v3;
    v5 = v4[112];

  }
  else
  {
    v5 = *((_QWORD *)v1 + 12);
  }
LABEL_13:

  return v5;
}

uint64_t NWActivity.init(token:)(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  __int16 v4;
  char v5;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char *v11;
  char *v12;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t);
  uint64_t result;
  __int128 v16;
  uint64_t v17;

  v2 = v1;
  v17 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v16 = sub_183B91494();
  WORD4(v16) = v4;
  BYTE10(v16) = v5;
  BYTE11(v16) = v6;
  BYTE12(v16) = v7;
  BYTE13(v16) = v8;
  BYTE14(v16) = v9;
  HIBYTE(v16) = v10;
  v11 = nw_activity_create_from_token(&v16);
  if (v11)
  {
    v12 = v11;
    v13 = sub_183B914AC();
    v14 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 8);
    swift_unknownObjectRetain();
    v14(a1, v13);
    v2[3] = 0;
    v2[4] = 0;
    v2[2] = v12;
    swift_unknownObjectRelease();
    return (uint64_t)v2;
  }
  else
  {
    result = sub_183B91F5C();
    __break(1u);
  }
  return result;
}

char *nw_activity_create_from_token(_OWORD *a1)
{
  return -[NWConcrete_nw_activity initWithToken:]([NWConcrete_nw_activity alloc], a1);
}

void sub_183210FEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_parameters_prohibit_interface_type(nw_parameters_t parameters, nw_interface_type_t interface_type)
{
  nw_parameters_t v3;
  _QWORD *p_isa;
  void **v5;
  void *v6;
  void *v7;
  int v8;
  void *v9;
  xpc_object_t v10;
  void **v11;
  void *v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  void *v20;
  NSObject *v21;
  os_log_type_t v22;
  NSObject *v23;
  void *v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  os_log_type_t v29;
  _QWORD applier[5];
  nw_interface_type_t v31;
  char v32;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v3 = parameters;
  p_isa = &v3->isa;
  if (!v3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v14, &type, &v32))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_47;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
        _os_log_impl(&dword_182FBE000, v15, v28, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_47;
  }
  v5 = (void **)*((_QWORD *)v3[13].isa + 22);
  if (v5)
  {
    v6 = *v5;
    if (!*v5)
      goto LABEL_9;
    goto LABEL_7;
  }
  v7 = malloc_type_calloc(1uLL, 0x90uLL, 0xEAFB8F1AuLL);
  if (v7)
  {
LABEL_6:
    *(_QWORD *)(p_isa[13] + 176) = v7;
    v6 = **(void ***)(p_isa[13] + 176);
    if (!v6)
      goto LABEL_9;
LABEL_7:
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    LOBYTE(v35) = 0;
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = __nw_parameters_prohibit_interface_type_block_invoke;
    applier[3] = &unk_1E149CFF8;
    v31 = interface_type;
    applier[4] = buf;
    xpc_array_apply(v6, applier);
    v8 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    if (v8)
    {
LABEL_11:

      return;
    }
    v9 = **(void ***)(p_isa[13] + 176);
    if (v9)
    {
LABEL_10:
      xpc_array_set_uint64(v9, 0xFFFFFFFFFFFFFFFFLL, interface_type);
      goto LABEL_11;
    }
LABEL_9:
    v10 = xpc_array_create(0, 0);
    v11 = *(void ***)(p_isa[13] + 176);
    v12 = *v11;
    *v11 = v10;

    v9 = **(void ***)(p_isa[13] + 176);
    if (v9)
      goto LABEL_10;
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v14, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types", buf, 0xCu);
        }
      }
      else if (v32)
      {
        v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        v27 = os_log_type_enabled(v21, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v25;
            _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v25);
          if (!v14)
            goto LABEL_11;
          goto LABEL_48;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
          _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_prohibit_interface_type";
          _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s called with null parameters->path_parameters->extended_objects->prohibited_interface_types, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_47:
    if (!v14)
      goto LABEL_11;
LABEL_48:
    free(v14);
    goto LABEL_11;
  }
  __nwlog_obj();
  v23 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "strict_calloc";
  *(_WORD *)&buf[12] = 2048;
  *(_QWORD *)&buf[14] = 1;
  *(_WORD *)&buf[22] = 2048;
  v35 = 144;
  v24 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v24))
  {
    free(v24);
    goto LABEL_6;
  }
  __break(1u);
}

void sub_18321165C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

id nw_parameters_copy_tls_session_id(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[16];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_copy_tls_session_id";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_tls_session_id";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_copy_tls_session_id";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_tls_session_id";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_tls_session_id";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_endpoint_set_alternate_port(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_WORD *)v3 + 114) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_set_alternate_port";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_set_alternate_port";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_set_alternate_port";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_set_alternate_port";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_set_alternate_port";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_path_flow_registration_access_interface_stats(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void (**v5)(_QWORD, _QWORD);
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  NSObject *v19;
  void *v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = (void (**)(_QWORD, _QWORD))v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_path_flow_registration_access_interface_stats";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null registration", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_path_flow_registration_access_interface_stats";
          v27 = 2082;
          v28 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v8)
          goto LABEL_7;
LABEL_44:
        free(v8);
        goto LABEL_7;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_42:

    goto LABEL_43;
  }
  if (!v4)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_path_flow_registration_access_interface_stats";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null access_block", buf, 0xCu);
      }
    }
    else if (v23)
    {
      v16 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v9, type);
      if (v16)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_path_flow_registration_access_interface_stats";
          v27 = 2082;
          v28 = (uint64_t)v16;
          _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v16);
        if (!v8)
          goto LABEL_7;
        goto LABEL_44;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_path_flow_registration_access_interface_stats";
        _os_log_impl(&dword_182FBE000, v9, v22, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_42;
  }
  v6 = (void *)v3[9];
  if (v6)
  {
LABEL_6:
    ((void (**)(_QWORD, void *))v5)[2](v5, v6);
LABEL_7:

    return;
  }
  v6 = malloc_type_calloc(1uLL, 0x68uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_5:
    v3[9] = v6;
    goto LABEL_6;
  }
  __nwlog_obj();
  v19 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v26 = "strict_calloc";
  v27 = 2048;
  v28 = 1;
  v29 = 2048;
  v30 = 104;
  v20 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v20))
  {
    free(v20);
    goto LABEL_5;
  }
  __break(1u);
}

void sub_1832121AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t getEnumTagSinglePayload for NWInterface(uint64_t *a1, unsigned int a2)
{
  uint64_t v3;
  int v4;

  if (!a2)
    return 0;
  if (a2 >= 0x7FFFFFFF && *((_BYTE *)a1 + 8))
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  v3 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF)
    LODWORD(v3) = -1;
  v4 = v3 - 1;
  if (v4 < 0)
    v4 = -1;
  return (v4 + 1);
}

void sub_1832122EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_establishment_report *nw_establishment_report_create_from_dictionary(void *a1)
{
  id v1;
  void *v2;
  Class Class;
  objc_class *v4;
  NWConcrete_nw_establishment_report *v5;
  xpc_object_t v6;
  xpc_object_t v7;
  char v8;
  xpc_object_t v9;
  xpc_object_t v10;
  NWConcrete_nw_establishment_report *v11;
  xpc_object_t value;
  _BOOL8 v14;
  OS_nw_array *proxy_endpoints;
  xpc_object_t v16;
  _BOOL8 v17;
  OS_nw_array *proxied_next_hop_endpoints;
  xpc_object_t v19;
  _BOOL8 v20;
  OS_nw_array *protocol_reports;
  xpc_object_t v22;
  void *v23;
  _BOOL8 v24;
  OS_nw_array *resolution_reports;
  void *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  void *v30;
  os_log_type_t v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  char *backtrace_string;
  os_log_type_t v37;
  _BOOL4 v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  char *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  os_log_type_t v46;
  os_log_type_t v47;
  _QWORD v48[4];
  NWConcrete_nw_establishment_report *v49;
  _QWORD v50[4];
  NWConcrete_nw_establishment_report *v51;
  _QWORD v52[4];
  NWConcrete_nw_establishment_report *v53;
  _QWORD applier[4];
  NWConcrete_nw_establishment_report *v55;
  char v56;
  os_log_type_t v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  char *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_establishment_report_create_from_dictionary";
    v27 = (char *)_os_log_send_and_compose_impl();

    v57 = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (!__nwlog_fault(v27, &v57, &v56))
      goto LABEL_80;
    if (v57 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v29 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null dictionary", buf, 0xCu);
      }
    }
    else if (v56)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v37 = v57;
      v38 = os_log_type_enabled(v28, v57);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_establishment_report_create_from_dictionary";
          v60 = 2082;
          v61 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v28, v37, "%{public}s called with null dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v27)
          goto LABEL_82;
        goto LABEL_81;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_182FBE000, v28, v37, "%{public}s called with null dictionary, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v45 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_182FBE000, v28, v45, "%{public}s called with null dictionary, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_79;
  }
  Class = object_getClass(v1);
  v4 = (objc_class *)MEMORY[0x1E0C812F8];
  if (Class != (Class)MEMORY[0x1E0C812F8])
  {
    __nwlog_obj();
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_establishment_report_create_from_dictionary";
    v27 = (char *)_os_log_send_and_compose_impl();

    v57 = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (!__nwlog_fault(v27, &v57, &v56))
      goto LABEL_80;
    if (v57 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v31 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary))", buf, 0xCu);
      }
    }
    else if (v56)
    {
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v40 = v57;
      v41 = os_log_type_enabled(v28, v57);
      if (v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_establishment_report_create_from_dictionary";
          v60 = 2082;
          v61 = v39;
          _os_log_impl(&dword_182FBE000, v28, v40, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v39);
LABEL_80:
        if (!v27)
        {
LABEL_82:
          v5 = 0;
          goto LABEL_17;
        }
LABEL_81:
        free(v27);
        goto LABEL_82;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_182FBE000, v28, v40, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v46 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl(&dword_182FBE000, v28, v46, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_79:

    goto LABEL_80;
  }
  v5 = objc_alloc_init(NWConcrete_nw_establishment_report);
  if (!v5)
  {
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_establishment_report_create_from_dictionary";
    v33 = (char *)_os_log_send_and_compose_impl();

    v57 = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (__nwlog_fault(v33, &v57, &v56))
    {
      if (v57 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v35 = v57;
        if (os_log_type_enabled(v34, v57))
        {
          *(_DWORD *)buf = 136446210;
          v59 = "nw_establishment_report_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null report", buf, 0xCu);
        }
      }
      else if (v56)
      {
        v42 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v43 = v57;
        v44 = os_log_type_enabled(v34, v57);
        if (v42)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            v59 = "nw_establishment_report_create_from_dictionary";
            v60 = 2082;
            v61 = v42;
            _os_log_impl(&dword_182FBE000, v34, v43, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v42);
          goto LABEL_86;
        }
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v59 = "nw_establishment_report_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v34, v43, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v47 = v57;
        if (os_log_type_enabled(v34, v57))
        {
          *(_DWORD *)buf = 136446210;
          v59 = "nw_establishment_report_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v34, v47, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_86:
    if (v33)
      free(v33);
    goto LABEL_16;
  }
  v5->attempt_started_after_milliseconds = xpc_dictionary_get_uint64(v2, "attempt_started_after_milliseconds");
  v5->duration_milliseconds = xpc_dictionary_get_uint64(v2, "duration_milliseconds");
  v5->resolution_started_after_milliseconds = xpc_dictionary_get_uint64(v2, "resolution_started_after_milliseconds");
  v5->flow_started_after_milliseconds = xpc_dictionary_get_uint64(v2, "flow_started_after_milliseconds");
  if (object_getClass(v2) != v4)
  {
LABEL_5:
    v6 = 0;
    goto LABEL_6;
  }
  value = xpc_dictionary_get_value(v2, "proxy_endpoints");
  v6 = value;
  if (value)
  {
    if (object_getClass(value) != (Class)MEMORY[0x1E0C812C8])
      goto LABEL_5;
    v6 = xpc_retain(v6);
    if (v6)
    {
      v14 = nw_array_create();
      proxy_endpoints = v5->proxy_endpoints;
      v5->proxy_endpoints = (OS_nw_array *)v14;

      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = __nw_establishment_report_create_from_dictionary_block_invoke;
      applier[3] = &unk_1E14AC908;
      v55 = v5;
      xpc_array_apply(v6, applier);

    }
  }
LABEL_6:
  if (object_getClass(v2) != v4)
  {
LABEL_7:
    v7 = 0;
    goto LABEL_8;
  }
  v16 = xpc_dictionary_get_value(v2, "proxied_next_hop_endpoints");
  v7 = v16;
  if (v16)
  {
    if (object_getClass(v16) != (Class)MEMORY[0x1E0C812C8])
      goto LABEL_7;
    v7 = xpc_retain(v7);
    if (v7)
    {
      v17 = nw_array_create();
      proxied_next_hop_endpoints = v5->proxied_next_hop_endpoints;
      v5->proxied_next_hop_endpoints = (OS_nw_array *)v17;

      v52[0] = MEMORY[0x1E0C809B0];
      v52[1] = 3221225472;
      v52[2] = __nw_establishment_report_create_from_dictionary_block_invoke_2;
      v52[3] = &unk_1E14AC908;
      v53 = v5;
      xpc_array_apply(v7, v52);

    }
  }
LABEL_8:
  v5->previous_attempt_count = xpc_dictionary_get_uint64(v2, "previous_attempt_count");
  *((_BYTE *)v5 + 84) = *((_BYTE *)v5 + 84) & 0xFE | xpc_dictionary_get_BOOL(v2, "proxy_configured");
  if (xpc_dictionary_get_BOOL(v2, "used_proxy"))
    v8 = 2;
  else
    v8 = 0;
  *((_BYTE *)v5 + 84) = *((_BYTE *)v5 + 84) & 0xFD | v8;
  if (object_getClass(v2) != v4)
  {
LABEL_12:
    v9 = 0;
    goto LABEL_13;
  }
  v19 = xpc_dictionary_get_value(v2, "protocol_reports");
  v9 = v19;
  if (v19)
  {
    if (object_getClass(v19) == (Class)MEMORY[0x1E0C812C8])
    {
      v9 = xpc_retain(v9);
      if (v9)
      {
        v20 = nw_array_create();
        protocol_reports = v5->protocol_reports;
        v5->protocol_reports = (OS_nw_array *)v20;

        v50[0] = MEMORY[0x1E0C809B0];
        v50[1] = 3221225472;
        v50[2] = __nw_establishment_report_create_from_dictionary_block_invoke_3;
        v50[3] = &unk_1E14AC908;
        v51 = v5;
        xpc_array_apply(v9, v50);

      }
      goto LABEL_13;
    }
    goto LABEL_12;
  }
LABEL_13:
  if (object_getClass(v2) == v4
    && (v22 = xpc_dictionary_get_value(v2, "resolution_reports")) != 0
    && (v23 = v22, object_getClass(v22) == (Class)MEMORY[0x1E0C812C8]))
  {
    v10 = xpc_retain(v23);
    if (v10)
    {
      v24 = nw_array_create();
      resolution_reports = v5->resolution_reports;
      v5->resolution_reports = (OS_nw_array *)v24;

      v48[0] = MEMORY[0x1E0C809B0];
      v48[1] = 3221225472;
      v48[2] = __nw_establishment_report_create_from_dictionary_block_invoke_4;
      v48[3] = &unk_1E14AC908;
      v49 = v5;
      xpc_array_apply(v10, v48);

    }
  }
  else
  {
    v10 = 0;
  }
  v11 = v5;

LABEL_16:
LABEL_17:

  return v5;
}

void sub_1832131BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_183213230(uint64_t a1, NSObject *a2)
{
  uint64_t v2;

  sub_18321323C(a1, a2, *(_QWORD *)(v2 + 16), *(void (**)(int *))(v2 + 24));
}

void sub_18321323C(uint64_t a1, NSObject *a2, uint64_t a3, void (*a4)(int *))
{
  os_unfair_lock_s *v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  int v10;

  v7 = *(os_unfair_lock_s **)(a3 + 16);
  v8 = (uint64_t)&v7[4];
  v9 = v7 + 48;
  os_unfair_lock_lock(v7 + 48);
  sub_1832132D4(v8, a1, a2, (uint64_t)&v10);
  os_unfair_lock_unlock(v9);
  if (a4)
    a4(&v10);
}

uint64_t sub_1832132D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, NSObject *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;
  unsigned int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned __int8 v12;

  swift_unknownObjectRetain();
  result = sub_183213398(a3, a2, (uint64_t)&v11);
  v9 = v11;
  v10 = v11 | ((unint64_t)v12 << 32);
  *(_BYTE *)(a1 + 172) = v12;
  *(_DWORD *)(a1 + 168) = v9;
  if (v10 >= 0x8000000002)
  {
    result = nw_utilities_minos_atleast();
    if ((_DWORD)result)
    {
      sub_1830630AC(*(_QWORD *)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      sub_1830630AC(*(_QWORD *)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      sub_1830630AC(*(_QWORD *)a1);
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      result = sub_1830630AC(*(_QWORD *)(a1 + 48));
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 0;
    }
  }
  *(_DWORD *)a4 = v10;
  *(_BYTE *)(a4 + 4) = BYTE4(v10);
  return result;
}

uint64_t sub_183213398@<X0>(nw_error_t error@<X1>, uint64_t result@<X0>, uint64_t a3@<X8>)
{
  unint64_t v5;
  nw_error_domain_t error_domain;
  uint64_t v7;
  unsigned int error_code;
  unsigned int v9;
  unsigned int v10;
  unsigned __int8 v11;

  switch((int)result)
  {
    case 0:
      result = swift_unknownObjectRelease();
      v5 = 0x8000000000;
      break;
    case 1:
      if (error)
      {
        error_domain = nw_error_get_error_domain(error);
        switch(error_domain)
        {
          case nw_error_domain_tls:
            error_code = nw_error_get_error_code(error);
            result = swift_unknownObjectRelease();
            v5 = error_code | 0x200000000;
            break;
          case nw_error_domain_dns:
            v9 = nw_error_get_error_code(error);
            result = swift_unknownObjectRelease();
            v5 = v9 | 0x100000000;
            break;
          case nw_error_domain_posix:
            nw_error_get_error_code(error);
            v7 = sub_183B915E4();
            result = swift_unknownObjectRelease();
            v5 = 22;
            if ((v7 & 0x100000000) == 0)
              v5 = v7;
            break;
          default:
            result = swift_unknownObjectRelease();
            v5 = 22;
            break;
        }
      }
      else
      {
        v5 = 50;
      }
      break;
    case 2:
      result = swift_unknownObjectRelease();
      v5 = 0x8000000001;
      break;
    case 3:
      result = (uint64_t)sub_1830840B4(error, (uint64_t)&v10);
      v5 = 0x4000000016;
      if (v11 != 255)
        v5 = v10 | ((unint64_t)v11 << 32) | 0x4000000000;
      break;
    default:
      result = swift_unknownObjectRelease();
      v5 = 0x8000000002;
      break;
  }
  *(_DWORD *)a3 = v5;
  *(_BYTE *)(a3 + 4) = BYTE4(v5);
  return result;
}

BOOL nw_txt_record_access_bytes(nw_txt_record_t txt_record, nw_txt_record_access_bytes_t access_bytes)
{
  nw_txt_record_t v3;
  nw_txt_record_access_bytes_t v4;
  uint64_t (**v5)(_QWORD, _QWORD, _QWORD);
  char v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = txt_record;
  v4 = access_bytes;
  v5 = (uint64_t (**)(_QWORD, _QWORD, _QWORD))v4;
  if (v3)
  {
    if (v4)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&v3[4]);
      v6 = ((uint64_t (**)(_QWORD, Class, Class))v5)[2](v5, v3[1].isa, v3[2].isa);
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
      goto LABEL_4;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_txt_record_access_bytes";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null access_bytes", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null access_bytes, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null access_bytes, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_txt_record_access_bytes";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null access_bytes, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_txt_record_access_bytes";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null txt_record", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_txt_record_access_bytes";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_txt_record_access_bytes";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_4:

  return v6;
}

void sub_1832139D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t on_frame_recv_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t protocol_from_stream_id;
  uint64_t v7;
  void (*v8)(void);
  NSObject *v9;
  int v10;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint32_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  int v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  int v25;
  int v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  NSObject *v31;
  char *backtrace_string;
  _BOOL4 v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  int v40;
  const char *v41;
  NSObject *v42;
  int v43;
  NSObject *v44;
  int v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  char *v51;
  _BOOL4 v52;
  int v53;
  const char *v54;
  NSObject *v55;
  int v56;
  _BOOL4 v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  char *v70;
  __int16 v71;
  _BYTE v72[10];
  int v73;
  __int16 v74;
  char *v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v68 = "on_frame_recv_callback";
    v27 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v65 = 0;
    if (__nwlog_fault(v27, &type, &v65))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v28 = __nwlog_obj();
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v68 = "on_frame_recv_callback";
          v30 = "%{public}s nghttp2 user data is NULL, not http2_transport";
LABEL_65:
          _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0xCu);
        }
      }
      else if (v65)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v28 = __nwlog_obj();
        v29 = type;
        v33 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v68 = "on_frame_recv_callback";
            v69 = 2082;
            v70 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_66;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v68 = "on_frame_recv_callback";
          v30 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
          goto LABEL_65;
        }
      }
      else
      {
        v28 = __nwlog_obj();
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v68 = "on_frame_recv_callback";
          v30 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
          goto LABEL_65;
        }
      }
    }
LABEL_66:
    if (v27)
      free(v27);
    return 4294966394;
  }
  if (gLogDatapath)
  {
    v31 = __nwlog_obj();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v68 = "on_frame_recv_callback";
      v69 = 2082;
      v70 = (char *)(a3 + 205);
      _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  result = 0;
  switch(*(_BYTE *)(a2 + 12))
  {
    case 0:
      if (gLogDatapath)
      {
        v42 = __nwlog_obj();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        {
          v43 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136446722;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)(a3 + 205);
          v71 = 1024;
          *(_DWORD *)v72 = v43;
          _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s received a complete DATA frame on stream %d", buf, 0x1Cu);
        }
      }
      if ((*(_BYTE *)(a2 + 13) & 1) == 0)
        return 0;
      if (gLogDatapath)
      {
        v55 = __nwlog_obj();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
        {
          v56 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136446722;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)(a3 + 205);
          v71 = 1024;
          *(_DWORD *)v72 = v56;
          _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s end stream flag detected, delivering input_finished for stream %d", buf, 0x1Cu);
        }
      }
      protocol_from_stream_id = nw_http2_transport_get_protocol_from_stream_id(a3, *(_DWORD *)(a2 + 8));
      if (protocol_from_stream_id)
      {
        v7 = *(_QWORD *)(protocol_from_stream_id + 24);
        if (v7)
        {
          v8 = *(void (**)(void))(v7 + 184);
          if (v8)
            goto LABEL_10;
        }
        v47 = protocol_from_stream_id;
        __nwlog_obj();
        v48 = a3 + 205;
        v49 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446978;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v71 = 2048;
        v64 = v47;
        *(_QWORD *)v72 = v47;
        *(_WORD *)&v72[8] = 1024;
        v73 = v49;
        v37 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v65 = 0;
        if (!__nwlog_fault(v37, &type, &v65))
          goto LABEL_100;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v38 = __nwlog_obj();
          v39 = type;
          if (!os_log_type_enabled(v38, type))
            goto LABEL_100;
          v50 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136446978;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)v48;
          v71 = 2048;
          *(_QWORD *)v72 = v64;
          *(_WORD *)&v72[8] = 1024;
          v73 = v50;
          v41 = "%{public}s %{public}s no input finished callback for protocol %p attached to stream %d";
          goto LABEL_99;
        }
        if (v65)
        {
          v51 = (char *)__nw_create_backtrace_string();
          v38 = __nwlog_obj();
          v39 = type;
          v57 = os_log_type_enabled(v38, type);
          if (v51)
          {
            if (!v57)
              goto LABEL_90;
            v58 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)buf = 136447234;
            v68 = "on_frame_recv_callback";
            v69 = 2082;
            v70 = (char *)v48;
            v71 = 2048;
            *(_QWORD *)v72 = v64;
            *(_WORD *)&v72[8] = 1024;
            v73 = v58;
            v74 = 2082;
            v75 = v51;
            v54 = "%{public}s %{public}s no input finished callback for protocol %p attached to stream %d, dumping backtrace:%{public}s";
            goto LABEL_89;
          }
          if (!v57)
            goto LABEL_100;
          v62 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136446978;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)v48;
          v71 = 2048;
          *(_QWORD *)v72 = v64;
          *(_WORD *)&v72[8] = 1024;
          v73 = v62;
          v41 = "%{public}s %{public}s no input finished callback for protocol %p attached to stream %d, no backtrace";
        }
        else
        {
          v38 = __nwlog_obj();
          v39 = type;
          if (!os_log_type_enabled(v38, type))
            goto LABEL_100;
          v61 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136446978;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)v48;
          v71 = 2048;
          *(_QWORD *)v72 = v64;
          *(_WORD *)&v72[8] = 1024;
          v73 = v61;
          v41 = "%{public}s %{public}s no input finished callback for protocol %p attached to stream %d, backtrace limit exceeded";
        }
        goto LABEL_99;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        v26 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446722;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v71 = 1024;
        *(_DWORD *)v72 = v26;
        v11 = "%{public}s %{public}s no input handler found for stream %d, dropping DATA";
        goto LABEL_29;
      }
      return result;
    case 1:
      if ((*(_BYTE *)(a2 + 13) & 1) != 0)
      {
        if (!gLogDatapath)
          return 0;
        v23 = __nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)(a3 + 205);
          _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s detected end stream on header frame", buf, 0x16u);
        }
      }
      if (!gLogDatapath)
        return 0;
      v9 = __nwlog_obj();
      result = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        v10 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446722;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v71 = 1024;
        *(_DWORD *)v72 = v10;
        v11 = "%{public}s %{public}s received incoming HEADERS frame for stream %d";
        v12 = v9;
        v13 = OS_LOG_TYPE_DEBUG;
        goto LABEL_40;
      }
      return result;
    case 2:
      if (!gLogDatapath)
        return 0;
      v14 = __nwlog_obj();
      result = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        *(_DWORD *)buf = 136446466;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v11 = "%{public}s %{public}s received complete PRIORITY frame, ignoring";
        goto LABEL_26;
      }
      return result;
    case 3:
      if (gLogDatapath)
      {
        v44 = __nwlog_obj();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          v45 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)buf = 136446722;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)(a3 + 205);
          v71 = 1024;
          *(_DWORD *)v72 = v45;
          _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s stream %d received RST_STREAM frame, setting error to ECONNRESET", buf, 0x1Cu);
        }
      }
      v15 = nw_http2_transport_get_protocol_from_stream_id(a3, *(_DWORD *)(a2 + 8));
      if (v15)
      {
        v16 = *(_QWORD *)(v15 + 24);
        if (v16)
        {
          v8 = *(void (**)(void))(v16 + 56);
          if (v8)
          {
LABEL_10:
            v8();
            return 0;
          }
        }
        v34 = v15;
        __nwlog_obj();
        v35 = a3 + 205;
        v36 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446978;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v71 = 2048;
        v63 = v34;
        *(_QWORD *)v72 = v34;
        *(_WORD *)&v72[8] = 1024;
        v73 = v36;
        v37 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v65 = 0;
        if (!__nwlog_fault(v37, &type, &v65))
          goto LABEL_100;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v38 = __nwlog_obj();
          v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            v40 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)buf = 136446978;
            v68 = "on_frame_recv_callback";
            v69 = 2082;
            v70 = (char *)v35;
            v71 = 2048;
            *(_QWORD *)v72 = v63;
            *(_WORD *)&v72[8] = 1024;
            v73 = v40;
            v41 = "%{public}s %{public}s no error callback for protocol %p attached to stream %d";
LABEL_99:
            _os_log_impl(&dword_182FBE000, v38, v39, v41, buf, 0x26u);
          }
        }
        else if (v65)
        {
          v51 = (char *)__nw_create_backtrace_string();
          v38 = __nwlog_obj();
          v39 = type;
          v52 = os_log_type_enabled(v38, type);
          if (v51)
          {
            if (v52)
            {
              v53 = *(_DWORD *)(a2 + 8);
              *(_DWORD *)buf = 136447234;
              v68 = "on_frame_recv_callback";
              v69 = 2082;
              v70 = (char *)v35;
              v71 = 2048;
              *(_QWORD *)v72 = v63;
              *(_WORD *)&v72[8] = 1024;
              v73 = v53;
              v74 = 2082;
              v75 = v51;
              v54 = "%{public}s %{public}s no error callback for protocol %p attached to stream %d, dumping backtrace:%{public}s";
LABEL_89:
              _os_log_impl(&dword_182FBE000, v38, v39, v54, buf, 0x30u);
            }
LABEL_90:
            free(v51);
            goto LABEL_100;
          }
          if (v52)
          {
            v60 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)buf = 136446978;
            v68 = "on_frame_recv_callback";
            v69 = 2082;
            v70 = (char *)v35;
            v71 = 2048;
            *(_QWORD *)v72 = v63;
            *(_WORD *)&v72[8] = 1024;
            v73 = v60;
            v41 = "%{public}s %{public}s no error callback for protocol %p attached to stream %d, no backtrace";
            goto LABEL_99;
          }
        }
        else
        {
          v38 = __nwlog_obj();
          v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            v59 = *(_DWORD *)(a2 + 8);
            *(_DWORD *)buf = 136446978;
            v68 = "on_frame_recv_callback";
            v69 = 2082;
            v70 = (char *)v35;
            v71 = 2048;
            *(_QWORD *)v72 = v63;
            *(_WORD *)&v72[8] = 1024;
            v73 = v59;
            v41 = "%{public}s %{public}s no error callback for protocol %p attached to stream %d, backtrace limit exceeded";
            goto LABEL_99;
          }
        }
LABEL_100:
        if (v37)
          free(v37);
        return 4294966775;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      if ((_DWORD)result)
      {
        v25 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446722;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v71 = 1024;
        *(_DWORD *)v72 = v25;
        v11 = "%{public}s %{public}s no input handler found for stream %d, ignoring RST_STREAM";
        v12 = v24;
        v13 = OS_LOG_TYPE_INFO;
        goto LABEL_40;
      }
      break;
    case 4:
      if (!gLogDatapath)
        return 0;
      v14 = __nwlog_obj();
      result = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        *(_DWORD *)buf = 136446466;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v11 = "%{public}s %{public}s received complete SETTINGS frame";
LABEL_26:
        v12 = v14;
        v13 = OS_LOG_TYPE_DEBUG;
        v17 = 22;
        goto LABEL_41;
      }
      return result;
    case 5:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        v19 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)buf = 136446722;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v71 = 1024;
        *(_DWORD *)v72 = v19;
        v11 = "%{public}s %{public}s received a complete PUSH_PROMISE frame on stream %d -- currently not supported";
LABEL_29:
        v12 = v18;
        v13 = OS_LOG_TYPE_ERROR;
LABEL_40:
        v17 = 28;
        goto LABEL_41;
      }
      return result;
    case 7:
      if (gLogDatapath)
      {
        v46 = __nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v68 = "on_frame_recv_callback";
          v69 = 2082;
          v70 = (char *)(a3 + 205);
          _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s received complete GOAWAY frame, tearing down tunnel connection", buf, 0x16u);
        }
      }
      nw_http2_transport_connection_close(a3);
      return 0;
    case 8:
      if (!gLogDatapath)
        return 0;
      v20 = __nwlog_obj();
      result = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        v21 = *(_DWORD *)(a2 + 8);
        v22 = *(_DWORD *)(a2 + 16);
        *(_DWORD *)buf = 136446978;
        v68 = "on_frame_recv_callback";
        v69 = 2082;
        v70 = (char *)(a3 + 205);
        v71 = 1024;
        *(_DWORD *)v72 = v21;
        *(_WORD *)&v72[4] = 1024;
        *(_DWORD *)&v72[6] = v22;
        v11 = "%{public}s %{public}s received window update frame for stream %d, window size increment %d";
        v12 = v20;
        v13 = OS_LOG_TYPE_DEBUG;
        v17 = 34;
LABEL_41:
        _os_log_impl(&dword_182FBE000, v12, v13, v11, buf, v17);
        return 0;
      }
      return result;
    default:
      return result;
  }
  return result;
}

void nw_parameters_set_discretionary(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_WORD *)(*((_QWORD *)v3 + 13) + 108) = *(_WORD *)(*((_QWORD *)v3 + 13) + 108) & 0xFFFE | a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_set_discretionary";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_discretionary";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_set_discretionary";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_discretionary";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_set_discretionary";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_parameters_set_prohibit_constrained(nw_parameters_t parameters, BOOL prohibit_constrained)
{
  _BOOL4 v2;
  nw_parameters_t v3;
  nw_parameters_t v4;
  __int16 v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v2 = prohibit_constrained;
  v20 = *MEMORY[0x1E0C80C00];
  v3 = parameters;
  v4 = v3;
  if (v3)
  {
    if (v2)
      v5 = 2;
    else
      v5 = 0;
    *((_WORD *)v3[13].isa + 50) = *((_WORD *)v3[13].isa + 50) & 0xFFFD | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_parameters_set_prohibit_constrained";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_prohibit_constrained";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_parameters_set_prohibit_constrained";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_prohibit_constrained";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_set_prohibit_constrained";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

BOOL nw_txt_record_create_dictionary_with_initial_length(size_t a1)
{
  NWConcrete_nw_txt_record *v2;
  _BYTE *v3;
  NWConcrete_nw_txt_record *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _BOOL8 result;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  NSObject *v20;
  void *v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  os_log_type_t v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  size_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_txt_record_create_dictionary_with_initial_length";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v15, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s txt_record cannot have length 0", buf, 0xCu);
        }
        goto LABEL_60;
      }
      if (!v29)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s txt_record cannot have length 0, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_60;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s txt_record cannot have length 0, no backtrace", buf, 0xCu);
        }
        goto LABEL_60;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v32 = "nw_txt_record_create_dictionary_with_initial_length";
        v33 = 2082;
        v34 = (size_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s txt_record cannot have length 0, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_48:

      free(backtrace_string);
    }
LABEL_61:
    if (v15)
      free(v15);
    return 0;
  }
  if (a1 >= 0x22C5)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_txt_record_create_dictionary_with_initial_length";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v15, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s txt_record can't have length > 8900", buf, 0xCu);
        }
LABEL_60:

        goto LABEL_61;
      }
      if (!v29)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v16, v28, "%{public}s txt_record can't have length > 8900, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_60;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s txt_record can't have length > 8900, no backtrace", buf, 0xCu);
        }
        goto LABEL_60;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v32 = "nw_txt_record_create_dictionary_with_initial_length";
        v33 = 2082;
        v34 = (size_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s txt_record can't have length > 8900, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_48;
    }
    goto LABEL_61;
  }
  v2 = objc_alloc_init(NWConcrete_nw_txt_record);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_txt_record_create_dictionary_with_initial_length";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v6, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s [nw_txt_record init] failed", buf, 0xCu);
        }
      }
      else if (v29)
      {
        v9 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (v9)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_txt_record_create_dictionary_with_initial_length";
            v33 = 2082;
            v34 = (size_t)v9;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s [nw_txt_record init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v9);
          if (!v6)
            goto LABEL_25;
          goto LABEL_24;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s [nw_txt_record init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_txt_record_create_dictionary_with_initial_length";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s [nw_txt_record init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v6)
      goto LABEL_25;
LABEL_24:
    free(v6);
    goto LABEL_25;
  }
  v3 = malloc_type_malloc(a1, 0xF2B69DE5uLL);
  if (v3)
  {
LABEL_5:
    *((_QWORD *)v2 + 1) = v3;
    *v3 = 0;
    *((_BYTE *)v2 + 36) |= 1u;
    *((_QWORD *)v2 + 2) = 1;
    *((_QWORD *)v2 + 3) = a1;
    v4 = v2;
LABEL_25:

    return (BOOL)v2;
  }
  __nwlog_obj();
  v20 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v32 = "strict_malloc";
  v33 = 2048;
  v34 = a1;
  v21 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

void sub_1832154CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t getEnumTagSinglePayload for IPv6Address.Scope(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFC)
    goto LABEL_17;
  if (a2 + 4 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 4) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 4;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 4;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 4;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 5;
  v8 = v6 - 5;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

NSObject *NWPath.unsatisfiedReason.getter@<X0>(_BYTE *a1@<X8>)
{
  uint64_t v1;
  NSObject *result;
  char v4;

  result = *(NSObject **)(v1 + *(int *)(type metadata accessor for NWPath(0) + 52));
  if (result)
  {
    result = nw_path_get_unsatisfied_reason(result);
    if (result >= 5)
      v4 = 0;
    else
      v4 = (char)result;
  }
  else
  {
    v4 = 0;
  }
  *a1 = v4;
  return result;
}

nw_path_unsatisfied_reason_t nw_path_get_unsatisfied_reason(nw_path_t path)
{
  nw_path_t v1;
  nw_path_t v2;
  int isa_high;
  unsigned int v4;
  nw_path_unsatisfied_reason_t v5;
  nw_path_unsatisfied_reason_t v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = path;
  v2 = v1;
  if (v1)
  {
    isa_high = HIDWORD(v1[47].isa);
    v4 = isa_high - 27;
    v5 = isa_high - 26;
    if (v4 >= 4)
      v6 = nw_path_unsatisfied_reason_not_available;
    else
      v6 = v5;
    goto LABEL_5;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_path_get_unsatisfied_reason";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_path_get_unsatisfied_reason";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_path_get_unsatisfied_reason";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_path_get_unsatisfied_reason";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_path_get_unsatisfied_reason";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v9)
    free(v9);
  v6 = nw_path_unsatisfied_reason_not_available;
LABEL_5:

  return v6;
}

id nw_agent_client_copy_path(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[6];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_agent_client_copy_path";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_agent_client_copy_path";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null client", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_agent_client_copy_path";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null client, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_agent_client_copy_path";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null client, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_agent_client_copy_path";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null client, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL __nw_socket_protocol_identifier_block_invoke()
{
  unk_1EDCE4817 = 0;
  unk_1EDCE480F = 0;
  byte_1EDCE4827 = 0;
  unk_1EDCE481F = 0;
  strcpy((char *)&nw_socket_protocol_identifier::identifier, "socket");
  qword_1EDCE4828 = 0x100000003;
  return nw_protocol_register_extended(&nw_socket_protocol_identifier::identifier, (uint64_t)nw_protocol_socket_create);
}

uint64_t sub_183215DE8@<X0>(uint64_t a1@<X0>, uint64_t (**a2)()@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)();

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    v5 = swift_allocObject();
    *(_QWORD *)(v5 + 16) = v3;
    *(_QWORD *)(v5 + 24) = v4;
    v6 = sub_182FEDAC0;
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }
  *a2 = v6;
  a2[1] = (uint64_t (*)())v5;
  return sub_183061488(v3);
}

void NWListener.newConnectionHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  _QWORD *v9;
  void *v10;
  _QWORD v11[6];

  v5 = *(_QWORD *)(v2 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 192));
  v6 = *(_QWORD *)(v5 + 16);
  sub_183061488(a1);
  sub_1830630AC(v6);
  *(_QWORD *)(v5 + 16) = a1;
  *(_QWORD *)(v5 + 24) = a2;
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 192));
  if (a1)
  {
    v7 = *(NSObject **)(v2 + 24);
    v8 = *(_QWORD *)(v2 + 32);
    v9 = (_QWORD *)swift_allocObject();
    v9[2] = v8;
    v9[3] = a1;
    v9[4] = a2;
    v11[4] = sub_183056AF8;
    v11[5] = v9;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 1107296256;
    v11[2] = sub_182FC77FC;
    v11[3] = &block_descriptor_3;
    v10 = _Block_copy(v11);
    sub_183061488(a1);
    sub_183061488(a1);
    swift_unknownObjectRetain();
    swift_retain();
    swift_release();
    nw_listener_set_new_connection_handler(v7, v10);
    sub_1830630AC(a1);
    _Block_release(v10);
    swift_unknownObjectRelease();
    sub_1830630AC(a1);
  }
  else
  {
    nw_listener_set_new_connection_handler(*(nw_listener_t *)(v2 + 24), 0);
  }
}

void nw_listener_set_new_connection_handler(nw_listener_t listener, nw_listener_new_connection_handler_t handler)
{
  nw_listener_t v3;
  nw_listener_new_connection_handler_t v4;
  void (**v5)(_QWORD);
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  NSObject *v15;
  id v16;
  char v17;
  os_log_type_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = listener;
  v4 = handler;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_set_new_connection_handler_block_invoke;
    aBlock[3] = &unk_1E14ACE18;
    v15 = v3;
    v16 = v4;
    v5 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v5[2](v5);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);

    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_listener_set_new_connection_handler";
  v7 = (char *)_os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_listener_set_new_connection_handler";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_listener_set_new_connection_handler";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_listener_set_new_connection_handler";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_listener_set_new_connection_handler";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_1832162DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __nw_listener_set_new_connection_handler_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const char *id_string;
  void *v6;
  uint64_t v7;
  void *v8;
  int v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v2 + 128) == 4)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1)
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44199);
      v4 = (id)glistenerLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_listener_get_id_string(*(void **)(a1 + 32));
        v9 = 136446466;
        v10 = "nw_listener_set_new_connection_handler_block_invoke";
        v11 = 2082;
        v12 = id_string;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Cannot set new connection handler after cancel", (uint8_t *)&v9, 0x16u);
      }

    }
  }
  else
  {
    v6 = _Block_copy(*(const void **)(a1 + 40));
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(void **)(v7 + 88);
    *(_QWORD *)(v7 + 88) = v6;

  }
}

void NWListener.start(queue:)(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  void *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t (*v8)();
  NSObject *v9;
  __int128 v10;
  uint64_t (*v11[4])();

  v2 = v1;
  v4 = *(_QWORD *)(v2 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 192));
  v5 = *(void **)(v4 + 176);
  v6 = a1;

  *(_QWORD *)(v4 + 176) = a1;
  *(_BYTE *)(v4 + 189) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 192));
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 192));
  sub_183215DE8(v4 + 16, v11);
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 192));
  if (v11[0])
  {
    v10 = *(_OWORD *)v11;
    v7 = swift_allocObject();
    *(_OWORD *)(v7 + 16) = v10;
    v8 = sub_182FEDAC0;
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  sub_183061488((uint64_t)v8);
  sub_183061488((uint64_t)v8);
  NWListener.stateUpdateHandler.setter((uint64_t)v8, v7);
  sub_1830630AC((uint64_t)v8);
  sub_1830630AC((uint64_t)v8);
  v9 = *(NSObject **)(v2 + 24);
  nw_listener_set_queue(v9, v6);
  nw_listener_start(v9);
}

uint64_t NWListener.stateUpdateHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD *v8;
  void *v9;
  _QWORD v11[6];

  v5 = *(_QWORD *)(v2 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 192));
  v6 = *(_QWORD *)(v5 + 48);
  sub_183061488(a1);
  sub_1830630AC(v6);
  *(_QWORD *)(v5 + 48) = a1;
  *(_QWORD *)(v5 + 56) = a2;
  LODWORD(v6) = *(unsigned __int8 *)(v5 + 189);
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 192));
  if ((_DWORD)v6 != 1)
    return sub_1830630AC(a1);
  v7 = *(NSObject **)(v2 + 24);
  v8 = (_QWORD *)swift_allocObject();
  v8[2] = v2;
  v8[3] = a1;
  v8[4] = a2;
  v11[4] = sub_183213230;
  v11[5] = v8;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 1107296256;
  v11[2] = sub_182FED9C4;
  v11[3] = &block_descriptor_6_2;
  v9 = _Block_copy(v11);
  swift_unknownObjectRetain();
  swift_retain();
  sub_183061488(a1);
  swift_release();
  nw_listener_set_state_changed_handler(v7, v9);
  sub_1830630AC(a1);
  _Block_release(v9);
  return swift_unknownObjectRelease();
}

void nw_listener_start(nw_listener_t listener)
{
  NSObject *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;
  void **v4;
  void (**v5)(_QWORD);
  qos_class_t v6;
  id v7;
  _QWORD *v8;
  id v9;
  char *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *backtrace_string;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  os_log_type_t v18;
  os_log_type_t v19;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _QWORD v28[4];
  void **v29;
  qos_class_t v30;
  char v31;
  _QWORD aBlock[4];
  void **v33;
  _BYTE *v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  __int16 v40;
  char *v41;
  _BYTE v42[24];
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v1 = listener;
  v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    *(_QWORD *)v42 = 0;
    *(_QWORD *)&v42[8] = v42;
    *(_QWORD *)&v42[16] = 0x2020000000;
    v3 = MEMORY[0x1E0C809B0];
    v43 = 0;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_start_block_invoke;
    aBlock[3] = &unk_1E14ACE40;
    v34 = v42;
    v4 = v1;
    v33 = v4;
    v5 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 2);
    v5[2](v5);
    os_unfair_lock_unlock(v2 + 2);

    if (*(_BYTE *)(*(_QWORD *)&v42[8] + 24))
    {
      v6 = qos_class_self();
      v7 = nw_parameters_copy_context(v4[2]);
      v28[0] = v3;
      v28[1] = 3221225472;
      v28[2] = __nw_listener_start_block_invoke_52;
      v28[3] = &unk_1E14AB378;
      v29 = v4;
      v30 = v6;
      nw_queue_context_async_if_needed(v7, v28);

LABEL_17:
      _Block_object_dispose(v42, 8);
      goto LABEL_18;
    }
    v8 = v4[2];
    if (!v8 || nw_path_parameters_get_logging_disabled(v8[13]))
      goto LABEL_17;
    if (__nwlog_listener_log::onceToken != -1)
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44199);
    v9 = (id)glistenerLogObj;
    v10 = (char *)v4 + 42;
    *(_DWORD *)buf = 136446466;
    v37 = "nw_listener_start";
    v38 = 2082;
    v39 = (char *)v4 + 42;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v11, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_listener_log::onceToken != -1)
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44199);
        v12 = (id)glistenerLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_listener_start";
          v38 = 2082;
          v39 = v10;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s [%{public}s] In wrong state for start", buf, 0x16u);
        }
      }
      else if (v31)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v15 = (char *)backtrace_string;
          if (__nwlog_listener_log::onceToken != -1)
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44199);
          v16 = (id)glistenerLogObj;
          v17 = type;
          if (os_log_type_enabled(v16, type))
          {
            *(_DWORD *)buf = 136446722;
            v37 = "nw_listener_start";
            v38 = 2082;
            v39 = v10;
            v40 = 2082;
            v41 = v15;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s [%{public}s] In wrong state for start, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v15);
          if (!v11)
            goto LABEL_17;
          goto LABEL_16;
        }
        if (__nwlog_listener_log::onceToken != -1)
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44199);
        v12 = (id)glistenerLogObj;
        v19 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_listener_start";
          v38 = 2082;
          v39 = v10;
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s [%{public}s] In wrong state for start, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        if (__nwlog_listener_log::onceToken != -1)
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44199);
        v12 = (id)glistenerLogObj;
        v18 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_listener_start";
          v38 = 2082;
          v39 = v10;
          _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s [%{public}s] In wrong state for start, backtrace limit exceeded", buf, 0x16u);
        }
      }

    }
    if (!v11)
      goto LABEL_17;
LABEL_16:
    free(v11);
    goto LABEL_17;
  }
  __nwlog_obj();
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)v42 = 136446210;
  *(_QWORD *)&v42[4] = "nw_listener_start";
  v21 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v21, buf, &type))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = buf[0];
      if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v42 = 136446210;
        *(_QWORD *)&v42[4] = "nw_listener_start";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null listener", v42, 0xCu);
      }
    }
    else if (type)
    {
      v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v25 = buf[0];
      v26 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)v42 = 136446466;
          *(_QWORD *)&v42[4] = "nw_listener_start";
          *(_WORD *)&v42[12] = 2082;
          *(_QWORD *)&v42[14] = v24;
          _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null listener, dumping backtrace:%{public}s", v42, 0x16u);
        }

        free(v24);
        goto LABEL_53;
      }
      if (v26)
      {
        *(_DWORD *)v42 = 136446210;
        *(_QWORD *)&v42[4] = "nw_listener_start";
        _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null listener, no backtrace", v42, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v27 = buf[0];
      if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v42 = 136446210;
        *(_QWORD *)&v42[4] = "nw_listener_start";
        _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s called with null listener, backtrace limit exceeded", v42, 0xCu);
      }
    }

  }
LABEL_53:
  if (v21)
    free(v21);
LABEL_18:

}

void sub_183216D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24)
{
  void *v24;
  void *v25;
  uint64_t v26;

  _Block_object_dispose((const void *)(v26 - 144), 8);
  _Unwind_Resume(a1);
}

void nw_listener_set_state_changed_handler(nw_listener_t listener, nw_listener_state_changed_handler_t handler)
{
  nw_listener_t v3;
  nw_listener_state_changed_handler_t v4;
  void (**v5)(_QWORD);
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  NSObject *v15;
  id v16;
  char v17;
  os_log_type_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = listener;
  v4 = handler;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_set_state_changed_handler_block_invoke;
    aBlock[3] = &unk_1E14ACE18;
    v15 = v3;
    v16 = v4;
    v5 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v5[2](v5);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);

    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_listener_set_state_changed_handler";
  v7 = (char *)_os_log_send_and_compose_impl();

  v18 = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_listener_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v18;
      v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_listener_set_state_changed_handler";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_listener_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_listener_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_1832170F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void nw_listener_set_queue(nw_listener_t listener, dispatch_queue_t queue)
{
  nw_listener_t v3;
  NSObject *v4;
  NSObject *v5;
  void (**v6)(_QWORD);
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD aBlock[4];
  NSObject *v22;
  NSObject *v23;
  char v24;
  os_log_type_t v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = listener;
  v4 = queue;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_listener_set_queue";
    v8 = (char *)_os_log_send_and_compose_impl();

    v25 = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24))
      goto LABEL_38;
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_listener_set_queue";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = v25;
      v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_listener_set_queue";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_listener_set_queue";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_listener_set_queue";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_set_queue_block_invoke;
    aBlock[3] = &unk_1E14ACE68;
    v22 = v3;
    v23 = v5;
    v6 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v6[2](v6);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);

    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_listener_set_queue";
  v8 = (char *)_os_log_send_and_compose_impl();

  v25 = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24))
    goto LABEL_38;
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_listener_set_queue";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_listener_set_queue";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = v25;
  v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_listener_set_queue";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_listener_set_queue";
    v28 = 2082;
    v29 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

