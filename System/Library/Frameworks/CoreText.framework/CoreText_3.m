void `anonymous namespace'::MorxLigatureSubtableBuilder::CreateSubtableData(_anonymous_namespace_::MorxLigatureSubtableBuilder *this, uint64_t a2)
{
  unint64_t v2;
  const __CFData *v4;
  CFIndex Length;
  CFIndex v6;
  uint64_t v7;
  unsigned int v8;
  unint64_t v9;
  __CFData *v10;
  __CFData *v11;
  __CFData *v12;
  __CFData *v13;
  const __CFData *v14;
  int v15;
  const __CFData *v16;
  int v17;
  const __CFData *v18;
  int v19;
  _anonymous_namespace_ *v20;
  const __CFData *v21;
  const __CFData *v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  unsigned int v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  const __CFData *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int *v31;
  __CFData *v32;
  unsigned int v33;
  const __CFData *v34;
  unsigned int v35;
  unsigned __int16 *v36;
  unsigned __int16 *v37;
  __CFData *v38;
  unsigned int v39;
  const __CFData *v40;
  unsigned int v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  __CFData *v44;
  unsigned int v45;
  unint64_t v46;
  id v48;
  UInt8 bytes[4];

  v2 = *(_QWORD *)(a2 + 360)
     + *(_QWORD *)(a2 + 512)
     - (*(_QWORD *)(a2 + 352)
      + *(_QWORD *)(a2 + 504))
     + *(_QWORD *)(a2 + 608)
     - *(_QWORD *)(a2 + 600);
  if (v2 >= 0xFFFFFFFF)
  {
    *(_QWORD *)this = 0;
  }
  else
  {
    v48 = (id)0xAAAAAAAAAAAAAAAALL;
    v4 = (const __CFData *)atomic_load((unint64_t *)(a2 + 32));
    Length = CFDataGetLength(v4);
    v6 = Length + 28;
    if ((unint64_t)(Length + 28) >= 0xFFFFFFFF
      || (v7 = *(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40), v8 = v7 + v6, (unint64_t)(v7 + v6) >= 0xFFFFFFFF)
      || (v9 = v2 + Length + v7 + *(_QWORD *)(a2 + 144) - *(_QWORD *)(a2 + 136) + 28, v9 >= 0xFFFFFFFF))
    {
      v48 = 0;
    }
    else
    {
      v48 = (id)0xAAAAAAAAAAAAAAAALL;
      v10 = (__CFData *)atomic_load((unint64_t *)&v48);
      *(_DWORD *)bytes = bswap32(*(_DWORD *)(a2 + 24));
      CFDataAppendBytes(v10, bytes, 4);
      v11 = (__CFData *)atomic_load((unint64_t *)&v48);
      *(_DWORD *)bytes = 469762048;
      CFDataAppendBytes(v11, bytes, 4);
      v12 = (__CFData *)atomic_load((unint64_t *)&v48);
      *(_DWORD *)bytes = bswap32(v6);
      CFDataAppendBytes(v12, bytes, 4);
      v13 = (__CFData *)atomic_load((unint64_t *)&v48);
      *(_DWORD *)bytes = bswap32(v8);
      CFDataAppendBytes(v13, bytes, 4);
    }
    v14 = (const __CFData *)atomic_load((unint64_t *)&v48);
    v15 = CFDataGetLength(v14);
    CFDataIncreaseLength(v14, 4);
    v16 = (const __CFData *)atomic_load((unint64_t *)&v48);
    v17 = CFDataGetLength(v16);
    CFDataIncreaseLength(v16, 4);
    v18 = (const __CFData *)atomic_load((unint64_t *)&v48);
    v19 = CFDataGetLength(v18);
    CFDataIncreaseLength(v18, 4);
    v20 = (_anonymous_namespace_ *)atomic_load((unint64_t *)&v48);
    v21 = (const __CFData *)atomic_load((unint64_t *)(a2 + 32));
    v23 = *(unsigned __int16 **)(a2 + 40);
    v24 = *(unsigned __int16 **)(a2 + 48);
    while (v23 != v24)
    {
      v25 = *v23++;
      *(_WORD *)bytes = bswap32(v25) >> 16;
      CFDataAppendBytes(v20, bytes, 2);
    }
    v27 = *(unsigned __int16 **)(a2 + 136);
    v26 = *(unsigned __int16 **)(a2 + 144);
    while (v27 != v26)
    {
      *(_WORD *)bytes = bswap32(*v27) >> 16;
      CFDataAppendBytes(v20, bytes, 2);
      *(_WORD *)bytes = bswap32(v27[1]) >> 16;
      CFDataAppendBytes(v20, bytes, 2);
      *(_WORD *)bytes = bswap32(v27[2]) >> 16;
      CFDataAppendBytes(v20, bytes, 2);
      v27 += 3;
    }
    v28 = (const __CFData *)atomic_load((unint64_t *)&v48);
    v29 = bswap32(CFDataGetLength(v28) - 12);
    *(_DWORD *)&CFDataGetMutableBytePtr(v14)[v15] = v29;
    v30 = *(unsigned int **)(a2 + 352);
    v31 = *(unsigned int **)(a2 + 360);
    while (v30 != v31)
    {
      v32 = (__CFData *)atomic_load((unint64_t *)&v48);
      v33 = *v30++;
      *(_DWORD *)bytes = bswap32(v33);
      CFDataAppendBytes(v32, bytes, 4);
    }
    v34 = (const __CFData *)atomic_load((unint64_t *)&v48);
    v35 = bswap32(CFDataGetLength(v34) - 12);
    *(_DWORD *)&CFDataGetMutableBytePtr(v16)[v17] = v35;
    v36 = *(unsigned __int16 **)(a2 + 504);
    v37 = *(unsigned __int16 **)(a2 + 512);
    while (v36 != v37)
    {
      v38 = (__CFData *)atomic_load((unint64_t *)&v48);
      v39 = *v36++;
      *(_WORD *)bytes = bswap32(v39) >> 16;
      CFDataAppendBytes(v38, bytes, 2);
    }
    v40 = (const __CFData *)atomic_load((unint64_t *)&v48);
    v41 = bswap32(CFDataGetLength(v40) - 12);
    *(_DWORD *)&CFDataGetMutableBytePtr(v18)[v19] = v41;
    v42 = *(unsigned __int16 **)(a2 + 600);
    v43 = *(unsigned __int16 **)(a2 + 608);
    while (v42 != v43)
    {
      v44 = (__CFData *)atomic_load((unint64_t *)&v48);
      v45 = *v42++;
      *(_WORD *)bytes = bswap32(v45) >> 16;
      CFDataAppendBytes(v44, bytes, 2);
    }
    do
      v46 = __ldaxr((unint64_t *)&v48);
    while (__stlxr(0, (unint64_t *)&v48));
    *(_QWORD *)this = v46;

  }
}

void `anonymous namespace'::MorxLigatureSubtableBuilder::~MorxLigatureSubtableBuilder(id *this)
{
  id *v2;
  void **v3;

  *this = off_1E15DEC28;
  v2 = this + 4;
  v3 = this + 75;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  v3 = this + 63;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  v3 = this + 44;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  *this = off_1E15DECA0;
  std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(this + 17));
  v3 = this + 5;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);

}

{
  id *v2;
  void **v3;

  *this = off_1E15DEC28;
  v2 = this + 4;
  v3 = this + 75;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  v3 = this + 63;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  v3 = this + 44;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  *this = off_1E15DECA0;
  std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(this + 17));
  v3 = this + 5;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);

  MEMORY[0x186DC03AC](this, 0x10F1C40AC1E5FC9);
}

char **AddPrevLigaturesFromLigInputs(char **result, char **a2, uint64_t a3)
{
  char **v3;
  char **v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  _QWORD v37[5];

  if (a3 - (uint64_t)a2 >= 1)
  {
    v3 = a2;
    v4 = result;
    v5 = (a3 - (uint64_t)a2) / 48;
    v7 = *result;
    v6 = (unint64_t)result[1];
    v8 = (uint64_t)(v6 - (_QWORD)*result) / 48;
    v9 = &(*result)[48 * v8];
    v10 = result[2];
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v10[-v6] >> 4)) >= v5)
    {
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (_QWORD)v9) >> 4)) >= v5)
      {
        v18 = (uint64_t)&a2[6 * v5];
        v19 = result[1];
      }
      else
      {
        v18 = (uint64_t)&a2[2 * ((uint64_t)(v6 - (_QWORD)v9) >> 4)];
        if ((uint64_t)(v6 - (_QWORD)v9) < 1)
          return result;
        v19 = v4[1];
      }
      v20 = &v9[48 * v5];
      v21 = &v19[-48 * v5];
      result = (char **)v19;
      if ((unint64_t)v21 < v6)
      {
        result = (char **)v19;
        do
        {
          v22 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)result, *(_BYTE **)v21, *((_BYTE **)v21 + 1));
          *(_WORD *)(v22 + 40) = *((_WORD *)v21 + 20);
          result = (char **)(v22 + 48);
          v21 += 48;
        }
        while ((unint64_t)v21 < v6);
      }
      v4[1] = (char *)result;
      if (v19 != v20)
      {
        v23 = v19 - 48;
        v24 = 16 * ((v19 - v20) >> 4);
        do
        {
          result = (char **)std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(v23, *(char **)&v9[v24 - 48], *(_QWORD *)&v9[v24 - 40], (uint64_t)(*(_QWORD *)&v9[v24 - 40] - *(_QWORD *)&v9[v24 - 48]) >> 1);
          *((_WORD *)v23 + 20) = *(_WORD *)&v9[v24 - 8];
          v23 -= 48;
          v24 -= 48;
        }
        while (v24);
      }
      if ((char **)v18 != v3)
      {
        do
        {
          result = (char **)std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(v9, *v3, (uint64_t)v3[1], (v3[1] - *v3) >> 1);
          *((_WORD *)v9 + 20) = *((_WORD *)v3 + 20);
          v3 += 6;
          v9 += 48;
        }
        while (v3 != (char **)v18);
      }
    }
    else
    {
      v11 = v8 + v5;
      if ((unint64_t)(v8 + v5) > 0x555555555555555)
        abort();
      v12 = (uint64_t)(result + 3);
      v13 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v7) >> 4);
      if (2 * v13 > v11)
        v11 = 2 * v13;
      if (v13 >= 0x2AAAAAAAAAAAAAALL)
        v14 = 0x555555555555555;
      else
        v14 = v11;
      v37[4] = v4 + 3;
      if (v14)
      {
        v17 = v16;
      }
      else
      {
        v15 = 0;
        v17 = 0;
      }
      v25 = &v15[48 * v8];
      v26 = (uint64_t)&v25[48 * v5];
      v27 = 48 * v5;
      v28 = (uint64_t)v25;
      do
      {
        v29 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v28, *v3, v3[1]);
        *(_WORD *)(v29 + 40) = *((_WORD *)v3 + 20);
        v28 = v29 + 48;
        v3 += 6;
        v27 -= 48;
      }
      while (v27);
      v30 = *v4;
      if (*v4 != v9)
      {
        v31 = 48 * v8;
        v32 = v15;
        do
        {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v32[v31 - 48], *(_BYTE **)&v7[v31 - 48], *(_BYTE **)&v7[v31 - 40]);
          *(_WORD *)&v32[v31 - 8] = *(_WORD *)&v7[v31 - 8];
          v7 -= 48;
          v32 -= 48;
        }
        while (&v7[v31] != v30);
        v25 = &v32[48 * v8];
      }
      v33 = &v15[48 * v17];
      v34 = v4[1];
      if (v34 != v9)
      {
        do
        {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v26, *(_BYTE **)v9, *((_BYTE **)v9 + 1));
          *(_WORD *)(v26 + 40) = *((_WORD *)v9 + 20);
          v26 += 48;
          v9 += 48;
        }
        while (v9 != v34);
        v9 = v4[1];
      }
      v35 = *v4;
      *v4 = v25;
      v4[1] = (char *)v26;
      v36 = v4[2];
      v4[2] = v33;
      v37[2] = v9;
      v37[3] = v36;
      v37[0] = v35;
      v37[1] = v35;
    }
  }
  return result;
}

_QWORD *TInlineVector<`anonymous namespace'::LigInput,30ul>::~TInlineVector(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;

  v2 = (_QWORD *)*a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = (_QWORD *)*a1;
    if ((_QWORD *)v3 != v2)
    {
      do
      {
        v3 -= 48;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v3);
      }
      while ((_QWORD *)v3 != v2);
      v4 = (_QWORD *)*a1;
    }
    a1[1] = v2;
    v5 = a1 + 183;
    if (a1 + 3 <= v4 && v5 > v4)
    {
      if (a1[2] == a1[183])
        *v5 = v4;
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t `anonymous namespace'::ParseSubstFormat3(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _WORD *v8;
  uint64_t result;
  unsigned __int16 *v10;
  int v11;
  char **v12;
  unsigned int v13;
  int v14;
  _WORD *v15;
  unint64_t v16;
  unint64_t v17;
  __int128 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  char *v29;
  unint64_t v30;
  char *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  __int128 v41;
  char *v42;
  char *v43;
  unint64_t v44;
  char *v45;
  void *v46;
  void *v47;
  uint64_t *v48;
  uint64_t v50;
  char **v51;
  unint64_t v52;
  _OWORD v53[2];
  unint64_t v54;
  void *__p[2];
  uint64_t v56;
  _QWORD v57[3];
  _QWORD *v58;
  _QWORD v59[5];

  v5 = a3;
  v6 = a1;
  v7 = 0;
  v59[3] = *MEMORY[0x1E0C80C00];
  *a4 = a1;
  a4[1] = a2;
  v8 = (_WORD *)(a1 + 2);
  v59[0] = a4 + 2;
  v59[1] = a4 + 18;
  v48 = (uint64_t *)(a4 + 18);
  v59[2] = a4 + 34;
  do
  {
    result = 0;
    if ((unint64_t)v8 < v6)
      return result;
    v10 = v8 + 1;
    if ((unint64_t)(v8 + 1) > a4[1])
      return result;
    v50 = v7;
    if (*v8)
    {
      v11 = 0;
      v12 = (char **)v59[v7];
      v13 = __rev16((unsigned __int16)*v8);
      if (v13 <= 1)
        v14 = 1;
      else
        v14 = v13;
      v51 = v12 + 15;
      v52 = (unint64_t)(v12 + 3);
      while (1)
      {
        v15 = v8 + 2;
        v8 = v10;
        __p[0] = 0;
        __p[1] = 0;
        v56 = 0;
        v17 = *a4;
        v16 = a4[1];
        if (*a4 <= (unint64_t)v8 && (unint64_t)v15 <= v16)
          break;
        std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](v48);
LABEL_22:
        v26 = 1;
LABEL_51:
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if (v26)
          return 0;
        ++v11;
        v10 = v8 + 1;
        if (v11 == v14)
          goto LABEL_57;
      }
      v54 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v53[0] = v19;
      v53[1] = v19;
      OTL::Coverage::Coverage((OTL::Coverage *)v53, (unsigned __int16 *)(v17 + (bswap32((unsigned __int16)*v8) >> 16)), v16, 0);
      v57[0] = &off_1E15DFE18;
      v57[1] = v5;
      v57[2] = __p;
      v58 = v57;
      OTL::Coverage::Iterate((unsigned __int16 **)v53, (uint64_t)v57);
      v20 = v58;
      if (v58 == v57)
      {
        v20 = v57;
        v21 = 4;
      }
      else
      {
        if (!v58)
          goto LABEL_18;
        v21 = 5;
      }
      (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_18:
      if (__p[0] == __p[1])
      {
        v26 = 0;
      }
      else
      {
        v22 = (unsigned __int16 *)((char *)__p[0] + 2);
        v23 = (unsigned __int16 *)((char *)__p[0] + 2);
        while (v23 != __p[1])
        {
          v24 = *v23;
          v25 = *(v23++ - 1);
          if (v24 < v25)
            goto LABEL_22;
        }
        while (v22 != __p[1])
        {
          v27 = *(v22 - 1);
          v28 = *v22++;
          if (v27 == v28)
          {
            if (v22 - 2 != __p[1])
              goto LABEL_22;
            break;
          }
        }
        v29 = v12[1];
        v30 = (unint64_t)v12[2];
        if ((unint64_t)v29 >= v30)
        {
          v32 = 0xAAAAAAAAAAAAAAABLL * ((v29 - *v12) >> 3);
          v33 = v32 + 1;
          if (v32 + 1 > 0xAAAAAAAAAAAAAAALL)
            abort();
          v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - (_QWORD)*v12) >> 3);
          if (2 * v34 > v33)
            v33 = 2 * v34;
          if (v34 >= 0x555555555555555)
            v35 = 0xAAAAAAAAAAAAAAALL;
          else
            v35 = v33;
          v36 = (char *)TInlineBufferAllocator<std::vector<unsigned short>,4ul>::allocate(v52, v35);
          v37 = &v36[24 * v32];
          v38 = &v36[24 * v35];
          *((_QWORD *)v37 + 1) = 0;
          *((_QWORD *)v37 + 2) = 0;
          *(_QWORD *)v37 = 0;
          *(_OWORD *)v37 = *(_OWORD *)__p;
          *((_QWORD *)v37 + 2) = v56;
          __p[1] = 0;
          v56 = 0;
          __p[0] = 0;
          v31 = v37 + 24;
          v39 = *v12;
          v40 = v12[1];
          if (v40 == *v12)
          {
            *v12 = v37;
            v12[1] = v31;
            v43 = v12[2];
            v12[2] = v38;
          }
          else
          {
            do
            {
              *((_QWORD *)v37 - 3) = 0;
              *((_QWORD *)v37 - 2) = 0;
              v37 -= 24;
              *((_QWORD *)v37 + 2) = 0;
              v41 = *(_OWORD *)(v40 - 24);
              v40 -= 24;
              *(_OWORD *)v37 = v41;
              *((_QWORD *)v37 + 2) = *((_QWORD *)v40 + 2);
              *(_QWORD *)v40 = 0;
              *((_QWORD *)v40 + 1) = 0;
              *((_QWORD *)v40 + 2) = 0;
            }
            while (v40 != v39);
            v40 = *v12;
            v42 = v12[1];
            *v12 = v37;
            v12[1] = v31;
            v43 = v12[2];
            v12[2] = v38;
            if (v42 != v40)
            {
              v44 = v6;
              v45 = v42;
              do
              {
                v47 = (void *)*((_QWORD *)v45 - 3);
                v45 -= 24;
                v46 = v47;
                if (v47)
                {
                  *((_QWORD *)v42 - 2) = v46;
                  operator delete(v46);
                }
                v42 = v45;
              }
              while (v45 != v40);
              v6 = v44;
              v5 = a3;
            }
          }
          if (v40)
          {
            if (v52 > (unint64_t)v40 || v51 <= (char **)v40)
            {
              operator delete(v40);
            }
            else if (v43 == *v51)
            {
              *v51 = v40;
            }
          }
        }
        else
        {
          *(_QWORD *)v29 = 0;
          *((_QWORD *)v29 + 1) = 0;
          *((_QWORD *)v29 + 2) = 0;
          *(_OWORD *)v29 = *(_OWORD *)__p;
          *((_QWORD *)v29 + 2) = v56;
          __p[0] = 0;
          __p[1] = 0;
          v56 = 0;
          v31 = v29 + 24;
        }
        v26 = 0;
        v12[1] = v31;
      }
      goto LABEL_51;
    }
LABEL_57:
    v7 = v50 + 1;
    v8 = v10;
  }
  while (v50 != 2);
  if (a4[18] != a4[19])
  {
    if ((unint64_t)v10 >= v6 && (unint64_t)(v10 + 1) <= a4[1])
    {
      *((_DWORD *)a4 + 100) = bswap32(*v10) >> 16;
      a4[51] = (unint64_t)(v10 + 1);
      return 1;
    }
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](v48);
  }
  return 0;
}

uint64_t SingleSubstIsEqualTo(unsigned __int16 *a1, uint64_t a2, unint64_t a3)
{
  unsigned int v4;
  uint64_t result;
  unsigned __int16 *v6;
  unsigned int v7;
  uint64_t v8;
  unsigned __int16 *v9;
  unint64_t v10;
  BOOL v11;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unint64_t v17;
  BOOL v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  BOOL v24;

  v4 = bswap32(*a1) >> 16;
  if (v4 != 2)
  {
    if (v4 == 1)
    {
      result = 0;
      if ((unint64_t)(a1 + 3) <= a3 && a2 + 6 <= a3)
        return a1[2] == *(unsigned __int16 *)(a2 + 4);
      return result;
    }
    return 0;
  }
  v6 = a1 + 3;
  if ((unint64_t)(a1 + 3) > a3)
    return 0;
  v7 = a1[2];
  v8 = __rev16(v7);
  v9 = &v6[v8];
  v10 = (unint64_t)(a1 + 4) <= a3 ? (a3 - (unint64_t)v6) >> 1 : 0;
  v11 = (unint64_t)v9 <= a3 && v9 >= v6;
  if (!v11 && v10 != v8)
    return 0;
  v13 = (unsigned __int16 *)(a2 + 6);
  if (a2 + 6 > a3)
    return 0;
  result = 0;
  v14 = *(unsigned __int16 *)(a2 + 4);
  v15 = __rev16(v14);
  v16 = &v13[v15];
  if (a2 + 8 <= a3)
    v17 = (a3 - (unint64_t)v13) >> 1;
  else
    v17 = 0;
  v19 = (unint64_t)v16 <= a3 && v16 >= v13 || v17 == v15;
  if (v19 && v7 == v14)
  {
    if (v7)
    {
      v20 = 2 * v8 - 2;
      do
      {
        v22 = *v6++;
        v21 = v22;
        v23 = *v13++;
        result = v21 == v23;
        v24 = v21 != v23 || v20 == 0;
        v20 -= 2;
      }
      while (!v24);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void std::vector<`anonymous namespace'::SubstFormat3,TInlineBufferAllocator<`anonymous namespace'::SubstFormat3,30ul>>::emplace_back<`anonymous namespace'::SubstFormat3>(uint64_t a1, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  __int128 v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __int128 v12;
  __int128 v13;
  unint64_t v14;

  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v14 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v12 = v7;
    v13 = v7;
    v8 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v5 - *(_QWORD *)a1) >> 5);
    if ((unint64_t)(v8 + 1) > 0x9D89D89D89D89DLL)
      abort();
    v9 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v4 - *(_QWORD *)a1) >> 5);
    v10 = 2 * v9;
    if (2 * v9 <= v8 + 1)
      v10 = v8 + 1;
    if (v9 >= 0x4EC4EC4EC4EC4ELL)
      v11 = 0x9D89D89D89D89DLL;
    else
      v11 = v10;
    *(_QWORD *)&v13 = v13 + 416;
    v6 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v6 = v5 + 416;
  }
  *(_QWORD *)(a1 + 8) = v6;
}

void CreateSingleSubstitutionLookupTable(unint64_t *a1, int64_t a2, int a3, unsigned __int16 *a4, unint64_t a5, uint64_t a6, uint64_t a7, __int16 a8)
{
  __CFData *SingleSubstitutionLKTHandle;
  _QWORD *v16;
  uint64_t v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v18, a7);
  SingleSubstitutionLKTHandle = CreateSingleSubstitutionLKTHandle(a2, a3, a4, a5, a6, (uint64_t)v18, a8);
  v16 = v19;
  if (v19 == v18)
  {
    v17 = 4;
    v16 = v18;
  }
  else
  {
    if (!v19)
      goto LABEL_6;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_6:
  if (SingleSubstitutionLKTHandle)
  {
    *a1 = 0xAAAAAAAAAAAAAAAALL;
    LKTCreateLookupTable(SingleSubstitutionLKTHandle, a1);
    DisposeLKTHandle(SingleSubstitutionLKTHandle);
  }
  else
  {
    *a1 = 0;
  }
}

void `anonymous namespace'::MorxContextualSubtableBuilder::CreateSubtableData(_anonymous_namespace_::MorxContextualSubtableBuilder *this, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t *v4;
  const __CFData *v5;
  unsigned int Length;
  const __CFData *v7;
  int v8;
  _anonymous_namespace_ *v9;
  const __CFData *v10;
  const __CFData *v11;
  _anonymous_namespace_ *v12;
  const __CFData *v13;
  const __CFData *v14;
  unint64_t v15;
  id v16;

  v2 = a2;
  v16 = (id)0xAAAAAAAAAAAAAAAALL;
  v4 = a2 + 51;
  v5 = (const __CFData *)atomic_load(a2 + 51);
  Length = CFDataGetLength(v5);
  v7 = (const __CFData *)atomic_load((unint64_t *)&v16);
  v8 = CFDataGetLength(v7);
  CFDataIncreaseLength(v7, 4);
  v9 = (_anonymous_namespace_ *)atomic_load((unint64_t *)&v16);
  v11 = (const __CFData *)atomic_load((unint64_t *)&v16);
  LODWORD(v2) = bswap32(CFDataGetLength(v11) - 12);
  *(_DWORD *)&CFDataGetMutableBytePtr(v7)[v8] = (_DWORD)v2;
  v12 = (_anonymous_namespace_ *)atomic_load((unint64_t *)&v16);
  v13 = (const __CFData *)atomic_load(v4);
  do
    v15 = __ldaxr((unint64_t *)&v16);
  while (__stlxr(0, (unint64_t *)&v16));
  *(_QWORD *)this = v15;

}

void `anonymous namespace'::MorxContextualSubtableBuilder::~MorxContextualSubtableBuilder(id *this)
{
  *this = &off_1E15DEC78;

}

{
  *this = &off_1E15DEC78;

  JUMPOUT(0x186DC03ACLL);
}

_QWORD *`anonymous namespace'::MorxChainBuilder::AddNoEffectExclusiveFeatures<std::__wrap_iter<unsigned short *>>(_QWORD *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 *v6;
  _QWORD *v7;
  _QWORD *v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  uint64_t v11;
  int v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;

  if (a2 != a3)
  {
    v17 = v3;
    v18 = v4;
    v6 = a2;
    v7 = result;
    v8 = result + 1;
    do
    {
      v9 = (unsigned __int16 *)v7[1];
      v10 = (unsigned __int16 *)v7[2];
      if (v9 != v10)
      {
        while (*v9 != *v6)
        {
          v9 += 6;
          if (v9 == v10)
          {
            v9 = (unsigned __int16 *)v7[2];
            break;
          }
        }
      }
      v11 = 0;
      LOWORD(v15) = *v9;
      v12 = *v9;
      while (*(unsigned __int16 *)((char *)&kMasterFeatureMap + v11 + 4) != v12)
      {
        v11 += 12;
        if (v11 == 1980)
        {
LABEL_14:
          v14 = 0;
          goto LABEL_15;
        }
      }
      while ((*((_BYTE *)&kMasterFeatureMap + v11 + 8) & 2) == 0)
      {
        if (v11 != 1968)
        {
          v13 = *(unsigned __int16 *)((char *)&kMasterFeatureMap + v11 + 16);
          v11 += 12;
          if (v13 == v12)
            continue;
        }
        goto LABEL_14;
      }
      v14 = *(_WORD *)((char *)&kMasterFeatureMap + v11 + 6);
LABEL_15:
      WORD1(v15) = v14;
      HIDWORD(v15) = 0;
      v16 = *((_DWORD *)v9 + 2) ^ *((_DWORD *)v9 + 1);
      result = std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::emplace<MortFeatureEntry>(v8, (char *)v9, &v15);
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

void std::vector<`anonymous namespace'::MorxChainBuilder,TInlineBufferAllocator<`anonymous namespace'::MorxChainBuilder,30ul>>::push_back[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  void **v15;
  void **v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t *v20;
  unint64_t *v21;
  unint64_t *v22;
  unint64_t *v23;
  void **v24;
  uint64_t v25;
  void ***v26;

  v5 = a1[1];
  v4 = a1[2];
  if (v5 >= v4)
  {
    v7 = 0xCBEEA4E1A08AD8F3 * ((uint64_t)(v5 - *a1) >> 4);
    if (v7 + 1 > 0x456C797DD49C34)
      abort();
    v8 = 0xCBEEA4E1A08AD8F3 * ((uint64_t)(v4 - *a1) >> 4);
    v9 = 2 * v8;
    if (2 * v8 <= v7 + 1)
      v9 = v7 + 1;
    if (v8 >= 0x22B63CBEEA4E1ALL)
      v10 = 0x456C797DD49C34;
    else
      v10 = v9;
    if (v10)
    {
      v11 = (char *)a1[3543];
      v12 = (unint64_t)&v11[944 * v10];
      if (v12 <= (unint64_t)(a1 + 3543))
      {
        a1[3543] = v12;
      }
      else
      {
        if (v10 > 0x456C797DD49C34)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v11 = (char *)operator new(944 * v10);
      }
    }
    else
    {
      v11 = 0;
    }
    v13 = (uint64_t)&v11[944 * v7];
    v14 = &v11[944 * v10];
    v6 = v13 + 944;
    v16 = (void **)*a1;
    v15 = (void **)a1[1];
    if (v15 == (void **)*a1)
    {
      *a1 = v13;
      a1[1] = v6;
      v25 = a1[2];
      a1[2] = (uint64_t)v14;
    }
    else
    {
      v17 = 0;
      do
      {
        v18 = v13 + v17 * 8;
        *(_DWORD *)(v13 + v17 * 8 - 944) = v15[v17 - 118];
        std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::vector<std::__wrap_iter<MortFeatureEntry const*>,0>((char **)(v13 + v17 * 8 - 936), v15[v17 - 117], v15[v17 - 116]);
        v19 = (_QWORD *)(v13 + v17 * 8 - 544);
        v20 = (unint64_t *)v15[v17 - 68];
        v21 = (unint64_t *)v15[v17 - 67];
        v19[2] = 0;
        *(_OWORD *)v19 = 0u;
        *(_QWORD *)(v18 - 280) = v18 - 520;
        std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>(v19, v20, v21, v21 - v20);
        v22 = (unint64_t *)v15[v17 - 34];
        v23 = (unint64_t *)v15[v17 - 33];
        *(_QWORD *)(v18 - 264) = 0;
        *(_QWORD *)(v18 - 272) = 0;
        *(_QWORD *)(v18 - 256) = 0;
        *(_QWORD *)(v18 - 8) = v18 - 248;
        std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>((_QWORD *)(v13 + v17 * 8 - 272), v22, v23, v23 - v22);
        v17 -= 118;
      }
      while (&v15[v17] != v16);
      v15 = (void **)*a1;
      v24 = (void **)a1[1];
      *a1 = v13 + v17 * 8;
      a1[1] = v6;
      v25 = a1[2];
      a1[2] = (uint64_t)v14;
      while (v24 != v15)
      {
        v24 -= 118;
      }
    }
    if (v15)
    {
      if (a1 + 3 > (uint64_t *)v15 || (v26 = (void ***)(a1 + 3543), a1 + 3543 <= (uint64_t *)v15))
      {
        operator delete(v15);
      }
      else if ((void **)v25 == *v26)
      {
        *v26 = v15;
      }
    }
  }
  else
  {
    v6 = v5 + 944;
  }
  a1[1] = v6;
}

uint64_t *std::__tree<unsigned int>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  return std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v6, a2);
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 != v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v18 = v7[1];
      *(_QWORD *)v12 = v18;
      if (v18)
        *(_QWORD *)(v18 + 16) = v12;
      v7[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(_QWORD *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12)
        result = v7;
      v7 = *(uint64_t **)v12;
    }
    v19 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24))
      goto LABEL_68;
    v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        v20 = v7;
      }
      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v26 = *v20;
        v7[1] = *v20;
        if (v26)
          *(_QWORD *)(v26 + 16) = v7;
        v20[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
        *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        v19 = v7;
      }
      v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      v24 = *(uint64_t **)v23;
      v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      *(_QWORD *)v23 = v27;
      if (v27)
        *(_QWORD *)(v27 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v13 = *(uint64_t **)(v12 + 8);
    v14 = *v13;
    *(_QWORD *)(v12 + 8) = *v13;
    if (v14)
      *(_QWORD *)(v14 + 16) = v12;
    v13[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
    *v13 = v12;
    *(_QWORD *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7)
      result = v7;
    v7 = *(uint64_t **)(*v7 + 8);
  }
  v15 = (_QWORD *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_59;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
    goto LABEL_49;
  }
  v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    v15 = v7;
  }
  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v22 = v15[1];
    *v7 = v22;
    if (v22)
      *(_QWORD *)(v22 + 16) = v7;
    v15[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    v16 = v7;
  }
  v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  v24 = *(uint64_t **)(v23 + 8);
  v25 = *v24;
  *(_QWORD *)(v23 + 8) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  *v24 = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::erase(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;
  uint64_t *v7;

  v3 = *(_QWORD **)(a2 + 8);
  if (v3)
  {
    do
    {
      v4 = v3;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  else
  {
    v5 = (_QWORD *)a2;
    do
    {
      v4 = (_QWORD *)v5[2];
      v6 = *v4 == (_QWORD)v5;
      v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2)
    *a1 = v4;
  v7 = (uint64_t *)a1[1];
  --a1[2];
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, (uint64_t *)a2);
  std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(*(_QWORD **)(a2 + 48));
  operator delete((void *)a2);
}

void std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15DF680;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15DF680;
  a2[1] = v2;
  return result;
}

void std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::operator()(uint64_t a1, __int16 *a2)
{
  __int16 v2;
  uint64_t v3;
  _WORD *v4;
  unint64_t v5;
  _WORD *v6;
  _WORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  __int16 v16;

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_WORD **)(v3 + 8);
  v5 = *(_QWORD *)(v3 + 16);
  if ((unint64_t)v4 >= v5)
  {
    v7 = *(_WORD **)v3;
    v8 = (uint64_t)v4 - *(_QWORD *)v3;
    if (v8 <= -3)
      abort();
    v9 = v8 >> 1;
    v10 = v5 - (_QWORD)v7;
    if (v10 <= (v8 >> 1) + 1)
      v11 = v9 + 1;
    else
      v11 = v10;
    if (v10 >= 0x7FFFFFFFFFFFFFFELL)
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v3 + 16, v12);
      v7 = *(_WORD **)v3;
      v4 = *(_WORD **)(v3 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[2 * v9];
    v15 = &v13[2 * v12];
    *(_WORD *)v14 = v2;
    v6 = v14 + 2;
    while (v4 != v7)
    {
      v16 = *--v4;
      *((_WORD *)v14 - 1) = v16;
      v14 -= 2;
    }
    *(_QWORD *)v3 = v14;
    *(_QWORD *)(v3 + 8) = v6;
    *(_QWORD *)(v3 + 16) = v15;
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v4 = v2;
    v6 = v4 + 1;
  }
  *(_QWORD *)(v3 + 8) = v6;
}

__n128 std::vector<unsigned short>::__move_assign(uint64_t a1, __n128 *a2)
{
  void *v4;
  __n128 result;

  v4 = *(void **)a1;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *a2;
  *(__n128 *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E15DFD88;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DFD88;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  __int16 v11;
  _WORD *v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  unsigned int v26;

  v4 = *a2;
  v5 = *a3;
  v6 = 1;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    v7 = **(_QWORD **)(a1 + 8);
    v8 = **(_QWORD **)(a1 + 16);
    v9 = v7 + 6;
    if (v7 + 8 <= v8)
      v10 = (v8 - (v7 + 6)) >> 1;
    else
      v10 = 0;
    if (v8 < v9)
    {
      return 0;
    }
    else
    {
      v11 = *a4;
      v12 = *(_WORD **)(a1 + 24);
      v13 = *a2;
      do
      {
        v14 = v13 - v4 + v11;
        v15 = bswap32(*(unsigned __int16 *)(v7 + 4)) >> 16;
        v16 = v9 + 2 * v15;
        if (v16 < v9 || v16 > v8)
        {
          v18 = v15 > v14 && v10 == v15;
          if (!v18)
            return 0;
        }
        else if (v15 <= v14)
        {
          return 0;
        }
        v19 = (unsigned __int16 *)(v7 + (bswap32(*(unsigned __int16 *)(v7 + 2 * v14 + 6)) >> 16));
        v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) > v8)
          return 0;
        v21 = bswap32(*v19) >> 16;
        v22 = (unint64_t)&v20[v21];
        v23 = (unint64_t)(v19 + 2) <= v8 ? (v8 - (unint64_t)v20) >> 1 : 0;
        v24 = v22 <= v8 && v22 >= (unint64_t)v20;
        if (!v24 && v23 != v21)
          return 0;
        v26 = (unsigned __int16)*v12;
        if (v26 <= v21)
          LOWORD(v26) = v21;
        *v12 = v26;
        v18 = v5 == v13++;
      }
      while (!v18);
      return 1;
    }
  }
  return v6;
}

void *std::get_temporary_buffer[abi:nn180100]<`anonymous namespace'::LookupInfo>(uint64_t a1)
{
  unint64_t v1;
  const std::nothrow_t *v2;
  void *result;
  BOOL v4;

  if (a1 < 1)
    return 0;
  if (a1 >= 0x1C71C71C71C71C7)
    v1 = 0x1C71C71C71C71C7;
  else
    v1 = a1;
  v2 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
  while (1)
  {
    result = operator new(72 * v1, v2);
    if (result)
      break;
    v4 = v1 > 1;
    v1 >>= 1;
    if (!v4)
      return 0;
  }
  return result;
}

__n128 *std::__stable_partition_impl<std::_ClassicAlgPolicy,`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_3 &,std::__wrap_iter<`anonymous namespace'::LookupInfo *>,long,std::pair<`anonymous namespace'::LookupInfo *,long>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  int v8;
  uint64_t v9;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  uint64_t v18;
  uint64_t i;
  int v20;
  __n128 v23;
  __int128 v24;
  unint64_t v25;
  int *v26;
  int v27;
  BOOL v29;
  __int128 v30;
  __int128 v31;
  int *v32;
  __n128 *v33;
  __n128 v34;
  __int128 v35;
  _OWORD *v36;
  __int128 v37;
  __int128 v38;
  __n128 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t j;
  int v43;
  BOOL v44;
  uint64_t v47[2];
  uint64_t v48;

  v6 = a1;
  if (a3 == 3)
  {
    v9 = a1 + 72;
    v8 = *(_DWORD *)(a1 + 72);
    if (v8 == 1667329140 || v8 == 1919707495 || v8 == 1919118452)
    {
      a1 = v6 + 72;
LABEL_13:
      return (__n128 *)a2;
    }
  }
  else
  {
    if (a3 == 2)
      goto LABEL_13;
    v13 = a4;
    if (a5 >= a3)
    {
      v47[0] = a4;
      v47[1] = (uint64_t)&v48;
      v23 = *(__n128 *)a1;
      v24 = *(_OWORD *)(a1 + 32);
      *(_OWORD *)(a4 + 16) = *(_OWORD *)(a1 + 16);
      *(_OWORD *)(a4 + 32) = v24;
      *(__n128 *)a4 = v23;
      *(_QWORD *)(a4 + 56) = 0;
      *(_QWORD *)(a4 + 64) = 0;
      *(_QWORD *)(a4 + 48) = 0;
      *(_OWORD *)(a4 + 48) = *(_OWORD *)(a1 + 48);
      *(_QWORD *)(a4 + 64) = *(_QWORD *)(a1 + 64);
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 64) = 0;
      v48 = 1;
      v25 = a4 + 72;
      v26 = (int *)(a1 + 72);
      if (a1 + 72 == a2)
      {
        v32 = (int *)a1;
      }
      else
      {
        do
        {
          v27 = *v26;
          v29 = *v26 == 1667329140 || v27 == 1919707495 || v27 == 1919118452;
          v30 = *(_OWORD *)v26;
          v31 = *((_OWORD *)v26 + 2);
          if (v29)
          {
            *(_OWORD *)(v6 + 16) = *((_OWORD *)v26 + 1);
            *(_OWORD *)(v6 + 32) = v31;
            *(_OWORD *)v6 = v30;
            std::vector<unsigned short>::__move_assign(v6 + 48, (__n128 *)v26 + 3);
            v6 += 72;
          }
          else
          {
            *(_OWORD *)(v25 + 16) = *((_OWORD *)v26 + 1);
            *(_OWORD *)(v25 + 32) = v31;
            *(_OWORD *)v25 = v30;
            *(_QWORD *)(v25 + 56) = 0;
            *(_QWORD *)(v25 + 64) = 0;
            *(_QWORD *)(v25 + 48) = 0;
            *(_OWORD *)(v25 + 48) = *((_OWORD *)v26 + 3);
            *(_QWORD *)(v25 + 64) = *((_QWORD *)v26 + 8);
            *((_QWORD *)v26 + 6) = 0;
            *((_QWORD *)v26 + 7) = 0;
            *((_QWORD *)v26 + 8) = 0;
            ++v48;
            v25 += 72;
          }
          v26 += 18;
        }
        while (v26 != (int *)a2);
        v32 = v26 - 18;
      }
      v34 = *(__n128 *)a2;
      v35 = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(v6 + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v6 + 32) = v35;
      *(__n128 *)v6 = v34;
      std::vector<unsigned short>::__move_assign(v6 + 48, (__n128 *)(v32 + 30));
      v9 = v6 + 72;
      if (v25 > v13)
      {
        v36 = (_OWORD *)(v6 + 72);
        do
        {
          v37 = *(_OWORD *)v13;
          v38 = *(_OWORD *)(v13 + 32);
          v36[1] = *(_OWORD *)(v13 + 16);
          v36[2] = v38;
          *v36 = v37;
          std::vector<unsigned short>::__move_assign((uint64_t)(v36 + 3), (__n128 *)(v13 + 48));
          v13 += 72;
          v36 = (_OWORD *)((char *)v36 + 72);
        }
        while (v13 < v25);
      }
    }
    else
    {
      if (a3 >= 0)
        v14 = a3;
      else
        v14 = a3 + 1;
      v15 = v14 >> 1;
      v16 = 9 * (v14 >> 1);
      v17 = (__n128 *)(a1 + 8 * v16);
      v18 = 8 * v16 - 72;
      for (i = v15; ; --i)
      {
        v20 = *(_DWORD *)(a1 + v18);
        if (v20 == 1667329140 || v20 == 1919118452 || v20 == 1919707495)
        {
          goto LABEL_47;
        }
        if (!v18)
          break;
        v18 -= 72;
      }
      v33 = (__n128 *)a1;
LABEL_47:
      v39 = (__n128 *)(a2 + 72);
      v40 = a3 - v15;
      v41 = v6 + 72 * v15;
      for (j = v41 + 72; ; j += 72)
      {
        v43 = *(_DWORD *)(j - 72);
        v44 = v43 == 1667329140 || v43 == 1919707495;
        if (!v44 && v43 != 1919118452)
          break;
        if (j == a2)
        --v40;
        v41 += 72;
      }
    }
  }
  return (__n128 *)v9;
}

__n128 std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::__wrap_iter<`anonymous namespace'::LookupInfo *> &,std::__wrap_iter<`anonymous namespace'::LookupInfo *> &>(__n128 *a1, __n128 *a2)
{
  unint64_t v3;
  __n128 v4;
  __n128 v5;
  void *v6;
  __n128 result;
  __n128 v8;
  __n128 v9;
  __n128 v10;
  __n128 v11;

  v9 = *a1;
  v10 = a1[1];
  v8 = a1[3];
  v11 = a1[2];
  v3 = a1[4].n128_u64[0];
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  v4 = *a2;
  v5 = a2[2];
  a1[1] = a2[1];
  a1[2] = v5;
  *a1 = v4;
  std::vector<unsigned short>::__move_assign((uint64_t)&a1[3], a2 + 3);
  *a2 = v9;
  a2[1] = v10;
  a2[2] = v11;
  v6 = (void *)a2[3].n128_u64[0];
  if (v6)
  {
    a2[3].n128_u64[1] = (unint64_t)v6;
    operator delete(v6);
  }
  result = v8;
  a2[3] = v8;
  a2[4].n128_u64[0] = v3;
  return result;
}

uint64_t *std::unique_ptr<`anonymous namespace'::LookupInfo,std::__destruct_n &>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  void *v7;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    v3 = (unint64_t *)a1[1];
    v4 = *v3;
    if (*v3)
    {
      v5 = 0;
      v6 = (_QWORD *)(v2 + 56);
      do
      {
        v7 = (void *)*(v6 - 1);
        if (v7)
        {
          *v6 = v7;
          operator delete(v7);
          v4 = *v3;
        }
        ++v5;
        v6 += 9;
      }
      while (v5 < v4);
    }
  }
  return a1;
}

__n128 *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<`anonymous namespace'::LookupInfo *>,std::__wrap_iter<`anonymous namespace'::LookupInfo *>>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  __n128 *v3;
  __n128 *v4;
  __n128 *v5;
  __n128 *i;
  __n128 *v7;
  __n128 *v8;

  v3 = a3;
  if (a1 != a2)
  {
    v4 = a2;
    v5 = a1;
    if (a2 != a3)
    {
      v5 = (__n128 *)((char *)v5 + 72);
      for (i = (__n128 *)((char *)v4 + 72); i != v3; i = (__n128 *)((char *)i + 72))
      {
        if (v5 == v4)
          v4 = i;
        v5 = (__n128 *)((char *)v5 + 72);
      }
      if (v5 != v4)
      {
        v7 = v5;
        v8 = v4;
        do
        {
          while (1)
          {
            v7 = (__n128 *)((char *)v7 + 72);
            v4 = (__n128 *)((char *)v4 + 72);
            if (v4 == v3)
              break;
            if (v7 == v8)
              v8 = v4;
          }
          v4 = v8;
        }
        while (v7 != v8);
      }
    }
    return v5;
  }
  return v3;
}

__n128 *std::__stable_partition_impl<std::_ClassicAlgPolicy,`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_6 &,std::__wrap_iter<`anonymous namespace'::LookupInfo *>,long,std::pair<`anonymous namespace'::LookupInfo *,long>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v8;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __n128 *v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v16;
  __int128 v17;
  unint64_t v18;
  __int128 *v19;
  __n128 *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  __n128 *v27;
  __n128 v28;
  __int128 v29;
  _OWORD *v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  __n128 *v34;
  __n128 *v35;
  unsigned __int32 *v36;
  unsigned __int32 v37;
  uint64_t v39[2];
  uint64_t v40;

  v6 = a1;
  if (a3 == 3)
  {
    v8 = a1 + 72;
    if (*(_DWORD *)(a1 + 72) != 1919707495)
    {
      return (__n128 *)v8;
    }
    a1 = v6 + 72;
    goto LABEL_6;
  }
  if (a3 == 2)
  {
LABEL_6:
    return (__n128 *)a2;
  }
  v10 = a4;
  if (a5 >= a3)
  {
    v39[0] = a4;
    v39[1] = (uint64_t)&v40;
    v16 = *(__n128 *)a1;
    v17 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(a4 + 16) = *(_OWORD *)(a1 + 16);
    *(_OWORD *)(a4 + 32) = v17;
    *(__n128 *)a4 = v16;
    *(_QWORD *)(a4 + 56) = 0;
    *(_QWORD *)(a4 + 64) = 0;
    *(_QWORD *)(a4 + 48) = 0;
    *(_OWORD *)(a4 + 48) = *(_OWORD *)(a1 + 48);
    *(_QWORD *)(a4 + 64) = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    v40 = 1;
    v18 = a4 + 72;
    v19 = (__int128 *)(a1 + 72);
    if (a1 + 72 == a2)
    {
      v23 = a1;
    }
    else
    {
      do
      {
        v20 = (__n128 *)(v19 + 3);
        v21 = *v19;
        v22 = v19[2];
        if (*(_DWORD *)v19 == 1919707495)
        {
          *(_OWORD *)(v6 + 16) = v19[1];
          *(_OWORD *)(v6 + 32) = v22;
          *(_OWORD *)v6 = v21;
          std::vector<unsigned short>::__move_assign(v6 + 48, v20);
          v6 += 72;
        }
        else
        {
          *(_OWORD *)(v18 + 16) = v19[1];
          *(_OWORD *)(v18 + 32) = v22;
          *(_OWORD *)v18 = v21;
          *(_QWORD *)(v18 + 56) = 0;
          *(_QWORD *)(v18 + 64) = 0;
          *(_QWORD *)(v18 + 48) = 0;
          *(_OWORD *)(v18 + 48) = v19[3];
          *(_QWORD *)(v18 + 64) = *((_QWORD *)v19 + 8);
          v20->n128_u64[0] = 0;
          *((_QWORD *)v19 + 7) = 0;
          *((_QWORD *)v19 + 8) = 0;
          ++v40;
          v18 += 72;
        }
        v19 = (__int128 *)((char *)v19 + 72);
      }
      while (v19 != (__int128 *)a2);
      v23 = (uint64_t)v19 - 72;
    }
    v28 = *(__n128 *)a2;
    v29 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(v6 + 16) = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v6 + 32) = v29;
    *(__n128 *)v6 = v28;
    std::vector<unsigned short>::__move_assign(v6 + 48, (__n128 *)(v23 + 120));
    v8 = v6 + 72;
    if (v18 > v10)
    {
      v30 = (_OWORD *)(v6 + 72);
      do
      {
        v31 = *(_OWORD *)v10;
        v32 = *(_OWORD *)(v10 + 32);
        v30[1] = *(_OWORD *)(v10 + 16);
        v30[2] = v32;
        *v30 = v31;
        std::vector<unsigned short>::__move_assign((uint64_t)(v30 + 3), (__n128 *)(v10 + 48));
        v10 += 72;
        v30 = (_OWORD *)((char *)v30 + 72);
      }
      while (v10 < v18);
    }
  }
  else
  {
    if (a3 >= 0)
      v11 = a3;
    else
      v11 = a3 + 1;
    v12 = v11 >> 1;
    v13 = (__n128 *)(a1 + 72 * (v11 >> 1));
    v14 = (uint64_t)&v13[-5].n128_i64[1];
    if (v13[-5].n128_u32[2] == 1919707495)
    {
      v15 = v11 >> 1;
LABEL_24:
    }
    else
    {
      v24 = 72 * v12;
      v15 = v12;
      while (1)
      {
        v25 = v24 - 72;
        if (v24 == 72)
          break;
        --v15;
        v26 = *(_DWORD *)(a1 + v24 - 144);
        v24 -= 72;
        if (v26 == 1919707495)
        {
          v14 = a1 + v25 - 72;
          goto LABEL_24;
        }
      }
      v27 = (__n128 *)a1;
    }
    v33 = a3 - v12;
    if (v13->n128_u32[0] == 1919707495)
    {
      v34 = (__n128 *)(a2 + 72);
      v35 = (__n128 *)(v6 + 72 * v12);
      v36 = &v35[4].n128_u32[2];
      while (v36 != (unsigned __int32 *)a2)
      {
        --v33;
        v37 = *v36;
        v36 += 18;
        v35 = (__n128 *)((char *)v35 + 72);
        if (v37 != 1919707495)
          goto LABEL_37;
      }
    }
    else
    {
      v35 = v13;
LABEL_37:
    }
  }
  return (__n128 *)v8;
}

char *TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  char *v2;
  char *result;
  char *v4;

  v2 = (char *)(a1 + 360);
  result = *(char **)(a1 + 360);
  v4 = &result[12 * a2];
  if (v4 <= v2)
  {
    *(_QWORD *)v2 = v4;
  }
  else
  {
    if (a2 >= 0x1555555555555556)
      std::__throw_bad_array_new_length[abi:nn180100]();
    return (char *)operator new(12 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  _QWORD *v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != *(_QWORD *)(a1 + 8))
    *(_QWORD *)(a1 + 16) = (v2 - *(_QWORD *)(a1 + 8) - 12) % 0xCuLL + *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = (_QWORD *)(v4 + 360);
    if (v4 <= (unint64_t)v3 && v5 > v3)
    {
      if (*(_QWORD *)(a1 + 24) == *v5)
        *v5 = v3;
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

void `anonymous namespace'::MorxSubtableBuilder::From(_anonymous_namespace_::MorxSubtableBuilder *this, unint64_t a2, int a3, int a4)
{
  unint64_t *v6;
  unint64_t v7;
  void *v8;
  __CFData *v9;
  CFIndex v10;
  id Mutable;

  *(_DWORD *)this = a3;
  *((_DWORD *)this + 1) = a4;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v6 = (unint64_t *)((char *)this + 8);
  do
    v7 = __ldaxr((unint64_t *)&Mutable);
  while (__stlxr(0, (unint64_t *)&Mutable));
  do
    v8 = (void *)__ldaxr(v6);
  while (__stlxr(v7, v6));

  v9 = (__CFData *)atomic_load(v6);
  if (a2 <= 0x10000)
    v10 = (a2 + 7) >> 3;
  else
    v10 = 0x2000;
  CFDataSetLength(v9, v10);
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E15DFE60;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E15DFE60;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x20uLL);
  *v2 = &off_1E15DFE60;
  std::vector<unsigned short>::vector(v2 + 1, v1);
  return v2;
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E15DFE60;
  return std::vector<unsigned short>::vector(a2 + 1, a1 + 8);
}

void std::__function::__func<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::destroy(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void std::__function::__func<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::destroy_deallocate(_QWORD *__p)
{
  void *v2;

  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

BOOL std::__function::__func<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<`anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned int v9;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *(unsigned __int16 **)(a1 + 16);
  if (v3 == v2)
    return 1;
  v4 = *a2;
  v5 = v3 - v2;
  do
  {
    v6 = v5 >> 1;
    v7 = &v2[v5 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v5 += ~(v5 >> 1);
    if (v9 < v4)
      v2 = v8;
    else
      v5 = v6;
  }
  while (v5);
  return v2 == v3 || *v2 > v4;
}

uint64_t std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;

  }
  v4 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = (_QWORD *)(v5 + 240);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(_QWORD *)(a1 + 24) == *v6)
        *v6 = v4;
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void `anonymous namespace'::MorxSubtableBuilder::CreateSubtableDataInternal(_anonymous_namespace_::MorxSubtableBuilder *this, unsigned int *a2, int a3)
{
  unsigned int v5;
  __CFData *Mutable;
  UInt8 bytes[4];
  UInt8 v8[4];
  UInt8 v9[4];

  v5 = a3 + 12;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (a3 + 12));
  *(_DWORD *)bytes = bswap32(v5);
  CFDataAppendBytes(Mutable, bytes, 4);
  *(_DWORD *)v8 = bswap32(*a2);
  CFDataAppendBytes(Mutable, v8, 4);
  *(_DWORD *)v9 = bswap32(a2[1]);
  CFDataAppendBytes(Mutable, v9, 4);
  *(_QWORD *)this = Mutable;
}

void std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15DFB00;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15DFB00;
  a2[1] = v2;
  return result;
}

void std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(`anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4;
  unsigned int v5;
  __int16 v7;
  _QWORD *v9;
  char *v10;
  char *v11;
  _QWORD v12[2];
  unint64_t v13;
  _OWORD v14[2];
  _QWORD *v15;

  v4 = *a2;
  v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    v7 = *a4;
    do
    {
      v13 = 0xAAAAAAAAAAAAAAAALL;
      v12[0] = 0xAAAAAAAAAAAAAAAALL;
      v15 = v12;
      v12[1] = (char *)v12 + 2;
      LOWORD(v12[0]) = v4;
      v9 = v12;
      v10 = (char *)v12 + 2;
      v11 = (char *)v12 + 2;
      memset(v14, 0, sizeof(v14));
      std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)v14);
      v10 = (char *)v12 + 2;
      LOWORD(v13) = v7;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v9);
    }
    while (v5 != (unsigned __int16)v4++);
  }
}

void std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E15DFA70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DFA70;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<`anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t result;
  unsigned __int16 v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v16;
  BOOL v17;
  _WORD *v18;
  unsigned __int16 *v19;
  uint64_t v20;
  unsigned __int16 *v21;
  unint64_t v22;
  BOOL v23;
  _BYTE *v25;
  uint64_t v26;
  unsigned int v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  _BYTE *v35;
  char *v36;
  __int16 v37;
  _BYTE *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  _BYTE *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  char *v49;
  _BYTE *v50;
  char *v51;
  __int16 v52;
  _BYTE *v53;
  uint64_t v54;
  char **v55;
  unint64_t v56;
  unsigned __int16 *v57;
  char *v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  char *v63;
  unint64_t v64;
  char *v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  char *v73;
  char **v74;
  char *v75;
  unsigned int v76;
  unsigned __int16 v77;
  uint64_t v78;
  __int16 v79;
  __int128 v80;
  __int128 v81;
  _QWORD v82[2];
  unint64_t v83;
  _BYTE *v84;
  _BYTE *v85;
  _BYTE *v86;
  uint64_t v87;
  _QWORD *v88;

  v5 = *a2;
  v6 = *a3;
  result = 1;
  if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
  {
    v79 = *a4;
    v8 = *a2;
    v78 = a1;
    v76 = *a3;
    v77 = *a2;
    while (1)
    {
      v9 = **(_QWORD **)(a1 + 8);
      v10 = **(_QWORD **)(a1 + 16);
      v11 = v9 + 6;
      if (v9 + 6 > v10)
        return 0;
      v12 = v8 - v5 + v79;
      v13 = bswap32(*(unsigned __int16 *)(v9 + 4)) >> 16;
      v14 = v11 + 2 * v13;
      if (v14 < v11 || v14 > v10)
      {
        v16 = (v10 - v11) >> 1;
        if (v9 + 8 > v10)
          v16 = 0;
        v17 = v13 > v12 && v16 == v13;
        if (!v17)
          return 0;
      }
      else if (v13 <= v12)
      {
        return 0;
      }
      v18 = (_WORD *)(v9 + (bswap32(*(unsigned __int16 *)(v9 + 2 * v12 + 6)) >> 16));
      v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) > v10)
        return 0;
      v20 = __rev16((unsigned __int16)*v18);
      v21 = &v19[v20];
      v22 = (unint64_t)(v18 + 2) <= v10 ? (v10 - (unint64_t)v19) >> 1 : 0;
      v23 = (unint64_t)v21 <= v10 && v21 >= v19;
      if (!v23 && v22 != v20)
        return 0;
      if (*v18)
        break;
LABEL_107:
      v17 = v6 == v8++;
      if (v17)
        return 1;
    }
    v82[0] = 0xAAAAAAAAAAAAAAAALL;
    v82[1] = v82;
    v83 = 0xAAAAAAAAAAAAAAAALL;
    v80 = 0xAAAAAAAAAAAAAAAALL;
    v81 = 0uLL;
    if (**(_BYTE **)(a1 + 24))
    {
      LOWORD(v83) = bswap32(*v19) >> 16;
      v25 = 0;
      v26 = (v20 - 1);
      if ((_DWORD)v20 != 1)
      {
        do
        {
          v27 = bswap32((unsigned __int16)v18[v26 + 1]) >> 16;
          if ((unint64_t)v25 >= *((_QWORD *)&v81 + 1))
          {
            v28 = (_BYTE *)*((_QWORD *)&v80 + 1);
            v29 = (uint64_t)&v25[-*((_QWORD *)&v80 + 1)];
            if ((uint64_t)&v25[-*((_QWORD *)&v80 + 1)] <= -3)
              goto LABEL_112;
            v30 = v29 >> 1;
            if (*((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1) <= (unint64_t)((v29 >> 1) + 1))
              v31 = v30 + 1;
            else
              v31 = *((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1);
            if (*((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1) >= 0x7FFFFFFFFFFFFFFEuLL)
              v32 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v32 = v31;
            v88 = v82;
            if (v32)
            {
              v33 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v82, v32);
              v28 = (_BYTE *)*((_QWORD *)&v80 + 1);
              v25 = (_BYTE *)v81;
            }
            else
            {
              v33 = 0;
            }
            v34 = &v33[2 * v30];
            *(_WORD *)v34 = v27;
            if (v25 == v28)
            {
              v36 = &v33[2 * v30];
            }
            else
            {
              v35 = v25;
              v36 = &v33[2 * v30];
              do
              {
                v37 = *((_WORD *)v35 - 1);
                v35 -= 2;
                *((_WORD *)v36 - 1) = v37;
                v36 -= 2;
              }
              while (v35 != v28);
            }
            v38 = v34 + 2;
            *((_QWORD *)&v80 + 1) = v36;
            *(_QWORD *)&v81 = v34 + 2;
            v39 = *((_QWORD *)&v81 + 1);
            *((_QWORD *)&v81 + 1) = &v33[2 * v32];
            v86 = v25;
            v87 = v39;
            v84 = v28;
            v85 = v28;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v84);
            v25 = v38;
          }
          else
          {
            *(_WORD *)v25 = v27;
            v25 += 2;
          }
          *(_QWORD *)&v81 = v25;
          --v26;
        }
        while ((_DWORD)v26);
      }
    }
    else
    {
      v40 = (v20 - 1);
      if ((_DWORD)v20 == 1)
      {
        v40 = 0;
        v25 = 0;
      }
      else
      {
        v25 = 0;
        v41 = 0;
        do
        {
          v42 = bswap32((unsigned __int16)v18[v41 + 1]) >> 16;
          if ((unint64_t)v25 >= *((_QWORD *)&v81 + 1))
          {
            v43 = (_BYTE *)*((_QWORD *)&v80 + 1);
            v44 = (uint64_t)&v25[-*((_QWORD *)&v80 + 1)];
            if ((uint64_t)&v25[-*((_QWORD *)&v80 + 1)] <= -3)
              goto LABEL_112;
            v45 = v44 >> 1;
            if (*((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1) <= (unint64_t)((v44 >> 1) + 1))
              v46 = v45 + 1;
            else
              v46 = *((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1);
            if (*((_QWORD *)&v81 + 1) - *((_QWORD *)&v80 + 1) >= 0x7FFFFFFFFFFFFFFEuLL)
              v47 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v47 = v46;
            v88 = v82;
            if (v47)
            {
              v48 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v82, v47);
              v43 = (_BYTE *)*((_QWORD *)&v80 + 1);
              v25 = (_BYTE *)v81;
            }
            else
            {
              v48 = 0;
            }
            v49 = &v48[2 * v45];
            *(_WORD *)v49 = v42;
            if (v25 == v43)
            {
              v51 = &v48[2 * v45];
            }
            else
            {
              v50 = v25;
              v51 = &v48[2 * v45];
              do
              {
                v52 = *((_WORD *)v50 - 1);
                v50 -= 2;
                *((_WORD *)v51 - 1) = v52;
                v51 -= 2;
              }
              while (v50 != v43);
            }
            v53 = v49 + 2;
            *((_QWORD *)&v80 + 1) = v51;
            *(_QWORD *)&v81 = v49 + 2;
            v54 = *((_QWORD *)&v81 + 1);
            *((_QWORD *)&v81 + 1) = &v48[2 * v47];
            v86 = v25;
            v87 = v54;
            v84 = v43;
            v85 = v43;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v84);
            v25 = v53;
          }
          else
          {
            *(_WORD *)v25 = v42;
            v25 += 2;
          }
          *(_QWORD *)&v81 = v25;
          ++v41;
        }
        while (v41 != v40);
      }
      LOWORD(v83) = bswap32((unsigned __int16)v18[v40 + 1]) >> 16;
    }
    a1 = v78;
    v55 = *(char ***)(v78 + 32);
    v57 = (unsigned __int16 *)v55[1];
    v56 = (unint64_t)v55[2];
    if ((unint64_t)v57 < v56)
    {
      *v57 = v8;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v57 + 4), *((_BYTE **)&v80 + 1), v25);
      v57[24] = v83;
      v58 = (char *)(v57 + 28);
      v6 = v76;
      LOWORD(v5) = v77;
LABEL_106:
      v55[1] = v58;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v80 + 8);
      goto LABEL_107;
    }
    v59 = 0x6DB6DB6DB6DB6DB7 * (((char *)v57 - *v55) >> 3);
    v60 = v59 + 1;
    if ((unint64_t)(v59 + 1) > 0x492492492492492)
LABEL_112:
      abort();
    v61 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v56 - (_QWORD)*v55) >> 3);
    if (2 * v61 > v60)
      v60 = 2 * v61;
    if (v61 >= 0x249249249249249)
      v62 = 0x492492492492492;
    else
      v62 = v60;
    if (v62)
    {
      v63 = v55[213];
      v64 = (unint64_t)&v63[56 * v62];
      if (v64 <= (unint64_t)(v55 + 213))
      {
        v55[213] = (char *)v64;
      }
      else
      {
        if (v62 > 0x492492492492492)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v63 = (char *)operator new(56 * v62);
      }
    }
    else
    {
      v63 = 0;
    }
    v65 = &v63[56 * v59];
    v66 = &v63[56 * v62];
    *(_WORD *)v65 = v8;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v65 + 8), *((_BYTE **)&v80 + 1), v25);
    *((_WORD *)v65 + 24) = v83;
    v58 = v65 + 56;
    v68 = *v55;
    v67 = v55[1];
    if (v67 == *v55)
    {
      *v55 = v65;
      v55[1] = v58;
      v72 = v55[2];
      v55[2] = v66;
    }
    else
    {
      v75 = v65 + 56;
      v69 = 0;
      do
      {
        *(_WORD *)&v65[v69 - 56] = *(_WORD *)&v67[v69 - 56];
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v65[v69 - 48], *(_BYTE **)&v67[v69 - 48], *(_BYTE **)&v67[v69 - 40]);
        *(_WORD *)&v65[v69 - 8] = *(_WORD *)&v67[v69 - 8];
        v69 -= 56;
      }
      while (&v67[v69] != v68);
      v67 = *v55;
      v70 = v55[1];
      v71 = &v65[v69];
      v58 = v65 + 56;
      *v55 = v71;
      v55[1] = v75;
      v72 = v55[2];
      v55[2] = v66;
      if (v70 != v67)
      {
        a1 = v78;
        v6 = v76;
        LOWORD(v5) = v77;
        do
        {
          v73 = v70 - 56;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v70 - 48));
          v70 = v73;
        }
        while (v73 != v67);
        v58 = v75;
        if (!v67)
          goto LABEL_106;
        goto LABEL_101;
      }
    }
    a1 = v78;
    v6 = v76;
    LOWORD(v5) = v77;
    if (!v67)
      goto LABEL_106;
LABEL_101:
    if (v55 + 3 > (char **)v67 || (v74 = v55 + 213, v55 + 213 <= (char **)v67))
    {
      operator delete(v67);
    }
    else if (v72 == *v74)
    {
      *v74 = v67;
    }
    goto LABEL_106;
  }
  return result;
}

void *TInlineBufferAllocator<unsigned short,3ul>::allocate(uint64_t a1, uint64_t a2)
{
  void *result;
  unint64_t v4;

  result = *(void **)(a1 + 8);
  v4 = (unint64_t)result + 2 * a2;
  if (v4 <= a1 + 6)
  {
    *(_QWORD *)(a1 + 8) = v4;
  }
  else
  {
    if (a2 < 0)
      std::__throw_bad_array_new_length[abi:nn180100]();
    return operator new(2 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 1) & 0xFFFFFFFFFFFFFFFELL);
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (v5 <= (unint64_t)v4 && v5 + 6 > (unint64_t)v4)
    {
      if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(v5 + 8))
        *(_QWORD *)(v5 + 8) = v4;
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  int64_t v4;
  uint64_t v7;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 32) = a1 + 24;
  v4 = a3 - a2;
  if (a3 != a2)
  {
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__vallocate[abi:nn180100]((_QWORD *)a1, v4 >> 1);
    v7 = *(_QWORD *)(a1 + 8);
    if (a3 != a2)
      memmove(*(void **)(a1 + 8), a2, v4);
    *(_QWORD *)(a1 + 8) = v7 + 2 * (v4 >> 1);
  }
  return a1;
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__vallocate[abi:nn180100](_QWORD *a1, uint64_t a2)
{
  char *result;

  if (a2 < 0)
    abort();
  result = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * a2];
  return result;
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  void *v2;
  void *v3;
  BOOL v4;
  BOOL v5;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    v3 = (void *)(a1 + 30);
    if (a1 + 24 <= (unint64_t)v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 32))
        *(_QWORD *)(a1 + 32) = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

BOOL `anonymous namespace'::MorxInsertionSubtableBuilder::StateNeedsAction(_anonymous_namespace_::MorxInsertionSubtableBuilder *this, int a2, int a3)
{
  uint64_t v4;

  v4 = 0;
}

BOOL `anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::ProcessMorxEntryTableForState(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned __int16 v9;
  unsigned int v10;

  v4 = (a3 + *(_DWORD *)(a1 + 24) * a2);
  v5 = *(_QWORD *)(a1 + 40);
  if (v4 >= (*(_QWORD *)(a1 + 48) - v5) >> 1)
    return 0;
  v6 = *(unsigned __int16 *)(v5 + 2 * v4);
  v7 = *(_QWORD *)(a1 + 136);
  if (v6 >= (*(_QWORD *)(a1 + 144) - v7) >> 3)
    return 0;
  v8 = (unsigned __int16 *)(v7 + 8 * v6);
  *a4 = v8;
  v9 = v8[1];
  v10 = bswap32(*v8) >> 16;
  return (v9 & 0xE0) != 0 || v10 > 1;
}

uint64_t GetActionIndex(unint64_t **a1, unsigned int a2, unsigned int a3, unsigned __int16 a4, uint64_t a5)
{
  unint64_t *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  unsigned __int16 *v15;
  unint64_t v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  unint64_t *v22;
  char *v23;
  unint64_t *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t **v28;

  v10 = *a1;
  v11 = a1[1];
  v12 = v11 - *a1;
  if (v11 == *a1)
  {
LABEL_11:
    v16 = (unint64_t)a1[2];
    if ((unint64_t)v11 >= v16)
    {
      if ((v12 + 1) >> 61)
        abort();
      v18 = v16 - (_QWORD)v10;
      v19 = v18 >> 2;
      if (v18 >> 2 <= v12 + 1)
        v19 = v12 + 1;
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v19;
      if (v20)
        v21 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(a1 + 3), v20);
      else
        v21 = 0;
      v22 = (unint64_t *)&v21[8 * v12];
      v23 = &v21[8 * v20];
      *v22 = ((unint64_t)a4 << 32) | (a5 << 48) | ((unint64_t)a3 << 16) | a2;
      v17 = v22 + 1;
      v25 = *a1;
      v24 = a1[1];
      if (v24 != *a1)
      {
        do
        {
          v26 = *--v24;
          *--v22 = v26;
        }
        while (v24 != v25);
        v24 = *a1;
      }
      *a1 = v22;
      a1[1] = v17;
      v27 = a1[2];
      a1[2] = (unint64_t *)v23;
      if (v24)
      {
        v28 = a1 + 33;
        if (a1 + 3 <= (unint64_t **)v24 && v28 > (unint64_t **)v24)
        {
          if (v27 == *v28)
            *v28 = v24;
        }
        else
        {
          operator delete(v24);
        }
      }
    }
    else
    {
      *v11 = ((unint64_t)a4 << 32) | (a5 << 48) | ((unint64_t)a3 << 16) | a2;
      v17 = v11 + 1;
    }
    a1[1] = v17;
    return v17 - *a1 - 1;
  }
  else
  {
    result = 0;
    if (v12 <= 1)
      v14 = 1;
    else
      v14 = v12;
    v15 = (unsigned __int16 *)v10 + 2;
    while (*(v15 - 2) != a2 || *(v15 - 1) != a3 || *v15 != a4 || v15[1] != (unsigned __int16)a5)
    {
      ++result;
      v15 += 4;
      if (v14 == result)
        goto LABEL_11;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>(uint64_t result, _WORD *a2, char **a3)
{
  _WORD *v5;
  uint64_t v6;
  char *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int16 v19;
  char *v20;
  char *v21;
  _QWORD v22[5];

  if ((_WORD *)result != a2)
  {
    v5 = (_WORD *)result;
    v6 = (uint64_t)(a3 + 3);
    v7 = a3[1];
    do
    {
      v8 = (unint64_t)a3[2];
      if ((unint64_t)v7 >= v8)
      {
        v9 = *a3;
        v10 = v7 - *a3;
        if (v10 <= -3)
          abort();
        v11 = v10 >> 1;
        v12 = v8 - (_QWORD)v9;
        if (v12 <= (v10 >> 1) + 1)
          v13 = v11 + 1;
        else
          v13 = v12;
        if (v12 >= 0x7FFFFFFFFFFFFFFELL)
          v14 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        v22[4] = v6;
        if (v14)
        {
          v15 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v6, v14);
          v9 = *a3;
          v7 = a3[1];
        }
        else
        {
          v15 = 0;
        }
        v16 = &v15[2 * v11];
        *(_WORD *)v16 = *v5;
        if (v7 == v9)
        {
          v18 = &v15[2 * v11];
        }
        else
        {
          v17 = v7;
          v18 = &v15[2 * v11];
          do
          {
            v19 = *((_WORD *)v17 - 1);
            v17 -= 2;
            *((_WORD *)v18 - 1) = v19;
            v18 -= 2;
          }
          while (v17 != v9);
        }
        v20 = v16 + 2;
        *a3 = v18;
        v22[0] = v9;
        v22[1] = v9;
        a3[1] = v16 + 2;
        v22[2] = v7;
        v21 = a3[2];
        a3[2] = &v15[2 * v14];
        v22[3] = v21;
        result = std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v22);
        v7 = v20;
      }
      else
      {
        *(_WORD *)v7 = *v5;
        v7 += 2;
      }
      a3[1] = v7;
      ++v5;
    }
    while (v5 != a2);
  }
  return result;
}

void `anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::CreateSubtableDataInternal(_anonymous_namespace_::MorxSubtableBuilder *a1, uint64_t a2, unsigned int a3)
{
  const __CFData *v6;
  CFIndex Length;
  CFIndex v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  __CFData *v12;
  __CFData *v13;
  __CFData *v14;
  __CFData *v15;
  UInt8 bytes[4];

  v6 = (const __CFData *)atomic_load((unint64_t *)(a2 + 32));
  Length = CFDataGetLength(v6);
  v8 = Length + 20;
  if ((unint64_t)(Length + 20) >= 0xFFFFFFFF
    || (v9 = *(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40), v10 = v9 + v8, (unint64_t)(v9 + v8) >= 0xFFFFFFFF)
    || (v11 = Length + a3 + v9 + *(_QWORD *)(a2 + 144) - *(_QWORD *)(a2 + 136) + 20, v11 >= 0xFFFFFFFF))
  {
    *(_QWORD *)a1 = 0;
  }
  else
  {
    *(_QWORD *)a1 = 0xAAAAAAAAAAAAAAAALL;
    v12 = (__CFData *)atomic_load((unint64_t *)a1);
    *(_DWORD *)bytes = bswap32(*(_DWORD *)(a2 + 24));
    CFDataAppendBytes(v12, bytes, 4);
    v13 = (__CFData *)atomic_load((unint64_t *)a1);
    *(_DWORD *)bytes = 335544320;
    CFDataAppendBytes(v13, bytes, 4);
    v14 = (__CFData *)atomic_load((unint64_t *)a1);
    *(_DWORD *)bytes = bswap32(v8);
    CFDataAppendBytes(v14, bytes, 4);
    v15 = (__CFData *)atomic_load((unint64_t *)a1);
    *(_DWORD *)bytes = bswap32(v10);
    CFDataAppendBytes(v15, bytes, 4);
  }
}

void `anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::AppendStateTablePieces(unint64_t *a1, _anonymous_namespace_ *this, const __CFData *a3)
{
  const __CFData *v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  UInt8 bytes[2];
  UInt8 v12[2];
  UInt8 v13[2];
  UInt8 v14[2];
  UInt8 v15[2];

  v5 = (const __CFData *)atomic_load(a1 + 4);
  v6 = (unsigned __int16 *)a1[5];
  v7 = (unsigned __int16 *)a1[6];
  while (v6 != v7)
  {
    v8 = *v6++;
    *(_WORD *)bytes = bswap32(v8) >> 16;
    CFDataAppendBytes(this, bytes, 2);
  }
  v10 = (unsigned __int16 *)a1[17];
  v9 = (unsigned __int16 *)a1[18];
  while (v10 != v9)
  {
    *(_WORD *)v12 = bswap32(*v10) >> 16;
    CFDataAppendBytes(this, v12, 2);
    *(_WORD *)v13 = bswap32(v10[1]) >> 16;
    CFDataAppendBytes(this, v13, 2);
    *(_WORD *)v14 = bswap32(v10[2]) >> 16;
    CFDataAppendBytes(this, v14, 2);
    *(_WORD *)v15 = bswap32(v10[3]) >> 16;
    CFDataAppendBytes(this, v15, 2);
    v10 += 4;
  }
}

uint64_t `anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::~MorxStateTableSubtableBuilder(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  BOOL v4;
  BOOL v5;
  void **v7;

  *(_QWORD *)a1 = off_1E15DECC8;
  v2 = *(_QWORD **)(a1 + 136);
  if (v2)
  {
    *(_QWORD *)(a1 + 144) = v2;
    v3 = (_QWORD *)(a1 + 400);
    if (a1 + 160 <= (unint64_t)v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(_QWORD *)(a1 + 152) == *(_QWORD *)(a1 + 400))
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
  v7 = (void **)(a1 + 40);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v7);

  return a1;
}

uint64_t std::__split_buffer<`anonymous namespace'::LigInput,TInlineBufferAllocator<`anonymous namespace'::LigInput,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 48;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](i - 48);
  }
  v4 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = (_QWORD *)(v5 + 1440);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(_QWORD *)(a1 + 24) == *v6)
        *v6 = v4;
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

char *std::__allocate_at_least[abi:nn180100]<TInlineBufferAllocator<`anonymous namespace'::LigInput,30ul>>(uint64_t a1, unint64_t a2)
{
  char *v2;
  char *result;
  char *v4;

  v2 = (char *)(a1 + 1440);
  result = *(char **)(a1 + 1440);
  v4 = &result[48 * a2];
  if (v4 <= v2)
  {
    *(_QWORD *)v2 = v4;
  }
  else
  {
    if (a2 >= 0x555555555555556)
      std::__throw_bad_array_new_length[abi:nn180100]();
    return (char *)operator new(48 * a2);
  }
  return result;
}

void std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E15DF950;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DF950;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<`anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(_QWORD **a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t result;
  __int16 v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v16;
  BOOL v17;
  _WORD *v18;
  _WORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v31;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  unint64_t v35;
  unsigned __int16 *v36;
  unint64_t v37;
  BOOL v38;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  __int16 v51;
  char *v52;
  unsigned __int16 *v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  char *v63;
  __int16 v64;
  char *v65;
  char *v66;
  __int16 v67;
  int v68;
  unsigned __int16 v69;
  _WORD *v70;
  _WORD *v71;
  uint64_t v72;
  unsigned __int16 v73;
  char *v74;
  char *v75;
  char *v76;
  _QWORD v77[2];
  unint64_t v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  _QWORD *v83;

  v5 = *a2;
  v6 = *a3;
  result = 1;
  if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
  {
    v8 = *a4;
    v73 = *a2;
    v68 = *a3;
    v69 = *a2;
    v67 = *a4;
    while (1)
    {
      v9 = *a1[1];
      v10 = *a1[2];
      v11 = v9 + 6;
      if (v9 + 6 > v10)
        return 0;
      v12 = v73 - v5 + v8;
      v13 = bswap32(*(unsigned __int16 *)(v9 + 4)) >> 16;
      v14 = v11 + 2 * v13;
      if (v14 < v11 || v14 > v10)
      {
        v16 = (v10 - v11) >> 1;
        if (v9 + 8 > v10)
          v16 = 0;
        v17 = v13 > v12 && v16 == v13;
        if (!v17)
          return 0;
      }
      else if (v13 <= v12)
      {
        return 0;
      }
      v18 = (_WORD *)(v9 + (bswap32(*(unsigned __int16 *)(v9 + 2 * v12 + 6)) >> 16));
      v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) > v10)
        return 0;
      v20 = __rev16((unsigned __int16)*v18);
      v21 = (unint64_t)&v19[v20];
      v22 = (v10 - (unint64_t)v19) >> 1;
      v70 = v18 + 2;
      if ((unint64_t)(v18 + 2) > v10)
        v22 = 0;
      v23 = v21 <= v10 && v21 >= (unint64_t)v19;
      if (!v23 && v22 != v20)
        return 0;
      if (*v18)
      {
        v25 = 0;
        if (v20 <= 1)
          v26 = 1;
        else
          v26 = v20;
        v72 = v26;
        v71 = v18;
        do
        {
          v27 = *a1[2];
          if ((unint64_t)v19 > v27)
            return 0;
          v28 = bswap32((unsigned __int16)*v18) >> 16;
          v29 = (unint64_t)&v19[v28];
          if (v29 < (unint64_t)v19 || v29 > v27)
          {
            v31 = (v27 - (unint64_t)v19) >> 1;
            if ((unint64_t)v70 > v27)
              v31 = 0;
            if (v31 != v28 || v25 >= v28)
              return 0;
          }
          else if (v25 >= v28)
          {
            return 0;
          }
          v33 = (_WORD *)((char *)v18 + (bswap32((unsigned __int16)v18[v25 + 1]) >> 16));
          v34 = v33 + 2;
          if ((unint64_t)(v33 + 2) > v27)
            return 0;
          v35 = __rev16(v33[1]);
          v36 = &v34[v35 - 1];
          v37 = (unint64_t)(v33 + 3) <= v27 ? (v27 - (unint64_t)v34) >> 1 : 0;
          v38 = (unint64_t)v36 <= v27 && v36 >= v34;
          if (!v38 && v37 != v35 - 1)
            return 0;
          if (v33[1])
          {
            v78 = 0xAAAAAAAAAAAAAAAALL;
            v77[0] = 0xAAAAAAAAAAAAAAAALL;
            v74 = 0;
            v75 = 0;
            v76 = 0;
            v77[1] = v77;
            LOWORD(v78) = bswap32(*v33) >> 16;
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::reserve(&v74, v35);
            v40 = v75;
            if (v75 >= v76)
            {
              v42 = v74;
              v43 = v75 - v74;
              if (v75 - v74 <= -3)
LABEL_111:
                abort();
              v44 = v43 >> 1;
              if (v76 - v74 <= (unint64_t)((v43 >> 1) + 1))
                v45 = v44 + 1;
              else
                v45 = v76 - v74;
              if ((unint64_t)(v76 - v74) >= 0x7FFFFFFFFFFFFFFELL)
                v46 = 0x7FFFFFFFFFFFFFFFLL;
              else
                v46 = v45;
              v83 = v77;
              if (v46)
              {
                v47 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v77, v46);
                v42 = v74;
                v40 = v75;
              }
              else
              {
                v47 = 0;
              }
              v48 = &v47[2 * v44];
              *(_WORD *)v48 = v73;
              if (v40 == v42)
              {
                v50 = &v47[2 * v44];
              }
              else
              {
                v49 = v40;
                v50 = &v47[2 * v44];
                do
                {
                  v51 = *((_WORD *)v49 - 1);
                  v49 -= 2;
                  *((_WORD *)v50 - 1) = v51;
                  v50 -= 2;
                }
                while (v49 != v42);
              }
              v41 = v48 + 2;
              v74 = v50;
              v75 = v48 + 2;
              v52 = v76;
              v76 = &v47[2 * v46];
              v81 = v40;
              v82 = v52;
              v79 = v42;
              v80 = v42;
              std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v79);
            }
            else
            {
              *(_WORD *)v75 = v73;
              v41 = v40 + 2;
            }
            v75 = v41;
            if (*a1[3] <= (uint64_t)v73)
              goto LABEL_108;
            if ((_DWORD)v35 != 1)
            {
              v53 = &v34[(v35 - 1)];
              while (1)
              {
                v54 = bswap32(*v34) >> 16;
                if (*a1[3] <= v54)
                  break;
                if (v41 >= v76)
                {
                  v55 = v74;
                  v56 = v41 - v74;
                  if (v41 - v74 <= -3)
                    goto LABEL_111;
                  v57 = v56 >> 1;
                  if (v76 - v74 <= (unint64_t)((v56 >> 1) + 1))
                    v58 = v57 + 1;
                  else
                    v58 = v76 - v74;
                  if ((unint64_t)(v76 - v74) >= 0x7FFFFFFFFFFFFFFELL)
                    v59 = 0x7FFFFFFFFFFFFFFFLL;
                  else
                    v59 = v58;
                  v83 = v77;
                  if (v59)
                  {
                    v60 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v77, v59);
                    v55 = v74;
                    v41 = v75;
                  }
                  else
                  {
                    v60 = 0;
                  }
                  v61 = &v60[2 * v57];
                  *(_WORD *)v61 = v54;
                  if (v41 == v55)
                  {
                    v63 = &v60[2 * v57];
                  }
                  else
                  {
                    v62 = v41;
                    v63 = &v60[2 * v57];
                    do
                    {
                      v64 = *((_WORD *)v62 - 1);
                      v62 -= 2;
                      *((_WORD *)v63 - 1) = v64;
                      v63 -= 2;
                    }
                    while (v62 != v55);
                  }
                  v65 = v61 + 2;
                  v74 = v63;
                  v75 = v61 + 2;
                  v66 = v76;
                  v76 = &v60[2 * v59];
                  v81 = v41;
                  v82 = v66;
                  v79 = v55;
                  v80 = v55;
                  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v79);
                  v41 = v65;
                }
                else
                {
                  *(_WORD *)v41 = v54;
                  v41 += 2;
                }
                v75 = v41;
                if (++v34 == v53)
                  goto LABEL_103;
              }
LABEL_108:
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v74);
              return 0;
            }
LABEL_103:
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v74);
            v18 = v71;
          }
        }
        while (++v25 != v72);
      }
      LOWORD(v5) = v69;
      v17 = v68 == v73++;
      v8 = v67;
      if (v17)
        return 1;
    }
  }
  return result;
}

char **std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::reserve(char **result, unint64_t a2)
{
  char **v3;
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  __int16 v10;
  char *v11;
  _QWORD v12[5];

  if (a2 > (result[2] - *result) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0)
      abort();
    v3 = result;
    v4 = result[1] - *result;
    v12[4] = result + 3;
    v5 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)(result + 3), a2);
    v7 = *v3;
    v6 = v3[1];
    v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    if (v6 != *v3)
    {
      v9 = v3[1];
      v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
      do
      {
        v10 = *((_WORD *)v9 - 1);
        v9 -= 2;
        *((_WORD *)v8 - 1) = v10;
        v8 -= 2;
      }
      while (v9 != v7);
    }
    *v3 = v8;
    v3[1] = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    v11 = v3[2];
    v3[2] = &v5[2 * a2];
    v12[2] = v6;
    v12[3] = v11;
    v12[0] = v7;
    v12[1] = v7;
    return (char **)std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)v12);
  }
  return result;
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  _BYTE *v12;
  void **v13;
  unint64_t v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  v10 = (uint64_t)(v8 - *(_QWORD *)result) >> 1;
  if (v10 < a4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      if (result + 24 <= v9 && result + 30 > v9)
      {
        if (&v9[2 * v10] == *((char **)result + 4))
          *((_QWORD *)result + 4) = v9;
      }
      else
      {
        operator delete(v9);
      }
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      abort();
    if (v8 <= a4)
      v19 = a4;
    else
      v19 = v8;
    if (v8 >= 0x7FFFFFFFFFFFFFFELL)
      v20 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v20 = v19;
    result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__vallocate[abi:nn180100](v7, v20);
    v21 = (char *)v7[1];
    v13 = (void **)(v7 + 1);
    v9 = v21;
LABEL_24:
    v16 = a3 - (_QWORD)__src;
    if (v16)
    {
      v17 = v9;
      v18 = __src;
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  v13 = (void **)(result + 8);
  v12 = (_BYTE *)*((_QWORD *)result + 1);
  v14 = (v12 - v9) >> 1;
  if (v14 >= a4)
    goto LABEL_24;
  v15 = &__src[2 * v14];
  if (v12 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, 2 * v14);
    v9 = (char *)*v13;
  }
  v16 = a3 - (_QWORD)v15;
  if (v16)
  {
    v17 = v9;
    v18 = v15;
LABEL_26:
    result = (char *)memmove(v17, v18, v16);
  }
LABEL_27:
  *v13 = &v9[v16];
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,`anonymous namespace'::LigInput *,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned __int16 **v12;
  uint64_t v13;
  unsigned __int16 **v14;
  unsigned __int16 **v15;
  __int128 v16;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  unsigned __int16 *v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  __int128 v24;
  char *v25;
  uint64_t v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unsigned __int16 *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  unsigned __int16 **v43;
  unsigned __int16 **v44;
  unsigned __int16 *v45;
  unsigned __int16 *v46;
  unint64_t v47;
  unsigned __int16 *v49;
  unsigned int v50;
  unsigned int v51;
  unsigned __int16 *v52;
  unsigned __int16 *v53;
  unint64_t v54;
  unsigned __int16 **v55;
  unsigned __int16 *v56;
  unsigned int v57;
  unsigned int v58;
  unsigned __int16 *v59;
  unsigned __int16 *v60;
  unint64_t v61;
  unsigned __int16 *v62;
  unsigned int v63;
  unsigned int v64;
  unint64_t v66;
  unint64_t v67;
  unsigned __int16 *v68;
  unsigned __int16 *v69;
  unint64_t v70;
  unsigned __int16 *v72;
  unsigned int v73;
  unsigned int v74;
  unsigned __int16 *v75;
  unsigned __int16 *v76;
  unint64_t v77;
  unsigned __int16 *v78;
  unsigned int v79;
  unsigned int v80;
  char v81;
  uint64_t v82;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  unsigned int v85;
  unsigned int v86;
  unsigned __int16 **v87;
  unsigned __int16 *v88;
  unsigned __int16 *v89;
  uint64_t v90;
  uint64_t v91;
  unsigned __int16 *v92;
  unsigned int v93;
  unsigned int v94;
  unint64_t v95;
  unsigned __int16 **i;
  uint64_t v97;
  uint64_t v98;
  unsigned __int16 *v99;
  unsigned int v100;
  unsigned int v101;
  unint64_t v102;
  unsigned __int16 *v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unsigned __int16 *v108;
  unsigned int v109;
  unsigned int v110;
  uint64_t v111;
  uint64_t v112;
  unsigned __int16 *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unsigned __int16 *v117;
  unsigned int v118;
  unsigned int v119;
  unsigned __int16 *v120;
  unsigned __int16 *v121;
  uint64_t v122;
  unsigned __int16 *v123;
  unint64_t v124;
  uint64_t v125;
  unsigned __int16 **v126;
  unsigned __int16 **v127;
  unsigned __int16 **v128;
  unsigned __int16 *v129;
  unsigned __int16 *v130;
  char *v131;
  unint64_t v132;
  uint64_t v133;
  __int128 v134;
  unsigned __int16 **v135;
  unsigned __int16 **v136;
  char *v137;
  uint64_t v138;
  unsigned __int16 *v139;
  unint64_t v140;
  unint64_t v141;
  char *v143;
  unsigned int v144;
  unsigned int v145;
  unint64_t v146;
  unsigned int v148;
  unsigned int v149;
  int64_t v150;
  int64_t v151;
  int64_t v152;
  uint64_t v153;
  char **v154;
  char *v155;
  char *v156;
  char *v157;
  unint64_t v158;
  uint64_t v159;
  unint64_t v160;
  unsigned int v162;
  unsigned int v163;
  unsigned __int16 **v164;
  unsigned __int16 *v165;
  unsigned __int16 *v166;
  unsigned __int16 *v167;
  unint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unsigned int v172;
  unsigned int v173;
  __int128 v174;
  unsigned __int16 **v175;
  char **v176;
  uint64_t v177;
  uint64_t v178;
  char *v179;
  char *v180;
  char *v181;
  unint64_t v182;
  uint64_t v183;
  unint64_t v184;
  unsigned int v186;
  unsigned int v187;
  char *v188;
  uint64_t v189;
  unsigned __int16 *v190;
  unint64_t v191;
  uint64_t v193;
  char *v194;
  unsigned int v195;
  unsigned int v196;
  int64_t v197;
  unsigned __int16 **v198;
  __int128 v199;
  uint64_t v200;
  char **v201;
  char *v202;
  uint64_t v203;
  int64_t v204;
  char *v205;
  char *v206;
  char *v207;
  unint64_t v208;
  uint64_t v209;
  unint64_t v210;
  unsigned int v212;
  unsigned int v213;
  uint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unsigned __int16 **v217;
  char *v218;
  char *v219;
  char *v220;
  unint64_t v221;
  uint64_t v222;
  __int128 v223;
  unsigned __int16 **v224;
  char *v225;
  uint64_t v226;
  unint64_t v227;
  unint64_t v229;
  unsigned __int16 *v230;
  unint64_t v231;
  uint64_t v233;
  unsigned __int16 *v234;
  unsigned __int16 *v235;
  unsigned int v236;
  unsigned int v237;
  unint64_t v238;
  unsigned int v240;
  unsigned int v241;
  unint64_t v242;
  unsigned int v244;
  unsigned int v245;
  unsigned __int16 **v246;
  unsigned __int16 *v247;
  unsigned __int16 *v248;
  unsigned __int16 *v249;
  unint64_t v250;
  uint64_t v251;
  __int128 v252;
  char *v253;
  unsigned __int16 **v254;
  unsigned __int16 **v255;
  char *v256;
  unint64_t v257;
  uint64_t v258;
  unint64_t v259;
  uint64_t v261;
  char *v262;
  unsigned __int16 *v263;
  unsigned int v264;
  unsigned int v265;
  unint64_t v266;
  unsigned int v268;
  unsigned int v269;
  _OWORD v270[2];
  __int128 v271;
  __int128 v272;
  __int128 v273;
  __int128 v274;

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<`anonymous namespace'::LigInput *&,`anonymous namespace'::LigInput *&>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  _OWORD v5[2];
  __int128 v6;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v5[1] = v4;
  v6 = v4;
  v5[0] = v4;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v5, *(_BYTE **)a1, *(_BYTE **)(a1 + 8));
  WORD4(v6) = *(_WORD *)(a1 + 40);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a1, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 1);
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a2, *(char **)&v5[0], *((uint64_t *)&v5[0] + 1), (uint64_t)(*((_QWORD *)&v5[0] + 1) - *(_QWORD *)&v5[0]) >> 1);
  *(_WORD *)(a2 + 40) = WORD4(v6);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v5);
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,`anonymous namespace'::LigInput *,0>(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, unsigned __int16 **a5)
{
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  unint64_t v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  unsigned __int16 *v17;
  unint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  unint64_t v23;
  uint64_t v24;
  unsigned __int16 *v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;

  v10 = *a5;
  v11 = a5[1];
  v12 = *(unsigned __int16 **)a4;
  v13 = v11 - *a5;
  v14 = *(_QWORD *)(a4 + 8) - *(_QWORD *)a4;
  if (v13 > v14 >> 1)
    goto LABEL_2;
  v30 = v14 >> 1;
  if (v11 != v10 && v13 >= v30)
  {
    while (1)
    {
      v32 = *v10;
      v33 = *v12;
      if (v32 != v33)
        break;
      ++v10;
      ++v12;
      if (!--v13)
        return;
    }
    if (v32 <= v33)
    {
LABEL_2:
      v15 = *(unsigned __int16 **)a4;
      v16 = *(unsigned __int16 **)(a4 + 8);
      v17 = *a3;
      v18 = ((uint64_t)v16 - *(_QWORD *)a4) >> 1;
      v19 = (char *)a3[1] - (char *)*a3;
      if (v18 > v19 >> 1)
        goto LABEL_3;
      if (v16 != v15 && v18 >= v19 >> 1)
      {
        while (1)
        {
          v34 = *v15;
          v35 = *v17;
          if (v34 != v35)
            break;
          ++v15;
          ++v17;
          if (!--v18)
            return;
        }
        if (v34 <= v35)
        {
LABEL_3:
          v20 = *a3;
          v21 = a3[1];
          v22 = *a2;
          v23 = v21 - *a3;
          v24 = (char *)a2[1] - (char *)*a2;
          if (v23 > v24 >> 1)
            goto LABEL_4;
          if (v21 != v20 && v23 >= v24 >> 1)
          {
            while (1)
            {
              v36 = *v20;
              v37 = *v22;
              if (v36 != v37)
                break;
              ++v20;
              ++v22;
              if (!--v23)
                return;
            }
            if (v36 <= v37)
            {
LABEL_4:
              v25 = *a2;
              v26 = a2[1];
              v27 = *a1;
              v28 = v26 - *a2;
              v29 = (char *)a1[1] - (char *)*a1;
              if (v28 > v29 >> 1)
                goto LABEL_5;
              if (v26 != v25 && v28 >= v29 >> 1)
              {
                while (1)
                {
                  v38 = *v25;
                  v39 = *v27;
                  if (v38 != v39)
                    break;
                  ++v25;
                  ++v27;
                  if (!--v28)
                    return;
                }
                if (v38 <= v39)
LABEL_5:
              }
            }
          }
        }
      }
    }
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,`anonymous namespace'::LigInput *>(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3)
{
  unsigned __int16 **v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v17;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v22;
  unsigned int v23;
  _BOOL4 v24;
  uint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  unint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;

  v5 = a1;
  v6 = *a2;
  v7 = a2[1];
  v8 = *a1;
  v9 = v7 - *a2;
  v10 = (char *)a1[1] - (char *)*a1;
  if (v9 > v10 >> 1)
  {
    v11 = *a3;
    v12 = a3[1];
    v13 = v12 - *a3;
    if (v13 <= v9)
    {
      v14 = 1;
      goto LABEL_17;
    }
LABEL_25:
    v25 = (uint64_t)a3;
LABEL_26:
    return;
  }
  v15 = v10 >> 1;
  if (v7 != v6 && v9 >= v15)
  {
    v17 = v7 - *a2;
    v18 = *a2;
    while (1)
    {
      v19 = *v18;
      v20 = *v8;
      if (v19 != v20)
        break;
      ++v18;
      ++v8;
      if (!--v17)
        goto LABEL_12;
    }
    v14 = v19 <= v20;
  }
  else
  {
LABEL_12:
    v14 = 0;
  }
  v11 = *a3;
  v12 = a3[1];
  v13 = v12 - *a3;
  if (v13 > v9)
  {
    if (!v14)
      goto LABEL_29;
    goto LABEL_25;
  }
LABEL_17:
  if (v13 < v9 || v12 == v11)
  {
LABEL_23:
    v24 = 0;
    if (!v14)
      goto LABEL_28;
    goto LABEL_24;
  }
  while (1)
  {
    v22 = *v11;
    v23 = *v6;
    if (v22 != v23)
      break;
    ++v11;
    ++v6;
    if (!--v13)
      goto LABEL_23;
  }
  v24 = v22 <= v23;
  if (v14)
  {
LABEL_24:
    if (!v24)
    {
      v31 = *a3;
      v32 = a3[1];
      v33 = *a2;
      v34 = v32 - *a3;
      v35 = (char *)a2[1] - (char *)*a2;
      if (v34 <= v35 >> 1)
      {
        if (v32 == v31 || v34 < v35 >> 1)
          return;
        while (1)
        {
          v38 = *v31;
          v39 = *v33;
          if (v38 != v39)
            break;
          ++v31;
          ++v33;
          if (!--v34)
            return;
        }
        if (v38 > v39)
          return;
      }
      a1 = a2;
    }
    goto LABEL_25;
  }
LABEL_28:
  if (!v24)
    return;
LABEL_29:
  v26 = *a2;
  v27 = a2[1];
  v28 = (char *)*v5;
  v29 = v27 - *a2;
  v30 = (char *)v5[1] - (char *)*v5;
  if (v29 > v30 >> 1)
    goto LABEL_30;
  if (v27 != v26 && v29 >= v30 >> 1)
  {
    while (1)
    {
      v36 = *v26;
      v37 = *(unsigned __int16 *)v28;
      if (v36 != v37)
        break;
      ++v26;
      v28 += 2;
      if (!--v29)
        return;
    }
    if (v36 <= v37)
    {
LABEL_30:
      a1 = v5;
      v25 = (uint64_t)a2;
      goto LABEL_26;
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,`anonymous namespace'::LigInput *>(uint64_t a1, unsigned __int16 **a2)
{
  _BOOL8 v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 **v11;
  int v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unint64_t v30;
  unsigned __int16 *v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v36;
  unsigned int v37;
  _OWORD v38[2];
  __int128 v39;

  v4 = 1;
  switch(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - a1) >> 4))
  {
    case 0uLL:
    case 1uLL:
      return v4;
    case 2uLL:
      v5 = *(a2 - 6);
      v6 = *(a2 - 5);
      v7 = *(unsigned __int16 **)a1;
      v8 = v6 - v5;
      v9 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
      if (v8 > v9 >> 1)
        goto LABEL_3;
      if (v6 == v5 || v8 < v9 >> 1)
        return v4;
      while (1)
      {
        v36 = *v5;
        v37 = *v7;
        if (v36 != v37)
          break;
        ++v5;
        ++v7;
        if (!--v8)
          return v4;
      }
      if (v36 <= v37)
      {
LABEL_3:
        return 1;
      }
      return 1;
    case 3uLL:
      return v4;
    case 4uLL:
      return v4;
    case 5uLL:
      return v4;
    default:
      v10 = a1 + 96;
      v11 = (unsigned __int16 **)(a1 + 144);
      if ((unsigned __int16 **)(a1 + 144) == a2)
        return 1;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *v11;
    v14 = v11[1];
    v15 = *(char **)v10;
    v16 = v14 - *v11;
    v17 = *(_QWORD *)(v10 + 8) - *(_QWORD *)v10;
    if (v16 <= v17 >> 1)
    {
      v30 = v17 >> 1;
      if (v14 == v13 || v16 < v30)
        goto LABEL_38;
      v32 = *v11;
      while (1)
      {
        v33 = *v32;
        v34 = *(unsigned __int16 *)v15;
        if (v33 != v34)
          break;
        ++v32;
        v15 += 2;
        if (!--v16)
          goto LABEL_38;
      }
      if (v33 > v34)
        goto LABEL_38;
    }
    *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v38[1] = v18;
    v39 = v18;
    v38[0] = v18;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v38, v13, v14);
    WORD4(v39) = *((_WORD *)v11 + 20);
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v11, *(char **)v10, *(_QWORD *)(v10 + 8), (uint64_t)(*(_QWORD *)(v10 + 8) - *(_QWORD *)v10) >> 1);
    *((_WORD *)v11 + 20) = *(_WORD *)(v10 + 40);
    v19 = a1;
    if (v10 != a1)
    {
      v20 = v10;
      while (1)
      {
        v21 = *(char **)(v20 - 48);
        v22 = *(_QWORD *)(v20 - 40);
        v20 -= 48;
        v24 = *((_QWORD *)&v38[0] + 1);
        v23 = *(char **)&v38[0];
        v25 = (uint64_t)(*((_QWORD *)&v38[0] + 1) - *(_QWORD *)&v38[0]) >> 1;
        if (v25 <= (v22 - (uint64_t)v21) >> 1)
        {
          if (*((_QWORD *)&v38[0] + 1) == *(_QWORD *)&v38[0] || v25 < (v22 - (uint64_t)v21) >> 1)
            break;
          v27 = 0;
          while (1)
          {
            v28 = *(unsigned __int16 *)(*(_QWORD *)&v38[0] + 2 * v27);
            v29 = *(unsigned __int16 *)&v21[2 * v27];
            if (v28 != v29)
              break;
            if (v25 == ++v27)
              goto LABEL_36;
          }
          if (v28 > v29)
            break;
        }
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v10, v21, v22, (v22 - (uint64_t)v21) >> 1);
        *(_WORD *)(v10 + 40) = *(_WORD *)(v10 - 8);
        v10 = v20;
        if (v20 == a1)
        {
          v19 = a1;
          goto LABEL_35;
        }
      }
      v19 = v10;
    }
LABEL_35:
    v24 = *((_QWORD *)&v38[0] + 1);
    v23 = *(char **)&v38[0];
    v25 = (uint64_t)(*((_QWORD *)&v38[0] + 1) - *(_QWORD *)&v38[0]) >> 1;
    v10 = v19;
LABEL_36:
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v10, v23, v24, v25);
    *(_WORD *)(v10 + 40) = WORD4(v39);
    if (++v12 == 8)
      break;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v38);
LABEL_38:
    v10 = (uint64_t)v11;
    v11 += 6;
    if (v11 == a2)
      return 1;
  }
  v4 = v11 + 6 == a2;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v38);
  return v4;
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,`anonymous namespace'::LigInput *>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 **a4)
{
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  unint64_t v16;
  uint64_t v17;
  unsigned __int16 *v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;

  v8 = *a4;
  v9 = a4[1];
  v10 = *(unsigned __int16 **)a3;
  v11 = v9 - *a4;
  v12 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
  if (v11 > v12 >> 1)
    goto LABEL_2;
  v23 = v12 >> 1;
  if (v9 != v8 && v11 >= v23)
  {
    while (1)
    {
      v25 = *v8;
      v26 = *v10;
      if (v25 != v26)
        break;
      ++v8;
      ++v10;
      if (!--v11)
        return;
    }
    if (v25 <= v26)
    {
LABEL_2:
      v13 = *(unsigned __int16 **)a3;
      v14 = *(unsigned __int16 **)(a3 + 8);
      v15 = *(unsigned __int16 **)a2;
      v16 = ((uint64_t)v14 - *(_QWORD *)a3) >> 1;
      v17 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
      if (v16 > v17 >> 1)
        goto LABEL_3;
      if (v14 != v13 && v16 >= v17 >> 1)
      {
        while (1)
        {
          v27 = *v13;
          v28 = *v15;
          if (v27 != v28)
            break;
          ++v13;
          ++v15;
          if (!--v16)
            return;
        }
        if (v27 <= v28)
        {
LABEL_3:
          v18 = *(unsigned __int16 **)a2;
          v19 = *(unsigned __int16 **)(a2 + 8);
          v20 = *(unsigned __int16 **)a1;
          v21 = ((uint64_t)v19 - *(_QWORD *)a2) >> 1;
          v22 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
          if (v21 > v22 >> 1)
            goto LABEL_4;
          if (v19 != v18 && v21 >= v22 >> 1)
          {
            while (1)
            {
              v29 = *v18;
              v30 = *v20;
              if (v29 != v30)
                break;
              ++v18;
              ++v20;
              if (!--v21)
                return;
            }
            if (v29 <= v30)
LABEL_4:
          }
        }
      }
    }
  }
}

BOOL `anonymous namespace'::MorxLigatureSubtableBuilder::StateNeedsAction(_anonymous_namespace_::MorxLigatureSubtableBuilder *this, int a2, int a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int16 *v7;
  char v8;
  unsigned int v9;
  _BOOL8 result;

  v3 = (a3 + *((_DWORD *)this + 6) * a2);
  v4 = *((_QWORD *)this + 5);
  result = 0;
  if (v3 < (*((_QWORD *)this + 6) - v4) >> 1)
  {
    v5 = *(unsigned __int16 *)(v4 + 2 * v3);
    v6 = *((_QWORD *)this + 17);
    if (0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 18) - v6) >> 1) > v5)
    {
      v7 = (unsigned __int16 *)(v6 + 6 * v5);
      v8 = v7[1];
      v9 = bswap32(*v7) >> 16;
      if ((v8 & 0xE0) != 0 || v9 > 1)
        return 1;
    }
  }
  return result;
}

void std::vector<`anonymous namespace'::StateMemberInfo,TInlineBufferAllocator<`anonymous namespace'::StateMemberInfo,30ul>>::push_back[abi:nn180100](char **a1, uint64_t a2)
{
  char *v4;
  char *v5;
  int v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  int v21;
  char *v22;
  char *v23;
  char *v24;
  char **v25;

  v5 = a1[1];
  v4 = a1[2];
  if (v5 < v4)
  {
    *(_WORD *)v5 = *(_WORD *)a2;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v5 + 8), *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
    v6 = *(_DWORD *)(a2 + 48);
    *((_WORD *)v5 + 26) = *(_WORD *)(a2 + 52);
    *((_DWORD *)v5 + 12) = v6;
    v7 = v5 + 56;
    goto LABEL_25;
  }
  v8 = (char *)(a1 + 3);
  v9 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
  if ((unint64_t)(v9 + 1) > 0x492492492492492)
    abort();
  v10 = 0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 3);
  v11 = 2 * v10;
  if (2 * v10 <= v9 + 1)
    v11 = v9 + 1;
  if (v10 >= 0x249249249249249)
    v12 = 0x492492492492492;
  else
    v12 = v11;
  if (v12)
  else
    v13 = 0;
  v14 = &v13[56 * v9];
  v15 = &v13[56 * v12];
  *(_WORD *)v14 = *(_WORD *)a2;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v14 + 8), *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
  v16 = *(_DWORD *)(a2 + 48);
  *((_WORD *)v14 + 26) = *(_WORD *)(a2 + 52);
  *((_DWORD *)v14 + 12) = v16;
  v7 = v14 + 56;
  v18 = *a1;
  v17 = a1[1];
  if (v17 == *a1)
  {
    *a1 = v14;
    a1[1] = v7;
    v23 = a1[2];
    a1[2] = v15;
    if (!v17)
      goto LABEL_25;
    goto LABEL_20;
  }
  v19 = 0;
  do
  {
    v20 = &v14[v19];
    *(_WORD *)&v14[v19 - 56] = *(_WORD *)&v17[v19 - 56];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v14[v19 - 48], *(_BYTE **)&v17[v19 - 48], *(_BYTE **)&v17[v19 - 40]);
    v21 = *(_DWORD *)&v17[v19 - 8];
    *((_WORD *)v20 - 2) = *(_WORD *)&v17[v19 - 4];
    *((_DWORD *)v20 - 2) = v21;
    v19 -= 56;
  }
  while (&v17[v19] != v18);
  v17 = *a1;
  v22 = a1[1];
  *a1 = &v14[v19];
  a1[1] = v7;
  v23 = a1[2];
  a1[2] = v15;
  if (v22 != v17)
  {
    do
    {
      v24 = v22 - 56;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v22 - 48));
      v22 = v24;
    }
    while (v24 != v17);
  }
  if (v17)
  {
LABEL_20:
    if (v8 > v17 || (v25 = a1 + 213, a1 + 213 <= (char **)v17))
    {
      operator delete(v17);
    }
    else if (v23 == *v25)
    {
      *v25 = v17;
    }
  }
LABEL_25:
  a1[1] = v7;
}

void DoSubgroupSubstitutions(_QWORD *a1, uint64_t a2, unsigned __int16 **a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 **v15;
  __int128 v16;
  uint64_t v17;
  const void *v18;
  size_t v19;
  _QWORD *v20;
  const void *v21;
  unint64_t v22;
  _OWORD v24[2];
  unint64_t v25;

  v4 = *(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40);
  if (v4)
  {
    v8 = 0;
    v9 = v4 / 56;
    v22 = v9;
    if (v9 <= 1)
      v10 = 1;
    else
      v10 = v9;
    do
    {
      v11 = *(_QWORD *)(a2 + 40);
      v12 = v11 + 56 * v8;
      v13 = *(_QWORD *)(v12 + 8);
      v14 = *(_QWORD *)(v12 + 16);
      v15 = (unsigned __int16 **)(v12 + 8);
      if (v13 == v14)
      {
        if (*(__int16 *)(v11 + 56 * v8 + 50) >= 1)
          DoSubgroupSubstitutions();
      }
      else if (ReplaceSubgroupWithSingle(v15, a3, a4))
      {
        v25 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v24[0] = v16;
        v24[1] = v16;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v24, *v15, v15[1]);
        v17 = 0;
        v18 = *(const void **)&v24[0];
        v19 = *((_QWORD *)&v24[0] + 1) - *(_QWORD *)&v24[0];
        v20 = (_QWORD *)(*(_QWORD *)(a2 + 40) + 16);
        while (1)
        {
          v21 = (const void *)*(v20 - 1);
          if (*v20 - (_QWORD)v21 != v19 || memcmp(v21, v18, v19))
            break;
          ++v17;
          v20 += 7;
          if (v10 == v17)
          {
            v17 = v10;
            break;
          }
        }
        if (v17 == v22)
          ChangeIdentityForward(a1, a2, a3, a4);
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v24);
      }
      ++v8;
    }
    while (v8 != v10);
  }
}

uint64_t GetActionLookupIndex(char **a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5;
  void *v6;
  __int16 v7;
  char *v8;
  int v9;
  unsigned int v10;
  char v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  const void *v15;
  BOOL v16;
  char v17;
  char **v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  char **v36;
  void *v37;
  uint64_t v38;
  uint64_t v42;
  __int128 v44;
  __int128 v45;
  _QWORD v46[2];
  unint64_t v47;

  v44 = 0xAAAAAAAAAAAAAAAALL;
  v46[0] = 0xAAAAAAAAAAAAAAAALL;
  v45 = 0uLL;
  v46[1] = v46;
  v47 = 0xAAAAAAAAAAAAAAAALL;
  WORD1(v47) = *((_WORD *)a1 + 857);
  v6 = *(void **)a4;
  v5 = *(_QWORD *)(a4 + 8);
  v7 = *((_WORD *)a1 + 856);
  if (*(_QWORD *)a4 == v5)
    v7 = -1;
  LOWORD(v47) = v7;
  v8 = *a1;
  v42 = v5;
  v9 = -1227133513 * ((unint64_t)(a1[1] - *a1) >> 3);
  v10 = 0;
  if (v9 >= 1)
  {
    v11 = 0;
    v12 = v5 - (_QWORD)v6;
    do
    {
      v13 = &v8[56 * v10];
      v14 = *(unsigned __int16 *)v13;
      v15 = (const void *)*((_QWORD *)v13 + 1);
      v16 = v12 == *((_QWORD *)v13 + 2) - (_QWORD)v15 && memcmp(v6, v15, v12) == 0;
      if (v14 == a2)
      {
        if (*(__int16 *)&v8[56 * v10 + 2] == a3)
        {
          if (v16)
            break;
        }
        else
        {
          v17 = !v16;
          if (v6 == (void *)v42)
            v17 = 1;
          if ((v17 & 1) == 0)
            LODWORD(v47) = *(_DWORD *)&v8[56 * v10 + 48];
        }
        v11 = 1;
      }
      else if ((v11 & 1) != 0)
      {
        v10 = v9 - 1;
      }
      ++v10;
    }
    while ((int)v10 < v9);
  }
  v18 = a1;
  if (v10 == v9)
  {
    LOWORD(v44) = a2;
    WORD1(v44) = a3;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v44 + 8, (char *)v6, v42, (v42 - (uint64_t)v6) >> 1);
    v20 = a1[1];
    v19 = (unint64_t)a1[2];
    if ((unint64_t)v20 < v19)
    {
      *(_DWORD *)v20 = v44;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v20 + 8), *((_BYTE **)&v44 + 1), (_BYTE *)v45);
      *((_DWORD *)v20 + 12) = v47;
      v21 = v20 + 56;
      goto LABEL_50;
    }
    v22 = 0x6DB6DB6DB6DB6DB7 * ((v20 - *a1) >> 3);
    if ((unint64_t)(v22 + 1) > 0x492492492492492)
      abort();
    v23 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v19 - (_QWORD)*a1) >> 3);
    v24 = 2 * v23;
    if (2 * v23 <= v22 + 1)
      v24 = v22 + 1;
    if (v23 >= 0x249249249249249)
      v25 = 0x492492492492492;
    else
      v25 = v24;
    if (v25)
    {
      v26 = a1[213];
      v27 = (unint64_t)&v26[56 * v25];
      if (v27 <= (unint64_t)(a1 + 213))
      {
        a1[213] = (char *)v27;
      }
      else
      {
        if (v25 > 0x492492492492492)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v26 = (char *)operator new(56 * v25);
      }
    }
    else
    {
      v26 = 0;
    }
    v28 = &v26[56 * v22];
    v29 = &v26[56 * v25];
    *(_DWORD *)v28 = v44;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v28 + 8), *((_BYTE **)&v44 + 1), (_BYTE *)v45);
    *((_DWORD *)v28 + 12) = v47;
    v21 = v28 + 56;
    v30 = *a1;
    v31 = a1[1];
    if (v31 == *a1)
    {
      *a1 = v28;
      a1[1] = v21;
      v34 = a1[2];
      a1[2] = v29;
    }
    else
    {
      v32 = 0;
      do
      {
        *(_DWORD *)&v28[v32 - 56] = *(_DWORD *)&v31[v32 - 56];
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v28[v32 - 48], *(_BYTE **)&v31[v32 - 48], *(_BYTE **)&v31[v32 - 40]);
        *(_DWORD *)&v28[v32 - 8] = *(_DWORD *)&v31[v32 - 8];
        v32 -= 56;
      }
      while (&v31[v32] != v30);
      v18 = a1;
      v31 = *a1;
      v33 = a1[1];
      *a1 = &v28[v32];
      a1[1] = v21;
      v34 = a1[2];
      a1[2] = v29;
      if (v33 == v31)
      {
        if (v31)
          goto LABEL_44;
        goto LABEL_50;
      }
      do
      {
        v35 = v33 - 56;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v33 - 48));
        v33 = v35;
      }
      while (v35 != v31);
    }
    if (v31)
    {
LABEL_44:
      if (a1 + 3 > (char **)v31 || (v36 = v18 + 213, v18 + 213 <= (char **)v31))
      {
        operator delete(v31);
      }
      else if (v34 == *v36)
      {
        *v36 = v31;
      }
    }
LABEL_50:
    v18[1] = v21;
    v37 = *(void **)a4;
    v38 = *(_QWORD *)(a4 + 8);
    if (*(_QWORD *)a4 != v38)
    {
      if ((unsigned __int16)v47 == *((unsigned __int16 *)v18 + 856))
        *((_WORD *)v18 + 856) = v47 + 1;
      if (WORD1(v47) == *((unsigned __int16 *)v18 + 857))
        *((_WORD *)v18 + 857) = WORD1(v47) + ((v38 - (_DWORD)v37) >> 1) + 1;
    }
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v44 + 8);
  return (unsigned __int16)v10;
}

char *std::__allocate_at_least[abi:nn180100]<TInlineBufferAllocator<`anonymous namespace'::StateMemberInfo,30ul>>(uint64_t a1, unint64_t a2)
{
  char *v2;
  char *result;
  char *v4;

  v2 = (char *)(a1 + 1680);
  result = *(char **)(a1 + 1680);
  v4 = &result[56 * a2];
  if (v4 <= v2)
  {
    *(_QWORD *)v2 = v4;
  }
  else
  {
    if (a2 >= 0x492492492492493)
      std::__throw_bad_array_new_length[abi:nn180100]();
    return (char *)operator new(56 * a2);
  }
  return result;
}

char **TInlineVector<`anonymous namespace'::StateMemberInfo,30ul>::TInlineVector(char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;

  *a1 = 0;
  a1[1] = 0;
  v4 = (uint64_t)(a1 + 3);
  a1[2] = 0;
  a1[213] = (char *)v4;
  if (a3 != a2)
  {
    v5 = a2;
    v6 = 0x6DB6DB6DB6DB6DB7 * ((a3 - a2) >> 3);
    if (v6 >= 0x492492492492493)
      abort();
    v9 = 0;
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[56 * v10];
    v11 = (uint64_t)(v8 + 8);
    do
    {
      *(_WORD *)(v11 - 8) = *(_WORD *)v5;
      v12 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v11, *(_BYTE **)(v5 + 8), *(_BYTE **)(v5 + 16));
      v13 = *(_DWORD *)(v5 + 48);
      *(_WORD *)(v12 + 44) = *(_WORD *)(v5 + 52);
      *(_DWORD *)(v12 + 40) = v13;
      v9 += 56;
      v11 = v12 + 56;
      v5 += 56;
    }
    while (v5 != a3);
    a1[1] = &v8[v9];
  }
  return a1;
}

void std::allocator_traits<TInlineBufferAllocator<`anonymous namespace'::StateInfo,30ul>>::destroy[abi:nn180100]<`anonymous namespace'::StateInfo,void,void>(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  v2 = a1[5];
  if (v2)
  {
    v3 = a1[6];
    v4 = (_QWORD *)a1[5];
    if (v3 != v2)
    {
      do
      {
        v5 = v3 - 56;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v3 - 48);
        v3 = v5;
      }
      while (v5 != v2);
      v4 = (_QWORD *)a1[5];
    }
    a1[6] = v2;
    v6 = a1 + 218;
    if (a1 + 8 <= v4 && v6 > v4)
    {
      if (a1[7] == a1[218])
        *v6 = v4;
    }
    else
    {
      operator delete(v4);
    }
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)a1);
}

uint64_t ReplaceSubgroupWithSingle(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 a3)
{
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  char i;
  int64_t v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  char *v20;
  uint64_t v21;

  v4 = *a1;
  v3 = a1[1];
  v5 = *a2;
  v6 = a2[1];
  if ((char *)v3 - (char *)*a1 >= (unint64_t)((char *)v6 - (char *)*a2))
  {
    for (i = 0; ; i = 1)
    {
      v12 = (char *)v6 - (char *)v5;
      v13 = v4;
      do
      {
        if (v6 == v5)
          goto LABEL_15;
        v14 = v3 - v13;
        v15 = v3;
        if (v14 >= v6 - v5)
        {
          v16 = (uint64_t)&v13[v14 + 1 - (v6 - v5)];
          v15 = v3;
          if ((unsigned __int16 *)v16 != v13)
          {
            while (*v13 != *v5)
            {
LABEL_13:
              if (++v13 == (unsigned __int16 *)v16)
              {
                v15 = v3;
                goto LABEL_16;
              }
            }
            v17 = 1;
            while (&v5[v17] != v6)
            {
              v18 = v13[v17];
              v19 = v5[v17++];
              if (v18 != v19)
                goto LABEL_13;
            }
LABEL_15:
            v15 = v13;
          }
        }
LABEL_16:
        if (v3 == v15)
          return i & 1;
        *v15 = a3;
        v4 = v15 + 1;
        i = 1;
        v13 = v4;
      }
      while (v12 == 2);
      v20 = (char *)v4 + v12 - 2;
      v21 = (char *)v3 - v20;
      if (v3 != (unsigned __int16 *)v20)
      {
        memmove(v4, v20, (char *)v3 - v20);
        v5 = *a2;
      }
      v3 = (unsigned __int16 *)((char *)v4 + v21);
      a1[1] = (unsigned __int16 *)((char *)v4 + v21);
      v6 = a2[1];
    }
  }
  i = 0;
  return i & 1;
}

uint64_t ChangeIdentityForward(_QWORD *a1, uint64_t a2, unsigned __int16 **a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = ReplaceSubgroupWithSingle((unsigned __int16 **)a2, a3, a4);
  if ((_DWORD)result)
  {
    v9 = *(_QWORD *)(a2 + 48) - *(_QWORD *)(a2 + 40);
    if (v9)
    {
      v10 = v9 / 56;
      *(_BYTE *)(a2 + 1752) = 1;
      if (v10 <= 1)
        v11 = 1;
      else
        v11 = v10;
      v12 = 50;
      do
      {
        if (*(__int16 *)(*(_QWORD *)(a2 + 40) + v12) != -1)
          result = ChangeIdentityForward(a1, *a1 + 1760 * *(__int16 *)(*(_QWORD *)(a2 + 40) + v12), a3, a4);
        v12 += 56;
        --v11;
      }
      while (v11);
    }
  }
  return result;
}

unint64_t GetActionIndex(char **a1, int a2, int a3, int a4)
{
  __int16 v4;
  int v6;
  unsigned __int16 v7;
  char *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t result;
  uint64_t v13;
  unsigned __int16 *v14;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  unint64_t v20;
  char *v21;
  char *v22;
  int v23;
  __int16 v24;

  v4 = a2;
  if (a4 == -1)
    v6 = a3;
  else
    v6 = a3 | 0x2000;
  if (a4 == -1)
    v7 = 0;
  else
    v7 = a4;
  v9 = *a1;
  v8 = a1[1];
  v10 = v8 - *a1;
  v11 = v10 / 6;
  if (v8 == *a1)
  {
LABEL_16:
    v15 = (unint64_t)a1[2];
    if ((unint64_t)v8 >= v15)
    {
      v17 = v11 + 1;
      if (v11 + 1 > 0x2AAAAAAAAAAAAAAALL)
        abort();
      if (0x5555555555555556 * ((uint64_t)(v15 - (_QWORD)v9) >> 1) > v17)
        v17 = 0x5555555555555556 * ((uint64_t)(v15 - (_QWORD)v9) >> 1);
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (_QWORD)v9) >> 1) >= 0x1555555555555555)
        v18 = 0x2AAAAAAAAAAAAAAALL;
      else
        v18 = v17;
      if (v18)
      {
        v19 = a1[26];
        v20 = (unint64_t)&v19[6 * v18];
        if (v20 <= (unint64_t)a1 + 204)
        {
          a1[26] = (char *)v20;
        }
        else
        {
          if (v18 > 0x2AAAAAAAAAAAAAAALL)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v19 = (char *)operator new(6 * v18);
        }
      }
      else
      {
        v19 = 0;
      }
      v21 = &v19[6 * v11];
      *(_WORD *)v21 = v4;
      *((_WORD *)v21 + 1) = v6;
      *((_WORD *)v21 + 2) = v7;
      v22 = v21;
      if (v8 != v9)
      {
        do
        {
          v23 = *(_DWORD *)(v8 - 6);
          v8 -= 6;
          v24 = *((_WORD *)v8 + 2);
          *(_DWORD *)(v22 - 6) = v23;
          v22 -= 6;
          *((_WORD *)v22 + 2) = v24;
        }
        while (v8 != v9);
        v8 = *a1;
        v15 = (unint64_t)a1[2];
      }
      v16 = v21 + 6;
      *a1 = v22;
      a1[1] = v21 + 6;
      a1[2] = &v19[6 * v18];
      if (v8)
      {
        if (a1 + 3 <= (char **)v8 && (char *)a1 + 204 > v8)
        {
          if ((char *)v15 == a1[26])
            a1[26] = v8;
        }
        else
        {
          operator delete(v8);
        }
      }
    }
    else
    {
      *(_WORD *)v8 = a2;
      *((_WORD *)v8 + 1) = v6;
      v16 = v8 + 6;
      *((_WORD *)v8 + 2) = v7;
    }
    a1[1] = v16;
    return 0xAAAAAAAAAAAAAAABLL * ((v16 - *a1) >> 1) - 1;
  }
  else
  {
    result = 0;
    if (v11 <= 1)
      v13 = 1;
    else
      v13 = v10 / 6;
    v14 = (unsigned __int16 *)(v9 + 4);
    while (*(v14 - 2) != a2 || *(v14 - 1) != v6 || *v14 != v7)
    {
      ++result;
      v14 += 3;
      if (v13 == result)
        goto LABEL_16;
    }
  }
  return result;
}

void std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E15DFFC8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DFFC8;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  _DWORD *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  BOOL v9;

  v4 = *(_DWORD **)(result + 8);
  if (v4[6] > *a4)
  {
    v5 = result;
    v6 = *a2;
    v7 = *a3;
    result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)v4 + 16))(*(_QWORD *)(result + 8), 0, *a4);
    if ((_DWORD)result)
    {
      if (v6 <= v7 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6)
            *(_BYTE *)(*(_QWORD *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6) = v6 + 1;
        }
        while (!v8);
      }
    }
    else if (*(_WORD *)(v5 + 32))
    {
      result = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v4 + 16))(v4);
      v9 = !(_DWORD)result || v6 > v7;
      if (!v9 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6)
            *(_BYTE *)(*(_QWORD *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6) = v6 + 1;
        }
        while (!v8);
      }
    }
  }
  return result;
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;
  void **v3;
  void **v4;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100]((uint64_t *)v2);
    v3 = (void **)**a1;
    v4 = *a1 + 93;
    if (*a1 + 3 <= v3 && v4 > v3)
    {
      if ((*a1)[2] == (*a1)[93])
        *v4 = v3;
    }
    else
    {
      operator delete(v3);
    }
  }
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  void *v2;
  void *v3;
  BOOL v4;
  BOOL v5;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    v3 = (void *)(a1 + 204);
    if (a1 + 24 <= (unint64_t)v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 208))
        *(_QWORD *)(a1 + 208) = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t std::vector<`anonymous namespace'::LigInput,TInlineBufferAllocator<`anonymous namespace'::LigInput,30ul>>::__construct_at_end<std::__wrap_iter<`anonymous namespace'::LigInput const*>,std::__wrap_iter<`anonymous namespace'::LigInput const*>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = *(_QWORD *)(a1 + 8);
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      v7 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(result, *(_BYTE **)v6, *(_BYTE **)(v6 + 8));
      *(_WORD *)(v7 + 40) = *(_WORD *)(v6 + 40);
      result = v7 + 48;
      v6 += 48;
    }
    while (v6 != a3);
  }
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_QWORD *std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  _QWORD *v8;

  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v7 = result;
    result = TInlineBufferAllocator<std::vector<unsigned short>,4ul>::allocate((uint64_t)(result + 3), a4);
    *v7 = result;
    v7[1] = result;
    v7[2] = &result[3 * a4];
    while (a2 != a3)
    {
      v8 = std::vector<unsigned short>::vector(result, a2);
      a2 += 24;
      result = v8 + 3;
    }
    v7[1] = result;
  }
  return result;
}

void *TInlineBufferAllocator<std::vector<unsigned short>,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v4 = *(_QWORD *)(a1 + 96);
  v2 = (unint64_t *)(a1 + 96);
  v3 = v4;
  v5 = v4 + 24 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL)
      std::__throw_bad_array_new_length[abi:nn180100]();
    return operator new(24 * a2);
  }
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;
  void **v3;
  void **v4;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100]((uint64_t *)v2);
    v3 = (void **)**a1;
    v4 = *a1 + 15;
    if (*a1 + 3 <= v3 && v4 > v3)
    {
      if ((*a1)[2] == (*a1)[15])
        *v4 = v3;
    }
    else
    {
      operator delete(v3);
    }
  }
}

_QWORD *std::__split_buffer<`anonymous namespace'::SubstFormat3,TInlineBufferAllocator<`anonymous namespace'::SubstFormat3,30ul> &>::__split_buffer(_QWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  unint64_t v8;
  char *v9;

  a1[3] = 0;
  a1[4] = a4;
  if (a2)
  {
    v7 = *(char **)(a4 + 12480);
    v8 = (unint64_t)&v7[416 * a2];
    if (v8 <= a4 + 12480)
    {
      *(_QWORD *)(a4 + 12480) = v8;
    }
    else
    {
      if (a2 >= 0x9D89D89D89D89ELL)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v7 = (char *)operator new(416 * a2);
    }
  }
  else
  {
    v7 = 0;
  }
  v9 = &v7[416 * a3];
  *a1 = v7;
  a1[1] = v9;
  a1[2] = v9;
  a1[3] = &v7[416 * a2];
  return a1;
}

void std::vector<`anonymous namespace'::SubstFormat3,TInlineBufferAllocator<`anonymous namespace'::SubstFormat3,30ul>>::__swap_out_circular_buffer(__n128 **a1, _QWORD *a2)
{
  __n128 *v4;
  __n128 *v5;
  __n128 *v6;
  __n128 *v7;
  __n128 *v8;
  __n128 *v9;

  v5 = *a1;
  v4 = a1[1];
  v6 = (__n128 *)a2[1];
  while (v4 != v5)
  {
    v6 -= 26;
    v4 -= 26;
  }
  a2[1] = v6;
  v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = (__n128 *)a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = (__n128 *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t std::__split_buffer<`anonymous namespace'::SubstFormat3,TInlineBufferAllocator<`anonymous namespace'::SubstFormat3,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 416;
  }
  v4 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = (_QWORD *)(v5 + 12480);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(_QWORD *)(a1 + 24) == *v6)
        *v6 = v4;
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

__n128 std::allocator_traits<TInlineBufferAllocator<`anonymous namespace'::SubstFormat3,30ul>>::construct[abi:nn180100]<`anonymous namespace'::SubstFormat3,`anonymous namespace'::SubstFormat3,void,void>(__n128 *a1, __n128 *a2)
{
  __n128 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 result;

  v3 = a1;
  *a1 = *a2;
  v4 = a2[1].n128_i64[0];
  v5 = a2[1].n128_i64[1];
  a1[1].n128_u64[0] = 0;
  a1[1].n128_u64[1] = 0;
  a1[2].n128_u64[0] = 0;
  a1[8].n128_u64[1] = (unint64_t)&a1[2].n128_u64[1];
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>((__n128 *)a1[1].n128_u64, v4, v5, 0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3));
  v6 = a2[9].n128_i64[0];
  v7 = a2[9].n128_i64[1];
  v3[9].n128_u64[0] = 0;
  v3 += 9;
  v3->n128_u64[1] = 0;
  v3[1].n128_u64[0] = 0;
  v3[7].n128_u64[1] = (unint64_t)&v3[1].n128_u64[1];
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(v3, v6, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v6) >> 3));
  v8 = a2[17].n128_i64[0];
  v9 = a2[17].n128_i64[1];
  v3[8].n128_u64[0] = 0;
  v3[8].n128_u64[1] = 0;
  v3[9].n128_u64[0] = 0;
  v3[15].n128_u64[1] = (unint64_t)&v3[9].n128_u64[1];
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>((__n128 *)v3[8].n128_u64, v8, v9, 0xAAAAAAAAAAAAAAABLL * ((v9 - v8) >> 3));
  result = a2[25];
  v3[16] = result;
  return result;
}

void std::allocator_traits<TInlineBufferAllocator<`anonymous namespace'::SubstFormat3,30ul>>::destroy[abi:nn180100]<`anonymous namespace'::SubstFormat3,void,void>(void **a1)
{
  void **v2;

  v2 = a1 + 34;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  v2 = a1 + 18;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  v2 = a1 + 2;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::__function::__func<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E15DFE18;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DFE18;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,`anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned __int16 **v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  unsigned int v13;
  uint64_t v14;
  _WORD *v15;
  unint64_t v16;
  _WORD *v17;
  _WORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  __int16 v26;
  BOOL v27;

  v3 = *a2;
  v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    do
    {
      v6 = *(unsigned __int16 ***)(a1 + 8);
      v7 = *v6;
      v8 = v6[1];
      if (v8 == v7)
        goto LABEL_11;
      v9 = v8 - v7;
      do
      {
        v10 = v9 >> 1;
        v11 = &v7[v9 >> 1];
        v13 = *v11;
        v12 = v11 + 1;
        v9 += ~(v9 >> 1);
        if (v13 < (unsigned __int16)v3)
          v7 = v12;
        else
          v9 = v10;
      }
      while (v9);
      if (v7 == v8 || *v7 > (unsigned __int16)v3)
      {
LABEL_11:
        v14 = *(_QWORD *)(a1 + 16);
        v15 = *(_WORD **)(v14 + 8);
        v16 = *(_QWORD *)(v14 + 16);
        if ((unint64_t)v15 >= v16)
        {
          v18 = *(_WORD **)v14;
          v19 = (uint64_t)v15 - *(_QWORD *)v14;
          if (v19 <= -3)
            abort();
          v20 = v19 >> 1;
          v21 = v16 - (_QWORD)v18;
          if (v21 <= (v19 >> 1) + 1)
            v22 = v20 + 1;
          else
            v22 = v21;
          if (v21 >= 0x7FFFFFFFFFFFFFFELL)
            v23 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v23 = v22;
          if (v23)
          {
            v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v14 + 16, v23);
            v18 = *(_WORD **)v14;
            v15 = *(_WORD **)(v14 + 8);
          }
          else
          {
            v24 = 0;
          }
          v25 = &v24[2 * v20];
          *(_WORD *)v25 = v3;
          v17 = v25 + 2;
          while (v15 != v18)
          {
            v26 = *--v15;
            *((_WORD *)v25 - 1) = v26;
            v25 -= 2;
          }
          *(_QWORD *)v14 = v25;
          *(_QWORD *)(v14 + 8) = v17;
          *(_QWORD *)(v14 + 16) = &v24[2 * v23];
          if (v18)
            operator delete(v18);
        }
        else
        {
          *v15 = v3;
          v17 = v15 + 1;
        }
        *(_QWORD *)(v14 + 8) = v17;
      }
      v27 = v4 == (unsigned __int16)v3;
      LOWORD(v3) = v3 + 1;
    }
    while (!v27);
  }
  return 1;
}

char **std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>(char **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  char **v8;

  if (a6)
  {
    v8 = result;
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100](result, a6);
    result = (char **)v8[1];
    while (a3 != a5)
    {
      a3 -= 24;
      result = (char **)(std::vector<unsigned short>::vector(result, a3) + 3);
    }
    v8[1] = (char *)result;
  }
  return result;
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v8;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  char v22[16];
  uint64_t v23;

  v8 = a3;
  v10 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a6)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v10) >> 3) >= a6)
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::vector<unsigned short>*,0>(v22, a2, a3, a4, a5, v10);
      v17 = v23;
      v18 = a1[1];
      if (v18 != v23)
      {
        v19 = a1[1];
        do
        {
          v21 = *(void **)(v19 - 24);
          v19 -= 24;
          v20 = v21;
          if (v21)
          {
            *(_QWORD *)(v18 - 16) = v20;
            operator delete(v20);
          }
          v18 = v19;
        }
        while (v19 != v17);
      }
      a1[1] = v17;
    }
    else
    {
      v14 = a3 - 8 * ((a1[1] - (uint64_t)v10) >> 3);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::vector<unsigned short>*,0>(v22, a2, a3, a2, v14, v10);
      v15 = a1[1];
      if (v14 != a5)
      {
        v16 = (_QWORD *)a1[1];
        do
        {
          v14 -= 24;
          v16 = std::vector<unsigned short>::vector(v16, v14) + 3;
          v15 += 24;
        }
        while (v14 != a5);
      }
      a1[1] = v15;
    }
  }
  else
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__vdeallocate(a1);
    if (a6 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v11 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v11 <= a6)
      v11 = a6;
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v11;
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100]((char **)a1, v12);
    v13 = (_QWORD *)a1[1];
    while (v8 != a5)
    {
      v8 -= 24;
      v13 = std::vector<unsigned short>::vector(v13, v8) + 3;
    }
    a1[1] = (uint64_t)v13;
  }
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__vdeallocate(uint64_t *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  if (*a1)
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](a1);
    v2 = (_QWORD *)*a1;
    v3 = a1 + 93;
    if ((unint64_t)(a1 + 3) <= *a1 && v3 > v2)
    {
      if (a1[2] == a1[93])
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::vector<unsigned short>*,0>(char *result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char *a6)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;

  v8 = result;
  if (a3 == a5)
  {
    v9 = a3;
  }
  else
  {
    v9 = a5;
    v10 = a3 - 24;
    do
    {
      if ((char *)v10 != a6)
        result = std::vector<unsigned short>::__assign_with_size[abi:nn180100]<unsigned short *,unsigned short *>(a6, *(char **)v10, *(_QWORD *)(v10 + 8), (uint64_t)(*(_QWORD *)(v10 + 8) - *(_QWORD *)v10) >> 1);
      a6 += 24;
      v11 = v10 == v9;
      v10 -= 24;
    }
    while (!v11);
  }
  *(_QWORD *)v8 = a2;
  *((_QWORD *)v8 + 1) = v9;
  *((_QWORD *)v8 + 2) = a6;
  return result;
}

char *std::vector<unsigned short>::__assign_with_size[abi:nn180100]<unsigned short *,unsigned short *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (uint64_t)(v8 - *(_QWORD *)result) >> 1)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      abort();
    if (v8 <= a4)
      v10 = a4;
    else
      v10 = v8;
    if (v8 >= 0x7FFFFFFFFFFFFFFELL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned short>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_17:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 1;
  if (v15 >= a4)
    goto LABEL_17;
  v16 = &__src[2 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_19:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_20:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned short>::__vallocate[abi:nn180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  char *v17;
  char *v18;
  char *v19;
  void *v20;
  void *v21;

  v6 = a2;
  v8 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a4)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v8) >> 3) >= a4)
    {
      v17 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::vector<unsigned short> const*,std::vector<unsigned short> const*,std::vector<unsigned short>*>(a2, a3, v8);
      v18 = (char *)a1[1];
      if (v18 != v17)
      {
        v19 = (char *)a1[1];
        do
        {
          v21 = (void *)*((_QWORD *)v19 - 3);
          v19 -= 24;
          v20 = v21;
          if (v21)
          {
            *((_QWORD *)v18 - 2) = v20;
            operator delete(v20);
          }
          v18 = v19;
        }
        while (v19 != v17);
      }
      a1[1] = (uint64_t)v17;
    }
    else
    {
      v13 = a2 + 8 * ((a1[1] - (uint64_t)v8) >> 3);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::vector<unsigned short> const*,std::vector<unsigned short> const*,std::vector<unsigned short>*>(a2, v13, v8);
      v14 = a1[1];
      if (v13 != a3)
      {
        v15 = (_QWORD *)a1[1];
        do
        {
          v16 = std::vector<unsigned short>::vector(v15, v13);
          v13 += 24;
          v15 = v16 + 3;
          v14 += 24;
        }
        while (v13 != a3);
      }
      a1[1] = v14;
    }
  }
  else
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__vdeallocate(a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v9 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v9 <= a4)
      v9 = a4;
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555)
      v10 = 0xAAAAAAAAAAAAAAALL;
    else
      v10 = v9;
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100]((char **)a1, v10);
    v11 = (_QWORD *)a1[1];
    while (v6 != a3)
    {
      v12 = std::vector<unsigned short>::vector(v11, v6);
      v6 += 24;
      v11 = v12 + 3;
    }
    a1[1] = (uint64_t)v11;
  }
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::vector<unsigned short> const*,std::vector<unsigned short> const*,std::vector<unsigned short>*>(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v5;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if ((char *)v5 != a3)
        std::vector<unsigned short>::__assign_with_size[abi:nn180100]<unsigned short *,unsigned short *>(a3, *(char **)v5, *(_QWORD *)(v5 + 8), (uint64_t)(*(_QWORD *)(v5 + 8) - *(_QWORD *)v5) >> 1);
      v5 += 24;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

_QWORD *std::vector<unsigned short>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<unsigned short>::__vallocate[abi:nn180100](a1, v5 >> 1);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

__CFData *CreateSingleSubstitutionLKTHandle(int64_t a1, int a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5, uint64_t a6, __int16 a7)
{
  __CFData *v12;
  unsigned int v13;
  _QWORD *v14;
  unsigned __int16 *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  _QWORD *v21;
  char v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int16 *v25;
  uint64_t v26;
  unint64_t v27;
  _BOOL4 v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  __int16 v33;
  __int128 v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  __CFData *v40;
  __int16 v41;
  uint64_t v42;
  unint64_t v43;
  int v44;
  _OWORD v45[2];
  unint64_t v46;
  unsigned __int16 *v47;
  uint64_t v48;
  __CFData *v49;
  _BYTE v50[24];
  _BYTE *v51;
  _BYTE v52[24];
  _BYTE *v53;
  _QWORD v54[3];
  _QWORD *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v42 = a5;
  v43 = a4;
  v41 = a7;
  v12 = NewLKTHandle(a1, 0);
  v40 = v12;
  if (a2 == 3)
  {
    v54[0] = a3;
    v15 = a3 + 3;
    if ((unint64_t)(a3 + 3) > a4)
      goto LABEL_25;
    v16 = bswap32(a3[2]) >> 16;
    v17 = (unint64_t)&v15[v16];
    v18 = (unint64_t)(a3 + 4) <= a4 ? (a4 - (unint64_t)v15) >> 1 : 0;
    v19 = v17 <= a4 && v17 >= (unint64_t)v15;
    if (!v19 && v18 != v16)
      goto LABEL_25;
    OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)a3, a4, (uint64_t)v45);
    v21 = operator new(0x38uLL);
    *v21 = &unk_1E15DFAB8;
    v21[1] = a6;
    v21[2] = v54;
    v21[3] = &v43;
    v21[4] = &v41;
    v21[5] = &v40;
    v21[6] = &v42;
    v51 = v21;
    v22 = OTL::Coverage::Iterate((unsigned __int16 **)v45, (uint64_t)v50);
    v23 = v51;
    if (v51 == v50)
    {
      v24 = 4;
      v23 = v50;
    }
    else
    {
      if (!v51)
        goto LABEL_24;
      v24 = 5;
    }
    (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_24:
    v12 = v40;
    if ((v22 & 1) != 0)
      return v12;
LABEL_25:
    DisposeLKTHandle(v12);
    return 0;
  }
  if (a2 != 1)
    goto LABEL_25;
  std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v52, a6);
  v48 = a5;
  v49 = v12;
  v13 = bswap32(*a3) >> 16;
  if (v13 == 2)
  {
    v47 = a3;
    v25 = a3 + 3;
    if ((unint64_t)(a3 + 3) > a4)
      goto LABEL_48;
    v26 = bswap32(a3[2]) >> 16;
    v27 = (unint64_t)&v25[v26];
    v29 = v27 >= (unint64_t)v25 && v27 <= a4;
    v30 = a4 - (_QWORD)v25;
    v31 = v30 >> 1;
    if ((unint64_t)(a3 + 4) > a4)
      v31 = 0;
    if (!v29 && v31 != v26)
      goto LABEL_48;
    v32 = v30 >> 1;
    if ((unint64_t)(a3 + 4) <= a4)
      v33 = v32;
    else
      v33 = 0;
    if (!v29)
      LOWORD(v26) = v33;
    v44 = (unsigned __int16)v26;
    v46 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v45[0] = v34;
    v45[1] = v34;
    OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)a3, a4, (uint64_t)v45);
    v14 = operator new(0x30uLL);
    *v14 = &unk_1E15DF8C0;
    v14[1] = v52;
    v14[2] = &v44;
    v14[3] = &v49;
    v14[4] = &v47;
    v14[5] = &v48;
  }
  else
  {
    if (v13 != 1)
      goto LABEL_48;
    v47 = a3;
    if ((unint64_t)(a3 + 3) > a4)
      goto LABEL_48;
    OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)a3, a4, (uint64_t)v45);
    v14 = operator new(0x28uLL);
    *v14 = &off_1E15DF878;
    v14[1] = v52;
    v14[2] = &v49;
    v14[3] = &v47;
    v14[4] = &v48;
  }
  v55 = v14;
  OTL::Coverage::Iterate((unsigned __int16 **)v45, (uint64_t)v54);
  v35 = v55;
  if (v55 == v54)
  {
    v36 = 4;
    v35 = v54;
    goto LABEL_47;
  }
  if (v55)
  {
    v36 = 5;
LABEL_47:
    (*(void (**)(void))(*v35 + 8 * v36))();
  }
LABEL_48:
  v37 = v53;
  if (v53 == v52)
  {
    v38 = 4;
    v37 = v52;
    goto LABEL_52;
  }
  if (v53)
  {
    v38 = 5;
LABEL_52:
    (*(void (**)(void))(*v37 + 8 * v38))();
  }
  return v12;
}

void std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E15DF878;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DF878;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  __int16 v10;

  v3 = *a2;
  v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    do
    {
      v6 = *(_QWORD *)(a1 + 8);
      v10 = v3;
      v7 = *(_QWORD *)(v6 + 24);
      if (!v7)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        JUMPOUT(0x1848FF18CLL);
      }
      if ((*(unsigned int (**)(uint64_t, __int16 *))(*(_QWORD *)v7 + 48))(v7, &v10)
        && LKTAddRange(**(__CFData ***)(a1 + 16), (unsigned __int16)v3, (unsigned __int16)v3, v3 + (bswap32(*(unsigned __int16 *)(**(_QWORD **)(a1 + 24) + 4)) >> 16)))
      {
        *(_BYTE *)(**(_QWORD **)(a1 + 32) + ((unsigned __int16)v3 >> 3)) |= 1 << (v3 & 7);
      }
      v8 = v4 == (unsigned __int16)v3;
      LOWORD(v3) = v3 + 1;
    }
    while (!v8);
  }
  return 1;
}

void std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x30uLL);
  *(_QWORD *)v2 = &unk_1E15DF8C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((_QWORD *)v2 + 5) = *(_QWORD *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &unk_1E15DF8C0;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4;
  unsigned int v5;
  __int16 v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 v13;

  v4 = *a2;
  v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    v7 = *a4;
    v8 = *a2;
    do
    {
      v9 = *(_QWORD *)(a1 + 8);
      v13 = v8;
      v10 = *(_QWORD *)(v9 + 24);
      if (!v10)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        JUMPOUT(0x1848FF318);
      }
      if ((*(unsigned int (**)(uint64_t, unsigned __int16 *))(*(_QWORD *)v10 + 48))(v10, &v13)
        && **(_DWORD **)(a1 + 16) > (unsigned __int16)(v8 - v4 + v7)
        && LKTAddRange(**(__CFData ***)(a1 + 24), v8, v8, bswap32(*(unsigned __int16 *)(**(_QWORD **)(a1 + 32)+ 2 * (unsigned __int16)(v8 - v4 + v7)+ 6)) >> 16))
      {
        *(_BYTE *)(**(_QWORD **)(a1 + 40) + (v8 >> 3)) |= 1 << (v8 & 7);
      }
    }
    while (v5 != v8++);
  }
  return 1;
}

void std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x38uLL);
  *(_QWORD *)v2 = &unk_1E15DFAB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  *(_QWORD *)a2 = &unk_1E15DFAB8;
  result = *(__n128 *)(a1 + 8);
  v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t result;
  __int16 v8;
  unsigned __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int16 v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v19;
  BOOL v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  uint64_t v28;
  _BOOL8 v29;
  unsigned __int16 v30;

  v5 = *a2;
  v6 = *a3;
  result = 1;
  if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
  {
    v8 = *a4;
    v9 = *a2;
    while (1)
    {
      v10 = *(_QWORD *)(a1 + 8);
      v30 = v9;
      v11 = *(_QWORD *)(v10 + 24);
      if (!v11)
        break;
      if ((*(unsigned int (**)(uint64_t, unsigned __int16 *))(*(_QWORD *)v11 + 48))(v11, &v30))
      {
        v12 = **(_QWORD **)(a1 + 16);
        v13 = **(_QWORD **)(a1 + 24);
        v14 = v12 + 6;
        if (v12 + 6 > v13)
          return 0;
        v15 = v9 - v5 + v8;
        v16 = bswap32(*(unsigned __int16 *)(v12 + 4)) >> 16;
        v17 = v14 + 2 * v16;
        if (v17 < v14 || v17 > v13)
        {
          v19 = (v13 - v14) >> 1;
          if (v12 + 8 > v13)
            v19 = 0;
          v20 = v16 > v15 && v19 == v16;
          if (!v20)
            return 0;
        }
        else if (v16 <= v15)
        {
          return 0;
        }
        v21 = (unsigned __int16 *)(v12 + (bswap32(*(unsigned __int16 *)(v12 + 2 * v15 + 6)) >> 16));
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) > v13)
          return 0;
        v23 = bswap32(*v21) >> 16;
        v24 = (unint64_t)&v22[v23];
        v25 = (unint64_t)(v21 + 2) <= v13 ? (v13 - (unint64_t)v22) >> 1 : 0;
        v26 = v24 <= v13 && v24 >= (unint64_t)v22;
        if (!v26 && v25 != v23)
          return 0;
        v28 = **(unsigned __int16 **)(a1 + 32);
        if (v28 < v23)
        {
          if (LKTAddRange(**(__CFData ***)(a1 + 40), v9, v9, bswap32(v21[v28 + 1]) >> 16))
            *(_BYTE *)(**(_QWORD **)(a1 + 48) + (v9 >> 3)) |= 1 << (v9 & 7);
        }
      }
      v20 = v6 == v9++;
      if (v20)
        return 1;
    }
    v29 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::~__func(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E15DFDD0;
  v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::~__func(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E15DFDD0;
  v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::__clone(_OWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  __int128 v4;

  v2 = (uint64_t)a1 + 8;
  v3 = operator new(0x68uLL);
  *v3 = &off_1E15DFDD0;
  std::vector<unsigned short>::vector(v3 + 1, v2);
  v4 = a1[3];
  *((_OWORD *)v3 + 2) = a1[2];
  *((_OWORD *)v3 + 3) = v4;
  *((_OWORD *)v3 + 4) = a1[4];
  std::vector<unsigned short>::vector(v3 + 10, (uint64_t)(a1 + 5));
  return v3;
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::__clone(_OWORD *a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;

  *(_QWORD *)a2 = &off_1E15DFDD0;
  std::vector<unsigned short>::vector((_QWORD *)(a2 + 8), (uint64_t)a1 + 8);
  v4 = a1[2];
  v5 = a1[4];
  *(_OWORD *)(a2 + 48) = a1[3];
  *(_OWORD *)(a2 + 64) = v5;
  *(_OWORD *)(a2 + 32) = v4;
  return std::vector<unsigned short>::vector((_QWORD *)(a2 + 80), (uint64_t)(a1 + 5));
}

void std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::destroy(uint64_t a1)
{
}

void std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::destroy_deallocate(void *a1)
{
  operator delete(a1);
}

BOOL std::__function::__func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::operator()(_QWORD *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  unsigned int v17;

  v2 = (unsigned __int16 *)a1[1];
  v3 = (unsigned __int16 *)a1[2];
  if (v3 == v2)
    return 0;
  v4 = *a2;
  v5 = v3 - v2;
  do
  {
    v6 = v5 >> 1;
    v7 = &v2[v5 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v5 += ~(v5 >> 1);
    if (v9 < v4)
      v2 = v8;
    else
      v5 = v6;
  }
  while (v5);
  if (v2 == v3 || *v2 > v4)
    return 0;
  v11 = (unsigned __int16 *)a1[10];
  v12 = (unsigned __int16 *)a1[11];
  if (v12 == v11)
    return 1;
  v13 = v12 - v11;
  do
  {
    v14 = v13 >> 1;
    v15 = &v11[v13 >> 1];
    v17 = *v15;
    v16 = v15 + 1;
    v13 += ~(v13 >> 1);
    if (v17 < v4)
      v11 = v16;
    else
      v13 = v14;
  }
  while (v13);
  return v11 == v12 || *v11 > v4;
}

void std::__function::__alloc_func<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<`anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,`anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::destroy[abi:nn180100](uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  v3 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v3;
    operator delete(v3);
  }
}

BOOL `anonymous namespace'::MorxContextualSubtableBuilder::StateNeedsAction(_anonymous_namespace_::MorxContextualSubtableBuilder *this, int a2, int a3)
{
  uint64_t v4;

  v4 = 0;
}

void AddGlyphClassesByAppearance(unsigned __int16 **a1, __CFData *a2, unsigned __int16 a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  unsigned __int16 **v5;
  unsigned __int16 *v7;
  _QWORD *v10;
  char v11;
  int v12;
  unsigned __int16 *v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  uint64_t v19;
  unint64_t v20;
  unsigned __int16 *v21;
  unint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  unsigned int v25;
  uint64_t v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  unsigned __int16 *v29;
  unsigned __int16 v30;
  unsigned __int16 *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  unsigned __int16 *v37;
  char *v38;
  uint64_t v39;
  unsigned __int16 **v40;
  char *v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  unsigned __int16 v44;
  unsigned __int16 *v45;
  int64_t v46;
  char *v47;
  char *v48;
  unsigned __int16 *v49;
  unint64_t v50;
  void *v51;
  char *v52;
  uint64_t v53;
  void *v54;
  char *v55;
  unsigned __int16 *v56;
  unsigned __int16 *v57;
  unsigned __int16 *v58;
  int v59;
  int v60;
  unsigned __int16 *v61;
  int v62;
  unsigned __int16 *v63;
  unsigned __int16 *v64;
  uint64_t v65;

  v5 = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a4 != a5)
  {
    v7 = a4;
    v10 = a1 + 2;
    v65 = (uint64_t)(a1 + 2);
    while (1)
    {
      v11 = 0;
      v12 = *((_DWORD *)v7 + 1);
      v13 = v7;
      while (1)
      {
        v14 = *v13;
        v15 = LKTGetValue(a2, v14);
        if ((v15 & 0xFF0000) != 0)
        {
          v11 = 1;
          a3 = v15;
        }
        else
        {
          LKTAddRange(a2, v14, v14, a3);
        }
        v7 = v13 + 4;
        if (v13 + 4 == a5)
          break;
        v16 = *((_DWORD *)v13 + 3);
        v13 += 4;
        if (v16 != v12)
          goto LABEL_11;
      }
      v7 = a5;
LABEL_11:
      v18 = *v5;
      v17 = v5[1];
      v19 = (char *)v17 - (char *)*v5;
      if (v17 == *v5)
      {
        v21 = v5[1];
      }
      else
      {
        v20 = v19 >> 1;
        v21 = *v5;
        do
        {
          v22 = v20 >> 1;
          v23 = &v21[v20 >> 1];
          v25 = *v23;
          v24 = v23 + 1;
          v20 += ~(v20 >> 1);
          if (v25 < a3)
            v21 = v24;
          else
            v20 = v22;
        }
        while (v20);
      }
      v26 = (char *)v21 - (char *)v18;
      v27 = (unsigned __int16 *)((char *)v18 + (((char *)v21 - (char *)v18) & 0xFFFFFFFFFFFFFFFELL));
      if ((unint64_t)v17 >= *v10)
        break;
      if (v27 == v17)
      {
        *v17 = a3;
        v5 = a1;
        a1[1] = v17 + 1;
      }
      else
      {
        v28 = v17 - 1;
        v29 = v17;
        v5 = a1;
        if ((unint64_t)v17 >= 2)
        {
          do
          {
            v30 = *v28++;
            *v29++ = v30;
          }
          while (v28 < v17);
        }
        a1[1] = v29;
        if (v17 != v27 + 1)
        {
          v31 = v27;
          memmove(&v17[-(v17 - (v27 + 1))], v27, (char *)v17 - (char *)(v27 + 1));
          v27 = v31;
        }
        *v27 = a3;
      }
LABEL_51:
      a3 += (v11 & 1) == 0;
      if (v7 == a5)
      {
        v57 = *v5;
        v56 = v5[1];
        goto LABEL_60;
      }
    }
    if (v19 <= -3)
      abort();
    v32 = *v10 - (_QWORD)v18;
    if (v32 <= (v19 >> 1) + 1)
      v33 = (v19 >> 1) + 1;
    else
      v33 = *v10 - (_QWORD)v18;
    if (v32 >= 0x7FFFFFFFFFFFFFFELL)
      v34 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v34 = v33;
    if (v34)
    {
      v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)v10, v34);
      v27 = (unsigned __int16 *)((char *)v18 + (((char *)v21 - (char *)v18) & 0xFFFFFFFFFFFFFFFELL));
    }
    else
    {
      v35 = 0;
    }
    v36 = v26 >> 1;
    v37 = (unsigned __int16 *)&v35[2 * (v26 >> 1)];
    v38 = &v35[2 * v34];
    if (v26 >> 1 == v34)
    {
      if (v26 < 1)
      {
        v64 = v27;
        if (v21 == v18)
          v50 = 1;
        else
          v50 = (char *)v21 - (char *)v18;
        v51 = v35;
        v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v65, v50);
        v37 = (unsigned __int16 *)&v52[2 * (v50 >> 2)];
        v38 = &v52[2 * v53];
        if (v51)
        {
          v54 = v51;
          v55 = v38;
          operator delete(v54);
          v38 = v55;
        }
        v40 = a1;
        v27 = v64;
        goto LABEL_44;
      }
      if (v36 >= -1)
        v39 = v36 + 1;
      else
        v39 = v36 + 2;
      v37 = (unsigned __int16 *)((char *)v37 - (v39 & 0xFFFFFFFFFFFFFFFELL));
    }
    v40 = a1;
LABEL_44:
    *v37 = a3;
    v41 = (char *)(v37 + 1);
    v42 = *v40;
    if (*v40 != v27)
    {
      v43 = v27;
      do
      {
        v44 = *--v43;
        *--v37 = v44;
      }
      while (v43 != v42);
    }
    v45 = v40[1];
    v46 = (char *)v45 - (char *)v27;
    if (v45 != v27)
    {
      v47 = v38;
      memmove(v41, v27, (char *)v45 - (char *)v27);
      v38 = v47;
    }
    v48 = &v41[v46];
    v5 = a1;
    v49 = *a1;
    *a1 = v37;
    a1[1] = (unsigned __int16 *)v48;
    a1[2] = (unsigned __int16 *)v38;
    v10 = (_QWORD *)v65;
    if (v49)
      operator delete(v49);
    goto LABEL_51;
  }
  v56 = 0;
  v57 = 0;
LABEL_60:
  if (v57 != v56)
  {
    v58 = v57 + 1;
    while (v58 != v56)
    {
      v59 = *(v58 - 1);
      v60 = *v58++;
      if (v59 == v60)
      {
        v61 = v58 - 2;
        while (v58 != v56)
        {
          v62 = v59;
          v59 = *v58;
          if (v62 != v59)
          {
            v61[1] = v59;
            ++v61;
          }
          ++v58;
        }
        v63 = v61 + 1;
        goto LABEL_71;
      }
    }
  }
  v63 = v56;
LABEL_71:
  if (v56 != v63)
    v5[1] = v63;
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::push_back[abi:nn180100](_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  __int128 v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  void *v20;
  void *v21;
  _QWORD *v22;

  v4 = (_QWORD *)a1[1];
  v5 = a1[2];
  if ((unint64_t)v4 < v5)
  {
    v6 = std::vector<unsigned short>::vector(v4, a2) + 3;
    goto LABEL_27;
  }
  v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a1) >> 3);
  if (v7 + 1 > 0xAAAAAAAAAAAAAAALL)
    abort();
  v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
  v9 = 2 * v8;
  if (2 * v8 <= v7 + 1)
    v9 = v7 + 1;
  if (v8 >= 0x555555555555555)
    v10 = 0xAAAAAAAAAAAAAAALL;
  else
    v10 = v9;
  if (v10)
    v11 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)(a1 + 3), v10);
  else
    v11 = 0;
  v12 = &v11[24 * v10];
  v13 = std::vector<unsigned short>::vector(&v11[24 * v7], a2);
  v6 = v13 + 3;
  v14 = (_QWORD *)*a1;
  v15 = (_QWORD *)a1[1];
  if (v15 == (_QWORD *)*a1)
  {
    *a1 = v13;
    a1[1] = v6;
    v18 = a1[2];
    a1[2] = v12;
    if (!v15)
      goto LABEL_27;
    goto LABEL_22;
  }
  do
  {
    *(v13 - 3) = 0;
    *(v13 - 2) = 0;
    v13 -= 3;
    v13[2] = 0;
    v16 = *(_OWORD *)(v15 - 3);
    v15 -= 3;
    *(_OWORD *)v13 = v16;
    v13[2] = v15[2];
    *v15 = 0;
    v15[1] = 0;
    v15[2] = 0;
  }
  while (v15 != v14);
  v15 = (_QWORD *)*a1;
  v17 = (_QWORD *)a1[1];
  *a1 = v13;
  a1[1] = v6;
  v18 = a1[2];
  a1[2] = v12;
  if (v17 != v15)
  {
    v19 = v17;
    do
    {
      v21 = (void *)*(v19 - 3);
      v19 -= 3;
      v20 = v21;
      if (v21)
      {
        *(v17 - 2) = v20;
        operator delete(v20);
      }
      v17 = v19;
    }
    while (v19 != v15);
  }
  if (v15)
  {
LABEL_22:
    if (a1 + 3 > v15 || (v22 = a1 + 93, a1 + 93 <= v15))
    {
      operator delete(v15);
    }
    else if (v18 == *v22)
    {
      *v22 = v15;
    }
  }
LABEL_27:
  a1[1] = v6;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(float *a1, unsigned __int16 a2, _WORD *a3)
{
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v33;

  v5 = a2;
  v6 = *((_QWORD *)a1 + 1);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = ((_DWORD)v6 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int16 *)v10 + 8) == a2)
              return v10;
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6)
                v11 %= v6;
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAAALL;
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v5;
  *((_WORD *)v10 + 8) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  v12 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v13 = a1[8];
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    v14 = 1;
    if (v6 >= 3)
      v14 = (v6 & (v6 - 1)) != 0;
    v15 = v14 | (2 * v6);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      prime = (int8x8_t)v16;
    else
      prime = (int8x8_t)v15;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v6 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v6)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v6)
    {
      v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        v24 = std::__next_prime(v24);
      }
      else
      {
        v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2)
          v24 = v26;
      }
      if (*(_QWORD *)&prime <= v24)
        prime = (int8x8_t)v24;
      if (*(_QWORD *)&prime >= v6)
      {
        v6 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v18 = operator new(8 * *(_QWORD *)&prime);
          v19 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v18;
          if (v19)
            operator delete(v19);
          v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v20++) = 0;
          while (*(_QWORD *)&prime != v20);
          v21 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v21)
          {
            v22 = v21[1];
            v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(_QWORD *)&prime)
                v22 %= *(_QWORD *)&prime;
            }
            else
            {
              v22 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = a1 + 4;
            v27 = (_QWORD *)*v21;
            if (*v21)
            {
              do
              {
                v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(_QWORD *)&prime)
                    v28 %= *(_QWORD *)&prime;
                }
                else
                {
                  v28 &= *(_QWORD *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v28))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  *v21 = *v27;
                  *v27 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v28);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v28) = v27;
                  v27 = v21;
                }
                v28 = v22;
LABEL_55:
                v21 = v27;
                v27 = (_QWORD *)*v27;
                v22 = v28;
              }
              while (v27);
            }
          }
          v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        v33 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v33)
          operator delete(v33);
        v6 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5)
        v8 = v5 % v6;
      else
        v8 = v5;
    }
    else
    {
      v8 = ((_DWORD)v6 - 1) & v5;
    }
  }
  v29 = *(_QWORD **)a1;
  v30 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v30)
  {
    *v10 = *v30;
LABEL_72:
    *v30 = v10;
    goto LABEL_73;
  }
  *v10 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v10;
  v29[v8] = a1 + 4;
  if (*v10)
  {
    v31 = *(_QWORD *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6)
        v31 %= v6;
    }
    else
    {
      v31 &= v6 - 1;
    }
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return v10;
}

void std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E15DFEA8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DFEA8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(_QWORD *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  _QWORD *v5;
  int v6;
  __int16 v8;

  v3 = *a2;
  v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    v5 = result;
    do
    {
      v8 = v3;
      v6 = *(_DWORD *)v5[2];
      result = std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((float *)v5[1], v3, &v8);
      *((_DWORD *)result + 5) |= v6;
    }
    while (v4 != (unsigned __int16)v3++);
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *,false>(uint64_t result, _DWORD *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  _DWORD *v20;
  _DWORD *v21;
  unsigned int v22;
  _DWORD *v23;
  unsigned int v24;
  unint64_t v25;
  __int16 v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35;
  unsigned int v36;
  _DWORD *v37;
  _DWORD *v38;
  unsigned int v39;
  __int16 v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  __int16 v46;
  unsigned int v47;
  unsigned int v48;
  __int16 v49;
  unsigned int v50;
  unsigned int v51;
  __int16 v52;
  __int16 v53;
  unsigned int v54;
  __int16 v55;
  unsigned int v56;
  __int16 v57;
  _DWORD *v58;
  BOOL v60;
  uint64_t v61;
  _DWORD *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  uint64_t v73;
  int *v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  int *v78;
  int v79;
  unsigned int v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  _DWORD *v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  unint64_t v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  _DWORD *v98;
  _DWORD *v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  _DWORD *v105;
  _DWORD *v106;
  int v107;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = (uint64_t)((uint64_t)a2 - v8) >> 3;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v44 = *(a2 - 1);
        v45 = *(_DWORD *)(v8 + 4);
        if (v44 < v45)
        {
          v46 = *(_WORD *)v8;
          *(_WORD *)v8 = *((_WORD *)a2 - 4);
          *((_WORD *)a2 - 4) = v46;
          *(_DWORD *)(v8 + 4) = v44;
          *(a2 - 1) = v45;
        }
        return result;
      case 3uLL:
      case 4uLL:
      case 5uLL:
        v47 = *(a2 - 1);
        v48 = *(_DWORD *)(v8 + 28);
        if (v47 < v48)
        {
          v49 = *(_WORD *)(v8 + 24);
          *(_WORD *)(v8 + 24) = *((_WORD *)a2 - 4);
          *((_WORD *)a2 - 4) = v49;
          *(_DWORD *)(v8 + 28) = v47;
          *(a2 - 1) = v48;
          v50 = *(_DWORD *)(v8 + 28);
          v51 = *(_DWORD *)(v8 + 20);
          if (v50 < v51)
          {
            v52 = *(_WORD *)(v8 + 16);
            v53 = *(_WORD *)(v8 + 24);
            *(_WORD *)(v8 + 16) = v53;
            *(_WORD *)(v8 + 24) = v52;
            *(_DWORD *)(v8 + 20) = v50;
            *(_DWORD *)(v8 + 28) = v51;
            v54 = *(_DWORD *)(v8 + 12);
            if (v50 < v54)
            {
              v55 = *(_WORD *)(v8 + 8);
              *(_WORD *)(v8 + 8) = v53;
              *(_WORD *)(v8 + 16) = v55;
              *(_DWORD *)(v8 + 12) = v50;
              *(_DWORD *)(v8 + 20) = v54;
              v56 = *(_DWORD *)(v8 + 4);
              if (v50 < v56)
              {
                v57 = *(_WORD *)v8;
                *(_WORD *)v8 = v53;
                *(_WORD *)(v8 + 8) = v57;
                *(_DWORD *)(v8 + 4) = v50;
                *(_DWORD *)(v8 + 12) = v56;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 191)
        {
          v58 = (_DWORD *)(v8 + 8);
          v60 = (_DWORD *)v8 == a2 || v58 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v60)
            {
              v61 = 0;
              v62 = (_DWORD *)v8;
              do
              {
                v63 = v62[3];
                v64 = v62[1];
                v62 = v58;
                if (v63 < v64)
                {
                  v65 = *v58;
                  v66 = v62[1];
                  v67 = v61;
                  while (1)
                  {
                    v68 = v8 + v67;
                    *(_WORD *)(v68 + 8) = *(_WORD *)(v8 + v67);
                    *(_DWORD *)(v68 + 12) = *(_DWORD *)(v8 + v67 + 4);
                    if (!v67)
                      break;
                    v67 -= 8;
                    if (*(_DWORD *)(v68 - 4) <= v66)
                    {
                      v69 = v8 + v67 + 8;
                      goto LABEL_78;
                    }
                  }
                  v69 = v8;
LABEL_78:
                  *(_WORD *)v69 = v65;
                  *(_DWORD *)(v69 + 4) = v66;
                }
                v58 = v62 + 2;
                v61 += 8;
              }
              while (v62 + 2 != a2);
            }
          }
          else if (!v60)
          {
            v100 = (_DWORD *)(v8 + 12);
            do
            {
              v101 = *(_DWORD *)(v7 + 12);
              v102 = *(_DWORD *)(v7 + 4);
              v7 = (uint64_t)v58;
              if (v101 < v102)
              {
                v103 = *(_QWORD *)v58;
                v104 = HIDWORD(*(_QWORD *)v7);
                v105 = v100;
                do
                {
                  v106 = v105;
                  *((_WORD *)v105 - 2) = *((_WORD *)v105 - 6);
                  v107 = *(v105 - 2);
                  v105 -= 2;
                  *v106 = v107;
                }
                while (*(v106 - 4) > v104);
                *((_WORD *)v105 - 2) = v103;
                *v105 = v104;
              }
              v58 = (_DWORD *)(v7 + 8);
              v100 += 2;
            }
            while ((_DWORD *)(v7 + 8) != a2);
          }
          return result;
        }
        if (!a3)
        {
          if ((_DWORD *)v8 != a2)
          {
            v70 = (v10 - 2) >> 1;
            v71 = v70;
            do
            {
              v72 = v71;
              if (v70 >= v71)
              {
                v73 = (2 * v71) | 1;
                v74 = (int *)(v8 + 8 * v73);
                if (2 * v72 + 2 < (uint64_t)v10)
                {
                  v75 = v74[1];
                  v76 = v74[3];
                  v74 += 2 * (v75 < v76);
                  if (v75 < v76)
                    v73 = 2 * v72 + 2;
                }
                v77 = v74[1];
                if (v77 >= *(_DWORD *)(v8 + 8 * v72 + 4))
                {
                  v78 = (int *)(v8 + 8 * v72);
                  v79 = *v78;
                  v80 = v78[1];
                  do
                  {
                    result = (uint64_t)v78;
                    v78 = v74;
                    *(_WORD *)result = *(_WORD *)v74;
                    *(_DWORD *)(result + 4) = v77;
                    if (v70 < v73)
                      break;
                    result = (2 * v73) | 1;
                    v74 = (int *)(v8 + 8 * result);
                    v81 = 2 * v73 + 2;
                    if (v81 < (uint64_t)v10)
                    {
                      v82 = v74[1];
                      v83 = v74[3];
                      v74 += 2 * (v82 < v83);
                      if (v82 < v83)
                        result = v81;
                    }
                    v77 = v74[1];
                    v73 = result;
                  }
                  while (v77 >= v80);
                  *(_WORD *)v78 = v79;
                  v78[1] = v80;
                }
              }
              v71 = v72 - 1;
            }
            while (v72);
            v84 = (unint64_t)v9 >> 3;
            do
            {
              v85 = 0;
              v86 = *(_QWORD *)v8;
              v87 = v8;
              do
              {
                v88 = (_DWORD *)(v87 + 8 * (v85 + 1));
                v89 = (2 * v85) | 1;
                v90 = 2 * v85 + 2;
                if (v90 < v84)
                {
                  v91 = v88[1];
                  v92 = v88[3];
                  v88 += 2 * (v91 < v92);
                  if (v91 < v92)
                    v89 = v90;
                }
                *(_WORD *)v87 = *(_WORD *)v88;
                *(_DWORD *)(v87 + 4) = v88[1];
                v87 = (unint64_t)v88;
                v85 = v89;
              }
              while (v89 <= (uint64_t)((unint64_t)(v84 - 2) >> 1));
              if (v88 == a2 - 2)
              {
                *(_WORD *)v88 = v86;
                v88[1] = HIDWORD(v86);
              }
              else
              {
                *(_WORD *)v88 = *((_WORD *)a2 - 4);
                v88[1] = *(a2 - 1);
                *((_WORD *)a2 - 4) = v86;
                *(a2 - 1) = HIDWORD(v86);
                v93 = (uint64_t)v88 - v8 + 8;
                if (v93 >= 9)
                {
                  v94 = (((unint64_t)v93 >> 3) - 2) >> 1;
                  v95 = *(_DWORD *)(v8 + 8 * v94 + 4);
                  if (v95 < v88[1])
                  {
                    v96 = *v88;
                    v97 = v88[1];
                    do
                    {
                      v98 = v88;
                      v88 = (_DWORD *)(v8 + 8 * v94);
                      *(_WORD *)v98 = *(_WORD *)v88;
                      v98[1] = v95;
                      if (!v94)
                        break;
                      v94 = (v94 - 1) >> 1;
                      v95 = *(_DWORD *)(v8 + 8 * v94 + 4);
                    }
                    while (v95 < v97);
                    *(_WORD *)v88 = v96;
                    v88[1] = v97;
                  }
                }
              }
              a2 -= 2;
            }
            while (v84-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = v8 + 8 * (v10 >> 1);
        if ((unint64_t)v9 < 0x401)
        {
        }
        else
        {
          v13 = *(_WORD *)v7;
          *(_WORD *)v7 = *(_WORD *)v12;
          *(_WORD *)v12 = v13;
          v14 = *(_DWORD *)(v7 + 4);
          *(_DWORD *)(v7 + 4) = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(v12 + 4) = v14;
        }
        --a3;
        if ((a4 & 1) == 0 && *(_DWORD *)(v7 - 4) >= *(_DWORD *)(v7 + 4))
        {
          v31 = *(_QWORD *)v7;
          v32 = HIDWORD(*(_QWORD *)v7);
          if (*(a2 - 1) <= v32)
          {
            v35 = v7 + 8;
            do
            {
              v8 = v35;
              if (v35 >= (unint64_t)a2)
                break;
              v36 = *(_DWORD *)(v35 + 4);
              v35 += 8;
            }
            while (v36 <= v32);
          }
          else
          {
            v33 = v7;
            do
            {
              v8 = v33 + 8;
              v34 = *(_DWORD *)(v33 + 12);
              v33 += 8;
            }
            while (v34 <= v32);
          }
          v37 = a2;
          if (v8 < (unint64_t)a2)
          {
            v38 = a2;
            do
            {
              v37 = v38 - 2;
              v39 = *(v38 - 1);
              v38 -= 2;
            }
            while (v39 > v32);
          }
          while (v8 < (unint64_t)v37)
          {
            v40 = *(_WORD *)v8;
            *(_WORD *)v8 = *(_WORD *)v37;
            *(_WORD *)v37 = v40;
            v41 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = v37[1];
            v37[1] = v41;
            do
            {
              v42 = *(_DWORD *)(v8 + 12);
              v8 += 8;
            }
            while (v42 <= v32);
            do
            {
              v43 = *(v37 - 1);
              v37 -= 2;
            }
            while (v43 > v32);
          }
          if (v8 - 8 != v7)
          {
            *(_WORD *)v7 = *(_WORD *)(v8 - 8);
            *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 4);
          }
          a4 = 0;
          *(_WORD *)(v8 - 8) = v31;
          *(_DWORD *)(v8 - 4) = v32;
          continue;
        }
        v15 = 0;
        v16 = *(_QWORD *)v7;
        v17 = HIDWORD(*(_QWORD *)v7);
        do
        {
          v18 = *(_DWORD *)(v7 + v15 + 12);
          v15 += 8;
        }
        while (v18 < v17);
        v19 = v7 + v15;
        v20 = a2;
        if (v15 == 8)
        {
          v23 = a2;
          while (v19 < (unint64_t)v23)
          {
            v21 = v23 - 2;
            v24 = *(v23 - 1);
            v23 -= 2;
            if (v24 < v17)
              goto LABEL_21;
          }
          v21 = v23;
        }
        else
        {
          do
          {
            v21 = v20 - 2;
            v22 = *(v20 - 1);
            v20 -= 2;
          }
          while (v22 >= v17);
        }
LABEL_21:
        v8 = v19;
        if (v19 < (unint64_t)v21)
        {
          v25 = (unint64_t)v21;
          do
          {
            v26 = *(_WORD *)v8;
            *(_WORD *)v8 = *(_WORD *)v25;
            *(_WORD *)v25 = v26;
            v27 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = *(_DWORD *)(v25 + 4);
            *(_DWORD *)(v25 + 4) = v27;
            do
            {
              v28 = *(_DWORD *)(v8 + 12);
              v8 += 8;
            }
            while (v28 < v17);
            do
            {
              v29 = *(_DWORD *)(v25 - 4);
              v25 -= 8;
            }
            while (v29 >= v17);
          }
          while (v8 < v25);
        }
        if (v8 - 8 != v7)
        {
          *(_WORD *)v7 = *(_WORD *)(v8 - 8);
          *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 4);
        }
        *(_WORD *)(v8 - 8) = v16;
        *(_DWORD *)(v8 - 4) = v17;
        if (v19 < (unint64_t)v21)
        {
LABEL_32:
          a4 = 0;
          continue;
        }
        if (!(_DWORD)result)
        {
          if (v30)
            continue;
          goto LABEL_32;
        }
        a2 = (_DWORD *)(v8 - 8);
        if (!v30)
          goto LABEL_2;
        return result;
    }
  }
}

__int16 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *>(__int16 *result, __int16 *a2, __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  __int16 v6;
  __int16 v7;
  unsigned int v8;
  unsigned int v9;
  __int16 v10;
  unsigned int v11;

  v3 = *((_DWORD *)a2 + 1);
  v4 = *((_DWORD *)result + 1);
  v5 = *((_DWORD *)a3 + 1);
  if (v3 >= v4)
  {
    if (v5 < v3)
    {
      v7 = *a2;
      *a2 = *a3;
      *a3 = v7;
      *((_DWORD *)a2 + 1) = v5;
      *((_DWORD *)a3 + 1) = v3;
      v8 = *((_DWORD *)a2 + 1);
      v9 = *((_DWORD *)result + 1);
      if (v8 < v9)
      {
        v10 = *result;
        *result = *a2;
        *a2 = v10;
        *((_DWORD *)result + 1) = v8;
        *((_DWORD *)a2 + 1) = v9;
      }
    }
  }
  else
  {
    v6 = *result;
    if (v5 >= v3)
    {
      *result = *a2;
      *a2 = v6;
      *((_DWORD *)result + 1) = v3;
      *((_DWORD *)a2 + 1) = v4;
      v11 = *((_DWORD *)a3 + 1);
      if (v11 >= v4)
        return result;
      *a2 = *a3;
      *a3 = v6;
      *((_DWORD *)a2 + 1) = v11;
    }
    else
    {
      *result = *a3;
      *a3 = v6;
      *((_DWORD *)result + 1) = v5;
    }
    *((_DWORD *)a3 + 1) = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned int v6;
  unsigned int v7;
  __int16 v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  __int16 v20;
  unsigned int v21;
  unsigned int v22;
  __int16 v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  unsigned int v27;
  __int16 v28;

  v4 = ((uint64_t)a2 - a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *(_DWORD *)(a1 + 4);
      if (v6 < v7)
      {
        v8 = *(_WORD *)a1;
        *(_WORD *)a1 = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4) = v8;
        *(_DWORD *)(a1 + 4) = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      v18 = *(a2 - 1);
      v19 = *(_DWORD *)(a1 + 28);
      if (v18 < v19)
      {
        v20 = *(_WORD *)(a1 + 24);
        *(_WORD *)(a1 + 24) = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4) = v20;
        *(_DWORD *)(a1 + 28) = v18;
        *(a2 - 1) = v19;
        v21 = *(_DWORD *)(a1 + 28);
        v22 = *(_DWORD *)(a1 + 20);
        if (v21 < v22)
        {
          v23 = *(_WORD *)(a1 + 16);
          v24 = *(_WORD *)(a1 + 24);
          *(_WORD *)(a1 + 16) = v24;
          *(_WORD *)(a1 + 24) = v23;
          *(_DWORD *)(a1 + 20) = v21;
          *(_DWORD *)(a1 + 28) = v22;
          v25 = *(_DWORD *)(a1 + 12);
          if (v21 < v25)
          {
            v26 = *(_WORD *)(a1 + 8);
            *(_WORD *)(a1 + 8) = v24;
            *(_WORD *)(a1 + 16) = v26;
            *(_DWORD *)(a1 + 12) = v21;
            *(_DWORD *)(a1 + 20) = v25;
            v27 = *(_DWORD *)(a1 + 4);
            if (v21 < v27)
            {
              v28 = *(_WORD *)a1;
              *(_WORD *)a1 = v24;
              *(_WORD *)(a1 + 8) = v28;
              *(_DWORD *)(a1 + 4) = v21;
              *(_DWORD *)(a1 + 12) = v27;
            }
          }
        }
      }
      return 1;
    default:
      v9 = (_DWORD *)(a1 + 16);
      v10 = (_DWORD *)(a1 + 24);
      if ((_DWORD *)(a1 + 24) == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (v10[1] < v9[1])
    {
      v13 = *v10;
      v14 = v10[1];
      v15 = v11;
      while (1)
      {
        v16 = a1 + v15;
        *(_WORD *)(v16 + 24) = *(_WORD *)(a1 + v15 + 16);
        *(_DWORD *)(v16 + 28) = *(_DWORD *)(a1 + v15 + 20);
        if (v15 == -16)
          break;
        v15 -= 8;
        if (*(_DWORD *)(v16 + 12) <= v14)
        {
          v17 = a1 + v15 + 24;
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *(_WORD *)v17 = v13;
      *(_DWORD *)(v17 + 4) = v14;
      if (++v12 == 8)
        return v10 + 2 == a2;
    }
    v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2)
      return 1;
  }
}

__int16 *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 *result;
  unsigned int v9;
  unsigned int v10;
  __int16 v11;
  unsigned int v12;
  unsigned int v13;
  __int16 v14;
  unsigned int v15;
  unsigned int v16;
  __int16 v17;

  v9 = *(_DWORD *)(a4 + 4);
  v10 = *(_DWORD *)(a3 + 4);
  if (v9 < v10)
  {
    v11 = *(_WORD *)a3;
    *(_WORD *)a3 = *(_WORD *)a4;
    *(_WORD *)a4 = v11;
    *(_DWORD *)(a3 + 4) = v9;
    *(_DWORD *)(a4 + 4) = v10;
    v12 = *(_DWORD *)(a3 + 4);
    v13 = *(_DWORD *)(a2 + 4);
    if (v12 < v13)
    {
      v14 = *(_WORD *)a2;
      *(_WORD *)a2 = *(_WORD *)a3;
      *(_WORD *)a3 = v14;
      *(_DWORD *)(a2 + 4) = v12;
      *(_DWORD *)(a3 + 4) = v13;
      v15 = *(_DWORD *)(a2 + 4);
      v16 = *(_DWORD *)(a1 + 4);
      if (v15 < v16)
      {
        v17 = *(_WORD *)a1;
        *(_WORD *)a1 = *(_WORD *)a2;
        *(_WORD *)a2 = v17;
        *(_DWORD *)(a1 + 4) = v15;
        *(_DWORD *)(a2 + 4) = v16;
      }
    }
  }
  return result;
}

void std::vector<std::pair<unsigned short,unsigned int>,TInlineBufferAllocator<std::pair<unsigned short,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  BOOL v4;
  BOOL v5;

  v2 = *(_QWORD **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    v3 = (_QWORD *)(a1 + 264);
    if (a1 + 24 <= (unint64_t)v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 264))
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E15DFEF0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15DFEF0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  char **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  BOOL v23;
  __int16 v24;
  _QWORD v25[5];

  v3 = *a2;
  v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    v5 = result;
    do
    {
      v24 = v3;
      v6 = *(char ***)(v5 + 8);
      result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(*(float **)(v5 + 16), v3, &v24);
      v7 = result;
      v9 = (unint64_t)v6[1];
      v8 = (unint64_t)v6[2];
      if (v9 >= v8)
      {
        v11 = (uint64_t)(v9 - (_QWORD)*v6) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          abort();
        v13 = v8 - (_QWORD)*v6;
        if (v13 >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        v25[4] = v6 + 3;
        v15 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(v6 + 3), v14);
        v16 = &v15[8 * v11];
        *(_WORD *)v16 = v3;
        *((_DWORD *)v16 + 1) = *(_DWORD *)(v7 + 20);
        v18 = *v6;
        v17 = v6[1];
        if (v17 == *v6)
        {
          v21 = v6[1];
          v19 = &v15[8 * v11];
        }
        else
        {
          v19 = &v15[8 * v11];
          do
          {
            v20 = *((_QWORD *)v17 - 1);
            v17 -= 8;
            *((_QWORD *)v19 - 1) = v20;
            v19 -= 8;
          }
          while (v17 != v18);
          v21 = *v6;
          v17 = v6[1];
        }
        v10 = v16 + 8;
        *v6 = v19;
        v25[0] = v21;
        v25[1] = v21;
        v6[1] = v16 + 8;
        v25[2] = v17;
        v22 = v6[2];
        v6[2] = &v15[8 * v14];
        v25[3] = v22;
        result = std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v25);
      }
      else
      {
        *(_WORD *)v9 = v3;
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(result + 20);
        v10 = (char *)(v9 + 8);
      }
      v6[1] = v10;
      v23 = v4 == (unsigned __int16)v3;
      LOWORD(v3) = v3 + 1;
    }
    while (!v23);
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_1 &,std::pair<unsigned short,unsigned int> *,false>(uint64_t result, _DWORD *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  _DWORD *v20;
  _DWORD *v21;
  unsigned int v22;
  _DWORD *v23;
  unsigned int v24;
  unint64_t v25;
  __int16 v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35;
  unsigned int v36;
  _DWORD *v37;
  _DWORD *v38;
  unsigned int v39;
  __int16 v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  __int16 v46;
  unsigned int v47;
  unsigned int v48;
  __int16 v49;
  unsigned int v50;
  unsigned int v51;
  __int16 v52;
  __int16 v53;
  unsigned int v54;
  __int16 v55;
  unsigned int v56;
  __int16 v57;
  _DWORD *v58;
  BOOL v60;
  uint64_t v61;
  _DWORD *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  uint64_t v73;
  int *v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  int *v78;
  int v79;
  unsigned int v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  _DWORD *v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  unint64_t v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  _DWORD *v98;
  _DWORD *v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  _DWORD *v105;
  _DWORD *v106;
  int v107;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = (uint64_t)((uint64_t)a2 - v8) >> 3;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v44 = *(a2 - 1);
        v45 = *(_DWORD *)(v8 + 4);
        if (v44 < v45)
        {
          v46 = *(_WORD *)v8;
          *(_WORD *)v8 = *((_WORD *)a2 - 4);
          *((_WORD *)a2 - 4) = v46;
          *(_DWORD *)(v8 + 4) = v44;
          *(a2 - 1) = v45;
        }
        return result;
      case 3uLL:
      case 4uLL:
      case 5uLL:
        v47 = *(a2 - 1);
        v48 = *(_DWORD *)(v8 + 28);
        if (v47 < v48)
        {
          v49 = *(_WORD *)(v8 + 24);
          *(_WORD *)(v8 + 24) = *((_WORD *)a2 - 4);
          *((_WORD *)a2 - 4) = v49;
          *(_DWORD *)(v8 + 28) = v47;
          *(a2 - 1) = v48;
          v50 = *(_DWORD *)(v8 + 28);
          v51 = *(_DWORD *)(v8 + 20);
          if (v50 < v51)
          {
            v52 = *(_WORD *)(v8 + 16);
            v53 = *(_WORD *)(v8 + 24);
            *(_WORD *)(v8 + 16) = v53;
            *(_WORD *)(v8 + 24) = v52;
            *(_DWORD *)(v8 + 20) = v50;
            *(_DWORD *)(v8 + 28) = v51;
            v54 = *(_DWORD *)(v8 + 12);
            if (v50 < v54)
            {
              v55 = *(_WORD *)(v8 + 8);
              *(_WORD *)(v8 + 8) = v53;
              *(_WORD *)(v8 + 16) = v55;
              *(_DWORD *)(v8 + 12) = v50;
              *(_DWORD *)(v8 + 20) = v54;
              v56 = *(_DWORD *)(v8 + 4);
              if (v50 < v56)
              {
                v57 = *(_WORD *)v8;
                *(_WORD *)v8 = v53;
                *(_WORD *)(v8 + 8) = v57;
                *(_DWORD *)(v8 + 4) = v50;
                *(_DWORD *)(v8 + 12) = v56;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 191)
        {
          v58 = (_DWORD *)(v8 + 8);
          v60 = (_DWORD *)v8 == a2 || v58 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v60)
            {
              v61 = 0;
              v62 = (_DWORD *)v8;
              do
              {
                v63 = v62[3];
                v64 = v62[1];
                v62 = v58;
                if (v63 < v64)
                {
                  v65 = *v58;
                  v66 = v62[1];
                  v67 = v61;
                  while (1)
                  {
                    v68 = v8 + v67;
                    *(_WORD *)(v68 + 8) = *(_WORD *)(v8 + v67);
                    *(_DWORD *)(v68 + 12) = *(_DWORD *)(v8 + v67 + 4);
                    if (!v67)
                      break;
                    v67 -= 8;
                    if (*(_DWORD *)(v68 - 4) <= v66)
                    {
                      v69 = v8 + v67 + 8;
                      goto LABEL_78;
                    }
                  }
                  v69 = v8;
LABEL_78:
                  *(_WORD *)v69 = v65;
                  *(_DWORD *)(v69 + 4) = v66;
                }
                v58 = v62 + 2;
                v61 += 8;
              }
              while (v62 + 2 != a2);
            }
          }
          else if (!v60)
          {
            v100 = (_DWORD *)(v8 + 12);
            do
            {
              v101 = *(_DWORD *)(v7 + 12);
              v102 = *(_DWORD *)(v7 + 4);
              v7 = (uint64_t)v58;
              if (v101 < v102)
              {
                v103 = *(_QWORD *)v58;
                v104 = HIDWORD(*(_QWORD *)v7);
                v105 = v100;
                do
                {
                  v106 = v105;
                  *((_WORD *)v105 - 2) = *((_WORD *)v105 - 6);
                  v107 = *(v105 - 2);
                  v105 -= 2;
                  *v106 = v107;
                }
                while (*(v106 - 4) > v104);
                *((_WORD *)v105 - 2) = v103;
                *v105 = v104;
              }
              v58 = (_DWORD *)(v7 + 8);
              v100 += 2;
            }
            while ((_DWORD *)(v7 + 8) != a2);
          }
          return result;
        }
        if (!a3)
        {
          if ((_DWORD *)v8 != a2)
          {
            v70 = (v10 - 2) >> 1;
            v71 = v70;
            do
            {
              v72 = v71;
              if (v70 >= v71)
              {
                v73 = (2 * v71) | 1;
                v74 = (int *)(v8 + 8 * v73);
                if (2 * v72 + 2 < (uint64_t)v10)
                {
                  v75 = v74[1];
                  v76 = v74[3];
                  v74 += 2 * (v75 < v76);
                  if (v75 < v76)
                    v73 = 2 * v72 + 2;
                }
                v77 = v74[1];
                if (v77 >= *(_DWORD *)(v8 + 8 * v72 + 4))
                {
                  v78 = (int *)(v8 + 8 * v72);
                  v79 = *v78;
                  v80 = v78[1];
                  do
                  {
                    result = (uint64_t)v78;
                    v78 = v74;
                    *(_WORD *)result = *(_WORD *)v74;
                    *(_DWORD *)(result + 4) = v77;
                    if (v70 < v73)
                      break;
                    result = (2 * v73) | 1;
                    v74 = (int *)(v8 + 8 * result);
                    v81 = 2 * v73 + 2;
                    if (v81 < (uint64_t)v10)
                    {
                      v82 = v74[1];
                      v83 = v74[3];
                      v74 += 2 * (v82 < v83);
                      if (v82 < v83)
                        result = v81;
                    }
                    v77 = v74[1];
                    v73 = result;
                  }
                  while (v77 >= v80);
                  *(_WORD *)v78 = v79;
                  v78[1] = v80;
                }
              }
              v71 = v72 - 1;
            }
            while (v72);
            v84 = (unint64_t)v9 >> 3;
            do
            {
              v85 = 0;
              v86 = *(_QWORD *)v8;
              v87 = v8;
              do
              {
                v88 = (_DWORD *)(v87 + 8 * (v85 + 1));
                v89 = (2 * v85) | 1;
                v90 = 2 * v85 + 2;
                if (v90 < v84)
                {
                  v91 = v88[1];
                  v92 = v88[3];
                  v88 += 2 * (v91 < v92);
                  if (v91 < v92)
                    v89 = v90;
                }
                *(_WORD *)v87 = *(_WORD *)v88;
                *(_DWORD *)(v87 + 4) = v88[1];
                v87 = (unint64_t)v88;
                v85 = v89;
              }
              while (v89 <= (uint64_t)((unint64_t)(v84 - 2) >> 1));
              if (v88 == a2 - 2)
              {
                *(_WORD *)v88 = v86;
                v88[1] = HIDWORD(v86);
              }
              else
              {
                *(_WORD *)v88 = *((_WORD *)a2 - 4);
                v88[1] = *(a2 - 1);
                *((_WORD *)a2 - 4) = v86;
                *(a2 - 1) = HIDWORD(v86);
                v93 = (uint64_t)v88 - v8 + 8;
                if (v93 >= 9)
                {
                  v94 = (((unint64_t)v93 >> 3) - 2) >> 1;
                  v95 = *(_DWORD *)(v8 + 8 * v94 + 4);
                  if (v95 < v88[1])
                  {
                    v96 = *v88;
                    v97 = v88[1];
                    do
                    {
                      v98 = v88;
                      v88 = (_DWORD *)(v8 + 8 * v94);
                      *(_WORD *)v98 = *(_WORD *)v88;
                      v98[1] = v95;
                      if (!v94)
                        break;
                      v94 = (v94 - 1) >> 1;
                      v95 = *(_DWORD *)(v8 + 8 * v94 + 4);
                    }
                    while (v95 < v97);
                    *(_WORD *)v88 = v96;
                    v88[1] = v97;
                  }
                }
              }
              a2 -= 2;
            }
            while (v84-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = v8 + 8 * (v10 >> 1);
        if ((unint64_t)v9 < 0x401)
        {
        }
        else
        {
          v13 = *(_WORD *)v7;
          *(_WORD *)v7 = *(_WORD *)v12;
          *(_WORD *)v12 = v13;
          v14 = *(_DWORD *)(v7 + 4);
          *(_DWORD *)(v7 + 4) = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(v12 + 4) = v14;
        }
        --a3;
        if ((a4 & 1) == 0 && *(_DWORD *)(v7 - 4) >= *(_DWORD *)(v7 + 4))
        {
          v31 = *(_QWORD *)v7;
          v32 = HIDWORD(*(_QWORD *)v7);
          if (*(a2 - 1) <= v32)
          {
            v35 = v7 + 8;
            do
            {
              v8 = v35;
              if (v35 >= (unint64_t)a2)
                break;
              v36 = *(_DWORD *)(v35 + 4);
              v35 += 8;
            }
            while (v36 <= v32);
          }
          else
          {
            v33 = v7;
            do
            {
              v8 = v33 + 8;
              v34 = *(_DWORD *)(v33 + 12);
              v33 += 8;
            }
            while (v34 <= v32);
          }
          v37 = a2;
          if (v8 < (unint64_t)a2)
          {
            v38 = a2;
            do
            {
              v37 = v38 - 2;
              v39 = *(v38 - 1);
              v38 -= 2;
            }
            while (v39 > v32);
          }
          while (v8 < (unint64_t)v37)
          {
            v40 = *(_WORD *)v8;
            *(_WORD *)v8 = *(_WORD *)v37;
            *(_WORD *)v37 = v40;
            v41 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = v37[1];
            v37[1] = v41;
            do
            {
              v42 = *(_DWORD *)(v8 + 12);
              v8 += 8;
            }
            while (v42 <= v32);
            do
            {
              v43 = *(v37 - 1);
              v37 -= 2;
            }
            while (v43 > v32);
          }
          if (v8 - 8 != v7)
          {
            *(_WORD *)v7 = *(_WORD *)(v8 - 8);
            *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 4);
          }
          a4 = 0;
          *(_WORD *)(v8 - 8) = v31;
          *(_DWORD *)(v8 - 4) = v32;
          continue;
        }
        v15 = 0;
        v16 = *(_QWORD *)v7;
        v17 = HIDWORD(*(_QWORD *)v7);
        do
        {
          v18 = *(_DWORD *)(v7 + v15 + 12);
          v15 += 8;
        }
        while (v18 < v17);
        v19 = v7 + v15;
        v20 = a2;
        if (v15 == 8)
        {
          v23 = a2;
          while (v19 < (unint64_t)v23)
          {
            v21 = v23 - 2;
            v24 = *(v23 - 1);
            v23 -= 2;
            if (v24 < v17)
              goto LABEL_21;
          }
          v21 = v23;
        }
        else
        {
          do
          {
            v21 = v20 - 2;
            v22 = *(v20 - 1);
            v20 -= 2;
          }
          while (v22 >= v17);
        }
LABEL_21:
        v8 = v19;
        if (v19 < (unint64_t)v21)
        {
          v25 = (unint64_t)v21;
          do
          {
            v26 = *(_WORD *)v8;
            *(_WORD *)v8 = *(_WORD *)v25;
            *(_WORD *)v25 = v26;
            v27 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = *(_DWORD *)(v25 + 4);
            *(_DWORD *)(v25 + 4) = v27;
            do
            {
              v28 = *(_DWORD *)(v8 + 12);
              v8 += 8;
            }
            while (v28 < v17);
            do
            {
              v29 = *(_DWORD *)(v25 - 4);
              v25 -= 8;
            }
            while (v29 >= v17);
          }
          while (v8 < v25);
        }
        if (v8 - 8 != v7)
        {
          *(_WORD *)v7 = *(_WORD *)(v8 - 8);
          *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 4);
        }
        *(_WORD *)(v8 - 8) = v16;
        *(_DWORD *)(v8 - 4) = v17;
        if (v19 < (unint64_t)v21)
        {
LABEL_32:
          a4 = 0;
          continue;
        }
        if (!(_DWORD)result)
        {
          if (v30)
            continue;
          goto LABEL_32;
        }
        a2 = (_DWORD *)(v8 - 8);
        if (!v30)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_1 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned int v6;
  unsigned int v7;
  __int16 v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  __int16 v20;
  unsigned int v21;
  unsigned int v22;
  __int16 v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  unsigned int v27;
  __int16 v28;

  v4 = ((uint64_t)a2 - a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *(_DWORD *)(a1 + 4);
      if (v6 < v7)
      {
        v8 = *(_WORD *)a1;
        *(_WORD *)a1 = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4) = v8;
        *(_DWORD *)(a1 + 4) = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      v18 = *(a2 - 1);
      v19 = *(_DWORD *)(a1 + 28);
      if (v18 < v19)
      {
        v20 = *(_WORD *)(a1 + 24);
        *(_WORD *)(a1 + 24) = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4) = v20;
        *(_DWORD *)(a1 + 28) = v18;
        *(a2 - 1) = v19;
        v21 = *(_DWORD *)(a1 + 28);
        v22 = *(_DWORD *)(a1 + 20);
        if (v21 < v22)
        {
          v23 = *(_WORD *)(a1 + 16);
          v24 = *(_WORD *)(a1 + 24);
          *(_WORD *)(a1 + 16) = v24;
          *(_WORD *)(a1 + 24) = v23;
          *(_DWORD *)(a1 + 20) = v21;
          *(_DWORD *)(a1 + 28) = v22;
          v25 = *(_DWORD *)(a1 + 12);
          if (v21 < v25)
          {
            v26 = *(_WORD *)(a1 + 8);
            *(_WORD *)(a1 + 8) = v24;
            *(_WORD *)(a1 + 16) = v26;
            *(_DWORD *)(a1 + 12) = v21;
            *(_DWORD *)(a1 + 20) = v25;
            v27 = *(_DWORD *)(a1 + 4);
            if (v21 < v27)
            {
              v28 = *(_WORD *)a1;
              *(_WORD *)a1 = v24;
              *(_WORD *)(a1 + 8) = v28;
              *(_DWORD *)(a1 + 4) = v21;
              *(_DWORD *)(a1 + 12) = v27;
            }
          }
        }
      }
      return 1;
    default:
      v9 = (_DWORD *)(a1 + 16);
      v10 = (_DWORD *)(a1 + 24);
      if ((_DWORD *)(a1 + 24) == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (v10[1] < v9[1])
    {
      v13 = *v10;
      v14 = v10[1];
      v15 = v11;
      while (1)
      {
        v16 = a1 + v15;
        *(_WORD *)(v16 + 24) = *(_WORD *)(a1 + v15 + 16);
        *(_DWORD *)(v16 + 28) = *(_DWORD *)(a1 + v15 + 20);
        if (v15 == -16)
          break;
        v15 -= 8;
        if (*(_DWORD *)(v16 + 12) <= v14)
        {
          v17 = a1 + v15 + 24;
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *(_WORD *)v17 = v13;
      *(_DWORD *)(v17 + 4) = v14;
      if (++v12 == 8)
        return v10 + 2 == a2;
    }
    v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2)
      return 1;
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_2 &,std::pair<unsigned short,unsigned int> *,false>(uint64_t result, _DWORD *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  _DWORD *v20;
  _DWORD *v21;
  unsigned int v22;
  _DWORD *v23;
  unsigned int v24;
  unint64_t v25;
  __int16 v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35;
  unsigned int v36;
  _DWORD *v37;
  _DWORD *v38;
  unsigned int v39;
  __int16 v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  __int16 v46;
  unsigned int v47;
  unsigned int v48;
  __int16 v49;
  unsigned int v50;
  unsigned int v51;
  __int16 v52;
  __int16 v53;
  unsigned int v54;
  __int16 v55;
  unsigned int v56;
  __int16 v57;
  _DWORD *v58;
  BOOL v60;
  uint64_t v61;
  _DWORD *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  uint64_t v73;
  int *v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  int *v78;
  int v79;
  unsigned int v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  _DWORD *v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  unint64_t v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  _DWORD *v98;
  _DWORD *v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  _DWORD *v105;
  _DWORD *v106;
  int v107;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = (uint64_t)((uint64_t)a2 - v8) >> 3;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v44 = *(a2 - 1);
        v45 = *(_DWORD *)(v8 + 4);
        if (v44 < v45)
        {
          v46 = *(_WORD *)v8;
          *(_WORD *)v8 = *((_WORD *)a2 - 4);
          *((_WORD *)a2 - 4) = v46;
          *(_DWORD *)(v8 + 4) = v44;
          *(a2 - 1) = v45;
        }
        return result;
      case 3uLL:
      case 4uLL:
      case 5uLL:
        v47 = *(a2 - 1);
        v48 = *(_DWORD *)(v8 + 28);
        if (v47 < v48)
        {
          v49 = *(_WORD *)(v8 + 24);
          *(_WORD *)(v8 + 24) = *((_WORD *)a2 - 4);
          *((_WORD *)a2 - 4) = v49;
          *(_DWORD *)(v8 + 28) = v47;
          *(a2 - 1) = v48;
          v50 = *(_DWORD *)(v8 + 28);
          v51 = *(_DWORD *)(v8 + 20);
          if (v50 < v51)
          {
            v52 = *(_WORD *)(v8 + 16);
            v53 = *(_WORD *)(v8 + 24);
            *(_WORD *)(v8 + 16) = v53;
            *(_WORD *)(v8 + 24) = v52;
            *(_DWORD *)(v8 + 20) = v50;
            *(_DWORD *)(v8 + 28) = v51;
            v54 = *(_DWORD *)(v8 + 12);
            if (v50 < v54)
            {
              v55 = *(_WORD *)(v8 + 8);
              *(_WORD *)(v8 + 8) = v53;
              *(_WORD *)(v8 + 16) = v55;
              *(_DWORD *)(v8 + 12) = v50;
              *(_DWORD *)(v8 + 20) = v54;
              v56 = *(_DWORD *)(v8 + 4);
              if (v50 < v56)
              {
                v57 = *(_WORD *)v8;
                *(_WORD *)v8 = v53;
                *(_WORD *)(v8 + 8) = v57;
                *(_DWORD *)(v8 + 4) = v50;
                *(_DWORD *)(v8 + 12) = v56;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 191)
        {
          v58 = (_DWORD *)(v8 + 8);
          v60 = (_DWORD *)v8 == a2 || v58 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v60)
            {
              v61 = 0;
              v62 = (_DWORD *)v8;
              do
              {
                v63 = v62[3];
                v64 = v62[1];
                v62 = v58;
                if (v63 < v64)
                {
                  v65 = *v58;
                  v66 = v62[1];
                  v67 = v61;
                  while (1)
                  {
                    v68 = v8 + v67;
                    *(_WORD *)(v68 + 8) = *(_WORD *)(v8 + v67);
                    *(_DWORD *)(v68 + 12) = *(_DWORD *)(v8 + v67 + 4);
                    if (!v67)
                      break;
                    v67 -= 8;
                    if (*(_DWORD *)(v68 - 4) <= v66)
                    {
                      v69 = v8 + v67 + 8;
                      goto LABEL_78;
                    }
                  }
                  v69 = v8;
LABEL_78:
                  *(_WORD *)v69 = v65;
                  *(_DWORD *)(v69 + 4) = v66;
                }
                v58 = v62 + 2;
                v61 += 8;
              }
              while (v62 + 2 != a2);
            }
          }
          else if (!v60)
          {
            v100 = (_DWORD *)(v8 + 12);
            do
            {
              v101 = *(_DWORD *)(v7 + 12);
              v102 = *(_DWORD *)(v7 + 4);
              v7 = (uint64_t)v58;
              if (v101 < v102)
              {
                v103 = *(_QWORD *)v58;
                v104 = HIDWORD(*(_QWORD *)v7);
                v105 = v100;
                do
                {
                  v106 = v105;
                  *((_WORD *)v105 - 2) = *((_WORD *)v105 - 6);
                  v107 = *(v105 - 2);
                  v105 -= 2;
                  *v106 = v107;
                }
                while (*(v106 - 4) > v104);
                *((_WORD *)v105 - 2) = v103;
                *v105 = v104;
              }
              v58 = (_DWORD *)(v7 + 8);
              v100 += 2;
            }
            while ((_DWORD *)(v7 + 8) != a2);
          }
          return result;
        }
        if (!a3)
        {
          if ((_DWORD *)v8 != a2)
          {
            v70 = (v10 - 2) >> 1;
            v71 = v70;
            do
            {
              v72 = v71;
              if (v70 >= v71)
              {
                v73 = (2 * v71) | 1;
                v74 = (int *)(v8 + 8 * v73);
                if (2 * v72 + 2 < (uint64_t)v10)
                {
                  v75 = v74[1];
                  v76 = v74[3];
                  v74 += 2 * (v75 < v76);
                  if (v75 < v76)
                    v73 = 2 * v72 + 2;
                }
                v77 = v74[1];
                if (v77 >= *(_DWORD *)(v8 + 8 * v72 + 4))
                {
                  v78 = (int *)(v8 + 8 * v72);
                  v79 = *v78;
                  v80 = v78[1];
                  do
                  {
                    result = (uint64_t)v78;
                    v78 = v74;
                    *(_WORD *)result = *(_WORD *)v74;
                    *(_DWORD *)(result + 4) = v77;
                    if (v70 < v73)
                      break;
                    result = (2 * v73) | 1;
                    v74 = (int *)(v8 + 8 * result);
                    v81 = 2 * v73 + 2;
                    if (v81 < (uint64_t)v10)
                    {
                      v82 = v74[1];
                      v83 = v74[3];
                      v74 += 2 * (v82 < v83);
                      if (v82 < v83)
                        result = v81;
                    }
                    v77 = v74[1];
                    v73 = result;
                  }
                  while (v77 >= v80);
                  *(_WORD *)v78 = v79;
                  v78[1] = v80;
                }
              }
              v71 = v72 - 1;
            }
            while (v72);
            v84 = (unint64_t)v9 >> 3;
            do
            {
              v85 = 0;
              v86 = *(_QWORD *)v8;
              v87 = v8;
              do
              {
                v88 = (_DWORD *)(v87 + 8 * (v85 + 1));
                v89 = (2 * v85) | 1;
                v90 = 2 * v85 + 2;
                if (v90 < v84)
                {
                  v91 = v88[1];
                  v92 = v88[3];
                  v88 += 2 * (v91 < v92);
                  if (v91 < v92)
                    v89 = v90;
                }
                *(_WORD *)v87 = *(_WORD *)v88;
                *(_DWORD *)(v87 + 4) = v88[1];
                v87 = (unint64_t)v88;
                v85 = v89;
              }
              while (v89 <= (uint64_t)((unint64_t)(v84 - 2) >> 1));
              if (v88 == a2 - 2)
              {
                *(_WORD *)v88 = v86;
                v88[1] = HIDWORD(v86);
              }
              else
              {
                *(_WORD *)v88 = *((_WORD *)a2 - 4);
                v88[1] = *(a2 - 1);
                *((_WORD *)a2 - 4) = v86;
                *(a2 - 1) = HIDWORD(v86);
                v93 = (uint64_t)v88 - v8 + 8;
                if (v93 >= 9)
                {
                  v94 = (((unint64_t)v93 >> 3) - 2) >> 1;
                  v95 = *(_DWORD *)(v8 + 8 * v94 + 4);
                  if (v95 < v88[1])
                  {
                    v96 = *v88;
                    v97 = v88[1];
                    do
                    {
                      v98 = v88;
                      v88 = (_DWORD *)(v8 + 8 * v94);
                      *(_WORD *)v98 = *(_WORD *)v88;
                      v98[1] = v95;
                      if (!v94)
                        break;
                      v94 = (v94 - 1) >> 1;
                      v95 = *(_DWORD *)(v8 + 8 * v94 + 4);
                    }
                    while (v95 < v97);
                    *(_WORD *)v88 = v96;
                    v88[1] = v97;
                  }
                }
              }
              a2 -= 2;
            }
            while (v84-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = v8 + 8 * (v10 >> 1);
        if ((unint64_t)v9 < 0x401)
        {
        }
        else
        {
          v13 = *(_WORD *)v7;
          *(_WORD *)v7 = *(_WORD *)v12;
          *(_WORD *)v12 = v13;
          v14 = *(_DWORD *)(v7 + 4);
          *(_DWORD *)(v7 + 4) = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(v12 + 4) = v14;
        }
        --a3;
        if ((a4 & 1) == 0 && *(_DWORD *)(v7 - 4) >= *(_DWORD *)(v7 + 4))
        {
          v31 = *(_QWORD *)v7;
          v32 = HIDWORD(*(_QWORD *)v7);
          if (*(a2 - 1) <= v32)
          {
            v35 = v7 + 8;
            do
            {
              v8 = v35;
              if (v35 >= (unint64_t)a2)
                break;
              v36 = *(_DWORD *)(v35 + 4);
              v35 += 8;
            }
            while (v36 <= v32);
          }
          else
          {
            v33 = v7;
            do
            {
              v8 = v33 + 8;
              v34 = *(_DWORD *)(v33 + 12);
              v33 += 8;
            }
            while (v34 <= v32);
          }
          v37 = a2;
          if (v8 < (unint64_t)a2)
          {
            v38 = a2;
            do
            {
              v37 = v38 - 2;
              v39 = *(v38 - 1);
              v38 -= 2;
            }
            while (v39 > v32);
          }
          while (v8 < (unint64_t)v37)
          {
            v40 = *(_WORD *)v8;
            *(_WORD *)v8 = *(_WORD *)v37;
            *(_WORD *)v37 = v40;
            v41 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = v37[1];
            v37[1] = v41;
            do
            {
              v42 = *(_DWORD *)(v8 + 12);
              v8 += 8;
            }
            while (v42 <= v32);
            do
            {
              v43 = *(v37 - 1);
              v37 -= 2;
            }
            while (v43 > v32);
          }
          if (v8 - 8 != v7)
          {
            *(_WORD *)v7 = *(_WORD *)(v8 - 8);
            *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 4);
          }
          a4 = 0;
          *(_WORD *)(v8 - 8) = v31;
          *(_DWORD *)(v8 - 4) = v32;
          continue;
        }
        v15 = 0;
        v16 = *(_QWORD *)v7;
        v17 = HIDWORD(*(_QWORD *)v7);
        do
        {
          v18 = *(_DWORD *)(v7 + v15 + 12);
          v15 += 8;
        }
        while (v18 < v17);
        v19 = v7 + v15;
        v20 = a2;
        if (v15 == 8)
        {
          v23 = a2;
          while (v19 < (unint64_t)v23)
          {
            v21 = v23 - 2;
            v24 = *(v23 - 1);
            v23 -= 2;
            if (v24 < v17)
              goto LABEL_21;
          }
          v21 = v23;
        }
        else
        {
          do
          {
            v21 = v20 - 2;
            v22 = *(v20 - 1);
            v20 -= 2;
          }
          while (v22 >= v17);
        }
LABEL_21:
        v8 = v19;
        if (v19 < (unint64_t)v21)
        {
          v25 = (unint64_t)v21;
          do
          {
            v26 = *(_WORD *)v8;
            *(_WORD *)v8 = *(_WORD *)v25;
            *(_WORD *)v25 = v26;
            v27 = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = *(_DWORD *)(v25 + 4);
            *(_DWORD *)(v25 + 4) = v27;
            do
            {
              v28 = *(_DWORD *)(v8 + 12);
              v8 += 8;
            }
            while (v28 < v17);
            do
            {
              v29 = *(_DWORD *)(v25 - 4);
              v25 -= 8;
            }
            while (v29 >= v17);
          }
          while (v8 < v25);
        }
        if (v8 - 8 != v7)
        {
          *(_WORD *)v7 = *(_WORD *)(v8 - 8);
          *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 - 4);
        }
        *(_WORD *)(v8 - 8) = v16;
        *(_DWORD *)(v8 - 4) = v17;
        if (v19 < (unint64_t)v21)
        {
LABEL_32:
          a4 = 0;
          continue;
        }
        if (!(_DWORD)result)
        {
          if (v30)
            continue;
          goto LABEL_32;
        }
        a2 = (_DWORD *)(v8 - 8);
        if (!v30)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,`anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_2 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned int v6;
  unsigned int v7;
  __int16 v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  __int16 v20;
  unsigned int v21;
  unsigned int v22;
  __int16 v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  unsigned int v27;
  __int16 v28;

  v4 = ((uint64_t)a2 - a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *(_DWORD *)(a1 + 4);
      if (v6 < v7)
      {
        v8 = *(_WORD *)a1;
        *(_WORD *)a1 = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4) = v8;
        *(_DWORD *)(a1 + 4) = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      v18 = *(a2 - 1);
      v19 = *(_DWORD *)(a1 + 28);
      if (v18 < v19)
      {
        v20 = *(_WORD *)(a1 + 24);
        *(_WORD *)(a1 + 24) = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4) = v20;
        *(_DWORD *)(a1 + 28) = v18;
        *(a2 - 1) = v19;
        v21 = *(_DWORD *)(a1 + 28);
        v22 = *(_DWORD *)(a1 + 20);
        if (v21 < v22)
        {
          v23 = *(_WORD *)(a1 + 16);
          v24 = *(_WORD *)(a1 + 24);
          *(_WORD *)(a1 + 16) = v24;
          *(_WORD *)(a1 + 24) = v23;
          *(_DWORD *)(a1 + 20) = v21;
          *(_DWORD *)(a1 + 28) = v22;
          v25 = *(_DWORD *)(a1 + 12);
          if (v21 < v25)
          {
            v26 = *(_WORD *)(a1 + 8);
            *(_WORD *)(a1 + 8) = v24;
            *(_WORD *)(a1 + 16) = v26;
            *(_DWORD *)(a1 + 12) = v21;
            *(_DWORD *)(a1 + 20) = v25;
            v27 = *(_DWORD *)(a1 + 4);
            if (v21 < v27)
            {
              v28 = *(_WORD *)a1;
              *(_WORD *)a1 = v24;
              *(_WORD *)(a1 + 8) = v28;
              *(_DWORD *)(a1 + 4) = v21;
              *(_DWORD *)(a1 + 12) = v27;
            }
          }
        }
      }
      return 1;
    default:
      v9 = (_DWORD *)(a1 + 16);
      v10 = (_DWORD *)(a1 + 24);
      if ((_DWORD *)(a1 + 24) == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (v10[1] < v9[1])
    {
      v13 = *v10;
      v14 = v10[1];
      v15 = v11;
      while (1)
      {
        v16 = a1 + v15;
        *(_WORD *)(v16 + 24) = *(_WORD *)(a1 + v15 + 16);
        *(_DWORD *)(v16 + 28) = *(_DWORD *)(a1 + v15 + 20);
        if (v15 == -16)
          break;
        v15 -= 8;
        if (*(_DWORD *)(v16 + 12) <= v14)
        {
          v17 = a1 + v15 + 24;
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *(_WORD *)v17 = v13;
      *(_DWORD *)(v17 + 4) = v14;
      if (++v12 == 8)
        return v10 + 2 == a2;
    }
    v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2)
      return 1;
  }
}

void std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E15E0010;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15E0010;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<`anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  _DWORD *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  BOOL v9;

  v4 = *(_DWORD **)(result + 8);
  if (v4[6] > *a4)
  {
    v5 = result;
    v6 = *a2;
    v7 = *a3;
    result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)v4 + 16))(*(_QWORD *)(result + 8), 0, *a4);
    if ((_DWORD)result)
    {
      if (v6 <= v7 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6)
            *(_BYTE *)(*(_QWORD *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6) = v6 + 1;
        }
        while (!v8);
      }
    }
    else if (*(_WORD *)(v5 + 32))
    {
      result = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v4 + 16))(v4);
      v9 = !(_DWORD)result || v6 > v7;
      if (!v9 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6)
            *(_BYTE *)(*(_QWORD *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6) = v6 + 1;
        }
        while (!v8);
      }
    }
  }
  return result;
}

uint64_t `anonymous namespace'::MorxContextualSubtableBuilder::PrepareArabicStateTable(uint64_t a1, uint64_t a2, int64_t a3, unsigned __int16 ***a4, unsigned __int16 **a5)
{
  __CFData *v9;
  unint64_t v10;
  _WORD *v11;
  _WORD *v12;
  unint64_t v13;
  _WORD *v14;
  _WORD *v15;
  unint64_t v16;
  _WORD *v17;
  _WORD *v18;
  _WORD *v19;
  _WORD *v20;
  unsigned __int16 **v21;
  unsigned __int16 **v22;
  unsigned __int16 v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  unsigned __int16 v26;
  char v27;
  uint64_t v28;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  void *v35;
  uint64_t v36;
  char *v37;
  __int16 v38;
  unint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  __int16 v50;
  char *v51;
  void *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  void **v56;
  char *v57;
  void **v58;
  char *v59;
  size_t v60;
  char *v61;
  size_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  void *__p;
  _WORD *v68;
  uint64_t v69;
  id v70[5];

  v9 = NewLKTHandle(a3, 1);
  if (qword_1ECDE7D88 != -1)
  __p = 0;
  v68 = 0;
  v69 = 0;
  std::vector<unsigned short>::reserve(&__p, qword_1ECDE7D80);
  v10 = (uint64_t)(*((_QWORD *)&_MergedGlobals_30 + 1) - _MergedGlobals_30) >> 1;
  std::vector<unsigned short>::resize((uint64_t)&__p, v10);
  (*(void (**)(uint64_t, _QWORD, void *, unint64_t))(*(_QWORD *)a2 + 664))(a2, _MergedGlobals_30, __p, v10);
  v11 = __p;
  v12 = v68;
  while (v11 != v12)
  {
    if (*v11)
      LKTAddRange(v9, (unsigned __int16)*v11, (unsigned __int16)*v11, 4);
    ++v11;
  }
  v13 = (unk_1ECDE7D58 - qword_1ECDE7D50) >> 1;
  std::vector<unsigned short>::resize((uint64_t)&__p, v13);
  (*(void (**)(uint64_t, uint64_t, void *, unint64_t))(*(_QWORD *)a2 + 664))(a2, qword_1ECDE7D50, __p, v13);
  v14 = __p;
  v15 = v68;
  while (v14 != v15)
  {
    if (*v14)
      LKTAddRange(v9, (unsigned __int16)*v14, (unsigned __int16)*v14, 5);
    ++v14;
  }
  v16 = (unk_1ECDE7D70 - qword_1ECDE7D68) >> 1;
  std::vector<unsigned short>::resize((uint64_t)&__p, v16);
  (*(void (**)(uint64_t, uint64_t, void *, unint64_t))(*(_QWORD *)a2 + 664))(a2, qword_1ECDE7D68, __p, v16);
  v17 = __p;
  v18 = v68;
  while (v17 != v18)
  {
    if (*v17)
      LKTAddRange(v9, (unsigned __int16)*v17, (unsigned __int16)*v17, 6);
    ++v17;
  }
  LODWORD(v70[0]) = 537724480;
  std::vector<unsigned short>::resize((uint64_t)&__p, 2uLL);
  (*(void (**)(uint64_t, id *, void *, uint64_t))(*(_QWORD *)a2 + 664))(a2, v70, __p, 2);
  v19 = __p;
  v20 = v68;
  while (v19 != v20)
  {
    if (*v19)
      LKTAddRange(v9, (unsigned __int16)*v19, (unsigned __int16)*v19, 7);
    ++v19;
  }
  v21 = *a4;
  v22 = a4[1];
  while (v21 != v22)
  {
    v23 = LKTGetValue(v9, **v21);
    v24 = *v21;
    v25 = v21[1];
    if (*v21 != v25)
    {
      v26 = v23;
      v27 = 0;
      do
      {
        while (1)
        {
          v28 = LKTGetValue(v9, *v24);
          if ((v27 & ((v28 & 0xFF0000) == 0)) != 0)
            goto LABEL_45;
          if ((v28 & 0xFF0000) == 0)
            break;
          if ((unsigned __int16)v28 != v26 && (unsigned __int16)v28 != 6)
            goto LABEL_45;
          ++v24;
          v27 = 1;
          if (v24 == v25)
            goto LABEL_39;
        }
        ++v24;
      }
      while (v24 != v25);
      if ((v27 & 1) != 0)
LABEL_39:
        LKTAddRange(v9, *((unsigned __int16 *)v21 + 20), *((unsigned __int16 *)v21 + 20), v26);
    }
    v21 += 6;
  }
  v31 = *a5;
  v30 = a5[1];
  while (v31 != v30)
  {
    if ((LKTGetValue(v9, *v31) & 0x10000) != 0)
    {
LABEL_45:
      v32 = 0;
      goto LABEL_90;
    }
    ++v31;
  }
  *(_DWORD *)(a1 + 24) = 8;
  LKTCreateLookupTable(v9, (unint64_t *)v70);
  v33 = (unint64_t *)(a1 + 32);
  do
    v34 = __ldaxr((unint64_t *)v70);
  while (__stlxr(0, (unint64_t *)v70));
  do
    v35 = (void *)__ldaxr(v33);
  while (__stlxr(v34, v33));

  DisposeLKTHandle(v9);
  v36 = 0;
  v37 = *(char **)(a1 + 48);
  do
  {
    v38 = word_18494FB6C[v36] - 1;
    v39 = *(_QWORD *)(a1 + 56);
    if ((unint64_t)v37 >= v39)
    {
      v40 = *(char **)(a1 + 40);
      v41 = v37 - v40;
      if (v37 - v40 <= -3)
        goto LABEL_93;
      v42 = v41 >> 1;
      v43 = v39 - (_QWORD)v40;
      if (v43 <= (v41 >> 1) + 1)
        v44 = v42 + 1;
      else
        v44 = v43;
      if (v43 >= 0x7FFFFFFFFFFFFFFELL)
        v45 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v45 = v44;
      v70[4] = (id)(a1 + 64);
      if (v45)
      {
        v46 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(a1 + 64, v45);
        v40 = *(char **)(a1 + 40);
        v37 = *(char **)(a1 + 48);
      }
      else
      {
        v46 = 0;
      }
      v47 = &v46[2 * v42];
      *(_WORD *)v47 = v38;
      if (v37 == v40)
      {
        v49 = &v46[2 * v42];
      }
      else
      {
        v48 = v37;
        v49 = &v46[2 * v42];
        do
        {
          v50 = *((_WORD *)v48 - 1);
          v48 -= 2;
          *((_WORD *)v49 - 1) = v50;
          v49 -= 2;
        }
        while (v48 != v40);
      }
      v51 = v47 + 2;
      *(_QWORD *)(a1 + 40) = v49;
      *(_QWORD *)(a1 + 48) = v47 + 2;
      v52 = *(void **)(a1 + 56);
      *(_QWORD *)(a1 + 56) = &v46[2 * v45];
      v70[2] = v37;
      v70[3] = v52;
      v70[0] = v40;
      v70[1] = v40;
      std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v70);
      v37 = v51;
    }
    else
    {
      *(_WORD *)v37 = v38;
      v37 += 2;
    }
    *(_QWORD *)(a1 + 48) = v37;
    ++v36;
  }
  while (v36 != 48);
  v53 = *(char **)(a1 + 136);
  v54 = *(_QWORD *)(a1 + 152);
  v55 = v54 - (_QWORD)v53;
  if ((unint64_t)(v54 - (_QWORD)v53) >= 0x78)
  {
    v59 = *(char **)(a1 + 144);
    v58 = (void **)(a1 + 144);
    v57 = v59;
    v60 = v59 - v53;
    if ((unint64_t)(v59 - v53) > 0x77)
    {
      *((_QWORD *)v53 + 14) = 0xFFFF000300000000;
      *((_OWORD *)v53 + 4) = xmmword_18494FC0C;
      *((_OWORD *)v53 + 5) = unk_18494FC1C;
      *((_OWORD *)v53 + 6) = xmmword_18494FC2C;
      *(_OWORD *)v53 = xmmword_18494FBCC;
      *((_OWORD *)v53 + 1) = unk_18494FBDC;
      v63 = 15;
      *((_OWORD *)v53 + 2) = xmmword_18494FBEC;
      *((_OWORD *)v53 + 3) = unk_18494FBFC;
    }
    else
    {
      v61 = (char *)&xmmword_18494FBCC + v60;
      if (v57 != v53)
      {
        memcpy(v53, &xmmword_18494FBCC, v60);
        v53 = (char *)*v58;
      }
      v62 = 120 - v60;
      memcpy(v53, v61, v62);
      v63 = v62 >> 3;
    }
  }
  else
  {
    if (v53)
    {
      *(_QWORD *)(a1 + 144) = v53;
      if (a1 + 160 > (unint64_t)v53 || (v56 = (void **)(a1 + 400), a1 + 400 <= (unint64_t)v53))
      {
        operator delete(v53);
      }
      else if (&v53[v55] == *v56)
      {
        *v56 = v53;
      }
      v54 = 0;
      *(_QWORD *)(a1 + 136) = 0;
      *(_QWORD *)(a1 + 144) = 0;
      *(_QWORD *)(a1 + 152) = 0;
    }
    v64 = v54 >> 2;
    if ((unint64_t)(v54 >> 2) <= 0xF)
      v64 = 15;
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
      v65 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v65 = v64;
    if (v65 >> 61)
LABEL_93:
      abort();
    v53 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(a1 + 160, v65);
    *(_QWORD *)(a1 + 136) = v53;
    *(_QWORD *)(a1 + 152) = &v53[8 * v65];
    v58 = (void **)(a1 + 144);
    *((_QWORD *)v53 + 14) = 0xFFFF000300000000;
    *(_OWORD *)v53 = xmmword_18494FBCC;
    *((_OWORD *)v53 + 1) = unk_18494FBDC;
    *((_OWORD *)v53 + 6) = xmmword_18494FC2C;
    *((_OWORD *)v53 + 4) = xmmword_18494FC0C;
    *((_OWORD *)v53 + 5) = unk_18494FC1C;
    v63 = 15;
    *((_OWORD *)v53 + 2) = xmmword_18494FBEC;
    *((_OWORD *)v53 + 3) = unk_18494FBFC;
  }
  *v58 = &v53[8 * v63];
  v32 = 1;
LABEL_90:
  if (__p)
  {
    v68 = __p;
    operator delete(__p);
  }
  return v32;
}

char **TInlineVector<`anonymous namespace'::LigInput,30ul>::TInlineVector(char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v6;
  char *v8;
  uint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  v4 = (uint64_t)(a1 + 3);
  a1[2] = 0;
  a1[183] = (char *)v4;
  if (a3 != a2)
  {
    v6 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 4);
    if (v6 >= 0x555555555555556)
      abort();
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[48 * v9];
  }
  return a1;
}

uint64_t `anonymous namespace'::MorxContextualSubtableBuilder::BuildArabicSubtableData(_anonymous_namespace_::MorxContextualSubtableBuilder *this, const __CFData *a2, const __CFData *a3, const __CFData *a4, const __CFData *a5)
{
  BOOL v5;
  BOOL v7;
  int v8;
  __CFData *v14;
  unsigned int v15;
  __CFData *v16;
  unsigned int v17;
  __CFData *v18;
  unsigned int v19;
  __CFData *v20;
  _anonymous_namespace_ *v21;
  const __CFData *v22;
  _anonymous_namespace_ *v23;
  const __CFData *v24;
  _anonymous_namespace_ *v25;
  const __CFData *v26;
  _anonymous_namespace_ *v27;
  const __CFData *v28;
  unint64_t *v29;
  unint64_t v30;
  void *v31;
  id Mutable;
  UInt8 bytes[4];

  if (a2)
    v5 = a3 == 0;
  else
    v5 = 1;
  v7 = v5 || a4 == 0 || a5 == 0;
  v8 = v7;
  if (!v7)
  {
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v14 = (__CFData *)atomic_load((unint64_t *)&Mutable);
    *(_DWORD *)bytes = 0x10000000;
    CFDataAppendBytes(v14, bytes, 4);
    v15 = CFDataGetLength(a2) + 16;
    v16 = (__CFData *)atomic_load((unint64_t *)&Mutable);
    *(_DWORD *)bytes = bswap32(v15);
    CFDataAppendBytes(v16, bytes, 4);
    v17 = v15 + CFDataGetLength(a3);
    v18 = (__CFData *)atomic_load((unint64_t *)&Mutable);
    *(_DWORD *)bytes = bswap32(v17);
    CFDataAppendBytes(v18, bytes, 4);
    v19 = v17 + CFDataGetLength(a4);
    v20 = (__CFData *)atomic_load((unint64_t *)&Mutable);
    *(_DWORD *)bytes = bswap32(v19);
    CFDataAppendBytes(v20, bytes, 4);
    v21 = (_anonymous_namespace_ *)atomic_load((unint64_t *)&Mutable);
    v23 = (_anonymous_namespace_ *)atomic_load((unint64_t *)&Mutable);
    v25 = (_anonymous_namespace_ *)atomic_load((unint64_t *)&Mutable);
    v27 = (_anonymous_namespace_ *)atomic_load((unint64_t *)&Mutable);
    v29 = (unint64_t *)((char *)this + 408);
    do
      v30 = __ldaxr((unint64_t *)&Mutable);
    while (__stlxr(0, (unint64_t *)&Mutable));
    do
      v31 = (void *)__ldaxr(v29);
    while (__stlxr(v30, v29));

  }
  return v8 ^ 1u;
}

void std::vector<unsigned short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int16 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    v9 = &v6[2 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t `anonymous namespace'::MorxContextualSubtableBuilder::PrepareArabicStateTable(TBaseFont const&,long,TInlineVector<`anonymous namespace'::LigInput,30ul>,TInlineVector const&<unsigned short,30ul>)::$_0::__invoke()
{
  uint64_t result;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  char v4[16];
  uint64_t v5;

  ArabicCharactersWithJoiningType(v4, "Dual_Joining");
  _MergedGlobals_30 = *(_OWORD *)v4;
  qword_1ECDE7D48 = v5;
  ArabicCharactersWithJoiningType(v4, "Right_Joining");
  *(_OWORD *)&qword_1ECDE7D50 = *(_OWORD *)v4;
  qword_1ECDE7D60 = v5;
  result = ArabicCharactersWithJoiningType(v4, "Transparent");
  qword_1ECDE7D68 = *(_QWORD *)v4;
  unk_1ECDE7D70 = *(_QWORD *)&v4[8];
  v1 = *(_QWORD *)&v4[8] - *(_QWORD *)v4;
  v2 = (unk_1ECDE7D58 - qword_1ECDE7D50) >> 1;
  if ((uint64_t)(*((_QWORD *)&_MergedGlobals_30 + 1) - _MergedGlobals_30) >> 1 > v2)
    v2 = (uint64_t)(*((_QWORD *)&_MergedGlobals_30 + 1) - _MergedGlobals_30) >> 1;
  if (v2 <= v1 >> 1)
    v3 = v1 >> 1;
  else
    v3 = v2;
  qword_1ECDE7D78 = v5;
  qword_1ECDE7D80 = v3;
  return result;
}

uint64_t ArabicCharactersWithJoiningType(char *a1, const char *a2)
{
  int64_t v3;
  size_t v4;
  void *v5;
  uint64_t v6;
  int v7;
  _QWORD *v8;
  uint64_t v9;
  char *__s;
  int v12;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  __s = (char *)0xAAAAAAAAAAAAAAAALL;
  asprintf(&__s, "[[[:block=Arabic:][:block=Arabic_Supplement:][:block=Arabic_Extended_A:][:Bidi_Control:]]&[:Joining_Type=%s:]]", a2);
  v3 = (strlen(__s) << 32) + 0x100000000;
  if (v3 < 0)
    v4 = -1;
  else
    v4 = v3 >> 31;
  v5 = (void *)operator new[]();
  bzero(v5, v4);
  u_uastrcpy((UChar *)v5, __s);
  v6 = uset_openPattern();
  free(__s);
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  if (v6)
  {
    v7 = MEMORY[0x186DC0D6C](v6);
    std::vector<unsigned short>::reserve((void **)a1, v7);
    v13[0] = &off_1E15DFA28;
    v13[1] = a1;
    v14 = v13;
    IterateItemRanges(v6, &v12, (uint64_t)v13);
    v8 = v14;
    if (v14 == v13)
    {
      v9 = 4;
      v8 = v13;
    }
    else
    {
      if (!v14)
      {
LABEL_10:
        uset_close();
        return MEMORY[0x186DC0394](v5, 0x1000C80BDFB0063);
      }
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
    goto LABEL_10;
  }
  return MEMORY[0x186DC0394](v5, 0x1000C80BDFB0063);
}

void std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15DFA28;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15DFA28;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::operator()(uint64_t a1, int *a2, int *a3)
{
  int v3;
  int v4;
  BOOL v5;
  uint64_t v7;
  _WORD *v8;
  unint64_t v9;
  _WORD *v10;
  _WORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  __int16 v19;

  v3 = *a2;
  v4 = *a3;
  if (HIWORD(*a2))
    v5 = 1;
  else
    v5 = v3 == v4;
  if (!v5)
  {
    do
    {
      v7 = *(_QWORD *)(a1 + 8);
      v8 = *(_WORD **)(v7 + 8);
      v9 = *(_QWORD *)(v7 + 16);
      if ((unint64_t)v8 >= v9)
      {
        v11 = *(_WORD **)v7;
        v12 = (uint64_t)v8 - *(_QWORD *)v7;
        if (v12 <= -3)
          abort();
        v13 = v12 >> 1;
        v14 = v9 - (_QWORD)v11;
        if (v14 <= (v12 >> 1) + 1)
          v15 = v13 + 1;
        else
          v15 = v14;
        if (v14 >= 0x7FFFFFFFFFFFFFFELL)
          v16 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        if (v16)
        {
          v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v7 + 16, v16);
          v11 = *(_WORD **)v7;
          v8 = *(_WORD **)(v7 + 8);
        }
        else
        {
          v17 = 0;
        }
        v18 = &v17[2 * v13];
        *(_WORD *)v18 = v3;
        v10 = v18 + 2;
        while (v8 != v11)
        {
          v19 = *--v8;
          *((_WORD *)v18 - 1) = v19;
          v18 -= 2;
        }
        *(_QWORD *)v7 = v18;
        *(_QWORD *)(v7 + 8) = v10;
        *(_QWORD *)(v7 + 16) = &v17[2 * v16];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v8 = v3;
        v10 = v8 + 1;
      }
      *(_QWORD *)(v7 + 8) = v10;
      ++v3;
    }
    while (v3 != v4);
  }
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E15DFF38;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E15DFF38;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x20uLL);
  *v2 = &off_1E15DFF38;
  std::vector<unsigned short>::vector(v2 + 1, v1);
  return v2;
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E15DFF38;
  return std::vector<unsigned short>::vector(a2 + 1, a1 + 8);
}

void std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::destroy(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::destroy_deallocate(_QWORD *__p)
{
  void *v2;

  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

BOOL std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned int v9;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *(unsigned __int16 **)(a1 + 16);
  if (v3 == v2)
    return 1;
  v4 = *a2;
  v5 = v3 - v2;
  do
  {
    v6 = v5 >> 1;
    v7 = &v2[v5 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v5 += ~(v5 >> 1);
    if (v9 < v4)
      v2 = v8;
    else
      v5 = v6;
  }
  while (v5);
  return v2 == v3 || *v2 > v4;
}

void std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15DFF80;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15DFF80;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<`anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,`anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;

  v4 = *a2;
  v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    v6 = result;
    v7 = *a4;
    do
    {
      result = LKTGetValue(*(__CFData **)(v6 + 8), (unsigned __int16)v4);
      if ((result & 0xFF0000) != 0)
        result = (uint64_t)LKTAddRange(*(__CFData **)(v6 + 8), v7, v7, result);
      v8 = v5 == (unsigned __int16)v4;
      LOWORD(v4) = v4 + 1;
    }
    while (!v8);
  }
  return result;
}

_QWORD *std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::emplace<MortFeatureEntry>(_QWORD *result, char *a2, uint64_t *a3)
{
  char **v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  int v32;
  char *v33;
  int64_t v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  _QWORD *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  _QWORD *v46;
  uint64_t v47;

  v3 = (char **)result;
  v47 = *MEMORY[0x1E0C80C00];
  v5 = (char *)*result;
  v4 = (char *)result[1];
  v6 = (uint64_t)&a2[-*result];
  v7 = v6 / 12;
  v8 = (char *)(*result + 12 * (v6 / 12));
  v9 = result[2];
  if ((unint64_t)v4 >= v9)
  {
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v14 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 2) + 1;
    if (v14 > 0x1555555555555555)
      abort();
    v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (_QWORD)v5) >> 2);
    if (2 * v16 > v14)
      v14 = 2 * v16;
    if (v16 >= 0xAAAAAAAAAAAAAAALL)
      v17 = 0x1555555555555555;
    else
      v17 = v14;
    v41 = result + 3;
    if (v17)
    {
      v18 = a3;
      v19 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate((uint64_t)(result + 3), v17);
      a3 = v18;
      v20 = v19;
    }
    else
    {
      v20 = 0;
    }
    v22 = &v20[12 * v7];
    v40 = &v20[12 * v17];
    if (v7 == v17)
    {
      if (v6 < 1)
      {
        v24 = &v20[12 * v17];
        if (v5 == a2)
          v25 = 1;
        else
          v25 = 2 * v7;
        v46 = v3 + 3;
        v26 = a3;
        v42 = v20;
        v43 = &v20[12 * v7];
        v37 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate((uint64_t)(v3 + 3), v25);
        v40 = &v37[12 * v25];
        v44 = v43;
        v45 = v24;
        std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer((uint64_t)&v42);
        a3 = v26;
        v22 = &v37[12 * (v25 >> 2)];
      }
      else
      {
        v23 = v7 + 2;
        if (v7 >= -1)
          v23 = v7 + 1;
        v22 -= 12 * (v23 >> 1);
      }
    }
    v27 = *a3;
    *((_DWORD *)v22 + 2) = *((_DWORD *)a3 + 2);
    *(_QWORD *)v22 = v27;
    v28 = v22 + 12;
    v39 = v22 + 12;
    v29 = *v3;
    if (*v3 != v8)
    {
      v30 = v8;
      do
      {
        v31 = *(_QWORD *)(v30 - 12);
        v30 -= 12;
        v32 = *((_DWORD *)v30 + 2);
        *(_QWORD *)(v22 - 12) = v31;
        v22 -= 12;
        *((_DWORD *)v22 + 2) = v32;
      }
      while (v30 != v29);
      v28 = v39;
    }
    v38 = v22;
    v33 = v3[1];
    v34 = v33 - v8;
    if (v33 != v8)
    {
      memmove(v28, v8, v33 - v8);
      v22 = v38;
      v8 = v3[1];
    }
    v35 = *v3;
    *v3 = v22;
    v3[1] = &v28[v34];
    v36 = v3[2];
    v3[2] = v40;
    v39 = v8;
    v40 = v36;
    v37 = v35;
    v38 = v35;
    return (_QWORD *)std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer((uint64_t)&v37);
  }
  else if (v8 == v4)
  {
    v21 = *a3;
    *((_DWORD *)v8 + 2) = *((_DWORD *)a3 + 2);
    *(_QWORD *)v8 = v21;
    result[1] = v8 + 12;
  }
  else
  {
    v42 = (char *)*a3;
    LODWORD(v43) = *((_DWORD *)a3 + 2);
    v10 = v8 + 12;
    v11 = v4 - 12;
    v12 = v4;
    while (v11 < v4)
    {
      v13 = *(_QWORD *)v11;
      *((_DWORD *)v12 + 2) = *((_DWORD *)v11 + 2);
      *(_QWORD *)v12 = v13;
      v12 += 12;
      v11 += 12;
    }
    result[1] = v12;
    if (v4 != v10)
      result = memmove(v8 + 12, v8, v4 - v10);
    *(_QWORD *)v8 = v42;
    *((_DWORD *)v8 + 2) = (_DWORD)v43;
  }
  return result;
}

_QWORD *std::allocator_traits<TInlineBufferAllocator<`anonymous namespace'::MorxChainBuilder,30ul>>::construct[abi:nn180100]<`anonymous namespace'::MorxChainBuilder,`anonymous namespace'::MorxChainBuilder const&,void,void>(uint64_t a1, uint64_t a2)
{
  unint64_t *v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t *v7;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::vector<std::__wrap_iter<MortFeatureEntry const*>,0>((char **)(a1 + 8), *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
  v4 = *(unint64_t **)(a2 + 400);
  v5 = *(unint64_t **)(a2 + 408);
  *(_QWORD *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_QWORD *)(a1 + 664) = a1 + 424;
  std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>((_QWORD *)(a1 + 400), v4, v5, v5 - v4);
  v6 = *(unint64_t **)(a2 + 672);
  v7 = *(unint64_t **)(a2 + 680);
  *(_QWORD *)(a1 + 688) = 0;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_QWORD *)(a1 + 936) = a1 + 696;
  return std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>((_QWORD *)(a1 + 672), v6, v7, v7 - v6);
}

char **std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::vector<std::__wrap_iter<MortFeatureEntry const*>,0>(char **a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t v4;
  int64_t v5;
  char *v8;
  char *v9;

  *a1 = 0;
  a1[1] = 0;
  v4 = (uint64_t)(a1 + 3);
  a1[2] = 0;
  a1[48] = (char *)v4;
  v5 = a3 - a2;
  if (a3 != a2)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v5 >> 2) >= 0x1555555555555556)
      abort();
    v8 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate(v4, 0xAAAAAAAAAAAAAAABLL * (v5 >> 2));
    *a1 = v8;
    a1[1] = v8;
    v9 = &v8[4 * (v5 >> 2)];
    a1[2] = v9;
    if (a3 != a2)
      memmove(v8, a2, v5);
    a1[1] = v9;
  }
  return a1;
}

_QWORD *std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>(_QWORD *result, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  _QWORD *v7;
  _QWORD *v8;
  void *v9;

  if (a4)
  {
    if (a4 >> 61)
      abort();
    v7 = result;
    result = TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(result + 3), a4);
    v8 = result;
    *v7 = result;
    v7[1] = result;
    v7[2] = &result[a4];
    while (a2 != a3)
    {
      v9 = (void *)atomic_load(a2);
      result = v9;
      *v8++ = result;
      ++a2;
    }
    v7[1] = v8;
  }
  return result;
}

void std::allocator_traits<TInlineBufferAllocator<`anonymous namespace'::MorxChainBuilder,30ul>>::destroy[abi:nn180100]<`anonymous namespace'::MorxChainBuilder,void,void>(void **a1)
{
  void **v2;

  v2 = a1 + 84;
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  v2 = a1 + 50;
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  v2 = a1 + 1;
  std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  id *v2;
  id *v4;
  void **v5;
  void **v6;
  id *v7;
  void **v8;

  v1 = *a1;
  v2 = (id *)**a1;
  if (v2)
  {
    v4 = (id *)v1[1];
    v5 = (void **)**a1;
    v6 = v1;
    if (v4 != v2)
    {
      do
      {
        v7 = v4 - 1;

        v4 = v7;
      }
      while (v7 != v2);
      v6 = *a1;
      v5 = (void **)**a1;
    }
    v1[1] = v2;
    v8 = v6 + 33;
    if (v6 + 3 <= v5 && v8 > v5)
    {
      if (v6[2] == v6[33])
        *v8 = v5;
    }
    else
    {
      operator delete(v5);
    }
  }
}

void std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v3;
  BOOL v4;
  BOOL v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    v3 = v1 + 48;
    if (v1 + 3 <= v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[48])
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<LtagStringRange,TInlineBufferAllocator<LtagStringRange,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  BOOL v4;
  BOOL v5;

  v2 = *(_QWORD **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    v3 = (_QWORD *)(a1 + 144);
    if (a1 + 24 <= (unint64_t)v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 144))
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

unint64_t `anonymous namespace'::MorxChainBuilder::TotalSize(_anonymous_namespace_::MorxChainBuilder *this, unint64_t a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t i;
  const __CFData *v6;

  v3 = (unint64_t *)*((_QWORD *)this + 50);
  v2 = (unint64_t *)*((_QWORD *)this + 51);
  v4 = ((a2 + 7) >> 3) + 4;
  if (a2 > 0x10000)
    v4 = 8196;
  for (i = *((_QWORD *)this + 2) - *((_QWORD *)this + 1) + (v2 - v3) * v4 + 28; v3 != v2; ++v3)
  {
    v6 = (const __CFData *)atomic_load(v3);
    LODWORD(i) = CFDataGetLength(v6) + i;
  }
  return ((_DWORD)i + 3) & 0xFFFFFFFC | ((unint64_t)((((_DWORD)i + 3) & 0xFFFFFFFC) - i) << 32);
}

void std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::destroy(a1[1]);
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy((_QWORD *)a1[6]);
    operator delete(a1);
  }
}

void AddLigInputForCharacters(uint64_t *a1, TBaseFont *a2, __int16 a3, __int16 *a4, unint64_t a5)
{
  unint64_t v5;
  __int128 v9;
  char *v10;
  __int16 *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  __int16 v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  void *v27;
  __int128 v28;
  char *v29;
  uint64_t v30;
  uint64_t InitializedGraphicsFont;
  uint64_t v32;
  _WORD *v33;
  uint64_t v34;
  void **v36;
  char *v37;
  void **v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  void **v46;
  char *v47;
  __int16 v48;
  char *v49;
  TBaseFont *v51;
  uint64_t *v52;
  uint64_t v53;
  void **v54;
  char *v55;
  char *v56;
  _QWORD v57[2];
  unint64_t v58;
  _QWORD v59[5];
  void *v60[2];
  _BYTE v61[24];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  _BYTE *v65;
  char *v66;
  char *v67;
  char *v68;
  _OWORD v69[4];
  char *v70;
  uint64_t v71;

  v5 = a5;
  v71 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v69[2] = v9;
  v69[3] = v9;
  v53 = a5 + 1;
  v69[0] = v9;
  v69[1] = v9;
  *(_QWORD *)&v61[16] = v69;
  v10 = (char *)v69 + 2;
  v70 = (char *)v69 + 2;
  LOWORD(v69[0]) = a3;
  v66 = (char *)v69;
  v67 = (char *)v69 + 2;
  v68 = (char *)v69 + 2;
  *(_OWORD *)v60 = 0u;
  *(_OWORD *)v61 = 0u;
  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v60);
  v67 = (char *)v69 + 2;
  if (v5)
  {
    v51 = a2;
    v52 = a1;
    v11 = &a4[v5];
    do
    {
      v12 = *a4;
      if (v10 >= v68)
      {
        v13 = v66;
        v14 = v10 - v66;
        if (v10 - v66 <= -3)
LABEL_58:
          abort();
        v15 = v14 >> 1;
        if (v68 - v66 <= (unint64_t)((v14 >> 1) + 1))
          v16 = v15 + 1;
        else
          v16 = v68 - v66;
        if ((unint64_t)(v68 - v66) >= 0x7FFFFFFFFFFFFFFELL)
          v17 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v17 = v16;
        *(_QWORD *)&v61[16] = v69;
        if (v17)
        {
          v18 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v69, v17);
          v13 = v66;
          v10 = v67;
        }
        else
        {
          v18 = 0;
        }
        v19 = &v18[2 * v15];
        *(_WORD *)v19 = v12;
        if (v10 == v13)
        {
          v21 = &v18[2 * v15];
        }
        else
        {
          v20 = v10;
          v21 = &v18[2 * v15];
          do
          {
            v22 = *((_WORD *)v20 - 1);
            v20 -= 2;
            *((_WORD *)v21 - 1) = v22;
            v21 -= 2;
          }
          while (v20 != v13);
        }
        v23 = v19 + 2;
        v66 = v21;
        v67 = v19 + 2;
        v24 = v68;
        v68 = &v18[2 * v17];
        *(_QWORD *)v61 = v10;
        *(_QWORD *)&v61[8] = v24;
        v60[0] = v13;
        v60[1] = v13;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v60);
        v10 = v23;
      }
      else
      {
        *(_WORD *)v10 = v12;
        v10 += 2;
      }
      v67 = v10;
      ++a4;
    }
    while (a4 != v11);
    *(_QWORD *)&v25 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v64 = v25;
    v63 = v25;
    v62 = v25;
    *(_OWORD *)&v61[8] = v25;
    v60[1] = 0;
    *(_QWORD *)v61 = 0;
    v60[0] = 0;
    v65 = &v61[8];
    a1 = v52;
    a2 = v51;
    v26 = v53;
    if (!v53)
    {
      v27 = 0;
      goto LABEL_26;
    }
  }
  else
  {
    *(_QWORD *)&v28 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v64 = v28;
    v63 = v28;
    v62 = v28;
    *(_OWORD *)&v61[8] = v28;
    v60[1] = 0;
    *(_QWORD *)v61 = 0;
    v60[0] = 0;
    v65 = &v61[8];
    v26 = v53;
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](v60, v26);
  v29 = (char *)v60[1];
  bzero(v60[1], 2 * v5 + 2);
  v60[1] = &v29[2 * v26];
  v27 = v60[0];
LABEL_26:
  if ((*(uint64_t (**)(TBaseFont *, char *, void *, uint64_t))(*(_QWORD *)a2 + 664))(a2, v66, v27, v26) >= v26)
  {
    v58 = 0xAAAAAAAAAAAAAAAALL;
    v56 = 0;
    v57[0] = 0xAAAAAAAAAAAAAAAALL;
    v54 = 0;
    v55 = 0;
    v57[1] = v57;
    LOWORD(v58) = *(_WORD *)v60[0];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::reserve((char **)&v54, v5);
    v30 = *((_QWORD *)a2 + 25);
    if (!v30)
    {
      InitializedGraphicsFont = TBaseFont::GetInitializedGraphicsFont(a2);
      v30 = (*(uint64_t (**)(TBaseFont *, uint64_t))(*(_QWORD *)a2 + 872))(a2, InitializedGraphicsFont);
    }
    if (v26 < 2)
    {
LABEL_55:
    }
    else
    {
      v32 = 1;
      while (1)
      {
        v33 = v60[0];
        v34 = *((unsigned __int16 *)v60[0] + v32);
        if ((_DWORD)v34 == (unsigned __int16)v58 || v30 <= v34)
          break;
        v36 = (void **)v55;
        if (v55 >= v56)
        {
          v38 = v54;
          v39 = v55 - (char *)v54;
          if (v55 - (char *)v54 <= -3)
            goto LABEL_58;
          v40 = v5;
          v41 = v39 >> 1;
          if (v56 - (char *)v54 <= (unint64_t)((v39 >> 1) + 1))
            v42 = v41 + 1;
          else
            v42 = v56 - (char *)v54;
          if ((unint64_t)(v56 - (char *)v54) >= 0x7FFFFFFFFFFFFFFELL)
            v43 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v43 = v42;
          v59[4] = v57;
          if (v43)
          {
            v44 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v57, v43);
            v38 = v54;
            v36 = (void **)v55;
            LOWORD(v34) = v33[v32];
          }
          else
          {
            v44 = 0;
          }
          v45 = &v44[2 * v41];
          *(_WORD *)v45 = v34;
          if (v36 == v38)
          {
            v47 = &v44[2 * v41];
            v5 = v40;
          }
          else
          {
            v46 = v36;
            v47 = &v44[2 * v41];
            v5 = v40;
            do
            {
              v48 = *((_WORD *)v46 - 1);
              v46 = (void **)((char *)v46 - 2);
              *((_WORD *)v47 - 1) = v48;
              v47 -= 2;
            }
            while (v46 != v38);
          }
          v37 = v45 + 2;
          v54 = (void **)v47;
          v55 = v45 + 2;
          v49 = v56;
          v56 = &v44[2 * v43];
          v59[2] = v36;
          v59[3] = v49;
          v59[0] = v38;
          v59[1] = v38;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)v59);
        }
        else
        {
          *(_WORD *)v55 = v34;
          v37 = (char *)v36 + 2;
        }
        v55 = v37;
        if (v32++ == v5)
          goto LABEL_55;
      }
    }
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v54);
  }
  v54 = v60;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v54);
  v60[0] = &v66;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v60);
}

void CreateLookupTableFromCharacterSwashes<std::pair<unsigned short,unsigned short> const*>(unint64_t *a1, uint64_t a2, int64_t a3, int *a4, int *a5, uint64_t a6)
{
  __CFData *i;
  int v12;
  int v13;
  int v14;

  for (i = NewLKTHandle(a3, 0); a4 != a5; ++a4)
  {
    v12 = *a4;
    v13 = -1431655766;
    v14 = v12;
    if ((*(uint64_t (**)(uint64_t, int *, int *, uint64_t))(*(_QWORD *)a2 + 664))(a2, &v14, &v13, 2) == 2
      && LKTAddRange(i, (unsigned __int16)v13, (unsigned __int16)v13, SHIWORD(v13)))
    {
      *(_BYTE *)(a6 + ((unint64_t)(unsigned __int16)v13 >> 3)) |= 1 << (v13 & 7);
    }
  }
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  LKTCreateLookupTable(i, a1);
  DisposeLKTHandle(i);
}

uint64_t TForcedBidiLevelsProvider::GetLevels(int64x2_t *this, CFRange a2, CTWritingDirection a3)
{
  CFIndex length;
  uint64_t result;
  _BYTE *v6;
  int64x2_t *v7;
  _BYTE *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  CFIndex v12;
  size_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  _BYTE *v18;
  unint64_t v19;
  uint64_t v20;
  char v21;
  int64x2_t v22;
  char *v23;
  uint64_t v24;
  int64x2_t v25;
  char *v26;
  __int8 *v27;

  length = a2.length;
  v7 = this + 1;
  result = this[1].i64[0];
  v6 = (_BYTE *)v7->i64[1];
  v8 = &v6[-result];
  v9 = a2.length - (_QWORD)&v6[-result];
  if (a2.length <= (unint64_t)&v6[-result])
  {
    if (a2.length < (unint64_t)&v6[-result])
      this[1].i64[1] = result + a2.length;
  }
  else
  {
    v10 = this[2].i64[0];
    if (v10 - (uint64_t)v6 >= v9)
    {
      do
      {
        *v6++ = this->i8[8];
        --v9;
      }
      while (v9);
      this[1].i64[1] = a2.length + result;
    }
    else
    {
      if (a2.length < 0)
        abort();
      v11 = v10 - result;
      v12 = 2 * v11;
      if (2 * v11 <= a2.length)
        v12 = a2.length;
      if (v11 >= 0x3FFFFFFFFFFFFFFFLL)
        v13 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      v27 = &this[2].i8[8];
      v14 = this[4].i64[1];
      if (v14 + v13 <= (unint64_t)this[4].u64 + 6)
        this[4].i64[1] = v14 + v13;
      else
        v14 = (uint64_t)operator new(v13);
      v15 = &v8[v14];
      v16 = (char *)(v14 + v13);
      v26 = (char *)(v14 + v13);
      v17 = (char *)(v14 + length);
      v18 = &v8[v14];
      do
      {
        *v18++ = this->i8[8];
        --v9;
      }
      while (v9);
      v25.i64[1] = v14 + length;
      v20 = this[1].i64[0];
      v19 = this[1].u64[1];
      if (v19 == v20)
      {
        v22 = vdupq_n_s64(v19);
      }
      else
      {
        do
        {
          v21 = *(_BYTE *)--v19;
          *--v15 = v21;
        }
        while (v19 != v20);
        v22 = this[1];
        v17 = (char *)v25.i64[1];
        v16 = v26;
      }
      this[1].i64[0] = (uint64_t)v15;
      this[1].i64[1] = (uint64_t)v17;
      v25 = v22;
      v23 = (char *)this[2].i64[0];
      this[2].i64[0] = (uint64_t)v16;
      v26 = v23;
      v24 = v22.i64[0];
      std::__split_buffer<char,TInlineBufferAllocator<char,30ul> &>::~__split_buffer((uint64_t)&v24);
    }
    return this[1].i64[0];
  }
  return result;
}

uint64_t TForcedBidiLevelsProvider::GetDefaultParagraphDirection(TForcedBidiLevelsProvider *this)
{
  return *((_BYTE *)this + 8) & 1;
}

void TForcedBidiLevelsProvider::~TForcedBidiLevelsProvider(TForcedBidiLevelsProvider *this)
{
  void **v1;

  *(_QWORD *)this = off_1E15DE5E0;
  v1 = (void **)((char *)this + 16);
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

{
  void **v2;

  *(_QWORD *)this = off_1E15DE5E0;
  v2 = (void **)((char *)this + 16);
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  MEMORY[0x186DC03AC](this, 0x1091C406A714F82);
}

uint64_t GetCharClass(UChar32 a1)
{
  uint64_t result;

  if (a1 > 8287)
  {
    switch(a1)
    {
      case 43616:
      case 43617:
      case 43618:
      case 43619:
      case 43620:
      case 43621:
      case 43622:
      case 43623:
      case 43624:
      case 43625:
      case 43626:
      case 43627:
      case 43628:
      case 43629:
      case 43630:
      case 43631:
      case 43633:
      case 43634:
      case 43635:
      case 43636:
      case 43637:
      case 43638:
      case 43642:
      case 43646:
      case 43647:
LABEL_8:
        result = 0;
        break;
      case 43632:
      case 43639:
      case 43640:
      case 43641:
LABEL_12:
        result = 8;
        break;
      case 43643:
LABEL_13:
        result = 24;
        break;
      case 43644:
      case 43645:
LABEL_10:
        result = 25;
        break;
      default:
        switch(a1)
        {
          case 43488:
          case 43489:
          case 43490:
          case 43491:
          case 43492:
          case 43495:
          case 43496:
          case 43497:
          case 43498:
          case 43499:
          case 43500:
          case 43501:
          case 43502:
          case 43503:
          case 43514:
          case 43515:
          case 43516:
          case 43517:
          case 43518:
            goto LABEL_8;
          case 43493:
LABEL_11:
            result = 19;
            break;
          case 43494:
            goto LABEL_12;
          case 43504:
          case 43505:
          case 43506:
          case 43507:
          case 43508:
          case 43509:
          case 43510:
          case 43511:
          case 43512:
          case 43513:
LABEL_6:
            result = 2;
            break;
          default:
            if (a1 == 8288)
            {
              result = 10;
            }
            else
            {
LABEL_31:
              if ((IsGenericBase(a1) & 1) != 0)
              {
                result = 3;
              }
              else if ((a1 & 0xFFF0) == 0xFE00)
              {
                result = 9;
              }
              else if ((u_charType(a1) - 12) >= 3)
              {
                result = 6;
              }
              else
              {
                result = 11;
              }
            }
            break;
        }
        break;
    }
  }
  else
  {
    result = 21;
    switch(a1)
    {
      case 4096:
      case 4097:
      case 4098:
      case 4099:
      case 4100:
      case 4101:
      case 4102:
      case 4103:
      case 4104:
      case 4105:
      case 4106:
      case 4107:
      case 4108:
      case 4109:
      case 4110:
      case 4111:
      case 4112:
      case 4113:
      case 4114:
      case 4115:
      case 4116:
      case 4117:
      case 4118:
      case 4119:
      case 4120:
      case 4121:
      case 4122:
      case 4123:
      case 4124:
      case 4125:
      case 4126:
      case 4127:
      case 4128:
      case 4159:
      case 4174:
      case 4176:
      case 4177:
      case 4186:
      case 4187:
      case 4188:
      case 4189:
      case 4193:
      case 4197:
      case 4198:
      case 4206:
      case 4207:
      case 4208:
      case 4213:
      case 4214:
      case 4215:
      case 4216:
      case 4217:
      case 4218:
      case 4219:
      case 4220:
      case 4221:
      case 4222:
      case 4223:
      case 4224:
      case 4225:
      case 4238:
        goto LABEL_8;
      case 4129:
      case 4130:
      case 4131:
      case 4132:
      case 4133:
      case 4134:
      case 4135:
      case 4136:
      case 4137:
      case 4138:
      case 4178:
      case 4179:
      case 4180:
      case 4181:
        result = 5;
        break;
      case 4139:
      case 4140:
      case 4182:
      case 4183:
      case 4194:
      case 4199:
      case 4200:
      case 4227:
        result = 23;
        break;
      case 4141:
      case 4142:
      case 4147:
      case 4148:
      case 4149:
      case 4209:
      case 4210:
      case 4211:
      case 4212:
      case 4229:
      case 4230:
      case 4253:
        goto LABEL_11;
      case 4143:
      case 4144:
      case 4184:
      case 4185:
        result = 20;
        break;
      case 4145:
      case 4228:
        result = 18;
        break;
      case 4146:
      case 4150:
        return result;
      case 4151:
        result = 22;
        break;
      case 4152:
      case 4231:
      case 4232:
      case 4233:
      case 4234:
      case 4235:
      case 4236:
      case 4237:
      case 4239:
      case 4250:
      case 4251:
      case 4252:
        goto LABEL_10;
      case 4153:
        result = 4;
        break;
      case 4154:
        result = 12;
        break;
      case 4155:
      case 4190:
      case 4191:
        result = 13;
        break;
      case 4156:
        result = 14;
        break;
      case 4157:
      case 4226:
        result = 15;
        break;
      case 4158:
        result = 16;
        break;
      case 4160:
        result = 1;
        break;
      case 4161:
      case 4162:
      case 4163:
      case 4164:
      case 4165:
      case 4166:
      case 4167:
      case 4168:
      case 4169:
      case 4240:
      case 4241:
      case 4242:
      case 4243:
      case 4244:
      case 4245:
      case 4246:
      case 4247:
      case 4248:
      case 4249:
        goto LABEL_6;
      case 4170:
      case 4171:
        result = 7;
        break;
      case 4172:
      case 4173:
      case 4175:
      case 4254:
      case 4255:
        goto LABEL_12;
      case 4192:
        result = 17;
        break;
      case 4195:
      case 4196:
      case 4201:
      case 4202:
      case 4203:
      case 4204:
      case 4205:
        goto LABEL_13;
      default:
        if ((a1 - 8204) >= 2)
          goto LABEL_31;
        result = 26;
        break;
    }
  }
  return result;
}

uint64_t HasAnusvara(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;

  v3 = a1[1];
  if (v3 >= a3)
    return 0;
  v4 = (_DWORD *)(**(_QWORD **)(*a1 + 104) + 16 * v3 + 24);
  v5 = a1[1];
  while (1)
  {
    v6 = *(v4 - 4);
    if (v6 != 21)
      break;
    ++v5;
    v4 += 4;
    if (a3 == v5)
      goto LABEL_13;
  }
  if (v6 == 22)
  {
    v7 = v5 + 1;
    v8 = v5 + 1 < a3;
    a3 = v5 + 1;
    if (v8)
    {
      v9 = v5 + 2;
      if (*v4 == 12)
        a3 = v9;
      else
        a3 = v7;
    }
  }
  else
  {
    a3 = v5;
  }
LABEL_13:
  if (a3 == v3)
    return 0;
  a1[1] = a3;
  return 1;
}

uint64_t MyanmarShapingEngine::ApplyScriptShaping(MyanmarShapingEngine *this, const OTL::GSUB *a2, OTL::GlyphLookups *a3)
{
  int64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __int128 v16;
  TRunGlue *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  unsigned __int16 FullChar;
  int CharClass;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  TRunGlue *v26;
  int64_t v27;
  int v28;
  int v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  _BOOL4 v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  _DWORD *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  int *v63;
  int v64;
  uint64_t v65;
  int *v66;
  int v67;
  int v68;
  uint64_t *p_StringIndex;
  uint64_t v70;
  __int128 v72;
  uint64_t v73;
  unsigned int *v74;
  unint64_t v75;
  uint64_t v76;
  unsigned int v77;
  CFIndex *v78;
  CFIndex *v79;
  char v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  TRunGlue *v86;
  char v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  uint64_t v98;
  uint64_t v99;
  int64_t v100;
  uint64_t v101;
  uint64_t v102;
  BOOL v103;
  uint64_t v104;
  unsigned int v105;
  uint64_t v106;
  int64_t v107;
  uint64_t v108;
  uint64_t v109;
  int64_t v110;
  BOOL v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  BOOL v119;
  CFIndex *v120;
  CFIndex *v121;
  CFIndex v122;
  CFIndex v123;
  __int128 v124;
  uint64_t v125;
  CFIndex *v126;
  CFIndex *v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  unsigned int *v136;
  unsigned int *v137;
  unsigned int v138;
  __int128 v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  unsigned int *v145;
  unsigned int *v146;
  uint64_t *v147;
  unsigned int v148;
  __int128 v149;
  uint64_t v150;
  uint64_t *v151;
  uint64_t *v152;
  uint64_t v153;
  uint64_t v154;
  unsigned int *v155;
  unsigned int *v156;
  unsigned int v157;
  __int128 v158;
  uint64_t v159;
  uint64_t *v160;
  uint64_t *v161;
  uint64_t v162;
  uint64_t v163;
  unsigned int *v164;
  unsigned int *v165;
  uint64_t *v166;
  unsigned int v167;
  _QWORD *v168;
  uint64_t v169;
  _QWORD *v170;
  unsigned __int8 v171;
  int v172;
  void **v173;
  uint64_t StringIndex;
  unsigned __int16 **v175;
  uint64_t *v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 *v208;
  unsigned __int16 *v209;
  __int128 v210;
  _QWORD v211[390];
  _QWORD *v212;
  CFIndex *v213;
  CFIndex *v214;
  uint64_t v215;
  _OWORD v216[30];
  _OWORD *v217;
  __int128 v218;
  int v219[64];
  __int128 v220;
  uint64_t v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  __int128 v228;
  unint64_t v229;
  __int128 *v230;
  uint64_t v231;
  CFRange v232;

  v4 = MEMORY[0x1E0C80A78](this, a2);
  v168 = v6;
  v7 = v4;
  v231 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(v4 + 8);
  if ((*(_DWORD *)(v8 + 24) & 0x80000000) != 0)
    return 0;
  v9 = v5;
  v10 = (uint64_t)&StringIndex;
  v171 = 0;
  v12 = *v5;
  v11 = v5[1];
  v169 = v7;
  if (v11 != *v5)
  {
    do
    {
      v13 = v11 - 104;
      v209 = (unsigned __int16 *)(v11 - 96);
      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v209);
      v11 = v13;
    }
    while (v13 != v12);
    v7 = v169;
    v8 = *(_QWORD *)(v169 + 8);
  }
  v9[1] = v12;
  v14 = *(_QWORD *)(v8 + 104);
  v15 = TRunGlue::length((TRunGlue *)v8);
  v170 = (_QWORD *)v14;
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::resize(v14, v15);
  *(_QWORD *)&v16 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v216[28] = v16;
  v216[29] = v16;
  v216[26] = v16;
  v216[27] = v16;
  v216[24] = v16;
  v216[25] = v16;
  v216[22] = v16;
  v216[23] = v16;
  v216[20] = v16;
  v216[21] = v16;
  v216[18] = v16;
  v216[19] = v16;
  v216[16] = v16;
  v216[17] = v16;
  v216[15] = v16;
  v216[14] = v16;
  v216[13] = v16;
  v216[12] = v16;
  v216[11] = v16;
  v216[10] = v16;
  v216[9] = v16;
  v216[8] = v16;
  v216[7] = v16;
  v216[6] = v16;
  v216[5] = v16;
  v216[4] = v16;
  v216[3] = v16;
  v216[2] = v16;
  v216[1] = v16;
  v216[0] = v16;
  v215 = 0;
  v217 = v216;
  v17 = *(TRunGlue **)(v7 + 8);
  v209 = *(unsigned __int16 **)v7;
  v210 = 0u;
  memset(v211, 0, 168);
  v211[18] = *((_QWORD *)v209 + 2);
  v213 = 0;
  v214 = 0;
  v18 = TRunGlue::length(v17);
  if (v18)
  {
    v10 = v18;
    v19 = 0;
    for (i = 0; i != v10; ++i)
    {
      StringIndex = TRunGlue::GetStringIndex(v17, i);
      FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v209, &StringIndex, 0);
      CharClass = GetCharClass(FullChar);
      v23 = **((_QWORD **)v17 + 13) + v19;
      *(_DWORD *)(v23 + 8) = CharClass;
      *(_DWORD *)(v23 + 12) = 0;
      v19 += 16;
    }
  }
  StringIndex = (uint64_t)&off_1E15E0A30;
  v175 = (unsigned __int16 **)&v213;
  *(_QWORD *)&v177 = &StringIndex;
  v24 = TRunGlue::length(*(TRunGlue **)(v7 + 8));
  if (!v24)
    goto LABEL_178;
  v3 = v24;
  v25 = 0;
  do
  {
    v26 = *(TRunGlue **)(v7 + 8);
    if (v25 + 31 >= v3)
      v10 = v3;
    else
      v10 = v25 + 31;
    *((_QWORD *)&v220 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v220 = 0xAAAAAAAAAAAAAAAALL;
    if (v25 >= v10)
    {
      v28 = 0;
      v29 = 3;
      v10 = v25;
      goto LABEL_35;
    }
    v27 = v3;
    v28 = 0;
    v29 = 3;
    v30 = 1;
    v31 = v25;
    while (1)
    {
      v32 = 16 * v31;
      while (1)
      {
        v33 = v30 & (v28 == 0);
        v34 = v31 < v10;
        if (v31 >= v10 || (v30 & (v28 == 0)) == 0)
          break;
        *(_QWORD *)&v218 = TRunGlue::GetStringIndex(v26, v31);
        v35 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v209, (uint64_t *)&v218, 0);
        if (v35 != 4100 && v35 != 4186 && v35 != 4123
          || v31 + 1 >= v10
          || (*(_QWORD *)&v218 = TRunGlue::GetStringIndex(v26, v31 + 1),
              TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v209, (uint64_t *)&v218, 0) != 4154)
          || v31 + 2 >= v10
          || (*(_QWORD *)&v218 = TRunGlue::GetStringIndex(v26, v31 + 2),
              TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v209, (uint64_t *)&v218, 0) != 4153))
        {
          v28 = 0;
          v34 = 1;
          v30 = 1;
          v33 = 1;
          break;
        }
        v31 += 3;
        v32 += 48;
        v30 = 1;
        v28 = 1;
        if (v31 >= v10)
          goto LABEL_32;
      }
      v36 = **((_QWORD **)v26 + 13);
      v37 = *(_DWORD *)(v36 + v32 + 8);
      if (v37 > 0xB)
        goto LABEL_48;
      if (((1 << v37) & 0x2D) == 0)
      {
        if (((1 << v37) & 0xDC2) != 0)
        {
          *(_QWORD *)&v220 = v26;
          if (v33)
          {
            v38 = v31 + 1;
            if (v31 + 1 < v10)
            {
              v29 = 0;
              goto LABEL_42;
            }
            v29 = 0;
            goto LABEL_47;
          }
        }
        else
        {
LABEL_48:
          *(_QWORD *)&v220 = v26;
          if (v37 == 4 && (v30 & 1) != 0)
          {
            v38 = v31 + 1;
            if (v31 + 1 < v10)
            {
LABEL_42:
              if (*(_DWORD *)(v36 + v32 + 24) == 9)
                v10 = v31 + 2;
              else
                v10 = v38;
              goto LABEL_33;
            }
LABEL_47:
            v10 = v38;
            goto LABEL_33;
          }
        }
        v39 = v37 == 9 && v34;
        v31 += v39;
        goto LABEL_55;
      }
      if ((v30 & 1) == 0)
        break;
      v30 = 0;
      ++v31;
      v29 = 2;
      if (v31 >= v10)
      {
LABEL_32:
        v10 = v31;
LABEL_33:
        v3 = v27;
        v7 = v169;
        goto LABEL_35;
      }
    }
    *(_QWORD *)&v220 = v26;
LABEL_55:
    if (v31 >= v10)
      goto LABEL_74;
    while (2)
    {
      v40 = 0;
      v41 = v31;
      while (2)
      {
        v42 = *(_DWORD *)(v36 + 16 * v41 + 8);
        if (v42 <= 4)
        {
          if (v42 != 4)
          {
            if (v42)
              goto LABEL_74;
            goto LABEL_69;
          }
          if ((v40 & 1) != 0)
            goto LABEL_74;
          ++v41;
          goto LABEL_64;
        }
        if (v42 == 26)
        {
          if (++v41 < v10 && *(_DWORD *)(v36 + 16 * v41 + 8) == 26)
            goto LABEL_74;
LABEL_64:
          v40 = 1;
          if (v41 >= v10)
            goto LABEL_74;
          continue;
        }
        break;
      }
      if (v42 != 5)
        break;
LABEL_69:
      if ((v40 & 1) != 0)
      {
        v31 = v41 + 1;
        if (v41 + 1 < v10)
        {
          v43 = v41 + 2;
          if (*(_DWORD *)(v36 + 16 * v31 + 8) == 9)
            v31 = v43;
        }
        if (v31 < v10)
          continue;
      }
      break;
    }
LABEL_74:
    if (v31 == v10)
      goto LABEL_75;
    if (*(_DWORD *)(v36 + 16 * v31 + 8) == 4)
    {
      if (v31 + 1 >= v10)
      {
        v29 = 1;
        v10 = v31 + 1;
      }
      else
      {
        if (*(_DWORD *)(v36 + 16 * (v31 + 1) + 8) == 26)
          v10 = v31 + 2;
        else
          v10 = v31 + 1;
        v29 = 1;
      }
LABEL_75:
      v3 = v27;
      v7 = v169;
    }
    else
    {
      if (v31 >= v10)
        goto LABEL_93;
      v44 = (_DWORD *)(v36 + 16 * v31 + 24);
      while (1)
      {
        v45 = *(v44 - 4);
        if (v45 != 12)
          break;
        ++v31;
        v44 += 4;
        if (v10 == v31)
        {
          v46 = v10;
          v3 = v27;
          v7 = v169;
          goto LABEL_133;
        }
      }
      if (v45 == 13)
      {
        v47 = v31 + 1;
        if (v31 + 1 < v10 && *v44 == 12)
          v47 = v31 + 2;
      }
      else
      {
LABEL_93:
        v47 = v31;
      }
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 14)
        ++v47;
      v3 = v27;
      v7 = v169;
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 15)
        ++v47;
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 16)
        ++v47;
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 17)
        ++v47;
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 12)
        ++v47;
      if (v47 < v10)
      {
        while (*(_DWORD *)(v36 + 16 * v47 + 8) == 18)
        {
          v48 = v47 + 1;
          if (v47 + 1 < v10)
          {
            v49 = v47 + 2;
            if (*(_DWORD *)(v36 + 16 * v48 + 8) == 9)
              v48 = v49;
          }
          v47 = v48;
          if (v48 >= v10)
            goto LABEL_117;
        }
      }
      v48 = v47;
LABEL_117:
      if (v48 < v10)
      {
        while (*(_DWORD *)(v36 + 16 * v48 + 8) == 19)
        {
          v50 = v48 + 1;
          if (v48 + 1 < v10)
          {
            v51 = v48 + 2;
            if (*(_DWORD *)(v36 + 16 * v50 + 8) == 9)
              v50 = v51;
          }
          v48 = v50;
          if (v50 >= v10)
            goto LABEL_125;
        }
      }
      v50 = v48;
LABEL_125:
      if (v50 < v10)
      {
        while (*(_DWORD *)(v36 + 16 * v50 + 8) == 20)
        {
          v46 = v50 + 1;
          if (v50 + 1 < v10)
          {
            v52 = v50 + 2;
            if (*(_DWORD *)(v36 + 16 * v46 + 8) == 9)
              v46 = v52;
          }
          v50 = v46;
          if (v46 >= v10)
            goto LABEL_133;
        }
      }
      v46 = v50;
LABEL_133:
      *((_QWORD *)&v220 + 1) = v46;
      HasAnusvara(&v220, (uint64_t)v26, v10);
      while (1)
      {
        v218 = v220;
        if (*((uint64_t *)&v220 + 1) >= v10)
          break;
        v53 = **(_QWORD **)(v218 + 104);
        if (*(_DWORD *)(v53 + 16 * *((_QWORD *)&v220 + 1) + 8) != 23)
          break;
        v54 = *((_QWORD *)&v220 + 1) + 1;
        if (*((_QWORD *)&v220 + 1) + 1 < v10 && *(_DWORD *)(v53 + 16 * v54 + 8) == 9)
          v54 = *((_QWORD *)&v220 + 1) + 2;
        if (v54 < v10 && *(_DWORD *)(v53 + 16 * v54 + 8) == 16)
          ++v54;
        if (v54 < v10 && *(_DWORD *)(v53 + 16 * v54 + 8) == 17)
          ++v54;
        if (v54 < v10)
        {
          v55 = (int *)(v53 + 16 * v54 + 8);
          while (1)
          {
            v56 = *v55;
            v55 += 4;
            if (v56 != 12)
              break;
            if (v10 == ++v54)
            {
              v57 = v10;
              goto LABEL_158;
            }
          }
        }
        v57 = v54;
        if (v54 < v10)
        {
          while (*(_DWORD *)(v53 + 16 * v54 + 8) == 19)
          {
            v57 = v54 + 1;
            if (v54 + 1 < v10)
            {
              v58 = v54 + 2;
              if (*(_DWORD *)(v53 + 16 * v57 + 8) == 9)
                v57 = v58;
            }
            v54 = v57;
            if (v57 >= v10)
              goto LABEL_158;
          }
          v57 = v54;
        }
LABEL_158:
        *((_QWORD *)&v218 + 1) = v57;
        HasAnusvara(&v218, (uint64_t)v26, v10);
        v220 = v218;
      }
      v59 = *((_QWORD *)&v220 + 1);
      while (v59 < v10 && *(_DWORD *)(**(_QWORD **)(v220 + 104) + 16 * v59 + 8) == 24)
      {
        *((_QWORD *)&v220 + 1) = v59 + 1;
        v60 = HasAnusvara(&v220, (uint64_t)v26, v10);
        v59 = *((_QWORD *)&v220 + 1);
        if ((v60 & 1) == 0 && *((uint64_t *)&v220 + 1) < v10)
        {
          v61 = **(_QWORD **)(v220 + 104);
          if (*(_DWORD *)(v61 + 16 * *((_QWORD *)&v220 + 1) + 8) == 12)
          {
            v62 = *((_QWORD *)&v220 + 1) + 1;
            if (*((_QWORD *)&v220 + 1) + 1 < v10)
            {
              v63 = (int *)(v61 + 16 * *((_QWORD *)&v220 + 1) + 24);
              while (1)
              {
                v64 = *v63;
                v63 += 4;
                if (v64 != 21)
                  break;
                if (v10 == ++v62)
                {
                  v62 = v10;
                  break;
                }
              }
            }
            *((_QWORD *)&v220 + 1) = v62;
            v59 = v62;
          }
        }
      }
      if (v59 >= v10)
      {
        v10 = v59;
      }
      else
      {
        v65 = -v59;
        v66 = (int *)(**(_QWORD **)(v220 + 104) + 16 * v59 + 8);
        while (1)
        {
          v68 = *v66;
          v66 += 4;
          v67 = v68;
          if (v68 != 25)
            break;
          if (-v10 == --v65)
            goto LABEL_35;
        }
        v10 = (v67 == 26) - v65;
      }
    }
LABEL_35:
    *(_QWORD *)&v218 = v25;
    *((_QWORD *)&v218 + 1) = v10 - v25;
    LODWORD(v220) = v29;
    LOBYTE(v173) = v28 != 0;
    if (!(_QWORD)v177)
      std::__throw_bad_function_call[abi:nn180100]();
    (*(void (**)(void))(*(_QWORD *)v177 + 48))();
    v25 = v10;
  }
  while (v10 != v3);
LABEL_178:
  p_StringIndex = (uint64_t *)v177;
  if ((uint64_t *)v177 == &StringIndex)
  {
    v70 = 4;
    p_StringIndex = &StringIndex;
LABEL_183:
    (*(void (**)(void))(*p_StringIndex + 8 * v70))();
  }
  else if ((_QWORD)v177)
  {
    v70 = 5;
    goto LABEL_183;
  }
  *(_QWORD *)&v72 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v72 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v183 = v72;
  v182 = v72;
  v181 = v72;
  v180 = v72;
  v179 = v72;
  v178 = v72;
  v177 = v72;
  v175 = 0;
  v176 = 0;
  StringIndex = 0;
  *(_QWORD *)&v184 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v184 + 1) = &v177;
  v218 = xmmword_184948840;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v209, &v218, v219);
  OTL::GCommon::GetLookups((uint64_t)v168, (uint64_t)&v209, (uint64_t)&StringIndex, 0);
  *(_QWORD *)&v220 = &v209;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v220);
  memset(v211, 170, sizeof(v211));
  v210 = 0uLL;
  v209 = 0;
  v212 = v211;
  v73 = TRunGlue::length(*(TRunGlue **)(v7 + 8));
  v74 = (unsigned int *)StringIndex;
  v75 = (unint64_t)v175;
  if ((unsigned __int16 **)StringIndex != v175)
  {
    v76 = v73;
    do
    {
      v77 = *v74++;
      v10 = v10 & 0xFFFFFFFF00000000 | v77;
      OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v209, v10, 0, v76);
    }
    while (v74 != (unsigned int *)v75);
  }
  OTL::GSUB::ApplyLookups(v168, *(TRunGlue **)(v169 + 8), *(_DWORD *)(*(_QWORD *)(v169 + 8) + 24), &v209, &v171, 0, 0);
  *(_QWORD *)&v218 = &v209;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
  v209 = (unsigned __int16 *)&StringIndex;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v209);
  v78 = v213;
  v79 = v214;
  if (v213 == v214)
    goto LABEL_277;
  v80 = 0;
  v81 = 0;
  v75 = 3;
  while (1)
  {
LABEL_189:
    v3 = *v78;
    v82 = *((_DWORD *)v78 + 2);
    if (!v82)
    {
LABEL_199:
      v81 += v3;
      goto LABEL_271;
    }
    v83 = *((_BYTE *)v78 + 12) ? 3 : 0;
    v84 = v169;
    if (v82 == 3)
    {
      LOWORD(StringIndex) = 9676;
      LOWORD(v218) = -21846;
      v85 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v169 + 8) + 616) + 400);
      if (!(*(uint64_t (**)(uint64_t, uint64_t *, __int128 *, uint64_t))(*(_QWORD *)v85 + 664))(v85, &StringIndex, &v218, 1))goto LABEL_271;
      v86 = *(TRunGlue **)(v169 + 8);
      LOWORD(v209) = v218;
      v87 = TRunGlue::DoGlyphInsertion(v86, (const unsigned __int16 *)&v209, 1u, *((_DWORD *)v86 + 6) >= 0, 0, v81, v81, 1, 0);
      v171 |= v87;
      *(_DWORD *)(*v170 + 16 * v81 + 8) = 3;
      ++*v78;
      ++v3;
      v88 = 1;
    }
    else
    {
      v88 = 1;
      if (v83 >= 1)
      {
        v88 = v83 + 1;
        TRunGlue::Rotate(*(TRunGlue **)(v169 + 8), v81, v81 + v83, v83 + 1 + v81, v170);
        v80 = 1;
      }
      if (v82 == 1)
        goto LABEL_199;
    }
    v89 = v81;
    v90 = v81 + v88;
    v81 += v3;
    if (v90 < v81)
    {
      v91 = (16 * v90) | 8;
      while (1)
      {
        if (!TRunGlue::IsDeleted(*(TRunGlue **)(v169 + 8), v90))
        {
          v92 = *(_DWORD *)(*v170 + v91);
          if (v92 > 0xE)
            goto LABEL_206;
          if (v92 == 14)
            break;
        }
        ++v90;
        v91 += 16;
        if (v90 >= v81)
        {
LABEL_206:
          v84 = v169;
          goto LABEL_208;
        }
      }
      v84 = v169;
      v93 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v169 + 8), v90);
      v90 = v93 + v94;
      TRunGlue::Rotate(*(TRunGlue **)(v169 + 8), v89, v93, v93 + v94, v170);
      v80 = 1;
    }
LABEL_208:
    if (v90 < v81)
    {
      v95 = 0;
      v3 = -1;
      do
      {
        v96 = *(_DWORD *)(*v170 + 16 * v90 + 8);
        if (v96 > 0x12)
          break;
        if (v96 == 18 || v96 == 9)
        {
          v98 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v84 + 8), v90);
          if (v98 >= v3)
            v100 = v3;
          else
            v100 = v98;
          v101 = v3 + v95;
          if (v3 + v95 <= v98 + v99)
            v101 = v98 + v99;
          v102 = v101 - v100;
          v103 = v3 == -1;
          if (v3 == -1)
            v3 = v98;
          else
            v3 = v100;
          if (v103)
            v95 = v99;
          else
            v95 = v102;
          v90 = v95 + v3 - 1;
        }
        ++v90;
      }
      while (v90 < v81);
      if (v3 != -1)
      {
        TRunGlue::Rotate(*(TRunGlue **)(v84 + 8), v89, v3, v95 + v3, v170);
        v80 = 1;
      }
    }
    if (v90 >= v81)
      break;
    v3 = 0;
    v104 = -1;
    do
    {
      if (!TRunGlue::IsDeleted(*(TRunGlue **)(v84 + 8), v90))
      {
        v105 = *(_DWORD *)(*v170 + 16 * v90 + 8);
        if (v105 >= 0x14)
        {
          if (v105 != 20)
            break;
          v106 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v84 + 8), v90);
          if (v106 >= v104)
            v108 = v104;
          else
            v108 = v106;
          v109 = v104 + v3;
          if (v104 + v3 <= v106 + v107)
            v109 = v106 + v107;
          v110 = v109 - v108;
          v111 = v104 == -1;
          if (v104 == -1)
            v104 = v106;
          else
            v104 = v108;
          if (v111)
            v3 = v107;
          else
            v3 = v110;
          v90 = v3 + v104 - 1;
        }
      }
      ++v90;
    }
    while (v90 < v81);
    if (v104 == -1)
      break;
    v3 += v104;
    if (v3 >= v81)
      break;
    v112 = 0;
    v113 = -1;
    do
    {
      if (!TRunGlue::IsDeleted(*(TRunGlue **)(v84 + 8), v3))
      {
        if (*(_DWORD *)(*v170 + 16 * v3 + 8) != 21)
          break;
        v114 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v84 + 8), v3);
        if (v114 >= v113)
          v116 = v113;
        else
          v116 = v114;
        v117 = v113 + v112;
        if (v113 + v112 <= v114 + v115)
          v117 = v114 + v115;
        v118 = v117 - v116;
        v119 = v113 == -1;
        if (v113 == -1)
          v113 = v114;
        else
          v113 = v116;
        if (v119)
          v112 = v115;
        else
          v112 = v118;
        v3 = v112 + v113 - 1;
      }
      ++v3;
    }
    while (v3 < v81);
    if (v113 == -1)
      break;
    TRunGlue::Rotate(*(TRunGlue **)(v84 + 8), v104, v113, v112 + v113, v170);
    v78 += 2;
    v80 = 1;
    v75 = 3;
    if (v78 == v79)
      goto LABEL_273;
  }
  v75 = 3;
LABEL_271:
  v78 += 2;
  if (v78 != v79)
    goto LABEL_189;
  if ((v80 & 1) == 0)
    goto LABEL_277;
LABEL_273:
  v171 = 1;
  if (*(_QWORD *)(*(_QWORD *)(v169 + 8) + 152))
  {
    v120 = v213;
    v121 = v214;
    if (v213 != v214)
    {
      v122 = 0;
      do
      {
        v123 = *v120;
        v120 += 2;
        v232.location = v122;
        v232.length = v123;
        TRunGlue::ClearSafeToBreakAfter(*(_QWORD *)(v169 + 8), v232);
        v122 += v123;
      }
      while (v120 != v121);
    }
  }
LABEL_277:
  memset(v211, 170, sizeof(v211));
  v210 = 0uLL;
  v209 = 0;
  v212 = v211;
  *(_QWORD *)&v124 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v124 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v206 = v124;
  v207 = v124;
  v204 = v124;
  v205 = v124;
  v202 = v124;
  v203 = v124;
  v200 = v124;
  v201 = v124;
  v198 = v124;
  v199 = v124;
  v196 = v124;
  v197 = v124;
  v194 = v124;
  v195 = v124;
  v192 = v124;
  v193 = v124;
  v191 = v124;
  v190 = v124;
  v189 = v124;
  v188 = v124;
  v187 = v124;
  v186 = v124;
  v185 = v124;
  v184 = v124;
  v183 = v124;
  v182 = v124;
  v181 = v124;
  v180 = v124;
  v179 = v124;
  v178 = v124;
  v125 = (uint64_t)v168;
  StringIndex = (uint64_t)v168;
  v175 = &v209;
  v126 = v213;
  v127 = v214;
  v177 = 0uLL;
  v176 = 0;
  v208 = &v178;
  v128 = (char *)v214 - (char *)v213;
  if (v214 != v213)
  {
    if (v128 < 0)
      abort();
    v129 = v128 >> 4;
    v130 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)&v178, v128 >> 4);
    v131 = 0;
    v176 = (uint64_t *)v130;
    *((_QWORD *)&v177 + 1) = &v130[16 * v129];
    do
    {
      *(_OWORD *)&v130[v131 * 8] = *(_OWORD *)&v126[v131];
      v131 += 2;
    }
    while (&v126[v131] != v127);
    *(_QWORD *)&v177 = &v130[v131 * 8];
    v125 = StringIndex;
    *(_QWORD *)&v124 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v124 + 1) = 0xAAAAAAAAAAAAAAAALL;
  }
  v229 = 0xAAAAAAAAAAAAAAAALL;
  v228 = v124;
  v227 = v124;
  v226 = v124;
  v225 = v124;
  v224 = v124;
  v223 = v124;
  v222 = v124;
  v221 = 0;
  v220 = 0uLL;
  v172 = 1919969382;
  v230 = &v222;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v218, &v172, &v173);
  OTL::GCommon::GetLookups(v125, (uint64_t)&v218, (uint64_t)&v220, 0);
  v173 = (void **)&v218;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v173);
  v133 = v176;
  v132 = (uint64_t *)v177;
  if (v176 != (uint64_t *)v177)
  {
    v134 = 0;
    do
    {
      v135 = *v133;
      v136 = (unsigned int *)*((_QWORD *)&v220 + 1);
      v137 = (unsigned int *)v220;
      if ((_QWORD)v220 != *((_QWORD *)&v220 + 1))
      {
        v75 = (unint64_t)v175;
        do
        {
          v138 = *v137++;
          v3 = v3 & 0xFFFFFFFF00000000 | v138;
          OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v75, v3, v134, v135);
        }
        while (v137 != v136);
      }
      v134 += v135;
      v133 += 2;
    }
    while (v133 != v132);
  }
  *(_QWORD *)&v218 = &v220;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
  *(_QWORD *)&v139 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v139 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v228 = v139;
  v227 = v139;
  v226 = v139;
  v225 = v139;
  v224 = v139;
  v223 = v139;
  v222 = v139;
  v221 = 0;
  v220 = 0uLL;
  v229 = 0xAAAAAAAAAAAAAAAALL;
  v230 = &v222;
  v140 = StringIndex;
  v172 = 1886545254;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v218, &v172, &v173);
  OTL::GCommon::GetLookups(v140, (uint64_t)&v218, (uint64_t)&v220, 0);
  v173 = (void **)&v218;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v173);
  v141 = (unint64_t)v176;
  v142 = v177;
  if (v176 != (uint64_t *)v177)
  {
    v143 = 0;
    do
    {
      v144 = *(_QWORD *)v141;
      v145 = (unsigned int *)*((_QWORD *)&v220 + 1);
      v146 = (unsigned int *)v220;
      if ((_QWORD)v220 != *((_QWORD *)&v220 + 1))
      {
        v147 = (uint64_t *)v175;
        do
        {
          v148 = *v146++;
          v75 = v75 & 0xFFFFFFFF00000000 | v148;
          OTL::GlyphLookups::SetLookupInRange<false>(v147, v75, v143, v144);
        }
        while (v146 != v145);
      }
      v143 += v144;
      v141 += 16;
    }
    while (v141 != v142);
  }
  *(_QWORD *)&v218 = &v220;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
  *(_QWORD *)&v149 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v149 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v228 = v149;
  v227 = v149;
  v226 = v149;
  v225 = v149;
  v224 = v149;
  v223 = v149;
  v222 = v149;
  v221 = 0;
  v220 = 0uLL;
  v229 = 0xAAAAAAAAAAAAAAAALL;
  v230 = &v222;
  v172 = 1651275622;
  v150 = StringIndex;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v218, &v172, &v173);
  OTL::GCommon::GetLookups(v150, (uint64_t)&v218, (uint64_t)&v220, 0);
  v173 = (void **)&v218;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v173);
  v151 = v176;
  v152 = (uint64_t *)v177;
  if (v176 != (uint64_t *)v177)
  {
    v153 = 0;
    do
    {
      v154 = *v151;
      v155 = (unsigned int *)*((_QWORD *)&v220 + 1);
      v156 = (unsigned int *)v220;
      if ((_QWORD)v220 != *((_QWORD *)&v220 + 1))
      {
        v141 = (unint64_t)v175;
        do
        {
          v157 = *v156++;
          v142 = v142 & 0xFFFFFFFF00000000 | v157;
          OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v141, v142, v153, v154);
        }
        while (v156 != v155);
      }
      v153 += v154;
      v151 += 2;
    }
    while (v151 != v152);
  }
  *(_QWORD *)&v218 = &v220;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
  *(_QWORD *)&v158 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v158 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v228 = v158;
  v227 = v158;
  v226 = v158;
  v225 = v158;
  v224 = v158;
  v223 = v158;
  v222 = v158;
  v221 = 0;
  v220 = 0uLL;
  v229 = 0xAAAAAAAAAAAAAAAALL;
  v230 = &v222;
  v159 = StringIndex;
  v172 = 1886614630;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v218, &v172, &v173);
  OTL::GCommon::GetLookups(v159, (uint64_t)&v218, (uint64_t)&v220, 0);
  v173 = (void **)&v218;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v173);
  v160 = v176;
  v161 = (uint64_t *)v177;
  if (v176 != (uint64_t *)v177)
  {
    v162 = 0;
    do
    {
      v163 = *v160;
      v164 = (unsigned int *)*((_QWORD *)&v220 + 1);
      v165 = (unsigned int *)v220;
      if ((_QWORD)v220 != *((_QWORD *)&v220 + 1))
      {
        v166 = (uint64_t *)v175;
        do
        {
          v167 = *v165++;
          v141 = v141 & 0xFFFFFFFF00000000 | v167;
          OTL::GlyphLookups::SetLookupInRange<false>(v166, v141, v162, v163);
        }
        while (v165 != v164);
      }
      v162 += v163;
      v160 += 2;
    }
    while (v160 != v161);
  }
  *(_QWORD *)&v218 = &v220;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
  OTL::GSUB::ApplyLookups(v168, *(TRunGlue **)(v169 + 8), *(_DWORD *)(*(_QWORD *)(v169 + 8) + 24), &v209, &v171, 0, 0);
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v176);
  StringIndex = (uint64_t)&v209;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&StringIndex);
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v213);
  return v171;
}

void std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__append((char **)a1, a2 - v2);
  }
}

uint64_t IsGenericBase(int a1)
{
  uint64_t result;
  unsigned int v3;

  result = 1;
  if (a1 > 9675)
  {
    v3 = a1 - 9676;
    if (v3 > 0x32 || ((1 << v3) & 0x7800000000001) == 0)
      return 0;
  }
  else if (((a1 - 8210) > 0x10 || ((1 << (a1 - 18)) & 0x1000F) == 0) && a1 != 160 && a1 != 215)
  {
    return 0;
  }
  return result;
}

void std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__append(char **a1, unint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  unint64_t v17;
  int64x2_t v18;
  char *v19;
  uint64_t v20;
  int64x2_t v21;
  char *v22;
  uint64_t *v23;

  v5 = a1[1];
  v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      bzero(a1[1], 16 * a2);
      v5 += 16 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = (uint64_t)(a1 + 3);
    v7 = v5 - *a1;
    v8 = a2 + (v7 >> 4);
    if (v8 >> 60)
      abort();
    v9 = v7 >> 4;
    v10 = v4 - *a1;
    if (v10 >> 3 > v8)
      v8 = v10 >> 3;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v8;
    v23 = (uint64_t *)(a1 + 3);
    if (v11)
      v12 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v6, v11);
    else
      v12 = 0;
    v13 = &v12[16 * v9];
    v14 = &v12[16 * v11];
    bzero(v13, 16 * a2);
    v15 = &v13[16 * a2];
    v16 = *a1;
    v17 = (unint64_t)a1[1];
    if ((char *)v17 == *a1)
    {
      v18 = vdupq_n_s64(v17);
    }
    else
    {
      do
      {
        *((_OWORD *)v13 - 1) = *(_OWORD *)(v17 - 16);
        v13 -= 16;
        v17 -= 16;
      }
      while ((char *)v17 != v16);
      v18 = *(int64x2_t *)a1;
    }
    *a1 = v13;
    a1[1] = v15;
    v21 = v18;
    v19 = a1[2];
    a1[2] = v14;
    v22 = v19;
    v20 = v18.i64[0];
    std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v20);
  }
}

void std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15E0A30;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15E0A30;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::operator()(uint64_t a1, uint64_t a2, int *a3, char *a4)
{
  uint64_t v4;
  int v5;
  char v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  _QWORD *v20;

  v4 = *(_QWORD *)(a2 + 8);
  v5 = *a3;
  v6 = *a4;
  v7 = *(_QWORD *)(a1 + 8);
  v9 = *(_QWORD **)(v7 + 8);
  v8 = *(_QWORD *)(v7 + 16);
  if ((unint64_t)v9 >= v8)
  {
    v11 = *(_QWORD **)v7;
    v12 = ((uint64_t)v9 - *(_QWORD *)v7) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      abort();
    v14 = v8 - (_QWORD)v11;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
    {
      v16 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v7 + 24, v15);
      v11 = *(_QWORD **)v7;
      v9 = *(_QWORD **)(v7 + 8);
    }
    else
    {
      v16 = 0;
    }
    v17 = &v16[16 * v12];
    *(_QWORD *)v17 = v4;
    *((_DWORD *)v17 + 2) = v5;
    v17[12] = v6;
    v18 = v17;
    if (v9 != v11)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v9 - 1);
        v18 -= 16;
        v9 -= 2;
      }
      while (v9 != v11);
      v11 = *(_QWORD **)v7;
    }
    v10 = v17 + 16;
    *(_QWORD *)v7 = v18;
    *(_QWORD *)(v7 + 8) = v17 + 16;
    v19 = *(_QWORD *)(v7 + 16);
    *(_QWORD *)(v7 + 16) = &v16[16 * v15];
    if (v11)
    {
      v20 = (_QWORD *)(v7 + 504);
      if (v7 + 24 <= (unint64_t)v11 && v20 > v11)
      {
        if (v19 == *v20)
          *v20 = v11;
      }
      else
      {
        operator delete(v11);
      }
    }
  }
  else
  {
    *v9 = v4;
    *((_DWORD *)v9 + 2) = v5;
    v10 = (char *)(v9 + 2);
    *((_BYTE *)v9 + 12) = v6;
  }
  *(_QWORD *)(v7 + 8) = v10;
}

BOOL IsLooseFontNameMatchingDisabled(void)
{
  if (gDisableLooseFontNameMatchingOverride)
    return 1;
  if (IsLooseFontNameMatchingDisabled(void)::onceToken != -1)
    dispatch_once(&IsLooseFontNameMatchingDisabled(void)::onceToken, &__block_literal_global_1);
  return gDisableLooseFontNameMatchingOverride != 0;
}

uint64_t ___Z31IsLooseFontNameMatchingDisabledv_block_invoke()
{
  uint64_t result;

  result = objc_msgSend((id)objc_msgSend((id)CTFontGetPlistFromGSFontCache(CFSTR("CoreTextConfig.plist"), 0), "objectForKey:", CFSTR("StrictMatch")), "BOOLValue");
  gDisableLooseFontNameMatchingOverride = result;
  return result;
}

BOOL IsPostScriptNameAlias(const __CFString *a1, const __CFString *a2)
{
  const __CFString *v3;
  void *v4;
  const __CFString *v5;
  __CFString *v6;
  _BOOL8 v7;
  id v9;
  id v10;

  v10 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyLowercasedString(a1, (unint64_t *)&v10);
  v3 = (const __CFString *)atomic_load((unint64_t *)&v10);
  CopyPostScriptNameForAliasLowercased(v3, (unint64_t *)&v9);
  v4 = (void *)atomic_load((unint64_t *)&v9);
  v5 = v4;
  v6 = (__CFString *)v5;
  if (v5 == a2)
  {
    v7 = 1;
  }
  else
  {
    v7 = 0;
    if (a2 && v5)
      v7 = CFStringCompare(v5, a2, 1uLL) == kCFCompareEqualTo;
  }

  return v7;
}

uint64_t SoftLinked__FSFontIsOverriddenSystemFontName(const __CFString *a1)
{
  uint64_t (*IsOverriddenSystemFontNameSymbolLoc)(const __CFString *);
  uint64_t result;
  void *v4;

  IsOverriddenSystemFontNameSymbolLoc = (uint64_t (*)(const __CFString *))getFSFontIsOverriddenSystemFontNameSymbolLoc();
  if (IsOverriddenSystemFontNameSymbolLoc)
    return IsOverriddenSystemFontNameSymbolLoc(a1);
  v4 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "BOOL SoftLinked__FSFontIsOverriddenSystemFontName(CFStringRef)"), CFSTR("MetadataSupport.cpp"), 27, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

BOOL IsInvisibleSystemFontName(const __CFString *a1)
{
  const __CFNumber *v1;
  _BOOL8 v2;
  id v4;
  int valuePtr;

  CopyAttributeForSystemFont(a1, CFSTR("CTFontInvisibleAttribute"), (const __CFString **)&v4);
  do
    v1 = (const __CFNumber *)__ldaxr((unint64_t *)&v4);
  while (__stlxr(0, (unint64_t *)&v4));

  if (v1)
  {
    valuePtr = -1431655766;
    CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
    v2 = valuePtr != 0;
  }
  else
  {
    v2 = 0;
  }

  return v2;
}

const void *IsInvisibleSystemFontPostScriptNameWithoutPrecedingPeriod(const void *value)
{
  const void *v1;

  if (value)
  {
    v1 = value;
    if (qword_1ECDE7DB8 != -1)
      dispatch_once(&qword_1ECDE7DB8, &__block_literal_global_22);
    value = (const void *)qword_1ECDE7DB0;
    if (qword_1ECDE7DB0)
      return (const void *)(CFSetContainsValue((CFSetRef)qword_1ECDE7DB0, v1) != 0);
  }
  return value;
}

void ___Z57IsInvisibleSystemFontPostScriptNameWithoutPrecedingPeriodPK10__CFString_block_invoke()
{
  unint64_t v0;
  id v1;
  void *values[2];
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = xmmword_1E15E84C8;
  v7 = *(_OWORD *)&off_1E15E84D8;
  v8 = xmmword_1E15E84E8;
  *(_OWORD *)values = xmmword_1E15E8488;
  v3 = *(_OWORD *)&off_1E15E8498;
  v4 = xmmword_1E15E84A8;
  v5 = *(_OWORD *)&off_1E15E84B8;
  v1 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)values, 14, MEMORY[0x1E0C9B3B0]);
  do
    v0 = __ldaxr((unint64_t *)&v1);
  while (__stlxr(0, (unint64_t *)&v1));
  qword_1ECDE7DB0 = v0;

}

BOOL GetStringEncodingSpecialCase(_BOOL8 key, unsigned int *a2)
{
  const void *v3;
  int ValueIfPresent;
  void *value;

  if (key)
  {
    v3 = (const void *)key;
    if (qword_1ECDE7DC8 != -1)
      dispatch_once_f(&qword_1ECDE7DC8, 0, (dispatch_function_t)GetStringEncodingSpecialCase(__CFString const*,unsigned int *)::$_0::__invoke);
    value = (void *)0xAAAAAAAAAAAAAAAALL;
    ValueIfPresent = CFDictionaryGetValueIfPresent((CFDictionaryRef)qword_1ECDE7DC0, v3, (const void **)&value);
    key = ValueIfPresent != 0;
    if (ValueIfPresent)
      *a2 = value;
  }
  return key;
}

uint64_t getFSFontIsOverriddenSystemFontNameSymbolLoc(void)
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = qword_1ECDE7DE8;
  v6 = qword_1ECDE7DE8;
  if (!qword_1ECDE7DE8)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = ___ZL44getFSFontIsOverriddenSystemFontNameSymbolLocv_block_invoke;
    v2[3] = &unk_1E15E20C0;
    v2[4] = &v3;
    ___ZL44getFSFontIsOverriddenSystemFontNameSymbolLocv_block_invoke(v2);
    v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void GetStringEncodingSpecialCase(__CFString const*,unsigned int *)::$_0::__invoke()
{
  const __CFAllocator *v0;
  __CFDictionary *Mutable;
  const __CFAllocator *v2;
  char **v3;
  const void *v4;
  CFStringRef v5;
  CFStringRef v6;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 29, MEMORY[0x1E0C9B390], 0);
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  v3 = &GetStringEncodingSpecialCase(__CFString const*,unsigned int *)::kPostScriptNameToEncodingMap;
  do
  {
    v4 = (const void *)*((unsigned int *)v3 + 2);
    v5 = CFStringCreateWithCStringNoCopy(v0, *v3, 0x600u, v2);
    if (v5)
    {
      v6 = v5;
      CFDictionaryAddValue(Mutable, v5, v4);
      CFRelease(v6);
    }
    v3 += 2;
  }
  while (v3 != (char **)&__block_literal_global_80);
  qword_1ECDE7DC0 = (uint64_t)Mutable;
}

char *GetUncompressedBitmapRepresentation(char *result, uint64_t a2, int a3, char *__dst)
{
  int v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v10;
  unsigned int v11;
  unsigned int v12;

  v5 = *((_DWORD *)result + 1);
  v6 = a2 - (v5 & 1);
  v7 = result + 8;
  v8 = &result[v6];
  while (v7 < v8)
  {
    v11 = *(unsigned __int16 *)v7;
    v10 = v7 + 2;
    result = (char *)memcpy(__dst, v10, 2 * v11);
    v7 = &v10[2 * v11];
    __dst += 2 * v11;
    if (v7 < v8)
    {
      v12 = *(unsigned __int16 *)v7;
      v7 += 2;
      result = (char *)memset(__dst, a3, 2 * v12);
      __dst += 2 * v12;
    }
  }
  if ((v5 & 1) != 0)
    *__dst = *v7;
  return result;
}

void CreateMemorySafeFontWithData(const __CFData *a1@<X0>, unint64_t *a2@<X8>)
{
  void *MemorySafeFontsFromData;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  unint64_t v7;

  *a2 = 0;
  if (a1)
  {
    MemorySafeFontsFromData = (void *)FPFontCreateMemorySafeFontsFromData();
    v4 = MemorySafeFontsFromData;
    if (v4)
    {
      v5 = v4;
      Count = CFArrayGetCount(v4);

      if (!Count)
      {
LABEL_7:

        return;
      }
      CFArrayGetValueAtIndex((CFArrayRef)MemorySafeFontsFromData, 0);
      v7 = CGFontCreateWithParserFont();
      do
        v4 = (const __CFArray *)__ldaxr(a2);
      while (__stlxr(v7, a2));
    }

    goto LABEL_7;
  }
}

void CopyPathFromInMemoryFontURL(const __CFURL *a1@<X0>, CFStringRef *a2@<X8>)
{
  __int128 v3;
  CFIndex BytesForComponent;
  CFIndex v5;
  CFStringRef v6;
  UInt8 **v7;
  UInt8 *v8[3];
  _OWORD v9[12];
  _OWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[11] = v3;
    v9[10] = v3;
    v9[9] = v3;
    v9[8] = v3;
    v9[7] = v3;
    v9[6] = v3;
    v9[4] = v3;
    v9[5] = v3;
    v9[2] = v3;
    v9[3] = v3;
    v9[0] = v3;
    v9[1] = v3;
    memset(v8, 0, sizeof(v8));
    v10 = v9;
    BytesForComponent = GetBytesForComponent(a1, v8);
    if (BytesForComponent == -1)
      v6 = 0;
    else
      v6 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &v8[0][BytesForComponent], v5, 0x8000100u, 0);
    *a2 = v6;
    v7 = v8;
    std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v7);
  }
  else
  {
    *a2 = 0;
  }
}

void CreateMaskedPath(const CGPath *a1@<X0>, CGPathRef path@<X1>, CGFloat a3@<D0>, CGAffineTransform *a4@<X2>, char a5@<W3>, unint64_t *a6@<X8>)
{
  const __CFArray *SeparateComponents;
  CGMutablePathRef Mutable;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  void *v14;
  const CGPath *v15;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGPath *v20;
  const CGPath *v21;
  unint64_t v22;
  void *v23;
  const CGPath *v24;
  unint64_t v25;
  void *v26;
  const CGPath *v27;
  const CGPath *v28;
  const __CFArray *v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex i;
  const CGPath *ValueAtIndex;
  CGPath *v35;
  unint64_t v36;
  id CopyBySubtractingPath;
  id v40[5];
  id v41;
  CGAffineTransform *v42;
  CGRect BoundingBox;
  CGRect v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect PathBoundingBox;

  SeparateComponents = CGPathCreateSeparateComponents(path, 0);
  Mutable = CGPathCreateMutable();
  if (SeparateComponents)
  {
    Count = CFArrayGetCount(SeparateComponents);
    if (Count)
    {
      v12 = Count;
      v13 = 0;
      v14 = (void *)MEMORY[0x1E0C809B0];
      do
      {
        CFArrayGetValueAtIndex(SeparateComponents, v13);
        v40[1] = v14;
        v40[2] = (id)3321888768;
        v40[3] = ___Z16CreateMaskedPathPK6CGPathS1_dP17CGAffineTransformb_block_invoke;
        v40[4] = &__block_descriptor_48_8_32c21_ZTS6TCFRefIP6CGPathE_e40_v24__0r__CGPathElement_i__CGPoint__8_B16l;
        v41 = Mutable;
        v42 = a4;
        CGPathApplyWithBlock2();

        ++v13;
      }
      while (v12 != v13);
    }
  }
  v40[0] = CGPathCreateCopyByStrokingPath(Mutable, 0, a3, kCGLineCapButt, kCGLineJoinRound, 0.0);
  v15 = a1;
  if ((a5 & 1) != 0)
  {
    BoundingBox = CGPathGetBoundingBox(a1);
    x = BoundingBox.origin.x;
    y = BoundingBox.origin.y;
    width = BoundingBox.size.width;
    height = BoundingBox.size.height;
    v20 = CGPathCreateMutable();
    v44.origin.x = x;
    v44.origin.y = y;
    v44.size.width = width;
    v44.size.height = height;
    v45.origin.x = CGRectGetMinX(v44);
    v45.origin.y = y;
    v45.size.width = a3;
    v45.size.height = height;
    CGPathAddRect(v20, 0, v45);
    v46.origin.x = x;
    v46.origin.y = y;
    v46.size.width = width;
    v46.size.height = height;
    v47.origin.x = CGRectGetMaxX(v46);
    v47.size.width = -a3;
    v47.origin.y = y;
    v47.size.height = height;
    CGPathAddRect(v20, 0, v47);
    v21 = (const CGPath *)atomic_load((unint64_t *)v40);
    CopyBySubtractingPath = CGPathCreateCopyBySubtractingPath(v21, v20, 0);
    do
      v22 = __ldaxr((unint64_t *)&CopyBySubtractingPath);
    while (__stlxr(0, (unint64_t *)&CopyBySubtractingPath));
    do
      v23 = (void *)__ldaxr((unint64_t *)v40);
    while (__stlxr(v22, (unint64_t *)v40));

  }
  v24 = (const CGPath *)atomic_load((unint64_t *)v40);
  CopyBySubtractingPath = CGPathCreateCopyByUnioningPath(v24, Mutable, 0);
  do
    v25 = __ldaxr((unint64_t *)&CopyBySubtractingPath);
  while (__stlxr(0, (unint64_t *)&CopyBySubtractingPath));
  do
    v26 = (void *)__ldaxr((unint64_t *)v40);
  while (__stlxr(v25, (unint64_t *)v40));

  v27 = (const CGPath *)atomic_load((unint64_t *)v40);
  v28 = CGPathCreateCopyBySubtractingPath(v15, v27, 0);
  v29 = CGPathCreateSeparateComponents(v28, 0);
  CopyBySubtractingPath = CGPathCreateMutable();
  if (v29)
  {
    v30 = CFArrayGetCount(v29);
    if (v30)
    {
      v31 = v30;
      for (i = 0; i != v31; ++i)
      {
        ValueAtIndex = (const CGPath *)CFArrayGetValueAtIndex(v29, i);
        PathBoundingBox = CGPathGetPathBoundingBox(ValueAtIndex);
        if (PathBoundingBox.size.width >= a3 || PathBoundingBox.size.height >= a3)
        {
          v35 = (CGPath *)atomic_load((unint64_t *)&CopyBySubtractingPath);
          CGPathAddPath(v35, 0, ValueAtIndex);
        }
      }
    }
  }
  do
    v36 = __ldaxr((unint64_t *)&CopyBySubtractingPath);
  while (__stlxr(0, (unint64_t *)&CopyBySubtractingPath));
  *a6 = v36;

}

void ___Z16CreateMaskedPathPK6CGPathS1_dP17CGAffineTransformb_block_invoke(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  CGPath *v3;
  CGPath *v4;
  CGPath *v5;
  CGPath *v6;
  CGFloat *v7;
  CGPath *v9;

  switch(*(_DWORD *)a2)
  {
    case 0:
      v3 = (CGPath *)atomic_load((unint64_t *)(a1 + 32));
      CGPathMoveToPoint(v3, *(const CGAffineTransform **)(a1 + 40), **(CGFloat **)(a2 + 8), *(CGFloat *)(*(_QWORD *)(a2 + 8) + 8));
      break;
    case 1:
      v4 = (CGPath *)atomic_load((unint64_t *)(a1 + 32));
      CGPathAddLineToPoint(v4, *(const CGAffineTransform **)(a1 + 40), **(CGFloat **)(a2 + 8), *(CGFloat *)(*(_QWORD *)(a2 + 8) + 8));
      break;
    case 2:
      v5 = (CGPath *)atomic_load((unint64_t *)(a1 + 32));
      CGPathAddQuadCurveToPoint(v5, *(const CGAffineTransform **)(a1 + 40), **(CGFloat **)(a2 + 8), *(CGFloat *)(*(_QWORD *)(a2 + 8) + 8), *(CGFloat *)(*(_QWORD *)(a2 + 8) + 16), *(CGFloat *)(*(_QWORD *)(a2 + 8) + 24));
      break;
    case 3:
      v6 = (CGPath *)atomic_load((unint64_t *)(a1 + 32));
      v7 = *(CGFloat **)(a2 + 8);
      CGPathAddCurveToPoint(v6, *(const CGAffineTransform **)(a1 + 40), *v7, v7[1], v7[2], v7[3], v7[4], v7[5]);
      break;
    case 4:
      v9 = (CGPath *)atomic_load((unint64_t *)(a1 + 32));
      CGPathCloseSubpath(v9);
      *a3 = 1;
      break;
    default:
      return;
  }
}

id __copy_helper_block_8_32c21_ZTS6TCFRefIP6CGPathE(uint64_t a1, uint64_t a2)
{
  void *v3;
  id result;

  v3 = (void *)atomic_load((unint64_t *)(a2 + 32));
  result = v3;
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_8_32c21_ZTS6TCFRefIP6CGPathE(uint64_t a1)
{

}

void TArabicJustEngine::PostcompTable(TArabicJustEngine *this@<X0>, unint64_t *a2@<X8>)
{
  const __CTFont *v4;
  CFIndex GlyphCount;
  __CFData *v6;
  uint64_t **i;
  const __CFData *v9;
  CFIndex Length;
  uint64_t **j;
  unint64_t v12;
  __CFData *v13;
  const __CFData *v14;
  const UInt8 *BytePtr;
  __CFData *v16;
  __int16 v17;
  char v18;
  char v19;
  __CFData *v20;
  __CFData *v21;
  __CFData *v22;
  __CFData *v23;
  __CFData *v24;
  id v25;
  id v26;
  id Mutable;
  UInt8 bytes[4];

  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v4 = (const __CTFont *)atomic_load((unint64_t *)(*((_QWORD *)this + 1) + 56));
  GlyphCount = CTFontGetGlyphCount(v4);
  v6 = NewLKTHandle(GlyphCount, 0);
  for (i = (uint64_t **)*((_QWORD *)this + 6); i; i = (uint64_t **)*i)
    LKTAddRange(v6, *((unsigned __int16 *)i + 8), *((unsigned __int16 *)i + 8), 1);
  LKTCreateLookupTable(v6, (unint64_t *)&v26);
  if (atomic_load((unint64_t *)&v26))
  {
    v9 = (const __CFData *)atomic_load((unint64_t *)&v26);
    Length = CFDataGetLength(v9);
  }
  else
  {
    Length = 0;
  }

  for (j = (uint64_t **)*((_QWORD *)this + 6); j; j = (uint64_t **)*j)
    LKTAddRange(v6, *((unsigned __int16 *)j + 8), *((unsigned __int16 *)j + 8), Length);
  v25 = (id)0xAAAAAAAAAAAAAAAALL;
  LKTCreateLookupTable(v6, (unint64_t *)&v25);
  DisposeLKTHandle(v6);
  v12 = atomic_load((unint64_t *)&v25);
  if (v12)
  {
    v13 = (__CFData *)atomic_load((unint64_t *)&Mutable);
    v14 = (const __CFData *)atomic_load((unint64_t *)&v25);
    BytePtr = CFDataGetBytePtr(v14);
    CFDataAppendBytes(v13, BytePtr, Length);
    v16 = (__CFData *)atomic_load((unint64_t *)&Mutable);
    *(_DWORD *)bytes = 0x2000000;
    CFDataAppendBytes(v16, bytes, 4);
    v17 = 0;
    v18 = 1;
    do
    {
      v19 = v18;
      v20 = (__CFData *)atomic_load((unint64_t *)&Mutable);
      *(_WORD *)bytes = v17;
      CFDataAppendBytes(v20, bytes, 2);
      v21 = (__CFData *)atomic_load((unint64_t *)&Mutable);
      *(_WORD *)bytes = 1280;
      CFDataAppendBytes(v21, bytes, 2);
      v22 = (__CFData *)atomic_load((unint64_t *)&Mutable);
      *(_DWORD *)bytes = 201326592;
      CFDataAppendBytes(v22, bytes, 4);
      v23 = (__CFData *)atomic_load((unint64_t *)&Mutable);
      *(_WORD *)bytes = 0;
      CFDataAppendBytes(v23, bytes, 2);
      v24 = (__CFData *)atomic_load((unint64_t *)&Mutable);
      *(_WORD *)bytes = bswap32(*((unsigned __int16 *)this + 8)) >> 16;
      CFDataAppendBytes(v24, bytes, 2);
      v18 = 0;
      v17 = 256;
    }
    while ((v19 & 1) != 0);
    do
      v12 = __ldaxr((unint64_t *)&Mutable);
    while (__stlxr(0, (unint64_t *)&Mutable));
  }
  *a2 = v12;

}

uint64_t TArabicJustEngine::HasPostcompensation(TArabicJustEngine *this)
{
  return 1;
}

void TFallbacksSource::CopyDescriptorsForFamily(TPurgeableCache **this@<X0>, const __CFString *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v6;
  unint64_t v8;
  void *v9;
  TPurgeableCache *v11;
  unint64_t v12;
  void *v13;
  TPurgeableCache *v14;
  id v15;

  *a3 = 0xAAAAAAAAAAAAAAAALL;
  TPurgeableCache::RetainedValueForKey(*this, a2, (unint64_t *)&v15);
  do
    v6 = __ldaxr((unint64_t *)&v15);
  while (__stlxr(0, (unint64_t *)&v15));
  *a3 = v6;

  if (!atomic_load(a3))
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v14);
    TDescriptorSource::CopyMatchingDescriptorsForFamily(&v14, a2, 0, 0x10063uLL, (unint64_t *)&v15);
    do
      v8 = __ldaxr((unint64_t *)&v15);
    while (__stlxr(0, (unint64_t *)&v15));
    do
      v9 = (void *)__ldaxr(a3);
    while (__stlxr(v8, a3));

    if (atomic_load(a3))
    {
      v11 = *this;
      v12 = atomic_load(a3);
      v13 = (void *)atomic_load((unint64_t *)v11);
      if (v12)
        objc_msgSend(v13, "setObject:forKey:", v12, a2);
      else
        objc_msgSend(v13, "removeObjectForKey:", a2);
    }
  }
}

void SyriacShapingEngine::SetFeatures(SyriacShapingEngine *this, const OTL::GSUB *a2, OTL::GlyphLookups *a3)
{
  uint64_t v3;
  __int128 v4;
  _QWORD *v5;
  TRunGlue *v6;
  uint64_t v7;
  int *v8;
  const char *v9;
  uint64_t i;
  __int128 v11;
  unint64_t v12;
  TRunGlue *v13;
  char **v14;
  char *v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  char *v26;
  int v27;
  int64x2_t v28;
  char *v29;
  uint64_t j;
  uint64_t v31;
  const char *v32;
  unsigned int **v33;
  unsigned int *v34;
  unsigned int *v35;
  unsigned int v36;
  unint64_t v37;
  unint64_t v38;
  char v39;
  int v40;
  UChar32 v41;
  BOOL v42;
  _BOOL8 v43;
  uint64_t v44;
  BOOL IsDeleted;
  TRunGlue *v46;
  _BOOL8 v47;
  UChar32 FullChar;
  int32_t IntPropertyValue;
  unsigned int v50;
  int32_t v51;
  unint64_t v52;
  unsigned int v53;
  unsigned int **v54;
  unsigned int *v55;
  unsigned int *v56;
  unsigned int v57;
  int v58;
  int GlyphID;
  char v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int **v64;
  unsigned int *v65;
  unsigned int *v66;
  unsigned int v67;
  uint64_t k;
  UChar32 c;
  uint64_t v70;
  uint64_t v71;
  TRunGlue *v73;
  UChar32 v74;
  TRunGlue *v75;
  uint64_t v76;
  int v78;
  int v80;
  _OWORD v81[21];
  uint64_t StringIndex;
  TRunGlue **v83;
  int64x2_t v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  TRunGlue *v96;
  TRunGlue *v97;
  uint64_t v98;
  _OWORD v99[7];
  unint64_t v100;
  _OWORD *v101;
  uint64_t v102;

  v3 = 0;
  v102 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v81[19] = v4;
  v81[20] = v4;
  v81[17] = v4;
  v81[18] = v4;
  v81[15] = v4;
  v81[16] = v4;
  v81[13] = v4;
  v81[14] = v4;
  v81[11] = v4;
  v81[12] = v4;
  v81[9] = v4;
  v81[10] = v4;
  v81[8] = v4;
  v81[6] = v4;
  v81[7] = v4;
  v81[4] = v4;
  v81[5] = v4;
  v81[2] = v4;
  v81[3] = v4;
  v81[0] = v4;
  v81[1] = v4;
  do
  {
    v5 = &v81[v3];
    *v5 = 0;
    v5[1] = 0;
    v5[2] = 0;
    v5[5] = (char *)&v81[v3 + 1] + 8;
    v3 += 3;
  }
  while (v3 != 21);
  v6 = (TRunGlue *)*((_QWORD *)this + 2);
  v7 = TRunGlue::length(v6);
  v8 = (int *)*((_QWORD *)this + 2);
  v70 = v8[6];
  if ((int)v70 < 1)
  {
    v73 = v6;
    v75 = (TRunGlue *)(v7 - 1);
    v9 = (const char *)&SyriacShapingEngine::SetFeatures(OTL::GSUB const&,OTL::GlyphLookups &)::rtlTagArray;
    v71 = -1;
  }
  else
  {
    v71 = TRunGlue::length((TRunGlue *)v8);
    v73 = (TRunGlue *)v8;
    v75 = 0;
    v9 = "lositinianifidem2dem2nif3niflosianif2nif3nifidem2demtini";
  }
  for (i = 0; i != 7; ++i)
  {
    v100 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v99[5] = v11;
    v99[6] = v11;
    v99[3] = v11;
    v99[4] = v11;
    v99[1] = v11;
    v99[2] = v11;
    v99[0] = v11;
    v97 = 0;
    v98 = 0;
    v96 = 0;
    v101 = v99;
    v80 = *(_DWORD *)&v9[4 * i];
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v83, &v80, v81);
    OTL::GCommon::GetLookups((uint64_t)a2, (uint64_t)&v83, (uint64_t)&v96, 0);
    StringIndex = (uint64_t)&v83;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&StringIndex);
    v12 = (unint64_t)v96;
    v13 = v97;
    if (v96 != v97)
    {
      v14 = (char **)&v81[3 * i];
      v15 = v14[1];
      do
      {
        v16 = *(_DWORD *)v12;
        v17 = (unint64_t)v14[2];
        if ((unint64_t)v15 >= v17)
        {
          v18 = (v15 - *v14) >> 2;
          if ((unint64_t)(v18 + 1) >> 62)
            abort();
          v19 = v17 - (_QWORD)*v14;
          v20 = v19 >> 1;
          if (v19 >> 1 <= (unint64_t)(v18 + 1))
            v20 = v18 + 1;
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
            v21 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v21 = v20;
          *((_QWORD *)&v85 + 1) = v14 + 3;
          if (v21)
            v22 = (char *)TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul>::allocate((uint64_t)(v14 + 3), v21);
          else
            v22 = 0;
          v23 = &v22[4 * v18];
          v24 = &v22[4 * v21];
          *(_QWORD *)&v85 = v24;
          *(_DWORD *)v23 = v16;
          v15 = v23 + 4;
          v84.i64[1] = (uint64_t)(v23 + 4);
          v26 = *v14;
          v25 = (unint64_t)v14[1];
          if ((char *)v25 == *v14)
          {
            v28 = vdupq_n_s64(v25);
          }
          else
          {
            do
            {
              v27 = *(_DWORD *)(v25 - 4);
              v25 -= 4;
              *((_DWORD *)v23 - 1) = v27;
              v23 -= 4;
            }
            while ((char *)v25 != v26);
            v28 = *(int64x2_t *)v14;
            v15 = (char *)v84.i64[1];
            v24 = (char *)v85;
          }
          *v14 = v23;
          v14[1] = v15;
          v84 = v28;
          v29 = v14[2];
          v14[2] = v24;
          *(_QWORD *)&v85 = v29;
          v83 = (TRunGlue **)v28.i64[0];
          std::__split_buffer<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&v83);
        }
        else
        {
          *(_DWORD *)v15 = v16;
          v15 += 4;
        }
        v14[1] = v15;
        v12 += 4;
      }
      while ((TRunGlue *)v12 != v13);
    }
    v83 = &v96;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v83);
  }
  for (j = 0; j != 7; ++j)
  {
    v31 = 0;
    while (*(_DWORD *)&v9[v31] != *(_DWORD *)&SyriacShapingEngine::SetFeatures(OTL::GSUB const&,OTL::GlyphLookups &)::ltrTagArray[4 * j + 28])
    {
      v31 += 4;
      if (v31 == 28)
      {
        v32 = v9 + 28;
        goto LABEL_33;
      }
    }
    v32 = &v9[v31];
LABEL_33:
    v33 = (unsigned int **)&v81[3 * ((v32 - v9) >> 2)];
    v34 = *v33;
    v35 = v33[1];
    if (*v33 != v35)
    {
      do
      {
        v36 = *v34++;
        v12 = v12 & 0xFFFFFFFF00000000 | v36;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)a3, v12, 0, 0);
      }
      while (v34 != v35);
    }
  }
  v83 = (TRunGlue **)*((_QWORD *)this + 1);
  v84 = 0u;
  v85 = 0u;
  v86 = 0u;
  v87 = 0u;
  v88 = 0u;
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  v92 = 0u;
  v93 = 0u;
  v95 = 0;
  v94 = 0u;
  *(_QWORD *)&v94 = v83[2];
  v96 = v73;
  v97 = v75;
  v37 = v71;
  if (v75 == (TRunGlue *)v71)
    goto LABEL_78;
  v76 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  c = 0;
  v42 = 0;
  v43 = 0;
  v44 = v70;
  do
  {
    IsDeleted = TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v96);
    v46 = v97;
    if (IsDeleted)
      goto LABEL_62;
    v78 = v40;
    v47 = v43;
    StringIndex = TRunGlue::GetStringIndex(v96, (uint64_t)v97);
    FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v83, &StringIndex, 0);
    IntPropertyValue = u_getIntPropertyValue(FullChar, UCHAR_JOINING_TYPE);
    v50 = JoiningScriptShapingEngine::shapeTypes[IntPropertyValue];
    if (v42)
    {
      v51 = IntPropertyValue;
      if (u_getIntPropertyValue(v41, UCHAR_JOINING_GROUP) == 2)
      {
        if (!v51)
        {
          v74 = v41;
          if ((v39 & 1) == 0)
          {
            if (u_getIntPropertyValue(c, UCHAR_JOINING_GROUP) == 7)
              v38 = 6;
            else
              v38 = 5;
          }
          v50 = 8;
          goto LABEL_47;
        }
        if ((v39 & 1) != 0)
          v38 = 4;
        else
          v38 = v38;
      }
    }
    if ((v50 & 4) != 0)
    {
      v46 = v97;
      if (!*((_BYTE *)this + 24))
      {
        GlyphID = TRunGlue::GetGlyphID(v96, (uint64_t)v97);
        v46 = v97;
        if (!GlyphID)
        {
          TRunGlue::Delete(*((_QWORD **)this + 2), (uint64_t)v97, 0);
          v46 = v97;
        }
      }
      v43 = v47;
      v58 = v78;
      goto LABEL_61;
    }
    v74 = v41;
LABEL_47:
    v43 = (v50 & 8) == 0;
    if ((v78 & v50 & 1) != 0)
      v52 = ((v50 & 8) >> 3) ^ 1u;
    else
      v52 = 0;
    if (v76 >= 1)
    {
      v53 = (v78 & v50) & v47 ? v38 + 2 : v38;
      v54 = (unsigned int **)&v81[3 * v53];
      v55 = *v54;
      v56 = v54[1];
      if (*v54 != v56)
      {
        do
        {
          v57 = *v55++;
          v38 = v38 & 0xFFFFFFFF00000000 | v57;
          OTL::GlyphLookups::SetLookupInRange<true>((uint64_t *)a3, v38, (uint64_t)v75, 1);
        }
        while (v55 != v56);
      }
    }
    v58 = (v50 >> 1) & 1;
    v46 = v97;
    c = v74;
    v41 = FullChar;
    v38 = v52;
    v75 = v97;
    v76 = 1;
    v44 = v70;
    v37 = v71;
    v42 = v47;
    v39 = v78;
LABEL_61:
    v40 = v58;
LABEL_62:
    v97 = (TRunGlue *)((char *)v46 + v44);
  }
  while ((TRunGlue *)((char *)v46 + v44) != (TRunGlue *)v37);
  if (v42)
  {
    v60 = (u_getIntPropertyValue(v41, UCHAR_JOINING_GROUP) != 2) | v39;
    v61 = (uint64_t *)a3;
    v63 = (uint64_t)v75;
    v62 = v76;
    if ((v60 & 1) == 0)
    {
      if (u_getIntPropertyValue(c, UCHAR_JOINING_GROUP) == 7)
        LODWORD(v38) = 6;
      else
        LODWORD(v38) = 5;
    }
  }
  else
  {
    v61 = (uint64_t *)a3;
    v63 = (uint64_t)v75;
    v62 = v76;
  }
  if (v62 >= 1)
  {
    v64 = (unsigned int **)&v81[3 * v38];
    v65 = *v64;
    v66 = v64[1];
    if (*v64 != v66)
    {
      do
      {
        v67 = *v65++;
        v37 = v37 & 0xFFFFFFFF00000000 | v67;
        OTL::GlyphLookups::SetLookupInRange<true>(v61, v37, v63, 1);
      }
      while (v65 != v66);
    }
  }
LABEL_78:
  for (k = 18; k != -3; k -= 3)
  {
    v83 = (TRunGlue **)&v81[k];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v83);
  }
}

void SyriacShapingEngine::~SyriacShapingEngine(SyriacShapingEngine *this)
{
  JUMPOUT(0x186DC03ACLL);
}

void **TCompactArray<unsigned short,8ul,3ul,30ul>::assign<unsigned int *>(uint64_t a1, int *a2, int *a3)
{
  int *v6;
  char **v7;
  void **result;
  int *v9;
  unsigned int v10;
  int *v11;
  char *v12;
  uint64_t v13;
  unsigned int v14;
  char *v15;
  unsigned __int16 *v16;
  uint64_t v17;
  unsigned __int16 *v18;
  uint64_t v19;
  int v20;
  int v21;
  int *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;

  *(_BYTE *)a1 = 0;
  v6 = a2 + 8;
  v7 = (char **)(a1 + 32);
  result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<unsigned int *,unsigned int *>((void **)(a1 + 32), *(char **)(a1 + 40), a2, a2 + 8, 8);
  if (v6 != a3)
  {
    v9 = a2 + 9;
    v10 = 1;
    do
    {
      v11 = v6;
      v6 += 8;
      v13 = *(_QWORD *)(a1 + 32);
      v12 = *(char **)(a1 + 40);
      v14 = (_DWORD)v12 - v13;
      if ((uint64_t)&v12[-v13] < 15)
      {
        v16 = *(unsigned __int16 **)(a1 + 32);
LABEL_17:
        v22 = v11 + 7;
        if (v16 != (unsigned __int16 *)v12)
        {
          v23 = 24;
          do
          {
            v24 = v16;
            if (v22 != v11)
            {
              v25 = v22 - v11;
              v26 = (v12 - (char *)v16) >> 1;
              v24 = *(unsigned __int16 **)(a1 + 40);
              if (v26 >= v25)
              {
                v27 = (uint64_t)&v16[v26 + 1 - v25];
                v24 = *(unsigned __int16 **)(a1 + 40);
                if ((unsigned __int16 *)v27 != v16)
                {
                  v24 = v16;
                  while (*v11 != *v24)
                  {
LABEL_27:
                    if (++v24 == (unsigned __int16 *)v27)
                    {
                      v24 = *(unsigned __int16 **)(a1 + 40);
                      goto LABEL_29;
                    }
                  }
                  v28 = 0;
                  v29 = 1;
                  while (v23 != v28)
                  {
                    v30 = v24[v29];
                    v31 = v9[v28 / 4];
                    ++v29;
                    v28 += 4;
                    if (v31 != v30)
                      goto LABEL_27;
                  }
                }
              }
            }
LABEL_29:
            if (v16 == v24)
              break;
            --v22;
            ++v16;
            v23 -= 4;
          }
          while (v16 != (unsigned __int16 *)v12);
        }
        v32 = (unint64_t)((char *)v6 - (char *)v22) >> 2;
        *(_BYTE *)(a1 + v10) = v32 + (v14 >> 1) - 8;
        v33 = *(_QWORD *)(a1 + 32);
        v34 = ((*(_QWORD *)(a1 + 40) - v33) >> 1) + v32;
        v35 = (*(_QWORD *)(a1 + 48) - v33) >> 1;
        if (v35 <= 0x1E)
          v35 = 30;
        if (v34 > v35)
        {
          v36 = 0;
          while (1)
          {
            v37 = TCompactArray<unsigned short,8ul,3ul,30ul>::assign<unsigned int *>(unsigned int *,unsigned int *)::kBuckets[v36];
            if (v34 <= v37)
              break;
            if (++v36 == 3)
            {
              v37 = 256;
              break;
            }
          }
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(v7, v37);
          v12 = *(char **)(a1 + 40);
        }
        result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<unsigned int *,unsigned int *>((void **)v7, v12, v22, v6, v6 - v22);
      }
      else
      {
        v15 = &v12[-v13];
        v16 = *(unsigned __int16 **)(a1 + 32);
        while (1)
        {
          v17 = (uint64_t)&v15[(_QWORD)v16 - 14];
          v18 = *(unsigned __int16 **)(a1 + 40);
          if ((unsigned __int16 *)v17 != v16)
          {
            v18 = v16;
            while (*v11 != *v18)
            {
LABEL_11:
              if (++v18 == (unsigned __int16 *)v17)
              {
                v18 = *(unsigned __int16 **)(a1 + 40);
                goto LABEL_13;
              }
            }
            v19 = 0;
            while (v19 != 7)
            {
              v20 = v18[v19 + 1];
              v21 = v9[v19++];
              if (v21 != v20)
                goto LABEL_11;
            }
          }
LABEL_13:
          if (v18 == v16)
            break;
          v15 = (char *)(v12 - (char *)++v16);
          if (v12 - (char *)v16 <= 14)
            goto LABEL_17;
        }
        *(_BYTE *)(a1 + v10) = ((_DWORD)v16 - v13) >> 1;
      }
      ++v10;
      v9 += 8;
    }
    while (v6 != a3);
  }
  return result;
}

void **std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<unsigned int *,unsigned int *>(void **result, char *__src, int *a3, int *a4, uint64_t a5)
{
  int *v6;
  char *v7;
  void **v8;
  unint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  int *v19;
  char *v20;
  int *v21;
  _WORD *v22;
  int v23;
  char *v24;
  char *v25;
  char *v26;
  __int16 v27;
  int v28;
  char *v29;
  uint64_t v30;
  char *v31;
  int v32;
  _QWORD v33[5];

  if (a5 < 1)
    return result;
  v6 = a3;
  v7 = __src;
  v8 = result;
  v9 = (unint64_t)result[1];
  v10 = result[2];
  if (a5 > (uint64_t)&v10[-v9] >> 1)
  {
    v11 = *result;
    v12 = a5 + ((uint64_t)(v9 - (_QWORD)*result) >> 1);
    if (v12 < 0)
      abort();
    v13 = (__src - v11) >> 1;
    v14 = (uint64_t)(result + 3);
    v15 = v10 - v11;
    if (v15 > v12)
      v12 = v15;
    if (v15 >= 0x7FFFFFFFFFFFFFFELL)
      v16 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v16 = v12;
    v33[4] = v8 + 3;
    if (v16)
      v17 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v14, v16);
    else
      v17 = 0;
    v29 = &v17[2 * v13];
    v33[0] = v17;
    v33[1] = v29;
    v33[3] = &v17[2 * v16];
    v30 = 2 * a5;
    v31 = &v29[2 * a5];
    do
    {
      v32 = *v6++;
      *(_WORD *)v29 = v32;
      v29 += 2;
      v30 -= 2;
    }
    while (v30);
    v33[2] = v31;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__swap_out_circular_buffer(v8, (uint64_t)v33, v7);
    return (void **)std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v33);
  }
  v18 = (uint64_t)(v9 - (_QWORD)__src) >> 1;
  if (v18 >= a5)
  {
    v19 = &a3[a5];
    v20 = (char *)result[1];
LABEL_18:
    v24 = &__src[2 * a5];
    v25 = &v20[-2 * a5];
    v26 = v20;
    if ((unint64_t)v25 < v9)
    {
      v26 = v20;
      do
      {
        v27 = *(_WORD *)v25;
        v25 += 2;
        *(_WORD *)v26 = v27;
        v26 += 2;
      }
      while ((unint64_t)v25 < v9);
    }
    result[1] = v26;
    if (v20 != v24)
      result = (void **)memmove(&v20[-2 * ((v20 - v24) >> 1)], __src, v20 - v24);
    for (; v6 != v19; v7 += 2)
    {
      v28 = *v6++;
      *(_WORD *)v7 = v28;
    }
    return result;
  }
  v19 = &a3[v18];
  v20 = (char *)result[1];
  if (v19 != a4)
  {
    v21 = v19;
    v22 = result[1];
    do
    {
      v23 = *v21++;
      *v22++ = v23;
      v20 += 2;
    }
    while (v21 != a4);
  }
  result[1] = v20;
  if ((uint64_t)(v9 - (_QWORD)__src) >= 1)
    goto LABEL_18;
  return result;
}

void JoiningScriptShapingEngine::~JoiningScriptShapingEngine(JoiningScriptShapingEngine *this)
{
  JUMPOUT(0x186DC03ACLL);
}

uint64_t JoiningScriptShapingEngine::ApplyScriptShaping(JoiningScriptShapingEngine *this, const OTL::GSUB *a2, OTL::GlyphLookups *a3, BOOL *a4)
{
  if (!*((_QWORD *)this + 1))
    return 0;
  *(_WORD *)(*((_QWORD *)this + 2) + 632) = 257;
  if (a4)
    *a4 = JoiningScriptShapingEngine::ApplyStretching((TRunGlue **)this, a2);
  (*(void (**)(JoiningScriptShapingEngine *, const OTL::GSUB *, OTL::GlyphLookups *))(*(_QWORD *)this + 24))(this, a2, a3);
  return 1;
}

uint64_t JoiningScriptShapingEngine::ApplyStretching(TRunGlue **this, const OTL::GSUB *a2)
{
  unint64_t v2;
  __int128 v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  TRunGlue *v11;
  void **v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void **v17[2];
  int v18;
  void **v19[3];
  _BYTE v20[3120];
  _BYTE *v21;
  _OWORD v22[9];
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v22[8] = v5;
  v23 = v5;
  v22[6] = v5;
  v22[7] = v5;
  v22[4] = v5;
  v22[5] = v5;
  v22[2] = v5;
  v22[3] = v5;
  v22[0] = v5;
  v22[1] = v5;
  v18 = 1937007464;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)v19, &v18, v19);
  OTL::GCommon::GetLookups((uint64_t)a2, (uint64_t)v19, (uint64_t)v22);
  v17[0] = (void **)v19;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](v17);
  if (!BYTE8(v23))
    return 0;
  memset(v20, 170, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  v21 = v20;
  v6 = TRunGlue::length(this[2]);
  v8 = (unsigned int *)*((_QWORD *)&v22[0] + 1);
  v7 = *(unsigned int **)&v22[0];
  if (*(_QWORD *)&v22[0] != *((_QWORD *)&v22[0] + 1))
  {
    v9 = v6;
    do
    {
      v10 = *v7++;
      v2 = v2 & 0xFFFFFFFF00000000 | v10;
      OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v19, v2, 0, v9);
    }
    while (v7 != v8);
  }
  v11 = this[2];
  v12 = (void **)*((_QWORD *)v11 + 13);
  v13 = TRunGlue::length(v11);
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::resize((uint64_t)v12, v13);
  v17[0] = v12;
  v17[1] = (void **)0xAAAAAAAA00000001;
  LOBYTE(v18) = 0;
  v14 = OTL::GSUB::ApplyLookups(a2, this[2], *((_DWORD *)this[2] + 6), (unsigned __int16 **)v19, &v18, (uint64_t)JoiningScriptShapingEngine::ApplyStretching(OTL::GSUB const&)::$_0::__invoke, (uint64_t)v17);
  if ((_BYTE)v18)
    v15 = v14;
  else
    v15 = 0;
  v17[0] = (void **)v19;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100](v17);
  if (BYTE8(v23))
  {
    v19[0] = (void **)v22;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](v19);
  }
  return v15;
}

uint64_t JoiningScriptShapingEngine::MakePositioningAdjustments(JoiningScriptShapingEngine *this)
{
  TRunGlue *v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  CGSize *v5;
  UChar32 FullChar;
  uint64_t StringIndex;
  TRunGlue *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v1 = (TRunGlue *)*((_QWORD *)this + 2);
  v10 = *((_QWORD *)this + 1);
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v22 = 0;
  v21 = 0u;
  *(_QWORD *)&v21 = *(_QWORD *)(v10 + 16);
  result = TRunGlue::length(v1);
  if (result)
  {
    v3 = result;
    v4 = 0;
    v5 = (CGSize *)MEMORY[0x1E0C9D820];
    do
    {
      v8 = v1;
      v9 = v4;
      result = TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v8);
      if ((result & 1) == 0)
      {
        StringIndex = TRunGlue::GetStringIndex(v8, v9);
        FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v10, &StringIndex, 0);
        result = u_getCombiningClass(FullChar);
        if ((_DWORD)result)
          result = (uint64_t)TRunGlue::SetAdvance(v8, v9, *v5);
      }
      ++v4;
    }
    while (v3 != v4);
  }
  return result;
}

void JoiningScriptShapingEngine::FinishStretching(JoiningScriptShapingEngine *this, const TCharStream *a2, TRunGlue *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  CGSize *v14;
  uint64_t v15;
  _DWORD *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  CFIndex v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  UChar32 FullChar;
  CFIndex v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  double v34;
  double v35;
  uint64_t v36;
  double v37;
  double v38;
  double v39;
  uint64_t v40;
  double v41;
  uint64_t v42;
  double Advance;
  double v44;
  uint64_t v45;
  __int128 v46;
  __int16 GlyphID;
  _WORD *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  double v53;
  unint64_t v54;
  CFRange v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  JoiningScriptShapingEngine *v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  void **v76;
  __int128 v77;
  _OWORD v78[4];
  __int128 v79;
  uint64_t v80;
  CGPoint v81;
  CGPoint v82;
  CGPoint v83;

  v80 = *MEMORY[0x1E0C80C00];
  TRunGlue::UpdateAdvancesIfNeeded(a2);
  v5 = (_QWORD *)*((_QWORD *)a2 + 13);
  v6 = v5[1] - *v5;
  if (TRunGlue::length(a2) != v6 >> 4)
    return;
  v7 = *((int *)a2 + 6);
  v63 = this;
  v74 = 0u;
  v64 = 0u;
  v65 = 0u;
  v66 = 0u;
  v67 = 0u;
  v68 = 0u;
  v69 = 0u;
  v70 = 0u;
  v71 = 0u;
  v72 = 0u;
  v73 = 0u;
  v8 = *((_QWORD *)this + 2);
  v75 = 0;
  *(_QWORD *)&v74 = v8;
  v9 = TRunGlue::length(a2);
  v10 = 0;
  if ((int)v7 <= 0)
    v10 = TRunGlue::length(a2) - 1;
  if (v10 < 0 || v9 <= v10)
    return;
  v11 = (double)(int)v7;
  if ((int)v7 >= 1)
    v12 = 0;
  else
    v12 = -1;
  v60 = v12 - v7;
  v13 = 16 * v7;
  v14 = (CGSize *)MEMORY[0x1E0C9D820];
  v61 = v7;
  v58 = v5;
  v59 = 16 * v7;
  do
  {
    v15 = *v5 + 16 * v10;
    v18 = *(_DWORD *)(v15 + 8);
    v16 = (_DWORD *)(v15 + 8);
    v17 = v18;
    if (!v18)
      goto LABEL_98;
    v19 = 1;
    if (v9 > v10)
    {
      v20 = v10;
      while (*v16 == v17)
      {
        if (v20 >= v10)
          v21 = v10;
        else
          v21 = v20;
        v22 = v10 + v19;
        if (v10 + v19 <= v20 + 1)
          v22 = v20 + 1;
        v19 = v22 - v21;
        v20 += v7;
        if (v20 >= 0)
        {
          v16 = (_DWORD *)((char *)v16 + v13);
          v10 = v21;
          if (v9 > v20)
            continue;
        }
        goto LABEL_23;
      }
      v21 = v10;
      if (*v16)
      {
LABEL_23:
        if ((int)v7 < 1)
          v23 = -1;
        else
          v23 = v19;
        v10 = v21 - v7 + v23;
        goto LABEL_98;
      }
    }
    if ((int)v7 < 1)
      v24 = -1;
    else
      v24 = v19;
    v25 = v24 + v10;
    if (v24 + v10 < 0 || v9 <= v25)
      goto LABEL_48;
    v62 = v9;
    v26 = 0;
    v27 = 0.0;
    v28 = v24 + v10;
    do
    {
      *(_QWORD *)&v77 = TRunGlue::GetStringIndex(a2, v28);
      FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v63, (uint64_t *)&v77, 0);
      if (((1 << u_charType(FullChar)) & 0xE3E) == 0)
      {
        v30 = v25;
        if (!v26)
          goto LABEL_47;
LABEL_42:
        if (v19 < 1)
        {
          v33 = 0.0;
        }
        else
        {
          v32 = 0;
          v33 = 0.0;
          do
          {
            v33 = v33 + TRunGlue::GetAdvance(a2, v10 + v32);
            v32 += 2;
          }
          while (v32 < v19);
        }
        if (v27 >= v33)
          v34 = v27;
        else
          v34 = v33;
        if ((int)v7 < 1)
          v34 = 0.0;
        v35 = v27 - v33;
        if (v19 >= 0)
          v36 = v19;
        else
          v36 = v19 + 1;
        v37 = v35 / (double)(v36 >> 1);
        if ((unint64_t)(v19 + 1) < 3)
          v37 = v27 - v33;
        if (v35 <= 0.0)
          v38 = v34 + v35 * v11 * 0.5;
        else
          v38 = v34;
        if (v35 <= 0.0)
          v39 = 0.0;
        else
          v39 = v37;
        v40 = v10 + v19 - 1;
        v41 = v38 - TRunGlue::GetAdvance(a2, v40);
        v81.y = 0.0;
        v81.x = v41;
        TRunGlue::SetOrigin(a2, v40, v81);
        TRunGlue::SetAdvance(a2, v40, *v14);
        if (v40 <= v10)
        {
LABEL_87:
          if (*((_QWORD *)a2 + 19))
          {
            if (v10 >= v30)
              v55.location = v30;
            else
              v55.location = v10;
            v56 = v30 + v26;
            if (v30 + v26 <= v19 + v10)
              v56 = v19 + v10;
            v55.length = v56 - v55.location;
            TRunGlue::ClearSafeToBreakAfter((uint64_t)a2, v55);
          }
          if ((int)v7 < 1)
            v57 = -1;
          else
            v57 = v26;
          v10 = v57 - v7 + v30;
          v5 = v58;
          v13 = v59;
          v9 = v62;
          goto LABEL_98;
        }
        v42 = v10 + v19 - 2;
        while (1)
        {
          Advance = TRunGlue::GetAdvance(a2, v42);
          v44 = Advance == 0.0 ? 0.0 : v39 / Advance;
          v45 = vcvtmd_s64_f64(v44);
          if (!v45)
            break;
          *(_QWORD *)&v46 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v46 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v78[3] = v46;
          v79 = v46;
          v78[1] = v46;
          v78[2] = v46;
          v77 = v46;
          v78[0] = v46;
          GlyphID = TRunGlue::GetGlyphID(a2, v42);
          v77 = 0uLL;
          *(_QWORD *)&v78[0] = 0;
          *((_QWORD *)&v79 + 1) = (char *)v78 + 8;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v77, v45);
          v48 = (_WORD *)*((_QWORD *)&v77 + 1);
          v49 = *((_QWORD *)&v77 + 1) + 2 * v45;
          v50 = 2 * v45;
          do
          {
            *v48++ = GlyphID;
            v50 -= 2;
          }
          while (v50);
          *((_QWORD *)&v77 + 1) = v49;
          v7 = v61;
          if ((TRunGlue::DoGlyphInsertion(a2, (const unsigned __int16 *)v77, (unsigned __int16)v45, 0, 1, v42, v42, 0, 0) & 1) == 0)
          {
            v76 = (void **)&v77;
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v76);
            goto LABEL_87;
          }
          if (v30 <= v10)
            v51 = 0;
          else
            v51 = v45;
          v30 += v51;
          v19 += v45;
          v62 += v45;
          v76 = (void **)&v77;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v76);
          if ((v45 & 0x8000000000000000) == 0)
          {
            v52 = v45 + 1;
            goto LABEL_81;
          }
LABEL_84:
          v40 -= 2;
          v41 = v41 - TRunGlue::GetAdvance(a2, v40);
          v83.y = 0.0;
          v83.x = v41;
          TRunGlue::SetOrigin(a2, v40, v83);
          TRunGlue::SetAdvance(a2, v40, *v14);
          v42 -= 2;
          if (v40 <= v10)
            goto LABEL_87;
        }
        v52 = 1;
LABEL_81:
        v53 = v39 / (double)v52;
        do
        {
          v41 = v41 - v53;
          v82.y = 0.0;
          v82.x = v41;
          TRunGlue::SetOrigin(a2, v42 + v45, v82);
          TRunGlue::SetAdvance(a2, v42 + v45, *v14);
          v54 = v45-- + 1;
        }
        while (v54 > 1);
        v7 = v61;
        goto LABEL_84;
      }
      if (v28 >= v25)
        v30 = v25;
      else
        v30 = v28;
      v31 = v25 + v26;
      if (v25 + v26 <= v28 + 1)
        v31 = v28 + 1;
      v26 = v31 - v30;
      v27 = v27 + TRunGlue::GetAdvance(a2, v28);
      v28 += v7;
      if (v28 < 0)
        break;
      v25 = v30;
    }
    while (v62 > v28);
    if (v26)
      goto LABEL_42;
LABEL_47:
    v25 = v30;
    v9 = v62;
    v13 = v59;
LABEL_48:
    v10 = v60 + v25;
LABEL_98:
    v10 += v7;
  }
  while (v10 >= 0 && v9 > v10);
}

uint64_t JoiningScriptShapingEngine::ApplyStretching(OTL::GSUB const&)::$_0::__invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  _DWORD *v5;

  if ((a4 & 1) != 0)
  {
    if (a4 <= 0)
    {
      v4 = *(_DWORD *)(result + 8);
    }
    else
    {
      v4 = *(_DWORD *)(result + 8);
      v5 = (_DWORD *)(**(_QWORD **)result + 16 * a2 + 8);
      do
      {
        *v5 = v4;
        v5 += 4;
        --a4;
      }
      while (a4);
    }
    *(_DWORD *)(result + 8) = v4 + 1;
  }
  return result;
}

uint64_t IndicShapingEngine::FindSyllableEnd(TRunGlue **this, uint64_t a2, int a3)
{
  uint64_t v6;
  char v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  char v21;
  TRunGlue *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t StringIndex;
  uint64_t v30;
  int *v31;
  int v32;
  _DWORD *v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;

  v6 = TRunGlue::length(this[1]);
  v7 = 0;
  v8 = 0;
  v9 = a2 + 31;
  if (a2 + 31 >= v6)
    v9 = v6;
  v40 = v9;
  if (a2 <= v9)
    v10 = v9;
  else
    v10 = a2;
  v38 = a3;
  v39 = a2 + 1;
  v41 = 16 * a2;
  v35 = 4 * a2;
  v36 = v10;
  v37 = a2;
  do
  {
    v11 = 0;
    v12 = 0;
    v13 = v41;
    v14 = a2;
    while (v10 != v14)
    {
      v15 = v14;
      v16 = *(_QWORD *)this[3] + v13;
      *(_DWORD *)(v16 + 12) = a3;
      v17 = *(_DWORD *)(v16 + 8);
      v18 = v17;
      if (v17 == 6)
      {
        v12 = 1;
      }
      else if (v17 == 5)
      {
        v8 = 1;
      }
      else if ((v12 & ((v17 & 0xFFFE) == 8)) != 0)
      {
        goto LABEL_17;
      }
      v19 = stateTable[16 * v11 + v17];
      v11 = stateTable[16 * v11 + v18];
      v14 = v15 + 1;
      v13 += 16;
      if (v19 < 0)
        goto LABEL_17;
    }
    v15 = v10;
LABEL_17:
    if (v7 & 1 | ((v8 & 1) == 0))
      break;
    v20 = v40 >= v15 + 1 ? v15 + 1 : v40;
    if (v39 == v20)
      break;
    v42 = v8;
    v21 = 0;
    v22 = this[1];
    v23 = **((_QWORD **)v22 + 13);
    v24 = *(_DWORD *)(v23 + 16 * a2 + 8);
    v25 = v20 - 1;
    v26 = v35;
    do
    {
      v27 = v24;
      v28 = a2 + 1;
      v24 = *(_DWORD *)(v23 + 4 * v26 + 24);
      if ((unsigned __int16)v27 == 7 && (unsigned __int16)*(_DWORD *)(v23 + 4 * v26 + 24) == 5)
      {
        StringIndex = TRunGlue::GetStringIndex(v22, a2);
        v30 = TRunGlue::GetStringIndex(v22, a2 + 1);
        TRunGlue::SetStringIndex(v22, a2, v30);
        TRunGlue::SetStringIndex(v22, a2 + 1, StringIndex);
        TRunGlue::Rotate(this[1], a2, a2 + 1, a2 + 2, 0);
        v31 = (int *)((char *)this[4] + v26);
        v32 = *v31;
        *v31 = v31[1];
        v31[1] = v32;
        v23 = **((_QWORD **)v22 + 13);
        v33 = (_DWORD *)(v23 + 4 * v26);
        v33[2] = v24;
        v33[3] = 0;
        v33[6] = v27;
        v33[7] = 0;
        v21 = 1;
      }
      v26 += 4;
      ++a2;
    }
    while (v25 != v28);
    v7 = 1;
    a2 = v37;
    a3 = v38;
    v8 = v42;
    v10 = v36;
  }
  while ((v21 & 1) != 0);
  return v15;
}

void IndicShapingEngine::SetFeatures(IndicShapingEngine *this@<X0>, char *a2@<X1>, OpenTypeReorderingOutput **a3@<X8>)
{
  IndicClassTable *v4;
  TRunGlue *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  int FullChar;
  int CharClass;
  uint64_t v12;
  IndicShapingEngine *v13;
  TRunGlue *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t StringIndex;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  OpenTypeReorderingOutput *v27;
  uint64_t v28;
  __int128 v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int *v33;
  void **v34;
  unint64_t v35;
  char *v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  int v41;
  char *v42;
  os_unfair_lock_t v43;
  OpenTypeReorderingOutput *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t SyllableEnd;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *v56;
  int v57;
  int v58;
  uint64_t v59;
  BOOL v60;
  int *v61;
  int v62;
  uint64_t v63;
  int *v64;
  int v65;
  int v66;
  int v67;
  BOOL v68;
  int v70;
  uint64_t v71;
  __int16 v72;
  int v73;
  unsigned __int8 **v74;
  uint64_t v75;
  uint32_t os_unfair_lock_opaque;
  OpenTypeReorderingOutput *v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  _DWORD *v84;
  unsigned int v85;
  BOOL v87;
  uint64_t j;
  _DWORD *v89;
  int v90;
  const char *v91;
  int v92;
  const char *v93;
  uint64_t v95;
  int v96;
  BOOL v98;
  uint64_t v99;
  uint64_t v100;
  char v101;
  uint64_t v102;
  uint64_t v103;
  _DWORD *v104;
  int v105;
  _BOOL4 v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  char v110;
  int v111;
  uint32_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  char **v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  int *v122;
  int v123;
  char *v124;
  char *v125;
  int v126;
  uint64_t v127;
  _DWORD *v128;
  int v129;
  const char *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t *v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  int v146;
  BOOL v147;
  BOOL v148;
  BOOL v149;
  uint64_t v150;
  unsigned __int16 *v151;
  unsigned __int16 *v152;
  uint64_t *v153;
  uint64_t *v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t (**v160)(_QWORD *, _QWORD);
  uint64_t *v161;
  unsigned __int16 *v162;
  uint64_t v163;
  uint64_t (*v164)(_QWORD *, _QWORD);
  _QWORD *v165;
  unsigned int v166;
  uint64_t v167;
  ChainContextSubstFormat1 *v168;
  int v169;
  IndicReorderingOutput *v170;
  uint64_t v171;
  IndicReorderingOutput *v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;
  char v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  IndicReorderingOutput *v180;
  uint64_t v181;
  int v182;
  uint64_t v183;
  __int16 v184;
  int v185;
  IndicReorderingOutput *v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int *v190;
  uint64_t v191;
  int v192;
  uint64_t v193;
  os_unfair_lock_s *v194;
  unsigned __int16 *v195;
  int v196;
  int v197;
  IndicReorderingOutput *v199;
  char v200;
  int v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  int v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  uint64_t v210;
  _BOOL8 v211;
  int v212;
  uint64_t v213;
  uint64_t v214;
  int *v215;
  int v216;
  _BYTE *v217;
  _BYTE *v218;
  uint64_t v219;
  uint64_t v220;
  int v221;
  const unsigned int *v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  IndicReorderingOutput *v226;
  char *v227;
  uint64_t v228;
  char *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  IndicReorderingOutput *v234;
  IndicReorderingOutput *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  int v239;
  BOOL v241;
  char **v242;
  IndicReorderingOutput *v243;
  _QWORD *v244;
  char **v245;
  uint64_t v246;
  uint64_t v247;
  unsigned __int16 *v248;
  int v249;
  int v250;
  uint64_t v252;
  const char *v253;
  int v254;
  unsigned int v255[2];
  uint64_t v256;
  int v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  os_unfair_lock_t lock;
  os_unfair_lock_s *locka;
  os_unfair_lock_t lockb;
  int v267[2];
  _QWORD *v268;
  int v269[2];
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  BOOL v274;
  char v275;
  uint64_t v276;
  int v278;
  uint64_t *v279;
  IndicReorderingOutput *v280;
  char **v281;
  char *v282;
  __int128 v283;
  __int128 v284;
  __int128 v285;
  __int128 v286;
  __int128 v287;
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  __int128 v293;
  uint64_t v294;
  void **v295;
  int *v296;
  unsigned __int8 v297;
  __int128 v298;
  _OWORD v299[8];
  __int128 v300;
  uint64_t v301;

  v301 = *MEMORY[0x1E0C80C00];
  v4 = (IndicClassTable *)*((_QWORD *)this + 63);
  if (!v4)
    v4 = (IndicClassTable *)*((_QWORD *)this + 62);
  v5 = (TRunGlue *)*((_QWORD *)this + 1);
  v282 = (char *)*((_QWORD *)this + 2);
  v283 = 0u;
  v284 = 0u;
  v285 = 0u;
  v286 = 0u;
  v287 = 0u;
  v288 = 0u;
  v289 = 0u;
  v290 = 0u;
  v291 = 0u;
  v292 = 0u;
  v294 = 0;
  v293 = 0u;
  *(_QWORD *)&v293 = *((_QWORD *)v282 + 2);
  v6 = TRunGlue::length(v5);
  if (v6)
  {
    v7 = v6;
    v8 = 0;
    for (i = 0; i != v7; ++i)
    {
      *(_QWORD *)&v298 = TRunGlue::GetStringIndex(v5, i);
      FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v282, (uint64_t *)&v298, 0);
      CharClass = IndicClassTable::getCharClass(v4, FullChar);
      v12 = **((_QWORD **)v5 + 13) + v8;
      *(_DWORD *)(v12 + 8) = CharClass;
      *(_DWORD *)(v12 + 12) = 0;
      v8 += 16;
    }
  }
  v13 = this;
  if (*(_DWORD *)(*((_QWORD *)this + 64) + 72) == 1802396769)
  {
    v14 = (TRunGlue *)*((_QWORD *)this + 1);
    v15 = TRunGlue::length(v14);
    if (v15 >= 3)
    {
      v16 = v15;
      v17 = 0;
      v18 = **((_QWORD **)v14 + 13);
      do
      {
        if ((*(_BYTE *)(v18 + 16 * v17 + 11) & 0x40) != 0)
        {
          v19 = v17 + 1;
          v20 = *(_DWORD *)(v18 + 16 * (v17 + 1) + 8);
          if ((unsigned __int16)v20 == 7 && (v21 = *(_DWORD *)(v18 + 16 * (v17 + 2) + 8), (unsigned __int16)v21 == 8))
          {
            StringIndex = TRunGlue::GetStringIndex(v14, v17 + 1);
            v23 = TRunGlue::GetStringIndex(v14, v17 + 2);
            TRunGlue::SetStringIndex(v14, v17 + 1, v23);
            TRunGlue::SetStringIndex(v14, v17 + 2, StringIndex);
            TRunGlue::Rotate(*((TRunGlue **)this + 1), v17 + 1, v17 + 2, v17 + 3, 0);
            *(int32x2_t *)(*((_QWORD *)this + 4) + 4 * v19) = vrev64_s32(*(int32x2_t *)(*((_QWORD *)this + 4) + 4 * v19));
            v18 = **((_QWORD **)v14 + 13);
            v24 = v18 + 16 * v19;
            v13 = this;
            *(_DWORD *)(v24 + 8) = v21;
            *(_DWORD *)(v24 + 12) = 0;
            v25 = v18 + 16 * (v17 + 2);
            *(_DWORD *)(v25 + 8) = v20;
            *(_DWORD *)(v25 + 12) = 0;
            v17 += 2;
          }
          else
          {
            v13 = this;
          }
        }
        ++v17;
      }
      while (v16 - v17 >= 3);
    }
  }
  if (!*((_BYTE *)v13 + 888))
  {
    v43 = (os_unfair_lock_t)*((_QWORD *)v13 + 63);
    if (!v43)
      v43 = (os_unfair_lock_t)*((_QWORD *)v13 + 62);
    strcpy(a2, "tkunnhkafhprfwlbflahftsputavtiniserpsvbaswlbstspnlah");
    a2[53] = 0;
    *((_WORD *)a2 + 27) = 0;
    v44 = (OpenTypeReorderingOutput *)operator new();
    OpenTypeReorderingOutput::OpenTypeReorderingOutput(v44, *((TRunGlue **)v13 + 1));
    *(_QWORD *)v45 = &off_1E15DDE80;
    *(_QWORD *)(v45 + 440) = 0;
    *(_QWORD *)(v45 + 448) = 0;
    *(_QWORD *)(v45 + 432) = 0;
    *(_QWORD *)(v45 + 968) = v45 + 456;
    *(_QWORD *)(v45 + 992) = (char *)v13 + 520;
    *(_DWORD *)(v45 + 1004) = 0;
    *(_DWORD *)(v45 + 1052) = 0;
    *(_DWORD *)(v45 + 1060) = 0;
    IndicReorderingOutput::reset((IndicReorderingOutput *)v45, -1);
    *(_QWORD *)&v298 = v44;
    v295 = (void **)*((_QWORD *)v13 + 3);
    v249 = *(_DWORD *)(*((_QWORD *)v13 + 64) + 72);
    v46 = TRunGlue::length(*((TRunGlue **)v13 + 1));
    if (v46 < 1)
      goto LABEL_245;
    v47 = v46;
    v48 = 0;
    v49 = 0;
    v252 = v46;
    lock = v43;
    while (1)
    {
      v50 = v48;
      *(_QWORD *)v267 = v49 + 1;
      SyllableEnd = IndicShapingEngine::FindSyllableEnd((TRunGlue **)v13, v48, (int)v49 + 1);
      if (SyllableEnd - v48 >= 2
        && IsProhibitedSequence(*(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v48), *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * (v48 + 1)), 0))
      {
        SyllableEnd = v48 + 1;
      }
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)v298 + 16))(v298, v48);
      v271 = SyllableEnd;
      if (SyllableEnd == v48)
      {
LABEL_46:
        v54 = v50 - 1;
        v52 = v50;
      }
      else
      {
        v52 = SyllableEnd;
        v53 = 16 * SyllableEnd - 8;
        while ((*(_DWORD *)((_BYTE *)*v295 + v53) & 0xFFFE) == 0xC)
        {
          IndicReorderingOutput::noteSyllableModifier((int64x2_t *)v298, (const IndicClassTable *)v43, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v52 - 4), v52 - 1, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah");
          v53 -= 16;
          if (v50 == --v52)
            goto LABEL_46;
        }
        while (1)
        {
          v54 = v52 - 1;
          if (*(_WORD *)((char *)*v295 + v53) != 1)
            break;
          IndicReorderingOutput::noteVowelModifier((int64x2_t *)v298, (const IndicClassTable *)v43, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v52 - 4), v52 - 1, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah");
          v53 -= 16;
          --v52;
          if (v50 == v54)
            goto LABEL_46;
        }
        if (v52 > v50)
        {
          v99 = v50 + 1;
          v100 = v52 - 1;
          do
          {
            v101 = IndicReorderingOutput::noteMatra((int64x2_t *)v298, (const IndicClassTable *)v43, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v100), v100, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah");
            --v100;
            if (v52 == v99)
              break;
            ++v99;
          }
          while ((v101 & 1) != 0);
          IndicReorderingOutput::finishMatras((IndicReorderingOutput *)v298, v271, 0);
          v55 = v100 + 1;
          v47 = v252;
          goto LABEL_48;
        }
      }
      v55 = v54;
LABEL_48:
      v56 = *v295;
      v57 = *((_DWORD *)*v295 + 4 * v50 + 2);
      if ((unsigned __int16)v57 > 0xFu)
        goto LABEL_239;
      v58 = 1 << v57;
      if (((1 << v57) & 0x3042) != 0)
      {
        v73 = IndicReorderingOutput::writeMpre((IndicReorderingOutput *)v298);
        v74 = (unsigned __int8 **)v298;
        if (!v50 || *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v50 - 4) != 9676)
        {
          if (v73)
            v75 = 0xA000000000000000;
          else
            v75 = 0x8000000000000000;
          OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, 9676, v50, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", 3, v75);
          v74 = (unsigned __int8 **)v298;
        }
        v48 = v271;
        os_unfair_lock_opaque = v43[3]._os_unfair_lock_opaque;
        if (os_unfair_lock_opaque >> 30 != 1)
        {
          IndicReorderingOutput::writeMabove(v74);
          std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 8, v298);
          os_unfair_lock_opaque = v43[3]._os_unfair_lock_opaque;
          v74 = (unsigned __int8 **)v298;
        }
        if ((os_unfair_lock_opaque & 0x20000000) != 0)
        {
          std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(v74[54], v74[55], 2863311362, (uint64_t)v74);
          std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 2863311363, v298);
          os_unfair_lock_opaque = v43[3]._os_unfair_lock_opaque;
          v74 = (unsigned __int8 **)v298;
        }
        if (os_unfair_lock_opaque >> 30 == 1)
        {
          IndicReorderingOutput::writeMabove(v74);
          std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 8, v298);
          v74 = (unsigned __int8 **)v298;
        }
        IndicReorderingOutput::writeMpost(v74);
        if ((v43[3]._os_unfair_lock_opaque & 0x20000000) == 0)
        {
LABEL_229:
          std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 2863311362, v298);
          std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 2863311363, v298);
        }
LABEL_230:
        IndicReorderingOutput::writeVMpost((unsigned __int8 **)v298);
        goto LABEL_231;
      }
      if ((v58 & 0x801C) != 0)
      {
        v59 = v50;
        if (v52 - v50 >= 3)
        {
          v59 = v50;
          if ((v57 & 0x40000000) != 0)
          {
            v59 = v50;
            if (LOWORD(v56[4 * v50 + 6]) == 7)
            {
              v59 = v50;
              if (v56[4 * v50 + 10] != 9)
              {
                v60 = (unsigned __int16)v56[4 * v50 + 10] != 8 || (v43[3]._os_unfair_lock_opaque & 0x10000000) == 0;
                v59 = v50 + 2;
                if (!v60)
                {
                  if ((unint64_t)(v52 - v50) <= 3)
                    v59 = v50;
                  else
                    v59 = v50 + 3;
                }
              }
            }
          }
        }
        if (v54 > v59)
        {
          v61 = &v56[4 * v54 + 2];
          while (1)
          {
            v62 = *v61;
            v61 -= 4;
            if (v62 < 0)
              break;
            if (--v54 <= v59)
            {
              v54 = v59;
              break;
            }
          }
        }
        v63 = v54 + 1;
        v256 = v54 + 1;
        if (v54 + 1 >= v52)
        {
          v72 = 0;
          v71 = v54 + 1;
        }
        else
        {
          v64 = &v56[4 * v54 + 6];
          while (1)
          {
            v66 = *v64;
            v64 += 4;
            v65 = v66;
            v67 = v66 & 0xFFFD;
            v68 = ((unsigned __int16)v66 | 2) == 7 || v65 == 9;
            if (!v68 && v67 != 8)
              break;
            if (v52 == ++v63)
            {
              v63 = v52;
              break;
            }
          }
          v70 = LOWORD(v56[4 * v256 + 2]);
          if (v70 == 5)
            v71 = v54 + 2;
          else
            v71 = v54 + 1;
          if (v70 == 5)
            v72 = 5;
          else
            v72 = 0;
        }
        v254 = *((_DWORD *)*v295 + 4 * v50 + 2);
        if (v54 <= v59)
        {
          v83 = v54;
        }
        else
        {
          v80 = 0;
          LOBYTE(v81) = 0;
          v82 = lock[3]._os_unfair_lock_opaque & 0xFFF;
          v83 = v54;
          while (1)
          {
            v84 = &v56[4 * v83];
            v85 = v84[2];
            if ((unsigned __int16)v85 == 8 && *((_WORD *)v84 - 4) == 7)
              break;
            if ((v85 & 0x80000000) != 0)
            {
              if ((v82 == 0) | v81 & 1)
                break;
              if ((v85 & 0x18000000) == 0 || LOWORD(v56[4 * v83 - 2]) != 7)
                break;
              v87 = v72 != 5;
              if ((v85 & 0x8000000) != 0)
              {
                if ((v80 & 1) != 0)
                  break;
                v80 = 0;
                v71 = v83;
              }
              else
              {
                v80 |= (v85 & 0x10000000) >> 28;
              }
              v81 = *(_DWORD *)&v87 & (v85 >> 29);
              --v82;
              --v83;
            }
            else
            {
              --v83;
            }
            v72 = v85;
            if (v83 <= v59)
            {
              v83 = v59;
              break;
            }
          }
        }
        IndicReorderingOutput::writeMpre((IndicReorderingOutput *)v298);
        v261 = v59;
        v272 = v83;
        if (v59 == v50 + 3)
        {
          OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v50), v50, (const unsigned int *)"tkunnhkafrkrflahftsputavtcjcserpsvbaswlbstspnlah", v254, 0);
          OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (v50 + 1)), v50 + 1, (const unsigned int *)"tkunnhkafrkrflahftsputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v50 + 6), 0);
          OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (v50 + 2)), v50 + 2, (const unsigned int *)"tkunnhkafrkrflahftsputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v50 + 10), 0);
        }
        v259 = v55;
        if (v59 < v83)
        {
          v274 = 1;
          for (j = v59; j < v83; ++j)
          {
            v89 = *v295;
            v90 = *((_DWORD *)*v295 + 4 * j + 2);
            if (v90 < 0)
            {
              v92 = v89[4 * j + 6];
              v93 = "tkunnhkafrkrferputavtcjcserpsvbaswlbstspnlah";
              if (!v274)
                v93 = "tkunnhkafrkrflahutavtcjcserpsvbaswlbstspnlah";
              v274 = (unsigned __int16)v92 != 5;
              if ((unsigned __int16)v92 == 5 || (v90 & 0x20000000) == 0)
                v91 = "tkunnhkafrkrflahutavtcjcserpsvbaswlbstspnlah";
              else
                v91 = v93;
              if ((v90 & 0x20000000) != 0)
              {
                if ((unsigned __int16)v92 == 7 && (j + 2 == v272 || LOWORD(v89[4 * j + 10]) != 8))
                {
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * j), j, (const unsigned int *)"tkunnhkafrkrfwlbutavtcjcserpsvbaswlbstspnlah", v90, 0);
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (j + 1)), j + 1, (const unsigned int *)"tkunnhkafrkrfwlbutavtcjcserpsvbaswlbstspnlah", v92, 0);
                  ++j;
                  v83 = v272;
                  continue;
                }
              }
              else
              {
                v274 = 0;
              }
              v83 = v272;
            }
            else if ((unsigned __int16)*((_DWORD *)*v295 + 4 * j + 2) == 7)
            {
              if (v89[4 * j + 6] == 9)
                v91 = "tkunnhkafrkrferputavtcjcserpsvbaswlbstspnlah";
              else
                v91 = "tkunnhkafrkrflahutavtcjcserpsvbaswlbstspnlah";
            }
            else
            {
              v91 = "tkunnhkafrkrflahutavtcjcserpsvbaswlbstspnlah";
            }
            OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * j), j, (const unsigned int *)v91, v90, 0);
          }
        }
        v95 = v83;
        if (v83 != v54)
        {
          v63 = v83 + 1;
          if (v83 + 1 >= v52)
          {
            v95 = v272;
          }
          else
          {
            v96 = (unsigned __int16)*((_DWORD *)*v295 + 4 * v63 + 2);
            v98 = v96 == 5 || *((_DWORD *)*v295 + 4 * v63 + 2) == 9 || v96 == 8;
            v95 = v272;
            if (v98)
              v63 = v272 + 2;
          }
        }
        IndicReorderingOutput::noteBaseConsonant((char **)v298, 1);
        if (v95 < v63)
        {
          v102 = v272;
          v103 = (16 * v272) | 8;
          do
          {
            OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v102), v102, (const unsigned int *)"tkunnhkafrkrferputavtcjcserpsvbaswlbstspnlah", *(_DWORD *)((char *)*v295 + v103), 0);
            ++v102;
            v103 += 16;
          }
          while (v63 != v102);
        }
        if (v63 < v259 && (unsigned __int16)*((_DWORD *)*v295 + 4 * v63 + 2) != 7)
          OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v63), v63, (const unsigned int *)"tkunnhkafrkrferputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v63 + 2), 0);
        if (v54 >= v259)
        {
          v106 = 0;
          v275 = 0;
        }
        else
        {
          v275 = 0;
          v104 = *v295;
          v105 = *((unsigned __int16 *)*v295 + 8 * v256 + 4);
          v106 = v105 == 7;
          if (v249 == 1802396769)
          {
            v107 = v272;
            if (v63 >= v52)
            {
              v48 = v271;
            }
            else
            {
              v48 = v271;
              if (v105 == 7)
              {
                if ((unsigned __int16)v104[4 * v63 + 2] == 7)
                {
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v63), v63, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", v104[4 * v63 + 2], 0);
                  v106 = 1;
                  v275 = 1;
                }
                else
                {
                  v275 = 0;
                  v106 = 1;
                }
              }
            }
LABEL_184:
            if (lock[3]._os_unfair_lock_opaque >> 30 == 2)
            {
              IndicReorderingOutput::writeMabove((unsigned __int8 **)v298);
              std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 8, v298);
            }
            if (v107 != v54)
            {
              v108 = v63 + 1;
              if (v63 + 1 < v71)
              {
                v109 = 16 * v63 + 24;
                do
                {
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v108), v108, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *(_DWORD *)((char *)*v295 + v109), 0);
                  ++v108;
                  v109 += 16;
                }
                while (v71 != v108);
              }
              v110 = v71 <= v54 || v106;
              if ((v110 & 1) != 0)
              {
                v48 = v271;
                v107 = v272;
              }
              else
              {
                v48 = v271;
                v107 = v272;
                if ((unsigned __int16)*((_DWORD *)*v295 + 4 * v63 + 2) == 7)
                {
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v63), v63, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v63 + 2), 0);
                  v275 = 1;
                }
              }
              if (v71 == v259)
              {
                v111 = *((_DWORD *)*v295 + 4 * v259 + 2);
                if (v111 == 9 || (unsigned __int16)*((_DWORD *)*v295 + 4 * v259 + 2) == 8)
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v259), v259, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", v111, 0);
              }
            }
            v113 = lock[3]._os_unfair_lock_opaque;
            if (!(v113 >> 30))
            {
              IndicReorderingOutput::writeMabove((unsigned __int8 **)v298);
              std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 8, v298);
              v113 = lock[3]._os_unfair_lock_opaque;
            }
            if ((v113 & 0x20000000) != 0)
            {
              if (v261 == v50 + 2)
              {
                OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v50), v50, (const unsigned int *)"tkunnhkafhprfrkrferpfwlbflahftsputavtcjcserpsvbaswlbstspnlah", v254, 0);
                v107 = v272;
                OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (v50 + 1)), v50 + 1, (const unsigned int *)"tkunnhkafhprfrkrferpfwlbflahftsputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v50 + 6), 0);
              }
              std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 2863311362, v298);
              std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 2863311363, v298);
            }
            v13 = this;
            if (v107 != v54)
            {
              if (v63 <= v71)
                v114 = v71;
              else
                v114 = v63;
              if (v114 <= v54)
              {
                v115 = (16 * v114) | 8;
                do
                {
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v114), v114, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *(_DWORD *)((char *)*v295 + v115), 0);
                  ++v114;
                  v115 += 16;
                }
                while (v256 != v114);
              }
              if ((v275 & 1) == 0 && (unsigned __int16)*((_DWORD *)*v295 + 4 * v63 + 2) == 7)
                OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v63), v63, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v63 + 2), 0);
              v48 = v271;
              if (v106)
              {
                OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v256), v256, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v256 + 2), 0);
                if (v256 < v259 && *((_DWORD *)*v295 + 4 * v54 + 10) == 9)
                  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (v54 + 2)), v54 + 2, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", 9, 0);
              }
            }
            v43 = lock;
            if (lock[3]._os_unfair_lock_opaque >> 30 == 1)
            {
              IndicReorderingOutput::writeMabove((unsigned __int8 **)v298);
              std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*(unsigned __int8 **)(v298 + 432), *(unsigned __int8 **)(v298 + 440), 8, v298);
            }
            IndicReorderingOutput::writeMpost((unsigned __int8 **)v298);
            v47 = v252;
            if ((lock[3]._os_unfair_lock_opaque & 0x20000000) == 0)
            {
              if (v261 == v50 + 2)
              {
                OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v50), v50, (const unsigned int *)"tkunnhkafhprfrkrferpfwlbflahftsputavtcjcserpsvbaswlbstspnlah", v254, 0);
                OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (v50 + 1)), v50 + 1, (const unsigned int *)"tkunnhkafhprfrkrferpfwlbflahftsputavtcjcserpsvbaswlbstspnlah", *((_DWORD *)*v295 + 4 * v50 + 6), 0);
              }
              goto LABEL_229;
            }
            goto LABEL_230;
          }
        }
        v48 = v271;
        v107 = v272;
        goto LABEL_184;
      }
      if ((v58 & 0x1A0) != 0)
      {
        v77 = (OpenTypeReorderingOutput *)v298;
        if (!v50 || (v78 = *((_QWORD *)v13 + 4), *(_DWORD *)(v78 + 4 * v50 - 4) != 9676))
        {
          v79 = *((_DWORD *)*v295 + 4 * v50 + 2);
          OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, 9676, v50, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", 3, 0x8000000000000000);
          v57 = v79;
          v77 = (OpenTypeReorderingOutput *)v298;
          v78 = *((_QWORD *)v13 + 4);
        }
        OpenTypeReorderingOutput::writeChar(v77, *(_DWORD *)(v78 + 4 * v50), v50, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", v57, 0);
        v48 = v271;
      }
      else
      {
LABEL_239:
        v48 = v271;
        if (v50 < v271)
        {
          v120 = (16 * v50) | 8;
          do
          {
            OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v298, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v50), v50, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *(_DWORD *)((char *)*v295 + v120), 0);
            ++v50;
            v120 += 16;
          }
          while (v271 != v50);
        }
      }
LABEL_231:
      v116 = v298;
      if ((uint64_t)(*(_QWORD *)(v298 + 64) - *(_QWORD *)(v298 + 56)) >= 1)
      {
        v117 = operator new(0x20uLL);
        *v117 = &off_1E15E03B8;
        v117[1] = &v298;
        v117[2] = v13;
        v117[3] = &v295;
        *(_QWORD *)&v284 = v117;
        OpenTypeReorderingOutput::forEachUnwrittenIndex(v116, v48, (uint64_t)&v282);
        v118 = (char **)v284;
        if ((char **)v284 == &v282)
        {
          v118 = &v282;
          v119 = 4;
          goto LABEL_236;
        }
        if ((_QWORD)v284)
        {
          v119 = 5;
LABEL_236:
          (*(void (**)(void))&(*v118)[8 * v119])();
        }
      }
      v49 = *(_QWORD *)v267;
      if (v48 >= v47)
      {
        v44 = (OpenTypeReorderingOutput *)v298;
LABEL_245:
        *a3 = v44;
        return;
      }
    }
  }
  v26 = *((_QWORD *)v13 + 63);
  if (!v26)
    v26 = *((_QWORD *)v13 + 62);
  strcpy(a2, "tkunnhkafhprfrkrferpfwlbflahftsputavtcjc");
  a2[41] = 0;
  *((_WORD *)a2 + 21) = 0;
  v27 = (OpenTypeReorderingOutput *)operator new();
  OpenTypeReorderingOutput::OpenTypeReorderingOutput(v27, *((TRunGlue **)v13 + 1));
  *(_QWORD *)v28 = &off_1E15DDE80;
  *(_QWORD *)(v28 + 440) = 0;
  *(_QWORD *)(v28 + 448) = 0;
  *(_QWORD *)(v28 + 432) = 0;
  *(_QWORD *)(v28 + 968) = v28 + 456;
  *(_QWORD *)(v28 + 992) = (char *)v13 + 520;
  *(_DWORD *)(v28 + 1004) = 0;
  *(_DWORD *)(v28 + 1052) = 0;
  *(_DWORD *)(v28 + 1060) = 0;
  IndicReorderingOutput::reset((IndicReorderingOutput *)v28, -1);
  v279 = (uint64_t *)*((_QWORD *)v13 + 3);
  v280 = v27;
  *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v299[7] = v29;
  v300 = v29;
  v299[5] = v29;
  v299[6] = v29;
  v299[3] = v29;
  v299[4] = v29;
  v299[1] = v29;
  v299[2] = v29;
  v298 = v29;
  v299[0] = v29;
  LOBYTE(v298) = 0;
  BYTE8(v300) = 0;
  v30 = *(_DWORD *)(v26 + 12);
  v31 = v26;
  v270 = v26;
  if ((v30 & 0x2000) == 0)
    goto LABEL_264;
  v32 = *((_QWORD *)v13 + 64);
  v278 = 1919969382;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(&v282, &v278, &v279);
  OTL::GCommon::GetLookups(v32, (uint64_t)&v282, (uint64_t)&v295);
  if (BYTE8(v300) != v297)
  {
    if (BYTE8(v300))
    {
      v281 = (char **)&v298;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v281);
      BYTE8(v300) = 0;
    }
    else
    {
      *(_QWORD *)&v299[0] = 0;
      v298 = 0uLL;
      *(_QWORD *)&v300 = (char *)v299 + 8;
      std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>,std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>>((char *)&v298, (int *)v295, v296, ((char *)v296 - (char *)v295) >> 2);
      BYTE8(v300) = 1;
    }
LABEL_261:
    if (v297)
    {
      v281 = (char **)&v295;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v281);
    }
    goto LABEL_263;
  }
  if (BYTE8(v300))
  {
    v34 = v295;
    v33 = v296;
    v35 = ((char *)v296 - (char *)v295) >> 2;
    v36 = (char *)v298;
    if (v35 <= (uint64_t)(*(_QWORD *)&v299[0] - v298) >> 2)
    {
      v39 = (char *)*((_QWORD *)&v298 + 1);
      v121 = (uint64_t)(*((_QWORD *)&v298 + 1) - v298) >> 2;
      if (v121 >= v35)
      {
        v31 = v270;
        v127 = v298;
        if (v295 != (void **)v296)
        {
          v128 = (_DWORD *)v298;
          do
          {
            v129 = *(_DWORD *)v34;
            v34 = (void **)((char *)v34 + 4);
            *v128++ = v129;
            v127 += 4;
          }
          while (v34 != (void **)v33);
        }
        v42 = (char *)(v127 - (_QWORD)v36);
        v39 = v36;
      }
      else
      {
        v122 = (int *)v295 + v121;
        v31 = v270;
        if (*((_QWORD *)&v298 + 1) != (_QWORD)v298)
        {
          do
          {
            v123 = *(_DWORD *)v34;
            v34 = (void **)((char *)v34 + 4);
            *(_DWORD *)v36 = v123;
            v36 += 4;
          }
          while (v34 != (void **)v122);
        }
        v124 = v39;
        if (v122 != v33)
        {
          v125 = v39;
          do
          {
            v126 = *v122++;
            *(_DWORD *)v125 = v126;
            v125 += 4;
            v124 += 4;
          }
          while (v122 != v33);
        }
        v42 = (char *)(v124 - v39);
      }
    }
    else
    {
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vdeallocate((uint64_t)&v298);
      if ((char *)v33 - (char *)v34 < 0)
        abort();
      v37 = (uint64_t)(*(_QWORD *)&v299[0] - v298) >> 1;
      if (v37 <= v35)
        v37 = ((char *)v33 - (char *)v34) >> 2;
      if (*(_QWORD *)&v299[0] - (_QWORD)v298 >= 0x7FFFFFFFFFFFFFFCuLL)
        v38 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v38 = v37;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vallocate[abi:nn180100](&v298, v38);
      v39 = (char *)*((_QWORD *)&v298 + 1);
      v40 = (char *)*((_QWORD *)&v298 + 1);
      if (v34 != (void **)v33)
      {
        v40 = (char *)*((_QWORD *)&v298 + 1);
        do
        {
          v41 = *(_DWORD *)v34;
          v34 = (void **)((char *)v34 + 4);
          *(_DWORD *)v40 = v41;
          v40 += 4;
        }
        while (v34 != (void **)v33);
      }
      v42 = (char *)(v40 - v39);
      v31 = v270;
    }
    *((_QWORD *)&v298 + 1) = &v42[(_QWORD)v39];
    goto LABEL_261;
  }
LABEL_263:
  v281 = &v282;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v281);
  v30 = *(_DWORD *)(v31 + 12);
LABEL_264:
  v295 = (void **)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah";
  if ((v30 & 0x1000) != 0)
    v130 = "tkunnhkafrkrflahutavtcjcserpsvbaswlbstspnlah";
  else
    v130 = "tkunnhkafrkrfwlbflahutavtcjcserpsvbaswlbstspnlah";
  v131 = TRunGlue::length(*((TRunGlue **)v13 + 1));
  if (v131 >= 1)
  {
    v132 = v131;
    v133 = 0;
    v134 = 0;
    v260 = v131;
    v253 = v130;
    while (1)
    {
      v135 = v133;
      v273 = v134 + 1;
      v136 = IndicShapingEngine::FindSyllableEnd((TRunGlue **)v13, v133, (int)v134 + 1);
      if (v136 - v133 >= 2
        && IsProhibitedSequence(*(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v133), *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * (v133 + 1)), 0))
      {
        v136 = v133 + 1;
      }
      (*(void (**)(IndicReorderingOutput *, uint64_t))(*(_QWORD *)v280 + 16))(v280, v133);
      v276 = v136;
      if (v136 == v133)
      {
LABEL_279:
        v139 = v279;
        v137 = v135;
      }
      else
      {
        v137 = v136;
        v138 = 16 * v136 - 8;
        while ((*(_DWORD *)(*v279 + v138) & 0xFFFE) == 0xC)
        {
          IndicReorderingOutput::noteSyllableModifier((int64x2_t *)v280, (const IndicClassTable *)v31, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v137 - 4), v137 - 1, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah");
          v138 -= 16;
          if (v135 == --v137)
            goto LABEL_279;
        }
        while (1)
        {
          v139 = v279;
          v140 = *v279;
          if (*(_WORD *)(*v279 + v138) != 1)
            break;
          IndicReorderingOutput::noteVowelModifier((int64x2_t *)v280, (const IndicClassTable *)v31, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v137 - 4), v137 - 1, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah");
          v138 -= 16;
          if (v135 == --v137)
            goto LABEL_279;
        }
        if (v137 > v135)
        {
          v174 = v137;
          while (v174 > v135)
          {
            --v174;
            v175 = *(unsigned __int16 *)(v140 + v138) - 7;
            v140 -= 16;
            if (v175 >= 3)
            {
              do
              {
                v176 = IndicReorderingOutput::noteMatra((int64x2_t *)v280, (const IndicClassTable *)v31, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v174), v174, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah");
                if (v174 <= v135)
                  break;
                --v174;
              }
              while ((v176 & 1) != 0);
              break;
            }
          }
          IndicReorderingOutput::assignReorderClasses((uint64_t)v280, (const IndicClassTable *)v31);
          v177 = IndicReorderingOutput::finishMatras(v280, v276, (*(_DWORD *)(*((_QWORD *)v13 + 62) + 12) & 0x4000000) == 0);
          if (v177 >= v137)
            v178 = v137;
          else
            v178 = v177;
          if (v177 != v276)
            v137 = v178;
          v139 = v279;
          v276 = v177;
        }
      }
      v141 = *v139;
      v142 = *(_DWORD *)(v141 + 16 * v135 + 8);
      if ((unsigned __int16)v142 > 0xFu)
        goto LABEL_349;
      v143 = 1 << v142;
      if (((1 << v142) & 0x3042) == 0)
        break;
      v169 = IndicReorderingOutput::writeMpre(v280);
      v170 = v280;
      v134 = v273;
      if (!v135 || *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v135 - 4) != 9676)
      {
        if (v169)
          v171 = 0xA000000000000000;
        else
          v171 = 0x8000000000000000;
        OpenTypeReorderingOutput::writeChar(v280, 9676, v135, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", 3, v171);
        v170 = v280;
      }
      v133 = v276;
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v170 + 54), *((unsigned __int8 **)v170 + 55), 0x100000000, (uint64_t)v170);
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 0x200000000, (uint64_t)v280);
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 0x300000000, (uint64_t)v280);
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 0x400000000, (uint64_t)v280);
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 2863311362, (uint64_t)v280);
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 2863311363, (uint64_t)v280);
      IndicReorderingOutput::writeVMpost((unsigned __int8 **)v280);
LABEL_495:
      v243 = v280;
      if ((uint64_t)(*((_QWORD *)v280 + 8) - *((_QWORD *)v280 + 7)) >= 1)
      {
        v244 = operator new(0x28uLL);
        *v244 = &off_1E15E0400;
        v244[1] = &v280;
        v244[2] = v13;
        v244[3] = &v295;
        v244[4] = &v279;
        *(_QWORD *)&v284 = v244;
        OpenTypeReorderingOutput::forEachUnwrittenIndex((uint64_t)v243, v133, (uint64_t)&v282);
        v245 = (char **)v284;
        if ((char **)v284 == &v282)
        {
          v245 = &v282;
          v246 = 4;
          goto LABEL_500;
        }
        if ((_QWORD)v284)
        {
          v246 = 5;
LABEL_500:
          (*(void (**)(void))&(*v245)[8 * v246])();
        }
      }
      if (v133 >= v132)
        goto LABEL_502;
    }
    if ((v143 & 0x801C) != 0)
    {
      v144 = v137 - v135;
      if (v137 - v135 >= 3 && (v142 & 0x40000000) != 0)
      {
        v146 = *(_DWORD *)(v141 + 16 * (v135 + 2) + 8);
        if ((unsigned __int16)*(_DWORD *)(v141 + 16 * (v135 + 1) + 8) == 7
          || (v144 >= 4 ? (v147 = *(_DWORD *)(v141 + 16 * (v135 + 1) + 8) == 9) : (v147 = 0),
              v147 ? (v148 = (unsigned __int16)*(_DWORD *)(v141 + 16 * (v135 + 2) + 8) == 7) : (v148 = 0),
              v148))
        {
          if ((*(_BYTE *)(v31 + 13) & 0x20) != 0
            || (v146 != 9 ? (v149 = (unsigned __int16)*(_DWORD *)(v141 + 16 * (v135 + 2) + 8) == 8) : (v149 = 1), v149))
          {
            if (v144 >= 4)
            {
              LOWORD(v281) = TRunGlue::GetGlyphID(*((TRunGlue **)v13 + 1), v135);
              WORD1(v281) = TRunGlue::GetGlyphID(*((TRunGlue **)v13 + 1), v135 + 1);
              WORD2(v281) = TRunGlue::GetGlyphID(*((TRunGlue **)v13 + 1), v135 + 2);
              if (BYTE8(v300))
              {
                v250 = v146;
                v257 = v142;
                v150 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v13 + 1) + 616) + 400);
                locka = (os_unfair_lock_s *)(v150 + 356);
                os_unfair_lock_lock_with_options();
                v248 = (unsigned __int16 *)*((_QWORD *)&v298 + 1);
                v151 = (unsigned __int16 *)v298;
                if ((_QWORD)v298 != *((_QWORD *)&v298 + 1))
                {
                  v247 = v150;
                  do
                  {
                    v152 = v151;
                    v153 = TBaseFont::NthLookup<OTL::GSUB>(v150, *((_QWORD **)v13 + 64), *v151);
                    if (v153)
                    {
                      v154 = v153;
                      v262 = (unsigned __int16)(-21845
                                              * ((*((_DWORD *)v153 + 24) - *((_DWORD *)v153 + 22)) >> 4));
                      if (-21845
                         * (unsigned __int16)((*((_DWORD *)v153 + 24) - *((_DWORD *)v153 + 22)) >> 4))
                      {
                        v155 = 0;
                        v268 = (_QWORD *)*((_QWORD *)this + 64);
                        while (2)
                        {
                          v156 = v154[11];
                          v157 = 0xAAAAAAAAAAAAAAABLL * ((v154[12] - v156) >> 4);
                          v158 = v157 <= v155 ? 0 : v156 + 48 * v155 + 8;
                          if (v157 > v155)
                          {
                            v159 = v156 + 48 * v155;
                            v160 = (uint64_t (**)(_QWORD *, _QWORD))(v159 + 24);
                            v161 = (uint64_t *)(v159 + 32);
                            v162 = (unsigned __int16 *)&v281;
                            v163 = 3;
                            do
                            {
                              v164 = *v160;
                              v165 = (_QWORD *)(v158 + (*v161 >> 1));
                              if ((*v161 & 1) != 0)
                                v164 = *(uint64_t (**)(_QWORD *, _QWORD))(*v165 + v164);
                              v166 = v164(v165, *v162);
                              if (v166)
                              {
                                v167 = v154[11];
                                v168 = 0xAAAAAAAAAAAAAAABLL * ((v154[12] - v167) >> 4) <= v155
                                     ? 0
                                     : *(ChainContextSubstFormat1 **)(v167 + 48 * v155);
                                if ((OTL::GSUB::WouldSubstituteSubtable(v268, (int)v154, *((unsigned __int16 *)v154 + 8), v168, v166, v162, v163) & 1) != 0)
                                {
                                  os_unfair_lock_unlock(locka);
                                  v13 = this;
                                  v183 = *((_QWORD *)this + 4);
                                  v184 = *(_DWORD *)(v183 + 4 * v135);
                                  v185 = *(_DWORD *)(v183 + 4 * (v135 + 1));
                                  v186 = v280;
                                  LOWORD(v183) = *(_DWORD *)(v183 + 4 * (v135 + 2));
                                  *((_QWORD *)v280 + 133) = v135;
                                  v135 += 3;
                                  *((_WORD *)v186 + 524) = v184;
                                  *((_DWORD *)v186 + 263) = v257;
                                  *((_WORD *)v186 + 528) = v185;
                                  *((_WORD *)v186 + 529) = v183;
                                  *((_DWORD *)v186 + 265) = v250;
                                  *((_QWORD *)v186 + 135) = "tkunnhkafhprfrkrferpfwlbflahftsputavtcjcserpsvbaswlbstspnlah";
                                  goto LABEL_354;
                                }
                              }
                              ++v162;
                              --v163;
                            }
                            while (v163);
                            if (++v155 != v262)
                              continue;
                          }
                          break;
                        }
                      }
                    }
                    v151 = v152 + 2;
                    v150 = v247;
                    v13 = this;
                  }
                  while (v152 + 2 != v248);
                }
                os_unfair_lock_unlock(locka);
LABEL_354:
                v31 = v270;
                v130 = v253;
              }
            }
          }
          else
          {
            v180 = v280;
            v181 = *((_QWORD *)v13 + 4);
            v182 = *(_DWORD *)(v181 + 4 * v135);
            LOWORD(v181) = *(_DWORD *)(v181 + 4 * (v135 + 1));
            *((_WORD *)v280 + 524) = v182;
            *((_DWORD *)v180 + 263) = v142;
            *((_WORD *)v180 + 528) = v181;
            *((_WORD *)v180 + 529) = 0;
            *((_DWORD *)v180 + 265) = 0;
            *((_QWORD *)v180 + 133) = v135;
            *((_QWORD *)v180 + 135) = "tkunnhkafhprfrkrferpfwlbflahftsputavtcjcserpsvbaswlbstspnlah";
            v135 += 2;
          }
        }
      }
      v187 = v137 - 1;
      if (v135 < v137 - 1)
        v187 = v135;
      v188 = v187 + 1;
      v189 = *v279;
      v190 = (int *)(*v279 + 16 * v137 - 8);
      v191 = v137;
      while (--v191 > v135)
      {
        v192 = *v190;
        v190 -= 4;
        if (v192 < 0)
        {
          v188 = v191 + 1;
          goto LABEL_362;
        }
      }
      v191 = v187;
LABEL_362:
      v193 = v188;
      v194 = (os_unfair_lock_s *)v188;
      if (v188 < v137)
      {
        v195 = (unsigned __int16 *)(v189 + 16 * v188 + 8);
        v193 = v188;
        while (1)
        {
          v197 = *v195;
          v195 += 8;
          v196 = v197;
          if ((v197 - 7) >= 4 && v196 != 5)
            break;
          if (v137 == ++v193)
          {
            v193 = v137;
            break;
          }
        }
        if (*(_WORD *)(v189 + 16 * v188 + 8) == 5)
          v194 = (os_unfair_lock_s *)(v188 + 1);
        else
          v194 = (os_unfair_lock_s *)v188;
      }
      v199 = v280;
      if (v191 <= v135)
      {
        v202 = 0;
        v204 = -1;
        v205 = v191;
      }
      else
      {
        v200 = 0;
        v201 = 0;
        v202 = 0;
        v203 = *(_DWORD *)(v31 + 12) & 0xFFF;
        v204 = -1;
        v205 = v191;
        do
        {
          v206 = *(_DWORD *)(v189 + 16 * v205 + 8);
          if ((unsigned __int16)v206 == 8)
          {
            v207 = v205 - 1;
            if (*(_WORD *)(v189 + 16 * (v205 - 1) + 8) == 7)
              goto LABEL_398;
          }
          else if (v206 < 0)
          {
            if (!v203)
              goto LABEL_398;
            v207 = v205 - 1;
            if (*(_WORD *)(v189 + 16 * (v205 - 1) + 8) != 7
              || (v206 & 0x18000000) == 0 && ((v206 & 0x4000000) == 0) | v200 & 1)
            {
              goto LABEL_398;
            }
            if ((v206 & 0x4000000) != 0
              && (v205 - 2 < v135
               || *(_DWORD *)(v189 + 16 * v188 - 40) != 9 && (unsigned __int16)*(_DWORD *)(v189 + 16 * v188 - 40) != 8))
            {
              v208 = *((_QWORD *)v13 + 4);
              v209 = *(_DWORD *)(v208 + 4 * v205);
              LOWORD(v208) = *(_DWORD *)(v208 + 4 * v207);
              *((_QWORD *)v199 + 128) = 0;
              *((_QWORD *)v199 + 127) = v205;
              *((_WORD *)v199 + 500) = v209;
              *((_DWORD *)v199 + 251) = v206;
              *((_WORD *)v199 + 504) = v208;
              *((_QWORD *)v199 + 130) = "tkunnhkafrkrferpftsputavtcjcserpsvbaswlbstspnlah";
              v200 = 1;
              v194 = (os_unfair_lock_s *)(v205 - 1);
              v202 = 2;
              v204 = v205 - 1;
            }
            if ((v206 & 0x8000000) != 0)
            {
              if ((v201 & 1) != 0)
                goto LABEL_398;
              v201 = 0;
              v194 = (os_unfair_lock_s *)v205;
            }
            else
            {
              v201 |= (v206 & 0x10000000u) >> 28;
            }
            --v203;
          }
          else
          {
            v207 = v205 - 1;
          }
          v205 = v207;
        }
        while (v207 > v135);
        v205 = v135;
      }
LABEL_398:
      *(_QWORD *)v255 = v202;
      v258 = v204;
      lockb = v194;
      *(_QWORD *)v269 = v188;
      if (*(_WORD *)(v189 + 16 * v205 + 8) == 7)
        v210 = v205 + 1;
      else
        v210 = v205;
      v211 = (os_unfair_lock_s *)(v205 + 1) == v194 && *(unsigned __int16 *)(v189 + 16 * v205 + 8) == 7;
      v263 = v211;
      if (*((_WORD *)v199 + 524))
      {
        v212 = *(_DWORD *)(v31 + 12) & 0x3000000;
        if (v212 == 50331648)
        {
          v213 = v210 + 1;
          if (v210 + 1 < v260 && *(_WORD *)(v189 + 16 * v213 + 8) == 5)
            v213 = v210 + 2;
        }
        else
        {
          v213 = v137;
          if (v212 == 0x2000000)
          {
            if (v210 <= v191)
              v214 = v191;
            else
              v214 = v210;
            v215 = (int *)(v189 + 16 * v210 + 24);
            v213 = v210;
            while (v214 != v213)
            {
              ++v213;
              v216 = *v215;
              v215 += 4;
              if ((~v216 & 0x88000000) == 0)
                goto LABEL_420;
            }
            v213 = v137;
          }
        }
LABEL_420:
        IndicReorderingOutput::writeReph(v199);
        v199 = v280;
      }
      else
      {
        v213 = v137;
      }
      v217 = (_BYTE *)*((_QWORD *)v199 + 54);
      v218 = (_BYTE *)*((_QWORD *)v199 + 55);
      if (v217 != v218)
      {
        while (*v217 != 5)
        {
          v217 += 64;
          if (v217 == v218)
            goto LABEL_426;
        }
      }
      if (v217 == v218)
      {
LABEL_426:
        if (*((_WORD *)v199 + 500))
          goto LABEL_427;
      }
      else
      {
LABEL_427:
        IndicReorderingOutput::writeMpre(v199);
      }
      if (v135 < v210)
      {
        v219 = 16 * v135;
        do
        {
          v220 = *v279;
          v221 = *(_DWORD *)(*v279 + v219 + 8);
          if (v213 == v135 && *((_WORD *)v280 + 524))
            *((_QWORD *)v280 + 134) = (uint64_t)(*((_QWORD *)v280 + 8) - *((_QWORD *)v280 + 7)) >> 2;
          v222 = (const unsigned int *)v130;
          if ((unsigned __int16)v221 == 7)
          {
            if (*(_DWORD *)(v220 + v219 + 24) == 9)
              v222 = (const unsigned int *)"tkunnhkafrkrferputavtcjcserpsvbaswlbstspnlah";
            else
              v222 = (const unsigned int *)v130;
          }
          OpenTypeReorderingOutput::writeChar(v280, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v135), v135, v222, v221, 0);
          v219 += 16;
          ++v135;
        }
        while (v210 != v135);
      }
      v223 = v193;
      if (v210 != v191)
      {
        v223 = v210 + 1;
        if (v210 + 1 < v137 && *(_WORD *)(*v279 + 16 * v223 + 8) == 5)
          v223 = v210 + 2;
      }
      IndicReorderingOutput::noteBaseConsonant((char **)v280, 0);
      if (v213 == v210 && *((_WORD *)v280 + 524))
        *((_QWORD *)v280 + 134) = (uint64_t)(*((_QWORD *)v280 + 8) - *((_QWORD *)v280 + 7)) >> 2;
      if (v210 < v223)
      {
        v224 = (16 * v210) | 8;
        v225 = v210;
        do
        {
          OpenTypeReorderingOutput::writeChar(v280, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v225), v225, (const unsigned int *)"tkunnhkafrkrferputavtcjcserpsvbaswlbstspnlah", *(_DWORD *)(*v279 + v224), 0);
          ++v225;
          v224 += 16;
        }
        while (v223 != v225);
      }
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 0x100000000, (uint64_t)v280);
      v226 = v280;
      v31 = v270;
      if (v213 == v223 && *((_WORD *)v280 + 524))
        *((_QWORD *)v280 + 134) = (uint64_t)(*((_QWORD *)v280 + 8) - *((_QWORD *)v280 + 7)) >> 2;
      v227 = (char *)lockb + v263;
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v226 + 54), *((unsigned __int8 **)v226 + 55), 0x200000000, (uint64_t)v226);
      v228 = 0;
      if (v210 != v191 && v223 < (uint64_t)v227)
      {
        v229 = v227 - 1;
        v230 = (16 * v223) | 8;
        v231 = v223;
        while (1)
        {
          v232 = *v279;
          if (v229 == (char *)v231 && *(_WORD *)(v232 + 16 * (_QWORD)v229 + 8) == 7)
            break;
          OpenTypeReorderingOutput::writeChar(v280, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v231), v231, (const unsigned int *)v295, *(_DWORD *)(v232 + v230), 0);
          ++v231;
          v230 += 16;
          if (v227 == (char *)v231)
          {
            v228 = 0;
            goto LABEL_459;
          }
        }
        v228 = -1;
LABEL_459:
        v31 = v270;
      }
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 0x300000000, (uint64_t)v280);
      if ((char *)v223 != v227 && (char *)v213 == v227 && *((_WORD *)v280 + 524))
        *((_QWORD *)v280 + 134) = (uint64_t)(*((_QWORD *)v280 + 8) - *((_QWORD *)v280 + 7)) >> 2;
      if (v210 != v191)
      {
        v227 += v228;
        v233 = v223 <= (uint64_t)v227 ? (uint64_t)v227 : v223;
        if (v233 < v193)
        {
          do
          {
            if (v233 == v258)
            {
              IndicReorderingOutput::writePreBaseConsonant(v280);
              v233 = *(_QWORD *)v255 + v258 - 1;
            }
            else
            {
              OpenTypeReorderingOutput::writeChar(v280, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v233), v233, (const unsigned int *)v295, *(_DWORD *)(*v279 + 16 * v233 + 8), 0);
            }
            ++v233;
          }
          while (v233 < v193);
          v31 = v270;
        }
      }
      v234 = v280;
      if (v213 >= *(uint64_t *)v269 && v213 != v223 && (char *)v213 != v227 && *((_WORD *)v280 + 524))
        *((_QWORD *)v280 + 134) = (uint64_t)(*((_QWORD *)v280 + 8) - *((_QWORD *)v280 + 7)) >> 2;
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v234 + 54), *((unsigned __int8 **)v234 + 55), 0x400000000, (uint64_t)v234);
      v235 = v280;
      v236 = *((_QWORD *)v280 + 5);
      v237 = v236 + 1;
      v13 = this;
      v134 = v273;
      if (v236 + 1 < v137)
      {
        v238 = 16 * v236 + 24;
        do
        {
          OpenTypeReorderingOutput::writeChar(v280, *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v237), v237, (const unsigned int *)v295, *(_DWORD *)(*v279 + v238), 0);
          ++v237;
          v238 += 16;
        }
        while (v137 != v237);
        v235 = v280;
      }
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v235 + 54), *((unsigned __int8 **)v235 + 55), 2863311362, (uint64_t)v235);
      std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(*((unsigned __int8 **)v280 + 54), *((unsigned __int8 **)v280 + 55), 2863311363, (uint64_t)v280);
      IndicReorderingOutput::writeVMpost((unsigned __int8 **)v280);
      v239 = *(_DWORD *)(v31 + 12);
      v241 = (~v239 & 0x300000) == 0 && v213 == v223;
      v242 = (char **)v280;
      if ((v239 & 0x3000000) == 0 && !v241 && *((_WORD *)v280 + 524))
        *((_QWORD *)v280 + 134) = (uint64_t)(*((_QWORD *)v280 + 8) - *((_QWORD *)v280 + 7)) >> 2;
      IndicReorderingOutput::writeRephFixup(v242);
      v130 = v253;
      v132 = v260;
      goto LABEL_494;
    }
    if ((v143 & 0x1A0) != 0)
    {
      v172 = v280;
      if (!v135 || (v173 = *((_QWORD *)v13 + 4), *(_DWORD *)(v173 + 4 * v135 - 4) != 9676))
      {
        OpenTypeReorderingOutput::writeChar(v280, 9676, v135, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", 3, 0x8000000000000000);
        v172 = v280;
        v173 = *((_QWORD *)v13 + 4);
      }
      v134 = v273;
      OpenTypeReorderingOutput::writeChar(v172, *(_DWORD *)(v173 + 4 * v135), v135, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", v142, 0);
LABEL_494:
      v133 = v276;
      goto LABEL_495;
    }
LABEL_349:
    v134 = v273;
    v133 = v276;
    if (v135 < v276)
    {
      v179 = (16 * v135) | 8;
      do
      {
        OpenTypeReorderingOutput::writeChar(v280, *(_DWORD *)(*((_QWORD *)v13 + 4) + 4 * v135), v135, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *(_DWORD *)(*v279 + v179), 0);
        ++v135;
        v179 += 16;
      }
      while (v276 != v135);
    }
    goto LABEL_495;
  }
LABEL_502:
  *a3 = v280;
  if (BYTE8(v300))
  {
    v295 = (void **)&v298;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v295);
  }
}

void OpenTypeReorderingOutput::writeChar(OpenTypeReorderingOutput *this, int a2, uint64_t a3, const unsigned int *a4, int a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t InsertedIndex;
  uint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  int *v27;
  _DWORD *v28;
  int *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  int *v35;
  char *v36;
  int v37;
  unint64_t v38;
  char *v39;
  _DWORD *v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  int v49;
  unint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;

  if ((a6 & 0x8000000000000000) == 0)
  {
    v10 = *((_QWORD *)this + 3);
    if ((v10 & 0x8000000000000000) == 0)
    {
      *((_DWORD *)this + 8) |= 1 << (a3 - v10);
      v11 = *((_QWORD *)this + 5);
      if (v11 <= a3)
        v11 = a3;
      *((_QWORD *)this + 5) = v11;
    }
  }
  InsertedIndex = OpenTypeReorderingOutput::getInsertedIndex(this, a2, a3, a6);
  v13 = InsertedIndex;
  v14 = *((_QWORD *)this + 12);
  v15 = (uint64_t *)*((_QWORD *)this + 11);
  if ((unint64_t)v15 >= v14)
  {
    v17 = (uint64_t *)*((_QWORD *)this + 10);
    v18 = v15 - v17;
    v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 61)
      goto LABEL_68;
    v20 = v14 - (_QWORD)v17;
    if (v20 >> 2 > v19)
      v19 = v20 >> 2;
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v21 = v19;
    if (v21)
    {
      v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<long>>((uint64_t)this + 96, v21);
      v17 = (uint64_t *)*((_QWORD *)this + 10);
      v15 = (uint64_t *)*((_QWORD *)this + 11);
    }
    else
    {
      v22 = 0;
    }
    v23 = (uint64_t *)&v22[8 * v18];
    v24 = &v22[8 * v21];
    *v23 = v13;
    v16 = v23 + 1;
    while (v15 != v17)
    {
      v25 = *--v15;
      *--v23 = v25;
    }
    *((_QWORD *)this + 10) = v23;
    *((_QWORD *)this + 11) = v16;
    *((_QWORD *)this + 12) = v24;
    if (v17)
      operator delete(v17);
  }
  else
  {
    *v15 = InsertedIndex;
    v16 = v15 + 1;
  }
  v26 = *((_QWORD *)this + 9);
  *((_QWORD *)this + 11) = v16;
  v27 = (int *)*((_QWORD *)this + 8);
  if ((unint64_t)v27 >= v26)
  {
    v29 = (int *)*((_QWORD *)this + 7);
    v30 = v27 - v29;
    v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 62)
      goto LABEL_68;
    v32 = v26 - (_QWORD)v29;
    if (v32 >> 1 > v31)
      v31 = v32 >> 1;
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL)
      v33 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v33 = v31;
    if (v33)
    {
      v34 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)this + 72, v33);
      v29 = (int *)*((_QWORD *)this + 7);
      v27 = (int *)*((_QWORD *)this + 8);
    }
    else
    {
      v34 = 0;
    }
    v35 = (int *)&v34[4 * v30];
    v36 = &v34[4 * v33];
    *v35 = a2;
    v28 = v35 + 1;
    while (v27 != v29)
    {
      v37 = *--v27;
      *--v35 = v37;
    }
    *((_QWORD *)this + 7) = v35;
    *((_QWORD *)this + 8) = v28;
    *((_QWORD *)this + 9) = v36;
    if (v29)
      operator delete(v29);
  }
  else
  {
    *v27 = a2;
    v28 = v27 + 1;
  }
  v38 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 8) = v28;
  v39 = (char *)*((_QWORD *)this + 14);
  if ((unint64_t)v39 >= v38)
  {
    v41 = (char *)*((_QWORD *)this + 13);
    v42 = (v39 - v41) >> 2;
    v43 = v42 + 1;
    if ((unint64_t)(v42 + 1) >> 62)
      goto LABEL_68;
    v44 = v38 - (_QWORD)v41;
    if (v44 >> 1 > v43)
      v43 = v44 >> 1;
    if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFFCLL)
      v45 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v45 = v43;
    if (v45)
    {
      v46 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)this + 120, v45);
      v41 = (char *)*((_QWORD *)this + 13);
      v39 = (char *)*((_QWORD *)this + 14);
    }
    else
    {
      v46 = 0;
    }
    v47 = &v46[4 * v42];
    v48 = &v46[4 * v45];
    *(_DWORD *)v47 = a5;
    v40 = v47 + 4;
    while (v39 != v41)
    {
      v49 = *((_DWORD *)v39 - 1);
      v39 -= 4;
      *((_DWORD *)v47 - 1) = v49;
      v47 -= 4;
    }
    *((_QWORD *)this + 13) = v47;
    *((_QWORD *)this + 14) = v40;
    *((_QWORD *)this + 15) = v48;
    if (v41)
      operator delete(v41);
  }
  else
  {
    *(_DWORD *)v39 = a5;
    v40 = v39 + 4;
  }
  v50 = *((_QWORD *)this + 18);
  *((_QWORD *)this + 14) = v40;
  v51 = (_QWORD *)*((_QWORD *)this + 17);
  if ((unint64_t)v51 < v50)
  {
    *v51 = *((_QWORD *)this + 6);
    v51[1] = a4;
    v52 = v51 + 2;
    goto LABEL_67;
  }
  v53 = *((_QWORD *)this + 16);
  v54 = ((uint64_t)v51 - v53) >> 4;
  v55 = v54 + 1;
  if ((unint64_t)(v54 + 1) >> 60)
LABEL_68:
    abort();
  v56 = v50 - v53;
  if (v56 >> 3 > v55)
    v55 = v56 >> 3;
  if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0)
    v57 = 0xFFFFFFFFFFFFFFFLL;
  else
    v57 = v55;
  v58 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>((uint64_t)this + 144, v57);
  v59 = &v58[16 * v54];
  v61 = &v58[16 * v60];
  *(_QWORD *)v59 = *((_QWORD *)this + 6);
  *((_QWORD *)v59 + 1) = a4;
  v52 = v59 + 16;
  v63 = (char *)*((_QWORD *)this + 16);
  v62 = (char *)*((_QWORD *)this + 17);
  if (v62 != v63)
  {
    do
    {
      *((_OWORD *)v59 - 1) = *((_OWORD *)v62 - 1);
      v59 -= 16;
      v62 -= 16;
    }
    while (v62 != v63);
    v62 = (char *)*((_QWORD *)this + 16);
  }
  *((_QWORD *)this + 16) = v59;
  *((_QWORD *)this + 17) = v52;
  *((_QWORD *)this + 18) = v61;
  if (v62)
    operator delete(v62);
LABEL_67:
  *((_QWORD *)this + 17) = v52;
}

void OpenTypeReorderingOutput::forEachUnwrittenIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3;
  uint64_t v4;
  void **v7;
  uint64_t v8;
  void *v9;
  void **v10;
  void **v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  void **v18;
  char *v19;
  uint64_t v20;
  void **v21;
  void ***i;
  uint64_t v23;
  void **v24[5];
  void **v25;
  void **v26;
  void **v27;
  _OWORD v28[15];
  _OWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[14] = v3;
  v28[13] = v3;
  v28[12] = v3;
  v28[11] = v3;
  v28[10] = v3;
  v28[9] = v3;
  v28[8] = v3;
  v28[7] = v3;
  v28[6] = v3;
  v28[5] = v3;
  v28[4] = v3;
  v28[3] = v3;
  v28[2] = v3;
  v28[1] = v3;
  v28[0] = v3;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  v29 = v28;
  v4 = a2 - *(_QWORD *)(a1 + 24);
  if (v4 >= 1)
  {
    v7 = 0;
    v8 = 0;
    while (1)
    {
      if (((*(_DWORD *)(a1 + 32) >> v8) & 1) == 0)
      {
        v9 = (void *)(*(_QWORD *)(a1 + 24) + v8);
        if (v7 >= v27)
        {
          v11 = v25;
          v12 = v7 - v25;
          v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61)
            goto LABEL_29;
          v14 = (char *)v27 - (char *)v25;
          if (((char *)v27 - (char *)v25) >> 2 > v13)
            v13 = v14 >> 2;
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
            v15 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v15 = v13;
          v24[4] = (void **)v28;
          if (v15)
          {
            v16 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v28, v15);
            v11 = v25;
            v7 = v26;
          }
          else
          {
            v16 = 0;
          }
          v17 = &v16[8 * v12];
          *(_QWORD *)v17 = v9;
          if (v7 == v11)
          {
            v19 = &v16[8 * v12];
          }
          else
          {
            v18 = v7;
            v19 = &v16[8 * v12];
            do
            {
              v20 = (uint64_t)*--v18;
              *((_QWORD *)v19 - 1) = v20;
              v19 -= 8;
            }
            while (v18 != v11);
          }
          v10 = (void **)(v17 + 8);
          v25 = (void **)v19;
          v26 = (void **)(v17 + 8);
          v21 = v27;
          v27 = (void **)&v16[8 * v15];
          v24[2] = v7;
          v24[3] = v21;
          v24[0] = v11;
          v24[1] = v11;
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v24);
          v7 = v10;
        }
        else
        {
          *v7++ = v9;
          v10 = v7;
        }
        v26 = v10;
      }
      if (++v8 == v4)
      {
        for (i = (void ***)v25; ; ++i)
        {
          if (i == (void ***)v7)
            goto LABEL_27;
          v24[0] = *i;
          v23 = *(_QWORD *)(a3 + 24);
          if (!v23)
            break;
          (*(void (**)(uint64_t, void ***))(*(_QWORD *)v23 + 48))(v23, v24);
        }
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_29:
        abort();
      }
    }
  }
LABEL_27:
  v24[0] = (void **)&v25;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](v24);
}

void IndicShapingEngine::~IndicShapingEngine(IndicShapingEngine *this)
{
  void **v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)this = off_1E15DDA68;
  v2 = (void **)((char *)this + 520);
  v4 = (void **)((char *)this + 808);
  std::vector<PostGSUBFixups::Adjustment,TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  v4 = v2;
  std::vector<PostGSUBFixups::FixupData,TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  v3 = *((_QWORD *)this + 63);
  *((_QWORD *)this + 63) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  OpenTypeShapingEngine::~OpenTypeShapingEngine(this);
}

{
  void **v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)this = off_1E15DDA68;
  v2 = (void **)((char *)this + 520);
  v4 = (void **)((char *)this + 808);
  std::vector<PostGSUBFixups::Adjustment,TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  v4 = v2;
  std::vector<PostGSUBFixups::FixupData,TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  v3 = *((_QWORD *)this + 63);
  *((_QWORD *)this + 63) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  OpenTypeShapingEngine::~OpenTypeShapingEngine(this);
  MEMORY[0x186DC03AC]();
}

void std::vector<PostGSUBFixups::Adjustment,TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v3;
  BOOL v4;
  BOOL v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    v3 = v1 + 9;
    if (v1 + 3 <= v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[9])
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<PostGSUBFixups::FixupData,TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v3;
  BOOL v4;
  BOOL v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    v3 = v1 + 35;
    if (v1 + 3 <= v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[35])
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::__function::__func<IndicShapingEngine::SetV1Features(unsigned int *)::$_1,std::allocator<IndicShapingEngine::SetV1Features(unsigned int *)::$_1>,void ()(long)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<IndicShapingEngine::SetV1Features(unsigned int *)::$_1,std::allocator<IndicShapingEngine::SetV1Features(unsigned int *)::$_1>,void ()(long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E15E03B8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<IndicShapingEngine::SetV1Features(unsigned int *)::$_1,std::allocator<IndicShapingEngine::SetV1Features(unsigned int *)::$_1>,void ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15E03B8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<IndicShapingEngine::SetV1Features(unsigned int *)::$_1,std::allocator<IndicShapingEngine::SetV1Features(unsigned int *)::$_1>,void ()(long)>::operator()(uint64_t a1, uint64_t *a2)
{
  OpenTypeReorderingOutput::writeChar(**(OpenTypeReorderingOutput ***)(a1 + 8), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32) + 4 * *a2), *a2, (const unsigned int *)"tkunnhkafrkrferpfwlbftsputavtcjcserpsvbaswlbstspnlah", *(_DWORD *)(***(_QWORD ***)(a1 + 24) + 16 * *a2 + 8), 0);
}

void std::__function::__func<IndicShapingEngine::SetV2Features(unsigned int *)::$_4,std::allocator<IndicShapingEngine::SetV2Features(unsigned int *)::$_4>,void ()(long)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<IndicShapingEngine::SetV2Features(unsigned int *)::$_4,std::allocator<IndicShapingEngine::SetV2Features(unsigned int *)::$_4>,void ()(long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E15E0400;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<IndicShapingEngine::SetV2Features(unsigned int *)::$_4,std::allocator<IndicShapingEngine::SetV2Features(unsigned int *)::$_4>,void ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15E0400;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<IndicShapingEngine::SetV2Features(unsigned int *)::$_4,std::allocator<IndicShapingEngine::SetV2Features(unsigned int *)::$_4>,void ()(long)>::operator()(uint64_t a1, uint64_t *a2)
{
  OpenTypeReorderingOutput::writeChar(**(OpenTypeReorderingOutput ***)(a1 + 8), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32) + 4 * *a2), *a2, **(const unsigned int ***)(a1 + 24), *(_DWORD *)(***(_QWORD ***)(a1 + 32) + 16 * *a2 + 8), 0);
}

void IndicClassTable::IndicClassTable(IndicClassTable *this, const IndicClassTable *a2, const __CTFont *a3, OTL::GSUB *a4)
{
  uint64_t v4;
  int v5;
  int v6;
  __CTFont *v7;
  __CTFont *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t *v14;
  __int32 *v15;
  __int32 *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  void *v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  const void *v26;
  unint64_t *v27;
  unint64_t v28;
  __int128 v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  size_t v34;
  unint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  unint64_t v39;
  TBaseFont *v40;
  __int128 v41;
  char *v42;
  char *v43;
  OTL::GSUB *v44;
  unint64_t v45;
  uint64_t v46;
  int v47;
  const unsigned __int16 (*v48)[2];
  __int16 v49;
  unsigned int *v50;
  unsigned int *i;
  unsigned int v52;
  char *v53;
  void ***v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  __int16 v60;
  const unsigned __int16 (*v61)[2];
  int v62;
  int v63;
  uint64_t v65;
  unint64_t v66;
  __CTFont *v67;
  int v68;
  unint64_t v69;
  int v70;
  int v71;
  BOOL v72;
  TBaseFont *v73;
  OTL::GSUB *v74;
  _BYTE v75[14];
  id v76[3];
  _BYTE v77[3120];
  _BYTE *v78;
  void **__dst[82];
  CGSize v80;
  __int128 v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD *v86;
  _OWORD v87[9];
  __int128 v88;
  uint64_t v89;

  v4 = MEMORY[0x1E0C80A78](this, a2);
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v11 = v4;
  v89 = *MEMORY[0x1E0C80C00];
  v12 = *(_DWORD *)(v9 + 12);
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(v9 + 8);
  *(_DWORD *)(v4 + 12) = v12;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)v4 = &off_1E15DD7D8;
  *(_WORD *)(v4 + 24) = *(_WORD *)(v9 + 24);
  v13 = v4 + 24;
  *(_QWORD *)(v4 + 32) = *(_QWORD *)(v9 + 32);
  *(_DWORD *)(v4 + 40) = *(_DWORD *)(v9 + 40);
  *(_QWORD *)(v4 + 48) = v9;
  *(_QWORD *)(v4 + 56) = *(_QWORD *)(v9 + 56);
  *(_QWORD *)(v4 + 64) = 0;
  v14 = (unint64_t *)(v4 + 64);
  *(_QWORD *)(v4 + 72) = 0;
  v74 = (OTL::GSUB *)v15;
  v16 = wmemchr((__int32 *)"gnebavedrjugurugadnkmylmayrolmatulet", v15[18], 9uLL);
  v17 = "";
  if (v16)
    v17 = (char *)v16;
  v18 = v17 - "gnebavedrjugurugadnkmylmayrolmatulet";
  if (v18 == 36)
    goto LABEL_4;
  v19 = v18 >> 2;
  v20 = *((_QWORD *)v8 + 5);
  TBaseFont::RetainedObject(*(os_unfair_lock_s **)(v20 + 400), 3, (const void *)(v18 >> 2), v76);
  do
    v21 = __ldaxr((unint64_t *)v76);
  while (__stlxr(0, (unint64_t *)v76));
  v71 = v6;
  do
    v22 = (void *)__ldaxr(v14);
  while (__stlxr(v21, v14));

  v23 = atomic_load(v14);
  if (!v23)
  {
    v24 = objc_opt_new();
    do
      v25 = (void *)__ldaxr(v14);
    while (__stlxr(v24, v14));

    v23 = atomic_load(v14);
    if (!v23)
    {
LABEL_4:
      *(_QWORD *)(v11 + 16) = *(_QWORD *)(v10 + 16);
      return;
    }
    v26 = (const void *)atomic_load(v14);
    TBaseFont::SetObject(*(os_unfair_lock_s **)(v20 + 400), 3, (const void *)v19, v26);
  }
  v27 = (unint64_t *)(v23 + 8 * v19 + 8);
  v28 = atomic_load(v27);
  *(_QWORD *)(v11 + 16) = v28;
  if (!v28)
  {
    v67 = v8;
    *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v87[8] = v29;
    v88 = v29;
    v87[6] = v29;
    v87[7] = v29;
    v87[4] = v29;
    v87[5] = v29;
    v87[2] = v29;
    v87[3] = v29;
    LODWORD(v82) = 1819239276;
    v87[0] = v29;
    v87[1] = v29;
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)v76, &v82, (_DWORD *)&v82 + 1);
    OTL::GCommon::GetLookups((uint64_t)v74, (uint64_t)v76, (uint64_t)v87);
    __dst[0] = v76;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](__dst);
    v30 = *(unsigned __int16 *)(v10 + 10) - (unint64_t)*(unsigned __int16 *)(v10 + 8);
    v31 = v30 + 1;
    v72 = v30 == -1;
    if ((v30 + 1) >> 62)
      v32 = -1;
    else
      v32 = 4 * v31;
    v33 = (void *)operator new[]();
    v34 = v32;
    v35 = v30;
    bzero(v33, v34);
    v36 = 0;
    v37 = ((*(_DWORD *)(v10 + 12) & 0x2000) << 17) ^ 0x40000000;
    if ((*(_DWORD *)(v10 + 12) & 0x2000) != 0)
      v38 = v71;
    else
      v38 = 1;
    v70 = v38;
    if (v71)
      v37 = 0x40000000;
    v68 = v37;
    v39 = (unint64_t)&v82;
    v86 = v85;
    v40 = *(TBaseFont **)(*((_QWORD *)v74 + 2) + 400);
    *(_QWORD *)&v41 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v85[3] = v41;
    v85[2] = v41;
    v85[1] = v41;
    v85[0] = v41;
    v83 = 0;
    v84 = 0;
    v82 = 0;
    if (!v72)
    {
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v82, v31);
      v42 = v83;
      bzero(v83, 2 * v35 + 2);
      v43 = &v42[2 * v31];
      v39 = (unint64_t)&v82;
      v83 = v43;
      v36 = v82;
    }
    (*(void (**)(TBaseFont *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v40 + 672))(v40, *(unsigned __int16 *)(v10 + 8), v31, v36);
    *(_WORD *)&v75[4] = 0;
    v73 = v40;
    (*(void (**)(TBaseFont *, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)v40 + 664))(v40, v13, &v75[4], 1);
    v44 = v74;
    if ((v35 & 0x8000000000000000) == 0)
    {
      v45 = v35;
      v46 = 0;
      v69 = v35;
      while (1)
      {
        v47 = *(_DWORD *)(*(_QWORD *)(v10 + 16) + 4 * v46);
        if (v47 < 0)
        {
          if (*(_WORD *)(v82 + 2 * v46))
            break;
        }
        *((_DWORD *)v33 + v46) = v47;
LABEL_60:
        if (v46++ == v45)
          goto LABEL_62;
      }
      *(_DWORD *)v75 = -1431655766;
      v48 = (const unsigned __int16 (*)[2])*(unsigned __int16 *)(v82 + 2 * v46);
      *(_WORD *)v75 = *(_WORD *)(v82 + 2 * v46);
      v49 = *(_WORD *)&v75[4];
      *(_WORD *)&v75[2] = *(_WORD *)&v75[4];
      if (!BYTE8(v88))
      {
LABEL_45:
        v56 = v47 & (v68 ^ 0xE3FFFFFF);
        if (v70)
        {
          v57 = hasForm(v73, v44, v48, v49, 1919969382);
          v58 = v68;
          if (!v57)
            v58 = 0;
          v56 |= v58;
          v48 = (const unsigned __int16 (*)[2])*(unsigned __int16 *)v75;
          v49 = *(_WORD *)&v75[2];
        }
        if ((v71 & 1) == 0)
        {
          v59 = hasForm(v73, v44, v48, v49, 1751215206);
          v60 = *(_WORD *)v75;
          v61 = (const unsigned __int16 (*)[2])*(unsigned __int16 *)&v75[2];
          if (v59)
            v56 |= 0x2000000u;
          *(_WORD *)v75 = *(_WORD *)&v75[2];
          *(_WORD *)&v75[2] = v60;
          if ((hasForm(v73, v44, v61, v60, 1886545254) & 1) != 0)
          {
            v62 = v56 | 0x4000000;
LABEL_59:
            v45 = v69;
            *((_DWORD *)v33 + v46) = v62;
            goto LABEL_60;
          }
          v48 = (const unsigned __int16 (*)[2])*(unsigned __int16 *)v75;
          v49 = *(_WORD *)&v75[2];
        }
        if (hasForm(v73, v44, v48, v49, 1651275622))
        {
          v62 = v56 | 0x10000000;
        }
        else
        {
          v63 = hasForm(v73, v44, (const unsigned __int16 (*)[2])*(unsigned __int16 *)v75, *(__int16 *)&v75[2], 1886614630);
          v62 = v56 | 0x8000000;
          if (!v63)
            v62 = v56;
        }
        goto LABEL_59;
      }
      v81 = 0u;
      v80 = (CGSize)0;
      memcpy(__dst, &unk_184950A98, sizeof(__dst));
      TRunGlue::TRunGlue((TRunGlue *)__dst, v67, (unsigned __int16 *)v75, &v80, 2, 0, 0, 0);
      memset(v77, 170, sizeof(v77));
      memset(v76, 0, sizeof(v76));
      v78 = v77;
      v50 = (unsigned int *)*((_QWORD *)&v87[0] + 1);
      for (i = *(unsigned int **)&v87[0]; i != v50; ++i)
      {
        v52 = *i;
        v39 = v39 & 0xFFFFFFFF00000000 | v52;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v76, v39, 0, 2);
      }
      v75[6] = 0;
      v44 = v74;
      if (OTL::GSUB::ApplyLookups(v74, (TRunGlue *)__dst, 1, (unsigned __int16 **)v76, &v75[6], 0, 0)
        && v75[6])
      {
        if (__dst[19])
        {
          TRunGlue::FocusOnIndex((TRunGlue *)__dst, 0);
          v53 = (char *)__dst[22] - 2 * (uint64_t)__dst[20];
        }
        else
        {
          v53 = (char *)__dst[22] + 2 * (uint64_t)__dst[20];
        }
        *(_WORD *)v75 = *(_WORD *)v53;
        *(_WORD *)&v75[2] = TRunGlue::GetGlyphID((TRunGlue *)__dst, 1);
      }
      *(_QWORD *)&v75[6] = v76;
      std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v75[6]);
      v54 = (void ***)__dst[73];
      if ((void ***)__dst[73] == &__dst[70])
      {
        v54 = &__dst[70];
        v55 = 4;
        v39 = (unint64_t)&v82;
      }
      else
      {
        v39 = (unint64_t)&v82;
        if (!__dst[73])
        {
LABEL_44:
          v76[0] = &__dst[46];
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v76);
          v76[0] = &__dst[26];
          std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v76);
          v76[0] = &__dst[7];
          std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v76);
          v48 = (const unsigned __int16 (*)[2])*(unsigned __int16 *)v75;
          v49 = *(_WORD *)&v75[2];
          goto LABEL_45;
        }
        v55 = 5;
      }
      ((void (*)(void))(*v54)[v55])();
      goto LABEL_44;
    }
LABEL_62:
    v65 = *(_QWORD *)(v11 + 16);
    while (1)
    {
      v66 = __ldaxr(v27);
      if (v66 != v65)
        break;
      if (!__stlxr((unint64_t)v33, v27))
      {
        *(_QWORD *)(v11 + 16) = v33;
        v76[0] = &v82;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v76);
        goto LABEL_67;
      }
    }
    __clrex();
    *(_QWORD *)(v11 + 16) = v66;
    v76[0] = &v82;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v76);
    MEMORY[0x186DC0394](v33, 0x1000C8052888210);
LABEL_67:
    if (BYTE8(v88))
    {
      v76[0] = v87;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v76);
    }
  }
}

uint64_t hasForm(const TBaseFont *a1, OTL::GSUB *a2, const unsigned __int16 (*a3)[2], __int16 a4, int a5)
{
  __int128 v7;
  _BOOL4 Lookups;
  uint64_t v9;
  unsigned __int16 *v10;
  uint64_t *v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t (**v20)(_QWORD *, _QWORD);
  uint64_t *v21;
  char v22;
  uint64_t (*v23)(_QWORD *, _QWORD);
  _QWORD *v24;
  unsigned int v25;
  uint64_t v26;
  ChainContextSubstFormat1 *v27;
  unint64_t v28;
  const TBaseFont *v30;
  os_unfair_lock_s *lock;
  char v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  uint64_t v35;
  int v36;
  int v37;
  char **v38;
  char *v39[34];
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  uint64_t v42;
  _OWORD v43[7];
  unint64_t v44;
  _OWORD *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  LOWORD(v37) = (_WORD)a3;
  HIWORD(v37) = a4;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v43[6] = v7;
  v43[5] = v7;
  v43[4] = v7;
  v43[3] = v7;
  v43[2] = v7;
  v43[1] = v7;
  v43[0] = v7;
  v44 = 0xAAAAAAAAAAAAAAAALL;
  v45 = v43;
  v41 = 0;
  v42 = 0;
  v40 = 0;
  v36 = a5;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(v39, &v36, &v37);
  Lookups = OTL::GCommon::GetLookups((uint64_t)a2, (uint64_t)v39, (uint64_t)&v40, 0);
  v38 = v39;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v38);
  v9 = 0;
  if (Lookups)
  {
    lock = (os_unfair_lock_s *)((char *)a1 + 356);
    os_unfair_lock_lock_with_options();
    v32 = 0;
    v30 = a1;
    while (1)
    {
      v10 = v40;
      v33 = v41;
      if (v40 != v41)
      {
        do
        {
          v34 = v10;
          v11 = TBaseFont::NthLookup<OTL::GSUB>((uint64_t)a1, a2, *v10);
          if (v11)
          {
            v12 = v11;
            v35 = (unsigned __int16)(-21845 * ((*((_DWORD *)v11 + 24) - *((_DWORD *)v11 + 22)) >> 4));
            if (-21845 * (unsigned __int16)((*((_DWORD *)v11 + 24) - *((_DWORD *)v11 + 22)) >> 4))
            {
              v13 = 0;
              while (2)
              {
                v14 = v12[11];
                v15 = 0xAAAAAAAAAAAAAAABLL * ((v12[12] - v14) >> 4);
                v16 = v15 <= v13 ? 0 : v14 + 48 * v13 + 8;
                if (v15 > v13)
                {
                  v17 = 0;
                  v18 = 0;
                  v19 = v14 + 48 * v13;
                  v20 = (uint64_t (**)(_QWORD *, _QWORD))(v19 + 24);
                  v21 = (uint64_t *)(v19 + 32);
                  do
                  {
                    v22 = v17;
                    v23 = *v20;
                    v24 = (_QWORD *)(v16 + (*v21 >> 1));
                    if ((*v21 & 1) != 0)
                      v23 = *(uint64_t (**)(_QWORD *, _QWORD))(*v24 + v23);
                    v25 = v23(v24, *((unsigned __int16 *)&v37 + v18));
                    if (v25)
                    {
                      v26 = v12[11];
                      v27 = 0xAAAAAAAAAAAAAAABLL * ((v12[12] - v26) >> 4) <= v13
                          ? 0
                          : *(ChainContextSubstFormat1 **)(v26 + 48 * v13);
                      if ((OTL::GSUB::WouldSubstituteSubtable(a2, (int)v12, *((unsigned __int16 *)v12 + 8), v27, v25, (unsigned __int16 *)&v37 + v18, 2 - (int)v18) & 1) != 0)
                      {
                        v9 = 1;
                        goto LABEL_25;
                      }
                    }
                    v17 = 1;
                    v18 = 1;
                  }
                  while ((v22 & 1) == 0);
                  if (++v13 != v35)
                    continue;
                }
                break;
              }
            }
          }
          v10 = v34 + 2;
          a1 = v30;
        }
        while (v34 + 2 != v33);
      }
      if ((v32 & 1) != 0)
        break;
      HIDWORD(v28) = v37;
      LODWORD(v28) = v37;
      v37 = v28 >> 16;
      v32 = 1;
    }
    v9 = 0;
LABEL_25:
    os_unfair_lock_unlock(lock);
  }
  v39[0] = (char *)&v40;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v39);
  return v9;
}

void IndicClassTable::~IndicClassTable(id *this)
{
  *this = &off_1E15DD7D8;

}

{
  *this = &off_1E15DD7D8;

  JUMPOUT(0x186DC03ACLL);
}

uint64_t IndicClassTable::getCharClass(IndicClassTable *this, int a2)
{
  uint64_t result;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  char v10;
  uint64_t v11;
  uint64_t v12;

  switch(a2)
  {
    case 160:
      return 2147483663;
    case 8204:
      return 9;
    case 8205:
      return 2147483656;
  }
  v4 = *((unsigned __int16 *)this + 4);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (!v5
    || *((unsigned __int16 *)this + 5) < a2
    || (result = *(unsigned int *)(*((_QWORD *)this + 2) + 4 * v6), !(_DWORD)result))
  {
    v7 = *((_QWORD *)this + 7);
    if (v7)
    {
      v8 = *((unsigned __int16 *)this + 20);
      v5 = a2 >= v8;
      v9 = a2 - v8;
      if (v5 && *((unsigned __int16 *)this + 21) >= a2)
        return *(unsigned int *)(v7 + 4 * v9);
    }
    result = 2147483651;
    if (a2 > 8209)
    {
      if (a2 > 9675)
      {
        if (a2 > 70400)
        {
          if ((a2 - 70459) < 2)
            return 5;
          if (a2 != 70401)
          {
            if (a2 == 70403)
              return 1048588;
            return 0;
          }
          return 3145729;
        }
        if ((a2 - 9676) > 0x32)
          return 0;
        v11 = 1 << (a2 + 52);
        v12 = 0x7800000000001;
        goto LABEL_43;
      }
      if ((a2 - 8304) > 0x19 || ((1 << (a2 - 112)) & 0x3FF03F1) == 0)
      {
        if ((a2 - 8210) > 0x10 || ((1 << (a2 - 18)) & 0x1000F) == 0)
        {
          if (a2 == 8432)
            return 3145740;
          return 0;
        }
        return result;
      }
    }
    else
    {
      v10 = a2 + 48;
      if ((a2 - 7376) <= 0x27)
      {
        if (((1 << v10) & 0x9021FFFFF7) != 0)
          return 13;
        if (((1 << v10) & 0x1E000000) != 0)
          return 14;
        if (((1 << v10) & 0x6000000000) != 0)
          return 2147483652;
      }
      if ((a2 - 160) > 0x37)
        return 0;
      if (((1 << (a2 + 96)) & 0x20C0000) == 0)
      {
        v11 = 1 << (a2 + 96);
        v12 = 0x80000000000001;
LABEL_43:
        if ((v11 & v12) == 0)
          return 0;
        return result;
      }
    }
    return 10;
  }
  return result;
}

uint64_t IndicClassTable::getReorderClassInternal(IndicClassTable *this)
{
  return 0;
}

double IndicReorderingOutput::reset(IndicReorderingOutput *this, uint64_t a2)
{
  double result;

  ++*((_QWORD *)this + 6);
  *((_QWORD *)this + 3) = a2;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 55) = *((_QWORD *)this + 54);
  *((_QWORD *)this + 122) = -1;
  *((_QWORD *)this + 123) = -1;
  *((_QWORD *)this + 133) = 0;
  *((_WORD *)this + 528) = 0;
  *((_WORD *)this + 524) = 0;
  *((_QWORD *)this + 129) = -1;
  *((_QWORD *)this + 134) = -1;
  *((_WORD *)this + 504) = 0;
  *((_WORD *)this + 500) = 0;
  *((_QWORD *)this + 130) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 1016) = 0u;
  return result;
}

int64x2_t *IndicReorderingOutput::saveMatra(int64x2_t *this, const IndicClassTable *a2, uint64_t a3, uint64_t a4, int a5, const unsigned int *a6, uint64_t a7)
{
  int v11;
  int64x2_t *v12;
  int v13;
  int v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  int64x2_t v32;
  uint64_t v33;
  uint64_t v34;
  int64x2_t v35;
  uint64_t v36;
  uint64_t *v37;

  v11 = a3;
  v12 = this;
  switch(((a5 & 0x700000u) - 0x100000) >> 20)
  {
    case 0u:
      if ((a5 & 0x700000) == 0x100000)
      {
        v13 = *((_DWORD *)a2 + 3) & 0x30000;
        if (v13 == 0x10000)
        {
          v14 = 4;
        }
        else if (v13 == 0x20000)
        {
          v14 = 3;
        }
        else
        {
          this = (int64x2_t *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 16))(*((_QWORD *)a2 + 6), a3);
          v14 = (int)this;
        }
      }
      else
      {
        v14 = 0;
      }
      v15 = 9;
      break;
    case 1u:
      v14 = 0;
      v15 = 8;
      break;
    case 2u:
      v14 = 0;
      v15 = 6;
      break;
    case 3u:
      v14 = 0;
      v15 = 5;
      break;
    default:
      v15 = 0;
      v14 = 0;
      break;
  }
  v16 = v12[27].u64[1];
  v17 = v12[28].u64[0];
  if (v16 >= v17)
  {
    v19 = v12[27].i64[0];
    v20 = (uint64_t)(v16 - v19) >> 6;
    v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 58)
      abort();
    v22 = v17 - v19;
    if (v22 >> 5 > v21)
      v21 = v22 >> 5;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFC0)
      v23 = 0x3FFFFFFFFFFFFFFLL;
    else
      v23 = v21;
    v37 = &v12[28].i64[1];
    if (v23)
      v24 = TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>::allocate((uint64_t)&v12[28].i64[1], v23);
    else
      v24 = 0;
    v25 = &v24[64 * v20];
    *v25 = v15;
    *((_DWORD *)v25 + 1) = v14;
    *((_DWORD *)v25 + 2) = v11;
    *((_QWORD *)v25 + 2) = a4;
    *((_QWORD *)v25 + 3) = a7;
    *((_QWORD *)v25 + 4) = a6;
    *((_DWORD *)v25 + 10) = a5;
    *((_QWORD *)v25 + 6) = -1;
    *((_QWORD *)v25 + 7) = -1;
    v26 = v12[27].i64[0];
    v27 = v12[27].u64[1];
    if (v27 == v26)
    {
      v32 = vdupq_n_s64(v27);
      v28 = &v24[64 * v20];
    }
    else
    {
      v28 = &v24[64 * v20];
      do
      {
        v29 = *(_OWORD *)(v27 - 64);
        v30 = *(_OWORD *)(v27 - 48);
        v31 = *(_OWORD *)(v27 - 16);
        *((_OWORD *)v28 - 2) = *(_OWORD *)(v27 - 32);
        *((_OWORD *)v28 - 1) = v31;
        *((_OWORD *)v28 - 4) = v29;
        *((_OWORD *)v28 - 3) = v30;
        v28 -= 64;
        v27 -= 64;
      }
      while (v27 != v26);
      v32 = v12[27];
    }
    v18 = v25 + 64;
    v12[27].i64[0] = (uint64_t)v28;
    v12[27].i64[1] = (uint64_t)(v25 + 64);
    v35 = v32;
    v33 = v12[28].i64[0];
    v12[28].i64[0] = (uint64_t)&v24[64 * v23];
    v36 = v33;
    v34 = v32.i64[0];
    this = (int64x2_t *)std::__split_buffer<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul> &>::~__split_buffer((uint64_t)&v34);
  }
  else
  {
    *(_BYTE *)v16 = v15;
    *(_DWORD *)(v16 + 4) = v14;
    *(_DWORD *)(v16 + 8) = v11;
    *(_QWORD *)(v16 + 16) = a4;
    *(_QWORD *)(v16 + 24) = a7;
    *(_QWORD *)(v16 + 32) = a6;
    *(_DWORD *)(v16 + 40) = a5;
    v18 = (char *)(v16 + 64);
    *(_QWORD *)(v16 + 48) = -1;
    *(_QWORD *)(v16 + 56) = -1;
  }
  v12[27].i64[1] = (uint64_t)v18;
  return this;
}

uint64_t IndicReorderingOutput::noteMatra(int64x2_t *this, const IndicClassTable *a2, int a3, uint64_t a4, const unsigned int *a5)
{
  unint64_t CharClass;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  int64x2_t v52;
  uint64_t v53;
  uint64_t v54;
  int64x2_t v55;
  uint64_t v56;
  __int8 *v57;

  CharClass = IndicClassTable::getCharClass(a2, a3);
  v11 = CharClass;
  if ((unsigned __int16)CharClass == 5)
  {
    v25 = this[27].u64[1];
    v28 = this[28].u64[0];
    if (v25 < v28)
    {
      v27 = 11;
      goto LABEL_23;
    }
    v37 = this[27].i64[0];
    v38 = (uint64_t)(v25 - v37) >> 6;
    v39 = v38 + 1;
    if (!((unint64_t)(v38 + 1) >> 58))
    {
      v40 = v28 - v37;
      if (v40 >> 5 > v39)
        v39 = v40 >> 5;
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFC0)
        v35 = 0x3FFFFFFFFFFFFFFLL;
      else
        v35 = v39;
      v57 = &this[28].i8[8];
      if (v35)
        v36 = TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>::allocate((uint64_t)&this[28].i64[1], v35);
      else
        v36 = 0;
      v41 = &v36[64 * v38];
      *v41 = 11;
      *((_DWORD *)v41 + 1) = 0;
      *((_DWORD *)v41 + 2) = a3;
      *((_QWORD *)v41 + 2) = a4;
      *((_QWORD *)v41 + 3) = 0;
      *((_QWORD *)v41 + 4) = a5;
      *((_DWORD *)v41 + 10) = v11;
      *((_QWORD *)v41 + 6) = -1;
      *((_QWORD *)v41 + 7) = -1;
      v48 = this[27].i64[0];
      v43 = this[27].u64[1];
      if (v43 != v48)
      {
        v44 = &v36[64 * v38];
        do
        {
          v49 = *(_OWORD *)(v43 - 64);
          v50 = *(_OWORD *)(v43 - 48);
          v51 = *(_OWORD *)(v43 - 16);
          *((_OWORD *)v44 - 2) = *(_OWORD *)(v43 - 32);
          *((_OWORD *)v44 - 1) = v51;
          *((_OWORD *)v44 - 4) = v49;
          *((_OWORD *)v44 - 3) = v50;
          v44 -= 64;
          v43 -= 64;
        }
        while (v43 != v48);
        goto LABEL_51;
      }
LABEL_52:
      v52 = vdupq_n_s64(v43);
      v44 = v41;
      goto LABEL_53;
    }
LABEL_57:
    abort();
  }
  if ((unsigned __int16)CharClass == 10)
  {
    v25 = this[27].u64[1];
    v26 = this[28].u64[0];
    if (v25 < v26)
    {
      v27 = 1;
LABEL_23:
      *(_BYTE *)v25 = v27;
      *(_DWORD *)(v25 + 4) = 0;
      *(_DWORD *)(v25 + 8) = a3;
      *(_QWORD *)(v25 + 16) = a4;
      *(_QWORD *)(v25 + 24) = 0;
      *(_QWORD *)(v25 + 32) = a5;
      *(_DWORD *)(v25 + 40) = CharClass;
      v29 = v25 + 64;
      *(_QWORD *)(v25 + 48) = -1;
      *(_QWORD *)(v25 + 56) = -1;
LABEL_54:
      this[27].i64[1] = v29;
      return 1;
    }
    v31 = this[27].i64[0];
    v32 = (uint64_t)(v25 - v31) >> 6;
    v33 = v32 + 1;
    if (!((unint64_t)(v32 + 1) >> 58))
    {
      v34 = v26 - v31;
      if (v34 >> 5 > v33)
        v33 = v34 >> 5;
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFC0)
        v35 = 0x3FFFFFFFFFFFFFFLL;
      else
        v35 = v33;
      v57 = &this[28].i8[8];
      if (v35)
        v36 = TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>::allocate((uint64_t)&this[28].i64[1], v35);
      else
        v36 = 0;
      v41 = &v36[64 * v32];
      *v41 = 1;
      *((_DWORD *)v41 + 1) = 0;
      *((_DWORD *)v41 + 2) = a3;
      *((_QWORD *)v41 + 2) = a4;
      *((_QWORD *)v41 + 3) = 0;
      *((_QWORD *)v41 + 4) = a5;
      *((_DWORD *)v41 + 10) = v11;
      *((_QWORD *)v41 + 6) = -1;
      *((_QWORD *)v41 + 7) = -1;
      v42 = this[27].i64[0];
      v43 = this[27].u64[1];
      if (v43 != v42)
      {
        v44 = &v36[64 * v32];
        do
        {
          v45 = *(_OWORD *)(v43 - 64);
          v46 = *(_OWORD *)(v43 - 48);
          v47 = *(_OWORD *)(v43 - 16);
          *((_OWORD *)v44 - 2) = *(_OWORD *)(v43 - 32);
          *((_OWORD *)v44 - 1) = v47;
          *((_OWORD *)v44 - 4) = v45;
          *((_OWORD *)v44 - 3) = v46;
          v44 -= 64;
          v43 -= 64;
        }
        while (v43 != v42);
LABEL_51:
        v52 = this[27];
LABEL_53:
        v29 = (uint64_t)(v41 + 64);
        this[27].i64[0] = (uint64_t)v44;
        this[27].i64[1] = (uint64_t)(v41 + 64);
        v55 = v52;
        v53 = this[28].i64[0];
        this[28].i64[0] = (uint64_t)&v36[64 * v35];
        v56 = v53;
        v54 = v52.i64[0];
        std::__split_buffer<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul> &>::~__split_buffer((uint64_t)&v54);
        goto LABEL_54;
      }
      goto LABEL_52;
    }
    goto LABEL_57;
  }
  if ((unsigned __int16)CharClass != 6)
    return 0;
  if ((CharClass & 0xF0000) != 0)
  {
    v12 = 0;
    v13 = *((_QWORD *)a2 + 4);
    v14 = v13 + 6 * ((CharClass >> 16) & 0xF);
    v15 = -6;
    do
    {
      v16 = v12;
      v17 = *(unsigned __int16 *)(v14 + v15);
      if (*(_WORD *)(v14 + v15))
        ++v12;
      v15 += 2;
    }
    while (v15);
    if (v12)
    {
      v18 = 0;
      if (v17)
        v19 = v16 + 1;
      else
        v19 = v16;
      v20 = -v19;
      v21 = v13 + 6 * ((CharClass >> 16) & 0xF) + 2 * v19 - 8;
      do
      {
        v22 = *(unsigned __int16 *)(v21 + 2 * v18);
        v23 = IndicClassTable::getCharClass(a2, *(unsigned __int16 *)(v21 + 2 * v18));
        if (v18)
          v24 = 0x8000000000000000;
        else
          v24 = 0x4000000000000000;
        IndicReorderingOutput::saveMatra(this, a2, v22, a4, v23, a5, v24);
        --v18;
      }
      while (v20 != v18);
    }
  }
  else
  {
    IndicReorderingOutput::saveMatra(this, a2, (unsigned __int16)a3, a4, CharClass, a5, 0);
  }
  return 1;
}

uint64_t IndicReorderingOutput::assignReorderClasses(uint64_t this, const IndicClassTable *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *i;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  v2 = *(unsigned __int8 **)(this + 432);
  for (i = *(unsigned __int8 **)(this + 440); v2 != i; v2 += 64)
  {
    if (!*((_DWORD *)v2 + 1))
    {
      v4 = *v2;
      if ((v4 - 6) >= 2)
      {
        if (v4 != 8)
          continue;
        v8 = *((_DWORD *)a2 + 3) & 0xC0000;
        switch(v8)
        {
          case 262144:
            v7 = 4;
            break;
          case 786432:
            v7 = 2;
            break;
          case 524288:
            v7 = 3;
            break;
          default:
            continue;
        }
      }
      else
      {
        v5 = *((_DWORD *)a2 + 3) & 0x300000;
        if (v5 == 0x200000)
          v6 = 2;
        else
          v6 = 4;
        if (v5 == 3145728)
          v6 = 1;
        if (v5 == 0x100000)
          v7 = 3;
        else
          v7 = v6;
      }
      *((_DWORD *)v2 + 1) = v7;
    }
  }
  return this;
}

uint64_t IndicReorderingOutput::finishMatras(IndicReorderingOutput *this, uint64_t a2, int a3)
{
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  BOOL v8;
  unsigned __int8 *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v26;
  unsigned __int8 *v27;
  int v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  unsigned __int8 *i;
  unsigned int v35;
  int v36;
  uint64_t v39;
  __int16 v40;
  char v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v6 = (unsigned __int8 *)*((_QWORD *)this + 54);
  v5 = (unsigned __int8 *)*((_QWORD *)this + 55);
  v7 = v5 - 64;
  v8 = v6 != v5 && v7 > v6;
  if (v8)
  {
    v9 = v6 + 64;
    do
    {
      v11 = *((_OWORD *)v9 - 2);
      v10 = *((_OWORD *)v9 - 1);
      v13 = *((_OWORD *)v9 - 4);
      v12 = *((_OWORD *)v9 - 3);
      v14 = *((_OWORD *)v7 + 3);
      v16 = *(_OWORD *)v7;
      v15 = *((_OWORD *)v7 + 1);
      *((_OWORD *)v9 - 2) = *((_OWORD *)v7 + 2);
      *((_OWORD *)v9 - 1) = v14;
      *((_OWORD *)v9 - 4) = v16;
      *((_OWORD *)v9 - 3) = v15;
      *(_OWORD *)v7 = v13;
      *((_OWORD *)v7 + 1) = v12;
      *((_OWORD *)v7 + 2) = v11;
      *((_OWORD *)v7 + 3) = v10;
      v7 -= 64;
      v17 = v9 >= v7;
      v9 += 64;
    }
    while (!v17);
    v6 = (unsigned __int8 *)*((_QWORD *)this + 54);
    v5 = (unsigned __int8 *)*((_QWORD *)this + 55);
  }
  v18 = a3 ^ 1u;
  v39 = v18;
  v41 = 0;
  v40 = 0;
  if (v6 != v5)
  {
    v19 = v6;
    while ((IndicReorderingOutput::DuplicateMarkFinder::operator()(&v39, *v19) & 1) == 0)
    {
      v19 += 64;
      if (v19 == v5)
        goto LABEL_36;
    }
    if (v19 != v5)
    {
      if (*v19 == 9)
      {
        v20 = v19 + 64;
        while (2)
        {
          v21 = v20;
          do
          {
            if (v21 == v5)
            {
              v39 = v18;
              v41 = 0;
              v40 = 0;
              while ((IndicReorderingOutput::DuplicateMarkFinder::operator()(&v39, *v19) & 1) == 0)
              {
                v19 += 64;
                if (v19 == v5)
                  goto LABEL_30;
              }
              goto LABEL_31;
            }
            v22 = *(v21 - 64);
            v24 = *v21;
            v21 += 64;
            v23 = v24;
          }
          while (v22 != 9 || v23 != 9);
          v19 += 64;
          v20 += 64;
          if (v19 != v5)
            continue;
          break;
        }
LABEL_30:
        v19 = v5;
      }
LABEL_31:
      if (v19 != v5 && *v19 <= 9u)
      {
        a2 = *((_QWORD *)v19 + 2);
        do
        {
          v5 -= 64;
          *((_QWORD *)this + 55) = v5;
        }
        while (*((_QWORD *)v5 - 6) >= a2);
        v6 = (unsigned __int8 *)*((_QWORD *)this + 54);
      }
    }
LABEL_36:
    if (v6 != v5)
    {
      v26 = 0;
      v27 = v6;
      do
      {
        v28 = *v27;
        if (v28 == 1)
        {
          v29 = v6;
          if (v6 != v27)
          {
            v30 = v26;
            v29 = v6;
            while (1)
            {
              v31 = *v29;
              v8 = v31 > 9;
              v32 = (1 << v31) & 0x360;
              if (!v8 && v32 != 0)
                break;
              v29 += 64;
              v30 -= 64;
              if (!v30)
              {
                v29 = v27;
                break;
              }
            }
          }
          for (i = v27 + 64; i != v5; i += 64)
          {
            v35 = *i;
            v8 = v35 > 9;
            v36 = (1 << v35) & 0x360;
            if (!v8 && v36 != 0)
            {
              if (v29 != v27 && i != v5)
              {
                a2 = *((_QWORD *)i + 2);
                do
                {
                  v5 -= 64;
                  *((_QWORD *)this + 55) = v5;
                }
                while (*((_QWORD *)v5 - 6) >= a2);
                return a2;
              }
              break;
            }
          }
        }
        else if (v28 == 11)
        {
          if (v27 == v6)
          {
            *v6 = 0;
          }
          else
          {
            *v27 = *(v27 - 64);
            *((_DWORD *)v27 + 1) = *((_DWORD *)v27 - 15);
          }
        }
        v27 += 64;
        v26 += 64;
      }
      while (v27 != v5);
    }
  }
  return a2;
}

uint64_t IndicReorderingOutput::noteVowelModifier(int64x2_t *this, const IndicClassTable *a2, int a3, uint64_t a4, const unsigned int *a5)
{
  uint64_t result;
  int v10;
  int v11;
  char v12;
  char v13;
  char v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  int64x2_t v31;
  uint64_t v32;
  uint64_t v33;
  int64x2_t v34;
  uint64_t v35;
  __int8 *v36;

  result = IndicClassTable::getCharClass(a2, a3);
  if ((unsigned __int16)result == 1)
  {
    v10 = result;
    v11 = result & 0x700000;
    if ((result & 0x700000) == 0x200000)
      v12 = 3;
    else
      v12 = 0;
    if (v11 == 3145728)
      v13 = 2;
    else
      v13 = v12;
    if (v11 == 0x100000)
      v14 = 4;
    else
      v14 = v13;
    v15 = this[27].u64[1];
    v16 = this[28].u64[0];
    if (v15 >= v16)
    {
      v18 = this[27].i64[0];
      v19 = (uint64_t)(v15 - v18) >> 6;
      v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 58)
        abort();
      v21 = v16 - v18;
      if (v21 >> 5 > v20)
        v20 = v21 >> 5;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFC0)
        v22 = 0x3FFFFFFFFFFFFFFLL;
      else
        v22 = v20;
      v36 = &this[28].i8[8];
      if (v22)
        v23 = TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>::allocate((uint64_t)&this[28].i64[1], v22);
      else
        v23 = 0;
      v24 = &v23[64 * v19];
      *v24 = v14;
      *((_DWORD *)v24 + 1) = 0;
      *((_DWORD *)v24 + 2) = a3;
      *((_QWORD *)v24 + 2) = a4;
      *((_QWORD *)v24 + 3) = 0;
      *((_QWORD *)v24 + 4) = a5;
      *((_DWORD *)v24 + 10) = v10;
      *((_QWORD *)v24 + 6) = -1;
      *((_QWORD *)v24 + 7) = -1;
      v25 = this[27].i64[0];
      v26 = this[27].u64[1];
      if (v26 == v25)
      {
        v31 = vdupq_n_s64(v26);
        v27 = &v23[64 * v19];
      }
      else
      {
        v27 = &v23[64 * v19];
        do
        {
          v28 = *(_OWORD *)(v26 - 64);
          v29 = *(_OWORD *)(v26 - 48);
          v30 = *(_OWORD *)(v26 - 16);
          *((_OWORD *)v27 - 2) = *(_OWORD *)(v26 - 32);
          *((_OWORD *)v27 - 1) = v30;
          *((_OWORD *)v27 - 4) = v28;
          *((_OWORD *)v27 - 3) = v29;
          v27 -= 64;
          v26 -= 64;
        }
        while (v26 != v25);
        v31 = this[27];
      }
      v17 = v24 + 64;
      this[27].i64[0] = (uint64_t)v27;
      this[27].i64[1] = (uint64_t)(v24 + 64);
      v34 = v31;
      v32 = this[28].i64[0];
      this[28].i64[0] = (uint64_t)&v23[64 * v22];
      v35 = v32;
      v33 = v31.i64[0];
      result = std::__split_buffer<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul> &>::~__split_buffer((uint64_t)&v33);
    }
    else
    {
      *(_BYTE *)v15 = v14;
      *(_DWORD *)(v15 + 4) = 0;
      *(_DWORD *)(v15 + 8) = a3;
      *(_QWORD *)(v15 + 16) = a4;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = a5;
      *(_DWORD *)(v15 + 40) = result;
      v17 = (char *)(v15 + 64);
      *(_QWORD *)(v15 + 48) = -1;
      *(_QWORD *)(v15 + 56) = -1;
    }
    this[27].i64[1] = (uint64_t)v17;
  }
  return result;
}

uint64_t IndicReorderingOutput::noteSyllableModifier(int64x2_t *this, const IndicClassTable *a2, int a3, uint64_t a4, const unsigned int *a5)
{
  uint64_t result;
  int v10;
  char v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  int64x2_t v29;
  uint64_t v30;
  uint64_t v31;
  int64x2_t v32;
  uint64_t v33;
  __int8 *v34;

  result = IndicClassTable::getCharClass(a2, a3);
  if ((result & 0xFFFE) == 0xC)
  {
    v10 = result;
    if ((result & 0x700000) == 0x300000)
      v11 = 7;
    else
      v11 = 0;
    if (a3 == 2817)
      v12 = 2;
    else
      v12 = 5;
    v13 = this[27].u64[1];
    v14 = this[28].u64[0];
    if (v13 >= v14)
    {
      v16 = this[27].i64[0];
      v17 = (uint64_t)(v13 - v16) >> 6;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 58)
        abort();
      v19 = v14 - v16;
      if (v19 >> 5 > v18)
        v18 = v19 >> 5;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFC0)
        v20 = 0x3FFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      v34 = &this[28].i8[8];
      if (v20)
        v21 = TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>::allocate((uint64_t)&this[28].i64[1], v20);
      else
        v21 = 0;
      v22 = &v21[64 * v17];
      *v22 = v11;
      *((_DWORD *)v22 + 1) = v12;
      *((_DWORD *)v22 + 2) = a3;
      *((_QWORD *)v22 + 2) = a4;
      *((_QWORD *)v22 + 3) = 0;
      *((_QWORD *)v22 + 4) = a5;
      *((_DWORD *)v22 + 10) = v10;
      *((_QWORD *)v22 + 6) = -1;
      *((_QWORD *)v22 + 7) = -1;
      v23 = this[27].i64[0];
      v24 = this[27].u64[1];
      if (v24 == v23)
      {
        v29 = vdupq_n_s64(v24);
        v25 = &v21[64 * v17];
      }
      else
      {
        v25 = &v21[64 * v17];
        do
        {
          v26 = *(_OWORD *)(v24 - 64);
          v27 = *(_OWORD *)(v24 - 48);
          v28 = *(_OWORD *)(v24 - 16);
          *((_OWORD *)v25 - 2) = *(_OWORD *)(v24 - 32);
          *((_OWORD *)v25 - 1) = v28;
          *((_OWORD *)v25 - 4) = v26;
          *((_OWORD *)v25 - 3) = v27;
          v25 -= 64;
          v24 -= 64;
        }
        while (v24 != v23);
        v29 = this[27];
      }
      v15 = v22 + 64;
      this[27].i64[0] = (uint64_t)v25;
      this[27].i64[1] = (uint64_t)(v22 + 64);
      v32 = v29;
      v30 = this[28].i64[0];
      this[28].i64[0] = (uint64_t)&v21[64 * v20];
      v33 = v30;
      v31 = v29.i64[0];
      result = std::__split_buffer<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul> &>::~__split_buffer((uint64_t)&v31);
    }
    else
    {
      *(_BYTE *)v13 = v11;
      *(_DWORD *)(v13 + 4) = v12;
      *(_DWORD *)(v13 + 8) = a3;
      *(_QWORD *)(v13 + 16) = a4;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = a5;
      *(_DWORD *)(v13 + 40) = result;
      v15 = (char *)(v13 + 64);
      *(_QWORD *)(v13 + 48) = -1;
      *(_QWORD *)(v13 + 56) = -1;
    }
    this[27].i64[1] = (uint64_t)v15;
  }
  return result;
}

char **IndicReorderingOutput::noteBaseConsonant(char **this, int a2)
{
  char **v2;
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  char *v6[3];

  v2 = this;
  v3 = (this[8] - this[7]) >> 2;
  this[122] = (char *)v3;
  if (a2)
  {
    v4 = (unsigned __int8 *)this[54];
    v5 = (unsigned __int8 *)this[55];
    LOBYTE(v6[0]) = 5;
    *(_WORD *)((char *)v6 + 1) = -21846;
    BYTE3(v6[0]) = -86;
    HIDWORD(v6[0]) = 0;
    v6[1] = (char *)v3;
    v6[2] = (char *)this;
    while (v4 != v5)
    {
      this = IndicReorderingOutput::TargetNoter::operator()(v6, v4);
      v4 += 64;
    }
  }
  else
  {
    this = IndicReorderingOutput::noteMpreTarget(this);
    if (*((_WORD *)v2 + 500))
      v2[129] = (char *)((v2[8] - v2[7]) >> 2);
  }
  return this;
}

char **IndicReorderingOutput::noteMpreTarget(char **this)
{
  uint64_t v1;
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  char *v4[3];

  v1 = (this[8] - this[7]) >> 2;
  v2 = (unsigned __int8 *)this[54];
  v3 = (unsigned __int8 *)this[55];
  LOBYTE(v4[0]) = 5;
  *(_WORD *)((char *)v4 + 1) = -21846;
  BYTE3(v4[0]) = -86;
  HIDWORD(v4[0]) = 0;
  v4[1] = (char *)v1;
  v4[2] = (char *)this;
  while (v2 != v3)
  {
    this = IndicReorderingOutput::TargetNoter::operator()(v4, v2);
    v2 += 64;
  }
  return this;
}

char **IndicReorderingOutput::writeRephFixup(char **this)
{
  uint64_t v1;
  uint64_t v2;

  if (*((_WORD *)this + 524))
  {
    v1 = (uint64_t)this[134];
    if ((v1 & 0x8000000000000000) == 0)
    {
      if (*((_WORD *)this + 529))
        v2 = 3;
      else
        v2 = 2;
      return PostGSUBFixups::add((char **)this[124], v1, (uint64_t)this[123], v2, 0);
    }
  }
  return this;
}

uint64_t IndicReorderingOutput::MarkWriter::operator()(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4;
  BOOL v5;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *((_DWORD *)a1 + 1);
  if (*a1)
  {
    if (v4)
      v5 = 0;
    else
      v5 = *a2 == *a1;
    if (!v5 || *((_DWORD *)a2 + 1) != 0)
      return 0;
  }
  else
  {
    if (v4)
      v8 = *((_DWORD *)a2 + 1) == v4;
    else
      v8 = 0;
    if (!v8)
      return 0;
  }
  v9 = *((_QWORD *)a2 + 7);
  v10 = *((_QWORD *)a1 + 1);
  v11 = (uint64_t)(*(_QWORD *)(v10 + 64) - *(_QWORD *)(v10 + 56)) >> 2;
  if (v9 < 0)
  {
    *((_QWORD *)a2 + 6) = v11;
  }
  else
  {
    PostGSUBFixups::add(*(char ***)(v10 + 992), v9, v11, 1, 0);
    v10 = *((_QWORD *)a1 + 1);
  }
  OpenTypeReorderingOutput::writeChar((OpenTypeReorderingOutput *)v10, *((_DWORD *)a2 + 2), *((_QWORD *)a2 + 2), *((const unsigned int **)a2 + 4), *((_DWORD *)a2 + 10), *((_QWORD *)a2 + 3));
  return 1;
}

uint64_t IndicReorderingOutput::writeMpre(IndicReorderingOutput *this)
{
  unsigned __int8 *v1;
  unsigned __int8 *v2;
  int v3;
  _QWORD v5[2];

  v5[0] = 2863311365;
  v5[1] = this;
  v1 = (unsigned __int8 *)*((_QWORD *)this + 54);
  v2 = (unsigned __int8 *)*((_QWORD *)this + 55);
  if (v1 == v2)
  {
    LOBYTE(v3) = 0;
  }
  else
  {
    v3 = 0;
    do
    {
      v3 |= IndicReorderingOutput::MarkWriter::operator()((unsigned __int8 *)v5, v1);
      v1 += 64;
    }
    while (v1 != v2);
  }
  return v3 & 1;
}

uint64_t IndicReorderingOutput::writeMabove(unsigned __int8 **this)
{
  std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(this[54], this[55], 6, (uint64_t)this);
  return std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(this[54], this[55], 7, (uint64_t)this);
}

uint64_t std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v5;
  _QWORD v7[2];

  v7[0] = a3;
  v7[1] = a4;
  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      IndicReorderingOutput::MarkWriter::operator()((unsigned __int8 *)v7, v5);
      v5 += 64;
    }
    while (v5 != a2);
    return v7[0];
  }
  return a3;
}

uint64_t IndicReorderingOutput::writeMpost(unsigned __int8 **this)
{
  std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(this[54], this[55], 0x200000000, (uint64_t)this);
  std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(this[54], this[55], 0x300000000, (uint64_t)this);
  return std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(this[54], this[55], 0x400000000, (uint64_t)this);
}

uint64_t IndicReorderingOutput::writeVMpost(unsigned __int8 **this)
{
  std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(this[54], this[55], 2863311364, (uint64_t)this);
  return std::for_each[abi:nn180100]<std::__wrap_iter<IndicReorderingOutput::MarkInfo *>,IndicReorderingOutput::MarkWriter>(this[54], this[55], 0x500000000, (uint64_t)this);
}

void IndicReorderingOutput::writePreBaseConsonant(IndicReorderingOutput *this)
{
  int v1;
  uint64_t v3;
  int v4;
  uint64_t v5;
  const unsigned int *v6;
  int v7;
  uint64_t v8;
  OpenTypeReorderingOutput *v9;

  v1 = *((unsigned __int16 *)this + 500);
  if (*((_WORD *)this + 500))
  {
    v3 = *((_QWORD *)this + 129);
    if (v3 < 0)
    {
      if ((*((_QWORD *)this + 122) & 0x8000000000000000) == 0)
      {
        PostGSUBFixups::add(*((char ***)this + 124), *((_QWORD *)this + 122), (uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 2, 2, 0x20000000);
        v1 = *((unsigned __int16 *)this + 500);
      }
      OpenTypeReorderingOutput::writeChar(this, v1, *((_QWORD *)this + 127), *((const unsigned int **)this + 130), *((_DWORD *)this + 251), *((_QWORD *)this + 128));
      v4 = *((unsigned __int16 *)this + 504);
      v5 = *((_QWORD *)this + 127) - 1;
      v6 = (const unsigned int *)*((_QWORD *)this + 130);
      v9 = this;
      v7 = 7;
      v8 = 0;
    }
    else
    {
      PostGSUBFixups::add(*((char ***)this + 124), v3, (uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 2, 2, 0x10000000);
      OpenTypeReorderingOutput::writeChar(this, *((unsigned __int16 *)this + 504), *((_QWORD *)this + 127) - 1, *((const unsigned int **)this + 130), 7, 0);
      v4 = *((unsigned __int16 *)this + 500);
      v5 = *((_QWORD *)this + 127);
      v6 = (const unsigned int *)*((_QWORD *)this + 130);
      v7 = *((_DWORD *)this + 251);
      v8 = *((_QWORD *)this + 128);
      v9 = this;
    }
    OpenTypeReorderingOutput::writeChar(v9, v4, v5, v6, v7, v8);
  }
}

void IndicReorderingOutput::writeReph(IndicReorderingOutput *this)
{
  int v1;

  v1 = *((unsigned __int16 *)this + 524);
  if (*((_WORD *)this + 524))
  {
    *((_QWORD *)this + 123) = (uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 2;
    OpenTypeReorderingOutput::writeChar(this, v1, *((_QWORD *)this + 133), *((const unsigned int **)this + 135), *((_DWORD *)this + 263), 0);
    OpenTypeReorderingOutput::writeChar(this, *((unsigned __int16 *)this + 528), *((_QWORD *)this + 133) + 1, *((const unsigned int **)this + 135), 7, 0);
    if (*((_WORD *)this + 529))
      OpenTypeReorderingOutput::writeChar(this, *((unsigned __int16 *)this + 529), *((_QWORD *)this + 133) + 2, *((const unsigned int **)this + 135), *((_DWORD *)this + 265), 0);
  }
}

void IndicReorderingOutput::~IndicReorderingOutput(IndicReorderingOutput *this)
{
  *(_QWORD *)this = &off_1E15DDE80;
  std::vector<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)this + 432);
  OpenTypeReorderingOutput::~OpenTypeReorderingOutput(this);
}

{
  *(_QWORD *)this = &off_1E15DDE80;
  std::vector<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)this + 432);
  OpenTypeReorderingOutput::~OpenTypeReorderingOutput(this);
  JUMPOUT(0x186DC03ACLL);
}

char *TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>::allocate(uint64_t a1, unint64_t a2)
{
  char *v2;
  char *result;
  char *v4;

  v2 = (char *)(a1 + 512);
  result = *(char **)(a1 + 512);
  v4 = &result[64 * a2];
  if (v4 <= v2)
  {
    *(_QWORD *)v2 = v4;
  }
  else
  {
    if (a2 >> 58)
      std::__throw_bad_array_new_length[abi:nn180100]();
    return (char *)operator new(a2 << 6);
  }
  return result;
}

uint64_t std::__split_buffer<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 63) & 0xFFFFFFFFFFFFFFC0);
  v4 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = (_QWORD *)(v5 + 512);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(_QWORD *)(a1 + 24) == *v6)
        *v6 = v4;
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t IndicReorderingOutput::DuplicateMarkFinder::operator()(_BYTE *a1, unsigned __int8 a2)
{
  uint64_t v2;
  _BYTE *v3;
  _BYTE *v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  BOOL v10;

  v2 = 0;
  if (a2 && a2 != 11)
  {
    if (*a1 && (a2 - 5) < 5u && ((0x1Bu >> (a2 - 5)) & 1) != 0)
      return 0;
    v3 = &a1[a2];
    v5 = v3[1];
    v4 = v3 + 1;
    if (!v5)
    {
      if (a2 > 9u || ((1 << a2) & 0x360) == 0 || a2 > 8u)
      {
LABEL_18:
        v2 = 0;
        *v4 = 1;
        return v2;
      }
      v6 = a2 + 2;
      while (1)
      {
        v7 = (v6 - 1);
        v8 = v7 > 9;
        v9 = (1 << v7) & 0x360;
        v10 = v8 || v9 == 0;
        if (!v10 && a1[v6])
          break;
        if (++v6 == 11)
          goto LABEL_18;
      }
    }
    return 1;
  }
  return v2;
}

char **IndicReorderingOutput::TargetNoter::operator()(char **result, unsigned __int8 *a2)
{
  int v2;
  BOOL v3;
  BOOL v5;
  uint64_t v6;

  v2 = *((_DWORD *)result + 1);
  if (*(_BYTE *)result)
  {
    if (v2)
      v3 = 0;
    else
      v3 = *a2 == *(unsigned __int8 *)result;
    if (!v3 || *((_DWORD *)a2 + 1) != 0)
      return result;
LABEL_15:
    v6 = *((_QWORD *)a2 + 6);
    if ((v6 & 0x8000000000000000) == 0)
      return PostGSUBFixups::add(*((char ***)result[2] + 124), (uint64_t)result[1], v6, 1, 0);
    *((_QWORD *)a2 + 7) = result[1];
    return result;
  }
  if (v2)
    v5 = *((_DWORD *)a2 + 1) == v2;
  else
    v5 = 0;
  if (v5)
    goto LABEL_15;
  return result;
}

void std::vector<IndicReorderingOutput::MarkInfo,TInlineBufferAllocator<IndicReorderingOutput::MarkInfo,8ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  BOOL v4;
  BOOL v5;

  v2 = *(_QWORD **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    v3 = (_QWORD *)(a1 + 536);
    if (a1 + 24 <= (unint64_t)v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 536))
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t *DevanagariShapingEngine::GetStaticClassTable(DevanagariShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    qword_1EDD175A8 = 0x111A0FFF097F0900;
    unk_1EDD175B0 = &devaCharClasses;
    DevanagariShapingEngine::GetStaticClassTable(void)::devaClassTable = (uint64_t)&off_1E15DD7D8;
    word_1EDD175B8 = 2381;
    qword_1EDD175C0 = 0;
    dword_1EDD175C8 = -1459640096;
    qword_1EDD175D0 = (uint64_t)&DevanagariShapingEngine::GetStaticClassTable(void)::devaClassTable;
    unk_1EDD175D8 = &devaExtendedCharClasses;
    qword_1EDD175E0 = 0;
    unk_1EDD175E8 = 0;
    byte_1EDD175F0 = 1;
  }
  return &DevanagariShapingEngine::GetStaticClassTable(void)::devaClassTable;
}

void DevanagariShapingEngine::~DevanagariShapingEngine(DevanagariShapingEngine *this)
{
  void **v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)this = off_1E15DDA68;
  v2 = (void **)((char *)this + 520);
  v4 = (void **)((char *)this + 808);
  std::vector<PostGSUBFixups::Adjustment,TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  v4 = v2;
  std::vector<PostGSUBFixups::FixupData,TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  v3 = *((_QWORD *)this + 63);
  *((_QWORD *)this + 63) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  OpenTypeShapingEngine::~OpenTypeShapingEngine(this);
}

{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t *GujaratiShapingEngine::GetStaticClassTable(GujaratiShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    qword_1EDD174B8 = 0x1150FFF0AFF0A80;
    unk_1EDD174C0 = &gujrCharClasses;
    GujaratiShapingEngine::GetStaticClassTable(void)::gujrClassTable = (uint64_t)&off_1E15DD7D8;
    word_1EDD174C8 = 2765;
    qword_1EDD174D0 = 0;
    dword_1EDD174D8 = 0;
    qword_1EDD174E0 = (uint64_t)&GujaratiShapingEngine::GetStaticClassTable(void)::gujrClassTable;
    unk_1EDD174E8 = 0;
    qword_1EDD174F0 = 0;
    unk_1EDD174F8 = 0;
    byte_1EDD17500 = 1;
  }
  return &GujaratiShapingEngine::GetStaticClassTable(void)::gujrClassTable;
}

void GujaratiShapingEngine::~GujaratiShapingEngine(GujaratiShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t *GurmukhiShapingEngine::GetStaticClassTable(GurmukhiShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    qword_1EDD17308 = 0x43050FFF0A760A00;
    unk_1EDD17310 = &guruCharClasses;
    GurmukhiShapingEngine::GetStaticClassTable(void)::guruClassTable = (uint64_t)&off_1E15DD7D8;
    word_1EDD17318 = 2637;
    qword_1EDD17320 = 0;
    dword_1EDD17328 = 0;
    qword_1EDD17330 = (uint64_t)&GurmukhiShapingEngine::GetStaticClassTable(void)::guruClassTable;
    unk_1EDD17338 = 0;
    qword_1EDD17340 = 0;
    unk_1EDD17348 = 0;
    byte_1EDD17350 = 1;
  }
  return &GurmukhiShapingEngine::GetStaticClassTable(void)::guruClassTable;
}

void GurmukhiShapingEngine::~GurmukhiShapingEngine(GurmukhiShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t *BengaliShapingEngine::GetStaticClassTable(BengaliShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    qword_1EDD17548 = 0x22090FFF09FF0980;
    unk_1EDD17550 = &bengCharClasses;
    BengaliShapingEngine::GetStaticClassTable(void)::bengClassTable = (uint64_t)&off_1E15DD7D8;
    word_1EDD17558 = 2509;
    qword_1EDD17560 = (uint64_t)&bengSplitTable;
    dword_1EDD17568 = 0;
    qword_1EDD17570 = (uint64_t)&BengaliShapingEngine::GetStaticClassTable(void)::bengClassTable;
    unk_1EDD17578 = 0;
    qword_1EDD17580 = 0;
    unk_1EDD17588 = 0;
    byte_1EDD17590 = 1;
  }
  return &BengaliShapingEngine::GetStaticClassTable(void)::bengClassTable;
}

void BengaliShapingEngine::~BengaliShapingEngine(BengaliShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t KannadaClassTable::getReorderClassInternal(KannadaClassTable *this, int a2)
{
  int v2;

  if ((a2 - 3262) > 0x18)
    return 0;
  v2 = 1 << (a2 + 66);
  if ((v2 & 0x1800060) != 0)
    return 3;
  if ((v2 & 0x19) != 0)
    return 2;
  else
    return 0;
}

uint64_t *KannadaShapingEngine::GetStaticClassTable(KannadaShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    word_1EDD17400 = 3277;
    qword_1EDD17408 = (uint64_t)&kndaSplitTable;
    dword_1EDD17410 = 0;
    qword_1EDD17418 = (uint64_t)&KannadaShapingEngine::GetStaticClassTable(void)::kndaClassTable;
    unk_1EDD17420 = 0;
    qword_1EDD17428 = 0;
    unk_1EDD17430 = 0;
    byte_1EDD17438 = 1;
    qword_1EDD173F0 = 0x842B10030CF20C80;
    unk_1EDD173F8 = &kndaCharClasses;
    KannadaShapingEngine::GetStaticClassTable(void)::kndaClassTable = (uint64_t)&off_1E15DD9C0;
  }
  return &KannadaShapingEngine::GetStaticClassTable(void)::kndaClassTable;
}

void KannadaShapingEngine::~KannadaShapingEngine(KannadaShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

void KannadaClassTable::~KannadaClassTable(id *this)
{
  *this = &off_1E15DD7D8;

}

{
  *this = &off_1E15DD7D8;

  JUMPOUT(0x186DC03ACLL);
}

uint64_t *OriyaShapingEngine::GetStaticClassTable(OriyaShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    qword_1EDD172A0 = 0x23390FFF0B770B00;
    unk_1EDD172A8 = &oryaCharClasses;
    OriyaShapingEngine::GetStaticClassTable(void)::oryaClassTable = (uint64_t)&off_1E15DD7D8;
    word_1EDD172B0 = 2893;
    qword_1EDD172B8 = (uint64_t)"G\vV\v";
    dword_1EDD172C0 = 0;
    qword_1EDD172C8 = (uint64_t)&OriyaShapingEngine::GetStaticClassTable(void)::oryaClassTable;
    unk_1EDD172D0 = 0;
    qword_1EDD172D8 = 0;
    unk_1EDD172E0 = 0;
    byte_1EDD172E8 = 1;
  }
  return &OriyaShapingEngine::GetStaticClassTable(void)::oryaClassTable;
}

void OriyaShapingEngine::~OriyaShapingEngine(OriyaShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t TeluguClassTable::getReorderClassInternal(TeluguClassTable *this, int a2)
{
  int v2;

  if ((a2 - 3137) > 0x15)
    return 0;
  v2 = 1 << (a2 - 65);
  if ((v2 & 0x200003) != 0)
    return 2;
  if ((v2 & 0xC) != 0)
    return 3;
  else
    return 0;
}

uint64_t *TeluguShapingEngine::GetStaticClassTable(TeluguShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    word_1EDD173A8 = 3149;
    qword_1EDD173B0 = (uint64_t)&teluSplitTable;
    dword_1EDD173B8 = 0;
    qword_1EDD173C0 = (uint64_t)&TeluguShapingEngine::GetStaticClassTable(void)::teluClassTable;
    unk_1EDD173C8 = 0;
    qword_1EDD173D0 = 0;
    unk_1EDD173D8 = 0;
    byte_1EDD173E0 = 1;
    qword_1EDD17398 = 0x802B30030C7F0C00;
    unk_1EDD173A0 = &teluCharClasses;
    TeluguShapingEngine::GetStaticClassTable(void)::teluClassTable = (uint64_t)&off_1E15DD998;
  }
  return &TeluguShapingEngine::GetStaticClassTable(void)::teluClassTable;
}

void TeluguShapingEngine::~TeluguShapingEngine(TeluguShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

void TeluguClassTable::~TeluguClassTable(id *this)
{
  *this = &off_1E15DD7D8;

}

{
  *this = &off_1E15DD7D8;

  JUMPOUT(0x186DC03ACLL);
}

uint64_t *MalayalamShapingEngine::GetStaticClassTable(MalayalamShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    qword_1EDD176F0 = 0x4B094FFF0D7F0D00;
    unk_1EDD176F8 = &mlymCharClasses;
    MalayalamShapingEngine::GetStaticClassTable(void)::mlymClassTable = (uint64_t)&off_1E15DD7D8;
    word_1EDD17700 = 3405;
    qword_1EDD17708 = (uint64_t)"F\r>\r";
    dword_1EDD17710 = 0;
    qword_1EDD17718 = (uint64_t)&MalayalamShapingEngine::GetStaticClassTable(void)::mlymClassTable;
    unk_1EDD17720 = 0;
    qword_1EDD17728 = 0;
    unk_1EDD17730 = 0;
    byte_1EDD17738 = 1;
  }
  return &MalayalamShapingEngine::GetStaticClassTable(void)::mlymClassTable;
}

void MalayalamShapingEngine::~MalayalamShapingEngine(MalayalamShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t *TamilShapingEngine::GetStaticClassTable(TamilShapingEngine *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    qword_1EDD17460 = 0x8154FFF0BFA0B80;
    unk_1EDD17468 = &tamlCharClasses;
    TamilShapingEngine::GetStaticClassTable(void)::tamlClassTable = (uint64_t)&off_1E15DD7D8;
    word_1EDD17470 = 3021;
    qword_1EDD17478 = (uint64_t)&tamlSplitTable;
    dword_1EDD17480 = 0;
    qword_1EDD17488 = (uint64_t)&TamilShapingEngine::GetStaticClassTable(void)::tamlClassTable;
    unk_1EDD17490 = 0;
    qword_1EDD17498 = 0;
    unk_1EDD174A0 = 0;
    byte_1EDD174A8 = 1;
  }
  return &TamilShapingEngine::GetStaticClassTable(void)::tamlClassTable;
}

void TamilShapingEngine::~TamilShapingEngine(TamilShapingEngine *this)
{
  DevanagariShapingEngine::~DevanagariShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

void *__CTEmojiImageSourceCopyImageStrikes(CGImageSource *a1)
{
  size_t v2;
  uint64_t v3;
  uint64_t v4;
  double *v5;
  CGImage *ImageAtIndex;
  CFDictionaryRef v7;
  void *v8;
  double v9;
  double v10;
  void *v11;
  void *v12;
  double v13;
  void *v14;
  double v15;
  CTEmojiImageStrike *v16;
  uint64_t v18;
  size_t Count;
  void *v20;

  Count = CGImageSourceGetCount(a1);
  v20 = (void *)objc_opt_new();
  if (Count)
  {
    v2 = 0;
    v18 = *MEMORY[0x1E0CBD090];
    v3 = *MEMORY[0x1E0CBD0F0];
    v4 = *MEMORY[0x1E0CBD100];
    v5 = (double *)MEMORY[0x1E0C9D820];
    do
    {
      ImageAtIndex = CGImageSourceCreateImageAtIndex(a1, v2, 0);
      v7 = CGImageSourceCopyPropertiesAtIndex(a1, v2, 0);
      -[__CFDictionary objectForKeyedSubscript:](v7, "objectForKeyedSubscript:", v18);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      v9 = *v5;
      v10 = v5[1];
      objc_msgSend(v8, "objectForKeyedSubscript:", v3);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v12 = v11;
      if (v11)
      {
        objc_msgSend(v11, "doubleValue");
        v9 = v13;
      }
      objc_msgSend(v8, "objectForKeyedSubscript:", v4);
      v14 = (void *)objc_claimAutoreleasedReturnValue();

      if (v14)
      {
        objc_msgSend(v14, "doubleValue");
        v10 = v15;
      }
      v16 = -[CTEmojiImageStrike initWithImage:alignmentInset:]([CTEmojiImageStrike alloc], "initWithImage:alignmentInset:", ImageAtIndex, v9, v10);
      objc_msgSend(v20, "addObject:", v16);
      CGImageRelease(ImageAtIndex);

      ++v2;
    }
    while (Count != v2);
  }
  return v20;
}

uint64_t __CTEmojiImageSourceGetImageIndex(CGImageSource *a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  size_t Count;
  size_t v13;
  size_t v14;
  uint64_t v15;
  const __CFDictionary *v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  CFDictionaryRef v21;
  void *v22;
  void *v23;
  double v24;
  double v25;
  uint64_t v26;
  const __CFDictionary *v27;
  double v28;
  void *v29;
  double v30;
  double v31;
  void *v32;
  void *v33;
  double v34;
  void *v35;
  double v36;
  void *v37;
  __int128 v39;
  _QWORD v40[2];
  const __CFString *v41;
  _QWORD v42[2];

  v42[1] = *MEMORY[0x1E0C80C00];
  Count = CGImageSourceGetCount(a1);
  if (!Count)
  {
    v16 = 0;
    goto LABEL_29;
  }
  v13 = Count;
  *(_QWORD *)&v39 = a2;
  *((_QWORD *)&v39 + 1) = a3;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = ceil(a5 * a6);
  v18 = *MEMORY[0x1E0CBD040];
  v19 = 0x7FFFFFFFFFFFFFFFLL;
  v20 = 0.0;
  do
  {
    v21 = CGImageSourceCopyPropertiesAtIndex(a1, v14, 0);
    -[__CFDictionary objectForKeyedSubscript:](v21, "objectForKeyedSubscript:", v18);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = v22;
    if (!v22)
      goto LABEL_14;
    objc_msgSend(v22, "doubleValue");
    v25 = v24;
    if (v24 < v17)
    {
      if (v20 == 0.0)
      {
        v26 = v15;
      }
      else
      {
        v26 = v15;
        if (v15 & 1 | (v24 <= v20))
          goto LABEL_14;
      }
LABEL_13:
      v27 = v21;

      v19 = v14;
      v16 = v27;
      v20 = v25;
      v15 = v26;
      goto LABEL_14;
    }
    v26 = 1;
    if (v20 == 0.0 || ((v15 ^ 1) & 1) != 0 || v24 < v20)
      goto LABEL_13;
LABEL_14:

    ++v14;
  }
  while (v13 != v14);
  if (v19 == 0x7FFFFFFFFFFFFFFFLL)
  {
LABEL_29:
    v19 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_30;
  }
  if (v39 != 0)
  {
    if (v20 <= a5)
      v28 = 1.0;
    else
      v28 = a5 / v20;
    if ((_QWORD)v39)
    {
      *(double *)v39 = a4;
      *(double *)(v39 + 8) = a5;
    }
    if (*((_QWORD *)&v39 + 1))
    {
      -[__CFDictionary objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", *MEMORY[0x1E0CBD090]);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      v30 = *MEMORY[0x1E0C9D538];
      v31 = *(double *)(MEMORY[0x1E0C9D538] + 8);
      objc_msgSend(v29, "objectForKeyedSubscript:", *MEMORY[0x1E0CBD0F0]);
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      v33 = v32;
      if (v32)
      {
        objc_msgSend(v32, "doubleValue");
        v30 = floor(v34 * v28 + 0.5);
      }
      objc_msgSend(v29, "objectForKeyedSubscript:", *MEMORY[0x1E0CBD100]);
      v35 = (void *)objc_claimAutoreleasedReturnValue();

      if (v35)
      {
        objc_msgSend(v35, "doubleValue");
        v31 = -floor(v36 * v28 + 0.5);
      }
      v41 = CFSTR("__NSEmojiImagePropertyKeyOrigin");
      *(double *)v40 = v30;
      *(double *)&v40[1] = v31;
      objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithBytes:objCType:", v40, "{CGPoint=dd}");
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      v42[0] = v37;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v42, &v41, 1);
      **((_QWORD **)&v39 + 1) = (id)objc_claimAutoreleasedReturnValue();

    }
  }
LABEL_30:

  return v19;
}

void TAATKernEngine::KernOrderedList::ProcessGlyphsT<TRunGlue::TGlyph>(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  TRunGlue *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t GlyphID;
  uint64_t v13;
  unsigned int v14;
  unsigned __int16 v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned __int16 *v19;
  unsigned int v20;

  if (*(_QWORD *)(a1 + 56))
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = **(TRunGlue ***)a1;
    v6 = TRunGlue::length(v5);
    if (*((_QWORD *)v5 + 19))
    {
      TRunGlue::FocusOnIndex(v5, 0);
      v7 = (unsigned __int16 *)(*((_QWORD *)v5 + 22) - 2 * *((_QWORD *)v5 + 20));
    }
    else
    {
      v7 = (unsigned __int16 *)(*((_QWORD *)v5 + 22) + 2 * *((_QWORD *)v5 + 20));
    }
    if (v6 >= 2)
    {
      v8 = v4 + 8;
      v9 = v4 + 10;
      v10 = *v7;
      for (i = 1; i != v6; ++i)
      {
        GlyphID = TRunGlue::GetGlyphID(v5, i);
        if ((_DWORD)GlyphID == 0xFFFF || (v13 = GlyphID, TRunGlue::IsDeleted(v5, i)))
        {
          v13 = v10;
          goto LABEL_10;
        }
        if (*(unsigned __int16 *)(a1 + 50) >= (unsigned __int16)v10)
        {
          if (*(_WORD *)(*(_QWORD *)(a1 + 56) + 2 * (unsigned __int16)v10))
          {
            v14 = *(unsigned __int16 *)(a1 + 48);
            if (v14 > (unsigned __int16)(*(_WORD *)(*(_QWORD *)(a1 + 56) + 2 * (unsigned __int16)v10) - 1))
            {
              v15 = *(_WORD *)(*(_QWORD *)(a1 + 56) + 2 * (unsigned __int16)v10) - 1;
              v16 = (unsigned __int16 *)(v9 + 6 * v15);
              do
              {
                v17 = bswap32(*(v16 - 1)) >> 16;
                if (v17 == (unsigned __int16)v10)
                {
                  if (v13 <= bswap32(*v16) >> 16)
                    goto LABEL_22;
                }
                else if (v17 >= (unsigned __int16)v10)
                {
LABEL_22:
                  v18 = v15;
                  v19 = (unsigned __int16 *)(v8 + 6 * v15);
                  if ((unsigned __int16)v10 == bswap32(*v19) >> 16 && (_DWORD)v13 == bswap32(v19[1]) >> 16)
                  {
                    v20 = *(unsigned __int16 *)(v8 + 6 * v18 + 4);
                    if (v20)
                    {
                      TAATKernEngine::HandleKern<TRunGlue::TGlyph>(*(_QWORD *)a1, (uint64_t)v5, i, (int)bswap32(v20) >> 16, *(_WORD *)(a1 + 24));
                      *a2 = 1;
                    }
                  }
                  break;
                }
                ++v15;
                v16 += 3;
              }
              while (v14 != v15);
            }
          }
        }
LABEL_10:
        v10 = v13;
      }
    }
  }
}

uint64_t std::vector<std::pair<long,TAATDeltaXListEntry>>::erase(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  if (a2 != a3)
  {
    v3 = *(_QWORD *)(result + 8);
    if (a3 != v3)
    {
      v4 = 16 * ((a3 - a2) >> 4);
      do
      {
        *(_QWORD *)a2 = *(_QWORD *)(a2 + v4);
        *(_WORD *)(a2 + 8) = *(_WORD *)(a2 + v4 + 8);
        a2 += 16;
      }
      while (a2 + v4 != v3);
    }
    *(_QWORD *)(result + 8) = a2;
  }
  return result;
}

void TAATKernEngine::HandleKern<TRunGlue::TGlyph>(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t i;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t *v29;

  v8 = (int)(*(double *)(a1 + 24) * (double)a4);
  if ((a5 & 0x4000) != 0)
  {
    v28 = a3;
    v29 = &v28;
    v12 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>((uint64_t **)(a1 + 56), &v28, (uint64_t)&std::piecewise_construct, &v29);
    if (v8 == -32768)
    {
      LOWORD(v8) = 0;
      *((_BYTE *)v12 + 42) = 1;
    }
    else if ((a5 & 0x800) == 0)
    {
      LOWORD(v8) = *((_WORD *)v12 + 20) + v8;
    }
    *((_WORD *)v12 + 20) = v8;
  }
  else
  {
    if ((a5 & 0x800) != 0)
    {
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(_QWORD *)(a1 + 40);
      v9 = a1 + 32;
      if (v10 != v11)
      {
        while (*(_QWORD *)v10 != a3)
        {
          v10 += 16;
          if (v10 == v11)
          {
            v10 = *(_QWORD *)(a1 + 40);
            goto LABEL_18;
          }
        }
        if (v10 != v11)
        {
          for (i = v10 + 16; i != v11; i += 16)
          {
            if (*(_QWORD *)i != a3)
            {
              *(_QWORD *)v10 = *(_QWORD *)i;
              *(_WORD *)(v10 + 8) = *(_WORD *)(i + 8);
              v10 += 16;
            }
          }
        }
      }
LABEL_18:
      std::vector<std::pair<long,TAATDeltaXListEntry>>::erase(v9, v10, v11);
    }
    v14 = *(_QWORD *)(a1 + 48);
    v15 = *(_QWORD *)(a1 + 40);
    if (v15 >= v14)
    {
      v17 = *(_QWORD *)(a1 + 32);
      v18 = (uint64_t)(v15 - v17) >> 4;
      v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 60)
        abort();
      v20 = v14 - v17;
      if (v20 >> 3 > v19)
        v19 = v20 >> 3;
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0)
        v21 = 0xFFFFFFFFFFFFFFFLL;
      else
        v21 = v19;
      v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>(a1 + 48, v21);
      v23 = &v22[16 * v18];
      v25 = &v22[16 * v24];
      *(_QWORD *)v23 = a3;
      *((_WORD *)v23 + 4) = v8;
      v16 = v23 + 16;
      v27 = *(char **)(a1 + 32);
      v26 = *(char **)(a1 + 40);
      if (v26 != v27)
      {
        do
        {
          *((_OWORD *)v23 - 1) = *((_OWORD *)v26 - 1);
          v23 -= 16;
          v26 -= 16;
        }
        while (v26 != v27);
        v26 = *(char **)(a1 + 32);
      }
      *(_QWORD *)(a1 + 32) = v23;
      *(_QWORD *)(a1 + 40) = v16;
      *(_QWORD *)(a1 + 48) = v25;
      if (v26)
        operator delete(v26);
    }
    else
    {
      *(_QWORD *)v15 = a3;
      *(_WORD *)(v15 + 8) = v8;
      v16 = (char *)(v15 + 16);
    }
    *(_QWORD *)(a1 + 40) = v16;
  }
}

void TAATControlPointAccess::TAATControlPointAccess(TAATControlPointAccess *this, const TBaseFont *a2)
{
  uint64_t ParserFont;
  void *v5;
  const __CFData *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  void *v9;
  id v10;
  const __CFData *v11;
  const __CFData *v12;
  const UInt8 *v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t v16;
  void *v17;
  unint64_t v18;
  void *v19;
  id v20;
  id v21;

  *(_QWORD *)this = 0;
  *((_WORD *)this + 4) = -1;
  *((_QWORD *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 133) = (char *)this + 40;
  *((_OWORD *)this + 67) = 0u;
  *((_BYTE *)this + 1088) = 0;
  if (TBaseFont::GetInitializedGraphicsFont(a2))
  {
    ParserFont = CGFontGetParserFont();
    *(_QWORD *)this = ParserFont;
    if (ParserFont)
      return;
  }
  else
  {
    *(_QWORD *)this = 0;
  }
  v21 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, const TBaseFont *, uint64_t))(*(_QWORD *)a2 + 480))(&v21, a2, 1751474532);
  v5 = (void *)atomic_load((unint64_t *)&v21);
  v6 = v5;
  v7 = v6;
  if (v6)
    BytePtr = CFDataGetBytePtr(v6);
  else
    BytePtr = 0;

  v9 = (void *)atomic_load((unint64_t *)&v21);
  v10 = v9;
  v11 = (const __CFData *)v10;
  if (v11)
  {
    v12 = v11;
    v13 = CFDataGetBytePtr(v11);

    if (v13)
      v13 += CFDataGetLength((CFDataRef)v10);
  }
  else
  {

    v13 = 0;
  }

  if (BytePtr && BytePtr + 54 <= v13)
  {
    v14 = (unint64_t *)((char *)this + 1072);
    v15 = (unint64_t *)((char *)this + 1080);
    *((_BYTE *)this + 1088) = *((_WORD *)BytePtr + 25) != 0;
    (*(void (**)(id *__return_ptr, const TBaseFont *, uint64_t))(*(_QWORD *)a2 + 480))(&v20, a2, 1819239265);
    do
      v16 = __ldaxr((unint64_t *)&v20);
    while (__stlxr(0, (unint64_t *)&v20));
    do
      v17 = (void *)__ldaxr(v14);
    while (__stlxr(v16, v14));

    (*(void (**)(id *__return_ptr, const TBaseFont *, uint64_t))(*(_QWORD *)a2 + 480))(&v20, a2, 1735162214);
    do
      v18 = __ldaxr((unint64_t *)&v20);
    while (__stlxr(0, (unint64_t *)&v20));
    do
      v19 = (void *)__ldaxr(v15);
    while (__stlxr(v18, v15));

  }
}

double TAATControlPointAccess::GetControlPointCoordinates(TAATControlPointAccess *this, int a2, unsigned int a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  int v12;
  void *v13;
  const __CFData *v14;
  const __CFData *v15;
  const UInt8 *v16;
  void *v17;
  id v18;
  const __CFData *v19;
  const __CFData *v20;
  const UInt8 *v21;
  unint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  uint64_t v25;
  const UInt8 *BytePtr;
  void *v27;
  const __CFData *v28;
  const UInt8 *v29;
  unint64_t v30;
  const UInt8 *v31;
  uint64_t v32;
  unint64_t *v33;
  void *v34;
  const __CFData *v35;
  const __CFData *v36;
  const UInt8 *v37;
  void *v38;
  double v39;
  void *v41;
  id v42;
  const __CFData *v43;
  const __CFData *v44;
  const UInt8 *v45;
  const UInt8 *v46;
  const UInt8 *v47;
  unsigned int v48;
  int v49;
  unint64_t v50;
  unsigned __int16 *v51;
  unint64_t v52;
  unint64_t v53;
  BOOL v54;
  unsigned int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  BOOL v60;
  unsigned __int16 v61;
  unsigned __int16 *v62;
  _BYTE *v63;
  __int16 *v64;
  void *v65;
  unint64_t v66;
  _BYTE *v67;
  unsigned __int16 *v68;
  _BYTE *v69;
  unsigned int v70;
  unsigned int v71;
  __int16 v72;
  char *v73;
  uint64_t v74;
  _WORD *v75;
  unsigned __int16 *v76;
  char v77;
  char v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  int v82;
  __int16 v83;
  char *v84;
  uint64_t v85;
  _WORD *v86;
  unsigned __int16 *v87;
  char v88;
  char v89;
  unsigned int v90;
  unsigned int v91;
  int v92;
  int v93;
  unsigned int v94;

  if (*(_QWORD *)this)
  {
    if (*((unsigned __int16 *)this + 4) != a2)
    {
      v6 = *((_QWORD *)this + 2);
      v7 = (unint64_t)(*((_QWORD *)this + 3) - v6) >> 4;
      v94 = v7;
      v8 = (*((_QWORD *)this + 4) - v6) >> 4;
      if (v8 <= 0x40)
        LODWORD(v8) = 64;
      if (v7 < v8)
      {
        v94 = v8;
        std::vector<CGPoint,TInlineBufferAllocator<CGPoint,64ul>>::resize((uint64_t)this + 16, v8);
      }
      if (!FPFontGetControlPoints())
        goto LABEL_33;
      v9 = *((_QWORD *)this + 3) - *((_QWORD *)this + 2);
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,64ul>>::resize((uint64_t)this + 16, v94);
      if (v94 > (unint64_t)(v9 >> 4) && (FPFontGetControlPoints() & 1) == 0)
        goto LABEL_33;
      *((_WORD *)this + 4) = a2;
    }
    v10 = *((_QWORD *)this + 2);
    if (a3 < (unint64_t)((*((_QWORD *)this + 3) - v10) >> 4))
    {
      v11 = (double *)(v10 + 16 * a3);
      return *v11;
    }
LABEL_33:
    v11 = (double *)MEMORY[0x1E0C9D538];
    return *v11;
  }
  v12 = *((unsigned __int8 *)this + 1088);
  v13 = (void *)atomic_load((unint64_t *)this + 134);
  v14 = v13;
  v15 = v14;
  if (!v12)
  {
    if (v14)
    {
      BytePtr = CFDataGetBytePtr(v14);

      if (!BytePtr)
        goto LABEL_33;
      v27 = (void *)atomic_load((unint64_t *)this + 134);
      v18 = v27;
      v19 = (const __CFData *)v18;
      if (v19)
      {
        v28 = v19;
        v29 = CFDataGetBytePtr(v19);

        if (v29)
        {
          v30 = (unint64_t)&v29[CFDataGetLength((CFDataRef)v18)];

          v31 = &BytePtr[2 * a2];
          if ((unint64_t)(v31 + 4) > v30)
            goto LABEL_33;
          v32 = bswap32(*(unsigned __int16 *)v31) >> 16;
          v24 = 2 * v32;
          v25 = 2 * ((bswap32(*((unsigned __int16 *)v31 + 1)) >> 16) - v32);
          if (!v25)
            goto LABEL_33;
          goto LABEL_27;
        }
        goto LABEL_31;
      }
      goto LABEL_30;
    }
LABEL_29:
    v38 = 0;
LABEL_32:

    goto LABEL_33;
  }
  if (!v14)
    goto LABEL_29;
  v16 = CFDataGetBytePtr(v14);

  if (!v16)
    goto LABEL_33;
  v17 = (void *)atomic_load((unint64_t *)this + 134);
  v18 = v17;
  v19 = (const __CFData *)v18;
  if (!v19)
  {
LABEL_30:

    goto LABEL_31;
  }
  v20 = v19;
  v21 = CFDataGetBytePtr(v19);

  if (!v21)
  {
LABEL_31:
    v38 = v18;
    goto LABEL_32;
  }
  v22 = (unint64_t)&v21[CFDataGetLength((CFDataRef)v18)];

  v23 = (unsigned int *)&v16[4 * a2];
  if ((unint64_t)(v23 + 2) > v22)
    goto LABEL_33;
  v24 = bswap32(*v23);
  v25 = bswap32(v23[1]) - v24;
  if (!v25)
    goto LABEL_33;
LABEL_27:
  v33 = (unint64_t *)((char *)this + 1080);
  v34 = (void *)atomic_load((unint64_t *)this + 135);
  v35 = v34;
  v36 = v35;
  if (v35)
    v37 = CFDataGetBytePtr(v35);
  else
    v37 = 0;

  v41 = (void *)atomic_load(v33);
  v42 = v41;
  v43 = (const __CFData *)v42;
  if (v43)
  {
    v44 = v43;
    v45 = CFDataGetBytePtr(v43);

    if (v45)
      v45 += CFDataGetLength((CFDataRef)v42);
  }
  else
  {

    v45 = 0;
  }

  if (!v37)
    goto LABEL_33;
  v46 = &v37[v24];
  v47 = &v37[v24 + v25];
  if (v47 < &v37[v24] || v47 > v45)
    goto LABEL_33;
  v48 = *(unsigned __int16 *)v46;
  v49 = (int)bswap32(v48) >> 16;
  v39 = *MEMORY[0x1E0C9D538];
  if ((v49 & 0x80000000) == 0)
  {
    v50 = (unint64_t)&v46[v25];
    v51 = (unsigned __int16 *)(v46 + 10);
    v52 = (unint64_t)&v46[2 * (unsigned __int16)v49 + 10];
    v53 = v46 + 12 <= &v46[v25] ? (unint64_t)(v25 - 10) >> 1 : 0;
    v54 = v52 <= v50 && v52 >= (unint64_t)v51;
    if (v54 || v53 == (unsigned __int16)v49)
    {
      if (v48)
      {
        LOWORD(v56) = 0;
        v57 = 0x10000;
        do
        {
          v58 = *v51++;
          v59 = bswap32(v58) >> 16;
          if (v59 <= (unsigned __int16)v56)
            v56 = (unsigned __int16)v56;
          else
            v56 = v59;
          v60 = (unsigned __int16)v49 <= v57 >> 16;
          v57 += 0x10000;
        }
        while (!v60);
        v61 = v56 + 1;
        if (((v56 + 1) & 0x10000) != 0)
          return v39;
      }
      else
      {
        v61 = 1;
      }
      v62 = (unsigned __int16 *)((char *)v51 + (bswap32(*v51) >> 16));
      v63 = operator new(v61);
      bzero(v63, v61);
      v64 = (__int16 *)operator new(2 * v61);
      bzero(v64, 2 * v61);
      v65 = operator new(2 * v61);
      bzero(v65, 2 * v61);
      v66 = (unint64_t)&v63[v61];
      v67 = v63;
      v68 = v62 + 1;
      while (v68 >= v62 + 1 && (unint64_t)v68 + 1 <= v50)
      {
        if ((*(_BYTE *)v68 & 8) != 0)
        {
          if (v67 >= v63)
          {
            LOWORD(v70) = 0;
            v71 = *((unsigned __int8 *)v68 + 1);
            while (1)
            {
              v69 = v67 + 1;
              if ((unint64_t)(v67 + 1) > v66)
                break;
              *v67 = *(_BYTE *)v68;
              v70 = (unsigned __int16)(v70 + 1);
              ++v67;
              if (v70 > v71)
              {
                ++v68;
                v67 = v69;
                goto LABEL_76;
              }
            }
          }
          break;
        }
        *v67++ = *(_BYTE *)v68;
        v68 = (unsigned __int16 *)((char *)v68 + 1);
        v69 = v67;
LABEL_76:
        if ((unint64_t)v69 >= v66)
        {
          v72 = 0;
          v73 = v63;
          v74 = v61;
          v75 = v64;
          v76 = v68;
          do
          {
            v78 = *v73++;
            v77 = v78;
            if ((v78 & 2) != 0)
            {
              if (v76 < v68 || v76 == (unsigned __int16 *)-1 || (unint64_t)v76 + 1 > v50)
                goto LABEL_111;
              v82 = *(unsigned __int8 *)v76;
              v76 = (unsigned __int16 *)((char *)v76 + 1);
              v81 = v82;
              if ((v77 & 0x10) != 0)
                LOWORD(v80) = v81;
              else
                v80 = -v81;
            }
            else if ((v77 & 0x10) != 0)
            {
              LOWORD(v80) = 0;
            }
            else
            {
              if (v76 < v68 || (unint64_t)v76 > 0xFFFFFFFFFFFFFFFDLL || (unint64_t)(v76 + 1) > v50)
                goto LABEL_111;
              v79 = *v76++;
              v80 = bswap32(v79) >> 16;
            }
            v72 += v80;
            *v75++ = v72;
            --v74;
          }
          while (v74);
          if (v76)
          {
            v83 = 0;
            v84 = v63;
            v85 = v61;
            v86 = v65;
            v87 = v76;
            do
            {
              v89 = *v84++;
              v88 = v89;
              if ((v89 & 4) != 0)
              {
                if (v87 < v76 || v87 == (unsigned __int16 *)-1 || (unint64_t)v87 + 1 > v50)
                  goto LABEL_111;
                v93 = *(unsigned __int8 *)v87;
                v87 = (unsigned __int16 *)((char *)v87 + 1);
                v92 = v93;
                if ((v88 & 0x20) != 0)
                  LOWORD(v91) = v92;
                else
                  v91 = -v92;
              }
              else if ((v88 & 0x20) != 0)
              {
                LOWORD(v91) = 0;
              }
              else
              {
                if (v87 < v76 || (unint64_t)v87 > 0xFFFFFFFFFFFFFFFDLL || (unint64_t)(v87 + 1) > v50)
                  goto LABEL_111;
                v90 = *v87++;
                v91 = bswap32(v90) >> 16;
              }
              v83 += v91;
              *v86++ = v83;
              --v85;
            }
            while (v85);
            if (v61 > a3 && v87)
              v39 = (double)v64[a3];
          }
          break;
        }
      }
LABEL_111:
      operator delete(v65);
      operator delete(v64);
      operator delete(v63);
    }
  }
  return v39;
}

void std::vector<CGPoint,TInlineBufferAllocator<CGPoint,64ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  char *v12;
  unint64_t v13;
  unint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  unint64_t *v18;
  unint64_t *v19;
  uint64_t v20;

  v3 = *(unint64_t **)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = (v4 - *(_QWORD *)a1) >> 4;
  if (a2 <= v5)
  {
    if (a2 >= v5)
      return;
    v14 = &v3[2 * a2];
    goto LABEL_15;
  }
  v6 = a2 - v5;
  v7 = *(_QWORD *)(a1 + 16);
  if (a2 - v5 <= (v7 - v4) >> 4)
  {
    bzero(*(void **)(a1 + 8), 16 * v6);
    v14 = (unint64_t *)(v4 + 16 * v6);
LABEL_15:
    *(_QWORD *)(a1 + 8) = v14;
    return;
  }
  if (a2 >> 60)
    abort();
  v8 = v7 - (_QWORD)v3;
  v9 = v8 >> 3;
  if (v8 >> 3 <= a2)
    v9 = a2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
    v10 = 0xFFFFFFFFFFFFFFFLL;
  else
    v10 = v9;
  v11 = (unint64_t *)(a1 + 1048);
  v12 = *(char **)(a1 + 1048);
  v13 = (unint64_t)&v12[16 * v10];
  if (v13 <= a1 + 1048)
  {
    *v11 = v13;
  }
  else
  {
    if (v10 >> 60)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v12 = (char *)operator new(16 * v10);
  }
  v15 = &v12[16 * v5];
  v16 = &v12[16 * v10];
  bzero(v15, 16 * v6);
  v17 = &v15[16 * v6];
  v19 = *(unint64_t **)a1;
  v18 = *(unint64_t **)(a1 + 8);
  if (v18 != *(unint64_t **)a1)
  {
    do
    {
      *((_OWORD *)v15 - 1) = *((_OWORD *)v18 - 1);
      v15 -= 16;
      v18 -= 2;
    }
    while (v18 != v19);
    v18 = *(unint64_t **)a1;
  }
  *(_QWORD *)a1 = v15;
  *(_QWORD *)(a1 + 8) = v17;
  v20 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v16;
  if (v18)
  {
    if (a1 + 24 <= (unint64_t)v18 && v11 > v18)
    {
      if (v20 == *v11)
        *v11 = (unint64_t)v18;
    }
    else
    {
      operator delete(v18);
    }
  }
}

CFArrayRef CTFontManagerCopyAvailablePostScriptNames(void)
{
  CFArrayRef v1;
  const __CFArray *v2;
  TPurgeableCache *v4;
  id v5;
  id v6;

  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v4);
  TDescriptorSource::CopyAvailablePostScriptNames(&v4, &v5);
  if (atomic_load((unint64_t *)&v5))
  {
    do
      v1 = (CFArrayRef)__ldaxr((unint64_t *)&v5);
    while (__stlxr(0, (unint64_t *)&v5));
  }
  else
  {
    v1 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  }
  v6 = v1;
  do
    v2 = (const __CFArray *)__ldaxr((unint64_t *)&v6);
  while (__stlxr(0, (unint64_t *)&v6));

  return v2;
}

CFArrayRef CTFontManagerCopyAvailableFontFamilyNames(void)
{
  CFArrayRef v1;
  const __CFArray *v2;
  _BYTE v4[8];
  id v5;
  id v6;

  TDescriptorSource::TDescriptorSource((TDescriptorSource *)v4);
  TDescriptorSource::CopyAvailableFamilyNames((unint64_t *)&v5);
  if (atomic_load((unint64_t *)&v5))
  {
    do
      v1 = (CFArrayRef)__ldaxr((unint64_t *)&v5);
    while (__stlxr(0, (unint64_t *)&v5));
  }
  else
  {
    v1 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  }
  v6 = v1;
  do
    v2 = (const __CFArray *)__ldaxr((unint64_t *)&v6);
  while (__stlxr(0, (unint64_t *)&v6));

  return v2;
}

BOOL CTFontManagerUnregisterFontsForURL(CFURLRef fontURL, CTFontManagerScope scope, CFErrorRef *error)
{
  return _CTFontManagerRegisterActionFontsForURL(fontURL, scope, 0, error);
}

BOOL CTFontManagerRegisterFontsForURLs(CFArrayRef fontURLs, CTFontManagerScope scope, CFArrayRef *errors)
{
  return _CTFontManagerRegisterActionFontsForURLs(fontURLs, scope, 1, (unint64_t *)errors);
}

BOOL CTFontManagerUnregisterFontsForURLs(CFArrayRef fontURLs, CTFontManagerScope scope, CFArrayRef *errors)
{
  return _CTFontManagerRegisterActionFontsForURLs(fontURLs, scope, 0, (unint64_t *)errors);
}

BOOL CTFontManagerRegisterGraphicsFont(CGFontRef font, CFErrorRef *error)
{
  int v4;
  BOOL v5;
  void *v6;
  CFArrayRef v7;
  id v9;
  BOOL v10;
  void *values;

  if (font)
  {
    v10 = -86;
    v9 = (id)0xAAAAAAAAAAAAAAAALL;
    CreateFontURLFromFont(font, &v10, (unint64_t *)&v9);
    EnsureGSFontInitialized();
    v4 = GSFontRegisterCGFont();
    v5 = v4 == 0;
    if (v4)
    {
      if (error)
        *error = CreateErrorForFailureToActOnGraphicsFont(1, font, v4);
    }
    else
    {
      v6 = (void *)atomic_load((unint64_t *)&v9);
      values = v6;
      v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
      CTFontManagerInstalledFontsChanged(v7, 0);

    }
  }
  else
  {
    v5 = 0;
    if (error)
      *error = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 22, 0);
  }
  return v5;
}

CFErrorRef CreateErrorForFailureToActOnGraphicsFont(int a1, void *a2, int a3)
{
  const __CFAllocator *v5;
  const char *v6;
  __CFString *v7;
  CFErrorRef v8;
  void *userInfoValues[2];
  void *userInfoKeys[3];

  userInfoKeys[2] = *(void **)MEMORY[0x1E0C80C00];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = "register";
  if (!a1)
    v6 = "unregister";
  v7 = (__CFString *)CFStringCreateWithFormat(v5, 0, CFSTR("Could not %s the CGFont '%@'"), v6, a2);
  userInfoKeys[0] = *(void **)MEMORY[0x1E0C9AFB0];
  userInfoKeys[1] = CFSTR("CTFailedCGFont");
  userInfoValues[0] = v7;
  userInfoValues[1] = a2;
  v8 = CFErrorCreateWithUserInfoKeysAndValues(v5, CFSTR("com.apple.CoreText.CTFontManagerErrorDomain"), a3, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 2);

  return v8;
}

BOOL CTFontManagerUnregisterGraphicsFont(CGFontRef font, CFErrorRef *error)
{
  int v4;
  BOOL v5;
  void *v6;
  const __CFArray *v7;
  id v9;
  BOOL v10;
  void *values;

  if (font)
  {
    v10 = -86;
    v9 = (id)0xAAAAAAAAAAAAAAAALL;
    CreateFontURLFromFont(font, &v10, (unint64_t *)&v9);
    EnsureGSFontInitialized();
    v4 = GSFontUnregisterCGFont();
    v5 = v4 == 0;
    if (v4)
    {
      if (error)
        *error = CreateErrorForFailureToActOnGraphicsFont(0, font, v4);
    }
    else
    {
      v6 = (void *)atomic_load((unint64_t *)&v9);
      values = v6;
      v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
      CTFontManagerInstalledFontsChanged(0, v7);

    }
  }
  else
  {
    v5 = 0;
    if (error)
      *error = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 22, 0);
  }
  return v5;
}

CFArrayRef CTFontManagerCreateFontDescriptorsFromURL(CFURLRef fileURL)
{
  void *v1;
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  CFIndex i;
  TDescriptor *ValueAtIndex;
  uint64_t v9;
  void *v10;
  id v11;
  __CFArray *v12;
  id v14;
  uint64_t v15;
  id FontsWithURL;

  FontsWithURL = (id)CGFontCreateFontsWithURL();
  do
    v1 = (void *)__ldaxr((unint64_t *)&FontsWithURL);
  while (__stlxr(0, (unint64_t *)&FontsWithURL));

  v2 = v1;
  v3 = v2;
  if (v2)
  {
    Count = CFArrayGetCount(v2);

    if (Count < 1)
    {
      v3 = 0;
      goto LABEL_19;
    }
    FontsWithURL = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (v1)
    {
      v5 = CFArrayGetCount((CFArrayRef)v1);
      if (v5)
      {
        v6 = v5;
        for (i = 0; i != v6; ++i)
        {
          ValueAtIndex = (TDescriptor *)CFArrayGetValueAtIndex((CFArrayRef)v1, i);
          v15 = 0xAAAAAAAAAAAAAAAALL;
          TDescriptor::CreateBaseFont(ValueAtIndex, (CGFont *)1);
          v15 = v9;
          if (v9)
            TCFBase_NEW<CTFontDescriptor,TBaseFont const*&>(&v15, (unint64_t *)&v14);
          else
            v14 = 0;
          do
            v10 = (void *)__ldaxr((unint64_t *)&v14);
          while (__stlxr(0, (unint64_t *)&v14));

          if (v10)
          {
            v11 = v10;
            v12 = (__CFArray *)atomic_load((unint64_t *)&FontsWithURL);
            CFArrayAppendValue(v12, v11);

          }
        }
      }
    }
    do
      v3 = (const __CFArray *)__ldaxr((unint64_t *)&FontsWithURL);
    while (__stlxr(0, (unint64_t *)&FontsWithURL));
    v2 = (const __CFArray *)FontsWithURL;
  }

LABEL_19:
  return v3;
}

unint64_t CTFontManagerCreateMemorySafeFontDescriptorFromData(const __CFData *a1)
{
  void *v2;
  void *v3;
  unint64_t v4;
  void *v6;
  id v7;
  id v8;
  id v9;

  v9 = (id)0xAAAAAAAAAAAAAAAALL;
  CreateMemorySafeFontWithData(a1, (unint64_t *)&v9);
  if (atomic_load((unint64_t *)&v9))
  {
    v8 = (id)0xAAAAAAAAAAAAAAAALL;
    v2 = (void *)atomic_load((unint64_t *)&v9);
    v6 = v2;
    TCFBase_NEW<CTFontDescriptor,CGFont *&,is_inmemory_t const&>(&v6, (unint64_t *)&v7);
    do
      v3 = (void *)__ldaxr((unint64_t *)&v7);
    while (__stlxr(0, (unint64_t *)&v7));
    v8 = v3;

    do
      v4 = __ldaxr((unint64_t *)&v8);
    while (__stlxr(0, (unint64_t *)&v8));

  }
  else
  {
    v4 = 0;
  }

  return v4;
}

CFArrayRef CTFontManagerCreateFontDescriptorsFromData(CFDataRef data)
{
  const __CFArray *FontsFromData;
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex i;
  void *v6;
  id v7;
  __CFArray *v8;
  const __CFArray *v9;
  id v11;
  void *ValueAtIndex;
  id Mutable;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  FontsFromData = (const __CFArray *)CGFontCreateFontsFromData();
  v2 = FontsFromData;
  if (FontsFromData)
  {
    Count = CFArrayGetCount(FontsFromData);
    if (Count)
    {
      v4 = Count;
      for (i = 0; i != v4; ++i)
      {
        ValueAtIndex = (void *)0xAAAAAAAAAAAAAAAALL;
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v2, i);
        TCFBase_NEW<CTFontDescriptor,CGFont *&,is_inmemory_t const&>(&ValueAtIndex, (unint64_t *)&v11);
        do
          v6 = (void *)__ldaxr((unint64_t *)&v11);
        while (__stlxr(0, (unint64_t *)&v11));

        if (v6)
        {
          v7 = v6;
          v8 = (__CFArray *)atomic_load((unint64_t *)&Mutable);
          CFArrayAppendValue(v8, v7);

        }
      }
    }
  }
  do
    v9 = (const __CFArray *)__ldaxr((unint64_t *)&Mutable);
  while (__stlxr(0, (unint64_t *)&Mutable));

  return v9;
}

void CTFontManagerRegisterFontURLs(CFArrayRef fontURLs, CTFontManagerScope scope, BOOL enabled, void *registrationHandler)
{
  _CTFontManagerRegisterActionFontURLs(fontURLs, scope, enabled, 1, 0, 0, (void (**)(_QWORD, _QWORD, _QWORD))registrationHandler);
}

void _CTFontManagerRegisterActionFontURLs(void *a1, int a2, uint64_t a3, int a4, int a5, void *a6, void (**a7)(_QWORD, _QWORD, _QWORD))
{
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  void *v17;
  void *v18;
  void *v19;
  unint64_t v20;
  void *v21;
  CFArrayRef v23;
  id obj;
  unint64_t v27;
  id v28[7];
  int v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[128];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    v11 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    obj = a1;
    v12 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
    if (v12)
    {
      v13 = v12;
      v14 = 0;
      v15 = *(_QWORD *)v31;
      do
      {
        for (i = 0; i != v13; ++i)
        {
          if (*(_QWORD *)v31 != v15)
            objc_enumerationMutation(obj);
          v17 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithObject:forKey:", *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8 * i), CFSTR("NSCTFontFileURLAttribute"));
          v18 = v17;
          if (a5 == 1)
            objc_msgSend(v17, "setObject:forKey:", MEMORY[0x1E0C9AAB0], CFSTR("CTFontIgnoreURLLocationAttribute"));
          if (a6)
          {
            v19 = (void *)objc_msgSend(a6, "objectAtIndex:", v14 + i);
            objc_msgSend(v18, "setObject:forKey:", objc_msgSend(v19, "objectAtIndexedSubscript:", 0), CFSTR("CTFontRegistrationUserInfoAttribute"));
            objc_msgSend(v18, "setObject:forKey:", objc_msgSend(v19, "objectAtIndexedSubscript:", 1), CFSTR("CTFontAssetDataAttribute"));
          }
          objc_msgSend(v11, "addObject:", v18);
        }
        v13 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v30, v34, 16);
        v14 += i;
      }
      while (v13);
    }
    v28[1] = (id)MEMORY[0x1E0C809B0];
    v28[2] = (id)3221225472;
    v28[3] = ___ZL36_CTFontManagerRegisterActionFontURLsPK9__CFArray18CTFontManagerScopeb6Action8URLTrustS1_U13block_pointerFbS1_bE_block_invoke;
    v28[4] = &unk_1E15E8800;
    v28[5] = obj;
    v28[6] = a7;
    v29 = a4;
    if (a4 == 1)
      FSFontProviderRegisterFonts();
    else
      FSFontProviderUnregisterFonts();
  }
  else
  {
    v27 = 0;
    v28[0] = 0;
    _CTFontManagerRegisterActionFontsForURLs((const __CFArray *)a1, a2, a4, &v27);
    v20 = v27;
    do
      v21 = (void *)__ldaxr((unint64_t *)v28);
    while (__stlxr(v20, (unint64_t *)v28));

    if (a7)
    {
      if (atomic_load((unint64_t *)v28))
      {
        do
          v23 = (CFArrayRef)__ldaxr((unint64_t *)v28);
        while (__stlxr(0, (unint64_t *)v28));
      }
      else
      {
        v23 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
      }
      ((void (**)(_QWORD, CFArrayRef, uint64_t))a7)[2](a7, v23, 1);

    }
  }
}

void CTFontManagerUnregisterFontURLs(CFArrayRef fontURLs, CTFontManagerScope scope, void *registrationHandler)
{
  _CTFontManagerRegisterActionFontURLs(fontURLs, scope, 1, 0, 0, 0, (void (**)(_QWORD, _QWORD, _QWORD))registrationHandler);
}

void CTFontManagerRegisterFontDescriptors(CFArrayRef fontDescriptors, CTFontManagerScope scope, BOOL enabled, void *registrationHandler)
{
  _CTFontManagerRegisterActionFontDescriptors(fontDescriptors, scope, enabled, 1, (uint64_t)registrationHandler);
}

void _CTFontManagerRegisterActionFontDescriptors(CFArrayRef theArray, int a2, unsigned int a3, int a4, uint64_t a5)
{
  void *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  const __CTFontDescriptor **ValueAtIndex;
  void *SupportedAttributes;
  void *v15;
  void *v16;
  void *v17;
  CFIndex v18;
  CFIndex v19;
  CFIndex j;
  const __CTFontDescriptor *v21;
  CFTypeRef v22;
  CFTypeRef v23;
  CFTypeRef v24;
  uint64_t v25;
  uint64_t v26;
  void (*v30[12])(_QWORD, _QWORD, _QWORD);
  int v31;
  uint64_t v32;
  const __CFString *v33;
  _QWORD v34[3];

  v34[1] = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    v8 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", CFArrayGetCount(theArray));
    if (theArray)
    {
      Count = CFArrayGetCount(theArray);
      if (Count)
      {
        v10 = Count;
        for (i = 0; i != v10; ++i)
        {
          ValueAtIndex = (const __CTFontDescriptor **)CFArrayGetValueAtIndex(theArray, i);
          SupportedAttributes = ExtractSupportedAttributes(ValueAtIndex[5], 1);
          if (SupportedAttributes)
            objc_msgSend(v8, "addObject:", SupportedAttributes);
        }
      }
    }
    v30[6] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v30[7] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
    v30[8] = (void (*)(_QWORD, _QWORD, _QWORD))___ZL43_CTFontManagerRegisterActionFontDescriptorsPK9__CFArray18CTFontManagerScopeb6ActionU13block_pointerFbS1_bE_block_invoke;
    v30[9] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E15E8800;
    v30[10] = (void (*)(_QWORD, _QWORD, _QWORD))theArray;
    v30[11] = (void (*)(_QWORD, _QWORD, _QWORD))a5;
    v31 = a4;
    if (a4 == 1)
      FSFontProviderRegisterFonts();
    else
      FSFontProviderUnregisterFonts();
  }
  else
  {
    v15 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", -[__CFArray count](theArray, "count"));
    v16 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", -[__CFArray count](theArray, "count"));
    v17 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", -[__CFArray count](theArray, "count"));
    if (theArray)
    {
      v18 = CFArrayGetCount(theArray);
      if (v18)
      {
        v19 = v18;
        for (j = 0; j != v19; ++j)
        {
          v21 = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(theArray, j);
          v22 = CTFontDescriptorCopyAttribute(v21, CFSTR("NSCTFontFileURLAttribute"));
          v23 = (id)CFMakeCollectable(v22);
          if (v23)
          {
            v24 = v23;
            objc_msgSend(v15, "addObject:", v23);
            objc_msgSend(v17, "setObject:forKeyedSubscript:", v21, v24);
          }
          else
          {
            objc_msgSend(v16, "addObject:", v21);
          }
        }
      }
    }
    v25 = objc_msgSend(v16, "count");
    if (a5 && v25)
    {
      v33 = CFSTR("CTFontManagerErrorFontDescriptors");
      v34[0] = v16;
      v26 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v34, &v33, 1);
      v32 = objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("com.apple.CoreText.CTFontManagerErrorDomain"), 303, v26);
      (*(void (**)(uint64_t, uint64_t, BOOL))(a5 + 16))(a5, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v32, 1), objc_msgSend(v15, "count") == 0);
    }
    if (objc_msgSend(v15, "count"))
    {
      v30[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
      v30[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
      v30[2] = (void (*)(_QWORD, _QWORD, _QWORD))___ZL43_CTFontManagerRegisterActionFontDescriptorsPK9__CFArray18CTFontManagerScopeb6ActionU13block_pointerFbS1_bE_block_invoke_2;
      v30[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E15E8828;
      v30[4] = (void (*)(_QWORD, _QWORD, _QWORD))v17;
      v30[5] = (void (*)(_QWORD, _QWORD, _QWORD))a5;
      _CTFontManagerRegisterActionFontURLs(v15, a2, a3, a4, 1, 0, v30);
    }
  }
}

void CTFontManagerUnregisterFontDescriptors(CFArrayRef fontDescriptors, CTFontManagerScope scope, void *registrationHandler)
{
  _CTFontManagerRegisterActionFontDescriptors(fontDescriptors, scope, 1u, 0, (uint64_t)registrationHandler);
}

void CTFontManagerRegisterFontsWithAssetNames(CFArrayRef fontAssetNames, CFBundleRef bundle, CTFontManagerScope scope, BOOL enabled, void *registrationHandler)
{
  _BOOL4 v6;
  void *v9;
  void *v10;
  uint64_t v11;
  int v12;
  objc_class *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const __CFUUID *v21;
  const __CFUUID *v22;
  CFStringRef v23;
  CFStringRef v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  const __CFString *v29;
  unint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  const __CFString *v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  _BOOL4 v39;
  void (**v40)(void *, uint64_t, BOOL);
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void (*v46[7])(_QWORD, _QWORD, _QWORD);
  id v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  id v52[5];
  id v53;
  id *v54;
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t);
  uint64_t v58;
  uint64_t v59;
  const __CFString *v60;
  void *v61;
  uint64_t v62;
  _QWORD v63[2];
  _QWORD v64[2];
  _QWORD v65[2];
  _BYTE v66[128];
  uint64_t v67;

  v6 = enabled;
  v67 = *MEMORY[0x1E0C80C00];
  v9 = (void *)-[__CFArray mutableCopy](fontAssetNames, "mutableCopy");
  if (bundle
    && (v10 = (void *)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", CFBundleGetIdentifier(bundle))) != 0)
  {
    v11 = (uint64_t)v10;
    v12 = objc_msgSend(v10, "isEqual:", objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"));
  }
  else
  {
    v11 = objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle");
    v12 = 1;
  }
  if (scope == kCTFontManagerScopePersistent && v12)
  {
    v39 = v6;
    v40 = (void (**)(void *, uint64_t, BOOL))registrationHandler;
    v44 = v9;
    v53 = 0;
    v54 = &v53;
    v55 = 0x3052000000;
    v56 = __Block_byref_object_copy__2;
    v57 = __Block_byref_object_dispose__2;
    v13 = (objc_class *)_MergedGlobals_33;
    v58 = _MergedGlobals_33;
    if (!_MergedGlobals_33)
    {
      v52[0] = (id)MEMORY[0x1E0C809B0];
      v52[1] = (id)3221225472;
      v52[2] = ___ZL19getNSDataAssetClassv_block_invoke;
      v52[3] = &unk_1E15E20C0;
      v52[4] = &v53;
      ___ZL19getNSDataAssetClassv_block_invoke((uint64_t)v52);
      v13 = (objc_class *)v54[5];
    }
    _Block_object_dispose(&v53, 8);
    v43 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", -[__CFArray count](fontAssetNames, "count"));
    v42 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", -[__CFArray count](fontAssetNames, "count"));
    v41 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", -[__CFArray count](fontAssetNames, "count"));
    if (v13)
    {
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v14 = -[__CFArray countByEnumeratingWithState:objects:count:](fontAssetNames, "countByEnumeratingWithState:objects:count:", &v48, v66, 16);
      if (v14)
      {
        v15 = v14;
        v16 = *(_QWORD *)v49;
        do
        {
          for (i = 0; i != v15; ++i)
          {
            if (*(_QWORD *)v49 != v16)
              objc_enumerationMutation(fontAssetNames);
            v18 = *(_QWORD *)(*((_QWORD *)&v48 + 1) + 8 * i);
            v19 = objc_msgSend([v13 alloc], "initWithName:bundle:", v18, v11);
            if (v19)
            {
              v20 = (void *)v19;
              v21 = CFUUIDCreate(0);
              if (v21)
              {
                v22 = v21;
                v23 = CFUUIDCreateString(0, v21);
                if (v23)
                {
                  v24 = v23;
                  v25 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", -[NSString stringByAppendingPathComponent:](NSTemporaryDirectory(), "stringByAppendingPathComponent:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@-%@"), v18, v23)));
                  CFRelease(v24);
                  CFRelease(v22);
                  if (v25)
                  {
                    if (objc_msgSend((id)objc_msgSend(v20, "data"), "writeToURL:atomically:", v25, 1))
                    {
                      v26 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithContentsOfURL:options:error:", v25, 8, 0);
                      if (v26)
                      {
                        v27 = (void *)v26;
                        objc_msgSend(v44, "removeObject:", v18);
                        objc_msgSend(v43, "addObject:", v25);
                        v65[0] = v18;
                        v65[1] = v27;
                        objc_msgSend(v42, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v65, 2));
                        objc_msgSend(v41, "setObject:forKeyedSubscript:", v18, v25);

                      }
                    }
                  }
                }
                else
                {
                  CFRelease(v22);
                }
              }

            }
          }
          v15 = -[__CFArray countByEnumeratingWithState:objects:count:](fontAssetNames, "countByEnumeratingWithState:objects:count:", &v48, v66, 16);
        }
        while (v15);
      }
    }
    v9 = v44;
    v28 = objc_msgSend(v44, "count");
    if (v40 && v28)
    {
      v53 = 0;
      if (objc_msgSend(v44, "count") == 1)
      {
        CTCopyLocalizedString(CFSTR("The font resource \"%@\" could not be found in an asset catalog."), CFSTR("CTFontManagerErrors"), (unint64_t *)&v47);
        v29 = (const __CFString *)atomic_load((unint64_t *)&v47);
        CreateLocalizedStringWithFormat(v29, (unint64_t *)v52, objc_msgSend(v44, "objectAtIndexedSubscript:", 0));
        do
          v30 = __ldaxr((unint64_t *)v52);
        while (__stlxr(0, (unint64_t *)v52));
        do
          v31 = (void *)__ldaxr((unint64_t *)&v53);
        while (__stlxr(v30, (unint64_t *)&v53));
      }
      else
      {
        CTCopyLocalizedString(CFSTR("%1$d font resources could not be found in an asset catalog: %2$@"), CFSTR("CTFontManagerErrors"), (unint64_t *)&v47);
        v34 = (const __CFString *)atomic_load((unint64_t *)&v47);
        CreateLocalizedStringWithFormat(v34, (unint64_t *)v52, objc_msgSend(v44, "count"), objc_msgSend(v44, "componentsJoinedByString:", CFSTR(", ")));
        do
          v35 = __ldaxr((unint64_t *)v52);
        while (__stlxr(0, (unint64_t *)v52));
        do
          v31 = (void *)__ldaxr((unint64_t *)&v53);
        while (__stlxr(v35, (unint64_t *)&v53));
      }

      v64[0] = v44;
      v36 = *MEMORY[0x1E0C9AFE0];
      v63[0] = CFSTR("CTFontManagerErrorFontAssetNameKey");
      v63[1] = v36;
      v37 = atomic_load((unint64_t *)&v53);
      v64[1] = v37;
      v38 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v64, v63, 2);
      v62 = objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("com.apple.CoreText.CTFontManagerErrorDomain"), 107, v38);
      v40[2](v40, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v62, 1), objc_msgSend(v43, "count") == 0);

    }
    if (objc_msgSend(v43, "count"))
    {
      v46[0] = (void (*)(_QWORD, _QWORD, _QWORD))MEMORY[0x1E0C809B0];
      v46[1] = (void (*)(_QWORD, _QWORD, _QWORD))3221225472;
      v46[2] = (void (*)(_QWORD, _QWORD, _QWORD))__CTFontManagerRegisterFontsWithAssetNames_block_invoke;
      v46[3] = (void (*)(_QWORD, _QWORD, _QWORD))&unk_1E15E87B0;
      v46[5] = (void (*)(_QWORD, _QWORD, _QWORD))v43;
      v46[6] = (void (*)(_QWORD, _QWORD, _QWORD))v40;
      v46[4] = (void (*)(_QWORD, _QWORD, _QWORD))v41;
      _CTFontManagerRegisterActionFontURLs(v43, 2, v39, 1, 1, v42, v46);
    }
  }
  else
  {
    v60 = CFSTR("CTFontManagerErrorFontAssetNameKey");
    v61 = v9;
    v32 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v61, &v60, 1);
    v33 = objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", *MEMORY[0x1E0C9AFD0], 22, v32);
    if (registrationHandler)
    {
      v59 = v33;
      (*((void (**)(void *, uint64_t, uint64_t))registrationHandler + 2))(registrationHandler, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v59, 1), 1);
    }
  }

}

void *TransformErrorsWithURLKeyIntoKey(void *a1, uint64_t a2, void *a3)
{
  uint64_t i;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t j;
  id obj;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  _BYTE v30[128];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v20 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend(a1, "count"));
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  obj = a1;
  v19 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v25, v30, 16);
  if (v19)
  {
    v18 = *(_QWORD *)v26;
    while (2)
    {
      for (i = 0; i != v19; ++i)
      {
        if (*(_QWORD *)v26 != v18)
          objc_enumerationMutation(obj);
        v6 = *(void **)(*((_QWORD *)&v25 + 1) + 8 * i);
        v7 = (id)objc_msgSend((id)objc_msgSend(v6, "userInfo"), "mutableCopy");
        v8 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
        v9 = (void *)objc_msgSend((id)objc_msgSend(v6, "userInfo"), "objectForKeyedSubscript:", CFSTR("CTFontManagerErrorFontURLs"));
        if (!v9)
        {
          CFLog();
          return 0;
        }
        v10 = v9;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
        if (v11)
        {
          v12 = v11;
          v13 = *(_QWORD *)v22;
          do
          {
            for (j = 0; j != v12; ++j)
            {
              if (*(_QWORD *)v22 != v13)
                objc_enumerationMutation(v10);
              objc_msgSend(v8, "addObject:", objc_msgSend(a3, "objectForKeyedSubscript:", *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * j)));
            }
            v12 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
          }
          while (v12);
        }
        objc_msgSend(v7, "removeObjectForKey:", CFSTR("CTFontManagerErrorFontURLs"));
        objc_msgSend(v7, "setObject:forKeyedSubscript:", v8, a2);
        objc_msgSend(v20, "addObject:", objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", objc_msgSend(v6, "domain"), objc_msgSend(v6, "code"), v7));
      }
      v19 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v25, v30, 16);
      if (v19)
        continue;
      break;
    }
  }
  return v20;
}

CFArrayRef CTFontManagerCopyRegisteredFontDescriptors(CTFontManagerScope scope, BOOL enabled)
{
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v6;
  CFIndex v7;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CTFontDescriptorRef v10;
  CTFontDescriptorRef v11;
  CFArrayRef v13;
  id v15;
  id v16;

  if (scope == kCTFontManagerScopePersistent && (v2 = (const __CFArray *)FSFontProviderRegisteredFontsInfo()) != 0)
  {
    v3 = v2;
    Count = CFArrayGetCount(v2);
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
    v6 = CFArrayGetCount(v3);
    if (v6)
    {
      v7 = v6;
      for (i = 0; i != v7; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, i);
        v10 = CTFontDescriptorCreateWithAttributes(ValueAtIndex);
        if (v10)
        {
          v11 = v10;
          CFArrayAppendValue(Mutable, v10);
          CFRelease(v11);
        }
      }
    }
  }
  else
  {
    CFLog();
    v15 = 0;
    if (atomic_load((unint64_t *)&v15))
    {
      do
        v13 = (CFArrayRef)__ldaxr((unint64_t *)&v15);
      while (__stlxr(0, (unint64_t *)&v15));
    }
    else
    {
      v13 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
    }
    v16 = v13;
    do
      Mutable = (__CFArray *)__ldaxr((unint64_t *)&v16);
    while (__stlxr(0, (unint64_t *)&v16));

  }
  return Mutable;
}

void CTFontManagerRequestFonts(CFArrayRef fontDescriptors, void *completionHandler)
{
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v5;
  CFIndex v6;
  CFIndex i;
  const __CTFontDescriptor **ValueAtIndex;
  CFArrayRef MatchingFontDescriptors;
  void *SupportedAttributes;

  if (fontDescriptors)
  {
    Count = CFArrayGetCount(fontDescriptors);
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
    v5 = CFArrayGetCount(fontDescriptors);
    if (v5)
    {
      v6 = v5;
      for (i = 0; i != v6; ++i)
      {
        ValueAtIndex = (const __CTFontDescriptor **)CFArrayGetValueAtIndex(fontDescriptors, i);
        MatchingFontDescriptors = CTFontDescriptorCreateMatchingFontDescriptors((CTFontDescriptorRef)ValueAtIndex, 0);
        if (!MatchingFontDescriptors)
        {
          SupportedAttributes = ExtractSupportedAttributes(ValueAtIndex[5], 0);
          if (SupportedAttributes)
            CFArrayAppendValue(Mutable, SupportedAttributes);
        }

      }
    }
    CFRetain(fontDescriptors);
    FSFontProviderRequestFonts();

  }
  else if (completionHandler)
  {
    (*((void (**)(void *, _QWORD))completionHandler + 2))(completionHandler, 0);
  }
}

void *ExtractSupportedAttributes(const __CTFontDescriptor *a1, char a2)
{
  void *v4;
  uint64_t v5;
  const __CFDictionary *v6;
  const void *Value;
  void *v8;
  id v10;
  _QWORD v11[9];

  v11[8] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v4 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v11[0] = CFSTR("NSFontNameAttribute");
  v11[1] = objc_opt_class();
  v11[2] = CFSTR("NSFontFamilyAttribute");
  v11[3] = objc_opt_class();
  v11[4] = CFSTR("NSCTFontFileURLAttribute");
  v11[5] = objc_opt_class();
  v11[6] = CFSTR("CTFontRegistrationUserInfoAttribute");
  v5 = 0;
  v11[7] = objc_opt_class();
  do
  {
    atomic_load((unint64_t *)a1 + 1);
    v6 = (const __CFDictionary *)atomic_load((unint64_t *)a1 + 1);
    if (v6)
      Value = CFDictionaryGetValue(v6, (const void *)v11[v5]);
    else
      Value = 0;
    if ((objc_opt_isKindOfClass() & 1) != 0)
      objc_msgSend(v4, "setObject:forKeyedSubscript:", Value, v11[v5]);
    v5 += 2;
  }
  while (v5 != 8);
  if ((a2 & 1) != 0 && (*((_DWORD *)a1 + 4) & 0x80000000) != 0)
  {
    TDescriptor::CopyAttribute(a1, CFSTR("NSCTFontFileURLAttribute"), 25, &v10);
    do
      v8 = (void *)__ldaxr((unint64_t *)&v10);
    while (__stlxr(0, (unint64_t *)&v10));

    if (v8)
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v8, CFSTR("NSCTFontFileURLAttribute"));

  }
  return v4;
}

uint64_t ___ZL40_CTFontManagerRegisterActionFontsForURLsPK9__CFArray18CTFontManagerScopeb6ActionPS1__block_invoke()
{
  return CFLog();
}

void CreateErrorForFailureToActOnFontURLs(CFErrorRef *a1, int a2, unint64_t a3, int a4)
{
  const __CFString *v7;
  void *v8;
  id v9;
  void *userInfoValues;
  unint64_t v11;
  void *userInfoKeys[3];

  userInfoKeys[2] = *(void **)MEMORY[0x1E0C80C00];
  v9 = (id)0xAAAAAAAAAAAAAAAALL;
  if (a2)
    v7 = CFSTR("Font registration was unsuccessful.");
  else
    v7 = CFSTR("Font unregistration was unsuccessful.");
  CTCopyLocalizedString(v7, CFSTR("CTFontManagerErrors"), (unint64_t *)&v9);
  userInfoKeys[0] = *(void **)MEMORY[0x1E0C9AFE0];
  userInfoKeys[1] = CFSTR("CTFontManagerErrorFontURLs");
  userInfoValues = (void *)0xAAAAAAAAAAAAAAAALL;
  v11 = 0xAAAAAAAAAAAAAAAALL;
  v8 = (void *)atomic_load((unint64_t *)&v9);
  userInfoValues = v8;
  v11 = a3;
  *a1 = CFErrorCreateWithUserInfoKeysAndValues((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.CoreText.CTFontManagerErrorDomain"), a4, (const void *const *)userInfoKeys, (const void *const *)&userInfoValues, 2);

}

uint64_t ___ZL36_CTFontManagerRegisterActionFontURLsPK9__CFArray18CTFontManagerScopeb6Action8URLTrustS1_U13block_pointerFbS1_bE_block_invoke(uint64_t result, void *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _BYTE v13[128];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 40))
  {
    v3 = result;
    v4 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v9 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v5 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)v10;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v10 != v7)
            objc_enumerationMutation(a2);
          objc_msgSend(v4, "addObject:", externalizeError(*(void **)(*((_QWORD *)&v9 + 1) + 8 * v8++), (uint64_t)CFSTR("CTFontManagerErrorFontURLs"), *(void **)(v3 + 32), *(unsigned int *)(v3 + 48)));
        }
        while (v6 != v8);
        v6 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
      }
      while (v6);
    }
    return (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 40) + 16))();
  }
  return result;
}

uint64_t externalizeError(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  __CFError *v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const __CFArray *Value;
  CFIndex Count;
  const void *v30;
  const __CFString *v31;
  __CFDictionary *v32;
  const void *v33;
  CFIndex Code;
  CFIndex v35;
  const void *v36;
  const __CFString *v37;
  const __CFString *v38;
  __CFDictionary *v39;
  const void *v40;
  const __CFAllocator *v41;
  const __CFDictionary *v42;
  const void *v43;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  id v52;
  id v53;
  id v54;
  _BYTE v55[128];
  uint64_t v56;

  v7 = a1;
  v56 = *MEMORY[0x1E0C80C00];
  v8 = (void *)objc_msgSend(a1, "userInfo");
  if (v8)
  {
    v9 = v8;
    v10 = *MEMORY[0x1E0D22418];
    v11 = objc_msgSend(v8, "objectForKeyedSubscript:", *MEMORY[0x1E0D22418]);
    if (v11)
    {
      v12 = (void *)v11;
      v46 = a2;
      v47 = a4;
      v13 = (id)objc_msgSend(v9, "mutableCopy");
      v14 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        v15 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v48, v55, 16);
        if (v15)
        {
          v16 = v15;
          v17 = *(_QWORD *)v49;
          do
          {
            for (i = 0; i != v16; ++i)
            {
              if (*(_QWORD *)v49 != v17)
                objc_enumerationMutation(v12);
              objc_msgSend(v14, "addObject:", objc_msgSend(a3, "objectAtIndexedSubscript:", (int)objc_msgSend(*(id *)(*((_QWORD *)&v48 + 1) + 8 * i), "intValue")));
            }
            v16 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v48, v55, 16);
          }
          while (v16);
        }
      }
      else
      {
        objc_msgSend(v14, "addObject:", objc_msgSend(a3, "objectAtIndexedSubscript:", (int)objc_msgSend(v12, "intValue")));
      }
      a2 = v46;
      objc_msgSend(v13, "setObject:forKey:", v14, v46);
      objc_msgSend(v13, "removeObjectForKey:", v10);
      a4 = v47;
    }
    else
    {
      v13 = 0;
    }
    v19 = *MEMORY[0x1E0CB3388];
    v20 = objc_msgSend(v9, "objectForKeyedSubscript:", *MEMORY[0x1E0CB3388]);
    if (v20)
    {
      v21 = v20;
      if (!v13)
        v13 = (id)objc_msgSend(v9, "mutableCopy");
      objc_msgSend(v13, "setObject:forKey:", externalizeError(v21, a2, a3, a4), v19);
    }
    if (v13)
    {
      v22 = (void *)objc_msgSend(v7, "domain");
      v23 = objc_msgSend(v7, "code");
      if (objc_msgSend(v22, "isEqualToString:", *MEMORY[0x1E0D223F0]))
      {
        if ((unint64_t)(v23 - 1) >= 0xA)
        {
          v45 = v23;
          CFLog();
          v24 = 301;
        }
        else
        {
          v24 = qword_184951FD8[v23 - 1];
        }
        v25 = (__CFError *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("com.apple.CoreText.CTFontManagerErrorDomain"), v24, v13, v45);
        v54 = (id)0xAAAAAAAAAAAAAAAALL;
        v26 = CFErrorCopyUserInfo(v25);
        TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v54, v26);

        v27 = (const __CFDictionary *)atomic_load((unint64_t *)&v54);
        Value = (const __CFArray *)CFDictionaryGetValue(v27, CFSTR("CTFontManagerErrorFontURLs"));
        if (Value)
          Count = CFArrayGetCount(Value);
        else
          Count = 0;
        v30 = (const void *)*MEMORY[0x1E0C9AFE8];
        if ((_DWORD)a4)
          v31 = CFSTR("Font registration was unsuccessful.");
        else
          v31 = CFSTR("Font unregistration was unsuccessful.");
        CTCopyLocalizedString(v31, CFSTR("CTFontManagerErrors"), (unint64_t *)&v53);
        v32 = (__CFDictionary *)atomic_load((unint64_t *)&v54);
        v33 = (const void *)atomic_load((unint64_t *)&v53);
        CFDictionarySetValue(v32, v30, v33);

        Code = CFErrorGetCode(v25);
        v35 = Code;
        if (Code <= 201)
        {
          switch(Code)
          {
            case 'e':
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file does not exist at the specified URL.");
              break;
            case 'f':
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file cannot be accessed due to insufficient permissions.");
              break;
            case 'g':
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file is not a recognized or supported font file format.");
              break;
            case 'h':
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file contains invalid font data that could cause system problems.");
              break;
            case 'i':
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file has already been registered in the specified scope.");
              break;
            case 'j':
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The operation failed due to a system limitation.");
              break;
            default:
              if (Code != 201)
                goto LABEL_53;
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file is not registered in the specified scope.");
              break;
          }
        }
        else
        {
          switch(Code)
          {
            case 301:
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file could not be processed due to an unexpected FontProvider error.");
              break;
            case 302:
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file could not be processed because the provider does not have a necessary entitlement.");
              break;
            case 303:
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The font descriptor does not have information to specify a font file.");
              break;
            case 304:
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The operation was cancelled by the user.");
              break;
            case 305:
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file could not be registered because of a duplicated font name.");
              break;
            case 306:
              v36 = (const void *)*MEMORY[0x1E0C9AFE0];
              v37 = CFSTR("The file is not in an allowed location. It must be either in the application's bundle or an on-demand resource.");
              break;
            default:
              if (Code == 202)
              {
                v36 = (const void *)*MEMORY[0x1E0C9AFE0];
                v37 = CFSTR("The file is actively in use and cannot be unregistered.");
              }
              else
              {
                if (Code != 203)
                  goto LABEL_53;
                v36 = (const void *)*MEMORY[0x1E0C9AFE0];
                v37 = CFSTR("The file is required by the system and cannot be unregistered.");
              }
              break;
          }
        }
        CTCopyLocalizedString(v37, CFSTR("CTFontManagerErrors"), (unint64_t *)&v52);
        v38 = (const __CFString *)atomic_load((unint64_t *)&v52);
        CreateLocalizedStringWithFormat(v38, (unint64_t *)&v53, Count);
        v39 = (__CFDictionary *)atomic_load((unint64_t *)&v54);
        v40 = (const void *)atomic_load((unint64_t *)&v53);
        CFDictionarySetValue(v39, v36, v40);

LABEL_53:
        v41 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v42 = (const __CFDictionary *)atomic_load((unint64_t *)&v54);
        v53 = CFErrorCreate(v41, CFSTR("com.apple.CoreText.CTFontManagerErrorDomain"), v35, v42);

        do
          v43 = (const void *)__ldaxr((unint64_t *)&v53);
        while (__stlxr(0, (unint64_t *)&v53));
        v7 = (id)CFMakeCollectable(v43);

      }
      else
      {
        return objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", v22, v23, v13);
      }
    }
  }
  return (uint64_t)v7;
}

uint64_t ___ZL43_CTFontManagerRegisterActionFontDescriptorsPK9__CFArray18CTFontManagerScopeb6ActionU13block_pointerFbS1_bE_block_invoke(uint64_t result, void *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _BYTE v13[128];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 40))
  {
    v3 = result;
    v4 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v9 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v5 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
    if (v5)
    {
      v6 = v5;
      v7 = *(_QWORD *)v10;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v10 != v7)
            objc_enumerationMutation(a2);
          objc_msgSend(v4, "addObject:", externalizeError(*(void **)(*((_QWORD *)&v9 + 1) + 8 * v8++), (uint64_t)CFSTR("CTFontManagerErrorFontDescriptors"), *(void **)(v3 + 32), *(unsigned int *)(v3 + 48)));
        }
        while (v6 != v8);
        v6 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v9, v13, 16);
      }
      while (v6);
    }
    return (*(uint64_t (**)(void))(*(_QWORD *)(v3 + 40) + 16))();
  }
  return result;
}

uint64_t ___ZL43_CTFontManagerRegisterActionFontDescriptorsPK9__CFArray18CTFontManagerScopeb6ActionU13block_pointerFbS1_bE_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  void *v6;
  void *v7;

  if (*(_QWORD *)(a1 + 40))
  {
    v6 = TransformErrorsWithURLKeyIntoKey(a2, (uint64_t)CFSTR("CTFontManagerErrorFontDescriptors"), *(void **)(a1 + 32));
    if (v6)
      v7 = v6;
    else
      v7 = a2;
    (*(void (**)(_QWORD, void *, uint64_t))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v7, a3);
  }
  return 1;
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class ___ZL19getNSDataAssetClassv_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;

  if (!qword_1ECDE7E10)
    qword_1ECDE7E10 = _sl_dlopen();
  if (!qword_1ECDE7E10)
  {
    v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *UIKitCoreLibrary()"), CFSTR("CTFontManager.cpp"), 1177, CFSTR("%s"), 0);
    goto LABEL_8;
  }
  result = objc_getClass("NSDataAsset");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
  {
    v4 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getNSDataAssetClass()_block_invoke"), CFSTR("CTFontManager.cpp"), 1178, CFSTR("Unable to find class %s"), "NSDataAsset");
LABEL_8:
    __break(1u);
  }
  _MergedGlobals_33 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void OpenTypeReorderingOutput::OpenTypeReorderingOutput(OpenTypeReorderingOutput *this, TRunGlue *a2)
{
  void **v2;
  void **v3;
  std::vector<unsigned int> *v4;
  std::vector<unsigned int> *v5;
  std::vector<unsigned int>::size_type v6;

  *(_QWORD *)this = &off_1E15DE5B8;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 3) = -1;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = -1;
  *((_QWORD *)this + 6) = -1;
  v2 = (void **)((char *)this + 80);
  v3 = (void **)((char *)this + 128);
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  v4 = (std::vector<unsigned int> *)((char *)this + 104);
  *(_OWORD *)((char *)this + 56) = 0u;
  v5 = (std::vector<unsigned int> *)((char *)this + 56);
  *(_OWORD *)((char *)this + 232) = 0u;
  *((_QWORD *)this + 35) = (char *)this + 248;
  *((_QWORD *)this + 36) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 47) = (char *)this + 312;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 1);
  v6 = TRunGlue::length(a2);
  std::vector<unsigned int>::reserve(v5, v6);
  std::vector<long>::reserve(v2, v6);
  std::vector<unsigned int>::reserve(v4, v6);
  std::vector<std::pair<long,unsigned int const*>>::reserve(v3, v6);
}

void std::vector<long>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<long>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<std::pair<long,unsigned int const*>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    v9 = &v6[16 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void OpenTypeReorderingOutput::~OpenTypeReorderingOutput(OpenTypeReorderingOutput *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void **v11;

  *(_QWORD *)this = &off_1E15DE5B8;
  v2 = (void *)*((_QWORD *)this + 51);
  if (v2)
  {
    *((_QWORD *)this + 52) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 48);
  if (v3)
  {
    *((_QWORD *)this + 49) = v3;
    operator delete(v3);
  }
  v11 = (void **)((char *)this + 288);
  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v11);
  v11 = (void **)((char *)this + 224);
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,8ul>>::__destroy_vector::operator()[abi:nn180100](&v11);
  v4 = (void *)*((_QWORD *)this + 25);
  if (v4)
  {
    *((_QWORD *)this + 26) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 22);
  if (v5)
  {
    *((_QWORD *)this + 23) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 19);
  if (v6)
  {
    *((_QWORD *)this + 20) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 16);
  if (v7)
  {
    *((_QWORD *)this + 17) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 13);
  if (v8)
  {
    *((_QWORD *)this + 14) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 10);
  if (v9)
  {
    *((_QWORD *)this + 11) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 7);
  if (v10)
  {
    *((_QWORD *)this + 8) = v10;
    operator delete(v10);
  }
}

{
  OpenTypeReorderingOutput::~OpenTypeReorderingOutput(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t OpenTypeReorderingOutput::finalizeOutput(OpenTypeReorderingOutput *this)
{
  int64_t v2;
  uint64_t v3;
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  TRunGlue *v9;
  double Advance;
  uint64_t v11;
  uint64_t v12;
  const TFont *v13;

  v2 = (uint64_t)(*((_QWORD *)this + 8) - *((_QWORD *)this + 7)) >> 2;
  v3 = *((_QWORD *)this + 29) - *((_QWORD *)this + 28);
  v4 = v3 >> 2;
  std::vector<unsigned short>::resize((uint64_t)this + 152, v2);
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)((char *)this + 176), v2);
  std::vector<CGSize>::resize((uint64_t)this + 200, v2);
  if (v3 >= 1)
  {
    std::vector<unsigned short>::resize((uint64_t)this + 384, v3 >> 2);
    std::vector<CGSize>::resize((uint64_t)this + 408, v3 >> 2);
  }
  v5 = TRunGlue::length(*((TRunGlue **)this + 1));
  if (v5 >= v2)
    v6 = v2;
  else
    v6 = v5;
  if (v6 >= 1)
  {
    v7 = 0;
    for (i = 0; i != v6; ++i)
    {
      v9 = (TRunGlue *)*((_QWORD *)this + 1);
      *(_WORD *)(*((_QWORD *)this + 19) + 2 * i) = TRunGlue::GetGlyphID(v9, i);
      *(_DWORD *)(*((_QWORD *)this + 22) + 4 * i) = TRunGlue::GetGlyphProps(v9, i);
      Advance = TRunGlue::GetAdvance(v9, i);
      v11 = *((_QWORD *)this + 25) + v7;
      *(double *)v11 = Advance;
      *(_QWORD *)(v11 + 8) = v12;
      v7 += 16;
    }
  }
  v13 = *(const TFont **)(*((_QWORD *)this + 1) + 616);
  GetGlyphsForLongCharacters(v13, *((const unsigned int **)this + 28), *((unsigned __int16 **)this + 48), v4);
  TFont::GetUnsummedAdvancesForGlyphs((uint64_t)v13, *((_QWORD *)this + 48), *((double **)this + 51), 2, v4, 0, 0);
  return v4;
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  std::vector<unsigned int>::size_type v2;

  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<unsigned int>::__append(this, __sz - v2);
  }
}

uint64_t OpenTypeReorderingOutput::getInsertedIndex(OpenTypeReorderingOutput *this, int a2, uint64_t a3, uint64_t a4)
{
  char *v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  int v20;
  void **v21;
  unint64_t v22;
  char *v23;
  _QWORD *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  void **v35;

  if (a4)
  {
    v8 = (char *)*((_QWORD *)this + 28);
    v9 = (char *)*((_QWORD *)this + 29);
    v10 = (v9 - v8) >> 2;
    v11 = *((_QWORD *)this + 30);
    if ((unint64_t)v9 >= v11)
    {
      if ((unint64_t)(v10 + 1) >> 62)
        goto LABEL_50;
      v13 = v11 - (_QWORD)v8;
      v14 = (uint64_t)(v11 - (_QWORD)v8) >> 1;
      if (v14 <= v10 + 1)
        v14 = v10 + 1;
      if (v13 >= 0x7FFFFFFFFFFFFFFCLL)
        v15 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
      {
        v16 = (char *)*((_QWORD *)this + 35);
        v17 = &v16[4 * v15];
        if (v17 <= (char *)this + 280)
        {
          *((_QWORD *)this + 35) = v17;
        }
        else
        {
          if (v15 >> 62)
            goto LABEL_51;
          v16 = (char *)operator new(4 * v15);
        }
      }
      else
      {
        v16 = 0;
      }
      v18 = &v16[4 * v10];
      *(_DWORD *)v18 = a2;
      v19 = v18;
      while (v9 != v8)
      {
        v20 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v19 - 1) = v20;
        v19 -= 4;
      }
      v12 = v18 + 4;
      *((_QWORD *)this + 28) = v19;
      *((_QWORD *)this + 29) = v18 + 4;
      *((_QWORD *)this + 30) = &v16[4 * v15];
      if (v8)
      {
        if ((char *)this + 248 > v8 || (v21 = (void **)((char *)this + 280), (char *)this + 280 <= v8))
        {
          operator delete(v8);
        }
        else if (&v8[v13] == *v21)
        {
          *v21 = v8;
        }
      }
    }
    else
    {
      *(_DWORD *)v9 = a2;
      v12 = v9 + 4;
    }
    *((_QWORD *)this + 29) = v12;
    v23 = (char *)*((_QWORD *)this + 37);
    v22 = *((_QWORD *)this + 38);
    if ((unint64_t)v23 < v22)
    {
      *(_QWORD *)v23 = a3;
      v24 = v23 + 8;
LABEL_48:
      *((_QWORD *)this + 37) = v24;
      return v10 | a4;
    }
    v25 = (char *)*((_QWORD *)this + 36);
    v26 = (v23 - v25) >> 3;
    if (!((unint64_t)(v26 + 1) >> 61))
    {
      v27 = v22 - (_QWORD)v25;
      v28 = (uint64_t)(v22 - (_QWORD)v25) >> 2;
      if (v28 <= v26 + 1)
        v28 = v26 + 1;
      if (v27 >= 0x7FFFFFFFFFFFFFF8)
        v29 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v29 = v28;
      if (!v29)
      {
        v30 = 0;
        goto LABEL_39;
      }
      v30 = (char *)*((_QWORD *)this + 47);
      v31 = &v30[8 * v29];
      if (v31 <= (char *)this + 376)
      {
        *((_QWORD *)this + 47) = v31;
        goto LABEL_39;
      }
      if (!(v29 >> 61))
      {
        v30 = (char *)operator new(8 * v29);
LABEL_39:
        v32 = &v30[8 * v26];
        *(_QWORD *)v32 = a3;
        v33 = v32;
        while (v23 != v25)
        {
          v34 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *((_QWORD *)v33 - 1) = v34;
          v33 -= 8;
        }
        v24 = v32 + 8;
        *((_QWORD *)this + 36) = v33;
        *((_QWORD *)this + 37) = v32 + 8;
        *((_QWORD *)this + 38) = &v30[8 * v29];
        if (v25)
        {
          if ((char *)this + 312 > v25 || (v35 = (void **)((char *)this + 376), (char *)this + 376 <= v25))
          {
            operator delete(v25);
          }
          else if (&v25[v27] == *v35)
          {
            *v35 = v25;
          }
        }
        goto LABEL_48;
      }
LABEL_51:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_50:
    abort();
  }
  return a3;
}

uint64_t OpenTypeReorderingOutput::reset(uint64_t this, uint64_t a2)
{
  ++*(_QWORD *)(this + 48);
  *(_QWORD *)(this + 24) = a2;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,8ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v3;
  BOOL v4;
  BOOL v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    v3 = v1 + 7;
    if (v1 + 3 <= v2)
    {
      v4 = v3 >= v2;
      v5 = v3 == v2;
    }
    else
    {
      v4 = 0;
      v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[7])
        *v3 = v2;
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<unsigned int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  std::__compressed_pair<unsigned int *> *p_end_cap;
  unsigned int *v5;
  unsigned int *value;
  unsigned int *end;
  std::vector<unsigned int>::pointer begin;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  unsigned int *v16;
  unsigned int *v17;
  int v18;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begin = this->__begin_;
    v9 = (char *)end - (char *)this->__begin_;
    v10 = __n + (v9 >> 2);
    if (v10 >> 62)
      abort();
    v11 = v9 >> 2;
    v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)p_end_cap, v13);
      begin = this->__begin_;
      end = this->__end_;
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = (unsigned int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    v17 = (unsigned int *)&v15[4 * __n];
    while (end != begin)
    {
      v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<unsigned int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
      operator delete(begin);
  }
}

void OpenTypeShapingEngine::OpenTypeShapingEngine(OpenTypeShapingEngine *this, const TCharStream *a2, TRunGlue *a3)
{
  uint64_t **v4;
  _QWORD *v5;
  uint64_t v6;
  TRunGlue *v8;
  unint64_t v9;
  TRunGlue *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t StringIndex;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t *v30;

  *(_QWORD *)this = off_1E15DDEA8;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = a2;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 22) = (char *)this + 56;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 23) = (char *)this + 192;
  v4 = (uint64_t **)((char *)this + 184);
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  v5 = (_QWORD *)((char *)this + 208);
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 59) = (char *)this + 232;
  v6 = *((_QWORD *)a3 + 5);
  if (v6 == -1)
  {
    TRunGlue::ComputeEndIndex(a3);
    v6 = *((_QWORD *)a3 + 5);
    a2 = (const TCharStream *)*((_QWORD *)this + 2);
  }
  *((_QWORD *)this + 60) = v6;
  *((_BYTE *)this + 488) = 0;
  if (a2)
  {
    *((_BYTE *)this + 488) = TRunGlue::FilterSurrogates(*((TRunGlue **)this + 1), (uint64_t)a2, 0);
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    v8 = (TRunGlue *)*((_QWORD *)this + 1);
    v17 = *((_QWORD *)this + 2);
    v18 = 0u;
    v19 = 0u;
    v20 = 0u;
    v21 = 0u;
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v29 = 0;
    *(_QWORD *)&v28 = *(_QWORD *)(v17 + 16);
    v9 = TRunGlue::length(v8);
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::resize((uint64_t)this + 32, v9);
    std::vector<long,TInlineBufferAllocator<long,30ul>>::resize((uint64_t)v5, v9);
    v10 = (TRunGlue *)*((_QWORD *)this + 1);
    v11 = TRunGlue::length(v10);
    if (v11)
    {
      v12 = v11;
      for (i = 0; i != v12; ++i)
      {
        StringIndex = TRunGlue::GetStringIndex(v10, i);
        v16 = StringIndex;
        if (*((_BYTE *)this + 488))
        {
          v15 = StringIndex - *((_QWORD *)this + 60);
          v30 = &v15;
          std::__tree<std::__value_type<long,long>,std::__map_value_compare<long,std::__value_type<long,long>,std::less<long>,true>,std::allocator<std::__value_type<long,long>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(v4, &v15, (uint64_t)&std::piecewise_construct, &v30)[5] = i;
        }
        *(_QWORD *)(*v5 + 8 * i) = i;
        *(_DWORD *)(*((_QWORD *)this + 4) + 4 * i) = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v17, &v16, 0);
      }
    }
  }
}

void OpenTypeShapingEngine::~OpenTypeShapingEngine(OpenTypeShapingEngine *this)
{
  void **v2;

  *(_QWORD *)this = off_1E15DDEA8;
  v2 = (void **)((char *)this + 208);
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)this + 184, *((_QWORD **)this + 24));
  v2 = (void **)((char *)this + 32);
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t OpenTypeShapingEngine::ApplyScriptShaping(OpenTypeShapingEngine *this, unsigned int *a2)
{
  TRunGlue *v3;
  int64_t v5;
  uint64_t v6;
  OpenTypeReorderingOutput *v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  CFIndex v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t StringIndex;
  unint64_t v19;
  int GlyphProps;
  uint64_t v21;
  TRunGlue *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int64_t v28;
  CFIndex v29;
  uint64_t v30;
  uint64_t v31;
  TRunGlue *v33;
  uint64_t v34;
  OpenTypeReorderingOutput *v35;
  unint64_t v36;
  unint64_t v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  unint64_t v42;
  char *v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  OpenTypeReorderingOutput *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  int v54;
  uint64_t v55;
  OpenTypeReorderingOutput *v56;
  CFRange v57;

  v3 = (TRunGlue *)*((_QWORD *)this + 1);
  if ((*((_DWORD *)v3 + 6) & 0x80000000) != 0
    || *((_QWORD *)this + 4) == *((_QWORD *)this + 5)
    || *((_QWORD *)this + 26) == *((_QWORD *)this + 27))
  {
    v9 = 0;
    return v9 & 1;
  }
  v5 = TRunGlue::length(v3);
  v6 = *(_QWORD *)(*((_QWORD *)this + 1) + 104);
  *((_QWORD *)this + 3) = v6;
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::resize(v6, v5);
  v56 = (OpenTypeReorderingOutput *)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(OpenTypeReorderingOutput **__return_ptr, OpenTypeShapingEngine *, unsigned int *))(*(_QWORD *)this + 16))(&v56, this, a2);
  OpenTypeReorderingOutput::finalizeOutput(v56);
  v7 = v56;
  v8 = *((_QWORD *)v56 + 8) - *((_QWORD *)v56 + 7);
  if (v8 >> 2 < v5)
  {
    v9 = 0;
    v11 = 0;
    v49 = *((_QWORD *)this + 1);
    goto LABEL_72;
  }
  if (v8 < 1)
  {
    v9 = 0;
    goto LABEL_65;
  }
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if (v8 >> 2 <= 1)
    v12 = 1;
  else
    v12 = v8 >> 2;
  v55 = v12;
  while (1)
  {
    v13 = *((_QWORD *)v7 + 10);
    if (v11 >= (unint64_t)((*((_QWORD *)v7 + 11) - v13) >> 3))
    {
      v14 = -1;
    }
    else
    {
      v14 = *(_QWORD *)(v13 + 8 * v11);
      if ((unint64_t)v14 >> 61)
      {
        v16 = (char *)v7 + 288;
        v15 = *((_QWORD *)v7 + 36);
        if ((v14 & 0x1FFFFFFFFFFFFFFFuLL) < (*((_QWORD *)v16 + 1) - v15) >> 3)
          v14 = *(_QWORD *)(v15 + 8 * v14);
      }
    }
    if (v14 >= v5)
      break;
    v17 = *(_QWORD *)(*((_QWORD *)this + 26) + 8 * v14);
    StringIndex = TRunGlue::GetStringIndex(*((TRunGlue **)this + 1), v17);
    v19 = *(_QWORD *)(*((_QWORD *)v56 + 10) + 8 * v11);
    if ((v19 & 0x8000000000000000) != 0)
    {
      GlyphProps = TRunGlue::GetGlyphProps(*((TRunGlue **)this + 1), v17);
      v21 = *(_QWORD *)(*((_QWORD *)v56 + 10) + 8 * v11);
      v57.location = v11;
      v57.length = 1;
      TRunGlue::InsertGlyphs(*((TRunGlue **)this + 1), v57);
      v22 = (TRunGlue *)*((_QWORD *)this + 1);
      v23 = *((_QWORD *)v22 + 19);
      if (v23)
        *(_DWORD *)(v23 + 256) = 2;
      v24 = v10++;
      if ((v21 & 0x2000000000000000) != 0)
      {
        if (v11 <= 1)
          v25 = 1;
        else
          v25 = v11;
        v26 = v25 - 1;
        if ((TRunGlue::GetGlyphProps(v22, v25 - 1) & 0x300) == 0)
        {
          v27 = GlyphProps | 0x80u;
          goto LABEL_34;
        }
      }
      else
      {
        v54 = GlyphProps;
        v28 = v5;
        v29 = v10 + v5;
        v26 = v11;
        if (v11 + 1 >= v29)
        {
          v5 = v28;
          v26 = v24 + v28;
        }
        else
        {
          do
          {
            v30 = TRunGlue::GetStringIndex(*((TRunGlue **)this + 1), v26 + 1);
            v31 = v26 + 2;
            ++v26;
          }
          while (v30 != StringIndex && v31 < v29);
          v22 = (TRunGlue *)*((_QWORD *)this + 1);
          v5 = v28;
        }
        v27 = v54 | 0x80u;
LABEL_34:
        TRunGlue::SetGlyphProps(v22, v26, v27);
      }
      OpenTypeShapingEngine::AdjustIndices((uint64_t *)this, v11 + 1, v10 + v5);
      v9 = 1;
      v12 = v55;
      goto LABEL_36;
    }
    if (v17 > v11)
    {
      TRunGlue::Rotate(*((TRunGlue **)this + 1), v11, v17, v17 + 1, 0);
      OpenTypeShapingEngine::AdjustIndices((uint64_t *)this, v11 + 1, v17 + 1);
      v9 = 1;
    }
LABEL_36:
    v33 = (TRunGlue *)*((_QWORD *)this + 1);
    if (!(v19 >> 61))
    {
      if (v11 == v17)
        TRunGlue::ClearGlyphCombiningMark(*((_QWORD **)this + 1), v11);
      goto LABEL_59;
    }
    v34 = TRunGlue::GetGlyphProps(*((TRunGlue **)this + 1), v11);
    if ((v34 & 0x80) == 0)
    {
      v35 = v56;
LABEL_39:
      v36 = *(_QWORD *)(*((_QWORD *)v35 + 10) + 8 * v11);
      v37 = v36 >> 61;
      if (v36 >> 61)
      {
        v39 = *((_QWORD *)v35 + 36);
        if ((v36 & 0x1FFFFFFFFFFFFFFFLL) < (*((_QWORD *)v35 + 37) - v39) >> 3)
          v36 = *(_QWORD *)(v39 + 8 * v36);
        LODWORD(v37) = 512;
        v38 = -129;
      }
      else
      {
        v38 = -1;
      }
      TRunGlue::SetGlyphProps(v33, v11, v37 | v34 & 0xFF0000 | *(_DWORD *)(*((_QWORD *)v35 + 22) + 4 * v36) & v38);
      goto LABEL_50;
    }
    if ((v19 & 0x8000000000000000) != 0)
    {
      v35 = v56;
      if (*(_DWORD *)(*((_QWORD *)v56 + 7) + 4 * v11) == 9676)
        goto LABEL_39;
    }
LABEL_50:
    TRunGlue::SetStringIndex(v33, v11, StringIndex);
    TRunGlue::SetAttachmentCount(v33, v11, (*(_DWORD *)(*((_QWORD *)v56 + 7) + 4 * v11) - 0x10000) < 0x100000);
    v40 = *(_QWORD *)(*((_QWORD *)v56 + 10) + 8 * v11);
    if (v40 >> 61 && (v40 & 0x1FFFFFFFFFFFFFFFLL) < (uint64_t)(*((_QWORD *)v56 + 29) - *((_QWORD *)v56 + 28)) >> 2)
    {
      v41 = (char *)v56 + 384;
      v40 &= 0x1FFFFFFFFFFFFFFFuLL;
    }
    else
    {
      v41 = (char *)v56 + 152;
    }
    TRunGlue::SetGlyphID<true>(v33, v11, *(unsigned __int16 *)(*(_QWORD *)v41 + 2 * v40));
    v42 = *(_QWORD *)(*((_QWORD *)v56 + 10) + 8 * v11);
    if (v42 >> 61 && (v42 & 0x1FFFFFFFFFFFFFFFLL) < (uint64_t)(*((_QWORD *)v56 + 29) - *((_QWORD *)v56 + 28)) >> 2)
    {
      v43 = (char *)v56 + 408;
      v42 &= 0x1FFFFFFFFFFFFFFFuLL;
    }
    else
    {
      v43 = (char *)v56 + 200;
    }
    TRunGlue::SetAdvance(v33, v11, *(CGSize *)(*(_QWORD *)v43 + 16 * v42));
    TRunGlue::SetOrigin(v33, v11, *MEMORY[0x1E0C9D538]);
LABEL_59:
    v44 = (uint64_t *)(*((_QWORD *)v56 + 16) + 16 * v11);
    v45 = *v44;
    v46 = **((_QWORD **)v33 + 13) + 16 * v11;
    *(_QWORD *)v46 = v44[1];
    v7 = v56;
    *(_DWORD *)(v46 + 8) = *(_DWORD *)(*((_QWORD *)v56 + 13) + 4 * v11);
    *(_DWORD *)(v46 + 12) = v45;
    if (++v11 == v12)
      goto LABEL_65;
  }
  v49 = *((_QWORD *)this + 1);
  if ((v9 & 1) != 0)
  {
    v50 = *(_QWORD *)(v49 + 152);
    if (v50)
      *(_DWORD *)(v50 + 256) = 2;
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
LABEL_72:
  v51 = TRunGlue::length((TRunGlue *)v49);
  v52 = v51 - v11;
  if (v51 > v11)
  {
    v53 = (_QWORD *)(**(_QWORD **)(v49 + 104) + 16 * v11);
    do
    {
      *v53 = 0;
      v53 += 2;
      --v52;
    }
    while (v52);
  }
LABEL_65:
  v48 = v56;
  v56 = 0;
  if (v48)
    (*(void (**)(OpenTypeReorderingOutput *))(*(_QWORD *)v48 + 8))(v48);
  return v9 & 1;
}

uint64_t *OpenTypeShapingEngine::AdjustIndices(uint64_t *this, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t v12;
  uint64_t *v13;

  if (a2 < a3)
  {
    v4 = a2;
    v5 = (uint64_t)this;
    v6 = (uint64_t **)(this + 23);
    v7 = (uint64_t **)(this + 24);
    do
    {
      this = (uint64_t *)TRunGlue::GetStringIndex(*(TRunGlue **)(v5 + 8), v4);
      v8 = (uint64_t)this - *(_QWORD *)(v5 + 480);
      if (*(_BYTE *)(v5 + 488))
      {
        v9 = *v7;
        v10 = v7;
        v11 = v7;
        if (*v7)
        {
          while (1)
          {
            while (1)
            {
              v11 = (uint64_t **)v9;
              v12 = v9[4];
              if (v12 <= v8)
                break;
              v9 = *v11;
              v10 = v11;
              if (!*v11)
                goto LABEL_11;
            }
            if (v12 >= v8)
              break;
            v9 = v11[1];
            if (!v9)
            {
              v10 = v11 + 1;
              goto LABEL_11;
            }
          }
        }
        else
        {
LABEL_11:
          v13 = (uint64_t *)operator new(0x30uLL);
          v13[4] = v8;
          v13[5] = 0;
          this = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__insert_node_at(v6, (uint64_t)v11, v10, v13);
          v11 = (uint64_t **)v13;
        }
        v8 = (uint64_t)v11[5];
      }
      ++*(_QWORD *)(*(_QWORD *)(v5 + 208) + 8 * v8);
      ++v4;
    }
    while (v4 != a3);
  }
  return this;
}

uint64_t OpenTypeShapingEngine::SetSafeToBreakAfterEachSyllable(uint64_t this)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  CFRange v6;
  CFIndex v7;
  CFIndex v8;
  int *v9;
  int v10;

  v1 = *(uint64_t **)(this + 24);
  if (v1)
  {
    v2 = this;
    if (*(_QWORD *)(*(_QWORD *)(this + 8) + 152))
    {
      v3 = *v1;
      if (*v1)
      {
        v4 = v1[1];
        v5 = (v4 - v3) >> 4;
        if (v4 - v3 < 1)
        {
          v6.location = 0;
        }
        else
        {
          v6.location = 0;
          v7 = 0;
          v8 = 0;
          do
          {
            v9 = (int *)(v3 + 28 + 16 * v7);
            while (++v8 < v5)
            {
              v10 = *v9;
              v9 += 4;
              if (v10 != *(_DWORD *)(v3 + 16 * v7 + 12))
              {
                v6.length = v8 - v6.location;
                this = TRunGlue::ClearSafeToBreakAfter(*(_QWORD *)(v2 + 8), v6);
                v6.location = v8;
                goto LABEL_11;
              }
            }
            v8 = v7 + 1;
LABEL_11:
            v7 = v8;
          }
          while (v8 < v5);
        }
        if (v4 != v3)
        {
          v6.length = v5 - v6.location;
          return TRunGlue::ClearSafeToBreakAfter(*(_QWORD *)(v2 + 8), v6);
        }
      }
    }
  }
  return this;
}

uint64_t *std::__tree<std::__value_type<long,long>,std::__map_value_compare<long,std::__value_type<long,long>,std::less<long>,true>,std::allocator<std::__value_type<long,long>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void OpenTypeClassTable::AddShapingGlyphs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  char *v9;
  __int16 *v10;
  __int16 *v11;
  __int16 **v12;
  __int16 *v13;
  void *v14;
  uint64_t v15;
  _OWORD v16[4];
  _OWORD *v17;
  uint64_t v18;

  v5 = 0;
  v18 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int16 *)(a1 + 8);
  v7 = *(unsigned __int16 *)(a1 + 10) - v6;
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[2] = v8;
  v16[3] = v8;
  v16[0] = v8;
  v16[1] = v8;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  v17 = v16;
  if (v7 != -1)
  {
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v13, v7 + 1);
    v9 = (char *)v14;
    bzero(v14, 2 * v7 + 2);
    v14 = &v9[2 * v7 + 2];
    v5 = v13;
  }
  (*(void (**)(_QWORD, uint64_t, uint64_t, __int16 *))(**(_QWORD **)(a2 + 400) + 672))(*(_QWORD *)(a2 + 400), v6, v7 + 1, v5);
  v10 = v13;
  v11 = (__int16 *)v14;
  while (v10 != v11)
  {
    if (*v10)
      std::function<void ()(unsigned short,unsigned short)>::operator()(a3, *v10, *v10);
    ++v10;
  }
  v12 = &v13;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v12);
}

void TRubyAnnotation::TRubyAnnotation(TRubyAnnotation *this, CTRubyAlignment a2, CTRubyOverhang a3, CTRubyPosition a4, __CFString *a5, id a6)
{
  uint64_t v8;
  const __CFString *v9;

  *(_BYTE *)this = a2;
  *((_BYTE *)this + 1) = a3;
  *((_QWORD *)this + 1) = 0x3FE0000000000000;
  *((_BYTE *)this + 48) = a4;
  *((_QWORD *)this + 7) = 0;
  v8 = 0;
  *((_QWORD *)this + 8) = a6;
  *((_WORD *)this + 36) = 256;
  do
  {
    if (v8 == *((unsigned __int8 *)this + 48))
      v9 = a5;
    else
      v9 = 0;
    *((_QWORD *)this + v8++ + 2) = v9;
  }
  while (v8 != 4);
  TRubyAnnotation::SetExtrasForTextAttributes(this);
}

void TRubyAnnotation::SetExtrasForTextAttributes(TRubyAnnotation *this)
{
  void *v2;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const __CFNumber *Value;
  void *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFBoolean *v9;
  void *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  const __CFBoolean *v13;

  v2 = (void *)atomic_load((unint64_t *)this + 8);
  v3 = v2;
  if (v3)
  {
    v4 = v3;
    Value = (const __CFNumber *)CFDictionaryGetValue(v3, CFSTR("CTRubyAnnotationSizeFactor"));

    if (Value)
      CFNumberGetValue(Value, kCFNumberDoubleType, (char *)this + 8);
  }
  else
  {

  }
  v6 = (void *)atomic_load((unint64_t *)this + 8);
  v7 = v6;
  if (v7)
  {
    v8 = v7;
    v9 = (const __CFBoolean *)CFDictionaryGetValue(v7, CFSTR("CTRubyAnnotationScaleToFit"));

    if (v9)
      *((_BYTE *)this + 72) = CFBooleanGetValue(v9) != 0;
  }
  else
  {

  }
  v10 = (void *)atomic_load((unint64_t *)this + 8);
  v11 = v10;
  if (v11)
  {
    v12 = v11;
    v13 = (const __CFBoolean *)CFDictionaryGetValue(v11, CFSTR("CTRubyAnnotationDrawBaseText"));

    if (v13)
      *((_BYTE *)this + 73) = CFBooleanGetValue(v13) != 0;
  }
  else
  {

  }
}

void TRubyAnnotation::TRubyAnnotation(TRubyAnnotation *this, CTRubyAlignment a2, CTRubyOverhang a3, CTRubyPosition a4, id a5)
{
  *(_BYTE *)this = a2;
  *((_BYTE *)this + 1) = a3;
  *((_QWORD *)this + 1) = 0x3FE0000000000000;
  *((_BYTE *)this + 48) = a4;
  *((_QWORD *)this + 7) = a5;
  *((_QWORD *)this + 8) = CFAttributedStringGetAttributes((CFAttributedStringRef)a5, 0, 0);
  *((_WORD *)this + 36) = 256;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  TRubyAnnotation::SetExtrasForTextAttributes(this);
}

void TRubyAnnotation::TRubyAnnotation(TRubyAnnotation *this, CFTypeRef cf)
{
  unint64_t *v4;
  CFTypeID v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;

  *(_WORD *)this = 0;
  *((_QWORD *)this + 1) = 0x3FE0000000000000;
  *((_BYTE *)this + 48) = 0;
  *((_QWORD *)this + 7) = 0;
  v4 = (unint64_t *)((char *)this + 56);
  *((_QWORD *)this + 8) = 0;
  *((_WORD *)this + 36) = 256;
  v5 = CFGetTypeID(cf);
  if (TCFBase<TRubyAnnotation>::GetTypeID(void)::once != -1)
    dispatch_once_f(&TCFBase<TRubyAnnotation>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TRubyAnnotation>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  if (v5 == TCFBase<TRubyAnnotation>::fTypeID)
  {
    v6 = *((_QWORD *)cf + 5);
    *(_WORD *)this = *(_WORD *)v6;
    *((_QWORD *)this + 1) = *(_QWORD *)(v6 + 8);
    *((_BYTE *)this + 48) = *(_BYTE *)(v6 + 48);
    v7 = (void *)atomic_load((unint64_t *)(v6 + 56));
    TCFRef<__CTFont const*>::Retain(v4, v7);
    v8 = (void *)atomic_load((unint64_t *)(v6 + 64));
    TCFRef<__CTFont const*>::Retain((unint64_t *)this + 8, v8);
    v9 = 0;
    *((_WORD *)this + 36) = *(_WORD *)(v6 + 72);
    do
    {
      *(_QWORD *)((char *)this + v9 + 16) = *(id *)(v6 + 16 + v9);
      v9 += 8;
    }
    while (v9 != 32);
  }
  else
  {
    *((_OWORD *)this + 1) = 0u;
    *((_OWORD *)this + 2) = 0u;
  }
}

void TRubyAnnotation::TRubyAnnotation(TRubyAnnotation *this, const TRubyAnnotation *a2)
{
  void *v4;
  void *v5;
  uint64_t i;

  *(_WORD *)this = *(_WORD *)a2;
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  *((_BYTE *)this + 48) = *((_BYTE *)a2 + 48);
  v4 = (void *)atomic_load((unint64_t *)a2 + 7);
  *((_QWORD *)this + 7) = v4;
  v5 = (void *)atomic_load((unint64_t *)a2 + 8);
  *((_QWORD *)this + 8) = v5;
  *((_WORD *)this + 36) = *((_WORD *)a2 + 36);
  for (i = 16; i != 48; i += 8)
    *(_QWORD *)((char *)this + i) = *(id *)((char *)a2 + i);
}

void TRubyAnnotation::~TRubyAnnotation(id *this)
{
  uint64_t i;

  for (i = 2; i != 6; ++i)

}

CFHashCode TRubyAnnotation::Hash(TRubyAnnotation *this)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  char *v6;
  const void *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  const void *v12;

  v2 = 0;
  v4 = *((_QWORD *)this + 1) + 2654435769;
  if (*((double *)this + 1) == 0.0)
    v4 = 2654435769;
  v3 = (*((unsigned __int8 *)this + 1)
      + ((*(unsigned __int8 *)this + 2654435769) << 6)
      + (((unint64_t)*(unsigned __int8 *)this + 2654435769u) >> 2)
      + 2654435769u) ^ (*(unsigned __int8 *)this + 2654435769);
  v5 = (v4 + (v3 << 6) + (v3 >> 2)) ^ v3;
  v6 = (char *)this + 16;
  do
  {
    v7 = *(const void **)&v6[v2];
    if (v7)
      v5 ^= (v5 << 6) + 2654435769u + (v5 >> 2) + CFHash(v7);
    v2 += 8;
  }
  while (v2 != 32);
  v8 = (unint64_t *)((char *)this + 56);
  v9 = atomic_load((unint64_t *)this + 7);
  if (v9 || (v8 = (unint64_t *)((char *)this + 64), (v10 = atomic_load((unint64_t *)this + 8)) != 0))
  {
    v11 = ((v5 << 6) + 2654435769u + (v5 >> 2) + *((unsigned __int8 *)this + 48)) ^ v5;
    v12 = (const void *)atomic_load(v8);
    return (CFHash(v12) + 2654435769u + (v11 << 6) + (v11 >> 2)) ^ v11;
  }
  return v5;
}

void ThaiClassTable::~ThaiClassTable(ThaiClassTable *this)
{
  JUMPOUT(0x186DC03ACLL);
}

void ThaiShapingEngine::SetFeatures(ThaiShapingEngine *this@<X0>, unsigned int *a2@<X1>, OpenTypeReorderingOutput **a3@<X8>)
{
  ThaiShapingEngine *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  OpenTypeReorderingOutput *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  ThaiShapingEngine *v30;
  char v31;

  v4 = this;
  v5 = (*(uint64_t (**)(ThaiShapingEngine *))(*(_QWORD *)this + 24))(this);
  v6 = v5;
  v7 = *(unsigned __int16 *)(v5 + 24);
  v8 = *(unsigned __int16 *)(v5 + 8);
  v26 = v7;
  if (v8 <= v7 && *(unsigned __int16 *)(v5 + 10) >= v7)
    v27 = *(unsigned __int16 *)(*(_QWORD *)(v5 + 16) + 4 * (v7 - v8) + 2) << 16;
  else
    v27 = 0;
  v28 = *(unsigned __int16 *)(v5 + 26);
  *a2 = 0;
  v9 = (OpenTypeReorderingOutput *)operator new();
  OpenTypeReorderingOutput::OpenTypeReorderingOutput(v9, *((TRunGlue **)v4 + 1));
  v10 = TRunGlue::length(*((TRunGlue **)v4 + 1));
  if (v10 >= 1)
  {
    v11 = v10;
    v12 = 0;
    v31 = 0;
    v13 = 0;
    v14 = 1;
    v30 = v4;
    do
    {
      v15 = *((_QWORD *)v4 + 4);
      v16 = *(unsigned __int16 *)(v15 + 4 * v12);
      v17 = *(unsigned __int16 *)(v6 + 8);
      if (v16 >= v17 && (v18 = *(unsigned __int16 *)(v6 + 10), v16 <= v18))
      {
        v21 = *(_QWORD *)(v6 + 16);
        v19 = *(_DWORD *)(v21 + 4 * (v16 - v17));
        if ((v19 & 0xFFFF0000) != 0)
        {
          if ((*(_DWORD *)(v21 + 4 * (v16 - v17)) & 0xFFFC) == 4)
          {
            v22 = v14;
            do
            {
              if (v22 >= v11)
                break;
              v23 = *(unsigned __int16 *)(v15 + 4 * v22);
              if (v23 < v17 || v23 > v18)
                break;
              v25 = *(unsigned __int16 *)(v21 + 4 * (v23 - v17));
              if (!((v25 != 10) | v31 & 1))
              {
                OpenTypeReorderingOutput::writeChar(v9, v26, v12, &features, 10, 0x8000000000000000);
                v31 = 1;
                break;
              }
              ++v22;
            }
            while ((v25 & 0xFFFC) == 4);
          }
          v13 |= v19 & 0xFFFF0000;
          OpenTypeReorderingOutput::writeChar(v9, v16, v12, &features, v19, 0);
          v4 = v30;
          goto LABEL_11;
        }
        if (v19 == 10)
        {
          if ((v13 & v27) != 0 && (!v12 || *(_DWORD *)(v15 + 4 * v12 - 4) != 9676))
            OpenTypeReorderingOutput::writeChar(v9, 9676, v12, &features, 1, 0x8000000000000000);
          v4 = v30;
          if ((v31 & 1) != 0)
          {
            v31 = 0;
            v20 = 0x4000000000000000;
            v19 = 10;
          }
          else
          {
            v19 = 10;
            OpenTypeReorderingOutput::writeChar(v9, v26, v12, &features, 10, 0x8000000000000000);
            v31 = 0;
            v20 = 0x4000000000000000;
          }
          v16 = v28;
        }
        else
        {
          v20 = 0;
          v4 = v30;
        }
      }
      else
      {
        v19 = 0;
        v20 = 0;
      }
      OpenTypeReorderingOutput::writeChar(v9, v16, v12, &features, v19, v20);
      v13 = 0;
LABEL_11:
      ++v12;
      ++v14;
    }
    while (v12 != v11);
  }
  *a3 = v9;
}

uint64_t *ThaiShapingEngine::GetClassTable(ThaiShapingEngine *this)
{
  GetThaiClassTable();
  return &GetThaiClassTable(void)::thaiClassTable;
}

uint64_t *GetThaiClassTable(void)
{
  unsigned __int8 v0;

  {
    qword_1EDD17368 = 243207680;
    unk_1EDD17370 = &thaiCharClasses;
    GetThaiClassTable(void)::thaiClassTable = (uint64_t)&off_1E15DD7B8;
    dword_1EDD17378 = 238161485;
  }
  return &GetThaiClassTable(void)::thaiClassTable;
}

void ThaiShapingEngine::~ThaiShapingEngine(ThaiShapingEngine *this)
{
  OpenTypeShapingEngine::~OpenTypeShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

unint64_t CTCreatePathMaskedByLines(const CGPath *a1, const __CFArray *a2, uint64_t a3, CGFloat a4)
{
  const CGPath *CopyByStrokingPath;
  CGPath *Mutable;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  double *v12;
  TLine *v13;
  CGFloat v14;
  CGFloat v15;
  __int128 v16;
  const CGPath *v17;
  unint64_t v18;
  id v20;
  CGAffineTransform m;

  if (!a3)
    return 0;
  CopyByStrokingPath = CGPathCreateCopyByStrokingPath(a1, 0, a4, kCGLineCapButt, kCGLineJoinMiter, 10.0);
  Mutable = CGPathCreateMutable();
  Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    v10 = Count;
    v11 = 0;
    v12 = (double *)(a3 + 8);
    do
    {
      v13 = (TLine *)*((_QWORD *)CFArrayGetValueAtIndex(a2, v11) + 5);
      v14 = *(v12 - 1);
      v15 = *v12;
      *(_QWORD *)&v16 = -1;
      *((_QWORD *)&v16 + 1) = -1;
      *(_OWORD *)&m.c = v16;
      *(_OWORD *)&m.tx = v16;
      *(_OWORD *)&m.a = v16;
      CGAffineTransformMakeTranslation(&m, v14, v15);
      TLine::CopyPath(v13, (unint64_t *)&v20);
      v17 = (const CGPath *)atomic_load((unint64_t *)&v20);
      CGPathAddPath(Mutable, &m, v17);

      ++v11;
      v12 += 2;
    }
    while (v10 != v11);
  }
  m.a = -3.72066208e-103;
  CreateMaskedPath(CopyByStrokingPath, Mutable, a4, 0, 0, (unint64_t *)&m);
  do
    v18 = __ldaxr((unint64_t *)&m);
  while (__stlxr(0, (unint64_t *)&m));

  return v18;
}

uint64_t *LaoShapingEngine::GetClassTable(LaoShapingEngine *this)
{
  GetLaoClassTable();
  return &GetLaoClassTable(void)::laoClassTable;
}

uint64_t *GetLaoClassTable(void)
{
  unsigned __int8 v0;

  {
    qword_1EDD17270 = 251596416;
    unk_1EDD17278 = &laoCharClasses;
    GetLaoClassTable(void)::laoClassTable = (uint64_t)&off_1E15DD7B8;
    dword_1EDD17280 = 246550221;
  }
  return &GetLaoClassTable(void)::laoClassTable;
}

void LaoShapingEngine::~LaoShapingEngine(LaoShapingEngine *this)
{
  OpenTypeShapingEngine::~OpenTypeShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

uint64_t KhmerShapingEngine::IsRequiredPresentationFeature(KhmerShapingEngine *this)
{
  return 1;
}

uint64_t KhmerShapingEngine::SetFeatures@<X0>(TRunGlue **this@<X0>, char *a2@<X1>, OpenTypeReorderingOutput **a3@<X8>)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  TRunGlue *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  int v27;
  unsigned int v28;
  OpenTypeReorderingOutput *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  TRunGlue *v36;
  int v37;
  uint64_t v39;
  TRunGlue *v40;
  int v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  int v47;
  int v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  OpenTypeReorderingOutput *v64;
  uint64_t v65;
  const unsigned int *v66;
  int v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v72;
  unint64_t v73;
  OpenTypeReorderingOutput *v74;

  v5 = (*((uint64_t (**)(TRunGlue **))*this + 3))(this);
  strcpy(a2, "ferpfwlbfvbaftsprafc");
  a2[21] = 0;
  *((_WORD *)a2 + 11) = 0;
  v74 = (OpenTypeReorderingOutput *)operator new();
  OpenTypeReorderingOutput::OpenTypeReorderingOutput(v74, this[1]);
  result = TRunGlue::length(this[1]);
  if (result >= 1)
  {
    v7 = 0;
    v72 = result;
    while (1)
    {
      v8 = 0;
      v9 = v7;
      v10 = v7 + 31;
      if (v7 + 31 >= result)
        v10 = result;
      if (v7 <= v10)
        v7 = v10;
      v11 = v9;
      while (v7 != v11)
      {
        if ((unsigned __int16)*((_DWORD *)this[4] + v11) - 8204 >= 2)
        {
          v13 = (unsigned __int16)*((_DWORD *)this[4] + v11);
          if (v13 == 9676)
          {
            v12 = 1;
          }
          else
          {
            v14 = *(unsigned __int16 *)(v5 + 8);
            if (v14 <= v13 && *(unsigned __int16 *)(v5 + 10) >= v13)
              v12 = *(unsigned __int16 *)(*(_QWORD *)(v5 + 16) + 4
                                                               * ((unsigned __int16)*((_DWORD *)this[4] + v11) - v14));
            else
              v12 = 0;
          }
        }
        else
        {
          v12 = 4;
        }
        v15 = khmerStateTable[12 * v8 + v12];
        ++v11;
        v8 = v15;
        if (v15 < 0)
        {
          v7 = v15 + v11;
          break;
        }
      }
      (*(void (**)(OpenTypeReorderingOutput *, uint64_t))(*(_QWORD *)v74 + 16))(v74, v9);
      if (v9 >= v7)
      {
        v16 = 0;
        v18 = -1;
        goto LABEL_66;
      }
      v16 = 0;
      v17 = this[4];
      v18 = -1;
      v19 = v9;
      while (1)
      {
        v20 = *((_DWORD *)v17 + v19);
        if ((unsigned __int16)v20 - 8204 >= 2 && (unsigned __int16)v20 != 9676)
        {
          v23 = *(unsigned __int16 *)(v5 + 8);
          if (v23 <= (unsigned __int16)v20)
          {
            v24 = *(unsigned __int16 *)(v5 + 10);
            if (v24 >= (unsigned __int16)v20)
              break;
          }
        }
        v22 = v19 + 1;
LABEL_27:
        v19 = v22;
        if (v22 == v7)
          goto LABEL_48;
      }
      v25 = *(_QWORD *)(v5 + 16);
      v26 = *(_DWORD *)(v25 + 4 * ((unsigned __int16)v20 - v23));
      if ((v26 & 0x2000000) != 0)
      {
        v29 = v74;
        v20 = 6081;
        v30 = 0x8000000000000000;
        goto LABEL_47;
      }
      if ((v26 & 0x80000) == 0)
      {
        v22 = v19 + 1;
        if ((v26 & 0x8000000) != 0 && v22 < v7)
        {
          if ((unsigned __int16)*((_DWORD *)v17 + v22) - 8204 >= 2)
          {
            v28 = (unsigned __int16)*((_DWORD *)v17 + v22);
            if (v28 == 9676)
            {
              v27 = 1;
            }
            else
            {
              v27 = 0;
              if (v23 <= v28 && v24 >= v28)
                v27 = *(_DWORD *)(v25 + 4 * ((unsigned __int16)*((_DWORD *)v17 + v22) - v23));
            }
          }
          else
          {
            v27 = 4;
          }
          if ((v27 & 0x1000000) != 0)
          {
            v16 = 2;
            v18 = v19;
          }
        }
        goto LABEL_27;
      }
      v29 = v74;
      v30 = 0;
LABEL_47:
      OpenTypeReorderingOutput::writeChar(v29, v20, v19, (const unsigned int *)"ferpfwlbfvbaftsp", v26, v30);
LABEL_48:
      if (v18 != -1)
      {
        if ((unsigned __int16)v18 - 8204 >= 2)
        {
          if ((unsigned __int16)v18 == 9676)
          {
            v31 = 1;
          }
          else
          {
            v32 = *(unsigned __int16 *)(v5 + 8);
            if (v32 <= (unsigned __int16)v18
              && *(unsigned __int16 *)(v5 + 10) >= (unsigned __int16)v18)
            {
              v31 = *(_DWORD *)(*(_QWORD *)(v5 + 16) + 4 * ((unsigned __int16)v18 - v32));
            }
            else
            {
              v31 = 0;
            }
          }
        }
        else
        {
          v31 = 4;
        }
        OpenTypeReorderingOutput::writeChar(v74, 6098, v18, (const unsigned int *)"ferpfwlbfvbaftsp", v31, 0);
        if ((unsigned __int16)(v18 + 1) - 8204 >= 2)
        {
          v34 = (unsigned __int16)(v18 + 1);
          if (v34 == 9676)
          {
            v33 = 1;
          }
          else
          {
            v35 = *(unsigned __int16 *)(v5 + 8);
            if (v35 <= v34 && *(unsigned __int16 *)(v5 + 10) >= v34)
              v33 = *(_DWORD *)(*(_QWORD *)(v5 + 16) + 4 * ((unsigned __int16)(v18 + 1) - v35));
            else
              v33 = 0;
          }
        }
        else
        {
          v33 = 4;
        }
        OpenTypeReorderingOutput::writeChar(v74, 6042, v18 + 1, (const unsigned int *)"ferpfwlbfvbaftsp", v33, 0);
      }
LABEL_66:
      v36 = this[4];
      v37 = *((_DWORD *)v36 + v9);
      if ((unsigned __int16)v37 - 8204 >= 2 && (unsigned __int16)v37 != 9676)
      {
        v70 = *(unsigned __int16 *)(v5 + 8);
        if (v70 <= (unsigned __int16)v37
          && *(unsigned __int16 *)(v5 + 10) >= (unsigned __int16)v37
          && (*(_DWORD *)(*(_QWORD *)(v5 + 16) + 4 * ((unsigned __int16)v37 - v70)) & 0x4000000) != 0
          && (!v9 || *((_DWORD *)v36 + v9 - 1) != 9676))
        {
          OpenTypeReorderingOutput::writeChar(v74, 9676, v9, &dfltFeatures, 1, 0x8000000000000000);
        }
      }
      if (v9 < v7)
        break;
LABEL_166:
      result = v72;
      if (v7 >= v72)
        goto LABEL_174;
    }
    v73 = v16 + v18;
    v39 = v9;
    while (1)
    {
      v40 = this[4];
      v41 = *((_DWORD *)v40 + v39);
      if ((unsigned __int16)v41 - 8204 >= 2)
      {
        v43 = (unsigned __int16)*((_DWORD *)v40 + v39);
        if (v43 == 9676)
        {
          v42 = 1;
        }
        else
        {
          v44 = *(unsigned __int16 *)(v5 + 8);
          if (v44 <= v43 && *(unsigned __int16 *)(v5 + 10) >= v43)
          {
            v42 = *(_DWORD *)(*(_QWORD *)(v5 + 16) + 4 * ((unsigned __int16)*((_DWORD *)v40 + v39) - v44));
            if ((v42 & 0x80000) != 0)
              goto LABEL_145;
          }
          else
          {
            v42 = 0;
          }
        }
      }
      else
      {
        v42 = 4;
      }
      v45 = v18 + 1;
      if (v39 != v18)
        break;
LABEL_146:
      v39 = v45 + 1;
      if (v45 + 1 >= v7)
        goto LABEL_166;
    }
    if (v39 >= v73)
      v46 = "fwlbfvbaftsprafc";
    else
      v46 = "fwlbfvbaftsp";
    v47 = v42 & 0xF0000;
    if ((v42 & 0xF0000) == 0x10000 || v47 == 0x40000 || v47 == 0x20000)
      goto LABEL_143;
    if ((v42 & 0x8000000) != 0)
    {
      v45 = v39 + 1;
      if (v39 + 1 < v7)
      {
        if ((unsigned __int16)v39 - 8204 >= 2)
        {
          if ((unsigned __int16)v39 == 9676)
          {
            v48 = 1;
          }
          else
          {
            v63 = *(unsigned __int16 *)(v5 + 8);
            if (v63 <= (unsigned __int16)v39
              && *(unsigned __int16 *)(v5 + 10) >= (unsigned __int16)v39)
            {
              v48 = *(_DWORD *)(*(_QWORD *)(v5 + 16) + 4 * ((unsigned __int16)v39 - v63));
            }
            else
            {
              v48 = 0;
            }
          }
        }
        else
        {
          v48 = 4;
        }
        OpenTypeReorderingOutput::writeChar(v74, v41, v39, (const unsigned int *)v46, v48, 0);
        if ((unsigned __int16)v45 - 8204 >= 2)
        {
          v68 = (unsigned __int16)(v39 + 1);
          if (v68 == 9676)
          {
            v67 = 1;
          }
          else
          {
            v69 = *(unsigned __int16 *)(v5 + 8);
            if (v69 <= v68 && *(unsigned __int16 *)(v5 + 10) >= v68)
              v67 = *(_DWORD *)(*(_QWORD *)(v5 + 16) + 4 * ((unsigned __int16)(v39 + 1) - v69));
            else
              v67 = 0;
          }
        }
        else
        {
          v67 = 4;
        }
        OpenTypeReorderingOutput::writeChar(v74, *((_DWORD *)this[4] + v45), v39 + 1, (const unsigned int *)v46, v67, 0);
        goto LABEL_146;
      }
    }
    if ((v42 & 0x10000000) != 0 && v39 + 1 < v7)
    {
      v49 = (unsigned __int16)*((_DWORD *)v40 + v39 + 1);
      v50 = (unsigned __int16)*((_DWORD *)v40 + v39 + 1);
      if (v50 - 8204 >= 2 && v50 != 9676)
      {
        v51 = *(unsigned __int16 *)(v5 + 8);
        if (v51 <= v50)
        {
          v52 = *(unsigned __int16 *)(v5 + 10);
          if (v52 >= v50)
          {
            v53 = *(_QWORD *)(v5 + 16);
            if ((*(_DWORD *)(v53 + 4 * (v49 - v51)) & 0x20000000) != 0)
              goto LABEL_159;
          }
        }
      }
      if (v39 + 2 < v7 && v50 - 8204 >= 2 && v50 != 9676)
      {
        v51 = *(unsigned __int16 *)(v5 + 8);
        if (v51 <= v50)
        {
          v52 = *(unsigned __int16 *)(v5 + 10);
          if (v52 >= v50)
          {
            v53 = *(_QWORD *)(v5 + 16);
            if (*(_WORD *)(v53 + 4 * (v49 - v51)) == 6070
              && (unsigned __int16)*((_DWORD *)v40 + v39 + 2) - 8204 >= 2)
            {
              v54 = (unsigned __int16)*((_DWORD *)v40 + v39 + 2);
              if (v54 != 9676
                && v51 <= v54
                && v52 >= v54
                && *(_WORD *)(v53 + 4 * ((unsigned __int16)*((_DWORD *)v40 + v39 + 2) - v51)) == 6086)
              {
                goto LABEL_159;
              }
            }
          }
        }
      }
      v55 = v39 + 3;
      if (v39 + 3 < v7 && (unsigned __int16)*((_DWORD *)v40 + v55) - 8204 >= 2)
      {
        v56 = (unsigned __int16)*((_DWORD *)v40 + v55);
        if (v56 != 9676)
        {
          v51 = *(unsigned __int16 *)(v5 + 8);
          if (v51 <= v56)
          {
            v52 = *(unsigned __int16 *)(v5 + 10);
            if (v52 >= v56)
            {
              v53 = *(_QWORD *)(v5 + 16);
              if ((*(_DWORD *)(v53 + 4 * ((unsigned __int16)*((_DWORD *)v40 + v55) - v51)) & 0x20000000) != 0)
              {
LABEL_159:
                if ((unsigned __int16)v39 - 8204 >= 2)
                {
                  if ((unsigned __int16)v39 == 9676)
                  {
                    v42 = 1;
                  }
                  else
                  {
                    v42 = 0;
                    if (v51 <= (unsigned __int16)v39 && v52 >= (unsigned __int16)v39)
                      v42 = *(_DWORD *)(v53 + 4 * ((unsigned __int16)v39 - (unint64_t)v51));
                  }
                }
                else
                {
                  v42 = 4;
                }
                goto LABEL_143;
              }
            }
          }
        }
      }
      if (v39 + 4 < v7)
      {
        v57 = *((_DWORD *)v40 + v55);
        if ((unsigned __int16)v57 - 8204 >= 2)
        {
          v58 = (unsigned __int16)*((_DWORD *)v40 + v55);
          if (v58 != 9676)
          {
            v59 = *(unsigned __int16 *)(v5 + 8);
            if (v59 <= v58)
            {
              v52 = *(unsigned __int16 *)(v5 + 10);
              if (v52 >= v58)
              {
                v60 = (unsigned __int16)v57;
                v53 = *(_QWORD *)(v5 + 16);
                if (*(_WORD *)(v53 + 4 * (v60 - v59)) == 6070)
                {
                  v61 = *((_DWORD *)v40 + v39 + 4);
                  if ((unsigned __int16)v61 - 8204 >= 2
                    && (unsigned __int16)v61 != 9676
                    && v59 <= (unsigned __int16)v61
                    && v52 >= (unsigned __int16)v61
                    && *(_WORD *)(v53 + 4 * ((unsigned __int16)v61 - v59)) == 6086)
                  {
                    LODWORD(v51) = *(unsigned __int16 *)(v5 + 8);
                    goto LABEL_159;
                  }
                }
              }
            }
          }
        }
      }
    }
    if ((unsigned __int16)v39 - 8204 >= 2)
    {
      if ((unsigned __int16)v39 == 9676)
      {
        v42 = 1;
      }
      else
      {
        v62 = *(unsigned __int16 *)(v5 + 8);
        if (v62 <= (unsigned __int16)v39
          && *(unsigned __int16 *)(v5 + 10) >= (unsigned __int16)v39)
        {
          v42 = *(_DWORD *)(*(_QWORD *)(v5 + 16) + 4 * ((unsigned __int16)v39 - v62));
        }
        else
        {
          v42 = 0;
        }
      }
    }
    else
    {
      v42 = 4;
    }
    if (v39 <= v9)
    {
      v64 = v74;
      v65 = v39;
      v66 = &dfltFeatures;
      goto LABEL_144;
    }
LABEL_143:
    v64 = v74;
    v65 = v39;
    v66 = (const unsigned int *)v46;
LABEL_144:
    OpenTypeReorderingOutput::writeChar(v64, v41, v65, v66, v42, 0);
LABEL_145:
    v45 = v39;
    goto LABEL_146;
  }
LABEL_174:
  *a3 = v74;
  return result;
}

uint64_t *KhmerShapingEngine::GetClassTable(KhmerShapingEngine *this)
{
  GetKhmerClassTable();
  return &GetKhmerClassTable(void)::khmerClassTable;
}

uint64_t *GetKhmerClassTable(void)
{
  unsigned __int8 v0;

  {
    qword_1EDD17528 = 402593664;
    unk_1EDD17530 = &khmerCharClasses;
    GetKhmerClassTable(void)::khmerClassTable = (uint64_t)&off_1E15DD800;
  }
  return &GetKhmerClassTable(void)::khmerClassTable;
}

void KhmerShapingEngine::~KhmerShapingEngine(KhmerShapingEngine *this)
{
  OpenTypeShapingEngine::~OpenTypeShapingEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

void KhmerClassTable::~KhmerClassTable(KhmerClassTable *this)
{
  JUMPOUT(0x186DC03ACLL);
}

uint64_t TPathProcessor::SortRangeInfo(TPathProcessor *this, double *a2, const void *a3)
{
  if (*(double *)this < *a2)
    return 0xFFFFFFFFLL;
  else
    return *(double *)this > *a2;
}

void TPathProcessor::SlicePathH(void *info, BOOL a2, uint64_t *a3, double a4, double a5)
{
  const CGPath *v6;
  double v8;
  double v9;
  uint64_t v11;
  uint64_t v12;
  const CGPath *v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  double *v18;
  double *v19;
  double v20;
  double *v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double *v26;
  double v27;
  uint64_t v28;
  const CGPath *v29;
  CGPoint v30;
  CGPoint v31;

  v6 = *(const CGPath **)info;
  if (v6)
  {
    v8 = a5;
    v9 = a4;
    if (a4 >= a5)
    {
      a4 = a5;
      a5 = v9;
    }
    *((double *)info + 2) = a4;
    *((double *)info + 3) = a5;
    *((_QWORD *)info + 11) = 0;
    *((_QWORD *)info + 4) = 0;
    *((_QWORD *)info + 10) = *((_QWORD *)info + 1);
    CGPathApply(v6, info, (CGPathApplierFunction)TPathProcessor::ProcessPathElementApplier);
    v11 = *a3;
    if (*a3 >= 1)
    {
      v12 = 0;
      do
      {
        if (*a3 <= v12)
        {
          v13 = 0;
        }
        else
        {
          *((_QWORD *)info + 10) = *(_QWORD *)(a3[10] + 8 * v12);
          v13 = (const CGPath *)atomic_load((unint64_t *)(a3[1] + 8 * v12));
        }
        CGPathApply(v13, info, (CGPathApplierFunction)TPathProcessor::ProcessPathElementApplier);
        ++v12;
      }
      while (v11 != v12);
    }
    v14 = *((_QWORD *)info + 11);
    if (v14)
    {
      qsort(*((void **)info + 5), v14, 0x10uLL, (int (__cdecl *)(const void *, const void *))TPathProcessor::SortRangeInfo);
      v15 = *((_QWORD *)info + 11);
      if (v15 < 2)
        goto LABEL_32;
      v16 = 0;
      v17 = (double *)*((_QWORD *)info + 5);
      v18 = &v17[2 * v15];
      v19 = v17 + 2;
      v20 = v17[1];
      v21 = v17;
      do
      {
        if (v20 >= *v19)
        {
          v22 = v19[1];
          if (v20 >= v22)
            v22 = v20;
        }
        else
        {
          *v21 = v20;
          v21[1] = *v19;
          v22 = v19[1];
          v21 += 2;
          ++v16;
        }
        v19 += 2;
        v20 = v22;
      }
      while (v19 < v18);
      if (v16)
      {
        v23 = 0;
        v24 = 0;
        v25 = (v9 + v8) * 0.5;
        v26 = v17;
        do
        {
          v27 = (*v17 + v17[1]) * 0.5;
          v30.x = v27;
          v30.y = v25;
          if (CGPathContainsPoint(*(CGPathRef *)info, 0, v30, a2))
          {
            if (v11 < 1)
            {
LABEL_27:
              if (v17 != v26)
                *(_OWORD *)v26 = *(_OWORD *)v17;
              v26 += 2;
              ++v24;
            }
            else
            {
              v28 = 0;
              while (1)
              {
                if (*a3 > v28)
                {
                  v29 = (const CGPath *)atomic_load((unint64_t *)(a3[1] + 8 * v28));
                  if (v29)
                  {
                    v31.x = v27;
                    v31.y = v25;
                    if (CGPathContainsPoint(v29, 0, v31, *(_DWORD *)(a3[19] + 4 * v28) == 0))
                      break;
                  }
                }
                if (v11 == ++v28)
                  goto LABEL_27;
              }
            }
          }
          v17 += 2;
          ++v23;
        }
        while (v23 != v16);
      }
      else
      {
LABEL_32:
        v24 = 0;
      }
      *((_QWORD *)info + 4) = v24;
    }
  }
}

double *TPathProcessor::ProcessPathElementApplier(CGPoint *this, _QWORD *a2, CGPathElement *a3)
{
  CGPoint *v4;
  CGPoint v5;
  double y;
  CGPoint v8;
  CGPoint v9;
  CGPoint v10;
  CGPoint v11;

  v4 = (CGPoint *)a2[1];
  switch(*(_DWORD *)a2)
  {
    case 0:
      this[4] = *v4;
      this[3] = *v4;
      return TPathProcessor::RemoveRangeForPoint(&this->x, this[4]);
    case 1:
      TPathProcessor::RemoveRangeForLine((TPathProcessor *)this, this[4], *v4, (uint64_t)a2, (double *)a3);
      v5 = *v4;
      goto LABEL_6;
    case 2:
      v8 = this[4];
      y = v4->y;
      v11 = v4[1];
      v9.x = (v8.x + v4->x * 2.0) / 3.0;
      v9.y = (v8.y + y * 2.0) / 3.0;
      v10.x = (v11.x + v4->x * 2.0) / 3.0;
      v10.y = (v11.y + y * 2.0) / 3.0;
      TPathProcessor::RemoveRangeForCurve(&this->x, v8, v9, v10, v11, (uint64_t)a2, (double *)a3);
      v5 = v4[1];
      goto LABEL_6;
    case 3:
      TPathProcessor::RemoveRangeForCurve(&this->x, this[4], *v4, v4[1], v4[2], (uint64_t)a2, (double *)a3);
      v5 = v4[2];
LABEL_6:
      this[4] = v5;
      break;
    case 4:
      TPathProcessor::RemoveRangeForLine((TPathProcessor *)this, this[4], this[3], (uint64_t)a2, (double *)a3);
      break;
    default:
      return TPathProcessor::RemoveRangeForPoint(&this->x, this[4]);
  }
  return TPathProcessor::RemoveRangeForPoint(&this->x, this[4]);
}

uint64_t TPathProcessor::RemoveRangeForLine(TPathProcessor *this, CGPoint a2, CGPoint a3, uint64_t a4, double *a5)
{
  double y;
  double x;
  double v7;
  double v8;
  double v10;
  double v11;
  uint64_t result;
  double v13;
  double v14;
  double v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  int v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  CGFloat v23;
  double *v24;
  char v25;
  double *v26;
  char v27;
  double *v28;
  CGFloat v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat v32;
  double v33;
  double v34;
  CGPoint v35;
  CGPoint v36;
  CGPoint v37;
  CGPoint v38;
  CGPoint v39;
  CGPoint v40;
  CGPoint v41;
  CGPoint v42;

  y = a3.y;
  x = a3.x;
  v7 = a2.y;
  v8 = a2.x;
  v33 = -1.79769313e308;
  v34 = 1.79769313e308;
  v10 = *((double *)this + 10);
  if (v10 == 0.0)
  {
    v11 = v8;
    result = TPathProcessor::CalculateExcludeRange((TPathProcessor *)&v34, a2, a3, *((CGFloat *)this + 2), *((CGFloat *)this + 3), &v33, a5);
    if ((result & 1) != 0)
      return (uint64_t)TPathProcessor::RemoveRange((uint64_t)this, v34, v33);
  }
  else
  {
    v13 = v10 * 0.5;
    v14 = sqrt((a3.y - a2.y) * (a3.y - a2.y) + (a3.x - v8) * (a3.x - v8));
    v15 = (y - a2.y) * v13 / v14;
    v16 = -((a3.x - v8) * v13) / v14;
    v35.x = v8 + v15;
    v35.y = a2.y + v16;
    v29 = v7 + v16;
    v30 = v8 + v15;
    v39.x = a3.x + v15;
    v39.y = y + v16;
    v31 = y + v16;
    v32 = x + v15;
    v17 = *((double *)this + 2);
    v18 = *((double *)this + 3);
    v19 = TPathProcessor::CalculateExcludeRange((TPathProcessor *)&v34, v35, v39, v17, v18, &v33, a5);
    v20 = v8 - v15;
    v21 = v7 - v16;
    v22 = x - v15;
    v23 = y - v16;
    v36.x = v20;
    v36.y = v21;
    v40.x = v22;
    v40.y = v23;
    v25 = TPathProcessor::CalculateExcludeRange((TPathProcessor *)&v34, v36, v40, v17, v18, &v33, v24);
    v37.x = v20;
    v37.y = v21;
    v41.y = v29;
    v41.x = v30;
    v27 = TPathProcessor::CalculateExcludeRange((TPathProcessor *)&v34, v37, v41, v17, v18, &v33, v26);
    v38.x = v22;
    v38.y = v23;
    v42.y = v31;
    v42.x = v32;
    result = TPathProcessor::CalculateExcludeRange((TPathProcessor *)&v34, v38, v42, v17, v18, &v33, v28);
    if ((result & 1) != 0 || (v27 & 1) != 0 || (v25 & 1) != 0 || v19)
      return (uint64_t)TPathProcessor::RemoveRange((uint64_t)this, v34, v33);
  }
  return result;
}

double *TPathProcessor::RemoveRangeForCurve(double *this, CGPoint a2, CGPoint a3, CGPoint a4, CGPoint a5, uint64_t a6, double *a7)
{
  double y;
  double x;
  double v9;
  double v10;
  TPathProcessor *v11;
  double v12;
  double v13;
  double v14;
  CGFloat v15;
  double v16;
  double v17;
  double v18;
  CGFloat v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  int v32;
  int v33;
  unsigned int v34;
  double v35;
  double v36;
  CGPoint v38;
  CGPoint v39;
  CGPoint v40;

  y = a2.y;
  x = a2.x;
  if (a5.y >= a4.y)
    v9 = a4.y;
  else
    v9 = a5.y;
  if (a3.y < a2.y)
    a2.y = a3.y;
  if (v9 < a2.y)
    a2.y = v9;
  v10 = this[10] * 0.5;
  if (a2.y - v10 <= this[3])
  {
    v11 = (TPathProcessor *)this;
    if (y >= a3.y)
      v12 = y;
    else
      v12 = a3.y;
    if (a4.y >= a5.y)
      v13 = a4.y;
    else
      v13 = a5.y;
    if (v12 < v13)
      v12 = v13;
    if (v12 + v10 >= this[2])
    {
      v14 = a3.x - x;
      v15 = a4.x - a3.x;
      v16 = a4.x - a3.x - (a3.x - x);
      v17 = a5.x - a4.x - v15;
      v18 = a3.y - y;
      v19 = a4.y - a3.y;
      v20 = a4.y - a3.y - (a3.y - y);
      v21 = a5.y - a4.y - v19;
      v22 = v20 * v20 + v16 * v16;
      if (v22 <= v21 * v21 + v17 * v17)
        v22 = v21 * v21 + v17 * v17;
      v23 = v22 * 9.0 * 0.0625;
      if (v23 > 0.25)
      {
        v24 = v21 - v20;
        v25 = v24 + (v18 + v20) * 3.0;
        v26 = (v20 + v24) * 6.0;
        v27 = v24 * 6.0;
        v28 = v17 - v16;
        v29 = v28 + (v14 + v16) * 3.0;
        v30 = (v16 + v28) * 6.0;
        v31 = v28 * 6.0;
        v32 = 1;
        do
        {
          v33 = v32;
          v31 = v31 * 0.125;
          v30 = v30 * 0.25 - v31;
          v29 = v29 * 0.5 - v30 * 0.5;
          v27 = v27 * 0.125;
          v26 = v26 * 0.25 - v27;
          v25 = v25 * 0.5 - v26 * 0.5;
          v32 *= 2;
          v23 = v23 * 0.0625;
        }
        while (v23 > 0.25 && v32 <= 0x10000);
        if (v32 >= 2)
        {
          v34 = (2 * v33) | 1;
          v35 = y;
          v36 = x;
          do
          {
            x = v36 + v29;
            v29 = v30 + v29;
            v30 = v31 + v30;
            y = v35 + v25;
            v25 = v26 + v25;
            v26 = v27 + v26;
            v40.x = x;
            v40.y = y;
            TPathProcessor::RemoveRangeForLine(v11, *(CGPoint *)&v36, v40, a6, a7);
            v38.x = x;
            v38.y = y;
            TPathProcessor::RemoveRangeForPoint((double *)v11, v38);
            --v34;
            v35 = y;
            v36 = x;
          }
          while (v34 > 2);
        }
      }
      v39.x = x;
      v39.y = y;
      return (double *)TPathProcessor::RemoveRangeForLine(v11, v39, a5, a6, a7);
    }
  }
  return this;
}

double *TPathProcessor::RemoveRangeForPoint(double *this, CGPoint a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  BOOL v6;
  double v7;
  BOOL v8;

  v2 = this[10];
  if (v2 <= 0.0)
    return this;
  v3 = v2 * 0.5;
  v4 = this[2];
  if (a2.y >= v4 && a2.y <= this[3])
    return (double *)TPathProcessor::RemoveRange((uint64_t)this, a2.x - v3, a2.x + v3);
  v5 = v4 - a2.y;
  v6 = a2.y < v4 && v5 < v3;
  if (v6 || ((v7 = this[3], v5 = a2.y - v7, a2.y > v7) ? (v8 = v5 < v3) : (v8 = 0), v8))
  {
    v3 = sqrt(v3 * v3 - v5 * v5);
    return (double *)TPathProcessor::RemoveRange((uint64_t)this, a2.x - v3, a2.x + v3);
  }
  return this;
}

uint64_t TPathProcessor::CalculateExcludeRange(TPathProcessor *this, CGPoint a2, CGPoint a3, CGFloat a4, CGFloat a5, double *a6, double *a7)
{
  BOOL v8;
  double x;
  double y;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;

  if (a2.y <= a4 && a3.y <= a4)
    return 0;
  v8 = a2.y < a5 || a3.y < a5;
  if (!v8)
    return 0;
  if (a2.y <= a3.y)
  {
    x = a3.x;
    y = a3.y;
    a3 = a2;
  }
  else
  {
    x = a2.x;
    y = a2.y;
  }
  if (a3.y < a4 || a3.y > a5 || y < a4 || y > a5)
  {
    if ((*(_QWORD *)&a3.y & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      if ((*(_QWORD *)&y & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        v12 = (x + a3.x) * 0.5;
        v13 = v12;
        goto LABEL_32;
      }
      v8 = a3.y < a4;
      v14 = a3.x - x;
      v15 = a3.y - y;
      v12 = a3.x;
      if (v8)
        v12 = x - (a4 - y) * v14 / v15;
      if (y > a5)
      {
        v13 = x - (a5 - y) * v14 / v15;
        goto LABEL_32;
      }
    }
    else
    {
      v12 = a3.x;
      if (a3.y < a4)
        v12 = a3.x + (x - a3.x) * (a4 - a3.y) / (y - a3.y);
      if (y > a5)
      {
        v13 = a3.x + (x - a3.x) * (a5 - a3.y) / (y - a3.y);
LABEL_32:
        if ((*(_QWORD *)&a3.x & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
          a3.x = v12;
        if ((*(_QWORD *)&x & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
          x = v13;
        goto LABEL_36;
      }
    }
    v13 = x;
    goto LABEL_32;
  }
LABEL_36:
  if (x >= a3.x)
    v16 = a3.x;
  else
    v16 = x;
  if (v16 < *(double *)this)
    *(double *)this = v16;
  if (x >= a3.x)
    v17 = x;
  else
    v17 = a3.x;
  if (v17 > *a6)
    *a6 = v17;
  return 1;
}

char *TPathProcessor::RemoveRange(uint64_t a1, double a2, double a3)
{
  unint64_t v6;
  char *result;
  uint64_t v8;
  double *v9;
  unint64_t v10;
  unint64_t v11;

  v6 = *(_QWORD *)(a1 + 88);
  result = *(char **)(a1 + 40);
  if (v6 % 0x1E)
  {
    if (!result)
      return result;
    goto LABEL_3;
  }
  if (!result)
  {
    result = (char *)malloc_type_realloc(0, 0x1E0uLL, 0xFE0C88B4uLL);
    goto LABEL_12;
  }
  v10 = v6 / 0x1E + 1;
  if (!is_mul_ok(v10, 0x1EuLL))
  {
    free(result);
LABEL_10:
    result = 0;
    goto LABEL_12;
  }
  v11 = 30 * v10;
  if (v11 >> 60)
    goto LABEL_10;
  result = (char *)reallocf(result, 16 * v11);
LABEL_12:
  *(_QWORD *)(a1 + 40) = result;
  if (!result)
    return result;
LABEL_3:
  v8 = *(_QWORD *)(a1 + 88);
  v9 = (double *)&result[16 * v8];
  *v9 = a2;
  v9[1] = a3;
  *(_QWORD *)(a1 + 88) = v8 + 1;
  return result;
}

__CFArray *CreateRectArrayFromPath(CFTypeRef cf, BOOL a2, uint64_t *a3, double *a4, double a5, double a6, double a7)
{
  CFIndex v13;
  __CFArray *Mutable;
  uint64_t v15;
  double Width;
  double v17;
  double v18;
  CGFloat v19;
  double v20;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v22;
  CFTypeRef cfa[2];
  __int128 v25;
  CFIndex capacity[2];
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  CGRect v31;
  CGRect v32;
  CGRect v33;

  v27 = unk_1849527E0;
  v28 = xmmword_1849527F0;
  cfa[0] = (CFTypeRef)__const_CreateRectArrayFromPath_pathProcessor;
  v25 = unk_1849527C0;
  cfa[1] = *(CFTypeRef *)&a5;
  v29 = -1;
  v30 = 0;
  capacity[0] = 0;
  capacity[1] = 0;
  if (cf)
    CFRetain(cf);
  cfa[0] = cf;
  TPathProcessor::SlicePathH(cfa, a2, a3, a6, a7);
  v13 = capacity[0];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], capacity[0], MEMORY[0x1E0C9B378]);
  if (v13)
  {
    v15 = 0;
    Width = 0.0;
    do
    {
      v17 = *(double *)(capacity[1] + v15);
      v18 = *(double *)(capacity[1] + v15 + 8) - v17;
      v19 = *(double *)&v25;
      v20 = *((double *)&v25 + 1) - *(double *)&v25;
      v31.origin.x = v17;
      *(_QWORD *)&v31.origin.y = v25;
      v31.size.width = v18;
      v31.size.height = *((double *)&v25 + 1) - *(double *)&v25;
      DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v31);
      if (DictionaryRepresentation)
      {
        v22 = DictionaryRepresentation;
        CFArrayAppendValue(Mutable, DictionaryRepresentation);
        CFRelease(v22);
      }
      v32.origin.x = v17;
      v32.origin.y = v19;
      v32.size.width = v18;
      v32.size.height = v20;
      if (Width < CGRectGetWidth(v32))
      {
        v33.origin.x = v17;
        v33.origin.y = v19;
        v33.size.width = v18;
        v33.size.height = v20;
        Width = CGRectGetWidth(v33);
      }
      v15 += 16;
      --v13;
    }
    while (v13);
    if (a4)
      goto LABEL_11;
  }
  else
  {
    Width = 0.0;
    if (a4)
LABEL_11:
      *a4 = Width;
  }
  if (cfa[0])
    CFRelease(cfa[0]);
  free((void *)capacity[1]);
  return Mutable;
}

__CFArray *CreateRectArrayFromPathVertical(uint64_t a1, BOOL a2, uint64_t *a3, double a4, double a5, double a6)
{
  void *v11;
  void *v12;
  CFIndex v13;
  __CFArray *Mutable;
  uint64_t v15;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v17;
  CGAffineTransform v19;
  CFTypeRef cf[2];
  __int128 v21;
  CFIndex capacity[2];
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD v27[3];
  CGRect v28;
  CGRect v29;

  v27[0] = kRotateRightTransform;
  v27[1] = unk_184952820;
  v27[2] = xmmword_184952830;
  v11 = (void *)MEMORY[0x186DBFE00](a1, v27);
  v12 = v11;
  v23 = unk_184952870;
  v24 = xmmword_184952880;
  cf[0] = (CFTypeRef)__const_CreateRectArrayFromPathVertical_pathProcessor;
  v21 = unk_184952850;
  cf[1] = *(CFTypeRef *)&a4;
  v25 = -1;
  v26 = 0;
  capacity[0] = 0;
  capacity[1] = 0;
  if (v11)
    CFRetain(v11);
  cf[0] = v12;
  TPathProcessor::SlicePathH(cf, a2, a3, -a5, -a6);
  v13 = capacity[0];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], capacity[0], MEMORY[0x1E0C9B378]);
  if (v13)
  {
    v15 = 0;
    do
    {
      v28.origin.x = *(CGFloat *)(capacity[1] + v15);
      v28.size.width = *(double *)(capacity[1] + v15 + 8) - v28.origin.x;
      *(_QWORD *)&v28.origin.y = v21;
      v28.size.height = *((double *)&v21 + 1) - *(double *)&v21;
      v19 = *(CGAffineTransform *)kRotateLeftTransform;
      v29 = CGRectApplyAffineTransform(v28, &v19);
      DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v29);
      if (DictionaryRepresentation)
      {
        v17 = DictionaryRepresentation;
        CFArrayAppendValue(Mutable, DictionaryRepresentation);
        CFRelease(v17);
      }
      v15 += 16;
      --v13;
    }
    while (v13);
  }
  if (cf[0])
    CFRelease(cf[0]);
  free((void *)capacity[1]);

  return Mutable;
}

__CFArray *CTFramesetterCreateCGRectArray(__CFArray *a1, const __CFDictionary *a2, CFArrayRef theArray, double a4, double a5)
{
  __CFArray *RectArrayFromPath;
  __int128 v9;
  double PathWidthAndFillRule;
  CTFramePathFillRule v12;
  _OWORD v13[13];
  uint64_t v14;

  RectArrayFromPath = a1;
  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v13[11] = v9;
    v13[12] = v9;
    v13[9] = v9;
    v13[10] = v9;
    v13[8] = v9;
    v13[6] = v9;
    v13[7] = v9;
    v13[4] = v9;
    v13[5] = v9;
    v13[2] = v9;
    v13[3] = v9;
    v13[0] = v9;
    v13[1] = v9;
    TClippingPathInfo::TClippingPathInfo((TClippingPathInfo *)v13, theArray, 0);
    v12 = -1431655766;
    PathWidthAndFillRule = GetPathWidthAndFillRule(a2, &v12);
    RectArrayFromPath = CreateRectArrayFromPath(RectArrayFromPath, v12 == kCTFramePathFillEvenOdd, (uint64_t *)v13, 0, PathWidthAndFillRule, a4, a5);
    TClippingPathInfo::~TClippingPathInfo((TClippingPathInfo *)v13);
  }
  return RectArrayFromPath;
}

double GetPathWidthAndFillRule(const __CFDictionary *a1, CTFramePathFillRule *a2)
{
  const __CFNumber *Value;
  CTFramePathFillRule v5;
  double v6;
  const __CFNumber *v7;
  double v9;
  int valuePtr;

  if (a1)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("CTFramePathFillRule"));
    if (Value)
    {
      valuePtr = -1431655766;
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      v5 = valuePtr;
    }
    else
    {
      v5 = kCTFramePathFillEvenOdd;
    }
    v9 = 0.0;
    v7 = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("CTFramePathWidth"));
    v6 = 0.0;
    if (v7)
    {
      CFNumberGetValue(v7, kCFNumberDoubleType, &v9);
      if (v9 >= 0.0)
        v6 = v9;
    }
  }
  else
  {
    v5 = kCTFramePathFillEvenOdd;
    v6 = 0.0;
  }
  *a2 = v5;
  return v6;
}

__CFArray *CTFramesetterCreateCGRectArrayVertical(__CFArray *a1, const __CFDictionary *a2, CFArrayRef theArray, double a4, double a5)
{
  __CFArray *RectArrayFromPathVertical;
  __int128 v9;
  double PathWidthAndFillRule;
  CTFramePathFillRule v12;
  _OWORD v13[13];
  uint64_t v14;

  RectArrayFromPathVertical = a1;
  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v13[11] = v9;
    v13[12] = v9;
    v13[9] = v9;
    v13[10] = v9;
    v13[8] = v9;
    v13[6] = v9;
    v13[7] = v9;
    v13[4] = v9;
    v13[5] = v9;
    v13[2] = v9;
    v13[3] = v9;
    v13[0] = v9;
    v13[1] = v9;
    TClippingPathInfo::TClippingPathInfo((TClippingPathInfo *)v13, theArray, 1);
    v12 = -1431655766;
    PathWidthAndFillRule = GetPathWidthAndFillRule(a2, &v12);
    RectArrayFromPathVertical = CreateRectArrayFromPathVertical((uint64_t)RectArrayFromPathVertical, v12 == kCTFramePathFillEvenOdd, (uint64_t *)v13, PathWidthAndFillRule, a4, a5);
    TClippingPathInfo::~TClippingPathInfo((TClippingPathInfo *)v13);
  }
  return RectArrayFromPathVertical;
}

void TClippingPathInfo::TClippingPathInfo(TClippingPathInfo *this, CFArrayRef theArray, int a3)
{
  CFIndex v5;
  void *ValueAtIndex;
  CFTypeID v7;
  void *Value;
  CFTypeID v9;
  unint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  unint64_t v23;
  unint64_t *v24;
  char *v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  uint64_t v31;
  unint64_t *v32;
  double PathWidthAndFillRule;
  unint64_t v34;
  CTFramePathFillRule *v35;
  CTFramePathFillRule *v36;
  CTFramePathFillRule *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  char *v43;
  CTFramePathFillRule *v44;
  CTFramePathFillRule *v45;
  int v46;
  unint64_t v47;
  char *v48;
  _QWORD *v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  unint64_t v56;
  double *v57;
  double *v58;
  uint64_t v59;
  char *v60;
  CTFramePathFillRule *v61;
  char *v62;
  CTFramePathFillRule *v63;
  void **v64;
  void **v65;
  _QWORD *v66;
  unint64_t *v67;
  unint64_t *v68;
  CFIndex Count;
  _OWORD v71[3];
  CTFramePathFillRule v72[2];
  id v73[2];

  *((_QWORD *)this + 1) = 0;
  v62 = (char *)this + 32;
  *((_QWORD *)this + 9) = (char *)this + 32;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 10) = 0;
  v64 = (void **)((char *)this + 80);
  v60 = (char *)this + 104;
  *((_QWORD *)this + 18) = (char *)this + 104;
  v66 = (_QWORD *)((char *)this + 8);
  v67 = (unint64_t *)((char *)this + 144);
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 19) = 0;
  v65 = (void **)((char *)this + 152);
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  v61 = (CTFramePathFillRule *)((char *)this + 176);
  *((_QWORD *)this + 25) = (char *)this + 176;
  if (theArray)
  {
    v68 = (unint64_t *)((char *)this + 72);
    *(_QWORD *)this = CFArrayGetCount(theArray);
    Count = CFArrayGetCount(theArray);
    if (Count)
    {
      v5 = 0;
      v63 = (CTFramePathFillRule *)((char *)this + 196);
      do
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, v5);
        v73[0] = 0;
        v7 = CFGetTypeID(ValueAtIndex);
        if (v7 == CFDictionaryGetTypeID())
        {
          Value = (void *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, CFSTR("CTFramePathClippingPath"));
          TCFRef<__CTFont const*>::Retain((unint64_t *)v73, Value);
        }
        else
        {
          v9 = CFGetTypeID(ValueAtIndex);
          if (v9 == CGPathGetTypeID())
            TCFRef<__CTFont const*>::Retain((unint64_t *)v73, ValueAtIndex);
          else
            CFLog();
          ValueAtIndex = 0;
        }
        if (atomic_load((unint64_t *)v73))
        {
          if (a3)
          {
            v11 = atomic_load((unint64_t *)v73);
            v71[0] = kRotateRightTransform;
            v71[1] = unk_184952820;
            v71[2] = xmmword_184952830;
            *(_QWORD *)v72 = MEMORY[0x186DBFE00](v11, v71);
            do
              v12 = __ldaxr((unint64_t *)v72);
            while (__stlxr(0, (unint64_t *)v72));
            do
              v13 = (void *)__ldaxr((unint64_t *)v73);
            while (__stlxr(v12, (unint64_t *)v73));

          }
          v15 = (unint64_t *)*((_QWORD *)this + 2);
          v14 = *((_QWORD *)this + 3);
          if ((unint64_t)v15 >= v14)
          {
            v18 = ((uint64_t)v15 - *v66) >> 3;
            if ((unint64_t)(v18 + 1) >> 61)
              goto LABEL_98;
            v19 = v14 - *v66;
            v20 = v19 >> 2;
            if (v19 >> 2 <= (unint64_t)(v18 + 1))
              v20 = v18 + 1;
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
              v21 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v21 = v20;
            if (v21)
            {
              v22 = (char *)*v68;
              v23 = *v68 + 8 * v21;
              if (v23 <= (unint64_t)v68)
              {
                *v68 = v23;
              }
              else
              {
                if (v21 >> 61)
                  goto LABEL_99;
                v22 = (char *)operator new(8 * v21);
              }
            }
            else
            {
              v22 = 0;
            }
            v24 = (unint64_t *)&v22[8 * v18];
            v25 = &v22[8 * v21];
            do
              v26 = __ldaxr((unint64_t *)v73);
            while (__stlxr(0, (unint64_t *)v73));
            *v24 = v26;
            v17 = v24 + 1;
            v27 = (unint64_t *)*((_QWORD *)this + 1);
            v28 = (unint64_t *)*((_QWORD *)this + 2);
            if (v28 == v27)
            {
              *((_QWORD *)this + 1) = v24;
              *((_QWORD *)this + 2) = v17;
              v31 = *((_QWORD *)this + 3);
              *((_QWORD *)this + 3) = v25;
            }
            else
            {
              do
              {
                --v24;
                --v28;
                do
                  v29 = __ldaxr(v28);
                while (__stlxr(0, v28));
                *v24 = v29;
              }
              while (v28 != v27);
              v28 = (unint64_t *)*((_QWORD *)this + 1);
              v30 = (unint64_t *)*((_QWORD *)this + 2);
              *((_QWORD *)this + 1) = v24;
              *((_QWORD *)this + 2) = v17;
              v31 = *((_QWORD *)this + 3);
              *((_QWORD *)this + 3) = v25;
              if (v30 != v28)
              {
                do
                {
                  v32 = v30 - 1;

                  v30 = v32;
                }
                while (v32 != v28);
              }
            }
            if (v28)
            {
              if (v62 > (char *)v28 || v68 <= v28)
              {
                operator delete(v28);
              }
              else if (v31 == *v68)
              {
                *v68 = (unint64_t)v28;
              }
            }
          }
          else
          {
            do
              v16 = __ldaxr((unint64_t *)v73);
            while (__stlxr(0, (unint64_t *)v73));
            *v15 = v16;
            v17 = v15 + 1;
          }
          *((_QWORD *)this + 2) = v17;
          v72[0] = -1431655766;
          PathWidthAndFillRule = GetPathWidthAndFillRule((const __CFDictionary *)ValueAtIndex, v72);
          v35 = (CTFramePathFillRule *)*((_QWORD *)this + 20);
          v34 = *((_QWORD *)this + 21);
          if ((unint64_t)v35 >= v34)
          {
            v37 = (CTFramePathFillRule *)*v65;
            v38 = ((char *)v35 - (_BYTE *)*v65) >> 2;
            if ((unint64_t)(v38 + 1) >> 62)
              goto LABEL_98;
            v39 = v34 - (_QWORD)v37;
            v40 = (uint64_t)(v34 - (_QWORD)v37) >> 1;
            if (v40 <= v38 + 1)
              v40 = v38 + 1;
            if (v39 >= 0x7FFFFFFFFFFFFFFCLL)
              v41 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v41 = v40;
            if (v41)
            {
              v42 = (char *)*((_QWORD *)this + 25);
              v43 = &v42[4 * v41];
              if (v43 <= (char *)v63)
              {
                *((_QWORD *)this + 25) = v43;
              }
              else
              {
                if (v41 >> 62)
                  goto LABEL_99;
                v42 = (char *)operator new(4 * v41);
              }
            }
            else
            {
              v42 = 0;
            }
            v44 = (CTFramePathFillRule *)&v42[4 * v38];
            *v44 = v72[0];
            v45 = v44;
            while (v35 != v37)
            {
              v46 = *((_DWORD *)v35-- - 1);
              *((_DWORD *)v45-- - 1) = v46;
            }
            v36 = v44 + 1;
            *((_QWORD *)this + 19) = v45;
            *((_QWORD *)this + 20) = v44 + 1;
            *((_QWORD *)this + 21) = &v42[4 * v41];
            if (v37)
            {
              if (v61 > v37 || v63 <= v37)
              {
                operator delete(v37);
              }
              else if ((CTFramePathFillRule *)((char *)v37 + v39) == *((CTFramePathFillRule **)this + 25))
              {
                *((_QWORD *)this + 25) = v37;
              }
            }
          }
          else
          {
            *v35 = v72[0];
            v36 = v35 + 1;
          }
          *((_QWORD *)this + 20) = v36;
          v48 = (char *)*((_QWORD *)this + 11);
          v47 = *((_QWORD *)this + 12);
          if ((unint64_t)v48 >= v47)
          {
            v50 = (char *)*v64;
            v51 = (v48 - (_BYTE *)*v64) >> 3;
            if ((unint64_t)(v51 + 1) >> 61)
LABEL_98:
              abort();
            v52 = v47 - (_QWORD)v50;
            v53 = (uint64_t)(v47 - (_QWORD)v50) >> 2;
            if (v53 <= v51 + 1)
              v53 = v51 + 1;
            if (v52 >= 0x7FFFFFFFFFFFFFF8)
              v54 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v54 = v53;
            if (v54)
            {
              v55 = (char *)*v67;
              v56 = *v67 + 8 * v54;
              if (v56 <= (unint64_t)v67)
              {
                *v67 = v56;
              }
              else
              {
                if (v54 >> 61)
LABEL_99:
                  std::__throw_bad_array_new_length[abi:nn180100]();
                v55 = (char *)operator new(8 * v54);
              }
            }
            else
            {
              v55 = 0;
            }
            v57 = (double *)&v55[8 * v51];
            *v57 = PathWidthAndFillRule;
            v58 = v57;
            while (v48 != v50)
            {
              v59 = *((_QWORD *)v48 - 1);
              v48 -= 8;
              *((_QWORD *)v58-- - 1) = v59;
            }
            v49 = v57 + 1;
            *((_QWORD *)this + 10) = v58;
            *((_QWORD *)this + 11) = v57 + 1;
            *((_QWORD *)this + 12) = &v55[8 * v54];
            if (v50)
            {
              if (v60 > v50 || v67 <= (unint64_t *)v50)
              {
                operator delete(v50);
              }
              else if (&v50[v52] == (char *)*v67)
              {
                *v67 = (unint64_t)v50;
              }
            }
          }
          else
          {
            *(double *)v48 = PathWidthAndFillRule;
            v49 = v48 + 8;
          }
          *((_QWORD *)this + 11) = v49;
        }

        ++v5;
      }
      while (v5 != Count);
    }
  }
  else
  {
    *(_QWORD *)this = 0;
  }
}

BOOL CTFramesetterFindRectPosition(const CGPath *a1, const __CFDictionary *a2, const __CFArray *a3, int a4, double *a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  _BOOL8 v20;
  CGSize v22;
  uint64_t v23;
  double v24;
  double MaxY;
  char v26;
  uint64_t v27;
  double v28;
  const CGPath *v29;
  double MinX;
  double MaxX;
  CGFloat v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat v35;
  CTFramePathFillRule v36;
  __CFArray *v37;
  const __CFArray *Count;
  const __CFArray *v39;
  double v41;
  __CFArray *v42;
  const __CFArray *v43;
  const __CFArray *v44;
  CFIndex v45;
  double v46;
  double v47;
  double PathWidthAndFillRule;
  double v50;
  double v51;
  CTFramePathFillRule v52;
  CGRect rect;
  _OWORD v54[5];
  CGSize v55;
  CGSize v56;
  CGSize v57;
  CGSize v58;
  CGSize v59;
  CGSize v60;
  CGSize v61;
  CGSize v62;
  uint64_t v63;
  CGRect BoundingBox;
  CGRect v65;
  CGRect v66;
  CGRect v67;
  CGRect v68;
  CGRect v69;
  CGRect v70;
  CGRect v71;

  v63 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  BoundingBox = CGPathGetBoundingBox(a1);
  if (BoundingBox.size.width < a8 || BoundingBox.size.height < a7)
    return 0;
  x = BoundingBox.origin.x;
  y = BoundingBox.origin.y;
  width = BoundingBox.size.width;
  height = BoundingBox.size.height;
  if (CGRectGetMinY(BoundingBox) > a6)
    return 0;
  v65.origin.x = x;
  v65.origin.y = y;
  v65.size.width = width;
  v65.size.height = height;
  if (a6 + a7 > CGRectGetMaxY(v65))
    return 0;
  v22.width = NAN;
  v22.height = NAN;
  rect.origin = (CGPoint)v22;
  rect.size = v22;
  v22.width = -3.72066208e-103;
  v22.height = -3.72066208e-103;
  v61 = v22;
  v62 = v22;
  v59 = v22;
  v60 = v22;
  v57 = v22;
  v58 = v22;
  v55 = v22;
  v56 = v22;
  v54[3] = v22;
  v54[4] = v22;
  v54[1] = v22;
  v54[2] = v22;
  v54[0] = v22;
  TClippingPathInfo::TClippingPathInfo((TClippingPathInfo *)v54, a3, 0);
  v52 = -1431655766;
  PathWidthAndFillRule = GetPathWidthAndFillRule(a2, &v52);
  v23 = *(_QWORD *)&v54[0];
  v24 = -1.0;
  if (a4)
    v24 = 1.0;
  v47 = v24;
  v50 = a7;
  do
  {
    MaxY = a6;
    while (v23 >= 1)
    {
      v26 = 0;
      v27 = 0;
      v28 = NAN;
      do
      {
        if (*(uint64_t *)&v54[0] <= v27)
        {
          v29 = 0;
        }
        else
        {
          v28 = *(double *)(*(_QWORD *)&v55.width + 8 * v27);
          v29 = (const CGPath *)atomic_load((unint64_t *)(*((_QWORD *)&v54[0] + 1) + 8 * v27));
        }
        if (CGPathIsRect(v29, &rect))
        {
          rect = CGRectInset(rect, v28 * -0.5, v28 * -0.5);
          MinX = CGRectGetMinX(rect);
          v66.origin.x = x;
          v66.origin.y = y;
          v66.size.width = width;
          v66.size.height = height;
          if (MinX <= CGRectGetMinX(v66) + a8)
          {
            MaxX = CGRectGetMaxX(rect);
            v67.origin.x = x;
            v67.origin.y = y;
            v67.size.width = width;
            v67.size.height = height;
            if (MaxX >= CGRectGetMaxX(v67) - a8 && MaxY + v50 > CGRectGetMinY(rect) && MaxY < CGRectGetMaxY(rect))
            {
              v32 = rect.origin.x;
              v33 = rect.origin.y;
              v34 = rect.size.width;
              v35 = rect.size.height;
              if (a4)
                MaxY = CGRectGetMaxY(*(CGRect *)&v32);
              else
                MaxY = CGRectGetMinY(*(CGRect *)&v32) - v50;
              v26 = 1;
            }
          }
        }
        ++v27;
      }
      while (v23 != v27);
      if ((v26 & 1) == 0)
        goto LABEL_32;
    }
    MaxY = a6;
LABEL_32:
    v68.origin.x = x;
    v68.origin.y = y;
    v68.size.width = width;
    v68.size.height = height;
    if (MaxY < CGRectGetMinY(v68)
      || (v69.origin.x = x,
          v69.origin.y = y,
          v69.size.width = width,
          v69.size.height = height,
          MaxY + v50 > CGRectGetMaxY(v69)))
    {
      v20 = 0;
      goto LABEL_57;
    }
    v51 = NAN;
    v36 = v52;
    v37 = CreateRectArrayFromPath(a1, v52 == kCTFramePathFillEvenOdd, (uint64_t *)v54, &v51, PathWidthAndFillRule, MaxY, MaxY + v50);
    Count = v37;
    v39 = Count;
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    v20 = v51 >= a8 && (uint64_t)Count > 0;

    if (v20)
    {
      if (a5)
        *a5 = MaxY;
LABEL_56:

      goto LABEL_57;
    }
    v41 = v47 + MaxY;
    v70.origin.x = x;
    v70.origin.y = y;
    v70.size.width = width;
    v70.size.height = height;
    if (v47 + MaxY < CGRectGetMinY(v70))
      goto LABEL_56;
    v71.origin.x = x;
    v71.origin.y = y;
    v71.size.width = width;
    v71.size.height = height;
    if (v41 + v50 > CGRectGetMaxY(v71))
      goto LABEL_56;
    a6 = v47 + MaxY;
    v42 = CreateRectArrayFromPath(a1, v36 == kCTFramePathFillEvenOdd, (uint64_t *)v54, &v51, PathWidthAndFillRule, v41, v41 + v50);
    v43 = v42;
    v44 = v43;
    if (v43)
      v45 = CFArrayGetCount(v43);
    else
      v45 = 0;
    v46 = v51;

  }
  while (v45 < 1 || v46 < a8);
  if (a5)
    *a5 = a6;
  v20 = 1;
LABEL_57:
  TClippingPathInfo::~TClippingPathInfo((TClippingPathInfo *)v54);
  return v20;
}

void TBaselineEngine::GetBaselineInfo(uint64_t a1, int a2, uint64_t a3)
{
  void *v7;
  const __CFData *v8;
  const __CFData *v9;
  unsigned __int16 *BytePtr;
  unint64_t v11;
  void *v12;
  void *v14;
  const __CFData *v15;
  const __CFData *v16;
  const UInt8 *v17;
  void *v18;
  id v19;
  const __CFData *v20;
  const __CFData *v21;
  const UInt8 *v22;
  void *v23;
  id v24;
  const __CFData *v25;
  const __CFData *v26;
  const UInt8 *v27;
  __int128 v28;
  id v29;
  id v30[2];
  __int128 v31;
  __int128 v32;
  __int128 v33;

  v29 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(a1 + 400) + 480))(&v29, *(_QWORD *)(a1 + 400), 1651731566);
  if (atomic_load((unint64_t *)&v29))
  {
    v7 = (void *)atomic_load((unint64_t *)&v29);
    v8 = v7;
    v9 = v8;
    if (v8)
      BytePtr = (unsigned __int16 *)CFDataGetBytePtr(v8);
    else
      BytePtr = 0;

    v18 = (void *)atomic_load((unint64_t *)&v29);
    v19 = v18;
    v20 = (const __CFData *)v19;
    if (v20)
    {
      v21 = v20;
      v22 = CFDataGetBytePtr(v20);

      if (v22)
        v22 += CFDataGetLength((CFDataRef)v19);
    }
    else
    {

      v22 = 0;
    }

    TAATBslnEngine::GetBaselineInfo(BytePtr, (unint64_t)v22, (const TBaseFont **)a1, a3);
  }
  else
  {
    (*(void (**)(id *__return_ptr, _QWORD, uint64_t))(**(_QWORD **)(a1 + 400) + 480))(v30, *(_QWORD *)(a1 + 400), 1111577413);
    do
      v11 = __ldaxr((unint64_t *)v30);
    while (__stlxr(0, (unint64_t *)v30));
    do
      v12 = (void *)__ldaxr((unint64_t *)&v29);
    while (__stlxr(v11, (unint64_t *)&v29));

    if (atomic_load((unint64_t *)&v29))
    {
      v14 = (void *)atomic_load((unint64_t *)&v29);
      v15 = v14;
      v16 = v15;
      if (v15)
        v17 = CFDataGetBytePtr(v15);
      else
        v17 = 0;

      v23 = (void *)atomic_load((unint64_t *)&v29);
      v24 = v23;
      v25 = (const __CFData *)v24;
      if (v25)
      {
        v26 = v25;
        v27 = CFDataGetBytePtr(v25);

        if (v27)
          v27 += CFDataGetLength((CFDataRef)v24);
      }
      else
      {

        v27 = 0;
      }

      *(_QWORD *)&v28 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v32 = v28;
      v33 = v28;
      *(_OWORD *)v30 = v28;
      v31 = v28;
      OTL::BASE::BASE((uint64_t)v30, (uint64_t)v17, (unint64_t)v27);
      if (v30[0])
        TOpenTypeBaselineEngine::GetBaselineInfo((unint64_t *)v30, (TFont *)a1, a2, a3, 0);
    }
    else if ((*(_BYTE *)a1 & 1) == 0)
    {
      TBaselineEngineImplementation::SynthesizeMissingBaselines(a1, a3, 0.0);
    }
  }

}

uint64_t TBaselineEngine::AlignBaselines(TBaselineEngine *this, TLine *a2, const TCharStream *a3)
{
  TBaselineEngine *v4;
  char *v5;
  int v6;
  double v7;
  int v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  char v14;
  int v15;
  int v16;
  char *v17;
  uint64_t v18;
  TLine **v19;
  int v20;
  uint64_t i;
  TLine **v22;
  __int16 v23;
  CGFloat a;
  CGFloat b;
  CGFloat v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int16 v33;
  int v34;
  uint64_t v35;
  TLine *v36;
  TLine *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  int v42;
  BOOL v43;
  BOOL v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  const __CFString *v48;
  const __CFString *v49;
  BOOL v50;
  unint64_t v51;
  void *v52;
  const __CTFont *v53;
  unint64_t v54;
  void *v55;
  CGFloat v56;
  int v57;
  const __CTFont *v58;
  unint64_t v59;
  void *v60;
  unint64_t v61;
  uint64_t v62;
  const __CTFont *v63;
  const __CTFont *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  _BYTE *v68;
  TLine **v69;
  TLine **v70;
  uint64_t v71;
  char v72;
  __int128 v73;
  BOOL v74;
  char v75;
  __int128 v76;
  uint64_t v77;
  double OriginalValueOf;
  double v79;
  const __CFString *v80;
  uint64_t v81;
  double v82;
  const __CTFontDescriptor *v83;
  const __CTFontDescriptor *v84;
  _OWORD *v85;
  __int128 v86;
  __int128 v87;
  const __CTFont *v88;
  unint64_t v89;
  void *v90;
  unint64_t v91;
  uint64_t v92;
  char v93;
  int v95;
  char v96;
  unint64_t v97;
  TBaselineEngine *v98;
  TLine *v99;
  TAttributes *v100;
  char *v101;
  __int16 v102;
  int v103;
  uint64_t v104;
  int v105;
  TLine *v106;
  TLine *v107;
  CGAffineTransform v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  unint64_t v112;
  TLine *__dst[42];
  void (**v114)(_anonymous_namespace_::BaselineRunComparator *__hidden);
  id v115;
  id v116;
  id v117;
  void *__p;
  char *v119;
  uint64_t v120;
  _BYTE v121[720];
  _QWORD v122[3];

  v122[1] = *MEMORY[0x1E0C80C00];
  v102 = *((_WORD *)this + 77);
  if ((v102 & 0x110) == 0)
  {
    v93 = 0;
    return v93 & 1;
  }
  v4 = this;
  memset(v121, 170, sizeof(v121));
  __p = 0;
  v119 = 0;
  v120 = 0;
  v122[0] = v121;
  v114 = &off_1E15DEBE0;
  TScriptRun::GetScriptRunsForLine(v4, (uint64_t)a2, (uint64_t)&v114, &__p);
  v5 = (char *)__p;
  v101 = v119;
  if (__p == v119)
  {
    v93 = 0;
    if (__p)
      goto LABEL_193;
    return v93 & 1;
  }
  v95 = 0;
  v6 = 0;
  v98 = v4;
  v7 = NAN;
  v99 = a2;
  do
  {
    v106 = (TLine *)*((_QWORD *)v5 + 1);
    v107 = *(TLine **)v5;
    v8 = *((_DWORD *)v5 + 4);
    v9 = 1;
    v10 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v4 + 2) + 8 * TLine::FindRunWithCharIndex(v4, *(_QWORD *)v5, 1)) + 48);
    if ((v102 & 0x100) == 0)
    {
      v11 = *(_QWORD *)(v10 + 184);
      if (v11)
      {
        if (*(_BYTE *)(v11 + 264))
          v11 += 136;
        else
          v11 = 0;
      }
      v9 = v11 != 0;
    }
    v12 = atomic_load((unint64_t *)(v10 + 56));
    v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v12 + 40) + 400) + 384))(*(_QWORD *)(*(_QWORD *)(v12 + 40) + 400));
    if (!v9 && (v13 & 1) == 0 && (*(_WORD *)(v10 + 178) & 0x2000) == 0)
    {
LABEL_163:
      v6 = 0;
      goto LABEL_176;
    }
    v103 = v13;
    memcpy(__dst, &unk_1849528D0, sizeof(__dst));
    __dst[0] = v4;
    __dst[1] = a2;
    __dst[2] = v107;
    __dst[3] = v106;
    v14 = 3;
    LODWORD(__dst[4]) = v8;
    if (v8 > 1818324576)
    {
      if (v8 <= 1936286819)
      {
        if (v8 > 1852143456)
        {
          if (v8 > 1935766897)
          {
            if (v8 == 1935766898)
              goto LABEL_66;
            v15 = 1936224868;
          }
          else
          {
            if (v8 == 1852143457)
              goto LABEL_66;
            v15 = 1869773153;
          }
        }
        else
        {
          if (v8 <= 1836016744)
          {
            if (v8 != 1818324577)
            {
              if (v8 != 1835103336)
                goto LABEL_179;
              v14 = 4;
            }
            goto LABEL_66;
          }
          if (v8 == 1836016745)
            goto LABEL_66;
          v15 = 1836344681;
        }
      }
      else if (v8 <= 1952541553)
      {
        if (v8 > 1936685422)
        {
          if (v8 == 1936685423)
            goto LABEL_66;
          v15 = 1937337455;
        }
        else
        {
          if (v8 == 1936286820)
            goto LABEL_66;
          v15 = 1936289380;
        }
      }
      else if (v8 <= 1953063539)
      {
        if (v8 == 1952541554)
          goto LABEL_66;
        v15 = 1952541813;
      }
      else
      {
        if (v8 == 1953063540 || v8 == 1953067624)
          goto LABEL_66;
        v15 = 2053205602;
      }
      goto LABEL_65;
    }
    if (v8 <= 1735750260)
    {
      if (v8 > 1667785068)
      {
        if (v8 > 1735549293)
        {
          if (v8 == 1735549294)
            goto LABEL_66;
          v15 = 1735748210;
        }
        else
        {
          if (v8 == 1667785069)
            goto LABEL_66;
          v15 = 1684371041;
        }
      }
      else if (v8 > 1650814566)
      {
        if (v8 == 1650814567)
          goto LABEL_66;
        v15 = 1651663208;
      }
      else
      {
        if (!v8)
        {
          v14 = -1;
          goto LABEL_66;
        }
        v15 = 1650551913;
      }
      goto LABEL_65;
    }
    if (v8 <= 1784772192)
    {
      if (v8 > 1751215720)
      {
        if (v8 == 1751215721)
        {
LABEL_58:
          v14 = 2;
          goto LABEL_66;
        }
        v16 = 1784769903;
      }
      else
      {
        if (v8 == 1735750261)
          goto LABEL_66;
        v16 = 1751215719;
      }
      if (v8 != v16)
        goto LABEL_179;
      goto LABEL_58;
    }
    if (v8 <= 1801547360)
    {
      if (v8 == 1784772193)
        goto LABEL_66;
      v15 = 1801546857;
      goto LABEL_65;
    }
    if (v8 == 1801547361)
      goto LABEL_58;
    if (v8 != 1802002802)
    {
      v15 = 1802791017;
LABEL_65:
      if (v8 != v15)
LABEL_179:
        v14 = 0;
    }
LABEL_66:
    v17 = v5;
    v18 = 0;
    v100 = (TAttributes *)(v10 + 40);
    BYTE4(__dst[4]) = v14;
    do
    {
      v19 = &__dst[v18];
      *((_BYTE *)v19 + 80) = 0;
      *((_BYTE *)v19 + 88) = 0;
      v18 += 2;
    }
    while (v18 != 16);
    v20 = v8;
    v104 = v10;
    v105 = v6;
    for (i = 0; i != 16; i += 2)
    {
      v22 = &__dst[i];
      *((_BYTE *)v22 + 208) = 0;
      *((_BYTE *)v22 + 216) = 0;
    }
    v23 = *((_WORD *)v4 + 77);
    v108.a = -3.72066208e-103;
    v108.b = -3.72066208e-103;
    TLine::GetClusterRange(v4, a2, (uint64_t)v107, 2, &v108, 0, 0);
    a = v108.a;
    b = v108.b;
    v108.a = -3.72066208e-103;
    v108.b = -3.72066208e-103;
    TLine::GetClusterRange(__dst[0], (_QWORD *)__dst[1], (uint64_t)v106 + (_QWORD)v107 - 1, 2, &v108, 0, 0);
    if (*(uint64_t *)&v108.a >= *(uint64_t *)&a)
      v26 = a;
    else
      v26 = v108.a;
    if (*(_QWORD *)&b + *(_QWORD *)&a <= *(_QWORD *)&v108.b + *(_QWORD *)&v108.a)
      v27 = *(_QWORD *)&v108.b + *(_QWORD *)&v108.a;
    else
      v27 = *(_QWORD *)&b + *(_QWORD *)&a;
    v28 = *((_QWORD *)__dst[0] + 2);
    v29 = *((_QWORD *)__dst[0] + 3);
    if (v28 == v29)
    {
      v36 = *(TLine **)&v26;
      v31 = *((_QWORD *)__dst[0] + 2);
      *(_QWORD *)&v32 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v33 = v23;
      v34 = v20;
      v5 = v17;
    }
    else
    {
      v30 = 0;
      v31 = *((_QWORD *)__dst[0] + 2);
      *(_QWORD *)&v32 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v33 = v23;
      v34 = v20;
      v5 = v17;
      while (1)
      {
        v35 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v31 + 40) + 208) + v30;
        if (v35 > *(uint64_t *)&v26)
          break;
        v31 += 8;
        v30 = v35;
        if (v31 == v29)
        {
          v36 = *(TLine **)&v26;
          v31 = *((_QWORD *)__dst[0] + 3);
          goto LABEL_83;
        }
      }
      v36 = (TLine *)(*(_QWORD *)&v26 - v30);
    }
LABEL_83:
    v37 = (TLine *)(v27 - *(_QWORD *)&v26);
    if (v31 != v29)
    {
      v38 = 0;
      v39 = v31;
      while (1)
      {
        v38 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v39 + 40) + 208);
        if (v38 >= (uint64_t)v37 + (uint64_t)v36)
          break;
        v39 += 8;
        if (v39 == v29)
          goto LABEL_89;
      }
      v29 = v39;
    }
LABEL_89:
    __dst[8] = v36;
    __dst[9] = v37;
    __dst[6] = (TLine *)((v31 - v28) >> 3);
    __dst[7] = (TLine *)(((v29 - v28) >> 3) - (unint64_t)__dst[6] + 1);
    v40 = *(unint64_t **)(*(_QWORD *)(*((_QWORD *)v4 + 2) + 8 * (uint64_t)__dst[6]) + 40);
    __dst[5] = (TLine *)v40;
    v41 = v40[23];
    if (v41)
    {
      v42 = *(unsigned __int8 *)(v41 + 264);
      v43 = *(_BYTE *)(v41 + 264) == 0;
      if (*(_BYTE *)(v41 + 264))
        v44 = 0;
      else
        v44 = (v33 & 0x100) == 0;
      if (v44)
        goto LABEL_152;
      v45 = v41 + 136;
      if (*(_BYTE *)(v41 + 264))
        v46 = v41 + 136;
      else
        v46 = 0;
      v47 = atomic_load((unint64_t *)(v41 + 272));
      v48 = CFSTR("CTBaselineVerticalFont");
      if ((v33 & 0x100) == 0)
        v48 = 0;
      if (v47)
        v49 = (const __CFString *)v47;
      else
        v49 = v48;
      if (v49)
        v50 = 0;
      else
        v50 = (v33 & 0x100) == 0;
      if (v50)
      {
        if (v42)
          goto LABEL_143;
        goto LABEL_152;
      }
      v96 = v43;
      v97 = v46;
    }
    else
    {
      if ((v33 & 0x100) == 0)
        goto LABEL_152;
      v97 = 0;
      v96 = 1;
      v49 = CFSTR("CTBaselineVerticalFont");
    }
    v117 = 0;
    if (CFEqual(v49, CFSTR("CTBaselineOriginalFont")))
    {
      TAttributes::OriginalFont((TAttributes *)(v40 + 5), (unint64_t *)&v108);
      do
        v51 = __ldaxr((unint64_t *)&v108);
      while (__stlxr(0, (unint64_t *)&v108));
      do
        v52 = (void *)__ldaxr((unint64_t *)&v117);
      while (__stlxr(v51, (unint64_t *)&v117));
    }
    else
    {
      if (CFEqual(v49, CFSTR("CTBaselineVerticalFont")))
      {
        TAttributes::OriginalFont((TAttributes *)(v40 + 5), (unint64_t *)&v116);
        v58 = (const __CTFont *)atomic_load((unint64_t *)&v116);
        VerticalCopyOf(v58, (CTFontRef *)&v108);
        do
          v59 = __ldaxr((unint64_t *)&v108);
        while (__stlxr(0, (unint64_t *)&v108));
        do
          v60 = (void *)__ldaxr((unint64_t *)&v117);
        while (__stlxr(v59, (unint64_t *)&v117));

        v56 = *(double *)&v116;
        goto LABEL_126;
      }
      *(_QWORD *)&v108.a = (id)_CTFontEnsureFontRef(v49);
      do
        v66 = __ldaxr((unint64_t *)&v108);
      while (__stlxr(0, (unint64_t *)&v108));
      do
        v52 = (void *)__ldaxr((unint64_t *)&v117);
      while (__stlxr(v66, (unint64_t *)&v117));
    }

    if ((v33 & 0x100) != 0)
    {
      v53 = (const __CTFont *)atomic_load((unint64_t *)&v117);
      VerticalCopyOf(v53, (CTFontRef *)&v108);
      do
        v54 = __ldaxr((unint64_t *)&v108);
      while (__stlxr(0, (unint64_t *)&v108));
      do
        v55 = (void *)__ldaxr((unint64_t *)&v117);
      while (__stlxr(v54, (unint64_t *)&v117));

      v56 = v108.a;
LABEL_126:

      v57 = 1;
      goto LABEL_127;
    }
    v57 = 0;
LABEL_127:
    v61 = atomic_load((unint64_t *)&v117);
    v62 = *(_QWORD *)(v61 + 40);
    TBaselineEngine::GetBaselineInfo(v62, v34, (uint64_t)&__dst[26]);
    v63 = (const __CTFont *)atomic_load(v40 + 7);
    if (!v57
      || (v64 = (const __CTFont *)atomic_load((unint64_t *)&v117), v64 == v63)
      || v63 && v64 && CFEqual(v64, v63))
    {
LABEL_141:
      TBaselineEngineImplementation::SynthesizeMissingBaselines(v62, (uint64_t)&__dst[26], 0.0);
    }
    else
    {
      v65 = 0;
      while (LOBYTE(__dst[v65 + 27]))
      {
        v65 += 2;
        if (v65 == 16)
          goto LABEL_141;
      }
      v83 = CTFontCopyFontDescriptor(v63);
      v84 = v83;
      v85 = *(_OWORD **)(v62 + 40);
      if (!v85)
        v85 = (_OWORD *)MEMORY[0x1E0C9BAA8];
      v87 = v85[1];
      v86 = v85[2];
      *(_OWORD *)&v108.a = *v85;
      *(_OWORD *)&v108.c = v87;
      *(_OWORD *)&v108.tx = v86;
      v116 = CTFontCreateWithFontDescriptor(v83, *(CGFloat *)(v62 + 16), &v108);
      v88 = (const __CTFont *)atomic_load((unint64_t *)&v116);
      VerticalCopyOf(v88, (CTFontRef *)&v115);
      do
        v89 = __ldaxr((unint64_t *)&v115);
      while (__stlxr(0, (unint64_t *)&v115));
      do
        v90 = (void *)__ldaxr((unint64_t *)&v116);
      while (__stlxr(v89, (unint64_t *)&v116));

      v91 = atomic_load((unint64_t *)&v116);
      v92 = *(_QWORD *)(v91 + 40);
      TBaselineEngine::GetBaselineInfo(v92, v34, (uint64_t)&__dst[26]);
      TBaselineEngineImplementation::SynthesizeMissingBaselines(v92, (uint64_t)&__dst[26], 0.0);

    }
    *(_QWORD *)&v32 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v45 = v97;
    if ((v96 & 1) == 0)
    {
LABEL_143:
      v67 = 0;
      v68 = (_BYTE *)(v45 + 8);
      v69 = &__dst[27];
      do
      {
        if (*v68)
        {
          *(v69 - 1) = (TLine *)*((_QWORD *)v68 - 1);
          *(_BYTE *)v69 = 1;
          if (v67 != 5)
          {
            if (v67 != 2)
              goto LABEL_151;
            v70 = &__dst[39];
            if (!LOBYTE(__dst[39]))
              goto LABEL_151;
LABEL_150:
            *(_BYTE *)v70 = 0;
            goto LABEL_151;
          }
          v70 = &__dst[41];
          if (LOBYTE(__dst[41]))
            goto LABEL_150;
        }
LABEL_151:
        ++v67;
        v69 += 2;
        v68 += 16;
      }
      while (v67 != 8);
    }
LABEL_152:
    v112 = 0xAAAAAAAAAAAAAAAALL;
    v110 = v32;
    v111 = v32;
    *(_OWORD *)&v108.tx = v32;
    v109 = v32;
    *(_OWORD *)&v108.a = v32;
    *(_OWORD *)&v108.c = v32;
    TOpenTypeBaselineEngine::TOpenTypeBaselineEngine(&v108, (uint64_t)__dst);
    if (((*(uint64_t (**)(CGAffineTransform *))(*(_QWORD *)&v108.a + 24))(&v108) & 1) != 0)
    {
      v4 = v98;
      a2 = v99;
      v6 = v105;
      v71 = v104;
      if (v103)
        v95 |= TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics((TOpenTypeBaselineEngine *)&v108);
      if (!v9)
      {
        *(_QWORD *)&v108.a = &off_1E15DE670;

        goto LABEL_176;
      }
      v72 = TBaselineEngineImplementation::AlignBaselinesForRuns((TBaselineEngineImplementation *)&v108);
      *(_QWORD *)&v108.a = &off_1E15DE670;

      if ((v72 & 1) != 0)
        goto LABEL_160;
    }
    else
    {
      *(_QWORD *)&v108.a = &off_1E15DE670;

      v4 = v98;
      a2 = v99;
      v6 = v105;
      v71 = v104;
    }
    *(_QWORD *)&v73 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v73 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v108.c = v73;
    *(_OWORD *)&v108.tx = v73;
    *(_OWORD *)&v108.a = v73;
    TAATBslnEngine::TAATBslnEngine(&v108, (uint64_t)__dst);
    v74 = TAATBslnEngine::AlignBaselinesForRuns((TAATBslnEngine *)&v108);
    TAATBslnEngine::~TAATBslnEngine((TAATBslnEngine *)&v108);
    if (!v74)
    {
      v108.tx = -3.72066208e-103;
      *(_QWORD *)&v76 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v76 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v108.a = v76;
      *(_OWORD *)&v108.c = v76;
      TGenericBaselineEngine::TGenericBaselineEngine(&v108, (uint64_t)__dst);
      v75 = TBaselineEngineImplementation::AlignBaselinesForRuns((TBaselineEngineImplementation *)&v108);
      *(_QWORD *)&v108.a = &off_1E15DE670;

      goto LABEL_162;
    }
LABEL_160:
    v75 = 1;
LABEL_162:
    if ((*(_WORD *)(v71 + 178) & 0x2000) == 0)
      goto LABEL_163;
    if ((v75 & 1) != 0)
    {
      v77 = *(_QWORD *)(v71 + 160);
      OriginalValueOf = 0.0;
      if (v77)
      {
        v79 = *(double *)(v77 + 48);
        v80 = *(const __CFString **)(v77 + 40);
        if (v80)
          OriginalValueOf = TAttributes::GetOriginalValueOf(v100, v80);
      }
      else
      {
        v79 = 0.0;
      }
      v7 = v79 - OriginalValueOf;
      v6 = 1;
    }
    else if (v6)
    {
      v6 = 1;
      if (v107 == *(TLine **)(v71 + 8) && v106 == *(TLine **)(v71 + 16))
      {
        v81 = *(_QWORD *)(v71 + 160);
        v82 = v81 ? *(double *)(v81 + 48) : 0.0;
        if (v82 != v7 + v82)
        {
          *(double *)(TAttributes::EnsureRareData(v100) + 48) = v7 + v82;
          *(_BYTE *)(v71 + 89) = 1;
        }
      }
    }
LABEL_176:
    v5 += 24;
  }
  while (v5 != v101);
  v5 = (char *)__p;
  v93 = v95;
  if (!__p)
    return v93 & 1;
LABEL_193:
  v119 = v5;
  if (v121 > v5 || v122 <= (_QWORD *)v5)
    operator delete(v5);
  return v93 & 1;
}

uint64_t TBaselineEngineImplementation::AlignBaselinesForRuns(TBaselineEngineImplementation *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v8;
  BOOL v9;
  int v10;
  unsigned int v12;

  result = (*(uint64_t (**)(TBaselineEngineImplementation *))(*(_QWORD *)this + 24))(this);
  if ((_DWORD)result)
  {
    v3 = *((_QWORD *)this + 1);
    if (*(uint64_t *)(v3 + 56) < 1)
    {
      return 0;
    }
    else
    {
      v4 = *(_QWORD *)(v3 + 40);
      v5 = *(_QWORD *)(v4 + 184);
      if (!v5 || (v6 = *(unsigned __int8 *)(v5 + 280), v6 == 255))
      {
        v6 = *(unsigned __int8 *)(v3 + 36);
        if (v6 == 3)
        {
          if ((*(_WORD *)(v4 + 178) & 0x2000) != 0)
            v6 = 0;
          else
            v6 = 3;
        }
        else if (v6 == 5 || v6 == 2)
        {
          v8 = *(_DWORD *)(v3 + 32);
          if (v8 > 1784769902)
          {
            v9 = v8 == 1801547361;
            v10 = 1784769903;
          }
          else
          {
            v9 = v8 == 1751215719;
            v10 = 1751215721;
          }
          if (v9 || v8 == v10)
          {
            v12 = v6 == 2 ? 6 : 7;
            if ((TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs((uint64_t)this, v12) & 1) != 0)
              return 1;
          }
        }
      }
      return TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs((uint64_t)this, v6);
    }
  }
  return result;
}

void TBaselineEngineImplementation::SynthesizeMissingBaselines(uint64_t a1, uint64_t a2, double a3)
{
  double TypoAscentDescent;
  double v7;
  double v8;
  int *v9;
  int *inited;
  double v11;
  int *v12;
  char v13;
  double v14;
  int *v15;
  int *v16;
  uint64_t v17;
  CGAffineTransform v18;

  TypoAscentDescent = TBaselineEngineImplementation::GetTypoAscentDescent((TBaseFont **)a1, (const TFont *)a2);
  v8 = v7;
  if (a3 == 0.0 && (*(_BYTE *)a1 & 1) != 0)
  {
    if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 400) + 472))(*(_QWORD *)(a1 + 400), 1986884728) & 1) != 0|| (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 400) + 472))(*(_QWORD *)(a1 + 400), 1448038983))
    {
      v9 = (int *)(a1 + 48);
      inited = (int *)(a1 + 48);
      if (!*(_DWORD *)(a1 + 48))
        inited = TFont::InitStrikeMetrics((TFont *)a1);
      v11 = *((double *)inited + 6);
      if (!*v9)
        v9 = TFont::InitStrikeMetrics((TFont *)a1);
      a3 = v11 * (double)*v9 * -0.5 - v8;
    }
    else
    {
      if (*(_DWORD *)(a1 + 48))
        v12 = (int *)(a1 + 48);
      else
        v12 = TFont::InitStrikeMetrics((TFont *)a1);
      a3 = *((double *)v12 + 4) * -0.5;
    }
  }
  if (!*(_BYTE *)(a2 + 88))
  {
    *(double *)(a2 + 80) = TypoAscentDescent + a3;
    *(_BYTE *)(a2 + 88) = 1;
  }
  if (!*(_BYTE *)(a2 + 40))
  {
    v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 400) + 736))(*(_QWORD *)(a1 + 400));
    v14 = v8;
    if ((v13 & 1) == 0)
    {
      v15 = *(_DWORD *)(a1 + 48) ? (int *)(a1 + 48) : TFont::InitStrikeMetrics((TFont *)a1);
      v14 = *((double *)v15 + 4) * -0.15;
      if (v14 >= 0.0)
        v14 = v8 * 0.5;
    }
    *(double *)(a2 + 32) = a3 + v14;
    *(_BYTE *)(a2 + 40) = 1;
  }
  if (!*(_BYTE *)(a2 + 8))
  {
    *(double *)a2 = a3;
    *(_BYTE *)(a2 + 8) = 1;
  }
  if (!*(_BYTE *)(a2 + 24) && *(_BYTE *)(a2 + 88))
  {
    *(double *)(a2 + 16) = (*(double *)(a2 + 80) + *(double *)(a2 + 32)) * 0.5;
    *(_BYTE *)(a2 + 24) = 1;
  }
  if (!*(_BYTE *)(a2 + 56))
  {
    if (*(_DWORD *)(a1 + 48))
      v16 = (int *)(a1 + 48);
    else
      v16 = TFont::InitStrikeMetrics((TFont *)a1);
    *(double *)(a2 + 48) = a3 + *((double *)v16 + 4);
    *(_BYTE *)(a2 + 56) = 1;
  }
  if (!*(_BYTE *)(a2 + 72))
  {
    v17 = *(_QWORD *)(a1 + 400);
    TFont::GetScaledMatrix((TFont *)a1, &v18);
    *(double *)(a2 + 64) = a3
                         + (*(double (**)(uint64_t, CGAffineTransform *))(*(_QWORD *)v17 + 608))(v17, &v18)
                         * 0.5;
    *(_BYTE *)(a2 + 72) = 1;
  }
}

_QWORD *TBaselineEngineImplementation::TBaselineEngineImplementation(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  void *v5;
  const __CFData *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  void *v9;
  id v10;
  const __CFData *v11;
  const __CFData *v12;
  const UInt8 *v13;

  *a1 = &off_1E15DE670;
  a1[1] = a2;
  if ((_DWORD)a3)
  {
    v4 = atomic_load((unint64_t *)(*(_QWORD *)(a2 + 40) + 56));
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(v4 + 40) + 400) + 480))(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 400), a3);
  }
  else
  {
    a1[2] = 0;
  }
  v5 = (void *)atomic_load(a1 + 2);
  v6 = v5;
  v7 = v6;
  if (v6)
    BytePtr = CFDataGetBytePtr(v6);
  else
    BytePtr = 0;

  a1[3] = BytePtr;
  v9 = (void *)atomic_load(a1 + 2);
  v10 = v9;
  v11 = (const __CFData *)v10;
  if (v11)
  {
    v12 = v11;
    v13 = CFDataGetBytePtr(v11);

    if (v13)
      v13 += CFDataGetLength((CFDataRef)v10);
  }
  else
  {

    v13 = 0;
  }

  a1[4] = v13;
  return a1;
}

void TBaselineEngineImplementation::~TBaselineEngineImplementation(id *this)
{
  *this = &off_1E15DE670;

}

{
  *this = &off_1E15DE670;

  JUMPOUT(0x186DC03ACLL);
}

uint64_t TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  v3 = v2 + 208;
  if (!*(_BYTE *)(v2 + 208 + 16 * a2 + 8))
    return 0;
  v4 = v2 + 80;
  if (!*(_BYTE *)(v4 + 16 * a2 + 8))
    return 0;
  v5 = *(double *)(v3 + 16 * a2) - *(double *)(v4 + 16 * a2);
  if (v5 != 0.0)
  {
    v9[0] = &off_1E15E0688;
    *(double *)&v9[1] = v5;
    v10 = v9;
    TBaselineEngineImplementation::ApplyToRuns(a1, (uint64_t)v9);
    v6 = v10;
    if (v10 == v9)
    {
      v7 = 4;
      v6 = v9;
      goto LABEL_9;
    }
    if (v10)
    {
      v7 = 5;
LABEL_9:
      (*(void (**)(void))(*v6 + 8 * v7))();
    }
  }
  return 1;
}

double TBaselineEngineImplementation::GetTypoAscentDescent(TBaseFont **this, const TFont *a2)
{
  uint64_t v4;
  double v5;

  v4 = -1;
  v5 = NAN;
  if ((TFont::GetTypoMetrics(this, &v5, (double *)&v4, 0) & 1) != 0)
    return v5;
  else
    return TFont::GetHorizontalAscentDescent(this);
}

BOOL TBaselineEngineImplementation::ApplyToRuns(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  _BOOL8 v32;

  v2 = *(uint64_t **)(a1 + 8);
  if (v2[7] < 1 || (v3 = v2[9], v3 < 1))
  {
    LOBYTE(v6) = 0;
    return v6 & 1;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = v2[8];
    v9 = *v2;
    v10 = v3 + v8;
    v11 = v2[6];
    for (i = *(_QWORD *)(*v2 + 16) + 8 * v11; ; i = v30 + 8 * v11)
    {
      v13 = *(_QWORD **)(*(_QWORD *)i + 48);
      v14 = v13[26];
      if (v8 != v7)
      {
        v15 = *(_QWORD *)(*(_QWORD *)(v13[27] + 48) + 8 * v13[25] + 8 * (v8 - v7));
        v16 = v13[1];
        v17 = v15 - v16;
        if (v15 >= v16 && v17 < v13[2])
        {
          if (v15 == v16)
            return v6 & 1;
          TLine::SplitRun(v9, v11, v17);
          v18 = *(_QWORD *)(a1 + 8);
          v20 = *(_QWORD *)(v18 + 48);
          v19 = *(_QWORD *)(v18 + 56);
          if (v20 <= v11 && v19 + v20 > v11)
            *(_QWORD *)(v18 + 56) = v19 + 1;
          v13 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v9 + 16) + 8 * v11) + 48);
          v14 = v13[26];
          v6 = 1;
        }
      }
      if (v10 - v7 < v14)
      {
        v22 = *(_QWORD *)(*(_QWORD *)(v13[27] + 48) + 8 * v13[25] + 8 * (v10 - v7));
        v23 = v13[1];
        v24 = v22 - v23;
        if (v22 >= v23 && v24 < v13[2])
        {
          if (v22 == v23)
            return v6 & 1;
          TLine::SplitRun(v9, v11, v24);
          v25 = *(_QWORD *)(a1 + 8);
          v27 = *(_QWORD *)(v25 + 48);
          v26 = *(_QWORD *)(v25 + 56);
          if (v27 <= v11 && v26 + v27 > v11)
            *(_QWORD *)(v25 + 56) = v26 + 1;
          v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 16) + 8 * v11) + 48) + 208);
          v6 = 1;
        }
      }
      v29 = *(_QWORD *)(a2 + 24);
      if (!v29)
        break;
      v6 |= (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 48))(v29);
      v8 += v14;
      if (v8 >= v10)
        return v6 & 1;
      ++v11;
      v30 = *(_QWORD *)(v9 + 16);
      if (v11 >= (*(_QWORD *)(v9 + 24) - v30) >> 3)
        return v6 & 1;
      v7 += v14;
    }
    v32 = std::__throw_bad_function_call[abi:nn180100]();
    return TBaselineEngineImplementation::CanProcess((TBaselineEngineImplementation *)v32);
  }
}

BOOL TBaselineEngineImplementation::CanProcess(TBaselineEngineImplementation *this)
{
  return *((_QWORD *)this + 3) != 0;
}

void `anonymous namespace'::BaselineRunComparator::~BaselineRunComparator(_anonymous_namespace_::BaselineRunComparator *this)
{
  JUMPOUT(0x186DC03ACLL);
}

BOOL `anonymous namespace'::BaselineRunComparator::RunsSimilar(_anonymous_namespace_::BaselineRunComparator *this, const TRun *a2, const TRun *a3)
{
  _BYTE *v6;
  int v7;
  _BYTE *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v6 = (_BYTE *)*((_QWORD *)a2 + 23);
  if (v6)
    v7 = v6[280];
  else
    v7 = 255;
  v8 = (_BYTE *)*((_QWORD *)a3 + 23);
  if (v8)
    v9 = v8[280];
  else
    v9 = 255;
  if (v7 != v9)
    return 0;
  if (v6)
  {
    if (v6[128])
      v10 = *((_QWORD *)a2 + 23);
    else
      v10 = 0;
    if (v8)
      goto LABEL_13;
LABEL_17:
    v11 = 0;
    goto LABEL_18;
  }
  v10 = 0;
  if (!v8)
    goto LABEL_17;
LABEL_13:
  if (v8[128])
    v11 = *((_QWORD *)a3 + 23);
  else
    v11 = 0;
LABEL_18:
    return 0;
  if (v6)
  {
    if (v6[264])
      v12 = (uint64_t)(v6 + 136);
    else
      v12 = 0;
    if (v8)
      goto LABEL_24;
LABEL_28:
    v13 = 0;
    goto LABEL_29;
  }
  v12 = 0;
  if (!v8)
    goto LABEL_28;
LABEL_24:
  if (v8[264])
    v13 = (uint64_t)(v8 + 136);
  else
    v13 = 0;
LABEL_29:
    return TRunComparator::RunsSimilar(this, a2, a3);
  return 0;
}

uint64_t `anonymous namespace'::BaselineRunComparator::EqualBaselineInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  BOOL v5;

  if (a1 == a2)
    return 1;
  v2 = 0;
  if (a1 && a2)
  {
    v3 = 0;
    while (1)
    {
      v4 = *(unsigned __int8 *)(a2 + v3 + 8);
      if (*(_BYTE *)(a1 + v3 + 8))
        v5 = v4 == 0;
      else
        v5 = 1;
      if (v5)
      {
        if ((*(_BYTE *)(a1 + v3 + 8) != 0) != (v4 != 0))
          return 0;
      }
      else if (*(double *)(a1 + v3) != *(double *)(a2 + v3))
      {
        return 0;
      }
      v3 += 16;
      if (v3 == 128)
        return 1;
    }
  }
  return v2;
}

void std::__function::__func<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0,std::allocator<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0>,BOOL ()(TRun &)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0,std::allocator<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0>,BOOL ()(TRun &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15E0688;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0,std::allocator<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0>,BOOL ()(TRun &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15E0688;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0,std::allocator<TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs(BaselineClass)::$_0>,BOOL ()(TRun &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  double v4;
  double v5;

  v3 = *(_QWORD *)(a2 + 160);
  if (v3)
  {
    v4 = *(double *)(v3 + 48);
    v5 = v4 + *(double *)(a1 + 8);
  }
  else
  {
    v4 = 0.0;
    v5 = *(double *)(a1 + 8) + 0.0;
  }
  if (v4 != v5)
  {
    *(double *)(TAttributes::EnsureRareData((TAttributes *)(a2 + 40)) + 48) = v5;
    *(_BYTE *)(a2 + 89) = 1;
  }
  return 1;
}

_QWORD *TAATBslnEngine::TAATBslnEngine(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  __int128 *v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;

  v3 = TBaselineEngineImplementation::TBaselineEngineImplementation(a1, a2, 1651731566);
  *v3 = &off_1E15DD2E8;
  v3[5] = 0;
  v4 = *(_QWORD *)(v3[1] + 40);
  v5 = atomic_load((unint64_t *)(v4 + 56));
  v6 = (unsigned int *)v3[3];
  if (!v6 || (**(_BYTE **)(v5 + 40) & 1) != 0)
    goto LABEL_13;
  v7 = a1[1];
  v8 = *(__int128 **)(*(_QWORD *)(v7 + 40) + 184);
  if (v8 && *((_BYTE *)v8 + 128))
  {
    v9 = v7 + 80;
    v10 = *v8;
    v11 = v8[1];
    v12 = v8[3];
    *(_OWORD *)(v7 + 112) = v8[2];
    *(_OWORD *)(v7 + 128) = v12;
    *(_OWORD *)(v7 + 80) = v10;
    *(_OWORD *)(v7 + 96) = v11;
    v13 = v8[4];
    v14 = v8[5];
    v15 = v8[7];
    *(_OWORD *)(v7 + 176) = v8[6];
    *(_OWORD *)(v7 + 192) = v15;
    *(_OWORD *)(v7 + 144) = v13;
    *(_OWORD *)(v7 + 160) = v14;
  }
  else
  {
    v16 = 0;
    v9 = v7 + 80;
    v17 = v7 + 88;
    do
    {
      if (*(_BYTE *)(v17 + v16))
        *(_BYTE *)(v17 + v16) = 0;
      v16 += 16;
    }
    while (v16 != 128);
  }
  if ((int)bswap32(*v6) < 0x10000
    || (v18 = a1[4],
        v19 = atomic_load((unint64_t *)(v4 + 56)),
        (TAATBslnEngine::GetBaselineInfo((unsigned __int16 *)v6, v18, *(const TBaseFont ***)(v19 + 40), v9) & 1) == 0))
  {
    v20 = (unint64_t *)(v4 + 56);
    atomic_load(v20);
    CFLog();
    v21 = atomic_load(v20);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(v21 + 40) + 400) + 488))(*(_QWORD *)(*(_QWORD *)(v21 + 40) + 400), 1651731566);
LABEL_13:
    a1[3] = 0;
  }
  return a1;
}

uint64_t TAATBslnEngine::GetBaselineInfo(unsigned __int16 *a1, unint64_t a2, const TBaseFont **this, uint64_t a4)
{
  __int128 v8;
  uint64_t v9;
  double b;
  double d;
  double ty;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  BOOL v25;
  unint64_t v26;
  const TBaseFont *v28;
  unsigned __int16 *v29;
  unsigned int v30;
  uint64_t i;
  uint64_t v32;
  double ControlPointCoordinates;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int16 *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  CGAffineTransform v46;
  void **v47;
  id __b[138];

  __b[137] = *(id *)MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)this & 1) != 0)
    return 0;
  *(_QWORD *)&v8 = -1;
  *((_QWORD *)&v8 + 1) = -1;
  *(_OWORD *)&v46.c = v8;
  *(_OWORD *)&v46.tx = v8;
  *(_OWORD *)&v46.a = v8;
  TFont::GetScaledMatrix((TFont *)this, &v46);
  switch(bswap32(a1[2]) >> 16)
  {
    case 0u:
LABEL_3:
      if ((unint64_t)(a1 + 36) > a2)
        goto LABEL_36;
      v9 = 0;
      b = v46.b;
      d = v46.d;
      ty = v46.ty;
      do
      {
        if ((unint64_t)(v9 - 6) >= 0x1A)
        {
          v13 = a4 + 16 * bslnToBaselineMap[v9];
          if (!*(_BYTE *)(v13 + 8))
          {
            *(double *)v13 = ty + d * (double)((int)bswap32(a1[v9 + 4]) >> 16) + b * 0.0;
            *(_BYTE *)(v13 + 8) = 1;
          }
        }
        ++v9;
      }
      while (v9 != 32);
      goto LABEL_44;
    case 1u:
      if ((unint64_t)(a1 + 37) <= a2)
      {
        v14 = 0;
        switch(bswap32(a1[36]) >> 16)
        {
          case 0u:
            goto LABEL_3;
          case 2u:
          case 4u:
          case 6u:
            if ((unint64_t)(a1 + 39) > a2)
              return 0;
            v18 = a1 + 42;
            v19 = bswap32(a1[37]) >> 16;
            v20 = a1[38];
            goto LABEL_64;
          case 8u:
            v39 = a1 + 39;
            if ((unint64_t)(a1 + 39) <= a2)
            {
              v40 = bswap32(a1[38]) >> 16;
              v41 = (unint64_t)&v39[v40];
              v42 = (unint64_t)(a1 + 40) <= a2 ? (a2 - (unint64_t)v39) >> 1 : 0;
              v43 = v41 <= a2 && v41 >= (unint64_t)v39;
              if (v43 || v42 == v40)
                goto LABEL_3;
            }
            return 0;
          case 0xAu:
            v18 = a1 + 40;
            if ((unint64_t)(a1 + 40) > a2)
              return 0;
            v19 = bswap32(a1[37]) >> 16;
            v20 = a1[39];
LABEL_64:
            v44 = (unint64_t)v18 + (bswap32(v20) >> 16) * (unint64_t)v19;
            if (v44 >= (unint64_t)v18 && v44 <= a2)
              goto LABEL_3;
            return 0;
          default:
            return v14;
        }
      }
      return 0;
    case 2u:
LABEL_35:
      if ((unint64_t)(a1 + 37) > a2)
        goto LABEL_36;
      v28 = this[50];
      if (!v28)
        goto LABEL_36;
      v29 = a1 + 5;
      v30 = bswap32(a1[4]) >> 16;
      memset(__b, 170, 0x448uLL);
      TAATControlPointAccess::TAATControlPointAccess((TAATControlPointAccess *)__b, v28);
      for (i = 0; i != 32; ++i)
      {
        if ((unint64_t)(i - 6) >= 0x1A)
        {
          v32 = bslnToBaselineMap[i];
          ControlPointCoordinates = TAATControlPointAccess::GetControlPointCoordinates((TAATControlPointAccess *)__b, v30, bswap32(v29[i]) >> 16);
          v35 = a4 + 16 * v32;
          if (!*(_BYTE *)(v35 + 8))
          {
            *(double *)v35 = v46.ty + v34 * v46.d + v46.b * ControlPointCoordinates;
            *(_BYTE *)(v35 + 8) = 1;
          }
        }
      }

      v47 = &__b[2];
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,64ul>>::__destroy_vector::operator()[abi:nn180100](&v47);
LABEL_44:
      v14 = 1;
      break;
    case 3u:
      if ((unint64_t)(a1 + 38) <= a2)
      {
        v14 = 0;
        switch(bswap32(a1[37]) >> 16)
        {
          case 0u:
            goto LABEL_35;
          case 2u:
          case 4u:
          case 6u:
            if ((unint64_t)(a1 + 40) > a2)
              goto LABEL_36;
            v15 = a1 + 43;
            v16 = bswap32(a1[38]) >> 16;
            v17 = a1[39];
            goto LABEL_31;
          case 8u:
            v21 = a1 + 40;
            if ((unint64_t)(a1 + 40) <= a2)
            {
              v22 = bswap32(a1[39]) >> 16;
              v23 = (unint64_t)&v21[v22];
              v24 = (unint64_t)(a1 + 41) <= a2 ? (a2 - (unint64_t)v21) >> 1 : 0;
              v25 = v23 <= a2 && v23 >= (unint64_t)v21;
              if (v25 || v24 == v22)
                goto LABEL_35;
            }
            goto LABEL_36;
          case 0xAu:
            v15 = a1 + 41;
            if ((unint64_t)(a1 + 41) > a2)
              goto LABEL_36;
            v16 = bswap32(a1[38]) >> 16;
            v17 = a1[40];
LABEL_31:
            v26 = (unint64_t)v15 + (bswap32(v17) >> 16) * (unint64_t)v16;
            if (v26 >= (unint64_t)v15 && v26 <= a2)
              goto LABEL_35;
            goto LABEL_36;
          default:
            goto LABEL_45;
        }
      }
      goto LABEL_36;
    default:
LABEL_36:
      v14 = 0;
      break;
  }
LABEL_45:
  v36 = 0;
  LODWORD(__b[0]) = 67306754;
  do
  {
    v37 = a4 + 16 * *((unsigned __int8 *)__b + v36);
    if (*(_BYTE *)(v37 + 8) && *(double *)v37 == 0.0)
      *(_BYTE *)(v37 + 8) = 0;
    ++v36;
  }
  while (v36 != 4);
  TBaselineEngineImplementation::SynthesizeMissingBaselines((uint64_t)this, a4, 0.0);
  return v14;
}

void TAATBslnEngine::~TAATBslnEngine(TAATBslnEngine *this)
{
  _QWORD *v2;
  void **v3;
  void **v4;

  *(_QWORD *)this = &off_1E15DD2E8;
  v4 = (void **)*((_QWORD *)this + 5);
  v2 = (_QWORD *)((char *)this + 40);
  v3 = v4;
  *v2 = 0;
  if (v4)
    std::default_delete<TAATControlPointAccess>::operator()[abi:nn180100]((uint64_t)v2, v3);
  *(_QWORD *)this = &off_1E15DE670;

}

{
  TAATBslnEngine::~TAATBslnEngine(this);
  JUMPOUT(0x186DC03ACLL);
}

BOOL TAATBslnEngine::AlignBaselinesForRuns(TAATBslnEngine *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  const SFNTLookupTable *v9;

  v1 = *((_QWORD *)this + 3);
  if (v1)
  {
    v2 = *((_QWORD *)this + 1);
    if (*(uint64_t *)(v2 + 56) >= 1)
    {
      v3 = *(_QWORD *)(v2 + 40);
      v4 = *(_QWORD *)(v3 + 184);
      if (v4)
      {
        v5 = *(unsigned __int8 *)(v4 + 280);
        if (v5 != 255)
        {
LABEL_15:
          TBaselineEngineImplementation::ApplySameBaselineToAllGlyphs((uint64_t)this, v5);
          return v1 != 0;
        }
      }
      v5 = *(unsigned __int8 *)(v2 + 36);
      if (v5 != 255)
      {
        if (v5 == 3)
        {
          if ((*(_WORD *)(v3 + 178) & 0x2000) != 0)
            v5 = 0;
          else
            v5 = 3;
        }
        goto LABEL_15;
      }
      v6 = bswap32(*(unsigned __int16 *)(v1 + 6)) >> 16;
      if (v6 > 0x1F)
        v7 = 0;
      else
        v7 = bslnToBaselineMap[v6];
      switch(bswap32(*(unsigned __int16 *)(v1 + 4)) >> 16)
      {
        case 0u:
        case 2u:
          v5 = v7;
          goto LABEL_15;
        case 1u:
          v9 = (const SFNTLookupTable *)(v1 + 72);
          goto LABEL_19;
        case 3u:
          v9 = (const SFNTLookupTable *)(v1 + 74);
LABEL_19:
          TAATBslnEngine::ProcessBSLNFormatsWithMap((uint64_t)this, v9, v7);
          break;
        default:
          return v1 != 0;
      }
    }
  }
  return v1 != 0;
}

uint64_t TAATBslnEngine::ProcessBSLNFormatsWithMap(uint64_t a1, const SFNTLookupTable *a2, char a3)
{
  __int128 v4;
  SFNTLookupTable *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[2];
  __int128 v11;
  __int128 v12;
  unint64_t v13;
  char v14;
  _BYTE v15[24];
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v14 = a3;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12 = v4;
  v11 = v4;
  v5 = *(SFNTLookupTable **)(a1 + 32);
  v10[0] = TAATLookupTable::BadTable;
  v10[1] = 0;
  *((_QWORD *)&v12 + 1) = 0;
  v13 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)v10, a2, v5);
  v6 = operator new(0x20uLL);
  *v6 = &off_1E15E00A0;
  v6[1] = &v14;
  v6[2] = v10;
  v6[3] = a1;
  v16 = v6;
  TBaselineEngineImplementation::ApplyToRuns(a1, (uint64_t)v15);
  v7 = v16;
  if (v16 == v15)
  {
    v8 = 4;
    v7 = v15;
    goto LABEL_5;
  }
  if (v16)
  {
    v8 = 5;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return 1;
}

void std::__function::__func<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1,std::allocator<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1>,BOOL ()(TRun &)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

__n128 std::__function::__func<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1,std::allocator<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1>,BOOL ()(TRun &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E15E00A0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1,std::allocator<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1>,BOOL ()(TRun &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E15E00A0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1,std::allocator<TAATBslnEngine::ProcessBSLNFormatsWithMap(SFNTLookupTable const*,BaselineClass)::$_1>,BOOL ()(TRun &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  double v6;
  double v7;
  unsigned __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(_QWORD *, uint64_t, unint64_t *);
  uint64_t v16;
  _QWORD *v17;
  unsigned __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t (*v28)(_QWORD *, uint64_t, unint64_t *);
  uint64_t v29;
  _QWORD *v30;
  unsigned __int16 *v31;
  unsigned int v32;
  uint64_t v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;

  v4 = *(_QWORD *)(a2 + 208);
  v5 = *(_QWORD *)(*(_QWORD *)(a2 + 216) + 16) + 2 * *(_QWORD *)(a2 + 200);
  v6 = 0.0;
  v7 = 0.0;
  if (v4 < 1)
  {
LABEL_13:
    v21 = *(_QWORD *)(a2 + 160);
    if (v21)
      v6 = *(double *)(v21 + 48);
    if (v6 != v7 + v6)
    {
      *(double *)(TAttributes::EnsureRareData((TAttributes *)(a2 + 40)) + 48) = v7 + v6;
      *(_BYTE *)(a2 + 89) = 1;
    }
    if (v4 < 1)
      return 1;
    v22 = 0;
    v23 = (double *)MEMORY[0x1E0C9D538];
    while (1)
    {
      v24 = *(unsigned __int16 *)(v5 + 2 * v22);
      v25 = *(_QWORD *)(a1 + 16);
      v26 = *(_QWORD *)(a1 + 24);
      v27 = **(unsigned __int8 **)(a1 + 8);
      v42 = 0xAAAAAAAAAAAAAAAALL;
      v28 = *(uint64_t (**)(_QWORD *, uint64_t, unint64_t *))v25;
      v29 = *(_QWORD *)(v25 + 8);
      v30 = (_QWORD *)(v25 + (v29 >> 1));
      if ((v29 & 1) != 0)
        v28 = *(uint64_t (**)(_QWORD *, uint64_t, unint64_t *))(*v30 + v28);
      v31 = (unsigned __int16 *)v28(v30, v24, &v42);
      if (v31)
      {
        v32 = bswap32(*v31) >> 16;
        if (v32 <= 0x1F)
          v27 = bslnToBaselineMap[v32];
      }
      v33 = *(_QWORD *)(v26 + 8) + 16 * v27;
      if (!*(_BYTE *)(v33 + 216) || !*(_BYTE *)(v33 + 88))
        break;
      v34 = *(double *)(v33 + 208) - *(double *)(v33 + 80);
      if (v34 != v7)
      {
        if ((*(_BYTE *)(a2 + 225) & 0x10) != 0)
        {
          objc_msgSend(*(id *)(a2 + 216), "originAtIndex:", v22 + *(_QWORD *)(a2 + 200));
          v36 = v37;
        }
        else
        {
          v36 = *v23;
          v35 = v23[1];
        }
        v38 = v34 - v7 + v35;
        objc_msgSend(*(id *)(a2 + 216), "setOrigin:atIndex:", v22 + *(_QWORD *)(a2 + 200), v36, v38);
        if (v36 != *v23 || v38 != v23[1])
          *(_BYTE *)(a2 + 225) |= 0x10u;
      }
      if (v4 == ++v22)
        return 1;
    }
  }
  else
  {
    v8 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a2 + 216) + 16) + 2 * *(_QWORD *)(a2 + 200));
    v9 = *(_QWORD *)(a2 + 208);
    while (1)
    {
      v11 = *v8++;
      v10 = v11;
      v12 = *(_QWORD *)(a1 + 16);
      v13 = *(_QWORD *)(a1 + 24);
      v14 = **(unsigned __int8 **)(a1 + 8);
      v42 = 0xAAAAAAAAAAAAAAAALL;
      v15 = *(uint64_t (**)(_QWORD *, uint64_t, unint64_t *))v12;
      v16 = *(_QWORD *)(v12 + 8);
      v17 = (_QWORD *)(v12 + (v16 >> 1));
      if ((v16 & 1) != 0)
        v15 = *(uint64_t (**)(_QWORD *, uint64_t, unint64_t *))(*v17 + v15);
      v18 = (unsigned __int16 *)v15(v17, v10, &v42);
      if (v18)
      {
        v19 = bswap32(*v18) >> 16;
        if (v19 <= 0x1F)
          v14 = bslnToBaselineMap[v19];
      }
      v20 = *(_QWORD *)(v13 + 8) + 16 * v14;
      if (!*(_BYTE *)(v20 + 216) || !*(_BYTE *)(v20 + 88))
        break;
      if (*(double *)(v20 + 208) - *(double *)(v20 + 80) < v7)
        v7 = *(double *)(v20 + 208) - *(double *)(v20 + 80);
      if (!--v9)
        goto LABEL_13;
    }
  }
  std::__throw_bad_optional_access[abi:nn180100]();
  return (uint64_t)TOpenTypeBaselineEngine::TOpenTypeBaselineEngine(v40, v41);
}

_QWORD *TOpenTypeBaselineEngine::TOpenTypeBaselineEngine(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  unint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  char v22;

  v3 = TBaselineEngineImplementation::TBaselineEngineImplementation(a1, a2, 1111577413);
  *v3 = &off_1E15DE588;
  v4 = (unint64_t *)OTL::BASE::BASE((uint64_t)(v3 + 5), a1[3], a1[4]);
  if (!a1[5])
    goto LABEL_12;
  v5 = a1[1];
  v6 = *(_QWORD *)(v5 + 40);
  v7 = *(__int128 **)(v6 + 184);
  if (v7 && *((_BYTE *)v7 + 128))
  {
    v8 = v5 + 80;
    v9 = *v7;
    v10 = v7[1];
    v11 = v7[3];
    *(_OWORD *)(v5 + 112) = v7[2];
    *(_OWORD *)(v5 + 128) = v11;
    *(_OWORD *)(v5 + 80) = v9;
    *(_OWORD *)(v5 + 96) = v10;
    v12 = v7[4];
    v13 = v7[5];
    v14 = v7[7];
    *(_OWORD *)(v5 + 176) = v7[6];
    *(_OWORD *)(v5 + 192) = v14;
    *(_OWORD *)(v5 + 144) = v12;
    *(_OWORD *)(v5 + 160) = v13;
    v6 = *(_QWORD *)(a1[1] + 40);
  }
  else
  {
    v15 = 0;
    v8 = v5 + 80;
    v16 = v5 + 88;
    do
    {
      if (*(_BYTE *)(v16 + v15))
        *(_BYTE *)(v16 + v15) = 0;
      v15 += 16;
    }
    while (v15 != 128);
  }
  v22 = -1;
  v17 = (unint64_t *)(v6 + 56);
  v18 = atomic_load((unint64_t *)(v6 + 56));
  TOpenTypeBaselineEngine::GetBaselineInfo(v4, *(TFont **)(v18 + 40), *(_DWORD *)(a1[1] + 32), v8, &v22);
  if (!v19)
  {
    atomic_load(v17);
    CFLog();
    v20 = atomic_load(v17);
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(v20 + 40) + 400) + 488))(*(_QWORD *)(*(_QWORD *)(v20 + 40) + 400), 1111577413);
LABEL_12:
    a1[3] = 0;
    return a1;
  }
  *(_BYTE *)(a1[1] + 36) = v22;
  return a1;
}

void TOpenTypeBaselineEngine::GetBaselineInfo(unint64_t *a1, TFont *this, int a3, uint64_t a4, char *a5)
{
  TFont *v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  unsigned __int16 *v11;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  uint64_t v25;
  unint64_t v26;
  unint64_t v28;
  unsigned int v29;
  unint64_t v30;
  BOOL v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  uint64_t v44;
  unint64_t v45;
  unint64_t v47;
  unsigned __int16 *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  __int128 v53;
  uint64_t v54;
  void *v55;
  void *v56;
  uint64_t *Script;
  unsigned int v58;
  char *v59;
  unsigned __int16 *v60;
  uint64_t v62;
  unint64_t v63;
  unint64_t v65;
  unsigned int v66;
  char *v67;
  unsigned __int16 *v68;
  _WORD *v69;
  unsigned __int16 *v70;
  unsigned int v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  BOOL v77;
  unsigned int v78;
  TOpenTypeBaselineEngine *v79;
  __int16 v80;
  char v81;
  int *v82;
  int *inited;
  double v84;
  const TFont *v85;
  void *v86;
  unint64_t v87;
  uint64_t v88;
  unsigned int v89;
  uint64_t v90;
  unint64_t v91;
  BOOL v92;
  unint64_t v94;
  uint8x8_t v95;
  unint64_t v96;
  uint64_t **v97;
  uint64_t *i;
  unint64_t v99;
  _QWORD *v100;
  float v101;
  _BOOL8 v102;
  unint64_t v103;
  unint64_t v104;
  int8x8_t prime;
  void *v106;
  void *v107;
  uint64_t v108;
  _QWORD **v109;
  unint64_t v110;
  uint8x8_t v111;
  unint64_t v112;
  uint8x8_t v113;
  uint64_t v114;
  _QWORD *j;
  unint64_t v116;
  _QWORD *v117;
  _QWORD *v118;
  unint64_t v119;
  void *v120;
  double v121;
  uint64_t v122;
  const OTL::BASE *v123;
  int v124;
  const __int16 *v125;
  double v126;
  unsigned __int16 *v127;
  unsigned __int16 *v128;
  unsigned __int16 *v129;
  unsigned int v130;
  uint64_t v131;
  uint64_t v132;
  unsigned __int16 *v133;
  uint64_t v134;
  unsigned int *v135;
  unint64_t v136;
  OTL::BaseCoordTable *v137;
  unsigned __int16 v138;
  uint64_t v139;
  double v140;
  uint64_t v141;
  unsigned __int16 *v142;
  unsigned __int16 *v143;
  unsigned __int16 *v144;
  unsigned int v145;
  uint64_t v146;
  uint64_t v147;
  unsigned __int16 *v148;
  uint64_t v149;
  _BYTE *v150;
  double v151;
  double v152;
  double v153;
  BOOL v154;
  double v155;
  double v156;
  double TypoAscentDescent;
  double v158;
  _QWORD *v159;
  _QWORD *v160;
  void *v161;
  TOpenTypeBaselineEngine *v162;
  unsigned int v163;
  unint64_t VariationValues;
  unsigned __int16 *v165;
  _WORD *v166;
  _WORD *v169;
  TFont *v170;
  char *v171;
  unsigned __int16 *v172;
  void *__p[2];
  void *v174[2];
  unint64_t v175;
  _BYTE v176[12];
  uint64_t v177;

  v7 = this;
  v177 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v9 = a1[1];
  v10 = *(unsigned __int16 *)(*a1 + 4);
  v11 = (unsigned __int16 *)(*a1 + __rev16(v10));
  if ((unint64_t)(v11 + 2) > v9 || v10 == 0)
    v13 = 0;
  else
    v13 = v11;
  if (!v13)
    goto LABEL_80;
  v14 = (unsigned __int16 *)((char *)v13 + __rev16(*v13));
  if (!*v13)
    v14 = 0;
  v15 = v14 + 1;
  if (v8 <= (unint64_t)v14 && (unint64_t)v15 <= v9)
  {
    v17 = bswap32(*v14) >> 16;
    v18 = (unint64_t)&v15[2 * v17];
    v19 = (unint64_t)(v14 + 3) <= v9 ? (v9 - (unint64_t)v15) >> 2 : 0;
    v20 = v18 <= v9 && v18 >= (unint64_t)v15;
    if (v20 || v19 == v17)
    {
      v22 = (unsigned __int16 *)((char *)v13 + __rev16(v13[1]));
      if (!v13[1])
        v22 = 0;
      v23 = v22 + 1;
      if (v8 <= (unint64_t)v22 && (unint64_t)v23 <= v9)
      {
        v25 = bswap32(*v22) >> 16;
        v26 = (unint64_t)&v23[3 * v25];
        if (v26 >= (unint64_t)v23 && v26 <= v9)
          goto LABEL_80;
        v28 = (v9 - (unint64_t)v23) / 6;
        if ((unint64_t)(v22 + 4) > v9)
          v28 = 0;
        if (v28 == v25)
        {
LABEL_80:
          v29 = *(unsigned __int16 *)(v8 + 6);
          v30 = v8 + __rev16(v29);
          v31 = v30 + 4 > v9 || v29 == 0;
          v32 = v31 ? 0 : (unsigned __int16 *)v30;
          if (!v32)
            goto LABEL_322;
          v33 = (unsigned __int16 *)((char *)v32 + __rev16(*v32));
          if (!*v32)
            v33 = 0;
          v34 = v33 + 1;
          if (v8 <= (unint64_t)v33 && (unint64_t)v34 <= v9)
          {
            v36 = bswap32(*v33) >> 16;
            v37 = (unint64_t)&v34[2 * v36];
            v38 = (unint64_t)(v33 + 3) <= v9 ? (v9 - (unint64_t)v34) >> 2 : 0;
            v39 = v37 <= v9 && v37 >= (unint64_t)v34;
            if (v39 || v38 == v36)
            {
              v41 = (unsigned __int16 *)((char *)v32 + __rev16(v32[1]));
              if (!v32[1])
                v41 = 0;
              v42 = v41 + 1;
              if (v8 <= (unint64_t)v41 && (unint64_t)v42 <= v9)
              {
                v44 = bswap32(*v41) >> 16;
                v45 = (unint64_t)&v42[3 * v44];
                if (v45 >= (unint64_t)v42 && v45 <= v9)
                  goto LABEL_322;
                v47 = (v9 - (unint64_t)v42) / 6;
                if ((unint64_t)(v41 + 4) > v9)
                  v47 = 0;
                if (v47 == v44)
                {
LABEL_322:
                  v48 = (*(_BYTE *)this & 1) != 0 ? v32 : v13;
                  if (v48)
                  {
                    v166 = v13;
                    v49 = (char *)v48 + __rev16(*v48);
                    v50 = *v48 ? v49 : 0;
                    v171 = v50;
                    v165 = v48;
                    v51 = (char *)v48 + __rev16(v48[1]);
                    v52 = v48[1] ? v51 : 0;
                    if (a3)
                    {
                      *(_QWORD *)&v53 = 0xAAAAAAAAAAAAAAAALL;
                      *((_QWORD *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
                      *(_OWORD *)__p = v53;
                      *(_OWORD *)v174 = v53;
                      v175 = 0xAAAAAAAAFFFFFFFFLL;
                      OTL::BASE::MapOfBaseScriptTableOffsets((uint64_t *)__p, v52);
                      v54 = 0;
                      *(_DWORD *)v176 = a3;
                      *(_QWORD *)&v176[4] = 0x6C61746E44464C54;
                      v55 = __p[0];
                      v56 = __p[1];
                      while (1)
                      {
                        Script = OTL::BASE::FindScript((uint64_t)v55, (unint64_t)v56, *(_DWORD *)&v176[v54]);
                        if (Script)
                        {
                          if (*((_WORD *)Script + 10))
                            break;
                        }
                        v54 += 4;
                        if (v54 == 12)
                        {
                          std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)__p);
                          goto LABEL_93;
                        }
                      }
                      v58 = __rev16(*((unsigned __int16 *)Script + 10));
                      std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)__p);
                    }
                    else
                    {
LABEL_93:
                      if (!*(_WORD *)v52 || !*((_WORD *)v52 + 3))
                        return;
                      v58 = __rev16(*((unsigned __int16 *)v52 + 3));
                    }
                    v59 = &v52[v58];
                    v60 = (unsigned __int16 *)(v59 + 6);
                    if ((unint64_t)(v59 + 4) >= v8 && (unint64_t)v60 <= v9)
                    {
                      v62 = bswap32(*((unsigned __int16 *)v59 + 2)) >> 16;
                      v63 = (unint64_t)&v60[3 * v62];
                      if (v63 >= (unint64_t)v60 && v63 <= v9)
                        goto LABEL_128;
                      v65 = (v9 - (unint64_t)v60) / 6;
                      if ((unint64_t)(v59 + 12) > v9)
                        v65 = 0;
                      if (v65 == v62)
                      {
LABEL_128:
                        v66 = *(unsigned __int16 *)v59;
                        v67 = &v59[__rev16(v66)];
                        v68 = v66 ? (unsigned __int16 *)v67 : 0;
                        v172 = v68;
                        if (v66)
                        {
                          v69 = v67 + 2;
                          v70 = (unsigned __int16 *)(v67 + 4);
                          if ((unint64_t)(v67 + 2) >= v8 && (unint64_t)v70 <= v9)
                          {
                            v72 = *((unsigned __int16 *)v67 + 1);
                            v73 = __rev16(v72);
                            v74 = (unint64_t)&v70[v73];
                            v75 = (unint64_t)(v67 + 6) <= v9 ? (v9 - (unint64_t)v70) >> 1 : 0;
                            v76 = v74 <= v9 && v74 >= (unint64_t)v70;
                            v77 = v76 || v75 == v73;
                            if (v77 && v72 == *(unsigned __int16 *)v171)
                            {
                              if (a5)
                              {
                                v78 = bswap32(*(unsigned __int16 *)v67);
                                if (v73 <= HIWORD(v78))
                                  v79 = 0;
                                else
                                  v79 = (TOpenTypeBaselineEngine *)bswap32(*(_DWORD *)&v171[4 * HIWORD(v78) + 2]);
                                v80 = TOpenTypeBaselineEngine::BaselineClassForTag(v79);
                                if ((v80 & 0xFF00) != 0)
                                  v81 = v80;
                                else
                                  v81 = -1;
                                *a5 = v81;
                              }
                              v82 = (int *)((char *)v7 + 48);
                              inited = (int *)((char *)v7 + 48);
                              if (!*((_DWORD *)v7 + 12))
                                inited = TFont::InitStrikeMetrics(v7);
                              v84 = *((double *)inited + 6);
                              if (!*v82)
                                v82 = TFont::InitStrikeMetrics(v7);
                              v163 = *v82;
                              *(_QWORD *)v176 = 0xAAAAAAAAAAAAAAAALL;
                              VariationValues = TFont::GetVariationValues(v7, (id *)v176);
                              *(_OWORD *)__p = 0u;
                              *(_OWORD *)v174 = 0u;
                              v175 = 0xAAAAAAAA3F800000;
                              if (*v69)
                              {
                                v86 = 0;
                                v87 = 0;
                                v88 = 0;
                                v89 = __rev16((unsigned __int16)*v69);
                                if (v89 <= 1)
                                  v90 = 1;
                                else
                                  v90 = v89;
                                v169 = v69;
                                v170 = v7;
                                while (1)
                                {
                                  if (bswap32((unsigned __int16)*v69) >> 16 <= (unsigned __int16)v88)
                                    goto LABEL_228;
                                  v91 = (unint64_t)v172 + __rev16(v172[v88 + 2]);
                                  v92 = !v172[v88 + 2] || v8 > v91;
                                  if (v92 || v91 + 4 > v9)
                                    goto LABEL_228;
                                  v94 = bswap32(*(_DWORD *)&v171[4 * v88 + 2]);
                                  if (v87)
                                  {
                                    v95 = (uint8x8_t)vcnt_s8((int8x8_t)v87);
                                    v95.i16[0] = vaddlv_u8(v95);
                                    if (v95.u32[0] > 1uLL)
                                    {
                                      v96 = v94;
                                      if (v87 <= v94)
                                        v96 = v94 % v87;
                                    }
                                    else
                                    {
                                      v96 = ((_DWORD)v87 - 1) & v94;
                                    }
                                    v97 = (uint64_t **)*((_QWORD *)__p[0] + v96);
                                    if (v97)
                                    {
                                      for (i = *v97; i; i = (uint64_t *)*i)
                                      {
                                        v99 = i[1];
                                        if (v99 == v94)
                                        {
                                          if (*((_DWORD *)i + 4) == (_DWORD)v94)
                                          {
                                            i[3] = v91;
                                            v69 = v169;
                                            v7 = v170;
                                            goto LABEL_228;
                                          }
                                        }
                                        else
                                        {
                                          if (v95.u32[0] > 1uLL)
                                          {
                                            if (v99 >= v87)
                                              v99 %= v87;
                                          }
                                          else
                                          {
                                            v99 &= v87 - 1;
                                          }
                                          if (v99 != v96)
                                            break;
                                        }
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v96 = 0xAAAAAAAAAAAAAAAALL;
                                  }
                                  v100 = operator new(0x20uLL);
                                  *v100 = 0;
                                  v100[1] = v94;
                                  *((_DWORD *)v100 + 4) = v94;
                                  v100[3] = v91;
                                  v101 = (float)((unint64_t)v86 + 1);
                                  if (!v87 || (float)(*(float *)&v175 * (float)v87) < v101)
                                    break;
LABEL_218:
                                  v117 = __p[0];
                                  v118 = (_QWORD *)*((_QWORD *)__p[0] + v96);
                                  v69 = v169;
                                  if (v118)
                                  {
                                    *v100 = *v118;
                                    v7 = v170;
LABEL_226:
                                    *v118 = v100;
                                    goto LABEL_227;
                                  }
                                  *v100 = v174[0];
                                  v174[0] = v100;
                                  v117[v96] = v174;
                                  v7 = v170;
                                  if (*v100)
                                  {
                                    v119 = *(_QWORD *)(*v100 + 8);
                                    if ((v87 & (v87 - 1)) != 0)
                                    {
                                      if (v119 >= v87)
                                        v119 %= v87;
                                    }
                                    else
                                    {
                                      v119 &= v87 - 1;
                                    }
                                    v118 = (char *)__p[0] + 8 * v119;
                                    goto LABEL_226;
                                  }
LABEL_227:
                                  v86 = ++v174[1];
LABEL_228:
                                  if (++v88 == v90)
                                    goto LABEL_239;
                                }
                                v102 = (v87 & (v87 - 1)) != 0;
                                if (v87 < 3)
                                  v102 = 1;
                                v103 = v102 | (2 * v87);
                                v104 = vcvtps_u32_f32(v101 / *(float *)&v175);
                                if (v103 <= v104)
                                  prime = (int8x8_t)v104;
                                else
                                  prime = (int8x8_t)v103;
                                if (*(_QWORD *)&prime == 1)
                                {
                                  prime = (int8x8_t)2;
                                }
                                else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
                                {
                                  prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
                                  v87 = (unint64_t)__p[1];
                                }
                                if (*(_QWORD *)&prime > v87)
                                  goto LABEL_184;
                                if (*(_QWORD *)&prime < v87)
                                {
                                  v112 = vcvtps_u32_f32((float)(unint64_t)v174[1] / *(float *)&v175);
                                  if (v87 < 3
                                    || (v113 = (uint8x8_t)vcnt_s8((int8x8_t)v87),
                                        v113.i16[0] = vaddlv_u8(v113),
                                        v113.u32[0] > 1uLL))
                                  {
                                    v112 = std::__next_prime(v112);
                                  }
                                  else
                                  {
                                    v114 = 1 << -(char)__clz(v112 - 1);
                                    if (v112 >= 2)
                                      v112 = v114;
                                  }
                                  if (*(_QWORD *)&prime <= v112)
                                    prime = (int8x8_t)v112;
                                  if (*(_QWORD *)&prime >= v87)
                                  {
                                    v87 = (unint64_t)__p[1];
                                  }
                                  else
                                  {
                                    if (prime)
                                    {
LABEL_184:
                                      if (*(_QWORD *)&prime >> 61)
                                        std::__throw_bad_array_new_length[abi:nn180100]();
                                      v106 = operator new(8 * *(_QWORD *)&prime);
                                      v107 = __p[0];
                                      __p[0] = v106;
                                      if (v107)
                                        operator delete(v107);
                                      v108 = 0;
                                      __p[1] = (void *)prime;
                                      do
                                        *((_QWORD *)__p[0] + v108++) = 0;
                                      while (*(_QWORD *)&prime != v108);
                                      v109 = (_QWORD **)v174[0];
                                      if (v174[0])
                                      {
                                        v110 = *((_QWORD *)v174[0] + 1);
                                        v111 = (uint8x8_t)vcnt_s8(prime);
                                        v111.i16[0] = vaddlv_u8(v111);
                                        if (v111.u32[0] > 1uLL)
                                        {
                                          if (v110 >= *(_QWORD *)&prime)
                                            v110 %= *(_QWORD *)&prime;
                                        }
                                        else
                                        {
                                          v110 &= *(_QWORD *)&prime - 1;
                                        }
                                        *((_QWORD *)__p[0] + v110) = v174;
                                        for (j = *v109; j; v110 = v116)
                                        {
                                          v116 = j[1];
                                          if (v111.u32[0] > 1uLL)
                                          {
                                            if (v116 >= *(_QWORD *)&prime)
                                              v116 %= *(_QWORD *)&prime;
                                          }
                                          else
                                          {
                                            v116 &= *(_QWORD *)&prime - 1;
                                          }
                                          if (v116 != v110)
                                          {
                                            if (!*((_QWORD *)__p[0] + v116))
                                            {
                                              *((_QWORD *)__p[0] + v116) = v109;
                                              goto LABEL_209;
                                            }
                                            *v109 = (_QWORD *)*j;
                                            *j = **((_QWORD **)__p[0] + v116);
                                            **((_QWORD **)__p[0] + v116) = j;
                                            j = v109;
                                          }
                                          v116 = v110;
LABEL_209:
                                          v109 = (_QWORD **)j;
                                          j = (_QWORD *)*j;
                                        }
                                      }
                                      v87 = (unint64_t)prime;
                                      goto LABEL_213;
                                    }
                                    v120 = __p[0];
                                    __p[0] = 0;
                                    if (v120)
                                      operator delete(v120);
                                    v87 = 0;
                                    __p[1] = 0;
                                  }
                                }
LABEL_213:
                                if ((v87 & (v87 - 1)) != 0)
                                {
                                  if (v87 <= v94)
                                    v96 = v94 % v87;
                                  else
                                    v96 = v94;
                                }
                                else
                                {
                                  v96 = ((_DWORD)v87 - 1) & v94;
                                }
                                goto LABEL_218;
                              }
LABEL_239:
                              v121 = v84 * (double)v163;
                              if ((*(_BYTE *)v7 & 1) != 0)
                              {
                                v125 = (const __int16 *)VariationValues;
                                v127 = (unsigned __int16 *)((char *)v165 + __rev16(*v165));
                                if (*v165)
                                  v128 = v127;
                                else
                                  v128 = 0;
                                v130 = *v128;
                                v129 = v128 + 1;
                                v131 = __rev16(v130);
                                v123 = (const OTL::BASE *)a1;
                                v122 = a4;
                                if (v130)
                                {
                                  v132 = 4 * v131;
                                  v133 = v129;
                                  while (*(_DWORD *)v133 != 1868915817)
                                  {
                                    v133 += 2;
                                    v132 -= 4;
                                    if (!v132)
                                    {
                                      v133 = &v129[2 * v131];
                                      break;
                                    }
                                  }
                                }
                                else
                                {
                                  v133 = v129;
                                }
                                if (v131 == ((char *)v133 - (char *)v129) >> 2)
                                  v126 = 0.0;
                                else
                                  v126 = v121 * -0.5;
                                *(double *)(a4 + 32) = v126;
                                LOBYTE(v124) = 1;
                                v134 = 2;
                              }
                              else
                              {
                                v123 = (const OTL::BASE *)a1;
                                v122 = a4;
                                v124 = *(unsigned __int8 *)(a4 + 40);
                                v125 = (const __int16 *)VariationValues;
                                if (*(_BYTE *)(a4 + 40))
                                {
                                  v126 = 0.0;
                                  if (*(_BYTE *)(a4 + 88))
                                    goto LABEL_263;
                                }
                                else if (!*(_BYTE *)(a4 + 88))
                                {
LABEL_256:
                                  v126 = 0.0;
                                  goto LABEL_263;
                                }
                                if (*(_BYTE *)(a4 + 24))
                                  *(_BYTE *)(a4 + 24) = 0;
                                if (v124)
                                {
                                  *(_BYTE *)(a4 + 40) = 0;
                                  goto LABEL_256;
                                }
                                v126 = 0.0;
                                v134 = 5;
                              }
                              *(_BYTE *)(v122 + 16 * v134 + 8) = v124;
LABEL_263:
                              v135 = (unsigned int *)v174[0];
                              if (v174[0])
                              {
                                v136 = *(_QWORD *)v176;
                                do
                                {
                                  v137 = (OTL::BaseCoordTable *)*((_QWORD *)v135 + 3);
                                  v138 = TOpenTypeBaselineEngine::BaselineClassForTag((TOpenTypeBaselineEngine *)v135[4]);
                                  if (v138 >= 0x100u && !*(_BYTE *)(v122 + 16 * v138 + 8))
                                  {
                                    v139 = v138;
                                    OTL::BaseCoordTable::GetCoord(v137, v123, v7, v136, v125);
                                    v141 = v122 + 16 * v139;
                                    *(double *)v141 = v126 + v140;
                                    *(_BYTE *)(v141 + 8) = 1;
                                  }
                                  v135 = *(unsigned int **)v135;
                                }
                                while (v135);
                              }
                              v142 = (_WORD *)((char *)v166 + __rev16((unsigned __int16)*v166));
                              if (*v166)
                                v143 = v142;
                              else
                                v143 = 0;
                              v145 = *v143;
                              v144 = v143 + 1;
                              v146 = __rev16(v145);
                              if (v145)
                              {
                                v147 = 4 * v146;
                                v148 = v144;
                                while (*(_DWORD *)v148 != 1868915817)
                                {
                                  v148 += 2;
                                  v147 -= 4;
                                  if (!v147)
                                  {
                                    v148 = &v144[2 * v146];
                                    break;
                                  }
                                }
                              }
                              else
                              {
                                v148 = v144;
                              }
                              if (v146 == ((char *)v148 - (char *)v144) >> 2)
                              {
                                if (!(*(unsigned int (**)(_QWORD))(**((_QWORD **)v7 + 50) + 736))(*((_QWORD *)v7 + 50)))
                                  goto LABEL_290;
                                if ((*(_BYTE *)v7 & 1) != 0)
                                {
                                  *(double *)(v122 + 80) = v121 + v126;
                                  v150 = (_BYTE *)(v122 + 88);
                                }
                                else
                                {
                                  *(double *)(v122 + 80) = TBaselineEngineImplementation::GetTypoAscentDescent((TBaseFont **)v7, v85);
                                  *(_BYTE *)(v122 + 88) = 1;
                                  *(_QWORD *)(v122 + 32) = v149;
                                  v150 = (_BYTE *)(v122 + 40);
                                }
                              }
                              else
                              {
                                v150 = (_BYTE *)(v122 + 88);
                                if (*(_BYTE *)(v122 + 88))
                                  goto LABEL_290;
                                if ((*(_BYTE *)v7 & 1) != 0)
                                {
                                  v151 = v121 + v126;
                                }
                                else
                                {
                                  if (!*(_BYTE *)(v122 + 40))
                                    goto LABEL_319;
                                  v151 = v121 + *(double *)(v122 + 32);
                                }
                                *(double *)(v122 + 80) = v151;
                              }
                              *v150 = 1;
LABEL_290:
                              if (*(_BYTE *)(v122 + 120) || (*(_BYTE *)v7 & 1) != 0 || !*(_BYTE *)(v122 + 104))
                                goto LABEL_313;
                              if (*(_BYTE *)(v122 + 40))
                                v152 = *(double *)(v122 + 32);
                              else
                                v152 = 1.79769313e308;
                              if (*(_BYTE *)(v122 + 88))
                                v153 = *(double *)(v122 + 80);
                              else
                                v153 = 1.79769313e308;
                              v154 = v152 != 1.79769313e308 && v153 == 1.79769313e308;
                              v155 = -0.0;
                              if (v154)
                                v155 = v121;
                              v156 = v152 + v155;
                              if (v153 != 1.79769313e308 && v156 != 1.79769313e308)
                                goto LABEL_312;
                              TypoAscentDescent = TBaselineEngineImplementation::GetTypoAscentDescent((TBaseFont **)v7, v85);
                              if (v156 == 1.79769313e308)
                                v156 = v158;
                              if (v153 == 1.79769313e308)
                                v153 = TypoAscentDescent;
                              if (*(_BYTE *)(v122 + 104))
                              {
LABEL_312:
                                *(double *)(v122 + 112) = v153 - (*(double *)(v122 + 96) - v156);
                                *(_BYTE *)(v122 + 120) = 1;
LABEL_313:
                                TBaselineEngineImplementation::SynthesizeMissingBaselines((uint64_t)v7, v122, v126);
                                v159 = v174[0];
                                if (v174[0])
                                {
                                  do
                                  {
                                    v160 = (_QWORD *)*v159;
                                    operator delete(v159);
                                    v159 = v160;
                                  }
                                  while (v160);
                                }
                                v161 = __p[0];
                                __p[0] = 0;
                                if (v161)
                                  operator delete(v161);
                                return;
                              }
LABEL_319:
                              std::__throw_bad_optional_access[abi:nn180100]();
                              TOpenTypeBaselineEngine::~TOpenTypeBaselineEngine(v162);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void TOpenTypeBaselineEngine::~TOpenTypeBaselineEngine(id *this)
{
  *this = &off_1E15DE670;

}

{
  *this = &off_1E15DE670;

  JUMPOUT(0x186DC03ACLL);
}

BOOL TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(TOpenTypeBaselineEngine *this)
{
  _BOOL8 v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = &off_1E15E05F8;
  v5[1] = this;
  v6 = v5;
  v1 = TBaselineEngineImplementation::ApplyToRuns((uint64_t)this, (uint64_t)v5);
  v2 = v6;
  if (v6 == v5)
  {
    v3 = 4;
    v2 = v5;
    goto LABEL_5;
  }
  if (v6)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return v1;
}

uint64_t TOpenTypeBaselineEngine::BaselineClassForTag(TOpenTypeBaselineEngine *this)
{
  int v1;
  int v2;

  if ((int)this <= 1768187246)
  {
    switch((_DWORD)this)
    {
      case 0x68616E67:
        v1 = 1;
        v2 = 3;
        return v2 | (v1 << 8);
      case 0x69636662:
        v1 = 1;
        v2 = 6;
        return v2 | (v1 << 8);
      case 0x69636674:
        v1 = 1;
        v2 = 7;
        return v2 | (v1 << 8);
    }
LABEL_16:
    v2 = 0;
    v1 = 0;
    return v2 | (v1 << 8);
  }
  if ((int)this > 1835103335)
  {
    if ((_DWORD)this == 1835103336)
    {
      v1 = 1;
      v2 = 4;
      return v2 | (v1 << 8);
    }
    if ((_DWORD)this == 1919905134)
    {
      v2 = 0;
      v1 = 1;
      return v2 | (v1 << 8);
    }
    goto LABEL_16;
  }
  if ((_DWORD)this == 1768187247)
  {
    v1 = 1;
    v2 = 2;
    return v2 | (v1 << 8);
  }
  if ((_DWORD)this != 1768191088)
    goto LABEL_16;
  v1 = 1;
  v2 = 5;
  return v2 | (v1 << 8);
}

void OTL::BASE::MapOfBaseScriptTableOffsets(uint64_t *a1, _WORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _WORD *v9;
  unint64_t v10;
  __int16 v11;
  uint8x8_t v12;
  unint64_t v13;
  uint64_t **v14;
  uint64_t *i;
  unint64_t v16;
  _QWORD *v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  int8x8_t prime;
  void *v24;
  void *v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  uint8x8_t v29;
  unint64_t v30;
  uint8x8_t v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  void *v38;
  uint64_t v39;

  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  a1[4] = 0xAAAAAAAA3F800000;
  if (*a2)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    LODWORD(v7) = __rev16((unsigned __int16)*a2);
    if (v7 <= 1)
      v7 = 1;
    else
      v7 = v7;
    v39 = v7;
    v8 = a1 + 2;
    while (1)
    {
      v9 = &a2[3 * v6];
      v10 = bswap32(*(_DWORD *)(v9 + 1));
      v11 = v9[3];
      if (v5)
      {
        v12 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
        v12.i16[0] = vaddlv_u8(v12);
        if (v12.u32[0] > 1uLL)
        {
          v13 = v10;
          if (v5 <= v10)
            v13 = v10 % v5;
        }
        else
        {
          v13 = ((_DWORD)v5 - 1) & v10;
        }
        v14 = *(uint64_t ***)(*a1 + 8 * v13);
        if (v14)
        {
          for (i = *v14; i; i = (uint64_t *)*i)
          {
            v16 = i[1];
            if (v16 == v10)
            {
              if (*((_DWORD *)i + 4) == (_DWORD)v10)
              {
                *((_WORD *)i + 10) = v11;
                goto LABEL_79;
              }
            }
            else
            {
              if (v12.u32[0] > 1uLL)
              {
                if (v16 >= v5)
                  v16 %= v5;
              }
              else
              {
                v16 &= v5 - 1;
              }
              if (v16 != v13)
                break;
            }
          }
        }
      }
      else
      {
        v13 = 0xAAAAAAAAAAAAAAAALL;
      }
      v17 = operator new(0x18uLL);
      *v17 = 0;
      v17[1] = v10;
      *((_DWORD *)v17 + 4) = v10;
      *((_WORD *)v17 + 10) = v11;
      v18 = (float)(unint64_t)(v4 + 1);
      v19 = *((float *)a1 + 8);
      if (!v5 || (float)(v19 * (float)v5) < v18)
        break;
LABEL_69:
      v35 = *a1;
      v36 = *(_QWORD **)(*a1 + 8 * v13);
      if (v36)
      {
        *v17 = *v36;
      }
      else
      {
        *v17 = *v8;
        *v8 = v17;
        *(_QWORD *)(v35 + 8 * v13) = v8;
        if (!*v17)
          goto LABEL_78;
        v37 = *(_QWORD *)(*v17 + 8);
        if ((v5 & (v5 - 1)) != 0)
        {
          if (v37 >= v5)
            v37 %= v5;
        }
        else
        {
          v37 &= v5 - 1;
        }
        v36 = (_QWORD *)(*a1 + 8 * v37);
      }
      *v36 = v17;
LABEL_78:
      v4 = a1[3] + 1;
      a1[3] = v4;
LABEL_79:
      if (++v6 == v39)
        return;
    }
    v20 = (v5 & (v5 - 1)) != 0;
    if (v5 < 3)
      v20 = 1;
    v21 = v20 | (2 * v5);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      prime = (int8x8_t)v22;
    else
      prime = (int8x8_t)v21;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v5 = a1[1];
    }
    if (*(_QWORD *)&prime > v5)
      goto LABEL_35;
    if (*(_QWORD *)&prime < v5)
    {
      v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v5 < 3 || (v31 = (uint8x8_t)vcnt_s8((int8x8_t)v5), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        v30 = std::__next_prime(v30);
      }
      else
      {
        v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2)
          v30 = v32;
      }
      if (*(_QWORD *)&prime <= v30)
        prime = (int8x8_t)v30;
      if (*(_QWORD *)&prime >= v5)
      {
        v5 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_35:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v24 = operator new(8 * *(_QWORD *)&prime);
          v25 = (void *)*a1;
          *a1 = (uint64_t)v24;
          if (v25)
            operator delete(v25);
          v26 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v26++) = 0;
          while (*(_QWORD *)&prime != v26);
          v27 = (_QWORD *)*v8;
          if (*v8)
          {
            v28 = v27[1];
            v29 = (uint8x8_t)vcnt_s8(prime);
            v29.i16[0] = vaddlv_u8(v29);
            if (v29.u32[0] > 1uLL)
            {
              if (v28 >= *(_QWORD *)&prime)
                v28 %= *(_QWORD *)&prime;
            }
            else
            {
              v28 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v28) = v8;
            v33 = (_QWORD *)*v27;
            if (*v27)
            {
              do
              {
                v34 = v33[1];
                if (v29.u32[0] > 1uLL)
                {
                  if (v34 >= *(_QWORD *)&prime)
                    v34 %= *(_QWORD *)&prime;
                }
                else
                {
                  v34 &= *(_QWORD *)&prime - 1;
                }
                if (v34 != v28)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v34))
                  {
                    *(_QWORD *)(*a1 + 8 * v34) = v27;
                    goto LABEL_60;
                  }
                  *v27 = *v33;
                  *v33 = **(_QWORD **)(*a1 + 8 * v34);
                  **(_QWORD **)(*a1 + 8 * v34) = v33;
                  v33 = v27;
                }
                v34 = v28;
LABEL_60:
                v27 = v33;
                v33 = (_QWORD *)*v33;
                v28 = v34;
              }
              while (v33);
            }
          }
          v5 = (unint64_t)prime;
          goto LABEL_64;
        }
        v38 = (void *)*a1;
        *a1 = 0;
        if (v38)
          operator delete(v38);
        v5 = 0;
        a1[1] = 0;
      }
    }
LABEL_64:
    if ((v5 & (v5 - 1)) != 0)
    {
      if (v5 <= v10)
        v13 = v10 % v5;
      else
        v13 = v10;
    }
    else
    {
      v13 = ((_DWORD)v5 - 1) & v10;
    }
    goto LABEL_69;
  }
}

uint64_t *OTL::BASE::FindScript(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t *result;
  signed int v7;

  v3 = a3;
  if (!result)
  {
    if ((v3 << 24) - 973078528 >= 0xF7000001)
    {
      v7 = v3 & 0xFFFFFF00 | 0x20;
      if (v7 > 1835822367)
      {
        if (v7 <= 1869773087)
        {
          if (v7 == 1835822368)
          {
            v3 = 1835825517;
          }
          else if (v7 == 1836674336)
          {
            v3 = 1836674418;
          }
        }
        else
        {
          switch(v7)
          {
            case 1869773088:
              v3 = 1869773153;
              break;
            case 1952803872:
              v3 = 1952803957;
              break;
            case 1953328160:
              v3 = 1952542060;
              break;
          }
        }
      }
      else if (v7 <= 1735029279)
      {
        if (v7 == 1651402528)
        {
          v3 = 1650814567;
        }
        else if (v7 == 1684370976)
        {
          v3 = 1684371041;
        }
      }
      else
      {
        switch(v7)
        {
          case 1735029280:
            v3 = 1735748210;
            break;
          case 1735750176:
            v3 = 1735750261;
            break;
          case 1802396704:
            v3 = 1802396769;
            break;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void OTL::BaseCoordTable::GetCoord(OTL::BaseCoordTable *this, const OTL::BASE *a2, const TFont *a3, unint64_t a4, const __int16 *a5)
{
  unsigned int v8;
  BOOL v9;
  _DWORD *v13;
  unsigned __int16 *v14;
  unint64_t v16;
  void *v17[3];

  v8 = bswap32(*(unsigned __int16 *)this) >> 16;
  switch(v8)
  {
    case 3u:
      if (*(_QWORD *)a2 <= (unint64_t)this && (unint64_t)this + 6 <= *((_QWORD *)a2 + 1))
      {
        v13 = (_DWORD *)((char *)a3 + 48);
        if (!*((_DWORD *)a3 + 12))
          TFont::InitStrikeMetrics(a3);
        if (a4)
        {
          if (!*v13)
            TFont::InitStrikeMetrics(a3);
          if (*((_WORD *)this + 2))
          {
            v14 = (unsigned __int16 *)((char *)this + __rev16(*((unsigned __int16 *)this + 2)));
            if ((unint64_t)(v14 + 3) <= *((_QWORD *)a2 + 1) && v14[2] == 128)
              ItemVariationStore::ValueForDeltaSet((const OTL::BASE *)((char *)a2 + 16), bswap32(*v14) >> 16, bswap32(v14[1]) >> 16, a4, a5, 0);
          }
        }
      }
      break;
    case 2u:
      if (*(_QWORD *)a2 <= (unint64_t)this && (unint64_t)this + 8 <= *((_QWORD *)a2 + 1))
      {
        if (!*((_DWORD *)a3 + 12))
          TFont::InitStrikeMetrics(a3);
        v16 = bswap32(*((unsigned __int16 *)this + 3)) >> 16;
        memset(v17, 170, sizeof(v17));
        TFont::GetControlPoints((TBaseFont **)a3, v16 + 1, v17);
        if (v16 < ((char *)v17[1] - (char *)v17[0]) >> 4 || v17[0])
          operator delete(v17[0]);
      }
      break;
    case 1u:
      v9 = *(_QWORD *)a2 > (unint64_t)this || (unint64_t)this + 4 > *((_QWORD *)a2 + 1);
      if (!v9 && !*((_DWORD *)a3 + 12))
        TFont::InitStrikeMetrics(a3);
      break;
  }
}

uint64_t OTL::BASE::ValueForTag(OTL::BASE *this, const TFont *a2, unsigned int a3, int a4)
{
  unint64_t v4;
  unint64_t v8;
  unsigned int v9;
  unsigned __int16 *v10;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  uint64_t v21;
  unsigned int *v22;
  unint64_t v23;
  unsigned int v24;
  char *v25;
  char *v26;
  _WORD *v27;
  uint64_t v29;
  unint64_t v30;
  unint64_t v32;
  unint64_t v33;
  __int128 v34;
  uint64_t *Script;
  char *v36;
  unint64_t v37;
  unint64_t v38;
  unsigned __int16 *v39;
  uint64_t v41;
  unint64_t v42;
  unint64_t v44;
  char *v45;
  unint64_t v46;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  BOOL v52;
  uint64_t result;
  unint64_t v55;
  OTL::BaseCoordTable *v56;
  const __int16 *VariationValues;
  uint64_t v59;
  unint64_t v60[2];
  __int128 v61;
  unint64_t v62;

  v4 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    return 0;
  v8 = *((_QWORD *)this + 1);
  v9 = (*(_BYTE *)a2 & 1) != 0 ? *(unsigned __int16 *)(v4 + 6) : *(unsigned __int16 *)(v4 + 4);
  v10 = (unsigned __int16 *)(v4 + __rev16(v9));
  if (!v9 || (unint64_t)(v10 + 2) > v8)
    return 0;
  v12 = (char *)v10 + __rev16(*v10);
  v13 = *v10 ? v12 : 0;
  v14 = v13 + 2;
  if (v4 > (unint64_t)v13 || (unint64_t)v14 > v8)
    return 0;
  v16 = __rev16(*(unsigned __int16 *)v13);
  v17 = (unint64_t)&v14[4 * v16];
  v18 = (unint64_t)(v13 + 6) <= v8 ? (v8 - (unint64_t)v14) >> 2 : 0;
  v19 = v17 <= v8 && v17 >= (unint64_t)v14;
  if (!v19 && v18 != v16)
    return 0;
  if (*(_WORD *)v13)
  {
    v21 = 4 * v16;
    v22 = (unsigned int *)(v13 + 2);
    while (bswap32(*v22) != a4)
    {
      ++v22;
      v21 -= 4;
      if (!v21)
      {
        v22 = (unsigned int *)&v14[4 * v16];
        break;
      }
    }
  }
  else
  {
    v22 = (unsigned int *)(v13 + 2);
  }
  v23 = (char *)v22 - v14;
  if (v16 == ((char *)v22 - v14) >> 2)
    return 0;
  v24 = v10[1];
  v25 = (char *)v10 + __rev16(v24);
  v26 = v24 ? v25 : 0;
  v27 = v26 + 2;
  if (v4 > (unint64_t)v26 || (unint64_t)v27 > v8)
    return 0;
  v29 = bswap32(*(unsigned __int16 *)v26) >> 16;
  v30 = (unint64_t)&v27[3 * v29];
  if (v30 < (unint64_t)v27 || v30 > v8)
  {
    v32 = (v8 - (unint64_t)v27) / 6;
    v33 = (unint64_t)(v26 + 8) <= v8 ? v32 : 0;
    if (v33 != v29)
      return 0;
  }
  *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v60 = v34;
  v61 = v34;
  v62 = 0xAAAAAAAAFFFFFFFFLL;
  OTL::BASE::MapOfBaseScriptTableOffsets((uint64_t *)v60, v26);
  Script = OTL::BASE::FindScript(v60[0], v60[1], a3);
  if (!Script || !*((_WORD *)Script + 10))
  {
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v60);
    return 0;
  }
  v36 = &v26[__rev16(*((unsigned __int16 *)Script + 10))];
  std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v60);
  v37 = *(_QWORD *)this;
  v38 = *((_QWORD *)this + 1);
  v39 = (unsigned __int16 *)(v36 + 6);
  if ((unint64_t)(v36 + 4) < *(_QWORD *)this || (unint64_t)v39 > v38)
    return 0;
  v41 = bswap32(*((unsigned __int16 *)v36 + 2)) >> 16;
  v42 = (unint64_t)&v39[3 * v41];
  if (v42 < (unint64_t)v39 || v42 > v38)
  {
    v44 = (v38 - (unint64_t)v39) / 6;
    if ((unint64_t)(v36 + 12) > v38)
      v44 = 0;
    if (v44 != v41)
      return 0;
  }
  if (!*(_WORD *)v36)
    return 0;
  v45 = &v36[__rev16(*(unsigned __int16 *)v36)];
  v46 = (unint64_t)(v45 + 4);
  if ((unint64_t)(v45 + 2) < v37 || v46 > v38)
    return 0;
  v48 = *((unsigned __int16 *)v45 + 1);
  v49 = __rev16(v48);
  v50 = v46 + 2 * v49;
  v51 = (unint64_t)(v45 + 6) <= v38 ? (v38 - v46) >> 1 : 0;
  v52 = v50 <= v38 && v50 >= v46;
  if (!v52 && v51 != v49)
    return 0;
  result = 0;
  if (v48 == *(unsigned __int16 *)v13)
  {
    v55 = v23 >> 2;
    if (v49 > (unsigned __int16)(v23 >> 2))
    {
      if (*(_WORD *)&v45[2 * (unsigned __int16)v55 + 4])
      {
        v56 = (OTL::BaseCoordTable *)&v45[__rev16(*(unsigned __int16 *)&v45[2 * (unsigned __int16)v55 + 4])];
        if (v37 <= (unint64_t)v56 && (unint64_t)v56 + 4 <= v38)
        {
          v60[0] = 0xAAAAAAAAAAAAAAAALL;
          VariationValues = (const __int16 *)TFont::GetVariationValues(a2, (id *)v60);
          OTL::BaseCoordTable::GetCoord(v56, this, a2, v60[0], VariationValues);
          return v59;
        }
      }
      return 0;
    }
  }
  return result;
}

void std::__function::__func<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0,std::allocator<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0>,BOOL ()(TRun &)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0,std::allocator<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0>,BOOL ()(TRun &)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15E05F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0,std::allocator<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0>,BOOL ()(TRun &)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15E05F8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0,std::allocator<TOpenTypeBaselineEngine::ApplyScriptSpecificMetrics(void)::$_0>,BOOL ()(TRun &)>::operator()(uint64_t a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  const TFont *v4;
  uint64_t v5;
  unsigned int v7;
  OTL::BASE *v8;
  int v9;
  double v10;
  char v11;
  _BOOL8 v12;
  int v13;
  double v14;
  char v15;
  int v16;
  double v17;
  char v18;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = atomic_load(a2 + 7);
  v4 = *(const TFont **)(v3 + 40);
  v5 = *((_QWORD *)v4 + 50);
  if (!v5 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 384))(v5))
    return 0;
  v7 = *(_DWORD *)(*(_QWORD *)(v2 + 8) + 32);
  v8 = (OTL::BASE *)(v2 + 40);
  if ((*(_DWORD *)v4 & 1) != 0)
    v9 = 1986098019;
  else
    v9 = 1751216995;
  v10 = COERCE_DOUBLE(OTL::BASE::ValueForTag(v8, v4, v7, v9));
  v12 = v11 != 0;
  if (v11 && v10 > 0.0)
    *(double *)(TRun::EnsureRareData((TRun *)a2) + 32) = v10;
  if ((*(_DWORD *)v4 & 1) != 0)
    v13 = 1986294627;
  else
    v13 = 1751413603;
  v14 = COERCE_DOUBLE(OTL::BASE::ValueForTag(v8, v4, v7, v13));
  if (v15)
  {
    v12 = 1;
    if (v14 != 0.0)
      *(double *)(TRun::EnsureRareData((TRun *)a2) + 40) = fabs(v14);
  }
  if ((*(_DWORD *)v4 & 1) != 0)
    v16 = 1986815856;
  else
    v16 = 1751934832;
  v17 = COERCE_DOUBLE(OTL::BASE::ValueForTag(v8, v4, v7, v16));
  if (v18)
  {
    if (v17 > 0.0)
      *(double *)(TRun::EnsureRareData((TRun *)a2) + 48) = v17;
    return 1;
  }
  return v12;
}

_QWORD *TGenericBaselineEngine::TGenericBaselineEngine(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  __int128 *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _BYTE *v17;

  v3 = TBaselineEngineImplementation::TBaselineEngineImplementation(a1, a2, 0);
  *v3 = &off_1E15DE430;
  v4 = v3[1];
  v5 = *(_QWORD *)(v4 + 40);
  v6 = *(__int128 **)(v5 + 184);
  if (v6 && *((_BYTE *)v6 + 128))
  {
    v7 = v4 + 80;
    v8 = *v6;
    v9 = v6[1];
    v10 = v6[3];
    *(_OWORD *)(v4 + 112) = v6[2];
    *(_OWORD *)(v4 + 128) = v10;
    *(_OWORD *)(v4 + 80) = v8;
    *(_OWORD *)(v4 + 96) = v9;
    v11 = v6[4];
    v12 = v6[5];
    v13 = v6[7];
    *(_OWORD *)(v4 + 176) = v6[6];
    *(_OWORD *)(v4 + 192) = v13;
    *(_OWORD *)(v4 + 144) = v11;
    *(_OWORD *)(v4 + 160) = v12;
    v5 = *(_QWORD *)(a1[1] + 40);
  }
  else
  {
    v14 = 0;
    v7 = v4 + 80;
    v15 = v4 + 88;
    do
    {
      if (*(_BYTE *)(v15 + v14))
        *(_BYTE *)(v15 + v14) = 0;
      v14 += 16;
    }
    while (v14 != 128);
  }
  v16 = atomic_load((unint64_t *)(v5 + 56));
  v17 = *(_BYTE **)(v16 + 40);
  if ((*v17 & 1) == 0)
    TBaselineEngineImplementation::SynthesizeMissingBaselines((uint64_t)v17, v7, 0.0);
  return a1;
}

uint64_t TGenericBaselineEngine::CanProcess(TGenericBaselineEngine *this)
{
  return 1;
}

void TGenericBaselineEngine::~TGenericBaselineEngine(id *this)
{
  *this = &off_1E15DE670;

}

{
  *this = &off_1E15DE670;

  JUMPOUT(0x186DC03ACLL);
}

void TAATAnkrTable::TAATAnkrTable(TAATAnkrTable *this, const TFont *a2)
{
  void *v4;
  const __CFData *v5;
  const __CFData *v6;
  const UInt8 *BytePtr;
  void *v8;
  id v9;
  const __CFData *v10;
  const __CFData *v11;
  SFNTLookupTable *v12;
  uint64_t v13;
  __CFString *v14;

  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 50) + 480))(*((_QWORD *)a2 + 50), 1634626418);
  v4 = (void *)atomic_load((unint64_t *)this);
  v5 = v4;
  v6 = v5;
  if (v5)
    BytePtr = CFDataGetBytePtr(v5);
  else
    BytePtr = 0;

  *((_QWORD *)this + 1) = BytePtr;
  v8 = (void *)atomic_load((unint64_t *)this);
  v9 = v8;
  v10 = (const __CFData *)v9;
  if (v10)
  {
    v11 = v10;
    v12 = (SFNTLookupTable *)CFDataGetBytePtr(v10);

    if (v12)
      v12 = (SFNTLookupTable *)((char *)v12 + CFDataGetLength((CFDataRef)v9));
  }
  else
  {

    v12 = 0;
  }

  *((_QWORD *)this + 3) = TAATLookupTable::BadTable;
  *((_QWORD *)this + 2) = v12;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_WORD *)this + 36) = -1;
  v13 = *((_QWORD *)this + 1);
  if (v13)
  {
    if (v13 + 12 > (unint64_t)v12 || *(_WORD *)v13)
    {
      v14 = TFont::DebugDescription(a2);
      CFLog();

      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 50) + 488))(*((_QWORD *)a2 + 50), 1634626418);
      *((_QWORD *)this + 1) = 0;
    }
    else
    {
      TAATLookupTable::SetTable((uint64_t)this + 24, (const SFNTLookupTable *)(v13 + bswap32(*(_DWORD *)(v13 + 4))), v12);
      *((_QWORD *)this + 10) = *((_QWORD *)this + 1) + bswap32(*(_DWORD *)(*((_QWORD *)this + 1) + 8));
    }
  }
}

double TAATAnkrTable::GetControlPointCoordinates(TAATAnkrTable *this, uint64_t a2, unsigned int a3)
{
  double v5;
  uint64_t (*v6)(_QWORD *, uint64_t, unint64_t *);
  uint64_t v7;
  _QWORD *v8;
  unsigned __int16 *v9;
  unsigned int *v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int *v14;
  unint64_t v18;

  v5 = *MEMORY[0x1E0C9D538];
  v18 = 0xAAAAAAAAAAAAAAAALL;
  v6 = (uint64_t (*)(_QWORD *, uint64_t, unint64_t *))*((_QWORD *)this + 3);
  v7 = *((_QWORD *)this + 4);
  v8 = (_QWORD *)((char *)this + (v7 >> 1) + 24);
  if ((v7 & 1) != 0)
    v6 = *(uint64_t (**)(_QWORD *, uint64_t, unint64_t *))(*v8 + v6);
  v9 = (unsigned __int16 *)v6(v8, a2, &v18);
  if (v9)
  {
    v10 = (unsigned int *)(*((_QWORD *)this + 10) + (bswap32(*v9) >> 16));
    v11 = *((_QWORD *)this + 1);
    v12 = *((_QWORD *)this + 2);
    if (v11 <= (unint64_t)v10 && (unint64_t)(v10 + 2) <= v12)
    {
      v14 = &v10[a3 + 1];
      if (bswap32(*v10) > a3 && v11 <= (unint64_t)v14 && (unint64_t)(v14 + 1) <= v12)
        return (double)((int)bswap32(*(unsigned __int16 *)v14) >> 16);
    }
  }
  return v5;
}

uint64_t TBaselineAttributes::BaselineClassFromName(CFTypeRef cf1, const __CFString *a2)
{
  uint64_t v3;
  CFTypeRef v4;
  int v5;
  int v6;
  _QWORD v8[17];

  v3 = 0;
  v8[16] = *MEMORY[0x1E0C80C00];
  v8[1] = 0xAAAAAAAAAAAAAA00;
  v8[3] = 0xAAAAAAAAAAAAAA01;
  v8[5] = 0xAAAAAAAAAAAAAA02;
  v8[7] = 0xAAAAAAAAAAAAAA05;
  v8[9] = 0xAAAAAAAAAAAAAA03;
  v8[11] = 0xAAAAAAAAAAAAAA04;
  v8[13] = 0xAAAAAAAAAAAAAA06;
  v8[0] = CFSTR("CTBaselineClassRoman");
  v8[2] = CFSTR("CTBaselineClassIdeographicCentered");
  v8[4] = CFSTR("CTBaselineClassIdeographicLow");
  v8[6] = CFSTR("CTBaselineClassIdeographicHigh");
  v8[8] = CFSTR("CTBaselineClassHanging");
  v8[10] = CFSTR("CTBaselineClassMath");
  v8[12] = CFSTR("CTBaselineClassICFBottom");
  v8[14] = CFSTR("CTBaselineClassICFTop");
  v8[15] = 0xAAAAAAAAAAAAAA07;
  while (1)
  {
    v4 = (CFTypeRef)v8[v3];
    v5 = LOBYTE(v8[v3 + 1]);
    if (v4 == cf1 || cf1 && v4 && CFEqual(cf1, v4))
      break;
    v3 += 2;
    if (v3 == 16)
    {
      v5 = 0;
      v6 = 0;
      return v5 | (v6 << 8);
    }
  }
  v6 = 1;
  return v5 | (v6 << 8);
}

double TAATOpbdTable::LookupByDistance(TAATOpbdTable *this, uint64_t a2)
{
  double DefaultBounds;
  double v5;
  CGFloat v6;
  double v7;
  double v8;
  double v9;
  CGFloat v10;
  unsigned __int8 *SideValues;
  CGFloat v12;
  CGRect v14;

  DefaultBounds = TAATOpbdTable::GetDefaultBounds(this, a2);
  v6 = v5;
  v8 = v7;
  v10 = v9;
  SideValues = TAATOpbdTable::GetSideValues(this, a2);
  if (SideValues && (**(_BYTE **)this & 1) == 0)
  {
    v12 = -(*((double *)this + 1) * (double)((int)bswap32(*(unsigned __int16 *)SideValues) >> 16));
    v14.size.width = v8 - (v12 - DefaultBounds);
    v14.origin.x = v12;
    v14.origin.y = v6;
    v14.size.height = v10;
    CGRectGetMaxX(v14);
    return v12;
  }
  return DefaultBounds;
}

double TAATOpbdTable::LookupByControlPoint(TAATControlPointAccess **this, uint64_t a2)
{
  double DefaultBounds;
  unsigned __int8 *SideValues;
  unsigned __int16 *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  DefaultBounds = TAATOpbdTable::GetDefaultBounds((TAATOpbdTable *)this, a2);
  SideValues = TAATOpbdTable::GetSideValues((TAATOpbdTable *)this, a2);
  if (SideValues)
  {
    v6 = (unsigned __int16 *)SideValues;
    v7 = *(unsigned __int16 *)SideValues;
    if (v7 != 0xFFFF)
      DefaultBounds = *((double *)this + 1)
                    * TAATControlPointAccess::GetControlPointCoordinates(this[8], a2, __rev16(v7));
    v8 = v6[2];
    if (v8 != 0xFFFF)
      TAATControlPointAccess::GetControlPointCoordinates(this[8], a2, __rev16(v8));
    v9 = v6[3];
    if (v9 != 0xFFFF)
      TAATControlPointAccess::GetControlPointCoordinates(this[8], a2, __rev16(v9));
    v10 = v6[1];
    if (v10 != 0xFFFF)
      TAATControlPointAccess::GetControlPointCoordinates(this[8], a2, __rev16(v10));
  }
  return DefaultBounds;
}

double TAATOpbdTable::InvalidLookup(TAATOpbdTable *this)
{
  return *MEMORY[0x1E0C9D628];
}

unsigned __int8 *TAATOpbdTable::GetSideValues(TAATOpbdTable *this, uint64_t a2)
{
  __int128 v4;
  SFNTLookupTable *v5;
  const SFNTLookupTable *v6;
  uint64_t (*v7)(TAATLookupTable *, unsigned __int16, unint64_t *);
  TAATLookupTable *v8;
  unsigned __int8 *result;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t (*v19)(TAATLookupTable *, unsigned __int16, unint64_t *);
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  unint64_t v23;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v22 = v4;
  v21 = v4;
  v5 = (SFNTLookupTable *)*((_QWORD *)this + 5);
  v6 = (const SFNTLookupTable *)(*((_QWORD *)this + 4) + 6);
  v19 = TAATLookupTable::BadTable;
  v20 = 0;
  *((_QWORD *)&v22 + 1) = 0;
  v23 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)&v19, v6, v5);
  v18 = 0xAAAAAAAAAAAAAAAALL;
  v7 = v19;
  v8 = (TAATLookupTable *)((char *)&v19 + (v20 >> 1));
  if ((v20 & 1) != 0)
    v7 = *(uint64_t (**)(TAATLookupTable *, unsigned __int16, unint64_t *))(*(_QWORD *)v8
                                                                                           + v19);
  result = (unsigned __int8 *)v7(v8, a2, &v18);
  if (result)
  {
    v10 = v18;
    v12 = *((_QWORD *)this + 4);
    v11 = *((_QWORD *)this + 5);
    v13 = (unint64_t)&result[v18];
    v14 = v12 <= (unint64_t)result && v13 >= (unint64_t)result;
    if (!v14 || v13 > v11)
      return 0;
    if (v18)
    {
      LODWORD(v16) = 0;
      do
      {
        v17 = *result++;
        v16 = v17 | ((_DWORD)v16 << 8);
        --v10;
      }
      while (v10);
    }
    else
    {
      v16 = 0;
    }
    result = (unsigned __int8 *)(v12 + v16);
    if (v12 + v16 + 8 > v11)
      return 0;
  }
  return result;
}

BOOL TRunComparator::RunsSimilar(TRunComparator *this, const TRun *a2, const TRun *a3)
{
  unint64_t v6;
  _BOOL8 v7;
  TFont *v8;
  unint64_t *v9;
  unint64_t v11;
  id v13;
  id v14;

  if (*((unsigned __int8 *)a2 + 224) != *((unsigned __int8 *)a3 + 224) || *((_DWORD *)a2 + 76) != *((_DWORD *)a3 + 76))
    return 0;
  v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TAttributes::OriginalFont((const TRun *)((char *)a2 + 40), (unint64_t *)&v14);
  v13 = (id)0xAAAAAAAAAAAAAAAALL;
  TAttributes::OriginalFont((const TRun *)((char *)a3 + 40), (unint64_t *)&v13);
  if (atomic_load((unint64_t *)&v14))
    v6 = atomic_load((unint64_t *)&v14);
  else
    v6 = atomic_load((unint64_t *)a2 + 7);
  v8 = *(TFont **)(v6 + 40);
  v9 = (unint64_t *)&v13;
  if (!atomic_load((unint64_t *)&v13))
    v9 = (unint64_t *)((char *)a3 + 56);
  v11 = atomic_load(v9);
  v7 = TFont::Compare(v8, *(const TFont **)(v11 + 40), 0) != 0;

  return v7;
}

void TScriptRun::GetScriptRunsForLine(TLine *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  void **v26;
  void **v27;
  uint64_t v28;
  void **v29;
  _QWORD *v30;
  void **v31;
  void **v32;
  void **v33;
  uint64_t v34;
  BOOL v35;
  void **v36;
  uint64_t v37;
  uint64_t v39;
  void **v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  BOOL v49;
  void **v50;
  char *v51;
  BOOL v52;
  void **v53;
  uint64_t v54;
  unint64_t v55;
  TFont *v56;
  unint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t *v63;
  char *v64;
  uint64_t v65;
  char *v66;
  char *v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t *v70;
  char *v71;
  uint64_t v72;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v78;
  unint64_t v79;
  int v80;
  void **v83;
  uint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  void **v88;
  uint64_t v89;
  _BYTE v90[24];
  TLine *v91;
  uint64_t v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  uint64_t v104;
  unint64_t v105;
  __int128 v106;
  _OWORD v107[15];
  _OWORD *v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)a1 + 3) - *((_QWORD *)a1 + 2);
  if (v4 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = v4 >> 3;
    v9 = 2863311360;
    v78 = v4 >> 3;
    while (1)
    {
      v10 = *((_QWORD *)a1 + 2);
      v11 = *(_QWORD *)(*(_QWORD *)(v10 + 8 * v5) + 40);
      v13 = *(void ***)(v11 + 8);
      v12 = *(_QWORD *)(v11 + 16);
      v14 = v5 + 1;
      if (v5 + 1 >= v8)
        break;
      v75 = v5;
      v15 = *(_QWORD *)(*(_QWORD *)(v10 + 8 * v14) + 40);
      if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, v11, v15))
      {
        v74 = 1;
        goto LABEL_15;
      }
      v16 = v75 + 2;
      while (1)
      {
        v17 = v16;
        v18 = *(_QWORD *)(v15 + 8);
        v19 = (uint64_t)v13 + v12;
        if (v18 < (uint64_t)v13)
          v13 = *(void ***)(v15 + 8);
        v20 = *(_QWORD *)(v15 + 16) + v18;
        if (v19 > v20)
          v20 = v19;
        v12 = v20 - (_QWORD)v13;
        v21 = v78;
        if (v78 == v17)
          break;
        v15 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v17) + 40);
        v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, v11, v15);
        v16 = v17 + 1;
        if (!v22)
        {
          v23 = v17;
          v21 = v78;
          goto LABEL_17;
        }
      }
      v23 = v78;
LABEL_17:
      v76 = v23;
      v74 = v17 < v21;
LABEL_18:
      *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v107[13] = v24;
      v107[14] = v24;
      v107[11] = v24;
      v107[12] = v24;
      v107[9] = v24;
      v107[10] = v24;
      v107[7] = v24;
      v107[8] = v24;
      v107[5] = v24;
      v107[6] = v24;
      v107[3] = v24;
      v107[4] = v24;
      v107[1] = v24;
      v107[2] = v24;
      v106 = v24;
      v107[0] = v24;
      v105 = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v90[8] = v24;
      v87 = (uint64_t)v13 + v12;
      v88 = v13;
      v90[16] = 0;
      v89 = 0;
      *(_QWORD *)v90 = 0;
      *(_QWORD *)&v90[5] = 0;
      v91 = a1;
      v92 = a2;
      v93 = 0u;
      v94 = 0u;
      v95 = 0u;
      v96 = 0u;
      v97 = 0u;
      v98 = 0u;
      v99 = 0u;
      v100 = 0u;
      v101 = 0u;
      v102 = 0u;
      v103 = 0u;
      v104 = 0;
      v25 = *(_QWORD *)(a2 + 16);
      v106 = 0uLL;
      v105 = 0;
      *(_QWORD *)&v103 = v25;
      v108 = v107;
      v79 = v9 | v7 | v6 | 0xAAAAAA0000000000;
      while (TScriptRun::NextRun((uint64_t)&v87, v79))
      {
        v80 = *(_DWORD *)&v90[8];
        v26 = v88;
        if (v89 < 1)
        {
          v43 = 0;
          v29 = v88;
        }
        else
        {
          v27 = (void **)((char *)v88 + v89);
          v28 = (uint64_t)v88;
          v29 = v88;
          while (1)
          {
            v30 = *(_QWORD **)(*(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * TLine::FindRunWithCharIndex(a1, v28, 1)) + 40);
            v31 = (void **)v30[1];
            v32 = (void **)((char *)v31 + v30[2]);
            if ((uint64_t)v32 >= (uint64_t)v27)
              v33 = v27;
            else
              v33 = (void **)((char *)v31 + v30[2]);
            v34 = (char *)v33 - (char *)v26;
            v35 = (uint64_t)v31 <= (uint64_t)v26 && (uint64_t)v26 < (uint64_t)v32;
            if (v35)
              v36 = v26;
            else
              v36 = 0;
            if (!v35)
              v34 = 0;
            v37 = (char *)v33 - (char *)v31;
            if ((uint64_t)v26 <= (uint64_t)v31 && (uint64_t)v31 < (uint64_t)v27)
            {
              v39 = v37;
            }
            else
            {
              v31 = v36;
              v39 = v34;
            }
            v40 = (uint64_t)v31 >= (uint64_t)v29 ? v29 : v31;
            v41 = (uint64_t)v31 + v39;
            v42 = v28 <= v41 ? v41 : v28;
            v43 = v42 - (_QWORD)v40;
            if ((uint64_t)v27 <= v41)
              break;
            while (1)
            {
              v44 = (_QWORD *)v30[3];
              if (!v44)
              {
                v29 = v40;
                goto LABEL_83;
              }
              v45 = v44[1];
              v46 = v44[2] + v45;
              if (v46 >= (uint64_t)v27)
                v47 = (char *)v27;
              else
                v47 = (char *)(v44[2] + v45);
              v48 = (char *)(v47 - (char *)v26);
              v49 = v45 <= (uint64_t)v26 && (uint64_t)v26 < v46;
              if (v49)
                v50 = v26;
              else
                v50 = 0;
              if (!v49)
                v48 = 0;
              v51 = &v47[-v45];
              v52 = (uint64_t)v26 <= v45 && v45 < (uint64_t)v27;
              v53 = v52 ? (void **)v44[1] : v50;
              v54 = (uint64_t)(v52 ? v51 : v48);
              v55 = atomic_load(v30 + 7);
              v56 = *(TFont **)(v55 + 40);
              v57 = atomic_load(v44 + 7);
              if (!TFont::Compare(v56, *(const TFont **)(v57 + 40), 0))
                break;
              if ((uint64_t)v53 >= (uint64_t)v40)
                v29 = v40;
              else
                v29 = v53;
              v58 = (char *)v40 + v43;
              if ((uint64_t)v40 + v43 <= (uint64_t)v53 + v54)
                v58 = (char *)v53 + v54;
              v43 = v58 - (char *)v29;
              v30 = v44;
              v40 = v29;
              if ((uint64_t)v27 <= (uint64_t)((char *)v53 + v54))
                goto LABEL_83;
            }
            v84 = v43;
            v86 = -1431655766;
            v83 = v40;
            v85 = v80;
            v60 = (char *)*a4;
            v59 = (char *)a4[1];
            if (v59 != (char *)*a4)
            {
              v61 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v59[-*a4] >> 3);
              do
              {
                v62 = v61 >> 1;
                v63 = (uint64_t *)&v60[24 * (v61 >> 1)];
                v65 = *v63;
                v64 = (char *)(v63 + 3);
                v61 += ~(v61 >> 1);
                if (v65 < (uint64_t)v40)
                  v60 = v64;
                else
                  v61 = v62;
              }
              while (v61);
              v59 = v60;
            }
            std::vector<TScriptRunInfo,TInlineBufferAllocator<TScriptRunInfo,30ul>>::insert(a4, v59, (unint64_t)&v83);
            v29 = (void **)((char *)v40 + v43);
            v43 = 0;
LABEL_83:
            v28 = (uint64_t)v29 + v43;
            if ((uint64_t)((char *)v29 + v43) >= (uint64_t)v27)
              goto LABEL_87;
          }
          v29 = v40;
        }
LABEL_87:
        v84 = v43;
        v86 = -1431655766;
        v83 = v29;
        v85 = v80;
        v67 = (char *)*a4;
        v66 = (char *)a4[1];
        if (v66 != (char *)*a4)
        {
          v68 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v66[-*a4] >> 3);
          do
          {
            v69 = v68 >> 1;
            v70 = (uint64_t *)&v67[24 * (v68 >> 1)];
            v72 = *v70;
            v71 = (char *)(v70 + 3);
            v68 += ~(v68 >> 1);
            if (v72 < (uint64_t)v29)
              v67 = v71;
            else
              v68 = v69;
          }
          while (v68);
          v66 = v67;
        }
        std::vector<TScriptRunInfo,TInlineBufferAllocator<TScriptRunInfo,30ul>>::insert(a4, v66, (unint64_t)&v83);
      }
      if (!v74)
      {
        v83 = (void **)&v105;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v83);
        return;
      }
      v6 = v90[12];
      v9 = *(_DWORD *)&v90[12] & 0xFFFFFF00;
      v7 = *(_QWORD *)&v90[12] & 0xFF00000000;
      v83 = (void **)&v105;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v83);
      v8 = v78;
      v5 = v76;
      if (v76 >= v78)
        return;
    }
    v74 = 0;
LABEL_15:
    v76 = v14;
    goto LABEL_18;
  }
}

_QWORD *std::vector<TScriptRunInfo,TInlineBufferAllocator<TScriptRunInfo,30ul>>::insert(_QWORD *result, char *__src, unint64_t a3)
{
  unint64_t v3;
  char *v4;
  char **v5;
  char *v6;
  unint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  __int128 v11;
  char *v12;
  unint64_t v13;
  uint64_t v14;
  int64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  char *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  __int128 v27;
  char *v28;
  char *v29;
  char *v30;
  __int128 v31;
  char *v32;
  int64_t v33;
  char *v34;
  char *v35;
  char *v37;
  char *v38;
  unint64_t v39;
  char *v40;
  _QWORD *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  _QWORD *v46;

  v3 = a3;
  v4 = __src;
  v5 = (char **)result;
  v6 = (char *)result[1];
  v7 = result[2];
  if ((unint64_t)v6 >= v7)
  {
    v12 = (char *)*result;
    v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v6[-*result] >> 3) + 1;
    v39 = 0xAAAAAAAAAAAAAAAALL;
    if (v13 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v14 = __src - v12;
    v15 = 0xAAAAAAAAAAAAAAABLL * ((__src - v12) >> 3);
    v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (_QWORD)v12) >> 3);
    if (2 * v16 > v13)
      v13 = 2 * v16;
    if (v16 >= 0x555555555555555)
      v17 = 0xAAAAAAAAAAAAAAALL;
    else
      v17 = v13;
    v41 = result + 3;
    if (v17)
      v18 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)(result + 3), v17);
    else
      v18 = 0;
    v21 = &v18[24 * v15];
    v22 = &v18[24 * v17];
    v40 = v22;
    if (v15 == v17)
    {
      if (v14 < 1)
      {
        if (v12 == v4)
          v24 = 1;
        else
          v24 = 2 * v15;
        v46 = v5 + 3;
        v25 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)(v5 + 3), v24);
        v26 = &v25[24 * (v24 >> 2)];
        v37 = v25;
        v38 = v26;
        v42 = v18;
        v43 = &v18[24 * v15];
        v40 = &v25[24 * v24];
        v44 = v43;
        v45 = v22;
        std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v42);
        v21 = v26;
      }
      else
      {
        v23 = v15 + 2;
        if (v15 >= -1)
          v23 = v15 + 1;
        v21 -= 24 * (v23 >> 1);
      }
    }
    v27 = *(_OWORD *)a3;
    *((_QWORD *)v21 + 2) = *(_QWORD *)(a3 + 16);
    *(_OWORD *)v21 = v27;
    v28 = v21 + 24;
    v39 = (unint64_t)(v21 + 24);
    v29 = *v5;
    if (*v5 != v4)
    {
      v30 = v4;
      do
      {
        v31 = *(_OWORD *)(v30 - 24);
        *((_DWORD *)v21 - 2) = *((_DWORD *)v30 - 2);
        *(_OWORD *)(v21 - 24) = v31;
        v21 -= 24;
        v30 -= 24;
      }
      while (v30 != v29);
      v28 = (char *)v39;
    }
    v32 = v5[1];
    v33 = v32 - v4;
    if (v32 != v4)
    {
      memmove(v28, v4, v33 - 4);
      v4 = v5[1];
    }
    v34 = *v5;
    *v5 = v21;
    v5[1] = &v28[v33];
    v35 = v5[2];
    v5[2] = v40;
    v39 = (unint64_t)v4;
    v40 = v35;
    v37 = v34;
    v38 = v34;
    return (_QWORD *)std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v37);
  }
  else if (__src == v6)
  {
    v20 = *(_OWORD *)a3;
    *((_QWORD *)__src + 2) = *(_QWORD *)(a3 + 16);
    *(_OWORD *)__src = v20;
    result[1] = __src + 24;
  }
  else
  {
    v8 = __src + 24;
    v9 = v6 - 24;
    v10 = result[1];
    while (v9 < v6)
    {
      v11 = *(_OWORD *)v9;
      *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
      *(_OWORD *)v10 = v11;
      v10 += 24;
      v9 += 24;
    }
    result[1] = v10;
    if (v6 != v8)
      result = memmove(v8, __src, v6 - v8 - 4);
    if ((unint64_t)v4 <= v3)
      v3 += 24 * ((unint64_t)v5[1] > v3);
    v19 = *(_OWORD *)v3;
    *((_DWORD *)v4 + 4) = *(_DWORD *)(v3 + 16);
    *(_OWORD *)v4 = v19;
  }
  return result;
}

uint64_t DestroyTable(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = 0;
    while (1)
    {
      if (*(_QWORD *)(v1 + v2))
      {
        *(_QWORD *)(v1 + v2) = 0;
        (*(void (**)(void))(v1 + v2 + 8))();
      }
      v2 += 16;
      if (v2 == 144)
        JUMPOUT(0x186DC03ACLL);
    }
  }
  return result;
}

BOOL CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCore(void *a1, void *a2, uint64_t a3, const void *a4)
{
  NSObject *v8;
  FontAssetDownloadManager *v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t *v12;
  unint64_t v13;
  id v14;
  void *v15;
  _QWORD v17[6];
  objc_super v18;

  if (a1)
  {
    if (qword_1ECDE7E48 != -1)
      dispatch_once(&qword_1ECDE7E48, &__block_literal_global_131);
    v8 = qword_1ECDE7E50;
    v9 = [FontAssetDownloadManager alloc];
    if (v9)
    {
      v18.receiver = v9;
      v18.super_class = (Class)FontAssetDownloadManager;
      v10 = (unint64_t *)objc_msgSendSuper2(&v18, sel_init);
      v11 = v10;
      if (v10)
      {
        TCFRef<__CTFont const*>::Retain(v10 + 1, a1);
        v12 = v11 + 2;
        v13 = atomic_load(v11 + 2);
        if ((void *)v13 != a2)
        {
          v14 = a2;
          do
            v15 = (void *)__ldaxr(v12);
          while (__stlxr((unint64_t)v14, v12));

        }
        v11[3] = (unint64_t)_Block_copy(a4);
        v11[4] = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 0);
        v11[5] = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 0);
        v11[6] = objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 0);
      }
    }
    else
    {
      v11 = 0;
    }
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v17[2] = ___ZL59CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCorePK9__CFArrayPK7__CFSetmU13block_pointerFb29CTFontDescriptorMatchingStatePK14__CFDictionaryE_block_invoke;
    v17[3] = &unk_1E15E8B80;
    v17[4] = v11;
    v17[5] = a3;
    dispatch_async(v8, v17);
  }
  return a1 != 0;
}

CFTypeRef CTFontDescriptorCopyDownloadableFontAttributesForRequests(const __CFArray *a1)
{
  return CopyDownloadableFontAttributesForRequests(a1, 0);
}

CFTypeRef CopyDownloadableFontAttributesForRequests(const __CFArray *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t i;
  void *v10;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  unsigned int v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  NSDictionary *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  void *v28;
  void *v29;
  unint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  id v37;
  const __CFDictionary *v38;
  unint64_t v39;
  void *v40;
  id v41;
  id v42;
  unint64_t v43;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  id v49;
  char v50;
  void *cf;
  unsigned int v52;
  id v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  const __CFArray *obj;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  id v78;
  _BYTE v79[128];
  _BYTE v80[128];
  _BYTE v81[128];
  _BYTE v82[128];
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  objc_opt_self();
  v56 = a2;
  if (-[__CFArray count](a1, "count") == 1)
    LOBYTE(v4) = (a2 & 0x1000 | objc_msgSend((id)-[__CFArray firstObject](a1, "firstObject"), "objectForKey:", CFSTR("NSFontNameAttribute"))) != 0;
  else
    v4 = (a2 >> 12) & 1;
  v50 = v4;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  obj = a1;
  v5 = -[__CFArray countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v74, v82, 16);
  if (!v5)
  {
    v13 = 2;
    goto LABEL_26;
  }
  LOBYTE(v6) = 0;
  v7 = *(_QWORD *)v75;
  LOBYTE(v8) = 1;
  do
  {
    for (i = 0; i != v5; ++i)
    {
      if (*(_QWORD *)v75 != v7)
        objc_enumerationMutation(obj);
      v10 = *(void **)(*((_QWORD *)&v74 + 1) + 8 * i);
      if ((v8 & 1) != 0)
      {
        v8 = objc_msgSend((id)objc_msgSend(*(id *)(*((_QWORD *)&v74 + 1) + 8 * i), "objectForKey:", CFSTR("NSCTFontDownloadedAttribute")), "BOOLValue");
        if ((v6 & 1) == 0)
          goto LABEL_11;
      }
      else
      {
        v8 = 0;
        if ((v6 & 1) == 0)
        {
LABEL_11:
          v6 = objc_msgSend((id)objc_msgSend(v10, "objectForKey:", CFSTR("CTFontAllowCellularDownloadAttribute")), "BOOLValue");
          continue;
        }
      }
      v6 = 1;
    }
    v5 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v74, v82, 16);
  }
  while (v5);
  if (v8)
    v11 = 6;
  else
    v11 = 4;
  if (v8)
    v12 = 2;
  else
    v12 = 0;
  if (v6)
    v13 = v11;
  else
    v13 = v12;
LABEL_26:
  v73 = 0;
  v49 = +[FontAssetDownloadManager availableMobileAssetsWithOptions:manager:error:]((uint64_t)FontAssetDownloadManager, v13, 0, &v73);
  cf = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v48 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v69, v81, 16);
  if (!v48)
    goto LABEL_91;
  v52 = 0;
  v45 = (v13 >> 1) & 1;
  v47 = *(_QWORD *)v70;
  while (2)
  {
    v14 = 0;
    while (2)
    {
      if (*(_QWORD *)v70 != v47)
      {
        v15 = v14;
        objc_enumerationMutation(v49);
        v14 = v15;
      }
      v46 = v14;
      v59 = *(void **)(*((_QWORD *)&v69 + 1) + 8 * v14);
      v16 = (void *)objc_msgSend(v59, "attributes");
      v17 = (void *)objc_msgSend(v16, "objectForKey:", CFSTR("FontDesignLanguages"));
      v53 = (id)objc_msgSend(v16, "objectForKey:", CFSTR("FontInfo4"));
      v54 = objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("_DownloadSize"));
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v57 = objc_msgSend(v53, "countByEnumeratingWithState:objects:count:", &v65, v80, 16);
      ++v52;
      if (v57)
      {
        v55 = *(_QWORD *)v66;
        v18 = v45;
        v19 = v45;
        do
        {
          v20 = 0;
          do
          {
            if (*(_QWORD *)v66 != v55)
            {
              v21 = v20;
              objc_enumerationMutation(v53);
              v20 = v21;
            }
            v58 = v20;
            v22 = *(NSDictionary **)(*((_QWORD *)&v65 + 1) + 8 * v20);
            if ((v56 & 2) == 0)
            {
              v23 = (void *)objc_msgSend(*(id *)(*((_QWORD *)&v65 + 1) + 8 * v20), "objectForKey:", CFSTR("FontFamilyName"));
              if (!objc_msgSend(v23, "length") || objc_msgSend(v23, "characterAtIndex:", 0) == 46)
                goto LABEL_87;
            }
            v63 = 0u;
            v64 = 0u;
            v61 = 0u;
            v62 = 0u;
            v24 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v61, v79, 16);
            if (!v24)
              goto LABEL_87;
            v25 = *(_QWORD *)v62;
            while (2)
            {
              v26 = 0;
              do
              {
                if (*(_QWORD *)v62 != v25)
                  objc_enumerationMutation(obj);
                v27 = *(void **)(*((_QWORD *)&v61 + 1) + 8 * v26);
                v28 = (void *)objc_msgSend(v27, "objectForKey:", CFSTR("NSCTFontDownloadedAttribute"));
                v29 = v28;
                if (v28)
                {
                  if ((v19 & 1) != 0)
                  {
                    v19 = 1;
                    if (((v18 ^ objc_msgSend(v28, "BOOLValue")) & 1) != 0)
                      goto LABEL_52;
                  }
                  else
                  {
                    objc_opt_self();
                    v30 = objc_msgSend(v59, "state");
                    if (v30 <= 6 && ((1 << v30) & 0x6C) != 0)
                    {
                      v19 = 1;
                      v18 = 1;
                      if ((objc_msgSend(v29, "BOOLValue") & 1) == 0)
                        goto LABEL_52;
                    }
                    else
                    {
                      v18 = 0;
                      v19 = 1;
                      if ((objc_msgSend(v29, "BOOLValue") & 1) != 0)
                        goto LABEL_52;
                    }
                  }
                }
                if (+[FontAssetDownloadManager fontInfo:andAssetDesignLanguages:matchesRequest:]((uint64_t)FontAssetDownloadManager, v22, (uint64_t)v17, v27))
                {
                  objc_opt_self();
                  v32 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
                  objc_msgSend(v32, "setObject:forKey:", -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("PostScriptFontName")), CFSTR("NSFontNameAttribute"));
                  v33 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("FontFamilyName"));
                  if (v33)
                    objc_msgSend(v32, "setObject:forKey:", v33, CFSTR("NSFontFamilyAttribute"));
                  v34 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("PreferredFamilyName"));
                  if (v34)
                    objc_msgSend(v32, "setObject:forKey:", v34, CFSTR("NSFontFamilyAttribute"));
                  v35 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("FontStyleName"));
                  if (v35)
                    objc_msgSend(v32, "setObject:forKey:", v35, CFSTR("NSFontFaceAttribute"));
                  v36 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("PreferredStyleName"));
                  if (v36)
                    objc_msgSend(v32, "setObject:forKey:", v36, CFSTR("NSFontFaceAttribute"));
                  v37 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("FontDesignLanguages"));
                  if (objc_msgSend(v37, "count") || (v37 = v17, objc_msgSend(v17, "count")))
                    objc_msgSend(v32, "setObject:forKey:", v37, CFSTR("NSCTFontDesignLanguagesAttribute"));
                  objc_msgSend(v32, "setObject:forKey:", MEMORY[0x1E0C9AAB0], CFSTR("NSCTFontDownloadableAttribute"));
                  v38 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("DisplayNames"));
                  CopyValueForCurrentUser(v38, 0, (unint64_t *)&v78);
                  v39 = atomic_load((unint64_t *)&v78);

                  if (v39)
                    objc_msgSend(v32, "setObject:forKey:", v39, CFSTR("NSFontVisibleNameAttribute"));
                  v40 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
                  if (-[__CFDictionary count](v38, "count"))
                    objc_msgSend(v40, "setObject:forKey:", v38, CFSTR("NSFontVisibleNameAttribute"));
                  v41 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("LocalizedFamilyNames"));
                  if (objc_msgSend(v41, "count"))
                    objc_msgSend(v40, "setObject:forKey:", v41, CFSTR("NSFontFamilyAttribute"));
                  v42 = -[NSDictionary objectForKey:](v22, "objectForKey:", CFSTR("LocalizedStyleNames"));
                  if (objc_msgSend(v42, "count"))
                    objc_msgSend(v40, "setObject:forKey:", v42, CFSTR("NSFontFaceAttribute"));
                  if (objc_msgSend(v40, "count"))
                    objc_msgSend(v32, "setObject:forKey:", v40, 0x1E15FBE60);
                  if ((v19 & 1) == 0)
                  {
                    objc_opt_self();
                    v43 = objc_msgSend(v59, "state");
                    if (v43 > 6)
                      v18 = 0;
                    else
                      v18 = (0x6Cu >> v43) & 1;
                  }
                  if (v54)
                    objc_msgSend(v32, "setObject:forKey:", v54, CFSTR("_DownloadSize"));
                  objc_msgSend(v32, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", v18 & 1), CFSTR("NSCTFontDownloadedAttribute"));
                  objc_msgSend(v32, "setObject:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v52), CFSTR("LocalID"));
                  objc_msgSend(cf, "addObject:", v32);
                  if ((v50 & 1) == 0)
                  {
                    v19 = 1;
                    goto LABEL_87;
                  }
                  goto LABEL_91;
                }
LABEL_52:
                ++v26;
              }
              while (v24 != v26);
              v31 = -[__CFArray countByEnumeratingWithState:objects:count:](obj, "countByEnumeratingWithState:objects:count:", &v61, v79, 16);
              v24 = v31;
              if (v31)
                continue;
              break;
            }
LABEL_87:
            v20 = v58 + 1;
          }
          while (v58 + 1 != v57);
          v57 = objc_msgSend(v53, "countByEnumeratingWithState:objects:count:", &v65, v80, 16);
        }
        while (v57);
      }
      v14 = v46 + 1;
      if (v46 + 1 != v48)
        continue;
      break;
    }
    v48 = objc_msgSend(v49, "countByEnumeratingWithState:objects:count:", &v69, v81, 16);
    if (v48)
      continue;
    break;
  }
LABEL_91:
  if (objc_msgSend(cf, "count"))
    return CFRetain(cf);
  else
    return 0;
}

void TDescriptorSource::CopyDownloadableDescriptorsForRequest(TDescriptorSource *this@<X0>, const __CFDictionary *a2@<X1>, unint64_t *a3@<X8>)
{
  CFTypeRef v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  const void *v11;
  unint64_t v12;
  id v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v19[0] = this;
  v4 = CopyDownloadableFontAttributesForRequests((const __CFArray *)objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v19, 1), (unint64_t)a2);
  v5 = (id)CFMakeCollectable(v4);
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 0);
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
  if (v7)
  {
    v8 = *(_QWORD *)v15;
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v15 != v8)
          objc_enumerationMutation(v5);
        v10 = CTFontDescriptorCreateWithAttributesAndOptions(*(void **)(*((_QWORD *)&v14 + 1) + 8 * v9), 0x40000000);
        if (v10)
        {
          v11 = (const void *)v10;
          objc_msgSend(v6, "addObject:", v10);
          CFRelease(v11);
        }
        ++v9;
      }
      while (v7 != v9);
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    }
    while (v7);
  }
  v13 = v6;
  do
    v12 = __ldaxr((unint64_t *)&v13);
  while (__stlxr(0, (unint64_t *)&v13));
  *a3 = v12;

}

void *CTFontDescriptorDownloadMatchingFontDescriptors(void *result, uint64_t a2, const void *a3)
{
  if ((a2 & 1) == 0)
    return (void *)CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCore(result, 0, a2, a3);
  return result;
}

BOOL CTFontDescriptorRequiresFontAssetRequest(const __CTFontDescriptor *a1)
{
  const __CFDictionary *v1;
  __CFDictionary *v2;
  __CFDictionary *v3;
  TDescriptorSource *v4;
  void *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  _BOOL8 v9;
  id v11;
  id v12;

  v1 = CTFontDescriptorCopyAttributes(a1);
  v12 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v12, v1);
  v2 = (__CFDictionary *)atomic_load((unint64_t *)&v12);
  CFDictionarySetValue(v2, CFSTR("NSCTFontDownloadableAttribute"), (const void *)*MEMORY[0x1E0C9AE50]);
  v3 = (__CFDictionary *)atomic_load((unint64_t *)&v12);
  CFDictionarySetValue(v3, CFSTR("NSCTFontDownloadedAttribute"), (const void *)*MEMORY[0x1E0C9AE40]);
  v11 = (id)0xAAAAAAAAAAAAAAAALL;
  v4 = (TDescriptorSource *)atomic_load((unint64_t *)&v12);
  TDescriptorSource::CopyDownloadableDescriptorsForRequest(v4, (const __CFDictionary *)0x1000, (unint64_t *)&v11);
  v5 = (void *)atomic_load((unint64_t *)&v11);
  v6 = v5;
  v7 = v6;
  if (v6)
    Count = CFArrayGetCount(v6);
  else
    Count = 0;
  v9 = Count > 0;

  return v9;
}

void sub_18491CD30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t GSFontLibraryCore(char **a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v1 = GSFontLibraryCore(char **)::frameworkLibrary;
  v6 = GSFontLibraryCore(char **)::frameworkLibrary;
  if (!GSFontLibraryCore(char **)::frameworkLibrary)
  {
    v7 = xmmword_1E15E8B20;
    v1 = _sl_dlopen();
    v4[3] = v1;
    GSFontLibraryCore(char **)::frameworkLibrary = v1;
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_18491CE30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc(void)
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc(void)::ptr;
  v6 = getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc(void)::ptr;
  if (!getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc(void)::ptr)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = ___ZL49getGSFontUpdateFontAssetLastAccessedTimeSymbolLocv_block_invoke;
    v2[3] = &unk_1E15E8B38;
    v2[4] = &v3;
    ___ZL49getGSFontUpdateFontAssetLastAccessedTimeSymbolLocv_block_invoke(v2);
    v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18491CEE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL59CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCorePK9__CFArrayPK7__CFSetmU13block_pointerFb29CTFontDescriptorMatchingStatePK14__CFDictionaryE_block_invoke(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const void *ValueAtIndex;
  const __CFSet *v12;
  void *MatchingFontDescriptorsWithOptions;
  const __CFArray *v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex i;
  const void *v18;
  uint64_t v19;
  unint64_t v20;
  void *v22;
  id v23;
  void (*GSFontUpdateFontAssetLastAccessedTimeSymbolLoc)(CFMutableArrayRef);
  void *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  const __CTFontDescriptor *v30;
  unint64_t *v31;
  const __CFDictionary *Value;
  void *v33;
  char v34;
  char v35;
  char v36;
  void *v37;
  void *v38;
  uint64_t v39;
  const __CFAllocator *v40;
  const __CFAllocator *v41;
  NSDictionary *v42;
  uint64_t v43;
  CFMutableArrayRef k;
  const __CTFontDescriptor *v45;
  CFDictionaryRef v46;
  void *v47;
  uint64_t v48;
  void *v49;
  _BOOL4 v50;
  uint64_t v51;
  double v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  void *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  double Helper_x8__ASDownloadPriorityHigh;
  double Helper_x8__ASDownloadOptionPriority;
  id v66;
  double v67;
  double Helper_x8__ASDownloadOptionAllowBatteryPower;
  uint64_t v69;
  id v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  void *v83;
  const __CFNumber *v84;
  const __CFNumber *v85;
  CFTypeID v86;
  int v87;
  int v88;
  void *v89;
  unint64_t v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  void *v94;
  unint64_t v95;
  uint64_t v96;
  void *v97;
  void *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t m;
  void *v102;
  BOOL v103;
  void *v104;
  uint64_t v105;
  void *v106;
  uint64_t v107;
  void *v108;
  void *v109;
  dispatch_source_t v110;
  id v111;
  void *v112;
  BOOL v113;
  dispatch_time_t v114;
  double v115;
  uint64_t v116;
  id v117;
  double v118;
  void *v119;
  _BOOL8 v120;
  __CFBundle *MainBundle;
  const __CFString *Identifier;
  uint64_t v123;
  void *v124;
  uint64_t v125;
  void *v126;
  uint64_t v127;
  void *v128;
  const __CFArray *v129;
  CFIndex v130;
  CFIndex v131;
  CFIndex v132;
  const void *v133;
  const __CFSet *v134;
  void *v135;
  const __CFArray *v136;
  const __CFArray *v137;
  CFIndex v138;
  void *v139;
  void *v140;
  BOOL v141;
  void *v143;
  void *v144;
  void *v145;
  void *v146;
  id v147;
  void *v148;
  uint64_t v149;
  void *v150;
  NSObject *dsema;
  id *v152;
  void *context;
  void *v154;
  char *v155;
  uint64_t v156;
  void *v157;
  uint64_t j;
  void *v159;
  void *v160;
  uint64_t v161;
  id obj;
  unsigned int obja;
  id v164;
  id v165;
  id val;
  id v167;
  id v168;
  uint64_t v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  const __CFAllocator *allocator;
  CFAllocatorRef allocatora;
  __int128 handler;
  __int128 v176;
  __int128 v177;
  id v178[3];
  _QWORD v179[5];
  uint64_t v180[6];
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  uint64_t v189;
  uint64_t *v190;
  uint64_t v191;
  char v192;
  id v193;
  id v194;
  id location[2];
  __int128 v196;
  __int128 v197;
  __int128 v198;
  _QWORD v199[8];
  id v200[3];
  int v201;
  void *v202;
  uint64_t v203;
  intptr_t (*v204)(uint64_t);
  void *v205;
  dispatch_source_t v206;
  NSObject *v207;
  _BYTE v208[128];
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  id valuePtr[18];

  valuePtr[16] = *(id *)MEMORY[0x1E0C80C00];
  context = (void *)MEMORY[0x186DC070C]();
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
  {
LABEL_226:
    v144 = 0;
    goto LABEL_224;
  }
  v4 = a1;
  v5 = *(_QWORD *)(a1 + 40);
  if (!-[FontAssetDownloadManager callProgressCallback:](v3, 0))
    goto LABEL_223;
  val = (id)v3;
  v149 = v4;
  if ((v5 & 2) != 0)
  {
    v6 = (void *)atomic_load((unint64_t *)(v3 + 8));
  }
  else
  {
    v6 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v7 = (const __CFArray *)atomic_load((unint64_t *)(v3 + 8));
    if (v7)
    {
      Count = CFArrayGetCount(v7);
      if (Count)
      {
        v9 = Count;
        v10 = 0;
        allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v7, v10);
          v12 = (const __CFSet *)atomic_load((unint64_t *)val + 2);
          MatchingFontDescriptorsWithOptions = (void *)CTFontDescriptorCreateMatchingFontDescriptorsWithOptions((uint64_t)ValueAtIndex, v12, 512);
          v14 = MatchingFontDescriptorsWithOptions;
          Mutable = v14;
          if (!v14)
            break;
          v15 = CFArrayGetCount(v14);

          if (!v15)
            goto LABEL_27;
          if (GSFontLibraryCore(0) && getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc())
          {
            Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
            if (MatchingFontDescriptorsWithOptions)
            {
              v16 = CFArrayGetCount((CFArrayRef)MatchingFontDescriptorsWithOptions);
              if (v16)
              {
                for (i = 0; i != v16; ++i)
                {
                  v18 = CFArrayGetValueAtIndex((CFArrayRef)MatchingFontDescriptorsWithOptions, i);
                  v19 = *((_QWORD *)v18 + 5);
                  if ((*(_DWORD *)(v19 + 16) & 0x80000000) == 0)
                    TDescriptor::InitBaseFont(*((TDescriptor **)v18 + 5), 0, 0.0);
                  v20 = atomic_load((unint64_t *)(v19 + 32));
                  valuePtr[0] = (id)0xAAAAAAAAAAAAAAAALL;
                  if (v20)
                    (*(void (**)(id *__return_ptr))(*(_QWORD *)v20 + 200))(valuePtr);
                  else
                    valuePtr[0] = 0;
                  if (atomic_load((unint64_t *)valuePtr))
                  {
                    v22 = (void *)atomic_load((unint64_t *)valuePtr);
                    v23 = v22;
                    CFArrayAppendValue(Mutable, v23);

                  }
                }
              }
            }
            if (CFArrayGetCount(Mutable) >= 1)
            {
              GSFontUpdateFontAssetLastAccessedTimeSymbolLoc = (void (*)(CFMutableArrayRef))getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc();
              if (!GSFontUpdateFontAssetLastAccessedTimeSymbolLoc)
              {
                v145 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
                objc_msgSend(v145, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void gsFontUpdateFontAssetLastAccessedTime(CFArrayRef)"), CFSTR("TDescriptorSourceDownloadableAsset.cpp"), 52, CFSTR("%s"), dlerror());
                __break(1u);
                goto LABEL_226;
              }
              GSFontUpdateFontAssetLastAccessedTimeSymbolLoc(Mutable);
            }

          }
LABEL_28:

          if (++v10 == v9)
            goto LABEL_31;
        }

LABEL_27:
        objc_msgSend(v6, "addObject:", ValueAtIndex);
        goto LABEL_28;
      }
    }
  }
LABEL_31:
  if (!objc_msgSend(v6, "count"))
    goto LABEL_201;
  v25 = (void *)*((_QWORD *)val + 4);
  if (v6)
    objc_msgSend(v25, "setObject:forKey:", v6, CFSTR("CTFontDescriptorMatchingDescriptors"));
  else
    objc_msgSend(v25, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingDescriptors"));
  v197 = 0u;
  v198 = 0u;
  *(_OWORD *)location = 0u;
  v196 = 0u;
  v26 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", location, valuePtr, 16);
  if (!v26)
  {
    v36 = 2;
    goto LABEL_59;
  }
  LOBYTE(v27) = 0;
  v28 = *(_QWORD *)v196;
  LOBYTE(v29) = 1;
  do
  {
    for (Mutable = 0; Mutable != (CFMutableArrayRef)v26; Mutable = (CFMutableArrayRef)((char *)Mutable + 1))
    {
      if (*(_QWORD *)v196 != v28)
        objc_enumerationMutation(v6);
      v30 = (const __CTFontDescriptor *)*((_QWORD *)location[1] + (_QWORD)Mutable);
      if ((v29 & 1) != 0)
      {
        v31 = (unint64_t *)(*((_QWORD *)v30 + 5) + 8);
        atomic_load(v31);
        Value = (const __CFDictionary *)atomic_load(v31);
        if (Value)
          Value = (const __CFDictionary *)CFDictionaryGetValue(Value, CFSTR("NSCTFontDownloadedAttribute"));
        v29 = -[__CFDictionary BOOLValue](Value, "BOOLValue");
        if ((v27 & 1) == 0)
        {
LABEL_44:
          v33 = (void *)CTFontDescriptorCopyAttribute(v30, CFSTR("CTFontAllowCellularDownloadAttribute"));
          v27 = objc_msgSend(v33, "BOOLValue");

          continue;
        }
      }
      else
      {
        v29 = 0;
        if ((v27 & 1) == 0)
          goto LABEL_44;
      }
      v27 = 1;
    }
    v26 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", location, valuePtr, 16);
  }
  while (v26);
  if (v29)
    v34 = 6;
  else
    v34 = 4;
  if (v29)
    v35 = 2;
  else
    v35 = 0;
  if (v27)
    v36 = v34;
  else
    v36 = v35;
LABEL_59:
  v180[0] = 0;
  obj = +[FontAssetDownloadManager availableMobileAssetsWithOptions:manager:error:]((uint64_t)FontAssetDownloadManager, v36, (uint64_t)val, v180);
  if (obj)
  {
    v167 = (id)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v187 = 0u;
    v188 = 0u;
    v185 = 0u;
    v186 = 0u;
    v156 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v185, &v209, 16);
    if (v156)
    {
      v152 = *(id **)v186;
      do
      {
        for (j = 0; j != v156; ++j)
        {
          if (*(id **)v186 != v152)
            objc_enumerationMutation(obj);
          v154 = *(void **)(*((_QWORD *)&v185 + 1) + 8 * j);
          v160 = (void *)objc_msgSend(v154, "attributes");
          v37 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
          v38 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
          v164 = (id)objc_msgSend(v160, "objectForKey:", CFSTR("FontInfo4"));
          v39 = objc_msgSend(v160, "objectForKey:", CFSTR("FontDesignLanguages"));
          v183 = 0u;
          v184 = 0u;
          v181 = 0u;
          v182 = 0u;
          v171 = objc_msgSend(v164, "countByEnumeratingWithState:objects:count:", &v181, v208, 16);
          if (v171)
          {
            v169 = *(_QWORD *)v182;
            do
            {
              v40 = 0;
              do
              {
                if (*(_QWORD *)v182 != v169)
                {
                  v41 = v40;
                  objc_enumerationMutation(v164);
                  v40 = v41;
                }
                allocatora = v40;
                v42 = *(NSDictionary **)(*((_QWORD *)&v181 + 1) + 8 * (_QWORD)v40);
                handler = 0u;
                v176 = 0u;
                v177 = 0u;
                *(_OWORD *)v178 = 0u;
                Mutable = (CFMutableArrayRef)objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &handler, v199, 16);
                if (Mutable)
                {
                  v43 = *(_QWORD *)v176;
                  do
                  {
                    for (k = 0; k != Mutable; k = (CFMutableArrayRef)((char *)k + 1))
                    {
                      if (*(_QWORD *)v176 != v43)
                        objc_enumerationMutation(v6);
                      v45 = *(const __CTFontDescriptor **)(*((_QWORD *)&handler + 1) + 8 * (_QWORD)k);
                      v46 = CTFontDescriptorCopyAttributes(v45);
                      if (+[FontAssetDownloadManager fontInfo:andAssetDesignLanguages:matchesRequest:]((uint64_t)FontAssetDownloadManager, v42, v39, v46))
                      {
                        objc_msgSend(v37, "addObject:", v45);
                        objc_msgSend(v38, "addObject:", v42);
                      }

                    }
                    Mutable = (CFMutableArrayRef)objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &handler, v199, 16);
                  }
                  while (Mutable);
                }
                v40 = (CFAllocatorRef)((char *)allocatora + 1);
              }
              while ((CFAllocatorRef)((char *)allocatora + 1) != (CFAllocatorRef)v171);
              v171 = objc_msgSend(v164, "countByEnumeratingWithState:objects:count:", &v181, v208, 16);
            }
            while (v171);
          }
          if (objc_msgSend(v37, "count"))
          {
            objc_msgSend(v167, "addObject:", v154);
            v202 = v37;
            v203 = (uint64_t)v38;
            objc_msgSend(*((id *)val + 6), "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v202, 2), v160);
          }
        }
        v156 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v185, &v209, 16);
      }
      while (v156);
    }
    v47 = v167;
  }
  else
  {
    v47 = 0;
  }
  v168 = v47;
  v48 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v47, "count"));
  v49 = (void *)*((_QWORD *)val + 4);
  if (v48)
    objc_msgSend(v49, "setObject:forKey:", v48, CFSTR("CTFontDescriptorMatchingTotalAssetCount"));
  else
    objc_msgSend(v49, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingTotalAssetCount"));
  objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingDescriptors"));
  if (v180[0])
    v50 = obj == 0;
  else
    v50 = 0;
  if (v50)
  {
    objc_msgSend(*((id *)val + 4), "setObject:forKey:");
    -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 8);
    objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingError"));
  }
  objc_opt_self();
  v209 = 0u;
  v210 = 0u;
  v211 = 0u;
  v212 = 0u;
  v51 = objc_msgSend(v168, "countByEnumeratingWithState:objects:count:", &v209, valuePtr, 16);
  gotLoadHelper_x27__ASAttributeDownloadSize(v52);
  v53 = (_QWORD *)*((_QWORD *)Mutable + 478);
  v54 = 0;
  if (v55)
  {
    v56 = *(_QWORD *)v210;
    do
    {
      v57 = 0;
      do
      {
        if (*(_QWORD *)v210 != v56)
          objc_enumerationMutation(v168);
        v58 = *(void **)(*((_QWORD *)&v209 + 1) + 8 * v57);
        v59 = (void *)objc_msgSend(v58, "attributes");
        objc_opt_self();
        v60 = objc_msgSend(v58, "state") - 2;
        if (v60 < 5 && ((0x1Bu >> v60) & 1) != 0)
          v61 = 0;
        else
          v61 = objc_msgSend((id)objc_msgSend(v59, "objectForKey:", *v53), "longValue");
        v54 += v61;
        ++v57;
      }
      while (v51 != v57);
      v51 = objc_msgSend(v168, "countByEnumeratingWithState:objects:count:", &v209, valuePtr, 16);
    }
    while (v51);
  }
  v62 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:", v54);
  v63 = (void *)*((_QWORD *)val + 4);
  if (v62)
    objc_msgSend(v63, "setObject:forKey:", v62, CFSTR("CTFontDescriptorMatchingTotalAssetSize"));
  else
    objc_msgSend(v63, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingTotalAssetSize"));
  dsema = dispatch_semaphore_create(0);
  v189 = 0;
  v190 = &v189;
  v191 = 0x2020000000;
  v192 = 1;
  Helper_x8__ASDownloadPriorityHigh = gotLoadHelper_x8__ASDownloadPriorityHigh(COERCE_DOUBLE(0x2020000000));
  Helper_x8__ASDownloadOptionPriority = gotLoadHelper_x8__ASDownloadOptionPriority(Helper_x8__ASDownloadPriorityHigh);
  objc_msgSend(v66, "setObject:forKey:", Helper_x8__ASDownloadOptionPriority);
  Helper_x8__ASDownloadOptionAllowBatteryPower = gotLoadHelper_x8__ASDownloadOptionAllowBatteryPower(v67);
  objc_msgSend(v70, "setObject:forKey:", MEMORY[0x1E0C9AAB0], **(_QWORD **)(v69 + 3896), Helper_x8__ASDownloadOptionAllowBatteryPower);
  v148 = (void *)objc_msgSend(v168, "count");
  v150 = (void *)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", CFSTR("com.apple.CoreText"));
  v187 = 0u;
  v188 = 0u;
  v185 = 0u;
  v186 = 0u;
  v71 = objc_msgSend(v168, "countByEnumeratingWithState:objects:count:", &v185, &v209, 16);
  if (!v71)
    goto LABEL_200;
  v72 = 0;
  v155 = 0;
  v172 = *(_QWORD *)v186;
  v73 = *MEMORY[0x1E0C999D0];
LABEL_111:
  v74 = 0;
  v165 = (id)v71;
  while (2)
  {
    if (*(_QWORD *)v186 != v172)
      objc_enumerationMutation(v168);
    v75 = *(void **)(*((_QWORD *)&v185 + 1) + 8 * v74);
    v76 = (void *)objc_msgSend(v75, "attributes");
    v77 = (void *)objc_msgSend(*((id *)val + 6), "objectForKey:", v76);
    if (objc_msgSend(v77, "count") != 2)
    {
      LODWORD(v79) = 0;
      goto LABEL_143;
    }
    v170 = v77;
    v78 = (void *)objc_msgSend(v77, "firstObject");
    v183 = 0u;
    v184 = 0u;
    v181 = 0u;
    v182 = 0u;
    v79 = objc_msgSend(v78, "countByEnumeratingWithState:objects:count:", &v181, v208, 16);
    if (!v79)
      goto LABEL_136;
    v157 = v76;
    v159 = v75;
    v161 = v74;
    obja = v72;
    v80 = *(_QWORD *)v182;
    while (2)
    {
      v81 = 0;
      while (2)
      {
        v82 = v53;
        if (*(_QWORD *)v182 != v80)
          objc_enumerationMutation(v78);
        v83 = (void *)CTFontDescriptorCopyAttribute(*(CTFontDescriptorRef *)(*((_QWORD *)&v181 + 1) + 8 * v81), CFSTR("CTFontAllowCellularDownloadAttribute"));
        LODWORD(valuePtr[0]) = -1431655766;
        v84 = v83;
        v85 = v84;
        if (!v84)
          goto LABEL_127;
        v86 = CFGetTypeID(v84);
        if (v86 == CFNumberGetTypeID() || v86 == CFBooleanGetTypeID())
        {
          CFNumberGetValue(v85, kCFNumberIntType, valuePtr);
          goto LABEL_124;
        }
        if (v86 == CFStringGetTypeID())
        {
          LODWORD(valuePtr[0]) = CFStringGetIntValue((CFStringRef)v85);
LABEL_124:
          v87 = 1;
        }
        else
        {
LABEL_127:
          v87 = 0;
        }
        v88 = (int)valuePtr[0];

        if (v87 && v88)
        {
          LODWORD(v79) = 1;
          v53 = v82;
          goto LABEL_135;
        }
        ++v81;
        v53 = v82;
        if (v79 != v81)
          continue;
        break;
      }
      v79 = objc_msgSend(v78, "countByEnumeratingWithState:objects:count:", &v181, v208, 16);
      if (v79)
        continue;
      break;
    }
LABEL_135:
    v72 = obja;
    v71 = (uint64_t)v165;
    v75 = v159;
    v74 = v161;
    v76 = v157;
LABEL_136:
    v89 = (void *)*((_QWORD *)val + 4);
    if (v78)
      objc_msgSend(v89, "setObject:forKey:", v78, CFSTR("CTFontDescriptorMatchingDescriptors"));
    else
      objc_msgSend(v89, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingDescriptors"));
    CopyValueForCurrentUser((const __CFDictionary *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v170, "objectAtIndex:", 1), "firstObject"), "objectForKey:", CFSTR("LocalizedFamilyNames")), 0, (unint64_t *)valuePtr);
    v90 = atomic_load((unint64_t *)valuePtr);

    if (v90)
    {
      objc_msgSend(*((id *)val + 4), "setObject:forKey:", v90, CFSTR("CTFontDescriptorMatchingLocalizedFamilyName"));
      v91 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", objc_msgSend(v150, "localizedStringForKey:value:table:", CFSTR("Downloading font \\U201C%@\\U201D\\U2026"), &stru_1E15EDAC0, 0), v90);
      v92 = (void *)*((_QWORD *)val + 4);
      if (v91)
        objc_msgSend(v92, "setObject:forKey:", v91, CFSTR("CTFontDescriptorMatchingLocalizedDescription"));
      else
        objc_msgSend(v92, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingLocalizedDescription"));
    }
LABEL_143:
    v93 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v72);
    v94 = (void *)*((_QWORD *)val + 4);
    if (v93)
      objc_msgSend(v94, "setObject:forKey:", v93, CFSTR("CTFontDescriptorMatchingProcessedAssetCount"));
    else
      objc_msgSend(v94, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingProcessedAssetCount"));
    objc_opt_self();
    v95 = objc_msgSend(v75, "state");
    if (v95 > 6 || ((1 << v95) & 0x6C) == 0)
    {
      v104 = (void *)objc_msgSend(v76, "objectForKey:", *v53);
      v105 = objc_msgSend(v104, "longValue");
      v106 = (void *)*((_QWORD *)val + 4);
      if (v104)
        objc_msgSend(v106, "setObject:forKey:", v104, CFSTR("CTFontDescriptorMatchingCurrentAssetSize"));
      else
        objc_msgSend(v106, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingCurrentAssetSize"));
      v107 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:", v155);
      v108 = (void *)*((_QWORD *)val + 4);
      if (v107)
        objc_msgSend(v108, "setObject:forKey:", v107, CFSTR("CTFontDescriptorMatchingTotalDownloadedSize"));
      else
        objc_msgSend(v108, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingTotalDownloadedSize"));
      v109 = v75;
      if (qword_1ECDE7E38 != -1)
        dispatch_once(&qword_1ECDE7E38, &__block_literal_global_129);
      v110 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, (dispatch_queue_t)qword_1ECDE7E40);
      v202 = (void *)MEMORY[0x1E0C809B0];
      v203 = 3221225472;
      v204 = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke;
      v205 = &unk_1E15E89F8;
      v206 = v110;
      v207 = dsema;
      v180[0] = MEMORY[0x1E0C809B0];
      v180[1] = 3221225472;
      v180[2] = (uint64_t)__57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_2;
      v180[3] = (uint64_t)&unk_1E15E8A48;
      v180[4] = (uint64_t)v109;
      v180[5] = (uint64_t)&v202;
      valuePtr[0] = (id)0xAAAAAAAAAAAAAAAALL;
      objc_initWeak(valuePtr, val);
      location[0] = (id)0xAAAAAAAAAAAAAAAALL;
      objc_initWeak(location, v110);
      *(_QWORD *)&handler = MEMORY[0x1E0C809B0];
      *((_QWORD *)&handler + 1) = 3221225472;
      *(_QWORD *)&v176 = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_4;
      *((_QWORD *)&v176 + 1) = &unk_1E15E8A70;
      objc_copyWeak((id *)&v177 + 1, valuePtr);
      objc_copyWeak(v178, location);
      *(_QWORD *)&v177 = v180;
      dispatch_source_set_event_handler(v110, &handler);
      v111 = (id)objc_msgSend(v180, "copy");
      v112 = (void *)*((_QWORD *)val + 4);
      if (v111)
        objc_msgSend(v112, "setObject:forKey:", v111, CFSTR("CTFontDescriptorMatchingCancelDownloadHandler"));
      else
        objc_msgSend(v112, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingCancelDownloadHandler"));
      v113 = -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 4);
      *((_BYTE *)v190 + 24) = v113;
      v114 = dispatch_time(0, 500000000);
      dispatch_source_set_timer(v110, v114, 0x1DCD6500uLL, 0x2FAF080uLL);
      dispatch_resume(v110);
      if (*((_BYTE *)v190 + 24))
      {
        v199[0] = MEMORY[0x1E0C809B0];
        v199[1] = 3221225472;
        v199[2] = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_5;
        v199[3] = &unk_1E15E8AC0;
        objc_copyWeak(v200, location);
        v199[4] = val;
        v199[5] = v109;
        v201 = v72;
        v200[1] = v155;
        v200[2] = v148;
        v199[7] = &v189;
        v199[6] = v180;
        objc_msgSend(v109, "attachProgressCallBack:", v199);
        gotLoadHelper_x8__OBJC_CLASS___MADownloadOptions(v115);
        v117 = objc_alloc_init(*(Class *)(v116 + 144));
        gotLoadHelper_x8__OBJC_CLASS___ASAsset(v118);
        v119 = (void *)objc_opt_class();
        v120 = 1;
        if (v119)
        {
          if ((objc_msgSend(v119, "nonUserInitiatedDownloadsAllowed") & 1) != 0
            || (MainBundle = CFBundleGetMainBundle()) != 0
            && (Identifier = CFBundleGetIdentifier(MainBundle)) != 0
            && CFStringHasPrefix(Identifier, CFSTR("com.apple.")))
          {
            v120 = 0;
          }
        }
        objc_msgSend(v117, "setDiscretionary:", v120);
        if ((_DWORD)v79)
        {
          CFLog();
          objc_msgSend(v117, "setAllowsCellularAccess:", 1);
        }
        v179[0] = MEMORY[0x1E0C809B0];
        v179[1] = 3221225472;
        v179[2] = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_7;
        v179[3] = &unk_1E15E8A20;
        v179[4] = &v202;
        objc_msgSend(v109, "startDownload:then:", v117, v179);

        dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
        v155 += v105;
        v123 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:");
        v124 = (void *)*((_QWORD *)val + 4);
        if (v123)
          objc_msgSend(v124, "setObject:forKey:", v123, CFSTR("CTFontDescriptorMatchingTotalDownloadedSize"));
        else
          objc_msgSend(v124, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingTotalDownloadedSize"));
        v125 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:", (uint64_t)(((double)(int)v72 + 1.0) / (double)(unint64_t)v148 * 100.0));
        v126 = (void *)*((_QWORD *)val + 4);
        if (v125)
          objc_msgSend(v126, "setObject:forKey:", v125, CFSTR("CTFontDescriptorMatchingPercentage"));
        else
          objc_msgSend(v126, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingPercentage"));
        objc_destroyWeak(v200);
      }
      else
      {
        dispatch_source_cancel(v110);
      }
      dispatch_release(v110);
      objc_destroyWeak(v178);
      objc_destroyWeak((id *)&v177 + 1);
      objc_destroyWeak(location);
      objc_destroyWeak(valuePtr);
      v75 = v109;
    }
    v96 = objc_msgSend(v75, "getLocalFileUrl");
    if (v96)
    {
      objc_opt_self();
      v97 = (void *)objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
      v98 = (void *)objc_msgSend(v97, "enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:", v96, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObject:", v73), 0, &__block_literal_global_101);
      v197 = 0u;
      v198 = 0u;
      *(_OWORD *)location = 0u;
      v196 = 0u;
      v99 = objc_msgSend(v98, "countByEnumeratingWithState:objects:count:", location, valuePtr, 16);
      if (v99)
      {
        v100 = *(_QWORD *)v196;
        do
        {
          for (m = 0; m != v99; ++m)
          {
            if (*(_QWORD *)v196 != v100)
              objc_enumerationMutation(v98);
            v102 = (void *)*((_QWORD *)location[1] + m);
            v194 = 0;
            if ((!objc_msgSend(v102, "getResourceValue:forKey:error:", &v194, v73, 0, v146, v147)
               || (objc_msgSend(v194, "BOOLValue") & 1) == 0)
              && (FSFontProviderSynchronizeFontAsset() & 1) == 0)
            {
              v193 = 0;
              if (!_CTFontManagerRegisterActionFontsForURL(v102, 1, 1, &v193))
              {
                v146 = v102;
                v147 = v193;
                CFLog();
              }

            }
          }
          v99 = objc_msgSend(v98, "countByEnumeratingWithState:objects:count:", location, valuePtr, 16);
        }
        while (v99);
      }
      v71 = (uint64_t)v165;
    }
    objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingCancelDownloadHandler"), v146);
    v103 = -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 6) && *((_BYTE *)v190 + 24) != 0;
    *((_BYTE *)v190 + 24) = v103;
    objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingError"));
    objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingTotalDownloadedSize"));
    objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingPercentage"));
    objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingCurrentAssetSize"));
    if (*((_BYTE *)v190 + 24))
    {
      objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingDescriptors"));
      v72 = (v72 + 1);
      if (++v74 != v71)
        continue;
      v127 = objc_msgSend(v168, "countByEnumeratingWithState:objects:count:", &v185, &v209, 16);
      v71 = v127;
      if (!v127)
        break;
      goto LABEL_111;
    }
    break;
  }
LABEL_200:
  dispatch_release(dsema);
  _Block_object_dispose(&v189, 8);
LABEL_201:
  v128 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v129 = (const __CFArray *)atomic_load((unint64_t *)val + 1);
  if (v129)
  {
    v130 = CFArrayGetCount(v129);
    if (v130)
    {
      v131 = v130;
      v132 = 0;
      while (1)
      {
        v133 = CFArrayGetValueAtIndex(v129, v132);
        v134 = (const __CFSet *)atomic_load((unint64_t *)val + 2);
        v135 = (void *)CTFontDescriptorCreateMatchingFontDescriptorsWithOptions((uint64_t)v133, v134, 513);
        v136 = v135;
        v137 = v136;
        if (!v136)
          break;
        v138 = CFArrayGetCount(v136);

        if (v138 < 1)
        {
LABEL_209:

          if (++v132 == v131)
            goto LABEL_219;
        }
        else
        {
          v139 = (void *)*((_QWORD *)val + 4);
          if (v133)
            objc_msgSend(v139, "setObject:forKey:", v133, CFSTR("CTFontDescriptorMatchingSourceDescriptor"));
          else
            objc_msgSend(v139, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingSourceDescriptor"));
          v140 = (void *)*((_QWORD *)val + 4);
          if (v135)
            objc_msgSend(v140, "setObject:forKey:", v135, CFSTR("CTFontDescriptorMatchingResult"));
          else
            objc_msgSend(v140, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingResult"));
          v141 = -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 7);
          objc_msgSend(v128, "addObjectsFromArray:", v135);

          if (++v132 == v131 || !v141)
            goto LABEL_219;
        }
      }

      goto LABEL_209;
    }
  }
LABEL_219:
  objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingSourceDescriptor"));
  objc_msgSend(*((id *)val + 4), "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingResult"));
  v143 = (void *)*((_QWORD *)val + 4);
  if (v128)
    objc_msgSend(v143, "setObject:forKey:", v128, CFSTR("CTFontDescriptorMatchingResult"));
  else
    objc_msgSend(v143, "removeObjectForKey:", CFSTR("CTFontDescriptorMatchingResult"));
  v4 = v149;
  v3 = (uint64_t)val;
LABEL_223:
  -[FontAssetDownloadManager callProgressCallback:](v3, 1);
  v144 = *(void **)(v4 + 32);
LABEL_224:

  objc_autoreleasePoolPop(context);
}

void sub_18491E4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location, uint64_t a15, uint64_t a16, id *a17, id *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a67;

  _Block_object_dispose(&a67, 8);
  _Unwind_Resume(a1);
}

BOOL CharacterSequence::IsProhibitedAfterAdding(CharacterSequence *this, int a2)
{
  uint64_t v2;
  _BOOL8 result;
  BOOL v5;

  v2 = *((_QWORD *)this + 2);
  result = 0;
  if (v2 != 3)
  {
    *((_QWORD *)this + 2) = v2 + 1;
    *((_DWORD *)this + v2) = a2;
    if ((unint64_t)(v2 + 1) >= 2)
    {
      v5 = 0;
      if (IsProhibitedSequence(*(_DWORD *)this, *((_DWORD *)this + 1), &v5)
        || v5
        && *((_QWORD *)this + 2) >= 3uLL
        && *(_DWORD *)this == 2352
        && *((_DWORD *)this + 1) == 2381
        && *((_DWORD *)this + 2) == 2311)
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t UniversalShapingEngine::ApplyScriptShaping(UniversalShapingEngine *this, const OTL::GSUB *a2, OTL::GlyphLookups *a3)
{
  int64_t i;
  uint64_t v4;
  unsigned __int16 **v5;
  unsigned __int16 **v6;
  OTL::GSUB *v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  uint64_t *v11;
  TRunGlue *v12;
  uint64_t v13;
  unint64_t v14;
  TRunGlue *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int FullChar;
  int CharClass;
  uint64_t v22;
  TRunGlue *v23;
  int *v24;
  uint64_t v25;
  int64_t j;
  uint64_t v27;
  TRunGlue *v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  int64_t v33;
  int64_t v34;
  uint64_t v35;
  uint64_t v36;
  int64_t v37;
  int64_t v38;
  uint64_t v39;
  uint64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  TRunGlue *v44;
  uint64_t v45;
  int v46;
  UChar32 v47;
  int8_t v48;
  int64_t v49;
  TRunGlue *v50;
  _BOOL4 IsProhibitedAfterAdding;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unsigned __int8 *v63;
  int v64;
  int64_t v65;
  int *v66;
  int v67;
  BOOL v68;
  uint64_t v69;
  int64_t v70;
  int *v71;
  int v72;
  BOOL v73;
  int v75;
  char v77;
  int64_t v78;
  int v79;
  uint64_t v80;
  unsigned __int8 *v81;
  int v82;
  int64_t v83;
  uint64_t v84;
  int64_t v85;
  int *v86;
  int v87;
  BOOL v88;
  uint64_t v89;
  int *v90;
  int v91;
  BOOL v92;
  int64_t v93;
  int *v94;
  int v95;
  BOOL v96;
  int *v97;
  int v98;
  BOOL v99;
  int64_t v100;
  int *v101;
  int v102;
  BOOL v103;
  int64_t v104;
  int *v105;
  int v106;
  BOOL v107;
  int64_t v108;
  int *v109;
  int v110;
  BOOL v111;
  int64_t v112;
  int *v113;
  int v114;
  BOOL v115;
  int64_t v116;
  unsigned __int8 *v117;
  int v118;
  int64_t v119;
  int64_t v120;
  int *v121;
  int v122;
  BOOL v123;
  int64_t v124;
  int *v125;
  int v126;
  BOOL v127;
  int64_t v128;
  int *v129;
  int v130;
  BOOL v131;
  int64_t v132;
  int *v133;
  int v134;
  BOOL v135;
  int64_t v136;
  int *v137;
  int v138;
  BOOL v139;
  int64_t v140;
  int *v141;
  int v142;
  BOOL v143;
  int64_t v144;
  int *v145;
  int v146;
  BOOL v147;
  uint64_t v148;
  uint64_t v149;
  unsigned __int8 *v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  int v154;
  unsigned __int8 *v155;
  int v156;
  int64_t v157;
  int *v158;
  int v159;
  BOOL v160;
  int *v161;
  int *v162;
  int64_t v163;
  int v164;
  BOOL v165;
  int v166;
  BOOL v167;
  int64_t v168;
  int *v169;
  int v170;
  BOOL v171;
  uint64_t v172;
  int64_t v173;
  int *v174;
  int v175;
  BOOL v176;
  uint64_t v177;
  int64_t v178;
  int *v179;
  int v180;
  BOOL v181;
  int v182;
  int v183;
  int v184;
  TRunGlue *v185;
  int8_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  int64_t v194;
  int v195;
  int v196;
  int64_t v197;
  int *v198;
  int v199;
  BOOL v200;
  int64_t v201;
  uint64_t v202;
  uint64_t v203;
  unsigned __int8 *v204;
  int v205;
  uint64_t v206;
  uint64_t v207;
  int64_t v208;
  int *v209;
  int v210;
  BOOL v211;
  int64_t v212;
  uint64_t v213;
  int v214;
  uint64_t v215;
  uint64_t v216;
  unsigned __int8 *v217;
  unsigned __int8 *v218;
  int v219;
  uint64_t v220;
  uint64_t v221;
  int v222;
  int64_t v223;
  int *v224;
  int v225;
  BOOL v226;
  uint64_t v227;
  int64_t v228;
  int *v229;
  int v230;
  BOOL v231;
  int v232;
  int64_t v233;
  int64_t v234;
  unsigned __int8 *v235;
  int v236;
  int64_t v237;
  int64_t v238;
  unsigned __int8 *v239;
  int v240;
  int64_t v241;
  uint64_t v242;
  unsigned __int8 *v243;
  int v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  unsigned __int8 *v248;
  int v249;
  uint64_t v250;
  uint64_t v251;
  unsigned __int8 *v252;
  int v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  unsigned __int8 *v257;
  unsigned __int8 *v258;
  int v259;
  uint64_t v260;
  int64_t v261;
  uint64_t v262;
  int v263;
  uint64_t v264;
  uint64_t v265;
  unsigned __int8 *v266;
  int v267;
  uint64_t v268;
  uint64_t v269;
  unsigned __int8 *v270;
  int v271;
  uint64_t v272;
  uint64_t v273;
  unsigned __int8 *v274;
  int v275;
  uint64_t v276;
  _QWORD *v277;
  uint64_t v278;
  int *v279;
  unint64_t v280;
  int64_t *v281;
  int64_t *p_location;
  uint64_t v283;
  int64_t v284;
  int v285;
  unsigned __int16 v286;
  uint64_t v287;
  uint64_t v288;
  char v289;
  CFRange *v290;
  CFRange *v291;
  CFRange *v292;
  uint64_t length;
  CFRange *v294;
  CFIndex location;
  CFRange *v296;
  uint64_t v297;
  int64_t v298;
  _QWORD *v299;
  UniversalClassTable *v300;
  int v301;
  __int128 v302;
  uint64_t v303;
  unsigned __int16 *v304;
  unsigned int *v305;
  unsigned int *v306;
  unsigned int v307;
  BOOL v308;
  unsigned __int16 *v309;
  unsigned __int16 *v311;
  unsigned __int16 v312;
  int64_t v313;
  CFRange *v314;
  CFRange *v315;
  CFRange *v316;
  int64_t v317;
  CFRange *v318;
  CFIndex v319;
  CFRange *v320;
  uint64_t v321;
  unsigned int *v322;
  uint64_t v323;
  unsigned int v324;
  __int128 v325;
  _DWORD *v326;
  CFRange *v327;
  CFRange *v328;
  unsigned int *v329;
  unsigned int *v330;
  uint64_t v331;
  unsigned int v332;
  __int128 v333;
  CFRange *v334;
  CFRange *v335;
  uint64_t v336;
  uint64_t v337;
  unsigned int *v339;
  uint64_t v340;
  unsigned int v341;
  __int128 v342;
  CFRange *v343;
  CFRange *v344;
  unsigned int *v345;
  unsigned int *v346;
  uint64_t v347;
  uint64_t v348;
  unsigned int v349;
  __int128 v350;
  CFRange *v351;
  CFRange *v352;
  unsigned int *v353;
  unsigned int *v354;
  uint64_t v355;
  uint64_t v356;
  unsigned int v357;
  uint64_t *v358;
  _QWORD *v359;
  CFRange *v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  int v372;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  int v386;
  int v387;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  int v392;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  CFRange *v400;
  CFRange *v401;
  uint64_t v402;
  uint64_t v403;
  char v404;
  unsigned __int16 **v406;
  uint64_t v407;
  OTL::GSUB *v408;
  int64_t v409;
  uint64_t v410;
  int64_t v411;
  uint64_t v412;
  int64_t v413;
  uint64_t v414;
  uint64_t v415;
  int v416;
  int64_t v417;
  uint64_t v418;
  int v419;
  UChar32 c;
  char v421;
  uint64_t v422;
  CFRange *v423;
  int v424;
  uint64_t v425;
  char v426;
  _QWORD *v427;
  int64_t v428;
  uint64_t StringIndex;
  __int128 v430;
  __int128 v431;
  __int128 v432;
  __int128 v433;
  __int128 v434;
  __int128 v435;
  __int128 v436;
  __int128 v437;
  __int128 v438;
  __int128 v439;
  __int128 v440;
  uint64_t v441;
  unsigned __int8 v442;
  _BYTE v443[28];
  int v444[3];
  unsigned __int16 *v445;
  __int128 v446;
  _OWORD v447[195];
  _OWORD *v448;
  unsigned int v449[2];
  unint64_t v450;
  uint64_t v451;
  __int128 v452;
  __int128 v453;
  __int128 v454;
  __int128 v455;
  __int128 v456;
  __int128 v457;
  __int128 v458;
  unint64_t v459;
  __int128 *v460;
  unsigned __int16 v461[16];
  uint64_t v462[3];
  _QWORD v463[3];
  _QWORD *v464;
  void *__p;
  CFRange *v466;
  uint64_t v467;
  _BYTE v468[1200];
  _QWORD v469[4];

  v4 = MEMORY[0x1E0C80A78](this, a2);
  v6 = v5;
  v408 = v7;
  v428 = v4;
  v469[1] = *MEMORY[0x1E0C80C00];
  v442 = 0;
  v9 = *v5;
  v8 = v5[1];
  if (v8 != *v5)
  {
    do
    {
      v10 = v8 - 52;
      v445 = v8 - 48;
      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v445);
      v8 = v10;
    }
    while (v10 != v9);
  }
  v406 = v6;
  v6[1] = v9;
  v11 = (uint64_t *)v428;
  v442 |= TRunGlue::FilterSurrogates(*(TRunGlue **)(v428 + 8), *(_QWORD *)v428, 0);
  v12 = *(TRunGlue **)(v428 + 8);
  v13 = *((_QWORD *)v12 + 13);
  v14 = TRunGlue::length(v12);
  v427 = (_QWORD *)v13;
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::resize(v13, v14);
  memset(v468, 170, sizeof(v468));
  __p = 0;
  v466 = 0;
  v467 = 0;
  v469[0] = v468;
  v463[0] = &off_1E15E05B0;
  v463[1] = &__p;
  v464 = v463;
  v446 = 0u;
  memset(v447, 0, 168);
  v15 = *(TRunGlue **)(v428 + 8);
  v16 = *(_QWORD *)(*(_QWORD *)v428 + 16);
  v445 = *(unsigned __int16 **)v428;
  *(_QWORD *)&v447[9] = v16;
  v17 = TRunGlue::length(v15);
  if (v17)
  {
    v18 = v17;
    v19 = 0;
    for (i = 0; i != v18; ++i)
    {
      StringIndex = TRunGlue::GetStringIndex(v15, i);
      FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v445, &StringIndex, 0);
      CharClass = UniversalClassTable::getCharClass(*(UniversalClassTable **)(v428 + 16), FullChar);
      v22 = **((_QWORD **)v15 + 13) + v19;
      *(_DWORD *)(v22 + 8) = CharClass;
      *(_DWORD *)(v22 + 12) = 0;
      v19 += 16;
    }
  }
  v23 = *(TRunGlue **)(v428 + 8);
  TRunGlue::length(v23);
  v24 = *(int **)(v428 + 8);
  v25 = v24[6];
  if ((v25 & 0x80000000) != 0)
  {
    v23 = *(TRunGlue **)(v428 + 8);
    j = TRunGlue::length((TRunGlue *)v24) - 1;
    v24 = *(int **)(v428 + 8);
  }
  else
  {
    j = 0;
  }
  v27 = TRunGlue::length((TRunGlue *)v24);
  if (v27 >= 1)
  {
    v28 = v23;
    v29 = 16 * v25;
    v412 = -v25;
    v407 = 2 * v25;
LABEL_11:
    v419 = 0;
    v30 = 0;
    v31 = 0;
    v415 = v27;
    v32 = 31;
    if ((unint64_t)v27 < 0x1F)
      v32 = v27;
    v410 = v32 * v25;
    v33 = v32 * v25 + j;
    *(_QWORD *)v449 = 0;
    v450 = 0xAAAAAAAA00000000;
    v451 = 0;
    v34 = -v33;
    v35 = v25 - v33;
    v413 = v25 - j + v412 * v32;
    v414 = v25 - v33;
    v36 = v32 - 1;
    v411 = v412 * v36 - j;
    v409 = j + v25 * v36;
    v37 = j;
    v417 = -v33;
    v418 = j;
LABEL_14:
    while (2)
    {
      v38 = v37;
      v416 = v30;
LABEL_15:
      v424 = v31;
      v39 = 0;
      v422 = v35 + v38;
      v40 = (16 * v38) | 8;
      v41 = v34 + v38;
      v42 = v38;
      v43 = (16 * (v25 + v38)) | 8;
      while (1)
      {
        if (!(v41 + v39))
          goto LABEL_420;
        v44 = v28;
        *(_QWORD *)v443 = TRunGlue::GetStringIndex(v28, v38 + v39);
        c = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v445, (uint64_t *)v443, 0);
        if (CharacterSequence::IsProhibitedAfterAdding((CharacterSequence *)v449, c))
        {
          v202 = v418;
          v33 = v418 + v25;
          v28 = v44;
          goto LABEL_421;
        }
        v45 = **((_QWORD **)v44 + 13);
        v46 = *(_DWORD *)(v45 + v40);
        v28 = v44;
        if (v46 != 12)
          break;
        if (!v424)
        {
          v31 = 0;
          v75 = v419;
          LOBYTE(v30) = v416;
          goto LABEL_145;
        }
        if (!(v422 + v39))
          goto LABEL_420;
        v42 += v25;
        *(_QWORD *)v443 = TRunGlue::GetStringIndex(v44, v25 + v38 + v39);
        v47 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v445, (uint64_t *)v443, 0);
        v48 = u_charType(v47);
        v28 = v44;
        v39 += v25;
        v40 += v29;
        v43 += v29;
        if (((1 << v48) & 0x140) == 0)
        {
          v33 = v38 + v39;
          goto LABEL_420;
        }
      }
      v31 = v424;
      switch(*(_DWORD *)(v45 + v40))
      {
        case 1u:
          v75 = v419;
          v30 = v416;
          if (v424)
            goto LABEL_85;
          v35 = v25 - v33;
          if (!(v414 + v38 + v39))
            goto LABEL_336;
          v37 = v25 + v38 + v39;
          v153 = **((_QWORD **)v44 + 13);
          while (1)
          {
            v154 = *(unsigned __int8 *)(v153 + v43);
            if (v154 != 21)
              break;
            v153 += v29;
            v39 += v25;
            if (v33 - (v25 + v38) == v39)
              goto LABEL_339;
          }
          if (v154 == 22)
            v37 = v407 + v38 + v39;
LABEL_339:
          v34 = -v33;
          if (v37 != v33)
          {
            while (2)
            {
              v157 = v25 + v37;
              v158 = (int *)(v45 + 8 + 16 * v37);
              while (1)
              {
                v159 = *v158;
                if ((*v158 & 0x2FF) == 0x208)
                  break;
                v158 = (int *)((char *)v158 + v29);
                v160 = v159 != 21 || v33 == v157;
                v157 += v25;
                if (v160)
                {
                  if (v37 != v33)
                  {
                    v172 = v45 + 8;
                    do
                    {
                      v173 = v25 + v37;
                      v174 = (int *)(v172 + 16 * v37);
                      while (1)
                      {
                        v175 = *v174;
                        if ((*v174 & 0x4FF) == 0x408)
                          break;
                        v174 = (int *)((char *)v174 + v29);
                        v176 = v175 != 21 || v33 == v173;
                        v173 += v25;
                        if (v176)
                          goto LABEL_402;
                      }
                      v37 = v173;
                    }
                    while (v33 != v173);
                  }
                  goto LABEL_378;
                }
              }
              v37 = v157;
              if (v33 != v157)
                continue;
              break;
            }
          }
          goto LABEL_378;
        case 2u:
          goto LABEL_101;
        case 4u:
          v75 = v419;
          v30 = v416;
          if (v424)
          {
LABEL_85:
            v49 = v38 + v39;
            goto LABEL_147;
          }
          v35 = v25 - v33;
          if (!(v414 + v38 + v39))
          {
LABEL_336:
            v419 = 1;
            v37 = v33;
            v31 = 1;
            v34 = -v33;
            continue;
          }
          v37 = v25 + v38 + v39;
          v155 = (unsigned __int8 *)(v45 + v43);
          while (1)
          {
            v156 = *v155;
            if (v156 != 21)
              break;
            v155 += v29;
            v39 += v25;
            if (v33 - (v25 + v38) == v39)
              goto LABEL_352;
          }
          if (v156 == 22)
            v37 = v407 + v38 + v39;
LABEL_352:
          v34 = -v33;
          if (v37 == v33)
            goto LABEL_378;
          v161 = (int *)(v45 + 16 * v37 + 8);
          v162 = v161;
          v163 = v37;
          while (1)
          {
            v164 = *v162;
            if ((*v162 & 0x2FF) == 0x211)
              break;
            v162 = (int *)((char *)v162 + v29);
            v165 = v164 != 21 || v409 == v163;
            v163 += v25;
            if (v165)
            {
              v163 = v37;
              do
              {
                v166 = *v161;
                if ((*v161 & 0x4FF) == 0x411)
                  goto LABEL_446;
                v161 = (int *)((char *)v161 + v29);
                v167 = v166 != 21 || v409 == v163;
                v163 += v25;
              }
              while (!v167);
              while (2)
              {
                v168 = v25 + v37;
                v169 = (int *)(v45 + 8 + 16 * v37);
                while (1)
                {
                  v170 = *v169;
                  if ((*v169 & 0x2FF) == 0x208)
                    break;
                  v169 = (int *)((char *)v169 + v29);
                  v171 = v170 != 21 || v33 == v168;
                  v168 += v25;
                  if (v171)
                  {
                    if (v37 != v33)
                    {
                      v177 = v45 + 8;
                      while (2)
                      {
                        v178 = v25 + v37;
                        v179 = (int *)(v177 + 16 * v37);
                        while (1)
                        {
                          v180 = *v179;
                          if ((*v179 & 0x4FF) == 0x408)
                            break;
                          v179 = (int *)((char *)v179 + v29);
                          v181 = v180 != 21 || v33 == v178;
                          v178 += v25;
                          if (v181)
                          {
LABEL_402:
                            v419 = 1;
                            v31 = 1;
                            goto LABEL_14;
                          }
                        }
                        v37 = v178;
                        if (v33 != v178)
                          continue;
                        break;
                      }
                    }
                    goto LABEL_378;
                  }
                }
                v37 = v168;
                if (v33 != v168)
                  continue;
                break;
              }
LABEL_378:
              v419 = 1;
              v37 = v33;
              v31 = 1;
              goto LABEL_14;
            }
          }
LABEL_446:
          if (v163 != v33)
          {
            while (2)
            {
              v197 = v25 + v163;
              v198 = (int *)(v45 + 8 + 16 * v163);
              while (1)
              {
                v199 = *v198;
                if ((*v198 & 0x2FF) == 0x211)
                  break;
                v198 = (int *)((char *)v198 + v29);
                v200 = v199 != 21 || v33 == v197;
                v197 += v25;
                if (v200)
                {
                  if (v163 != v33)
                  {
                    v207 = v45 + 8;
                    do
                    {
                      v208 = v25 + v163;
                      v209 = (int *)(v207 + 16 * v163);
                      while (1)
                      {
                        v210 = *v209;
                        if ((*v209 & 0x4FF) == 0x411)
                          break;
                        v209 = (int *)((char *)v209 + v29);
                        v211 = v210 != 21 || v33 == v208;
                        v208 += v25;
                        if (v211)
                        {
                          v419 = 4;
                          v33 = v163;
                          goto LABEL_420;
                        }
                      }
                      v163 = v208;
                    }
                    while (v33 != v208);
                  }
                  goto LABEL_508;
                }
              }
              v163 = v197;
              if (v33 != v197)
                continue;
              break;
            }
          }
LABEL_508:
          v183 = 4;
          goto LABEL_415;
        case 9u:
        case 0xAu:
          v49 = v38 + v39;
          LOBYTE(v30) = v416;
          if (v424 != 1)
          {
            v38 += v39;
            v75 = v419;
            goto LABEL_145;
          }
          if (v414 + v38 + v39)
          {
            v50 = v28;
            *(_QWORD *)v443 = TRunGlue::GetStringIndex(v28, v25 + v38 + v39);
            c = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v445, (uint64_t *)v443, 0);
            IsProhibitedAfterAdding = CharacterSequence::IsProhibitedAfterAdding((CharacterSequence *)v449, c);
            v28 = v50;
            LOBYTE(v30) = v416;
            if (IsProhibitedAfterAdding)
            {
              v33 = v25 + v38 + v39;
              goto LABEL_420;
            }
          }
          v52 = 0;
          v53 = 0;
          LODWORD(v54) = 0;
          while (2)
          {
            while (2)
            {
              v55 = v49;
LABEL_29:
              v56 = 0;
              v57 = v54;
              v58 = 16 * v55;
              v59 = (16 * (v25 + v55)) | 8;
              v54 = v52;
              while (1)
              {
                v52 = v54;
                if (v33 == v49)
                  goto LABEL_67;
                v60 = **((_QWORD **)v28 + 13);
                v61 = *(unsigned __int8 *)(v60 + v58 + 8);
                if (v61 != 13)
                  break;
                if (!(v413 + v49))
                  goto LABEL_67;
                v49 += v25;
                v62 = *(unsigned __int8 *)(v60 + ((16 * v25) | 8) + v58);
                v58 += v29;
                v56 += v25;
                v59 += v29;
                v54 = 1;
                if ((v57 & (v62 != 13)) == 0)
                {
                  v55 = v49;
                  if (v62 == 13)
                    goto LABEL_68;
                  goto LABEL_29;
                }
              }
              switch(v61)
              {
                case 1:
                  if (!(v53 & 1 | ((v57 & 1) == 0)))
                  {
                    if (!(v413 + v49))
                      goto LABEL_66;
                    v49 += v25;
                    v63 = (unsigned __int8 *)(v60 + v59);
                    while (1)
                    {
                      v64 = *v63;
                      if (v64 != 21)
                        break;
                      v63 += v29;
                      v56 += v25;
                      if (v33 - (v25 + v55) == v56)
                        goto LABEL_54;
                    }
                    if (v64 == 22)
                      v49 = v407 + v55 + v56;
LABEL_54:
                    if (v49 == v33)
                    {
LABEL_66:
                      LOBYTE(v52) = 0;
                      v53 = 1;
                    }
                    else
                    {
LABEL_55:
                      v65 = v25 + v49;
                      v66 = (int *)(v60 + 8 + 16 * v49);
                      do
                      {
                        v67 = *v66;
                        if ((*v66 & 0x2FF) == 0x208)
                        {
                          v53 = 1;
                          v49 = v65;
                          if (v33 != v65)
                            goto LABEL_55;
                          goto LABEL_81;
                        }
                        v66 = (int *)((char *)v66 + v29);
                        v68 = v67 != 21 || v33 == v65;
                        v65 += v25;
                      }
                      while (!v68);
                      if (v49 == v33)
                        goto LABEL_66;
                      v69 = v60 + 8;
                      do
                      {
                        v70 = v25 + v49;
                        v71 = (int *)(v69 + 16 * v49);
                        while (1)
                        {
                          v72 = *v71;
                          if ((*v71 & 0x4FF) == 0x408)
                            break;
                          v71 = (int *)((char *)v71 + v29);
                          v73 = v72 != 21 || v33 == v70;
                          v70 += v25;
                          v53 = 1;
                          if (v73)
                          {
                            LOBYTE(v52) = 0;
                            goto LABEL_68;
                          }
                        }
                        v53 = 1;
                        v49 = v70;
                      }
                      while (v33 != v70);
LABEL_81:
                      LOBYTE(v52) = 0;
                    }
LABEL_67:
                    v49 = v33;
                  }
                  break;
                case 8:
                  if ((v53 & v57 & 1) != 0)
                    goto LABEL_50;
                  break;
                case 10:
                  if (((v53 | v57) & 1) != 0)
                    break;
                  v53 = 0;
LABEL_51:
                  v49 += v25;
                  LODWORD(v54) = 1;
                  continue;
                default:
                  if ((v53 | v57) & 1 | (v61 != 9))
                    goto LABEL_68;
LABEL_50:
                  v53 = 1;
                  goto LABEL_51;
              }
              break;
            }
LABEL_68:
            if ((v57 & v53 & 1) != 0)
            {
              v52 = 0;
              v53 = 0;
              LODWORD(v54) = 0;
              if (v49 == v33)
              {
                v31 = 2;
                v49 = v33;
                v75 = v419;
                goto LABEL_147;
              }
              continue;
            }
            break;
          }
          v75 = v419;
          if (!(_BYTE)v52)
          {
            v31 = 2;
            goto LABEL_147;
          }
          v33 = v49;
          goto LABEL_420;
        case 0xDu:
          v38 += v39;
          v34 = -v33;
          v75 = v419;
          LOBYTE(v30) = v416;
          goto LABEL_140;
        case 0xFu:
          LOBYTE(v30) = v416;
          v75 = v419;
          if ((v424 != 0) | v416 & 1)
            goto LABEL_102;
          v31 = 0;
          v30 = 1;
          v75 = 6;
          goto LABEL_335;
        case 0x14u:
          LOBYTE(v30) = v416;
          v38 += v39;
          v75 = v419;
          if ((v424 != 0) | v416 & 1)
            goto LABEL_145;
          v31 = 0;
          v30 = 1;
          v42 = v38;
          goto LABEL_335;
        default:
          if (c != 8288 && v46 && v46 != 14)
          {
            v49 = v38 + v39;
            v75 = v419;
            v30 = v416;
            switch((char)v46)
            {
              case 16:
                if (v424)
                  goto LABEL_147;
                v212 = v25 + v38 + v39;
                if (v212 == v33)
                  goto LABEL_508;
                v213 = v45;
                while (1)
                {
                  v214 = *(unsigned __int8 *)(v213 + v43);
                  if (v214 != 21)
                    break;
                  v213 += v29;
                  v39 += v25;
                  if (v418 + v410 - (v25 + v38) == v39)
                    goto LABEL_496;
                }
                if (v214 == 22)
                  v212 = v407 + v38 + v39;
LABEL_496:
                if (v212 != v33)
                {
                  while (2)
                  {
                    v223 = v25 + v212;
                    v224 = (int *)(v45 + 8 + 16 * v212);
                    while (1)
                    {
                      v225 = *v224;
                      if ((*v224 & 0x2FF) == 0x211)
                        break;
                      v224 = (int *)((char *)v224 + v29);
                      v226 = v225 != 21 || v33 == v223;
                      v223 += v25;
                      if (v226)
                      {
                        if (v212 != v33)
                        {
                          v227 = v45 + 8;
                          do
                          {
                            v228 = v25 + v212;
                            v229 = (int *)(v227 + 16 * v212);
                            while (1)
                            {
                              v230 = *v229;
                              if ((*v229 & 0x4FF) == 0x411)
                                break;
                              v229 = (int *)((char *)v229 + v29);
                              v231 = v230 != 21 || v33 == v228;
                              v228 += v25;
                              if (v231)
                              {
                                v232 = 4;
                                goto LABEL_520;
                              }
                            }
                            v212 = v228;
                          }
                          while (v33 != v228);
                        }
                        goto LABEL_508;
                      }
                    }
                    v212 = v223;
                    if (v33 != v223)
                      continue;
                    break;
                  }
                }
                goto LABEL_508;
              case 17:
              case 18:
              case 19:
              case 20:
              case 22:
              case 24:
                v38 += v39;
                goto LABEL_145;
              case 21:
                goto LABEL_335;
              case 23:
              case 25:
                if (v424)
                  goto LABEL_147;
                v201 = v38 + v39;
                v202 = v418;
                while (2)
                {
                  v203 = 0;
                  v204 = (unsigned __int8 *)(v45 + 8 + 16 * v201);
                  while (1)
                  {
                    v205 = *v204;
                    if (v205 != 21)
                      break;
                    v204 += v29;
                    v203 -= v25;
                    if (v201 - v33 == v203)
                      goto LABEL_464;
                  }
                  if (v205 == 25)
                  {
                    v206 = v25 + v201;
                    v201 = v25 + v201 - v203;
                    if (v206 - v33 != v203)
                      continue;
                  }
                  else
                  {
LABEL_464:
                    if (v201 != v33)
                    {
                      v215 = 0;
                      v216 = 0;
                      v217 = (unsigned __int8 *)(v45 + 8 + 16 * v201);
                      v218 = (unsigned __int8 *)(v45 + 8 + 16 * (v25 + v201));
                      while (1)
                      {
                        v219 = *v217;
                        if (v219 != 21)
                          break;
                        v217 += v29;
                        v216 -= v25;
                        v215 += v25;
                        v218 += v29;
                        if (v201 - v33 == v216)
                          goto LABEL_493;
                      }
                      if (v219 != 23)
                      {
LABEL_493:
                        v419 = 5;
                        v33 = v201;
                        goto LABEL_421;
                      }
                      v220 = v25 + v201;
                      if (v25 + v201 - v33 != v216)
                      {
                        v212 = v220 - v216;
                        v221 = v418 + v410 - v220;
                        while (1)
                        {
                          v222 = *v218;
                          if (v222 != 21)
                            break;
                          v218 += v29;
                          v215 += v25;
                          if (v221 == v215)
                            goto LABEL_523;
                        }
                        v233 = v407 + v201 + v215;
                        if (v222 == 22)
                          v212 = v233;
LABEL_523:
                        if (v212 != v33)
                        {
                          v234 = -v212;
                          v235 = (unsigned __int8 *)(v45 + 16 * v212 + 8);
                          while (1)
                          {
                            v236 = *v235;
                            if (v236 != 21)
                              break;
                            v235 += v29;
                            v234 -= v25;
                            if (v417 == v234)
                              goto LABEL_530;
                          }
                          v237 = v25 - v234;
                          if (v236 == 28)
                            v212 = v237;
LABEL_530:
                          if (v212 != v33)
                          {
                            v238 = -v212;
                            v239 = (unsigned __int8 *)(v45 + 16 * v212 + 8);
                            while (1)
                            {
                              v240 = *v239;
                              if (v240 != 21)
                                break;
                              v239 += v29;
                              v238 -= v25;
                              if (v417 == v238)
                                goto LABEL_537;
                            }
                            v241 = v25 - v238;
                            if (v240 == 27)
                              v212 = v241;
LABEL_537:
                            if (v212 != v33)
                            {
                              while (2)
                              {
                                v242 = 0;
                                v243 = (unsigned __int8 *)(v45 + 8 + 16 * v212);
                                while (1)
                                {
                                  v244 = *v243;
                                  if (v244 != 21)
                                    break;
                                  v243 += v29;
                                  v242 -= v25;
                                  if (v212 - v33 == v242)
                                    goto LABEL_545;
                                }
                                if (v244 == 26)
                                {
                                  v245 = v25 + v212;
                                  v212 = v25 + v212 - v242;
                                  v419 = 5;
                                  if (v245 - v33 != v242)
                                    continue;
                                  goto LABEL_420;
                                }
                                break;
                              }
LABEL_545:
                              if (v212 == v33)
                              {
LABEL_546:
                                v183 = 5;
                                goto LABEL_415;
                              }
                              v246 = v45 + 8;
                              while (2)
                              {
                                v247 = 0;
                                v248 = (unsigned __int8 *)(v246 + 16 * v212);
                                while (1)
                                {
                                  v249 = *v248;
                                  if (v249 != 21)
                                    break;
                                  v248 += v29;
                                  v247 -= v25;
                                  if (v212 - v33 == v247)
                                    goto LABEL_600;
                                }
                                if (v249 != 24)
                                {
LABEL_600:
                                  v232 = 5;
LABEL_520:
                                  v419 = v232;
                                  v33 = v212;
                                  goto LABEL_420;
                                }
                                v250 = v25 + v212;
                                if (v250 - v33 == v247)
                                  goto LABEL_546;
                                v212 = v250 - v247;
LABEL_555:
                                v251 = 0;
                                v252 = (unsigned __int8 *)(v246 + 16 * v212);
                                while (1)
                                {
                                  v253 = *v252;
                                  if (v253 != 21)
                                    break;
                                  v252 += v29;
                                  v251 -= v25;
                                  if (v212 - v33 == v251)
                                    goto LABEL_562;
                                }
                                if (v253 != 25)
                                {
LABEL_562:
                                  if (v212 != v33)
                                  {
                                    v255 = 0;
                                    v256 = 0;
                                    v257 = (unsigned __int8 *)(v246 + 16 * v212);
                                    v258 = (unsigned __int8 *)(v246 + 16 * (v25 + v212));
                                    while (1)
                                    {
                                      v259 = *v257;
                                      if (v259 != 21)
                                        break;
                                      v257 += v29;
                                      v256 -= v25;
                                      v255 += v25;
                                      v258 += v29;
                                      if (v212 - v33 == v256)
                                        goto LABEL_598;
                                    }
                                    if (v259 != 23)
                                    {
LABEL_598:
                                      v419 = 5;
                                      if (v212 != v33)
                                        continue;
                                      goto LABEL_420;
                                    }
                                    v260 = v25 + v212;
                                    if (v25 + v212 - v33 != v256)
                                    {
                                      v261 = v260 - v256;
                                      v262 = v418 + v410 - v260;
                                      while (1)
                                      {
                                        v263 = *v258;
                                        if (v263 != 21)
                                          break;
                                        v258 += v29;
                                        v255 += v25;
                                        if (v262 == v255)
                                          goto LABEL_575;
                                      }
                                      v264 = v407 + v212 + v255;
                                      if (v263 == 22)
                                        v261 = v264;
LABEL_575:
                                      if (v261 != v33)
                                      {
                                        v265 = -v261;
                                        v266 = (unsigned __int8 *)(v246 + 16 * v261);
                                        while (1)
                                        {
                                          v267 = *v266;
                                          if (v267 != 21)
                                            break;
                                          v266 += v29;
                                          v265 -= v25;
                                          if (v417 == v265)
                                            goto LABEL_582;
                                        }
                                        v268 = v25 - v265;
                                        if (v267 == 28)
                                          v261 = v268;
LABEL_582:
                                        if (v261 != v33)
                                        {
                                          v269 = -v261;
                                          v270 = (unsigned __int8 *)(v246 + 16 * v261);
                                          while (1)
                                          {
                                            v271 = *v270;
                                            if (v271 != 21)
                                              break;
                                            v270 += v29;
                                            v269 -= v25;
                                            if (v417 == v269)
                                              goto LABEL_589;
                                          }
                                          v272 = v25 - v269;
                                          if (v271 == 27)
                                            v261 = v272;
LABEL_589:
                                          if (v261 != v33)
                                          {
                                            while (2)
                                            {
                                              v273 = 0;
                                              v274 = (unsigned __int8 *)(v246 + 16 * v261);
                                              while (1)
                                              {
                                                v275 = *v274;
                                                if (v275 != 21)
                                                  break;
                                                v274 += v29;
                                                v273 -= v25;
                                                if (v261 - v33 == v273)
                                                  goto LABEL_597;
                                              }
                                              if (v275 != 26)
                                              {
LABEL_597:
                                                v212 = v261;
                                                goto LABEL_598;
                                              }
                                              v276 = v25 + v261;
                                              v261 = v25 + v261 - v273;
                                              v419 = 5;
                                              if (v276 - v33 != v273)
                                                continue;
                                              goto LABEL_420;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  goto LABEL_546;
                                }
                                break;
                              }
                              v254 = v25 + v212;
                              v212 = v25 + v212 - v251;
                              v419 = 5;
                              if (v254 - v33 != v251)
                                goto LABEL_555;
                              goto LABEL_420;
                            }
                          }
                        }
                      }
                    }
                  }
                  break;
                }
                v196 = 5;
                goto LABEL_443;
              default:
                if (v46 == 3)
                {
                  if (!v424)
                  {
                    v35 = v25 - v33;
                    if (v414 + v38 + v39)
                    {
                      v37 = v25 + v38 + v39;
                      do
                      {
                        v182 = *(unsigned __int8 *)(v45 + v43);
                        if (v182 != 21)
                        {
                          if (v182 == 22)
                            v37 = v407 + v38 + v39;
                          v419 = 3;
                          v31 = 3;
                          v34 = -v33;
                          goto LABEL_14;
                        }
                        v45 += v29;
                        v39 += v25;
                      }
                      while (v33 - (v25 + v38) != v39);
                      v419 = 3;
                    }
                    else
                    {
                      v419 = 3;
                      v37 = v33;
                    }
                    v31 = 3;
                    v34 = -v33;
                    continue;
                  }
                  goto LABEL_147;
                }
                if (v46 != 11 || v424 != 3)
                {
                  v38 += v39;
                  goto LABEL_145;
                }
LABEL_116:
                v77 = 0;
                v78 = v49;
                break;
            }
            while (1)
            {
              v79 = *(unsigned __int8 *)(v45 + 16 * v78 + 8);
              if (v79 == 11)
              {
                if ((v77 & 1) != 0)
                  goto LABEL_136;
                v78 += v25;
              }
              else
              {
                if (v79 != 13)
                {
                  if (v79 == 3 && (v77 & 1) != 0)
                  {
                    v49 = v78 + v25;
                    if (v78 + v25 == v33)
                      goto LABEL_420;
                    v80 = -v78;
                    v81 = (unsigned __int8 *)(v45 + 8 + 16 * v49);
                    while (1)
                    {
                      v82 = *v81;
                      if (v82 != 21)
                        break;
                      v81 += v29;
                      v80 -= v25;
                      if (v411 == v80)
                        goto LABEL_134;
                    }
                    v83 = v407 - v80;
                    if (v82 == 22)
                      v49 = v83;
LABEL_134:
                    if (v49 == v33)
                    {
LABEL_420:
                      v202 = v418;
                      goto LABEL_421;
                    }
                    goto LABEL_116;
                  }
LABEL_136:
                  if (v49 == v33)
                    goto LABEL_420;
                  if (*(_BYTE *)(v45 + 16 * v49 + 8) != 11)
                  {
                    v31 = 5;
                    goto LABEL_147;
                  }
                  v31 = 4;
                  v75 = 2;
                  v42 = v49;
LABEL_335:
                  v419 = v75;
                  v37 = v42 + v25;
                  v34 = -v33;
                  v35 = v25 - v33;
                  goto LABEL_14;
                }
                v78 += v25;
                if (v78 == v33 || *(_BYTE *)(v45 + 16 * v78 + 8) == 13)
                  goto LABEL_136;
              }
              v77 = 1;
              if (v78 == v33)
                goto LABEL_136;
            }
          }
LABEL_101:
          LOBYTE(v30) = v416;
          v75 = v419;
          if ((v424 != 0) | v416 & 1)
          {
LABEL_102:
            v38 += v39;
            while (1)
            {
LABEL_145:
              if (!((v31 != 0) | v30 & 1))
              {
                v184 = v75;
                v185 = v28;
                v186 = u_charType(c);
                v28 = v185;
                if (((1 << v186) & 0x140) != 0)
                  v184 = 6;
                v419 = v184;
                v33 = v38 + v25;
                goto LABEL_420;
              }
              v49 = v38;
LABEL_147:
              if (v75 != 1)
              {
                v38 = v49;
                v34 = -v33;
                goto LABEL_196;
              }
              if (v49 == v33)
                break;
              v84 = **((_QWORD **)v28 + 13);
              v85 = v25 + v49;
              v86 = (int *)(v84 + 16 * v49 + 8);
              v34 = -v33;
              while (1)
              {
                v87 = *v86;
                if ((*v86 & 0x8FF) == 0x807)
                  break;
                v86 = (int *)((char *)v86 + v29);
                v88 = v87 != 21 || v33 == v85;
                v85 += v25;
                if (v88)
                {
                  v85 = v49;
                  break;
                }
              }
              if (v85 == v33)
                break;
              v89 = v25 + v85;
              v90 = (int *)(v84 + 16 * v85 + 8);
              while (1)
              {
                v91 = *v90;
                if ((*v90 & 0x2FF) == 0x207)
                  break;
                v90 = (int *)((char *)v90 + v29);
                v92 = v91 != 21 || v33 == v89;
                v89 += v25;
                if (v92)
                {
                  v89 = v85;
                  break;
                }
              }
              if (v89 == v33)
                break;
              v93 = v25 + v89;
              v94 = (int *)(v84 + 16 * v89 + 8);
              while (1)
              {
                v95 = *v94;
                if ((*v94 & 0x4FF) == 0x407)
                  break;
                v94 = (int *)((char *)v94 + v29);
                v96 = v95 != 21 || v33 == v93;
                v93 += v25;
                if (v96)
                {
                  v93 = v89;
                  break;
                }
              }
              if (v93 == v33)
                break;
              v38 = v25 + v93;
              v97 = (int *)(v84 + 16 * v93 + 8);
              while (1)
              {
                v98 = *v97;
                if ((*v97 & 0x1FF) == 0x107)
                  break;
                v97 = (int *)((char *)v97 + v29);
                v99 = v98 != 21 || v33 == v38;
                v38 += v25;
                if (v99)
                {
                  v38 = v93;
                  break;
                }
              }
              if (v38 == v33)
                break;
LABEL_185:
              v100 = v25 + v38;
              v101 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v102 = *v101;
                if ((*v101 & 0x8FF) == 0x812)
                {
                  v38 = v100;
                  if (v33 == v100)
                    goto LABEL_414;
                  goto LABEL_185;
                }
                v101 = (int *)((char *)v101 + v29);
                v103 = v102 != 21 || v33 == v100;
                v100 += v25;
              }
              while (!v103);
              if (v38 == v33)
                break;
LABEL_200:
              v104 = v25 + v38;
              v105 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v106 = *v105;
                if ((*v105 & 0x2FF) == 0x212)
                {
                  v38 = v104;
                  if (v33 == v104)
                    goto LABEL_414;
                  goto LABEL_200;
                }
                v105 = (int *)((char *)v105 + v29);
                v107 = v106 != 21 || v33 == v104;
                v104 += v25;
              }
              while (!v107);
              if (v38 == v33)
                break;
LABEL_211:
              v108 = v25 + v38;
              v109 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v110 = *v109;
                if ((*v109 & 0x4FF) == 0x412)
                {
                  v38 = v108;
                  if (v33 == v108)
                    goto LABEL_414;
                  goto LABEL_211;
                }
                v109 = (int *)((char *)v109 + v29);
                v111 = v110 != 21 || v33 == v108;
                v108 += v25;
              }
              while (!v111);
              if (v38 == v33)
                break;
LABEL_222:
              v112 = v25 + v38;
              v113 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v114 = *v113;
                if ((*v113 & 0x1FF) == 0x112)
                {
                  v38 = v112;
                  if (v33 == v112)
                    goto LABEL_414;
                  goto LABEL_222;
                }
                v113 = (int *)((char *)v113 + v29);
                v115 = v114 != 21 || v33 == v112;
                v112 += v25;
              }
              while (!v115);
              if (v38 == v33)
                break;
              v116 = -v38;
              v117 = (unsigned __int8 *)(v84 + 16 * v38 + 8);
              while (1)
              {
                v118 = *v117;
                if (v118 != 21)
                  break;
                v117 += v29;
                v116 -= v25;
                if (v417 == v116)
                  goto LABEL_239;
              }
              v119 = v25 - v116;
              if (v118 == 10)
                v38 = v119;
LABEL_239:
              if (v38 == v33)
                break;
LABEL_240:
              v120 = v25 + v38;
              v121 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v122 = *v121;
                if ((*v121 & 0x8FF) == 0x813)
                {
                  v38 = v120;
                  if (v33 == v120)
                    goto LABEL_414;
                  goto LABEL_240;
                }
                v121 = (int *)((char *)v121 + v29);
                v123 = v122 != 21 || v33 == v120;
                v120 += v25;
              }
              while (!v123);
              if (v38 == v33)
                break;
LABEL_251:
              v124 = v25 + v38;
              v125 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v126 = *v125;
                if ((*v125 & 0x2FF) == 0x213)
                {
                  v38 = v124;
                  if (v33 == v124)
                    goto LABEL_414;
                  goto LABEL_251;
                }
                v125 = (int *)((char *)v125 + v29);
                v127 = v126 != 21 || v33 == v124;
                v124 += v25;
              }
              while (!v127);
              if (v38 == v33)
                break;
LABEL_262:
              v128 = v25 + v38;
              v129 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v130 = *v129;
                if ((*v129 & 0x4FF) == 0x413)
                {
                  v38 = v128;
                  if (v33 == v128)
                    goto LABEL_414;
                  goto LABEL_262;
                }
                v129 = (int *)((char *)v129 + v29);
                v131 = v130 != 21 || v33 == v128;
                v128 += v25;
              }
              while (!v131);
              if (v38 == v33)
                break;
LABEL_273:
              v132 = v25 + v38;
              v133 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v134 = *v133;
                if ((*v133 & 0x1FF) == 0x113)
                {
                  v38 = v132;
                  if (v33 == v132)
                    goto LABEL_414;
                  goto LABEL_273;
                }
                v133 = (int *)((char *)v133 + v29);
                v135 = v134 != 21 || v33 == v132;
                v132 += v25;
              }
              while (!v135);
              if (v38 == v33)
                break;
LABEL_284:
              v136 = v25 + v38;
              v137 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v138 = *v137;
                if ((*v137 & 0x2FF) == 0x205)
                {
                  v38 = v136;
                  if (v33 == v136)
                    goto LABEL_414;
                  goto LABEL_284;
                }
                v137 = (int *)((char *)v137 + v29);
                v139 = v138 != 21 || v33 == v136;
                v136 += v25;
              }
              while (!v139);
              if (v38 == v33)
                break;
LABEL_295:
              v140 = v25 + v38;
              v141 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v142 = *v141;
                if ((*v141 & 0x4FF) == 0x405)
                {
                  v38 = v140;
                  if (v33 == v140)
                    goto LABEL_414;
                  goto LABEL_295;
                }
                v141 = (int *)((char *)v141 + v29);
                v143 = v142 != 21 || v33 == v140;
                v140 += v25;
              }
              while (!v143);
              if (v38 == v33)
                break;
LABEL_306:
              v144 = v25 + v38;
              v145 = (int *)(v84 + 8 + 16 * v38);
              do
              {
                v146 = *v145;
                if ((*v145 & 0x1FF) == 0x105)
                {
                  v38 = v144;
                  if (v33 == v144)
                    goto LABEL_414;
                  goto LABEL_306;
                }
                v145 = (int *)((char *)v145 + v29);
                v147 = v146 != 21 || v33 == v144;
                v144 += v25;
              }
              while (!v147);
              if (v38 == v33)
                break;
              v148 = v84 + 8;
              while (1)
              {
                v149 = 0;
                v150 = (unsigned __int8 *)(v148 + 16 * v38);
                while (1)
                {
                  v151 = *v150;
                  if (v151 != 21)
                    break;
                  v150 += v29;
                  v149 -= v25;
                  if (v38 - v33 == v149)
                    goto LABEL_196;
                }
                if (v151 != 6)
                  break;
                v152 = v25 + v38;
                v38 = v25 + v38 - v149;
                if (v152 - v33 == v149)
                  goto LABEL_414;
              }
LABEL_196:
              if (v38 == v33)
                goto LABEL_420;
              v45 = **((_QWORD **)v28 + 13);
              if (*(_BYTE *)(v45 + 16 * v38 + 8) != 13)
              {
                v33 = v38;
                goto LABEL_420;
              }
LABEL_140:
              if ((v31 != 0) | v30 & 1)
              {
                v38 += v25;
                v202 = v418;
                if (v38 == v33)
                  goto LABEL_421;
                v35 = v25 - v33;
                if (*(_BYTE *)(v45 + 16 * v38 + 8) == 13)
                {
                  v33 = v38;
                  goto LABEL_421;
                }
                goto LABEL_15;
              }
              v31 = 0;
            }
LABEL_414:
            v183 = 1;
LABEL_415:
            v419 = v183;
            goto LABEL_420;
          }
          v194 = v25 + v38 + v39;
          if (v194 == v33)
          {
            v419 = 0;
            goto LABEL_420;
          }
          v202 = v418;
          while (1)
          {
            v195 = *(unsigned __int8 *)(v45 + v43);
            if (v195 != 21)
              break;
            v45 += v29;
            v39 += v25;
            if (v418 + v410 - (v25 + v38) == v39)
            {
              v419 = 0;
              v33 = v194;
              goto LABEL_421;
            }
          }
          if (v195 == 22)
            v33 = v407 + v38 + v39;
          else
            v33 = v194;
          v196 = 0;
LABEL_443:
          v419 = v196;
LABEL_421:
          if (v202 >= v33 - v25)
            v187 = v33 - v25;
          else
            v187 = v202;
          if (v202 - (v33 - v25) >= 0)
            v188 = v202 - (v33 - v25);
          else
            v188 = v33 - v25 - v202;
          v189 = TRunGlue::GetStringIndex(v28, v202);
          i = v428;
          v190 = TRunGlue::GetStringIndex(*(TRunGlue **)(v428 + 8), v33 - v25);
          v191 = *(_QWORD *)(v428 + 8);
          if (*(_QWORD *)(v191 + 152))
          {
            TRunGlue::FocusOnIndex(*(TRunGlue **)(v428 + 8), v33 - v25);
            v192 = objc_msgSend(*(id *)(*(_QWORD *)(v191 + 152) + 216), "attachmentCountAtIndex:", v33 - v25 - *(_QWORD *)(v191 + 160) + *(_QWORD *)(*(_QWORD *)(v191 + 152) + 200));
          }
          else
          {
            v192 = 0;
          }
          v193 = v188 + 1;
          StringIndex = v189;
          *(_QWORD *)&v430 = v190 - v189 + v192 + 1;
          *((_QWORD *)&v430 + 1) = v187;
          *(_QWORD *)&v431 = v193;
          DWORD2(v431) = v419;
          if (!v464)
            std::__throw_bad_function_call[abi:nn180100]();
          (*(void (**)(_QWORD *, uint64_t *))(*v464 + 48))(v464, &StringIndex);
          v11 = (uint64_t *)v428;
          v28 = *(TRunGlue **)(v428 + 8);
          j = v33;
          v27 = v415 - v193;
          if (v415 <= v193)
            goto LABEL_601;
          goto LABEL_11;
      }
    }
  }
LABEL_601:
  v277 = v464;
  if (v464 == v463)
  {
    v278 = 4;
    v277 = v463;
    goto LABEL_605;
  }
  if (v464)
  {
    v278 = 5;
LABEL_605:
    (*(void (**)(void))(*v277 + 8 * v278))();
  }
  v279 = (int *)v11[1];
  StringIndex = *v11;
  v430 = 0u;
  v431 = 0u;
  v441 = 0;
  v440 = 0u;
  v439 = 0u;
  v438 = 0u;
  v437 = 0u;
  v436 = 0u;
  v435 = 0u;
  v434 = 0u;
  v432 = 0u;
  v433 = 0u;
  *(_QWORD *)&v440 = *(_QWORD *)(StringIndex + 16);
  v280 = v279[6];
  v461[0] = -1;
  v281 = (int64_t *)__p;
  p_location = &v466->location;
  if (__p == v466)
  {
    v298 = v428;
  }
  else
  {
    j = 1;
    do
    {
      if (*((_DWORD *)v281 + 8) == 6)
      {
        v449[0] = 9676;
        i = *v281;
        v283 = *(_QWORD *)(v428 + 8);
        v284 = *(_QWORD *)(v283 + 40);
        if (v284 == -1)
        {
          TRunGlue::ComputeEndIndex(*(_QWORD **)(v428 + 8));
          v284 = *(_QWORD *)(v283 + 40);
        }
        if (i <= v284
          || (v445 = (unsigned __int16 *)(i - 1),
              v285 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&StringIndex, (uint64_t *)&v445, 0),
              v285 != v449[0]))
        {
          v286 = v461[0];
          v287 = *(_QWORD *)(v428 + 8);
          if (v461[0] == 0xFFFF)
          {
            GetGlyphsForLongCharacters(*(const TFont **)(v287 + 616), v449, v461, 1);
            v287 = *(_QWORD *)(v428 + 8);
            v286 = v461[0];
          }
          v288 = v281[2];
          LOWORD(v445) = v286;
          v289 = TRunGlue::DoGlyphInsertion((TRunGlue *)v287, (const unsigned __int16 *)&v445, 1u, *(_DWORD *)(v287 + 24) >= 0, 0, v288, v288, 1, 0);
          v442 |= v289;
          v290 = (CFRange *)__p;
          v291 = v466;
          if (__p != v466)
          {
            v292 = (CFRange *)((char *)__p + 24);
            while (1)
            {
              length = v292[-1].length;
              if (length > v288)
                break;
              location = v292->location;
              v294 = v292;
              if (v292->location + length > v288)
                goto LABEL_620;
LABEL_621:
              v290 = (CFRange *)((char *)v290 + 40);
              v296 = v292 + 1;
              v292 = (CFRange *)((char *)v292 + 40);
              if (v296 == v291)
                goto LABEL_622;
            }
            v294 = v290 + 1;
            location = v292[-1].length;
LABEL_620:
            v294->location = location + 1;
            goto LABEL_621;
          }
LABEL_622:
          v297 = v281[3] - 1;
          if ((int)v280 > 0)
            v297 = 0;
          *(_DWORD *)(*v427 + 16 * (v297 + v281[2]) + 8) = 1;
        }
      }
      v281 += 5;
    }
    while (v281 != p_location);
    v298 = v428;
    v279 = *(int **)(v428 + 8);
  }
  v299 = v427;
  if (TRunGlue::length((TRunGlue *)v279) >= 1)
  {
    for (j = 0; j < TRunGlue::length(*(TRunGlue **)(v298 + 8)); ++j)
    {
      if ((*(_BYTE *)(*v299 + 16 * j + 9) & 0x10) != 0)
      {
        v462[0] = TRunGlue::GetStringIndex(*(TRunGlue **)(v298 + 8), j);
        v300 = (UniversalClassTable *)TCharStreamIterator::GetFullChar((TCharStreamIterator *)&StringIndex, v462, 0);
        *(_QWORD *)v449 = 0xAAAAAAAAAAAAAAAALL;
        LODWORD(v450) = -1431655766;
        *(_QWORD *)v449 = UniversalClassTable::getSplitMatra(v300);
        LODWORD(v450) = v301;
        if (v301)
          i = 3;
        else
          i = 2;
        *(_QWORD *)&v302 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v302 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v447[2] = v302;
        v447[3] = v302;
        v447[0] = v302;
        v447[1] = v302;
        v445 = 0;
        v446 = 0uLL;
        *(_QWORD *)&v447[4] = v447;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v445, i);
        v303 = v446;
        bzero((void *)v446, ((2 * (_BYTE)i + 6) & 6) + 2);
        *(_QWORD *)&v446 = v303 + 2 * i;
        if (GetGlyphsForLongCharacters(*(const TFont **)(*(_QWORD *)(v298 + 8) + 616), v449, v445, i) == i)
        {
          v442 = 1;
          TRunGlue::SetGlyphID<true>(*(TRunGlue **)(v298 + 8), j, *v445);
          if ((v280 & 0x80000000) != 0)
          {
            v305 = &v449[i - 1];
            if (v305 > v449)
            {
              v306 = &v449[1];
              do
              {
                v307 = *(v306 - 1);
                *(v306 - 1) = *v305;
                *v305-- = v307;
                v308 = v306++ >= v305;
              }
              while (!v308);
            }
            v304 = v445;
            v309 = (unsigned __int16 *)(v446 - 2);
            if (v445 + 1 != (unsigned __int16 *)v446 && v309 > v445 + 1)
            {
              v311 = v445 + 2;
              do
              {
                v312 = *(v311 - 1);
                *(v311 - 1) = *v309;
                *v309-- = v312;
                v308 = v311++ >= v309;
              }
              while (!v308);
            }
          }
          else
          {
            v304 = v445;
          }
          v313 = i - 1;
          if (TRunGlue::DoGlyphInsertion(*(TRunGlue **)(v298 + 8), v304 + 1, (unsigned __int16)(i - 1), (v280 >> 31) & 1, 0, j, j, 0, 0))
          {
            v314 = (CFRange *)__p;
            v315 = v466;
            if (__p != v466)
            {
              v316 = (CFRange *)((char *)__p + 24);
              while (1)
              {
                v317 = v316[-1].length;
                if (v317 > j)
                  break;
                v319 = v316->location;
                v318 = v316;
                if (v316->location + v317 > j)
                  goto LABEL_655;
LABEL_656:
                v314 = (CFRange *)((char *)v314 + 40);
                v320 = v316 + 1;
                v316 = (CFRange *)((char *)v316 + 40);
                if (v320 == v315)
                  goto LABEL_657;
              }
              v318 = v314 + 1;
              v319 = v316[-1].length;
LABEL_655:
              v318->location = v319 + v313;
              goto LABEL_656;
            }
LABEL_657:
            v321 = (16 * j) | 8;
            v322 = v449;
            v298 = v428;
            do
            {
              v323 = *v427;
              v324 = *v322++;
              *(_DWORD *)(v323 + v321) = UniversalClassTable::getCharClass(*(UniversalClassTable **)(v428 + 16), v324);
              v321 += 16;
              --i;
            }
            while (i);
            j += v313;
          }
          else
          {
            v298 = v428;
          }
        }
        *(_QWORD *)v443 = &v445;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
        v299 = v427;
      }
    }
  }
  qmemcpy(v462, "pmcclcolartlmrtltkunnhka", sizeof(v462));
  qmemcpy(v461, "pmcclcolaltrmltrtkunnhka", 24);
  *(_QWORD *)&v325 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v325 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v458 = v325;
  v457 = v325;
  v456 = v325;
  v455 = v325;
  v454 = v325;
  v453 = v325;
  v452 = v325;
  v459 = 0xAAAAAAAAAAAAAAAALL;
  v451 = 0;
  v460 = &v452;
  if ((int)v280 <= 0)
    v326 = v461;
  else
    v326 = v462;
  *(_QWORD *)v449 = 0;
  v450 = 0;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v445, v326, v326 + 6);
  OTL::GCommon::GetLookups((uint64_t)v408, (uint64_t)&v445, (uint64_t)v449, 0);
  *(_QWORD *)v443 = &v445;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
  memset(v447, 170, sizeof(v447));
  v445 = 0;
  v446 = 0uLL;
  v448 = v447;
  v327 = (CFRange *)__p;
  v328 = v466;
  while (v327 != v328)
  {
    v329 = *(unsigned int **)v449;
    v330 = (unsigned int *)v450;
    if (*(_QWORD *)v449 != v450)
    {
      v331 = v327[1].location;
      j = v327[1].length;
      do
      {
        v332 = *v329++;
        i = i & 0xFFFFFFFF00000000 | v332;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v445, i, v331, j);
      }
      while (v329 != v330);
    }
    v327 = (CFRange *)((char *)v327 + 40);
  }
  *(_QWORD *)v443 = &__p;
  *(_QWORD *)&v443[8] = v427;
  *(_QWORD *)&v443[16] = 0xAAAAAAAA00000000;
  OTL::GSUB::ApplyLookups(v408, *(TRunGlue **)(v428 + 8), *(_DWORD *)(*(_QWORD *)(v428 + 8) + 24), &v445, &v442, (uint64_t)UniversalShapingEngine::ApplyLookups<TInlineVector<UniversalShapingEngine::Syllable,30ul>>(OTL::GSUB const&,OTL::GlyphLookups &,TInlineVector<UniversalShapingEngine::Syllable,30ul> &,SyncState *,TGlyphAuxDataList &,unsigned int)const::{lambda(void *,CFRange,long)#1}::__invoke, (uint64_t)v443);
  *(_QWORD *)v443 = &v445;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
  v445 = (unsigned __int16 *)v449;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v445);
  *(_QWORD *)&v333 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v333 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v458 = v333;
  v457 = v333;
  v456 = v333;
  v455 = v333;
  v454 = v333;
  v453 = v333;
  v452 = v333;
  v459 = 0xAAAAAAAAAAAAAAAALL;
  v451 = 0;
  *(_QWORD *)v449 = 0;
  v450 = 0;
  v460 = &v452;
  LODWORD(v462[0]) = 1919969382;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v445, v462, (_DWORD *)v462 + 1);
  OTL::GCommon::GetLookups((uint64_t)v408, (uint64_t)&v445, (uint64_t)v449, 0);
  *(_QWORD *)v443 = &v445;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
  memset(v447, 170, sizeof(v447));
  v445 = 0;
  v446 = 0uLL;
  v448 = v447;
  v334 = (CFRange *)__p;
  v335 = v466;
  while (v334 != v335)
  {
    v336 = v334[1].length;
    v337 = v336 - 3;
    if (v336 >= 3)
    {
      if ((v280 & 0x80000000) == 0 || v336 == 3)
        v337 = 0;
      v339 = *(unsigned int **)v449;
      i = v450;
      if (*(_QWORD *)v449 != v450)
      {
        v340 = v334[1].location + v337;
        do
        {
          v341 = *v339++;
          j = j & 0xFFFFFFFF00000000 | v341;
          OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v445, j, v340, 3);
        }
        while (v339 != (unsigned int *)i);
      }
    }
    v334 = (CFRange *)((char *)v334 + 40);
  }
  *(_QWORD *)v443 = &__p;
  *(_QWORD *)&v443[8] = v427;
  *(_QWORD *)&v443[16] = 0xAAAAAAAA0000000FLL;
  OTL::GSUB::ApplyLookups(v408, *(TRunGlue **)(v428 + 8), *(_DWORD *)(*(_QWORD *)(v428 + 8) + 24), &v445, &v442, (uint64_t)UniversalShapingEngine::ApplyLookups<TInlineVector<UniversalShapingEngine::Syllable,30ul>>(OTL::GSUB const&,OTL::GlyphLookups &,TInlineVector<UniversalShapingEngine::Syllable,30ul> &,SyncState *,TGlyphAuxDataList &,unsigned int)const::{lambda(void *,CFRange,long)#1}::__invoke, (uint64_t)v443);
  *(_QWORD *)v443 = &v445;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
  v445 = (unsigned __int16 *)v449;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v445);
  *(_QWORD *)&v342 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v342 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v458 = v342;
  v457 = v342;
  v456 = v342;
  v455 = v342;
  v454 = v342;
  v453 = v342;
  v452 = v342;
  v459 = 0xAAAAAAAAAAAAAAAALL;
  v451 = 0;
  v460 = &v452;
  LODWORD(v462[0]) = 1886545254;
  *(_QWORD *)v449 = 0;
  v450 = 0;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v445, v462, (_DWORD *)v462 + 1);
  OTL::GCommon::GetLookups((uint64_t)v408, (uint64_t)&v445, (uint64_t)v449, 0);
  *(_QWORD *)v443 = &v445;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
  memset(v447, 170, sizeof(v447));
  v445 = 0;
  v446 = 0uLL;
  v448 = v447;
  v343 = (CFRange *)__p;
  v344 = v466;
  while (v343 != v344)
  {
    v345 = *(unsigned int **)v449;
    v346 = (unsigned int *)v450;
    if (*(_QWORD *)v449 != v450)
    {
      v347 = v343[1].location;
      v348 = v343[1].length;
      do
      {
        v349 = *v345++;
        i = i & 0xFFFFFFFF00000000 | v349;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v445, i, v347, v348);
      }
      while (v345 != v346);
    }
    v343 = (CFRange *)((char *)v343 + 40);
  }
  *(_QWORD *)&v443[16] = 0xAAAAAAAA00020812;
  *(_QWORD *)v443 = &__p;
  *(_QWORD *)&v443[8] = v427;
  OTL::GSUB::ApplyLookups(v408, *(TRunGlue **)(v428 + 8), *(_DWORD *)(*(_QWORD *)(v428 + 8) + 24), &v445, &v442, (uint64_t)UniversalShapingEngine::ApplyLookups<TInlineVector<UniversalShapingEngine::Syllable,30ul>>(OTL::GSUB const&,OTL::GlyphLookups &,TInlineVector<UniversalShapingEngine::Syllable,30ul> &,SyncState *,TGlyphAuxDataList &,unsigned int)const::{lambda(void *,CFRange,long)#1}::__invoke, (uint64_t)v443);
  *(_QWORD *)v443 = &v445;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
  v445 = (unsigned __int16 *)v449;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v445);
  *(_QWORD *)&v350 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v350 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v458 = v350;
  v457 = v350;
  v456 = v350;
  v455 = v350;
  v454 = v350;
  v453 = v350;
  v452 = v350;
  v459 = 0xAAAAAAAAAAAAAAAALL;
  v451 = 0;
  *(_QWORD *)v449 = 0;
  v450 = 0;
  v460 = &v452;
  qmemcpy(v443, "frkrfvbafwlbflahftsputavtcjc", sizeof(v443));
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v445, v443, v444);
  OTL::GCommon::GetLookups((uint64_t)v408, (uint64_t)&v445, (uint64_t)v449, 0);
  v462[0] = (uint64_t)&v445;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v462);
  memset(v447, 170, sizeof(v447));
  v445 = 0;
  v446 = 0uLL;
  v448 = v447;
  v351 = (CFRange *)__p;
  v352 = v466;
  while (v351 != v352)
  {
    v353 = *(unsigned int **)v449;
    v354 = (unsigned int *)v450;
    if (*(_QWORD *)v449 != v450)
    {
      v355 = v351[1].location;
      v356 = v351[1].length;
      do
      {
        v357 = *v353++;
        i = i & 0xFFFFFFFF00000000 | v357;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v445, i, v355, v356);
      }
      while (v353 != v354);
    }
    v351 = (CFRange *)((char *)v351 + 40);
  }
  *(_QWORD *)&v443[16] = 0xAAAAAAAA00000000;
  v359 = v427;
  v358 = (uint64_t *)v428;
  *(_QWORD *)v443 = &__p;
  *(_QWORD *)&v443[8] = v427;
  OTL::GSUB::ApplyLookups(v408, *(TRunGlue **)(v428 + 8), *(_DWORD *)(*(_QWORD *)(v428 + 8) + 24), &v445, &v442, (uint64_t)UniversalShapingEngine::ApplyLookups<TInlineVector<UniversalShapingEngine::Syllable,30ul>>(OTL::GSUB const&,OTL::GlyphLookups &,TInlineVector<UniversalShapingEngine::Syllable,30ul> &,SyncState *,TGlyphAuxDataList &,unsigned int)const::{lambda(void *,CFRange,long)#1}::__invoke, (uint64_t)v443);
  *(_QWORD *)v443 = &v445;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v443);
  v445 = (unsigned __int16 *)v449;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v445);
  v360 = (CFRange *)__p;
  v423 = v466;
  if (__p == v466)
    goto LABEL_784;
  v421 = 0;
  do
  {
    v362 = v360[1].location;
    v361 = v360[1].length;
    v363 = v361 - 1;
    if ((int)v280 > 0)
      v363 = 0;
    v364 = v363 + v362;
    if (*(_BYTE *)(*v359 + 16 * (v363 + v362) + 8) == 15)
    {
      v365 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v428 + 8), v364);
      v367 = v365;
      v425 = v366;
      if ((int)v280 <= 0)
        v368 = -1;
      else
        v368 = v366;
      v369 = v368 + v365;
      v370 = v361 + v362;
      if (v362 <= v368 + v365 && v370 > v369)
      {
        do
        {
          if (TRunGlue::IsDeleted(*(TRunGlue **)(v428 + 8), v369))
            goto LABEL_720;
          v372 = *(_DWORD *)(*v359 + 16 * v369 + 8);
          if (v372 == 1 || v372 == 4)
            goto LABEL_720;
          if (v372 != 10)
            break;
          if ((v372 & 0x100FF) != 0xA)
          {
LABEL_720:
            v374 = v369;
          }
          else
          {
            v374 = v369 + v280;
            if (v362 > (uint64_t)(v369 + v280) || v370 <= v374 || *(_BYTE *)(*v359 + 16 * v374 + 8) != 13)
              break;
          }
          v369 = v374 + v280;
        }
        while (v362 <= (uint64_t)(v374 + v280) && v370 > v369);
      }
      v376 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v428 + 8), v369 - v280);
      if ((int)v280 < 1)
      {
        v378 = v364 + 1;
        v379 = v376;
        v377 = v367;
      }
      else
      {
        v377 = v367 + v425;
        v378 = v376 + v375;
        v379 = v364;
      }
      TRunGlue::Rotate(*(TRunGlue **)(v428 + 8), v379, v377, v378, v427);
      v421 = 1;
    }
    else
    {
      v370 = v361 + v362;
    }
    if (v362 <= v364 && v370 > v364)
    {
      v381 = 0;
      v426 = 0;
      if ((int)v280 <= 0)
        v382 = -1;
      else
        v382 = v361;
      v383 = v382 + v362;
      v384 = (16 * v364) | 8;
      v385 = v364;
      while (1)
      {
        if (!TRunGlue::IsDeleted(*(TRunGlue **)(v428 + 8), v385))
        {
          v386 = *(_DWORD *)(*v427 + v384);
          v387 = v386;
          if (v386 > 0x11u)
          {
            if (v386 - 18 < 2 && (v386 & 0x800) != 0)
            {
              if ((*(_DWORD *)&v426 & ((v386 & 0x20000u) >> 17) & 1) != 0)
              {
                v426 = 1;
              }
              else
              {
                if (v364 >= v385)
                  v395 = v385;
                else
                  v395 = v364;
                if (v381 >= 0)
                  v396 = v381;
                else
                  v396 = -v381;
                v426 = 1;
                if (v395 <= v383 && v395 + v396 + 1 > v383)
                {
                  v397 = v385 + 1;
                  if ((int)v280 < 1)
                  {
                    v398 = v385;
                    v399 = v385 + 1;
                    v397 = v383 + 1;
                  }
                  else
                  {
                    v398 = v383;
                    v399 = v385;
                  }
                  TRunGlue::Rotate(*(TRunGlue **)(v428 + 8), v398, v399, v397, v427);
                  v426 = 1;
                  v421 = 1;
                }
              }
            }
            goto LABEL_740;
          }
          if (v386 == 1 || v386 == 4)
          {
            if (v362 <= v383 && v370 > v383)
              goto LABEL_740;
            v389 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v428 + 8), v385);
            v391 = v390 - 1;
            if ((int)v280 > 0)
              v391 = 0;
          }
          else
          {
            v392 = v386 & 0x100FF;
            if (v387 != 10 || v392 != 10)
              goto LABEL_740;
            v389 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v428 + 8), v385);
            if ((int)v280 <= 0)
              v391 = -1;
            else
              v391 = v394;
          }
          v383 = v391 + v389;
        }
LABEL_740:
        v385 += v280;
        if (v362 <= v385)
        {
          v381 -= v280;
          v384 += 16 * v280;
          if (v370 > v385)
            continue;
        }
        break;
      }
    }
    v360 = (CFRange *)((char *)v360 + 40);
    v359 = v427;
  }
  while (v360 != v423);
  v358 = (uint64_t *)v428;
  if ((v421 & 1) != 0)
  {
    v442 = 1;
    if (*(_QWORD *)(*(_QWORD *)(v428 + 8) + 152))
    {
      v400 = (CFRange *)__p;
      v401 = v466;
      while (v400 != v401)
      {
        TRunGlue::ClearSafeToBreakAfter(*(_QWORD *)(v428 + 8), v400[1]);
        v400 = (CFRange *)((char *)v400 + 40);
      }
    }
  }
LABEL_784:
  if (*(_BYTE *)(v358[2] + 8))
  {
    v403 = *v358;
    v402 = v358[1];
    v445 = (unsigned __int16 *)&off_1E15DE610;
    *(_QWORD *)&v446 = v403;
    *((_QWORD *)&v446 + 1) = v402;
    *(_QWORD *)&v447[0] = 0xAAAAAAAAAAAAAA01;
    if (v403)
    {
      *(_WORD *)(v402 + 632) = 257;
      JoiningScriptShapingEngine::SetFeatures((JoiningScriptShapingEngine *)&v445, v408, v406);
      v404 = 1;
    }
    else
    {
      v404 = 0;
    }
    v442 |= v404;
  }
  if (__p)
  {
    v466 = (CFRange *)__p;
    if (v468 > __p || v469 <= __p)
      operator delete(__p);
  }
  return v442;
}

void std::__function::__func<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0,std::allocator<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0>,void ()(UniversalShapingEngine::Syllable)>::~__func()
{
  JUMPOUT(0x186DC03ACLL);
}

_QWORD *std::__function::__func<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0,std::allocator<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0>,void ()(UniversalShapingEngine::Syllable)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E15E05B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0,std::allocator<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0>,void ()(UniversalShapingEngine::Syllable)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E15E05B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0,std::allocator<UniversalShapingEngine::ApplyScriptShaping(OTL::GSUB const&,OTL::GlyphLookups *)::$_0>,void ()(UniversalShapingEngine::Syllable)>::operator()(uint64_t a1, __int128 *a2)
{
  char **v2;
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  char *v20;
  char **v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v22 = *a2;
  v23 = a2[1];
  v24 = *((_QWORD *)a2 + 4);
  v2 = *(char ***)(a1 + 8);
  v3 = (unint64_t)v2[1];
  v4 = (unint64_t)v2[2];
  if (v3 >= v4)
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v3 - (_QWORD)*v2) >> 3);
    v9 = v8 + 1;
    if (v8 + 1 > 0x666666666666666)
      abort();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - (_QWORD)*v2) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    if (v11)
    {
      v12 = v2[153];
      v13 = (unint64_t)&v12[40 * v11];
      if (v13 <= (unint64_t)(v2 + 153))
      {
        v2[153] = (char *)v13;
      }
      else
      {
        if (v11 > 0x666666666666666)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v12 = (char *)operator new(40 * v11);
      }
    }
    else
    {
      v12 = 0;
    }
    v14 = &v12[40 * v8];
    *(_OWORD *)v14 = v22;
    *((_OWORD *)v14 + 1) = v23;
    *((_QWORD *)v14 + 4) = v24;
    v16 = *v2;
    v15 = v2[1];
    v17 = v14;
    if (v15 != *v2)
    {
      do
      {
        v18 = *(_OWORD *)(v15 - 40);
        v19 = *(_OWORD *)(v15 - 24);
        *((_QWORD *)v17 - 1) = *((_QWORD *)v15 - 1);
        *(_OWORD *)(v17 - 24) = v19;
        *(_OWORD *)(v17 - 40) = v18;
        v17 -= 40;
        v15 -= 40;
      }
      while (v15 != v16);
      v15 = *v2;
    }
    v7 = v14 + 40;
    *v2 = v17;
    v2[1] = v14 + 40;
    v20 = v2[2];
    v2[2] = &v12[40 * v11];
    if (v15)
    {
      if (v2 + 3 > (char **)v15 || (v21 = v2 + 153, v2 + 153 <= (char **)v15))
      {
        operator delete(v15);
      }
      else if (v20 == *v21)
      {
        *v21 = v15;
      }
    }
  }
  else
  {
    v5 = *a2;
    v6 = a2[1];
    *(_QWORD *)(v3 + 32) = *((_QWORD *)a2 + 4);
    *(_OWORD *)v3 = v5;
    *(_OWORD *)(v3 + 16) = v6;
    v7 = (char *)(v3 + 40);
  }
  v2[1] = v7;
}

_DWORD *UniversalShapingEngine::ApplyLookups<TInlineVector<UniversalShapingEngine::Syllable,30ul>>(OTL::GSUB const&,OTL::GlyphLookups &,TInlineVector<UniversalShapingEngine::Syllable,30ul> &,SyncState *,TGlyphAuxDataList &,unsigned int)const::{lambda(void *,CFRange,long)#1}::__invoke(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  int *v12;

  if (a4 - a3 >= 1)
  {
    v4 = **(_QWORD ***)result;
    v5 = *(_QWORD **)(*(_QWORD *)result + 8);
    if (v4 != v5)
    {
      v6 = v4 + 3;
      while (1)
      {
        v7 = *(v6 - 1);
        if (v7 > a2)
          break;
        v9 = *v6;
        v8 = v6;
        if (*v6 + v7 > a2)
          goto LABEL_7;
LABEL_8:
        v4 += 5;
        v10 = v6 + 2;
        v6 += 5;
        if (v10 == v5)
          goto LABEL_9;
      }
      v8 = v4 + 2;
      v9 = *(v6 - 1);
LABEL_7:
      *v8 = v9 + a4 - a3;
      goto LABEL_8;
    }
  }
LABEL_9:
  v11 = result[4];
  v12 = (int *)(**((_QWORD **)result + 1) + 16 * a2 + 8);
  if (!v11)
    v11 = *v12 | 0x10000;
  *v12 = v11;
  return result;
}

uint64_t sub_1849211C0()
{
  return MEMORY[0x1E0CAE8D0]();
}

uint64_t sub_1849211CC()
{
  return MEMORY[0x1E0CAE8F0]();
}

uint64_t sub_1849211D8()
{
  return MEMORY[0x1E0CAE8F8]();
}

uint64_t sub_1849211E4()
{
  return MEMORY[0x1E0CB01F0]();
}

uint64_t sub_1849211F0()
{
  return MEMORY[0x1E0CB0228]();
}

uint64_t sub_1849211FC()
{
  return MEMORY[0x1E0CB0240]();
}

uint64_t sub_184921208()
{
  return MEMORY[0x1E0DF0228]();
}

uint64_t sub_184921214()
{
  return MEMORY[0x1E0CB1940]();
}

uint64_t sub_184921220()
{
  return MEMORY[0x1E0CB1980]();
}

uint64_t sub_18492122C()
{
  return MEMORY[0x1E0DEA758]();
}

uint64_t sub_184921238()
{
  return MEMORY[0x1E0DECFC0]();
}

uint64_t sub_184921244()
{
  return MEMORY[0x1E0DECFF0]();
}

uint64_t sub_184921250()
{
  return MEMORY[0x1E0DED0F0]();
}

uint64_t sub_18492125C()
{
  return MEMORY[0x1E0DED120]();
}

uint64_t sub_184921268()
{
  return MEMORY[0x1E0DED600]();
}

uint64_t sub_184921274()
{
  return MEMORY[0x1E0DEDEF8]();
}

uint64_t sub_184921280()
{
  return MEMORY[0x1E0DEDF10]();
}

uint64_t sub_18492128C()
{
  return MEMORY[0x1E0DEDF40]();
}

uint64_t sub_184921298()
{
  return MEMORY[0x1E0DEE240]();
}

uint64_t sub_1849212A4()
{
  return MEMORY[0x1E0DEE270]();
}

uint64_t sub_1849212B0()
{
  return MEMORY[0x1E0DEE8E0]();
}

uint64_t sub_1849212BC()
{
  return MEMORY[0x1E0DEE8E8]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1E0C97C98](allocator, size, hint);
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x1E0C97D00](theArray, range.location, range.length, applier, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D10](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1E0C97D30](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D78](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  MEMORY[0x1E0C97DA8](theArray, range.location, range.length, values);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DB0](theArray, idx, value);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x1E0C97DB8](theArray);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
  MEMORY[0x1E0C97DC8](theArray, range.location, range.length, newValues, newCount);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x1E0C97DE0](theArray, range.location, range.length, comparator, context);
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x1E0C97DF0](alloc, str, attributes);
}

CFAttributedStringRef CFAttributedStringCreateCopy(CFAllocatorRef alloc, CFAttributedStringRef aStr)
{
  return (CFAttributedStringRef)MEMORY[0x1E0C97DF8](alloc, aStr);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFAttributedStringRef aStr)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1E0C97E08](alloc, maxLength, aStr);
}

CFAttributedStringRef CFAttributedStringCreateWithSubstring(CFAllocatorRef alloc, CFAttributedStringRef aStr, CFRange range)
{
  return (CFAttributedStringRef)MEMORY[0x1E0C97E10](alloc, aStr, range.location, range.length);
}

CFTypeRef CFAttributedStringGetAttribute(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange *effectiveRange)
{
  return (CFTypeRef)MEMORY[0x1E0C97E20](aStr, loc, attrName, effectiveRange);
}

CFDictionaryRef CFAttributedStringGetAttributes(CFAttributedStringRef aStr, CFIndex loc, CFRange *effectiveRange)
{
  return (CFDictionaryRef)MEMORY[0x1E0C97E30](aStr, loc, effectiveRange);
}

uint64_t CFAttributedStringGetBidiLevelsAndResolvedDirections()
{
  return MEMORY[0x1E0C97E40]();
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x1E0C97E48](aStr);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  return (CFStringRef)MEMORY[0x1E0C97E50](aStr);
}

void CFAttributedStringRemoveAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName)
{
  MEMORY[0x1E0C97E60](aStr, range.location, range.length, attrName);
}

void CFAttributedStringReplaceAttributedString(CFMutableAttributedStringRef aStr, CFRange range, CFAttributedStringRef replacement)
{
  MEMORY[0x1E0C97E68](aStr, range.location, range.length, replacement);
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C97E70](aStr, range.location, range.length, replacement);
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
  MEMORY[0x1E0C97E78](aStr, range.location, range.length, attrName, value);
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1E0C97E90](arg);
}

CFBitVectorRef CFBitVectorCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex numBits)
{
  return (CFBitVectorRef)MEMORY[0x1E0C97F58](allocator, bytes, numBits);
}

CFMutableBitVectorRef CFBitVectorCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableBitVectorRef)MEMORY[0x1E0C97F68](allocator, capacity);
}

CFBit CFBitVectorGetBitAtIndex(CFBitVectorRef bv, CFIndex idx)
{
  return MEMORY[0x1E0C97F78](bv, idx);
}

CFIndex CFBitVectorGetCount(CFBitVectorRef bv)
{
  return MEMORY[0x1E0C97F88](bv);
}

void CFBitVectorSetAllBits(CFMutableBitVectorRef bv, CFBit value)
{
  MEMORY[0x1E0C97FA8](bv, *(_QWORD *)&value);
}

void CFBitVectorSetBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx, CFBit value)
{
  MEMORY[0x1E0C97FB0](bv, idx, *(_QWORD *)&value);
}

void CFBitVectorSetBits(CFMutableBitVectorRef bv, CFRange range, CFBit value)
{
  MEMORY[0x1E0C97FB8](bv, range.location, range.length, *(_QWORD *)&value);
}

void CFBitVectorSetCount(CFMutableBitVectorRef bv, CFIndex count)
{
  MEMORY[0x1E0C97FC0](bv, count);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFArrayRef CFBundleCopyBundleLocalizations(CFBundleRef bundle)
{
  return (CFArrayRef)MEMORY[0x1E0C97FF8](bundle);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  return (CFArrayRef)MEMORY[0x1E0C98040](locArray, prefArray);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1E0C98050](bundle, key, value, tableName);
}

uint64_t CFBundleCopyLocalizedStringForLocalization()
{
  return MEMORY[0x1E0C98060]();
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1E0C98120](bundle);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98130](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  MEMORY[0x1E0C982A0](theSet, theRange.location, theRange.length);
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  MEMORY[0x1E0C982A8](theSet, theString);
}

CFCharacterSetRef CFCharacterSetCreateCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982B8](alloc, theSet);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  return (CFMutableCharacterSetRef)MEMORY[0x1E0C982C8](alloc);
}

CFMutableCharacterSetRef CFCharacterSetCreateMutableCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFMutableCharacterSetRef)MEMORY[0x1E0C982D0](alloc, theSet);
}

CFCharacterSetRef CFCharacterSetCreateWithBitmapRepresentation(CFAllocatorRef alloc, CFDataRef theData)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982D8](alloc, theData);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef alloc, CFRange theRange)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982E0](alloc, theRange.location, theRange.length);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982E8](alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982F0](theSetIdentifier);
}

CFTypeID CFCharacterSetGetTypeID(void)
{
  return MEMORY[0x1E0C982F8]();
}

uint64_t CFCharacterSetInitInlineBuffer()
{
  return MEMORY[0x1E0C98308]();
}

void CFCharacterSetIntersect(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  MEMORY[0x1E0C98310](theSet, theOtherSet);
}

void CFCharacterSetInvert(CFMutableCharacterSetRef theSet)
{
  MEMORY[0x1E0C98318](theSet);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x1E0C98320](theSet, theChar);
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  return MEMORY[0x1E0C98328](theSet, *(_QWORD *)&theChar);
}

Boolean CFCharacterSetIsSupersetOfSet(CFCharacterSetRef theSet, CFCharacterSetRef theOtherset)
{
  return MEMORY[0x1E0C98330](theSet, theOtherset);
}

void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  MEMORY[0x1E0C98338](theSet, theRange.location, theRange.length);
}

void CFCharacterSetRemoveCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  MEMORY[0x1E0C98340](theSet, theString);
}

void CFCharacterSetUnion(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  MEMORY[0x1E0C98348](theSet, theOtherSet);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x1E0C98390](theData, bytes, length);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1E0C983C8](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1E0C98408](theData);
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
  MEMORY[0x1E0C98420](theData, extraLength);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98648](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1E0C98650](allocator, domain, code, userInfo);
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  return (CFErrorRef)MEMORY[0x1E0C98658](allocator, domain, code, userInfoKeys, userInfoValues, numUserInfoValues);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1E0C98660](err);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1E0C98720](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

CFArrayRef CFLocaleCopyAvailableLocaleIdentifiers(void)
{
  return (CFArrayRef)MEMORY[0x1E0C98768]();
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1E0C98770]();
}

CFArrayRef CFLocaleCopyISOLanguageCodes(void)
{
  return (CFArrayRef)MEMORY[0x1E0C98788]();
}

CFArrayRef CFLocaleCopyPreferredLanguages(void)
{
  return (CFArrayRef)MEMORY[0x1E0C98790]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1E0C98798](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987A0](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987B0](allocator, localeIdentifier);
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  return (CFDictionaryRef)MEMORY[0x1E0C987B8](allocator, localeID);
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987C8](allocator, dictionary);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987D8](locale);
}

uint64_t CFLocaleGetLanguageRegionEncodingForLocaleIdentifier()
{
  return MEMORY[0x1E0C987E8]();
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x1E0C98800](locale, key);
}

uint64_t CFLog()
{
  return MEMORY[0x1E0C98808]();
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98858](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988D0]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  MEMORY[0x1E0C988E0](center, name, object, userInfo, deliverImmediately);
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1E0C98908]();
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1E0C98910](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return MEMORY[0x1E0C98AF8](propertyList, stream, format, options, error);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98D78](theSet, applier, context);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1E0C98D80](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1E0C98D88](allocator, values, numValues, callBacks);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98DA0](allocator, capacity, theSet);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1E0C98DA8](theSet);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  MEMORY[0x1E0C98DD0](theSet, values);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DE0](theSet, value);
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DF0](theSet, value);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  MEMORY[0x1E0C98EE8](theString, chars, numChars);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x1E0C98EF0](theString, formatOptions, format);
}

void CFStringCapitalize(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C98F00](theString, locale);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptionsAndLocale(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions, CFLocaleRef locale)
{
  return MEMORY[0x1E0C98F20](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions, locale);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1E0C98F58](alloc, theString, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1E0C98F80](alloc, theString, *(_QWORD *)&encoding, lossByte);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FC8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FE0](alloc, cStr, *(_QWORD *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1E0C98FE8](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithCharactersNoCopy(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FF8](alloc, chars, numChars, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  MEMORY[0x1E0C99038](theString, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99060](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

void CFStringFold(CFMutableStringRef theString, CFStringCompareFlags theFlags, CFLocaleRef theLocale)
{
  MEMORY[0x1E0C99078](theString, theFlags, theLocale);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  MEMORY[0x1E0C990C0](theString, range.location, range.length, buffer);
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x1E0C990C8](theString);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  double result;

  MEMORY[0x1E0C990D0](str);
  return result;
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1E0C990F0](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99118](length, *(_QWORD *)&encoding);
}

void CFStringGetParagraphBounds(CFStringRef string, CFRange range, CFIndex *parBeginIndex, CFIndex *parEndIndex, CFIndex *contentsEndIndex)
{
  MEMORY[0x1E0C99140](string, range.location, range.length, parBeginIndex, parEndIndex, contentsEndIndex);
}

uint64_t CFStringGetRangeOfCharacterClusterAtIndex()
{
  return MEMORY[0x1E0C99158]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1E0C99190](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C991D0](theString, locale);
}

uint64_t CFStringOpenUText()
{
  return MEMORY[0x1E0C991E0]();
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C991F0](theString, range.location, range.length, replacement);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  MEMORY[0x1E0C99258](theString);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1E0C992C8](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyFragment(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1E0C992E8](anURL, charactersToLeaveEscaped);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C993F8](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(_QWORD *)&encoding);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  return (CFURLRef)MEMORY[0x1E0C99478](anURL);
}

CFRange CFURLGetByteRangeForComponent(CFURLRef url, CFURLComponentType component, CFRange *rangeIncludingSeparators)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99480](url, component, rangeIncludingSeparators);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C99488](url, buffer, bufferLength);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C994A0](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1E0C994B8]();
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1E0C99518](alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1E0C99538](alloc, uuid);
}

uint64_t CFUniCharIsMemberOf()
{
  return MEMORY[0x1E0C99598]();
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  MEMORY[0x1E0C99600](stream);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x1E0C99630](alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1E0C99650](stream);
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BA90](retstr, t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAB0](retstr, t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAD8](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAE0](retstr, tx, ty);
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAF8](retstr, t, sx, sy);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1E0C9BB10](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x1E0C9BB20](context);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x1E0C9BC78](space, components);
}

CGFloat CGColorGetAlpha(CGColorRef color)
{
  CGFloat result;

  MEMORY[0x1E0C9BCF8](color);
  return result;
}

CGColorRef CGColorGetConstantColor(CFStringRef colorName)
{
  return (CGColorRef)MEMORY[0x1E0C9BD10](colorName);
}

CFTypeID CGColorGetTypeID(void)
{
  return MEMORY[0x1E0C9BD38]();
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x1E0C9BD68](color);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDF0]();
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE50](name);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BEC8](space);
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9BFD0](c, x, y);
}

void CGContextAddPath(CGContextRef c, CGPathRef path)
{
  MEMORY[0x1E0C9BFD8](c, path);
}

void CGContextBeginTransparencyLayer(CGContextRef c, CFDictionaryRef auxiliaryInfo)
{
  MEMORY[0x1E0C9C008](c, auxiliaryInfo);
}

uint64_t CGContextClear()
{
  return MEMORY[0x1E0C9C018]();
}

void CGContextClipToRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C038](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
  MEMORY[0x1E0C9C050](c, transform);
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x1E0C9C170](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)
{
  MEMORY[0x1E0C9C1B8](c, *(_QWORD *)&mode);
}

void CGContextEndTransparencyLayer(CGContextRef c)
{
  MEMORY[0x1E0C9C200](c);
}

void CGContextFillPath(CGContextRef c)
{
  MEMORY[0x1E0C9C218](c);
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C220](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

uint64_t CGContextGetAlpha()
{
  return MEMORY[0x1E0C9C238]();
}

CGAffineTransform *__cdecl CGContextGetCTM(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9C250](retstr, c);
}

uint64_t CGContextGetCharacterSpacing()
{
  return MEMORY[0x1E0C9C258]();
}

uint64_t CGContextGetFillColorAsColor()
{
  return MEMORY[0x1E0C9C280]();
}

uint64_t CGContextGetFontSize()
{
  return MEMORY[0x1E0C9C298]();
}

uint64_t CGContextGetShouldDrawBitmapRuns()
{
  return MEMORY[0x1E0C9C2F0]();
}

uint64_t CGContextGetStyle()
{
  return MEMORY[0x1E0C9C300]();
}

CGAffineTransform *__cdecl CGContextGetTextMatrix(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9C308](retstr, c);
}

CGPoint CGContextGetTextPosition(CGContextRef c)
{
  double v1;
  double v2;
  CGPoint result;

  MEMORY[0x1E0C9C310](c);
  result.y = v2;
  result.x = v1;
  return result;
}

uint64_t CGContextGetType()
{
  return MEMORY[0x1E0C9C318]();
}

CGAffineTransform *__cdecl CGContextGetUserSpaceToDeviceSpaceTransform(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9C320](retstr, c);
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9C330](c, x, y);
}

void CGContextRestoreGState(CGContextRef c)
{
  MEMORY[0x1E0C9C370](c);
}

void CGContextSaveGState(CGContextRef c)
{
  MEMORY[0x1E0C9C388](c);
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  MEMORY[0x1E0C9C390](c, sx, sy);
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
  MEMORY[0x1E0C9C3B8](c, alpha);
}

void CGContextSetBlendMode(CGContextRef c, CGBlendMode mode)
{
  MEMORY[0x1E0C9C3C8](c, *(_QWORD *)&mode);
}

uint64_t CGContextSetCTM()
{
  return MEMORY[0x1E0C9C3D8]();
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x1E0C9C408](c, color);
}

void CGContextSetFont(CGContextRef c, CGFontRef font)
{
  MEMORY[0x1E0C9C420](c, font);
}

void CGContextSetFontSize(CGContextRef c, CGFloat size)
{
  MEMORY[0x1E0C9C438](c, size);
}

void CGContextSetLineDash(CGContextRef c, CGFloat phase, const CGFloat *lengths, size_t count)
{
  MEMORY[0x1E0C9C470](c, lengths, count, phase);
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
  MEMORY[0x1E0C9C480](c, width);
}

void CGContextSetShadowWithColor(CGContextRef c, CGSize offset, CGFloat blur, CGColorRef color)
{
  MEMORY[0x1E0C9C4C0](c, color, (__n128)offset, *(__n128 *)&offset.height, blur);
}

uint64_t CGContextSetShouldDrawBitmapRuns()
{
  return MEMORY[0x1E0C9C4D8]();
}

void CGContextSetShouldSubpixelQuantizeFonts(CGContextRef c, BOOL shouldSubpixelQuantizeFonts)
{
  MEMORY[0x1E0C9C4F0](c, shouldSubpixelQuantizeFonts);
}

void CGContextSetStrokeColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x1E0C9C508](c, color);
}

uint64_t CGContextSetStyle()
{
  return MEMORY[0x1E0C9C518]();
}

void CGContextSetTextDrawingMode(CGContextRef c, CGTextDrawingMode mode)
{
  MEMORY[0x1E0C9C520](c, *(_QWORD *)&mode);
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
  MEMORY[0x1E0C9C530](c, t);
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9C538](c, x, y);
}

void CGContextShowGlyphsAtPositions(CGContextRef c, const CGGlyph *glyphs, const CGPoint *Lpositions, size_t count)
{
  MEMORY[0x1E0C9C548](c, glyphs, Lpositions, count);
}

uint64_t CGContextShowGlyphsAtPositionsWithString()
{
  return MEMORY[0x1E0C9C550]();
}

void CGContextShowGlyphsWithAdvances(CGContextRef c, const CGGlyph *glyphs, const CGSize *advances, size_t count)
{
  MEMORY[0x1E0C9C558](c, glyphs, advances, count);
}

void CGContextStrokePath(CGContextRef c)
{
  MEMORY[0x1E0C9C570](c);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  MEMORY[0x1E0C9C588](c, tx, ty);
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C5F0](data);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C600](info, data, size, releaseData);
}

uint64_t CGFontCopyCharacterSet()
{
  return MEMORY[0x1E0C9C6D0]();
}

uint64_t CGFontCopyFamilyName()
{
  return MEMORY[0x1E0C9C6D8]();
}

CFStringRef CGFontCopyFullName(CGFontRef font)
{
  return (CFStringRef)MEMORY[0x1E0C9C6E0](font);
}

CFStringRef CGFontCopyGlyphNameForGlyph(CGFontRef font, CGGlyph glyph)
{
  return (CFStringRef)MEMORY[0x1E0C9C6E8](font, glyph);
}

uint64_t CGFontCopyName()
{
  return MEMORY[0x1E0C9C6F0]();
}

CFStringRef CGFontCopyPostScriptName(CGFontRef font)
{
  return (CFStringRef)MEMORY[0x1E0C9C700](font);
}

CFDataRef CGFontCopyTableForTag(CGFontRef font, uint32_t tag)
{
  return (CFDataRef)MEMORY[0x1E0C9C708](font, *(_QWORD *)&tag);
}

CFArrayRef CGFontCopyTableTags(CGFontRef font)
{
  return (CFArrayRef)MEMORY[0x1E0C9C710](font);
}

uint64_t CGFontCopyURL()
{
  return MEMORY[0x1E0C9C718]();
}

CFDictionaryRef CGFontCopyVariations(CGFontRef font)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9C720](font);
}

CGFontRef CGFontCreateCopyWithVariations(CGFontRef font, CFDictionaryRef variations)
{
  return (CGFontRef)MEMORY[0x1E0C9C728](font, variations);
}

uint64_t CGFontCreateFontsFromData()
{
  return MEMORY[0x1E0C9C730]();
}

uint64_t CGFontCreateFontsWithURL()
{
  return MEMORY[0x1E0C9C738]();
}

uint64_t CGFontCreateGlyphPath()
{
  return MEMORY[0x1E0C9C740]();
}

CGFontRef CGFontCreateWithDataProvider(CGDataProviderRef provider)
{
  return (CGFontRef)MEMORY[0x1E0C9C748](provider);
}

CGFontRef CGFontCreateWithFontName(CFStringRef name)
{
  return (CGFontRef)MEMORY[0x1E0C9C750](name);
}

uint64_t CGFontCreateWithParserFont()
{
  return MEMORY[0x1E0C9C760]();
}

uint64_t CGFontCreateWithPathAndName()
{
  return MEMORY[0x1E0C9C768]();
}

uint64_t CGFontCreateWithVariations()
{
  return MEMORY[0x1E0C9C770]();
}

uint64_t CGFontDBGetLocal()
{
  return MEMORY[0x1E0C9C790]();
}

uint64_t CGFontDBPurgeFont()
{
  return MEMORY[0x1E0C9C7A0]();
}

int CGFontGetCapHeight(CGFontRef font)
{
  return MEMORY[0x1E0C9C7C8](font);
}

CGRect CGFontGetFontBBox(CGFontRef font)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x1E0C9C7D8](font);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

uint64_t CGFontGetGlyphAdvancesForStyle()
{
  return MEMORY[0x1E0C9C7E0]();
}

BOOL CGFontGetGlyphBBoxes(CGFontRef font, const CGGlyph *glyphs, size_t count, CGRect *bboxes)
{
  return MEMORY[0x1E0C9C7E8](font, glyphs, count, bboxes);
}

uint64_t CGFontGetGlyphBBoxesForStyle()
{
  return MEMORY[0x1E0C9C7F0]();
}

uint64_t CGFontGetGlyphVerticalAdvances()
{
  return MEMORY[0x1E0C9C800]();
}

uint64_t CGFontGetGlyphVerticalOffsets()
{
  return MEMORY[0x1E0C9C808]();
}

CGGlyph CGFontGetGlyphWithGlyphName(CGFontRef font, CFStringRef name)
{
  return MEMORY[0x1E0C9C810](font, name);
}

uint64_t CGFontGetGlyphsForCIDs()
{
  return MEMORY[0x1E0C9C818]();
}

uint64_t CGFontGetGlyphsForUnichars()
{
  return MEMORY[0x1E0C9C820]();
}

uint64_t CGFontGetHMetrics()
{
  return MEMORY[0x1E0C9C828]();
}

CGFloat CGFontGetItalicAngle(CGFontRef font)
{
  CGFloat result;

  MEMORY[0x1E0C9C830](font);
  return result;
}

uint64_t CGFontGetMaxUnichars()
{
  return MEMORY[0x1E0C9C838]();
}

size_t CGFontGetNumberOfGlyphs(CGFontRef font)
{
  return MEMORY[0x1E0C9C840](font);
}

uint64_t CGFontGetParserFont()
{
  return MEMORY[0x1E0C9C848]();
}

uint64_t CGFontGetRegistryOrderingSupplement()
{
  return MEMORY[0x1E0C9C850]();
}

uint64_t CGFontGetUnderlinePosition()
{
  return MEMORY[0x1E0C9C860]();
}

uint64_t CGFontGetUnderlineThickness()
{
  return MEMORY[0x1E0C9C868]();
}

uint64_t CGFontGetUnicharsForGlyph()
{
  return MEMORY[0x1E0C9C870]();
}

int CGFontGetUnitsPerEm(CGFontRef font)
{
  return MEMORY[0x1E0C9C878](font);
}

uint64_t CGFontGetVMetrics()
{
  return MEMORY[0x1E0C9C880]();
}

uint64_t CGFontGetVariationAxes()
{
  return MEMORY[0x1E0C9C888]();
}

uint64_t CGFontGetVariations()
{
  return MEMORY[0x1E0C9C890]();
}

int CGFontGetXHeight(CGFontRef font)
{
  return MEMORY[0x1E0C9C898](font);
}

uint64_t CGFontIsBitmapOnly()
{
  return MEMORY[0x1E0C9C8A8]();
}

uint64_t CGFontIsFixedPitch()
{
  return MEMORY[0x1E0C9C8B0]();
}

uint64_t CGFontNameTableCopyLocales()
{
  return MEMORY[0x1E0C9C8B8]();
}

uint64_t CGFontNameTableCopyNameForLocaleIdentifier()
{
  return MEMORY[0x1E0C9C8C0]();
}

uint64_t CGFontNameTableCopyRootName()
{
  return MEMORY[0x1E0C9C8C8]();
}

uint64_t CGFontNameTableCreate()
{
  return MEMORY[0x1E0C9C8D0]();
}

uint64_t CGFontNameTableRelease()
{
  return MEMORY[0x1E0C9C8D8]();
}

uint64_t CGFontURLCreate()
{
  return MEMORY[0x1E0C9C8F0]();
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x1E0C9CB80](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(_QWORD *)&bitmapInfo, provider);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
  MEMORY[0x1E0CBC308](idst, image, properties);
}

void CGImageDestinationAddImageFromSource(CGImageDestinationRef idst, CGImageSourceRef isrc, size_t index, CFDictionaryRef properties)
{
  MEMORY[0x1E0CBC318](idst, isrc, index, properties);
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x1E0CBC338](data, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x1E0CBC358](idst);
}

void CGImageDestinationSetProperties(CGImageDestinationRef idst, CFDictionaryRef properties)
{
  MEMORY[0x1E0CBC368](idst, properties);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x1E0C9CBF8](image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return MEMORY[0x1E0C9CC08](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9CC20](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1E0C9CC60](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1E0C9CCD0](image);
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x1E0C9CDA0](image);
}

CGImageRef CGImageRetain(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x1E0C9CDA8](image);
}

CFDictionaryRef CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CFDictionaryRef)MEMORY[0x1E0CBC530](isrc, index, options);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x1E0CBC568](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1E0CBC590](data, options);
}

CGImageSourceRef CGImageSourceCreateWithDataProvider(CGDataProviderRef provider, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1E0CBC5A0](provider, options);
}

size_t CGImageSourceGetCount(CGImageSourceRef isrc)
{
  return MEMORY[0x1E0CBC5F0](isrc);
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D298](path, m, cp1x, cp1y, cp2x, cp2y, x, y);
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D2A8](path, m, x, y);
}

void CGPathAddPath(CGMutablePathRef path1, const CGAffineTransform *m, CGPathRef path2)
{
  MEMORY[0x1E0C9D2B8](path1, m, path2);
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D2C0](path, m, cpx, cpy, x, y);
}

void CGPathAddRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
  MEMORY[0x1E0C9D2C8](path, m, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGPathApply(CGPathRef path, void *info, CGPathApplierFunction function)
{
  MEMORY[0x1E0C9D2E8](path, info, function);
}

uint64_t CGPathApplyWithBlock2()
{
  return MEMORY[0x1E0C9D308]();
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
  MEMORY[0x1E0C9D310](path);
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return MEMORY[0x1E0C9D318](path, m, eoFill, (__n128)point, *(__n128 *)&point.y);
}

CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat lineWidth, CGLineCap lineCap, CGLineJoin lineJoin, CGFloat miterLimit)
{
  return (CGPathRef)MEMORY[0x1E0C9D348](path, transform, *(_QWORD *)&lineCap, *(_QWORD *)&lineJoin, lineWidth, miterLimit);
}

CGPathRef CGPathCreateCopyBySubtractingPath(CGPathRef path, CGPathRef maskPath, BOOL evenOddFillRule)
{
  return (CGPathRef)MEMORY[0x1E0C9D350](path, maskPath, evenOddFillRule);
}

CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x1E0C9D358](path, transform);
}

CGPathRef CGPathCreateCopyByUnioningPath(CGPathRef path, CGPathRef maskPath, BOOL evenOddFillRule)
{
  return (CGPathRef)MEMORY[0x1E0C9D360](path, maskPath, evenOddFillRule);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x1E0C9D388]();
}

CFArrayRef CGPathCreateSeparateComponents(CGPathRef path, BOOL evenOddFillRule)
{
  return (CFArrayRef)MEMORY[0x1E0C9D3A0](path, evenOddFillRule);
}

uint64_t CGPathCreateWithContinuousRoundedRect()
{
  return MEMORY[0x1E0C9D3B0]();
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x1E0C9D3C8](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x1E0C9D3F0](path);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGPathGetPathBoundingBox(CGPathRef path)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x1E0C9D410](path);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CFTypeID CGPathGetTypeID(void)
{
  return MEMORY[0x1E0C9D418]();
}

BOOL CGPathIsRect(CGPathRef path, CGRect *rect)
{
  return MEMORY[0x1E0C9D460](path, rect);
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D490](path, m, x, y);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D548](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D558]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9D560]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D580]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D588]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5A0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5D0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x1E0C9D5E8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

BOOL CGRectIntersectsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D600]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x1E0C9D608]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x1E0C9D618]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x1E0C9D620](dict, rect);
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x1E0C9D630]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D640]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

uint64_t FPFontCopyFamilyName()
{
  return MEMORY[0x1E0D22430]();
}

uint64_t FPFontCopyMetadata()
{
  return MEMORY[0x1E0D22458]();
}

uint64_t FPFontCopyPath()
{
  return MEMORY[0x1E0D22468]();
}

uint64_t FPFontCopyPostScriptName()
{
  return MEMORY[0x1E0D22470]();
}

uint64_t FPFontCreateCopyWithVariation()
{
  return MEMORY[0x1E0D22498]();
}

uint64_t FPFontCreateMemorySafeFontsFromData()
{
  return MEMORY[0x1E0D224B8]();
}

uint64_t FPFontCreateWithData()
{
  return MEMORY[0x1E0D224D0]();
}

uint64_t FPFontGetControlPoints()
{
  return MEMORY[0x1E0D224F8]();
}

uint64_t FPFontGetDefaultInstance()
{
  return MEMORY[0x1E0D22500]();
}

uint64_t FPFontGetFormat()
{
  return MEMORY[0x1E0D22510]();
}

uint64_t FPFontGetGlyphIdealAdvanceWidths()
{
  return MEMORY[0x1E0D22530]();
}

uint64_t FPFontGetGlyphsForCharacterRange()
{
  return MEMORY[0x1E0D22568]();
}

uint64_t FPFontGetGlyphsForCharacters()
{
  return MEMORY[0x1E0D22570]();
}

uint64_t FPFontGetOS2UnicodeRanges()
{
  return MEMORY[0x1E0D225A0]();
}

uint64_t FPFontGetStrikeout()
{
  return MEMORY[0x1E0D225C0]();
}

uint64_t FPFontGetTypoMetrics()
{
  return MEMORY[0x1E0D225D8]();
}

uint64_t FPFontGetVariationAxisFlags()
{
  return MEMORY[0x1E0D22608]();
}

uint64_t FPFontGetVariationAxisNameID()
{
  return MEMORY[0x1E0D22610]();
}

uint64_t FPFontGetVariationScalar()
{
  return MEMORY[0x1E0D22618]();
}

uint64_t FPFontGetVariationScalars()
{
  return MEMORY[0x1E0D22620]();
}

uint64_t FPFontGetVariationValues()
{
  return MEMORY[0x1E0D22628]();
}

uint64_t FPFontGetWinMetrics()
{
  return MEMORY[0x1E0D22630]();
}

uint64_t FPFontHasNamedInstanceWithOpticalSize()
{
  return MEMORY[0x1E0D22638]();
}

uint64_t FPFontIsNamedInstance()
{
  return MEMORY[0x1E0D22648]();
}

uint64_t FPFontIsSuitcase()
{
  return MEMORY[0x1E0D22650]();
}

uint64_t FPFontPurgeCaches()
{
  return MEMORY[0x1E0D22658]();
}

uint64_t FPFontRelease()
{
  return MEMORY[0x1E0D22660]();
}

uint64_t FSFontCopyFontNamesForFamily()
{
  return MEMORY[0x1E0D223B0]();
}

uint64_t FSFontIsHidden()
{
  return MEMORY[0x1E0D223B8]();
}

uint64_t FSFontProviderRegisterFonts()
{
  return MEMORY[0x1E0D223C0]();
}

uint64_t FSFontProviderRegisteredFontsInfo()
{
  return MEMORY[0x1E0D223C8]();
}

uint64_t FSFontProviderRequestFonts()
{
  return MEMORY[0x1E0D223D0]();
}

uint64_t FSFontProviderSynchronizeFontAsset()
{
  return MEMORY[0x1E0D223D8]();
}

uint64_t FSFontProviderUnregisterFonts()
{
  return MEMORY[0x1E0D223E0]();
}

uint64_t FSGetMaxSupportedFontAssetCompatibilityVersion()
{
  return MEMORY[0x1E0D223E8]();
}

uint64_t GSFontCacheGetData()
{
  return MEMORY[0x1E0D22760]();
}

uint64_t GSFontCopyFamilyNames()
{
  return MEMORY[0x1E0D22690]();
}

uint64_t GSFontCopyFontFilePath()
{
  return MEMORY[0x1E0D22698]();
}

uint64_t GSFontCopyNormalizedAdditionalFontName()
{
  return MEMORY[0x1E0D226B8]();
}

uint64_t GSFontGetCacheDictionary()
{
  return MEMORY[0x1E0D226D0]();
}

uint64_t GSFontInitialize()
{
  return MEMORY[0x1E0D226D8]();
}

uint64_t GSFontRegisterCGFont()
{
  return MEMORY[0x1E0D22708]();
}

uint64_t GSFontRegisterURL()
{
  return MEMORY[0x1E0D22710]();
}

uint64_t GSFontUnregisterCGFont()
{
  return MEMORY[0x1E0D22740]();
}

uint64_t GSFontUnregisterURL()
{
  return MEMORY[0x1E0D22748]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

void NSFreeMapTable(NSMapTable *table)
{
  MEMORY[0x1E0CB2B40](table);
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

void *__cdecl NSMapGet(NSMapTable *table, const void *key)
{
  return (void *)MEMORY[0x1E0CB2DA0](table, key);
}

void NSMapInsert(NSMapTable *table, const void *key, const void *value)
{
  MEMORY[0x1E0CB2DA8](table, key, value);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB3250]();
}

uint64_t OTSVGDocumentCreate()
{
  return MEMORY[0x1E0D65030]();
}

uint64_t OTSVGDocumentRelease()
{
  return MEMORY[0x1E0D65038]();
}

uint64_t OTSVGGlyphRecordingCreate()
{
  return MEMORY[0x1E0D65040]();
}

uint64_t OTSVGGlyphRecordingGetBoundingRect()
{
  return MEMORY[0x1E0D65048]();
}

uint64_t OTSVGGlyphRecordingPlaybackRecordingsAtPositions()
{
  return MEMORY[0x1E0D65050]();
}

uint64_t OTSVGGlyphRecordingRelease()
{
  return MEMORY[0x1E0D65058]();
}

uint64_t OTSVGTableCreateFromData()
{
  return MEMORY[0x1E0D65060]();
}

uint64_t OTSVGTableEnumerateGlyphs()
{
  return MEMORY[0x1E0D65068]();
}

uint64_t OTSVGTableGetDocumentIndexForGlyph()
{
  return MEMORY[0x1E0D65070]();
}

uint64_t OTSVGTableRelease()
{
  return MEMORY[0x1E0D65078]();
}

uint64_t XTCopyAvailableFontURLs()
{
  return MEMORY[0x1E0D22408]();
}

uint64_t _AXSEnhanceTextLegibilityEnabled()
{
  return MEMORY[0x1E0DDD710]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x1E0C80940](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _CFAppVersionCheckLessThan()
{
  return MEMORY[0x1E0C99EE0]();
}

uint64_t _CFCharacterSetCompact()
{
  return MEMORY[0x1E0C9A070]();
}

uint64_t _CFExecutableLinkedOnOrAfter()
{
  return MEMORY[0x1E0C9A178]();
}

uint64_t _CFIsDeallocating()
{
  return MEMORY[0x1E0C9A1D8]();
}

uint64_t _CFLocaleCopyNumberingSystemForLocaleIdentifier()
{
  return MEMORY[0x1E0C9A208]();
}

uint64_t _CFLocaleCopyPreferred()
{
  return MEMORY[0x1E0C9A210]();
}

uint64_t _CFNonObjCEqual()
{
  return MEMORY[0x1E0C9A270]();
}

uint64_t _CFNonObjCHash()
{
  return MEMORY[0x1E0C9A278]();
}

uint64_t _CFNonObjCRelease()
{
  return MEMORY[0x1E0C9A280]();
}

uint64_t _CFNonObjCRetain()
{
  return MEMORY[0x1E0C9A288]();
}

uint64_t _CFRuntimeBridgeClasses()
{
  return MEMORY[0x1E0C9A490]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1E0C9A498]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1E0C9A4B0]();
}

uint64_t _CFStringCreateTaggedPointerString()
{
  return MEMORY[0x1E0C9A500]();
}

uint64_t _CFTryRetain()
{
  return MEMORY[0x1E0C9A5A8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
  MEMORY[0x1E0DE4930](__format);
}

uint64_t std::__sort<std::__less<double,double> &,double *>()
{
  return MEMORY[0x1E0DE4AE0]();
}

uint64_t std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>()
{
  return MEMORY[0x1E0DE4B00]();
}

uint64_t std::__sort<std::__less<long,long> &,long *>()
{
  return MEMORY[0x1E0DE4B08]();
}

uint64_t std::__sort<std::__less<unsigned short,unsigned short> &,unsigned short *>()
{
  return MEMORY[0x1E0DE4B20]();
}

uint64_t operator delete[]()
{
  return off_1E15DBEC8();
}

void operator delete(void *__p)
{
  off_1E15DBED0(__p);
}

uint64_t operator delete()
{
  return off_1E15DBED8();
}

void *__cdecl operator new[](size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1E15DBEE0(__sz, a2);
}

uint64_t operator new[]()
{
  return off_1E15DBEE8();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E15DBEF0(__sz);
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1E15DBEF8(__sz, a2);
}

uint64_t operator new()
{
  return off_1E15DBF00();
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

double __exp10(double a1)
{
  double result;

  MEMORY[0x1E0C80AC8](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1E0DA88F0]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

long double acos(long double __x)
{
  long double result;

  MEMORY[0x1E0C81500](__x);
  return result;
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

long double cbrt(long double __x)
{
  long double result;

  MEMORY[0x1E0C81850](__x);
  return result;
}

id class_createInstance(Class cls, size_t extraBytes)
{
  return (id)MEMORY[0x1E0DE7A90](cls, extraBytes);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x1E0DE5270](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(_QWORD *)&algorithm);
}

size_t compression_decode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x1E0DE5278](*(_QWORD *)&algorithm);
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x1E0C82B40](__x);
  return result;
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82C18](queue, context, work);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x1E0C82D08](key);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  MEMORY[0x1E0C82E10](predicate, context, function);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  MEMORY[0x1E0C82E80](queue, key, context, destructor);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  MEMORY[0x1E0C82F08](object, queue);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x1E0C82F88](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1E0C83158]();
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C83440](__x, __y);
  return result;
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

uint8_t *__cdecl getsectiondata(const mach_header_64 *mhp, const char *segname, const char *sectname, unint64_t *size)
{
  return (uint8_t *)MEMORY[0x1E0C837E0](mhp, segname, sectname, size);
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C838E8](__x, __y);
  return result;
}

size_t malloc_good_size(size_t size)
{
  return MEMORY[0x1E0C83EB0](size);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x1E0DE7BB0](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1E0DE7BF0](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

id objc_constructInstance(Class cls, void *bytes)
{
  return (id)MEMORY[0x1E0DE7C00](cls, bytes);
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  MEMORY[0x1E0DE7C30](dest, src, size, atomic, hasStrong);
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void *__cdecl objc_destructInstance(id obj)
{
  return (void *)MEMORY[0x1E0DE7C68](obj);
}

void objc_end_catch(void)
{
  MEMORY[0x1E0DE7C80]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x1E0DE7CA8](object, key);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1E0DE7D00](location);
}

Class objc_lookUpClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7D10](name);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D20](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x1E0DE7D58]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E68](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
  MEMORY[0x1E0DE7F40](object, key, value, policy);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F90](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F98](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

void *__cdecl object_getIndexedIvars(id a1)
{
  return (void *)MEMORY[0x1E0DE8008](a1);
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1E0C849A0]();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1E0C849F8]();
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

void *__cdecl pthread_get_stackaddr_np(pthread_t a1)
{
  return (void *)MEMORY[0x1E0C84DA0](a1);
}

size_t pthread_get_stacksize_np(pthread_t a1)
{
  return MEMORY[0x1E0C84DA8](a1);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1E0C84DC0](a1);
}

uint64_t pthread_key_init_np()
{
  return MEMORY[0x1E0C84DF0]();
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1E0C84ED8]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1E0C84F18](a1, a2);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1E0C85030](__ptr, __size);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85498](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  double result;

  MEMORY[0x1E0C85620](a1, a2, a3);
  return result;
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1E0C85660](a1, a2, *(_QWORD *)&a3, a4);
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x1E0DEEB08]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x1E0DEEB18]();
}

uint64_t swift_getTypeByMangledNameInContext2()
{
  return MEMORY[0x1E0DEED38]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x1E0DEED50]();
}

uint64_t swift_release()
{
  return MEMORY[0x1E0DEEE30]();
}

uint64_t swift_retain()
{
  return MEMORY[0x1E0DEEE48]();
}

UCharDirection u_charDirection(UChar32 c)
{
  return MEMORY[0x1E0DE5960](*(_QWORD *)&c);
}

UChar32 u_charMirror(UChar32 c)
{
  return MEMORY[0x1E0DE5968](*(_QWORD *)&c);
}

int8_t u_charType(UChar32 c)
{
  return MEMORY[0x1E0DE5978](*(_QWORD *)&c);
}

UChar32 u_getBidiPairedBracket(UChar32 c)
{
  return MEMORY[0x1E0DE5998](*(_QWORD *)&c);
}

const USet *__cdecl u_getBinaryPropertySet(UProperty property, UErrorCode *pErrorCode)
{
  return (const USet *)MEMORY[0x1E0DE59A0](*(_QWORD *)&property, pErrorCode);
}

uint8_t u_getCombiningClass(UChar32 c)
{
  return MEMORY[0x1E0DE59A8](*(_QWORD *)&c);
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  return MEMORY[0x1E0DE59C0](*(_QWORD *)&c, *(_QWORD *)&which);
}

double u_getNumericValue(UChar32 c)
{
  double result;

  MEMORY[0x1E0DE59C8](*(_QWORD *)&c);
  return result;
}

UBool u_hasBinaryProperty(UChar32 c, UProperty which)
{
  return MEMORY[0x1E0DE59E0](*(_QWORD *)&c, *(_QWORD *)&which);
}

UBool u_isMirrored(UChar32 c)
{
  return MEMORY[0x1E0DE59E8](*(_QWORD *)&c);
}

UBool u_isUWhiteSpace(UChar32 c)
{
  return MEMORY[0x1E0DE5A08](*(_QWORD *)&c);
}

UBool u_isWhitespace(UChar32 c)
{
  return MEMORY[0x1E0DE5A10](*(_QWORD *)&c);
}

UBool u_isbase(UChar32 c)
{
  return MEMORY[0x1E0DE5A28](*(_QWORD *)&c);
}

uint64_t u_shapeArabic()
{
  return MEMORY[0x1E0DE5A78]();
}

UChar *__cdecl u_uastrcpy(UChar *dst, const char *src)
{
  return (UChar *)MEMORY[0x1E0DE5B28](dst, src);
}

uint64_t ubidi_close()
{
  return MEMORY[0x1E0DE5BD8]();
}

uint64_t ubidi_getLevels()
{
  return MEMORY[0x1E0DE5BF8]();
}

uint64_t ubidi_getParagraph()
{
  return MEMORY[0x1E0DE5C18]();
}

uint64_t ubidi_open()
{
  return MEMORY[0x1E0DE5C38]();
}

uint64_t ubidi_setPara()
{
  return MEMORY[0x1E0DE5C60]();
}

uint64_t ubrk_close()
{
  return MEMORY[0x1E0DE5C98]();
}

uint64_t ubrk_open()
{
  return MEMORY[0x1E0DE5CE8]();
}

uint64_t ubrk_preceding()
{
  return MEMORY[0x1E0DE5CF0]();
}

uint64_t ubrk_setUText()
{
  return MEMORY[0x1E0DE5D10]();
}

uint64_t uloc_addLikelySubtags()
{
  return MEMORY[0x1E0DE6388]();
}

uint64_t uloc_getISO3Language()
{
  return MEMORY[0x1E0DE6408]();
}

uint64_t uloc_getKeywordValue()
{
  return MEMORY[0x1E0DE6420]();
}

uint64_t uloc_getScript()
{
  return MEMORY[0x1E0DE6448]();
}

uint64_t ulocdata_close()
{
  return MEMORY[0x1E0DE6488]();
}

uint64_t ulocdata_getDelimiter()
{
  return MEMORY[0x1E0DE6498]();
}

uint64_t ulocdata_getExemplarSet()
{
  return MEMORY[0x1E0DE64A0]();
}

uint64_t ulocdata_open()
{
  return MEMORY[0x1E0DE64B0]();
}

uint64_t unorm2_composePair()
{
  return MEMORY[0x1E0DE64B8]();
}

uint64_t unorm2_getDecomposition()
{
  return MEMORY[0x1E0DE64C0]();
}

uint64_t unorm2_getNFCInstance()
{
  return MEMORY[0x1E0DE64D0]();
}

uint64_t unorm2_getNFDInstance()
{
  return MEMORY[0x1E0DE64D8]();
}

uint64_t unorm2_isNormalized()
{
  return MEMORY[0x1E0DE64F0]();
}

uint64_t unorm2_normalize()
{
  return MEMORY[0x1E0DE64F8]();
}

uint64_t uscript_getCode()
{
  return MEMORY[0x1E0DE6880]();
}

uint64_t uscript_getSampleString()
{
  return MEMORY[0x1E0DE6890]();
}

uint64_t uscript_getScript()
{
  return MEMORY[0x1E0DE6898]();
}

uint64_t uscript_getShortName()
{
  return MEMORY[0x1E0DE68A8]();
}

uint64_t uscript_hasScript()
{
  return MEMORY[0x1E0DE68B0]();
}

uint64_t uscript_isCased()
{
  return MEMORY[0x1E0DE68B8]();
}

uint64_t uset_add()
{
  return MEMORY[0x1E0DE6938]();
}

uint64_t uset_addAll()
{
  return MEMORY[0x1E0DE6940]();
}

uint64_t uset_applyIntPropertyValue()
{
  return MEMORY[0x1E0DE6960]();
}

uint64_t uset_close()
{
  return MEMORY[0x1E0DE6988]();
}

uint64_t uset_contains()
{
  return MEMORY[0x1E0DE6998]();
}

uint64_t uset_freeze()
{
  return MEMORY[0x1E0DE69A8]();
}

uint64_t uset_getItem()
{
  return MEMORY[0x1E0DE69B0]();
}

uint64_t uset_getItemCount()
{
  return MEMORY[0x1E0DE69B8]();
}

uint64_t uset_openEmpty()
{
  return MEMORY[0x1E0DE69D8]();
}

uint64_t uset_openPattern()
{
  return MEMORY[0x1E0DE69E0]();
}

uint64_t uset_size()
{
  return MEMORY[0x1E0DE6A10]();
}

UChar32 utext_char32At(UText *ut, int64_t nativeIndex)
{
  return MEMORY[0x1E0DE6A48](ut, nativeIndex);
}

UText *__cdecl utext_close(UText *ut)
{
  return (UText *)MEMORY[0x1E0DE6A50](ut);
}

int64_t utext_getNativeIndex(const UText *ut)
{
  return MEMORY[0x1E0DE6A68](ut);
}

int64_t utext_getPreviousNativeIndex(UText *ut)
{
  return MEMORY[0x1E0DE6A70](ut);
}

UChar32 utext_next32(UText *ut)
{
  return MEMORY[0x1E0DE6A88](ut);
}

UText *__cdecl utext_openUChars(UText *ut, const UChar *s, int64_t length, UErrorCode *status)
{
  return (UText *)MEMORY[0x1E0DE6A90](ut, s, length, status);
}

UChar32 utext_previous32(UText *ut)
{
  return MEMORY[0x1E0DE6AA0](ut);
}

void utext_setNativeIndex(UText *ut, int64_t nativeIndex)
{
  MEMORY[0x1E0DE6AA8](ut, nativeIndex);
}

UText *__cdecl utext_setup(UText *ut, int32_t extraSpace, UErrorCode *status)
{
  return (UText *)MEMORY[0x1E0DE6AB0](ut, *(_QWORD *)&extraSpace, status);
}

void vDSP_sveD(const double *__A, vDSP_Stride __I, double *__C, vDSP_Length __N)
{
  MEMORY[0x1E0C8C2F8](__A, __I, __C, __N);
}

void vDSP_vsmulD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
  MEMORY[0x1E0C8C8E8](__A, __IA, __B, __C, __IC, __N);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1E0C85CB8](__s, *(_QWORD *)&__c, __n);
}

uint64_t CEMStringIsSingleEmoji_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreEmoji))
    dlopenHelper_CoreEmoji(a1);
  return MEMORY[0x1E0D15DD0]();
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_InternationalSupport(double a1)
{
  dlopen("/System/Library/PrivateFrameworks/InternationalSupport.framework/InternationalSupport", 0);
  atomic_store(1u, (unsigned int *)&dlopenHelperFlag_InternationalSupport);
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_CoreEmoji(double a1)
{
  dlopen("/System/Library/PrivateFrameworks/CoreEmoji.framework/CoreEmoji", 0);
  atomic_store(1u, &dlopenHelperFlag_CoreEmoji);
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_MobileAsset(double a1)
{
  dlopen("/System/Library/PrivateFrameworks/MobileAsset.framework/MobileAsset", 0);
  atomic_store(1u, (unsigned int *)&dlopenHelperFlag_MobileAsset);
  return a1;
}

double gotLoadHelper_x8__InternationalSupportVersionNumber(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_InternationalSupport))
    return dlopenHelper_InternationalSupport(result);
  return result;
}

double gotLoadHelper_x8__CEMStringIsSingleEmoji(double result)
{
  if (!atomic_load(&dlopenHelperFlag_CoreEmoji))
    return dlopenHelper_CoreEmoji(result);
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___MAAsset(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    return dlopenHelper_MobileAsset(result);
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___MADownloadOptions(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    return dlopenHelper_MobileAsset(result);
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___MAAssetQuery(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    return dlopenHelper_MobileAsset(result);
  return result;
}

void gotLoadHelper_x27__ASAttributeDownloadSize(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    dlopenHelper_MobileAsset(a1);
}

double gotLoadHelper_x8__ASDownloadPriorityHigh(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    return dlopenHelper_MobileAsset(result);
  return result;
}

double gotLoadHelper_x8__ASDownloadOptionPriority(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    return dlopenHelper_MobileAsset(result);
  return result;
}

double gotLoadHelper_x8__ASDownloadOptionAllowBatteryPower(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    return dlopenHelper_MobileAsset(result);
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___ASAsset(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_MobileAsset))
    return dlopenHelper_MobileAsset(result);
  return result;
}

